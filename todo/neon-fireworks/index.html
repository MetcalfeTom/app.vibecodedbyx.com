<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Neon Fireworks</title>
  <link rel="icon" href="https://emojicdn.elk.sh/âœ¨">
  <meta name="description" content="Interactive neon fireworks that follow your cursor.">
  <meta property="og:title" content="Neon Fireworks">
  <meta property="og:description" content="Click and move to paint the night with glowing explosions.">
  <meta property="og:url" content="https://sloppy.live/neon-fireworks">
  <meta property="og:image" content="https://sloppy.live/neon-fireworks/og-image.png">
  <meta property="og:type" content="website">
  <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700&display=swap" rel="stylesheet">
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }
    body {
      background: #000;
      overflow: hidden;
      cursor: crosshair;
      font-family: 'Orbitron', monospace;
    }
    canvas {
      display: block;
    }
    .hint {
      position: fixed;
      bottom: 30px;
      left: 50%;
      transform: translateX(-50%);
      color: rgba(255, 255, 255, 0.4);
      font-size: 12px;
      letter-spacing: 2px;
      text-transform: uppercase;
      pointer-events: none;
      transition: opacity 0.5s;
      text-shadow: 0 0 10px rgba(255, 255, 255, 0.3);
    }
    .hint.hidden {
      opacity: 0;
    }
    .backlink {
      position: fixed;
      bottom: 15px;
      right: 20px;
      color: rgba(255, 255, 255, 0.3);
      font-size: 10px;
      text-decoration: none;
      letter-spacing: 1px;
      z-index: 10;
    }
    .backlink:hover {
      color: rgba(255, 255, 255, 0.6);
    }
  </style>
</head>
<body>
  <canvas id="canvas"></canvas>
  <div class="hint" id="hint">Click & move to ignite</div>
  <a href="https://sloppy.live" class="backlink">sloppy.live</a>

  <script>
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    const hint = document.getElementById('hint');

    let width, height;
    let mouseX = 0, mouseY = 0;
    let isMouseDown = false;
    let hasInteracted = false;

    // Neon color palettes
    const palettes = [
      ['#ff00ff', '#ff66ff', '#cc00cc'], // Magenta
      ['#00ffff', '#66ffff', '#00cccc'], // Cyan
      ['#ff0066', '#ff3399', '#cc0052'], // Hot pink
      ['#00ff66', '#66ff99', '#00cc52'], // Neon green
      ['#ffff00', '#ffff66', '#cccc00'], // Yellow
      ['#ff6600', '#ff9933', '#cc5200'], // Orange
      ['#6600ff', '#9933ff', '#5200cc'], // Purple
      ['#00ff00', '#66ff66', '#00cc00'], // Lime
    ];

    function resize() {
      width = canvas.width = window.innerWidth;
      height = canvas.height = window.innerHeight;
    }
    resize();
    window.addEventListener('resize', resize);

    // Particle class
    class Particle {
      constructor(x, y, color, velocity, size, life) {
        this.x = x;
        this.y = y;
        this.color = color;
        this.vx = velocity.x;
        this.vy = velocity.y;
        this.size = size;
        this.life = life;
        this.maxLife = life;
        this.gravity = 0.03;
        this.friction = 0.99;
      }

      update() {
        this.vx *= this.friction;
        this.vy *= this.friction;
        this.vy += this.gravity;
        this.x += this.vx;
        this.y += this.vy;
        this.life--;
      }

      draw() {
        const alpha = this.life / this.maxLife;
        const size = this.size * alpha;

        ctx.save();
        ctx.globalAlpha = alpha;

        // Outer glow
        ctx.shadowBlur = 20;
        ctx.shadowColor = this.color;

        ctx.beginPath();
        ctx.arc(this.x, this.y, size, 0, Math.PI * 2);
        ctx.fillStyle = this.color;
        ctx.fill();

        // Inner bright core
        ctx.beginPath();
        ctx.arc(this.x, this.y, size * 0.5, 0, Math.PI * 2);
        ctx.fillStyle = '#fff';
        ctx.fill();

        ctx.restore();
      }

      isDead() {
        return this.life <= 0;
      }
    }

    // Trail particle (follows mouse)
    class TrailParticle {
      constructor(x, y, color) {
        this.x = x;
        this.y = y;
        this.color = color;
        this.size = 3 + Math.random() * 3;
        this.life = 30 + Math.random() * 20;
        this.maxLife = this.life;
        this.vx = (Math.random() - 0.5) * 2;
        this.vy = (Math.random() - 0.5) * 2 - 1;
      }

      update() {
        this.x += this.vx;
        this.y += this.vy;
        this.vy += 0.05;
        this.life--;
      }

      draw() {
        const alpha = this.life / this.maxLife;
        ctx.save();
        ctx.globalAlpha = alpha * 0.8;
        ctx.shadowBlur = 15;
        ctx.shadowColor = this.color;
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.size * alpha, 0, Math.PI * 2);
        ctx.fillStyle = this.color;
        ctx.fill();
        ctx.restore();
      }

      isDead() {
        return this.life <= 0;
      }
    }

    // Firework class
    class Firework {
      constructor(x, y, targetX, targetY) {
        this.x = x;
        this.y = y;
        this.targetX = targetX;
        this.targetY = targetY;

        const angle = Math.atan2(targetY - y, targetX - x);
        const speed = 8 + Math.random() * 4;
        this.vx = Math.cos(angle) * speed;
        this.vy = Math.sin(angle) * speed;

        this.palette = palettes[Math.floor(Math.random() * palettes.length)];
        this.color = this.palette[0];
        this.trail = [];
        this.exploded = false;
      }

      update() {
        if (this.exploded) return true;

        // Add trail
        this.trail.push({ x: this.x, y: this.y, alpha: 1 });
        if (this.trail.length > 10) this.trail.shift();

        this.x += this.vx;
        this.y += this.vy;
        this.vy += 0.05;

        // Check if reached target or going back down
        const distToTarget = Math.hypot(this.targetX - this.x, this.targetY - this.y);
        if (distToTarget < 20 || this.vy > 0) {
          this.explode();
          return true;
        }

        return false;
      }

      draw() {
        if (this.exploded) return;

        // Draw trail
        this.trail.forEach((point, i) => {
          const alpha = (i / this.trail.length) * 0.5;
          ctx.save();
          ctx.globalAlpha = alpha;
          ctx.shadowBlur = 10;
          ctx.shadowColor = this.color;
          ctx.beginPath();
          ctx.arc(point.x, point.y, 2, 0, Math.PI * 2);
          ctx.fillStyle = this.color;
          ctx.fill();
          ctx.restore();
        });

        // Draw head
        ctx.save();
        ctx.shadowBlur = 20;
        ctx.shadowColor = this.color;
        ctx.beginPath();
        ctx.arc(this.x, this.y, 4, 0, Math.PI * 2);
        ctx.fillStyle = '#fff';
        ctx.fill();
        ctx.restore();
      }

      explode() {
        this.exploded = true;
        const particleCount = 60 + Math.floor(Math.random() * 40);

        for (let i = 0; i < particleCount; i++) {
          const angle = (Math.PI * 2 * i) / particleCount + Math.random() * 0.2;
          const speed = 2 + Math.random() * 4;
          const color = this.palette[Math.floor(Math.random() * this.palette.length)];

          particles.push(new Particle(
            this.x,
            this.y,
            color,
            { x: Math.cos(angle) * speed, y: Math.sin(angle) * speed },
            2 + Math.random() * 3,
            60 + Math.random() * 40
          ));
        }

        // Add some sparkles
        for (let i = 0; i < 20; i++) {
          const angle = Math.random() * Math.PI * 2;
          const speed = 1 + Math.random() * 2;

          particles.push(new Particle(
            this.x,
            this.y,
            '#ffffff',
            { x: Math.cos(angle) * speed, y: Math.sin(angle) * speed },
            1 + Math.random(),
            30 + Math.random() * 20
          ));
        }
      }
    }

    let particles = [];
    let trailParticles = [];
    let fireworks = [];
    let lastTrailTime = 0;
    let autoLaunchTime = 0;

    // Mouse events
    canvas.addEventListener('mousedown', (e) => {
      isMouseDown = true;
      hideHint();
      launchFirework(e.clientX, e.clientY);
    });

    canvas.addEventListener('mouseup', () => {
      isMouseDown = false;
    });

    canvas.addEventListener('mousemove', (e) => {
      mouseX = e.clientX;
      mouseY = e.clientY;

      if (isMouseDown) {
        hideHint();
        // Spawn trail particles
        const now = Date.now();
        if (now - lastTrailTime > 30) {
          const palette = palettes[Math.floor(Math.random() * palettes.length)];
          for (let i = 0; i < 3; i++) {
            trailParticles.push(new TrailParticle(
              mouseX + (Math.random() - 0.5) * 10,
              mouseY + (Math.random() - 0.5) * 10,
              palette[Math.floor(Math.random() * palette.length)]
            ));
          }
          lastTrailTime = now;
        }

        // Occasionally launch firework toward mouse
        if (Math.random() < 0.05) {
          launchFirework(mouseX, mouseY);
        }
      }
    });

    // Touch events
    canvas.addEventListener('touchstart', (e) => {
      e.preventDefault();
      isMouseDown = true;
      hideHint();
      const touch = e.touches[0];
      mouseX = touch.clientX;
      mouseY = touch.clientY;
      launchFirework(mouseX, mouseY);
    });

    canvas.addEventListener('touchmove', (e) => {
      e.preventDefault();
      const touch = e.touches[0];
      mouseX = touch.clientX;
      mouseY = touch.clientY;

      const now = Date.now();
      if (now - lastTrailTime > 30) {
        const palette = palettes[Math.floor(Math.random() * palettes.length)];
        for (let i = 0; i < 3; i++) {
          trailParticles.push(new TrailParticle(
            mouseX + (Math.random() - 0.5) * 10,
            mouseY + (Math.random() - 0.5) * 10,
            palette[Math.floor(Math.random() * palette.length)]
          ));
        }
        lastTrailTime = now;
      }

      if (Math.random() < 0.08) {
        launchFirework(mouseX, mouseY);
      }
    });

    canvas.addEventListener('touchend', () => {
      isMouseDown = false;
    });

    function hideHint() {
      if (!hasInteracted) {
        hasInteracted = true;
        hint.classList.add('hidden');
      }
    }

    function launchFirework(targetX, targetY) {
      const startX = Math.random() * width;
      const startY = height + 10;
      fireworks.push(new Firework(startX, startY, targetX, targetY));
    }

    // Auto-launch fireworks periodically for ambiance
    function autoLaunch() {
      if (!isMouseDown && Math.random() < 0.02) {
        const targetX = Math.random() * width;
        const targetY = 100 + Math.random() * (height * 0.4);
        launchFirework(targetX, targetY);
      }
    }

    function animate() {
      // Fade effect for trails
      ctx.fillStyle = 'rgba(0, 0, 0, 0.1)';
      ctx.fillRect(0, 0, width, height);

      // Auto launch
      autoLaunch();

      // Update and draw fireworks
      fireworks = fireworks.filter(fw => !fw.update());
      fireworks.forEach(fw => fw.draw());

      // Update and draw particles
      particles = particles.filter(p => {
        p.update();
        if (!p.isDead()) {
          p.draw();
          return true;
        }
        return false;
      });

      // Update and draw trail particles
      trailParticles = trailParticles.filter(p => {
        p.update();
        if (!p.isDead()) {
          p.draw();
          return true;
        }
        return false;
      });

      requestAnimationFrame(animate);
    }

    // Initial fireworks
    setTimeout(() => {
      for (let i = 0; i < 3; i++) {
        setTimeout(() => {
          launchFirework(
            width * 0.3 + Math.random() * width * 0.4,
            height * 0.2 + Math.random() * height * 0.3
          );
        }, i * 300);
      }
    }, 500);

    animate();
  </script>
</body>
</html>
