<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Cube Escape</title>
  <link rel="icon" href="https://emojicdn.elk.sh/üü¶">
  <meta property="og:title" content="Cube Escape">
  <meta property="og:description" content="Dodge falling spreadsheets and Trello cards!">
  <meta property="og:url" content="https://app.sloppy.live/cube-escape">
  <meta property="og:image" content="https://emojicdn.elk.sh/üü¶?style=apple&size=512">
  <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&family=Share+Tech+Mono&display=swap" rel="stylesheet">
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }

    body {
      background: #0a0a12;
      overflow: hidden;
      height: 100vh;
      font-family: 'Orbitron', sans-serif;
      cursor: none;
    }

    canvas {
      display: block;
    }

    .ui {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      padding: 20px 30px;
      display: flex;
      justify-content: space-between;
      align-items: flex-start;
      pointer-events: none;
      z-index: 10;
    }

    .score-panel {
      background: rgba(0, 0, 0, 0.5);
      border: 2px solid #00ffff;
      border-radius: 10px;
      padding: 15px 25px;
      box-shadow: 0 0 20px rgba(0, 255, 255, 0.3);
    }

    .score-label {
      font-size: 0.7rem;
      color: #00ffff;
      letter-spacing: 2px;
      margin-bottom: 5px;
    }

    .score-value {
      font-size: 2rem;
      font-weight: 900;
      color: #fff;
      text-shadow: 0 0 20px #00ffff;
    }

    .stats-panel {
      display: flex;
      gap: 20px;
    }

    .stat {
      background: rgba(0, 0, 0, 0.5);
      border: 2px solid #ff00ff;
      border-radius: 10px;
      padding: 10px 20px;
      text-align: center;
      box-shadow: 0 0 15px rgba(255, 0, 255, 0.3);
    }

    .stat-label {
      font-size: 0.6rem;
      color: #ff00ff;
      letter-spacing: 1px;
    }

    .stat-value {
      font-size: 1.2rem;
      font-weight: 700;
      color: #fff;
      text-shadow: 0 0 10px #ff00ff;
    }

    /* Game Over Screen */
    .game-over {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.9);
      display: none;
      justify-content: center;
      align-items: center;
      z-index: 100;
      flex-direction: column;
      gap: 30px;
    }

    .game-over.active {
      display: flex;
      animation: fadeIn 0.5s ease;
    }

    @keyframes fadeIn {
      from { opacity: 0; }
      to { opacity: 1; }
    }

    .game-over h1 {
      font-size: 4rem;
      font-weight: 900;
      color: #ff3366;
      text-shadow: 0 0 30px #ff3366, 0 0 60px #ff3366;
      letter-spacing: 5px;
      animation: glitch 0.5s ease-in-out infinite;
    }

    @keyframes glitch {
      0%, 100% { transform: translate(0); }
      20% { transform: translate(-2px, 2px); }
      40% { transform: translate(2px, -2px); }
      60% { transform: translate(-2px, -2px); }
      80% { transform: translate(2px, 2px); }
    }

    .final-score {
      text-align: center;
    }

    .final-score-label {
      font-size: 1rem;
      color: #00ffff;
      letter-spacing: 3px;
      margin-bottom: 10px;
    }

    .final-score-value {
      font-size: 5rem;
      font-weight: 900;
      color: #fff;
      text-shadow: 0 0 30px #00ffff;
    }

    .restart-btn {
      background: linear-gradient(135deg, #00ffff, #ff00ff);
      border: none;
      padding: 15px 50px;
      border-radius: 30px;
      font-family: 'Orbitron', sans-serif;
      font-size: 1.2rem;
      font-weight: 700;
      color: #000;
      cursor: pointer;
      letter-spacing: 2px;
      transition: all 0.3s;
      pointer-events: auto;
    }

    .restart-btn:hover {
      transform: scale(1.1);
      box-shadow: 0 0 30px rgba(0, 255, 255, 0.5), 0 0 30px rgba(255, 0, 255, 0.5);
    }

    /* Start Screen */
    .start-screen {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.95);
      display: flex;
      justify-content: center;
      align-items: center;
      z-index: 100;
      flex-direction: column;
      gap: 40px;
    }

    .start-screen.hidden {
      display: none;
    }

    .start-screen h1 {
      font-size: 3.5rem;
      font-weight: 900;
      background: linear-gradient(90deg, #00ffff, #ff00ff, #00ffff);
      background-size: 200% auto;
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
      animation: gradient-shift 3s linear infinite;
      letter-spacing: 5px;
    }

    @keyframes gradient-shift {
      0% { background-position: 0% center; }
      100% { background-position: 200% center; }
    }

    .start-screen p {
      color: #888;
      font-size: 1rem;
      text-align: center;
      max-width: 400px;
      line-height: 1.8;
    }

    .controls-hint {
      display: flex;
      gap: 30px;
      color: #666;
      font-size: 0.85rem;
    }

    .control-key {
      display: flex;
      align-items: center;
      gap: 10px;
    }

    .key {
      background: #222;
      border: 2px solid #444;
      border-radius: 8px;
      padding: 8px 15px;
      font-family: 'Share Tech Mono', monospace;
      color: #00ffff;
    }

    .start-btn {
      background: linear-gradient(135deg, #00ffff, #ff00ff);
      border: none;
      padding: 20px 60px;
      border-radius: 30px;
      font-family: 'Orbitron', sans-serif;
      font-size: 1.3rem;
      font-weight: 700;
      color: #000;
      cursor: pointer;
      letter-spacing: 3px;
      transition: all 0.3s;
      animation: pulse-btn 2s ease-in-out infinite;
    }

    @keyframes pulse-btn {
      0%, 100% { box-shadow: 0 0 20px rgba(0, 255, 255, 0.5); }
      50% { box-shadow: 0 0 40px rgba(255, 0, 255, 0.5); }
    }

    .start-btn:hover {
      transform: scale(1.1);
    }

    .back-link {
      position: fixed;
      bottom: 15px;
      right: 15px;
      color: #444;
      text-decoration: none;
      font-size: 0.75rem;
      z-index: 50;
      font-family: 'Share Tech Mono', monospace;
    }

    .back-link:hover {
      color: #00ffff;
    }

    /* Mobile controls */
    .mobile-controls {
      display: none;
      position: fixed;
      bottom: 30px;
      left: 50%;
      transform: translateX(-50%);
      gap: 20px;
      z-index: 50;
    }

    @media (max-width: 768px) {
      .mobile-controls {
        display: flex;
      }
      .controls-hint {
        display: none;
      }
    }

    .mobile-btn {
      width: 70px;
      height: 70px;
      background: rgba(0, 255, 255, 0.2);
      border: 2px solid #00ffff;
      border-radius: 50%;
      color: #00ffff;
      font-size: 2rem;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      -webkit-tap-highlight-color: transparent;
    }

    .mobile-btn:active {
      background: rgba(0, 255, 255, 0.4);
    }
  </style>
</head>
<body>
  <canvas id="game"></canvas>

  <div class="ui">
    <div class="score-panel">
      <div class="score-label">SCORE</div>
      <div class="score-value" id="score">0</div>
    </div>
    <div class="stats-panel">
      <div class="stat">
        <div class="stat-label">LEVEL</div>
        <div class="stat-value" id="level">1</div>
      </div>
      <div class="stat">
        <div class="stat-label">DODGED</div>
        <div class="stat-value" id="dodged">0</div>
      </div>
    </div>
  </div>

  <div class="start-screen" id="start-screen">
    <h1>CUBE ESCAPE</h1>
    <p>Dodge the falling spreadsheets and Trello cards! Don't let productivity catch you!</p>
    <div class="controls-hint">
      <div class="control-key"><span class="key">‚Üê</span> Left</div>
      <div class="control-key"><span class="key">‚Üí</span> Right</div>
      <div class="control-key"><span class="key">MOUSE</span> Move</div>
    </div>
    <button class="start-btn" onclick="startGame()">START</button>
  </div>

  <div class="game-over" id="game-over">
    <h1>GAME OVER</h1>
    <div class="final-score">
      <div class="final-score-label">FINAL SCORE</div>
      <div class="final-score-value" id="final-score">0</div>
    </div>
    <button class="restart-btn" onclick="restartGame()">PLAY AGAIN</button>
  </div>

  <div class="mobile-controls" id="mobile-controls">
    <button class="mobile-btn" id="left-btn">‚Üê</button>
    <button class="mobile-btn" id="right-btn">‚Üí</button>
  </div>

  <a href="https://sloppy.live" class="back-link">‚Üê sloppy.live</a>

  <script>
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');

    let width, height;
    let gameRunning = false;
    let score = 0;
    let level = 1;
    let dodged = 0;
    let time = 0;

    // Player
    const player = {
      x: 0,
      y: 0,
      size: 40,
      speed: 8,
      glowIntensity: 0,
      trail: []
    };

    // Obstacles
    let obstacles = [];
    let particles = [];

    // Input
    let keys = { left: false, right: false };
    let mouseX = null;
    let mobileLeft = false;
    let mobileRight = false;

    // Obstacle types
    const obstacleTypes = [
      {
        name: 'spreadsheet',
        color: '#0f9d58',
        borderColor: '#00ff88',
        width: 80,
        height: 60,
        draw: (ctx, x, y, w, h, glow) => {
          // Sheet background
          ctx.fillStyle = '#1a3a2a';
          ctx.shadowColor = '#0f9d58';
          ctx.shadowBlur = glow;
          ctx.fillRect(x, y, w, h);
          ctx.shadowBlur = 0;

          // Border
          ctx.strokeStyle = '#0f9d58';
          ctx.lineWidth = 2;
          ctx.strokeRect(x, y, w, h);

          // Grid lines
          ctx.strokeStyle = 'rgba(15, 157, 88, 0.5)';
          ctx.lineWidth = 1;
          const cols = 4;
          const rows = 3;
          for (let i = 1; i < cols; i++) {
            ctx.beginPath();
            ctx.moveTo(x + (w / cols) * i, y);
            ctx.lineTo(x + (w / cols) * i, y + h);
            ctx.stroke();
          }
          for (let i = 1; i < rows; i++) {
            ctx.beginPath();
            ctx.moveTo(x, y + (h / rows) * i);
            ctx.lineTo(x + w, y + (h / rows) * i);
            ctx.stroke();
          }

          // Label
          ctx.fillStyle = '#0f9d58';
          ctx.font = '10px Share Tech Mono';
          ctx.textAlign = 'center';
          ctx.fillText('XLSX', x + w / 2, y + h / 2 + 3);
        }
      },
      {
        name: 'trello',
        color: '#0079bf',
        borderColor: '#00d4ff',
        width: 70,
        height: 90,
        draw: (ctx, x, y, w, h, glow) => {
          // Card background
          ctx.fillStyle = '#0a2a3a';
          ctx.shadowColor = '#0079bf';
          ctx.shadowBlur = glow;
          roundRect(ctx, x, y, w, h, 8);
          ctx.fill();
          ctx.shadowBlur = 0;

          // Border
          ctx.strokeStyle = '#0079bf';
          ctx.lineWidth = 2;
          roundRect(ctx, x, y, w, h, 8);
          ctx.stroke();

          // Header stripe
          ctx.fillStyle = '#0079bf';
          ctx.fillRect(x + 5, y + 5, w - 10, 15);

          // Fake text lines
          ctx.fillStyle = 'rgba(0, 121, 191, 0.5)';
          ctx.fillRect(x + 8, y + 28, w - 16, 6);
          ctx.fillRect(x + 8, y + 40, w - 30, 6);
          ctx.fillRect(x + 8, y + 52, w - 20, 6);

          // Checkbox
          ctx.strokeStyle = '#0079bf';
          ctx.lineWidth = 1;
          ctx.strokeRect(x + 8, y + h - 20, 10, 10);
        }
      },
      {
        name: 'excel',
        color: '#217346',
        borderColor: '#00ff66',
        width: 70,
        height: 55,
        draw: (ctx, x, y, w, h, glow) => {
          // Background
          ctx.fillStyle = '#0a2a1a';
          ctx.shadowColor = '#217346';
          ctx.shadowBlur = glow;
          ctx.fillRect(x, y, w, h);
          ctx.shadowBlur = 0;

          // Border
          ctx.strokeStyle = '#217346';
          ctx.lineWidth = 2;
          ctx.strokeRect(x, y, w, h);

          // X logo
          ctx.fillStyle = '#217346';
          ctx.font = 'bold 24px Arial';
          ctx.textAlign = 'center';
          ctx.textBaseline = 'middle';
          ctx.fillText('X', x + w / 2, y + h / 2);
        }
      },
      {
        name: 'notion',
        color: '#ffffff',
        borderColor: '#aaaaaa',
        width: 65,
        height: 75,
        draw: (ctx, x, y, w, h, glow) => {
          // Background
          ctx.fillStyle = '#1a1a1a';
          ctx.shadowColor = '#ffffff';
          ctx.shadowBlur = glow * 0.5;
          roundRect(ctx, x, y, w, h, 6);
          ctx.fill();
          ctx.shadowBlur = 0;

          // Border
          ctx.strokeStyle = '#444';
          ctx.lineWidth = 2;
          roundRect(ctx, x, y, w, h, 6);
          ctx.stroke();

          // N logo
          ctx.fillStyle = '#fff';
          ctx.font = 'bold 20px serif';
          ctx.textAlign = 'center';
          ctx.textBaseline = 'middle';
          ctx.fillText('N', x + w / 2, y + 25);

          // Lines
          ctx.fillStyle = 'rgba(255, 255, 255, 0.3)';
          ctx.fillRect(x + 8, y + 45, w - 16, 4);
          ctx.fillRect(x + 8, y + 55, w - 25, 4);
        }
      },
      {
        name: 'jira',
        color: '#0052cc',
        borderColor: '#4488ff',
        width: 60,
        height: 60,
        draw: (ctx, x, y, w, h, glow) => {
          // Background
          ctx.fillStyle = '#0a1a3a';
          ctx.shadowColor = '#0052cc';
          ctx.shadowBlur = glow;
          roundRect(ctx, x, y, w, h, 8);
          ctx.fill();
          ctx.shadowBlur = 0;

          // Border
          ctx.strokeStyle = '#0052cc';
          ctx.lineWidth = 2;
          roundRect(ctx, x, y, w, h, 8);
          ctx.stroke();

          // Jira-like icon
          ctx.fillStyle = '#0052cc';
          ctx.beginPath();
          ctx.moveTo(x + w / 2, y + 15);
          ctx.lineTo(x + w - 15, y + h / 2);
          ctx.lineTo(x + w / 2, y + h - 15);
          ctx.lineTo(x + 15, y + h / 2);
          ctx.closePath();
          ctx.fill();
        }
      }
    ];

    function roundRect(ctx, x, y, w, h, r) {
      ctx.beginPath();
      ctx.moveTo(x + r, y);
      ctx.lineTo(x + w - r, y);
      ctx.quadraticCurveTo(x + w, y, x + w, y + r);
      ctx.lineTo(x + w, y + h - r);
      ctx.quadraticCurveTo(x + w, y + h, x + w - r, y + h);
      ctx.lineTo(x + r, y + h);
      ctx.quadraticCurveTo(x, y + h, x, y + h - r);
      ctx.lineTo(x, y + r);
      ctx.quadraticCurveTo(x, y, x + r, y);
      ctx.closePath();
    }

    function resize() {
      width = canvas.width = window.innerWidth;
      height = canvas.height = window.innerHeight;
      player.y = height - 100;
      if (player.x === 0) player.x = width / 2;
    }

    function spawnObstacle() {
      const type = obstacleTypes[Math.floor(Math.random() * obstacleTypes.length)];
      const x = Math.random() * (width - type.width);

      obstacles.push({
        type,
        x,
        y: -type.height,
        speed: 3 + level * 0.5 + Math.random() * 2,
        rotation: (Math.random() - 0.5) * 0.02,
        angle: 0,
        glow: 15
      });
    }

    function spawnParticle(x, y, color) {
      for (let i = 0; i < 10; i++) {
        particles.push({
          x,
          y,
          vx: (Math.random() - 0.5) * 10,
          vy: (Math.random() - 0.5) * 10,
          life: 1,
          color,
          size: Math.random() * 5 + 2
        });
      }
    }

    function updatePlayer() {
      // Keyboard input
      if (keys.left || mobileLeft) {
        player.x -= player.speed;
      }
      if (keys.right || mobileRight) {
        player.x += player.speed;
      }

      // Mouse input
      if (mouseX !== null) {
        const diff = mouseX - player.x;
        player.x += diff * 0.15;
      }

      // Boundaries
      player.x = Math.max(player.size / 2, Math.min(width - player.size / 2, player.x));

      // Trail
      player.trail.unshift({ x: player.x, y: player.y });
      if (player.trail.length > 15) player.trail.pop();

      // Glow pulse
      player.glowIntensity = 20 + Math.sin(time * 0.1) * 10;
    }

    function updateObstacles() {
      for (let i = obstacles.length - 1; i >= 0; i--) {
        const obs = obstacles[i];
        obs.y += obs.speed;
        obs.angle += obs.rotation;
        obs.glow = 15 + Math.sin(time * 0.15 + i) * 5;

        // Check collision
        const playerLeft = player.x - player.size / 2;
        const playerRight = player.x + player.size / 2;
        const playerTop = player.y - player.size / 2;
        const playerBottom = player.y + player.size / 2;

        const obsLeft = obs.x;
        const obsRight = obs.x + obs.type.width;
        const obsTop = obs.y;
        const obsBottom = obs.y + obs.type.height;

        if (playerRight > obsLeft && playerLeft < obsRight &&
            playerBottom > obsTop && playerTop < obsBottom) {
          gameOver();
          return;
        }

        // Remove if off screen
        if (obs.y > height + 100) {
          obstacles.splice(i, 1);
          score += 10 * level;
          dodged++;
          updateUI();
        }
      }
    }

    function updateParticles() {
      for (let i = particles.length - 1; i >= 0; i--) {
        const p = particles[i];
        p.x += p.vx;
        p.y += p.vy;
        p.vy += 0.3;
        p.life -= 0.02;

        if (p.life <= 0) {
          particles.splice(i, 1);
        }
      }
    }

    function drawPlayer() {
      // Trail
      player.trail.forEach((pos, i) => {
        const alpha = (1 - i / player.trail.length) * 0.3;
        const size = player.size * (1 - i / player.trail.length * 0.5);

        ctx.fillStyle = `rgba(0, 255, 255, ${alpha})`;
        ctx.shadowColor = '#00ffff';
        ctx.shadowBlur = 10;
        ctx.fillRect(pos.x - size / 2, pos.y - size / 2, size, size);
      });

      // Main cube
      ctx.shadowColor = '#00ffff';
      ctx.shadowBlur = player.glowIntensity;

      // Outer glow
      ctx.fillStyle = 'rgba(0, 255, 255, 0.3)';
      ctx.fillRect(
        player.x - player.size / 2 - 5,
        player.y - player.size / 2 - 5,
        player.size + 10,
        player.size + 10
      );

      // Main cube
      const gradient = ctx.createLinearGradient(
        player.x - player.size / 2,
        player.y - player.size / 2,
        player.x + player.size / 2,
        player.y + player.size / 2
      );
      gradient.addColorStop(0, '#00ffff');
      gradient.addColorStop(1, '#ff00ff');

      ctx.fillStyle = gradient;
      ctx.fillRect(
        player.x - player.size / 2,
        player.y - player.size / 2,
        player.size,
        player.size
      );

      // Inner highlight
      ctx.fillStyle = 'rgba(255, 255, 255, 0.5)';
      ctx.fillRect(
        player.x - player.size / 2 + 5,
        player.y - player.size / 2 + 5,
        player.size / 3,
        player.size / 3
      );

      ctx.shadowBlur = 0;
    }

    function drawObstacles() {
      obstacles.forEach(obs => {
        ctx.save();
        ctx.translate(obs.x + obs.type.width / 2, obs.y + obs.type.height / 2);
        ctx.rotate(obs.angle);
        ctx.translate(-obs.type.width / 2, -obs.type.height / 2);

        obs.type.draw(ctx, 0, 0, obs.type.width, obs.type.height, obs.glow);

        ctx.restore();
      });
    }

    function drawParticles() {
      particles.forEach(p => {
        ctx.fillStyle = p.color;
        ctx.globalAlpha = p.life;
        ctx.fillRect(p.x - p.size / 2, p.y - p.size / 2, p.size, p.size);
      });
      ctx.globalAlpha = 1;
    }

    function drawBackground() {
      // Grid
      ctx.strokeStyle = 'rgba(0, 255, 255, 0.05)';
      ctx.lineWidth = 1;

      const gridSize = 50;
      const offsetY = (time * 2) % gridSize;

      for (let x = 0; x < width; x += gridSize) {
        ctx.beginPath();
        ctx.moveTo(x, 0);
        ctx.lineTo(x, height);
        ctx.stroke();
      }

      for (let y = -gridSize + offsetY; y < height + gridSize; y += gridSize) {
        ctx.beginPath();
        ctx.moveTo(0, y);
        ctx.lineTo(width, y);
        ctx.stroke();
      }

      // Scanlines
      ctx.fillStyle = 'rgba(0, 0, 0, 0.03)';
      for (let y = 0; y < height; y += 4) {
        ctx.fillRect(0, y, width, 2);
      }
    }

    function render() {
      // Clear
      ctx.fillStyle = '#0a0a12';
      ctx.fillRect(0, 0, width, height);

      drawBackground();
      drawParticles();
      drawObstacles();
      drawPlayer();
    }

    function gameLoop() {
      if (!gameRunning) return;

      time++;

      // Spawn obstacles
      const spawnRate = Math.max(30, 60 - level * 5);
      if (time % spawnRate === 0) {
        spawnObstacle();
      }

      // Level up
      if (score > level * 500) {
        level++;
        document.getElementById('level').textContent = level;
        // Flash effect
        spawnParticle(width / 2, height / 2, '#ffff00');
      }

      updatePlayer();
      updateObstacles();
      updateParticles();
      render();

      requestAnimationFrame(gameLoop);
    }

    function updateUI() {
      document.getElementById('score').textContent = score;
      document.getElementById('dodged').textContent = dodged;
    }

    function startGame() {
      document.getElementById('start-screen').classList.add('hidden');
      gameRunning = true;
      gameLoop();
    }

    function gameOver() {
      gameRunning = false;
      document.getElementById('game-over').classList.add('active');
      document.getElementById('final-score').textContent = score;

      // Explosion effect
      for (let i = 0; i < 50; i++) {
        particles.push({
          x: player.x,
          y: player.y,
          vx: (Math.random() - 0.5) * 20,
          vy: (Math.random() - 0.5) * 20,
          life: 1,
          color: Math.random() > 0.5 ? '#00ffff' : '#ff00ff',
          size: Math.random() * 8 + 3
        });
      }

      // Continue rendering particles
      const renderExplosion = () => {
        updateParticles();
        render();
        if (particles.length > 0) {
          requestAnimationFrame(renderExplosion);
        }
      };
      renderExplosion();
    }

    function restartGame() {
      document.getElementById('game-over').classList.remove('active');
      score = 0;
      level = 1;
      dodged = 0;
      time = 0;
      obstacles = [];
      particles = [];
      player.x = width / 2;
      player.trail = [];
      updateUI();
      document.getElementById('level').textContent = 1;
      gameRunning = true;
      gameLoop();
    }

    // Event listeners
    window.addEventListener('resize', resize);

    document.addEventListener('keydown', (e) => {
      if (e.key === 'ArrowLeft' || e.key === 'a') keys.left = true;
      if (e.key === 'ArrowRight' || e.key === 'd') keys.right = true;
      if (e.key === ' ' && !gameRunning && document.getElementById('start-screen').classList.contains('hidden')) {
        restartGame();
      }
      if (e.key === ' ' && !document.getElementById('start-screen').classList.contains('hidden')) {
        startGame();
      }
    });

    document.addEventListener('keyup', (e) => {
      if (e.key === 'ArrowLeft' || e.key === 'a') keys.left = false;
      if (e.key === 'ArrowRight' || e.key === 'd') keys.right = false;
    });

    canvas.addEventListener('mousemove', (e) => {
      if (gameRunning) {
        mouseX = e.clientX;
      }
    });

    canvas.addEventListener('mouseleave', () => {
      mouseX = null;
    });

    // Mobile controls
    const leftBtn = document.getElementById('left-btn');
    const rightBtn = document.getElementById('right-btn');

    leftBtn.addEventListener('touchstart', (e) => { e.preventDefault(); mobileLeft = true; });
    leftBtn.addEventListener('touchend', () => { mobileLeft = false; });
    rightBtn.addEventListener('touchstart', (e) => { e.preventDefault(); mobileRight = true; });
    rightBtn.addEventListener('touchend', () => { mobileRight = false; });

    // Touch movement
    canvas.addEventListener('touchmove', (e) => {
      e.preventDefault();
      if (gameRunning && e.touches[0]) {
        mouseX = e.touches[0].clientX;
      }
    });

    canvas.addEventListener('touchend', () => {
      mouseX = null;
    });

    // Initialize
    resize();
    render();
  </script>
<script src="/sloppy-header/sloppy-bar.js"></script>
<script src="/vibelib-extended.js"></script>
<script>
  // Compatibility Patch for Legacy Apps
  window.addEventListener("load", () => {
    if (window.SloppyKarma && window.VibeLib.Economy) {
      // Redirect old calls to new engine
      window.SloppyKarma.track = window.VibeLib.Economy.track;
    }
  });
</script>
</body>
</html>
