<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
  <title>Neon Flap - Glowing Bird Adventure</title>
  <meta name="description" content="A neon-themed flappy bird clone with high scores">
  <meta property="og:title" content="Neon Flap">
  <meta property="og:description" content="Flap through neon pipes in this glowing arcade game">
  <meta property="og:url" content="https://app.sloppy.live/neon-flap">
  <meta property="og:image" content="https://app.sloppy.live/neon-flap/og-image.png">
  <link rel="icon" href="https://emojicdn.elk.sh/ðŸ¦">
  <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&display=swap" rel="stylesheet">
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      min-height: 100vh;
      background: #0a0a15;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      font-family: 'Orbitron', monospace;
      overflow: hidden;
      touch-action: manipulation;
    }

    .game-wrapper {
      position: relative;
      width: 100%;
      max-width: 400px;
      aspect-ratio: 9/16;
      max-height: 90vh;
    }

    canvas {
      display: block;
      width: 100%;
      height: 100%;
      border-radius: 12px;
      box-shadow:
        0 0 30px rgba(0, 255, 200, 0.2),
        inset 0 0 30px rgba(0, 0, 0, 0.5);
    }

    .hud {
      position: absolute;
      top: 20px;
      left: 0;
      right: 0;
      display: flex;
      justify-content: space-between;
      padding: 0 20px;
      pointer-events: none;
      z-index: 10;
    }

    .score-display {
      font-size: 32px;
      font-weight: 900;
      color: #00ffc8;
      text-shadow: 0 0 20px #00ffc8, 0 0 40px #00ffc8;
    }

    .high-score {
      font-size: 14px;
      color: #ff00aa;
      text-shadow: 0 0 10px #ff00aa;
    }

    .overlay {
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(10, 10, 21, 0.9);
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      border-radius: 12px;
      z-index: 20;
      opacity: 1;
      transition: opacity 0.3s;
    }

    .overlay.hidden {
      opacity: 0;
      pointer-events: none;
    }

    .title {
      font-size: 36px;
      font-weight: 900;
      color: #00ffc8;
      text-shadow: 0 0 30px #00ffc8;
      margin-bottom: 10px;
      letter-spacing: 4px;
    }

    .subtitle {
      font-size: 12px;
      color: rgba(255, 255, 255, 0.5);
      letter-spacing: 3px;
      margin-bottom: 40px;
    }

    .game-over-title {
      font-size: 28px;
      color: #ff3366;
      text-shadow: 0 0 20px #ff3366;
      margin-bottom: 20px;
    }

    .final-score {
      font-size: 48px;
      font-weight: 900;
      color: #00ffc8;
      text-shadow: 0 0 30px #00ffc8;
      margin-bottom: 10px;
    }

    .new-high {
      font-size: 14px;
      color: #ffcc00;
      text-shadow: 0 0 10px #ffcc00;
      margin-bottom: 20px;
      animation: pulse 0.5s ease infinite alternate;
    }

    @keyframes pulse {
      from { opacity: 0.7; }
      to { opacity: 1; }
    }

    .best-score {
      font-size: 14px;
      color: #ff00aa;
      margin-bottom: 40px;
    }

    .play-btn {
      padding: 15px 40px;
      font-family: 'Orbitron', monospace;
      font-size: 16px;
      font-weight: 700;
      letter-spacing: 3px;
      background: transparent;
      border: 2px solid #00ffc8;
      color: #00ffc8;
      cursor: pointer;
      transition: all 0.2s;
      border-radius: 4px;
    }

    .play-btn:hover {
      background: #00ffc8;
      color: #0a0a15;
      box-shadow: 0 0 30px #00ffc8;
    }

    .instructions {
      margin-top: 30px;
      font-size: 11px;
      color: rgba(255, 255, 255, 0.4);
      text-align: center;
      line-height: 1.8;
    }

    .back-link {
      position: fixed;
      bottom: 10px;
      left: 50%;
      transform: translateX(-50%);
      color: rgba(255, 255, 255, 0.3);
      text-decoration: none;
      font-size: 11px;
      letter-spacing: 2px;
      z-index: 100;
    }

    .back-link:hover {
      color: #00ffc8;
    }
  </style>
</head>
<body>
  <div class="game-wrapper">
    <canvas id="game"></canvas>

    <div class="hud">
      <div class="score-display" id="score">0</div>
      <div class="high-score">BEST: <span id="highScore">0</span></div>
    </div>

    <div class="overlay" id="startScreen">
      <div class="title">NEON FLAP</div>
      <div class="subtitle">GLOWING BIRD ADVENTURE</div>
      <button class="play-btn" onclick="startGame()">PLAY</button>
      <div class="instructions">
        TAP or SPACE to flap<br>
        Avoid the pipes!
      </div>
    </div>

    <div class="overlay hidden" id="gameOverScreen">
      <div class="game-over-title">GAME OVER</div>
      <div class="final-score" id="finalScore">0</div>
      <div class="new-high hidden" id="newHigh">â˜… NEW HIGH SCORE â˜…</div>
      <div class="best-score">BEST: <span id="bestScore">0</span></div>
      <button class="play-btn" onclick="startGame()">RETRY</button>
    </div>
  </div>

  <a href="https://sloppy.live" class="back-link">sloppy.live</a>

  <script>
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');

    // Responsive sizing
    function resize() {
      const wrapper = canvas.parentElement;
      const rect = wrapper.getBoundingClientRect();
      canvas.width = rect.width;
      canvas.height = rect.height;
    }
    resize();
    window.addEventListener('resize', resize);

    // Game constants
    const GRAVITY = 0.4;
    const FLAP_POWER = -7;
    const PIPE_SPEED = 3;
    const PIPE_GAP = 150;
    const PIPE_WIDTH = 60;
    const PIPE_SPAWN_RATE = 100;

    // Colors
    const COLORS = {
      bg1: '#0a0a15',
      bg2: '#1a1a2e',
      bird: '#00ffc8',
      birdGlow: 'rgba(0, 255, 200, 0.5)',
      pipe: '#ff00aa',
      pipeGlow: 'rgba(255, 0, 170, 0.3)',
      pipeEdge: '#ff66cc',
      star: '#ffffff'
    };

    // Game state
    let gameState = 'start'; // start, playing, gameover
    let score = 0;
    let highScore = parseInt(localStorage.getItem('neonFlapHighScore')) || 0;
    let frameCount = 0;

    // Bird
    let bird = {
      x: 80,
      y: 0,
      vy: 0,
      radius: 15,
      rotation: 0
    };

    // Pipes
    let pipes = [];

    // Stars (background)
    let stars = [];
    for (let i = 0; i < 50; i++) {
      stars.push({
        x: Math.random(),
        y: Math.random(),
        size: Math.random() * 2 + 1,
        speed: Math.random() * 0.5 + 0.2
      });
    }

    // Update high score display
    document.getElementById('highScore').textContent = highScore;

    function startGame() {
      document.getElementById('startScreen').classList.add('hidden');
      document.getElementById('gameOverScreen').classList.add('hidden');

      bird.y = canvas.height / 2;
      bird.vy = 0;
      bird.rotation = 0;
      pipes = [];
      score = 0;
      frameCount = 0;
      gameState = 'playing';

      document.getElementById('score').textContent = '0';
    }

    function gameOver() {
      gameState = 'gameover';

      const isNewHigh = score > highScore;
      if (isNewHigh) {
        highScore = score;
        localStorage.setItem('neonFlapHighScore', highScore);
        document.getElementById('highScore').textContent = highScore;
      }

      document.getElementById('finalScore').textContent = score;
      document.getElementById('bestScore').textContent = highScore;
      document.getElementById('newHigh').classList.toggle('hidden', !isNewHigh);
      document.getElementById('gameOverScreen').classList.remove('hidden');
    }

    function flap() {
      if (gameState === 'playing') {
        bird.vy = FLAP_POWER;
      }
    }

    // Input handlers
    document.addEventListener('keydown', (e) => {
      if (e.code === 'Space') {
        e.preventDefault();
        if (gameState === 'start') startGame();
        else if (gameState === 'playing') flap();
        else if (gameState === 'gameover') startGame();
      }
    });

    canvas.addEventListener('click', () => {
      if (gameState === 'playing') flap();
    });

    canvas.addEventListener('touchstart', (e) => {
      e.preventDefault();
      if (gameState === 'playing') flap();
    });

    function spawnPipe() {
      const minY = 80;
      const maxY = canvas.height - PIPE_GAP - 80;
      const gapY = minY + Math.random() * (maxY - minY);

      pipes.push({
        x: canvas.width + PIPE_WIDTH,
        gapY: gapY,
        passed: false
      });
    }

    function update() {
      if (gameState !== 'playing') return;

      frameCount++;

      // Bird physics
      bird.vy += GRAVITY;
      bird.y += bird.vy;
      bird.rotation = Math.min(Math.max(bird.vy * 3, -30), 90);

      // Spawn pipes
      if (frameCount % PIPE_SPAWN_RATE === 0) {
        spawnPipe();
      }

      // Update pipes
      for (let i = pipes.length - 1; i >= 0; i--) {
        const pipe = pipes[i];
        pipe.x -= PIPE_SPEED;

        // Score
        if (!pipe.passed && pipe.x + PIPE_WIDTH < bird.x) {
          pipe.passed = true;
          score++;
          document.getElementById('score').textContent = score;
        }

        // Remove off-screen pipes
        if (pipe.x < -PIPE_WIDTH) {
          pipes.splice(i, 1);
        }

        // Collision detection
        if (checkCollision(pipe)) {
          gameOver();
          return;
        }
      }

      // Ceiling/floor collision
      if (bird.y - bird.radius < 0 || bird.y + bird.radius > canvas.height) {
        gameOver();
      }

      // Update stars
      stars.forEach(star => {
        star.x -= star.speed * 0.001;
        if (star.x < 0) star.x = 1;
      });
    }

    function checkCollision(pipe) {
      const birdLeft = bird.x - bird.radius;
      const birdRight = bird.x + bird.radius;
      const birdTop = bird.y - bird.radius;
      const birdBottom = bird.y + bird.radius;

      const pipeLeft = pipe.x;
      const pipeRight = pipe.x + PIPE_WIDTH;
      const gapTop = pipe.gapY;
      const gapBottom = pipe.gapY + PIPE_GAP;

      // Check if bird is in pipe x range
      if (birdRight > pipeLeft && birdLeft < pipeRight) {
        // Check if bird is outside gap
        if (birdTop < gapTop || birdBottom > gapBottom) {
          return true;
        }
      }

      return false;
    }

    function draw() {
      // Background gradient
      const gradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
      gradient.addColorStop(0, COLORS.bg1);
      gradient.addColorStop(1, COLORS.bg2);
      ctx.fillStyle = gradient;
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      // Stars
      stars.forEach(star => {
        ctx.fillStyle = `rgba(255, 255, 255, ${0.3 + Math.sin(frameCount * 0.05 + star.x * 10) * 0.2})`;
        ctx.beginPath();
        ctx.arc(star.x * canvas.width, star.y * canvas.height, star.size, 0, Math.PI * 2);
        ctx.fill();
      });

      // Grid lines (subtle)
      ctx.strokeStyle = 'rgba(0, 255, 200, 0.03)';
      ctx.lineWidth = 1;
      for (let x = 0; x < canvas.width; x += 40) {
        ctx.beginPath();
        ctx.moveTo(x, 0);
        ctx.lineTo(x, canvas.height);
        ctx.stroke();
      }
      for (let y = 0; y < canvas.height; y += 40) {
        ctx.beginPath();
        ctx.moveTo(0, y);
        ctx.lineTo(canvas.width, y);
        ctx.stroke();
      }

      // Pipes
      pipes.forEach(pipe => {
        drawPipe(pipe);
      });

      // Bird
      drawBird();
    }

    function drawPipe(pipe) {
      const { x, gapY } = pipe;

      // Pipe glow
      ctx.shadowColor = COLORS.pipe;
      ctx.shadowBlur = 20;

      // Top pipe
      ctx.fillStyle = COLORS.pipe;
      ctx.fillRect(x, 0, PIPE_WIDTH, gapY);

      // Top pipe edge
      ctx.fillStyle = COLORS.pipeEdge;
      ctx.fillRect(x - 5, gapY - 20, PIPE_WIDTH + 10, 20);

      // Bottom pipe
      ctx.fillStyle = COLORS.pipe;
      ctx.fillRect(x, gapY + PIPE_GAP, PIPE_WIDTH, canvas.height - gapY - PIPE_GAP);

      // Bottom pipe edge
      ctx.fillStyle = COLORS.pipeEdge;
      ctx.fillRect(x - 5, gapY + PIPE_GAP, PIPE_WIDTH + 10, 20);

      // Inner glow lines
      ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(x + 10, 0);
      ctx.lineTo(x + 10, gapY - 20);
      ctx.stroke();
      ctx.beginPath();
      ctx.moveTo(x + 10, gapY + PIPE_GAP + 20);
      ctx.lineTo(x + 10, canvas.height);
      ctx.stroke();

      ctx.shadowBlur = 0;
    }

    function drawBird() {
      ctx.save();
      ctx.translate(bird.x, bird.y);
      ctx.rotate(bird.rotation * Math.PI / 180);

      // Outer glow
      ctx.shadowColor = COLORS.bird;
      ctx.shadowBlur = 25;

      // Bird body
      ctx.fillStyle = COLORS.bird;
      ctx.beginPath();
      ctx.ellipse(0, 0, bird.radius * 1.3, bird.radius, 0, 0, Math.PI * 2);
      ctx.fill();

      // Eye
      ctx.fillStyle = '#0a0a15';
      ctx.shadowBlur = 0;
      ctx.beginPath();
      ctx.arc(bird.radius * 0.4, -bird.radius * 0.2, 5, 0, Math.PI * 2);
      ctx.fill();

      // Eye shine
      ctx.fillStyle = '#ffffff';
      ctx.beginPath();
      ctx.arc(bird.radius * 0.5, -bird.radius * 0.35, 2, 0, Math.PI * 2);
      ctx.fill();

      // Beak
      ctx.fillStyle = '#ffcc00';
      ctx.beginPath();
      ctx.moveTo(bird.radius * 1.2, 0);
      ctx.lineTo(bird.radius * 1.8, bird.radius * 0.3);
      ctx.lineTo(bird.radius * 1.2, bird.radius * 0.5);
      ctx.closePath();
      ctx.fill();

      // Wing
      ctx.fillStyle = 'rgba(0, 200, 160, 0.8)';
      const wingFlap = Math.sin(frameCount * 0.3) * 10;
      ctx.beginPath();
      ctx.ellipse(-bird.radius * 0.3, wingFlap * 0.3, bird.radius * 0.6, bird.radius * 0.4, wingFlap * 0.05, 0, Math.PI * 2);
      ctx.fill();

      ctx.restore();
    }

    function gameLoop() {
      update();
      draw();
      requestAnimationFrame(gameLoop);
    }

    // Start loop
    gameLoop();
  </script>
<script src="/sloppy-header/sloppy-bar.js"></script>
</body>
</html>
