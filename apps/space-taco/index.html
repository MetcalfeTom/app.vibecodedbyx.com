<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Space Taco</title>
  <link rel="icon" href="https://emojicdn.elk.sh/üåÆ">
  <meta property="og:title" content="Space Taco">
  <meta property="og:description" content="Shoot neon salsa at space foxes in this cosmic taco adventure">
  <meta property="og:url" content="https://app.sloppy.live/space-taco">
  <meta property="og:image" content="https://emojicdn.elk.sh/üåÆ?style=apple&size=512">
  <link href="https://fonts.googleapis.com/css2?family=Bangers&family=Orbitron:wght@700;900&display=swap" rel="stylesheet">
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body { background: #000; overflow: hidden; font-family: 'Orbitron', sans-serif; cursor: crosshair; }

    #canvas-container { position: fixed; top: 0; left: 0; width: 100%; height: 100%; }
    canvas { display: block; }

    .hud {
      position: fixed; top: 0; left: 0; width: 100%; padding: 20px;
      display: flex; justify-content: space-between; align-items: flex-start;
      pointer-events: none; z-index: 100;
    }

    .title {
      font-family: 'Bangers', cursive; font-size: 2.5rem;
      color: #ffff00; text-shadow: 0 0 20px #ff6600, 0 0 40px #ff0000, 3px 3px 0 #ff6600;
      letter-spacing: 4px;
    }

    .score-panel {
      background: rgba(0, 0, 0, 0.7); border: 3px solid #ff6600;
      border-radius: 15px; padding: 15px 25px; text-align: right;
    }

    .score-label { color: #ff6600; font-size: 0.7rem; letter-spacing: 2px; }
    .score-value {
      font-size: 2rem; font-weight: 900; color: #ffff00;
      text-shadow: 0 0 15px #ff6600;
    }

    .foxes-label { color: #00ffaa; font-size: 0.7rem; margin-top: 10px; }
    .foxes-value { font-size: 1.2rem; color: #00ffaa; }

    .instructions {
      position: fixed; bottom: 20px; left: 50%; transform: translateX(-50%);
      background: rgba(0, 0, 0, 0.8); border: 2px solid #ff00ff;
      border-radius: 25px; padding: 12px 25px; z-index: 100;
      text-align: center;
    }
    .instructions p { color: #ff00ff; font-size: 0.75rem; margin: 3px 0; }
    .instructions .key { color: #ffff00; font-weight: 700; }

    .salsa-meter {
      position: fixed; bottom: 20px; left: 20px;
      background: rgba(0, 0, 0, 0.8); border: 2px solid #ff0044;
      border-radius: 10px; padding: 10px 15px; z-index: 100;
    }
    .salsa-label { color: #ff0044; font-size: 0.6rem; margin-bottom: 5px; }
    .salsa-bar { width: 120px; height: 12px; background: #220000; border-radius: 6px; overflow: hidden; }
    .salsa-fill { height: 100%; background: linear-gradient(90deg, #ff0044, #ff6600, #ffff00); transition: width 0.1s; }

    .combo {
      position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%);
      font-family: 'Bangers', cursive; font-size: 4rem; color: #ff00ff;
      text-shadow: 0 0 30px #ff00ff, 0 0 60px #ff0044;
      opacity: 0; pointer-events: none; z-index: 200;
      transition: opacity 0.3s, transform 0.3s;
    }
    .combo.show { opacity: 1; transform: translate(-50%, -50%) scale(1.2); }

    .game-over {
      position: fixed; top: 0; left: 0; width: 100%; height: 100%;
      background: rgba(0, 0, 0, 0.9); display: none; justify-content: center;
      align-items: center; flex-direction: column; z-index: 300;
    }
    .game-over.show { display: flex; }
    .game-over h1 { font-family: 'Bangers', cursive; font-size: 5rem; color: #ff0044; text-shadow: 0 0 30px #ff0044; }
    .game-over p { color: #ffff00; font-size: 1.5rem; margin: 20px 0; }
    .restart-btn {
      padding: 15px 40px; background: linear-gradient(135deg, #ff6600, #ff0044);
      border: none; border-radius: 30px; color: #fff; font-family: 'Bangers', cursive;
      font-size: 1.5rem; cursor: pointer; transition: transform 0.2s;
    }
    .restart-btn:hover { transform: scale(1.1); }

    .back-link {
      position: fixed; bottom: 20px; right: 20px;
      color: #444; font-size: 0.7rem; text-decoration: none; z-index: 100;
    }
    .back-link:hover { color: #ff6600; }
  </style>
</head>
<body>
  <div id="canvas-container"></div>

  <div class="hud">
    <div class="title">üåÆ SPACE TACO üåÆ</div>
    <div class="score-panel">
      <div class="score-label">SCORE</div>
      <div class="score-value" id="score">0</div>
      <div class="foxes-label">FOXES SALSAFIED</div>
      <div class="foxes-value" id="foxes">0</div>
    </div>
  </div>

  <div class="salsa-meter">
    <div class="salsa-label">üå∂Ô∏è SALSA POWER</div>
    <div class="salsa-bar">
      <div class="salsa-fill" id="salsa-fill" style="width: 100%"></div>
    </div>
  </div>

  <div class="instructions">
    <p><span class="key">WASD/Arrows</span> - Move Taco</p>
    <p><span class="key">CLICK/SPACE</span> - Shoot Salsa</p>
  </div>

  <div class="combo" id="combo">SPICY!</div>

  <div class="game-over" id="game-over">
    <h1>GAME OVER</h1>
    <p>Final Score: <span id="final-score">0</span></p>
    <p>Foxes Salsafied: <span id="final-foxes">0</span></p>
    <button class="restart-btn" onclick="restartGame()">üåÆ PLAY AGAIN üåÆ</button>
  </div>

  <a href="https://sloppy.live" class="back-link">sloppy.live</a>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script>
    let scene, camera, renderer;
    let taco, tacoGroup;
    let foxes = [], salsaShots = [], jalapenos = [];
    let score = 0, foxesHit = 0, salsaPower = 100;
    let gameOver = false;
    let keys = { w: false, a: false, s: false, d: false, up: false, down: false, left: false, right: false };
    let comboCount = 0, lastHitTime = 0;

    function init() {
      scene = new THREE.Scene();
      scene.background = new THREE.Color(0x0a0015);

      camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
      camera.position.set(0, 0, 20);

      renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
      document.getElementById('canvas-container').appendChild(renderer.domElement);

      createTaco();
      createJalapenoStars();
      spawnFox();

      // Event listeners
      document.addEventListener('keydown', onKeyDown);
      document.addEventListener('keyup', onKeyUp);
      document.addEventListener('click', shootSalsa);
      document.addEventListener('mousedown', (e) => { if (e.button === 0) shootSalsa(); });
      window.addEventListener('resize', onResize);

      animate();

      // Spawn foxes periodically
      setInterval(() => {
        if (!gameOver && foxes.length < 8) spawnFox();
      }, 2000);

      // Regenerate salsa
      setInterval(() => {
        if (!gameOver && salsaPower < 100) {
          salsaPower = Math.min(100, salsaPower + 2);
          updateSalsaMeter();
        }
      }, 100);
    }

    function createTaco() {
      tacoGroup = new THREE.Group();

      // Taco shell (curved shape)
      const shellGeo = new THREE.TorusGeometry(1, 0.4, 8, 16, Math.PI);
      const shellMat = new THREE.MeshBasicMaterial({ color: 0xffaa00 });
      const shell = new THREE.Mesh(shellGeo, shellMat);
      shell.rotation.x = Math.PI / 2;
      shell.rotation.z = Math.PI / 2;
      tacoGroup.add(shell);

      // Taco filling - lettuce
      const lettuceGeo = new THREE.SphereGeometry(0.6, 8, 6);
      const lettuceMat = new THREE.MeshBasicMaterial({ color: 0x44ff44 });
      const lettuce = new THREE.Mesh(lettuceGeo, lettuceMat);
      lettuce.scale.set(1.2, 0.4, 0.8);
      lettuce.position.y = 0.2;
      tacoGroup.add(lettuce);

      // Taco filling - meat
      const meatGeo = new THREE.SphereGeometry(0.5, 8, 6);
      const meatMat = new THREE.MeshBasicMaterial({ color: 0x884422 });
      const meat = new THREE.Mesh(meatGeo, meatMat);
      meat.scale.set(1, 0.3, 0.6);
      meat.position.y = 0.35;
      tacoGroup.add(meat);

      // Cheese shreds
      for (let i = 0; i < 6; i++) {
        const cheeseGeo = new THREE.BoxGeometry(0.1, 0.3, 0.05);
        const cheeseMat = new THREE.MeshBasicMaterial({ color: 0xffff00 });
        const cheese = new THREE.Mesh(cheeseGeo, cheeseMat);
        cheese.position.set((Math.random() - 0.5) * 0.8, 0.4 + Math.random() * 0.2, (Math.random() - 0.5) * 0.3);
        cheese.rotation.set(Math.random(), Math.random(), Math.random());
        tacoGroup.add(cheese);
      }

      // Tomato chunks
      for (let i = 0; i < 4; i++) {
        const tomatoGeo = new THREE.SphereGeometry(0.12, 6, 6);
        const tomatoMat = new THREE.MeshBasicMaterial({ color: 0xff2222 });
        const tomato = new THREE.Mesh(tomatoGeo, tomatoMat);
        tomato.position.set((Math.random() - 0.5) * 0.6, 0.45, (Math.random() - 0.5) * 0.3);
        tacoGroup.add(tomato);
      }

      // Engine glow
      const glowGeo = new THREE.SphereGeometry(0.3, 8, 8);
      const glowMat = new THREE.MeshBasicMaterial({ color: 0x00ffff, transparent: true, opacity: 0.6 });
      const glow = new THREE.Mesh(glowGeo, glowMat);
      glow.position.set(-1.2, 0, 0);
      tacoGroup.add(glow);

      tacoGroup.position.set(-6, 0, 0);
      tacoGroup.rotation.z = -Math.PI / 2;
      scene.add(tacoGroup);
      taco = tacoGroup;
    }

    function createJalapenoStars() {
      for (let i = 0; i < 100; i++) {
        const jalapeno = createJalapeno();
        jalapeno.position.set(
          (Math.random() - 0.5) * 60,
          (Math.random() - 0.5) * 40,
          -10 - Math.random() * 30
        );
        jalapeno.rotation.set(Math.random() * Math.PI, Math.random() * Math.PI, Math.random() * Math.PI);
        jalapeno.scale.setScalar(0.1 + Math.random() * 0.2);
        jalapeno.userData.twinklePhase = Math.random() * Math.PI * 2;
        scene.add(jalapeno);
        jalapenos.push(jalapeno);
      }
    }

    function createJalapeno() {
      const group = new THREE.Group();

      // Body (using cylinder + spheres since CapsuleGeometry not in r128)
      const bodyMat = new THREE.MeshBasicMaterial({ color: 0x00ff44 });

      // Main cylinder body
      const cylinderGeo = new THREE.CylinderGeometry(0.3, 0.25, 1, 8);
      const cylinder = new THREE.Mesh(cylinderGeo, bodyMat);
      cylinder.rotation.z = Math.PI / 6;
      group.add(cylinder);

      // Top cap
      const topCapGeo = new THREE.SphereGeometry(0.3, 8, 6, 0, Math.PI * 2, 0, Math.PI / 2);
      const topCap = new THREE.Mesh(topCapGeo, bodyMat);
      topCap.position.set(0.25, 0.45, 0);
      topCap.rotation.z = Math.PI / 6;
      group.add(topCap);

      // Bottom cap (pointed tip)
      const bottomCapGeo = new THREE.ConeGeometry(0.25, 0.4, 8);
      const bottomCap = new THREE.Mesh(bottomCapGeo, bodyMat);
      bottomCap.position.set(-0.3, -0.5, 0);
      bottomCap.rotation.z = Math.PI / 6 + Math.PI;
      group.add(bottomCap);

      // Stem
      const stemGeo = new THREE.CylinderGeometry(0.08, 0.12, 0.3, 6);
      const stemMat = new THREE.MeshBasicMaterial({ color: 0x228822 });
      const stem = new THREE.Mesh(stemGeo, stemMat);
      stem.position.set(0.2, 0.6, 0);
      group.add(stem);

      // Glow
      const glowGeo = new THREE.SphereGeometry(0.6, 8, 8);
      const glowMat = new THREE.MeshBasicMaterial({ color: 0x00ff44, transparent: true, opacity: 0.3 });
      const glow = new THREE.Mesh(glowGeo, glowMat);
      group.add(glow);

      return group;
    }

    function createSpaceFox() {
      const fox = new THREE.Group();

      // Body
      const bodyGeo = new THREE.SphereGeometry(0.8, 12, 8);
      const bodyMat = new THREE.MeshBasicMaterial({ color: 0xff6622 });
      const body = new THREE.Mesh(bodyGeo, bodyMat);
      body.scale.set(1.3, 1, 0.9);
      fox.add(body);

      // Head
      const headGeo = new THREE.SphereGeometry(0.5, 10, 8);
      const head = new THREE.Mesh(headGeo, bodyMat);
      head.position.set(0.9, 0.3, 0);
      fox.add(head);

      // Snout
      const snoutGeo = new THREE.ConeGeometry(0.2, 0.5, 8);
      const snout = new THREE.Mesh(snoutGeo, bodyMat);
      snout.rotation.z = -Math.PI / 2;
      snout.position.set(1.35, 0.2, 0);
      fox.add(snout);

      // Nose
      const noseGeo = new THREE.SphereGeometry(0.08, 6, 6);
      const noseMat = new THREE.MeshBasicMaterial({ color: 0x111111 });
      const nose = new THREE.Mesh(noseGeo, noseMat);
      nose.position.set(1.58, 0.2, 0);
      fox.add(nose);

      // Eyes (glowing)
      [-1, 1].forEach(side => {
        const eyeGeo = new THREE.SphereGeometry(0.1, 8, 8);
        const eyeMat = new THREE.MeshBasicMaterial({ color: 0xff00ff });
        const eye = new THREE.Mesh(eyeGeo, eyeMat);
        eye.position.set(1.1, 0.45, side * 0.25);
        fox.add(eye);

        // Eye glow
        const eyeGlowGeo = new THREE.SphereGeometry(0.15, 6, 6);
        const eyeGlowMat = new THREE.MeshBasicMaterial({ color: 0xff00ff, transparent: true, opacity: 0.4 });
        const eyeGlow = new THREE.Mesh(eyeGlowGeo, eyeGlowMat);
        eyeGlow.position.set(1.1, 0.45, side * 0.25);
        fox.add(eyeGlow);
      });

      // Ears
      [-1, 1].forEach(side => {
        const earGeo = new THREE.ConeGeometry(0.2, 0.5, 4);
        const ear = new THREE.Mesh(earGeo, bodyMat);
        ear.position.set(0.7, 0.7, side * 0.3);
        ear.rotation.z = side * 0.3;
        fox.add(ear);
      });

      // Tail
      const tailGeo = new THREE.CylinderGeometry(0.1, 0.3, 1.2, 8);
      const tail = new THREE.Mesh(tailGeo, bodyMat);
      tail.position.set(-1, 0.2, 0);
      tail.rotation.z = Math.PI / 4;
      fox.add(tail);

      // Tail tip (white)
      const tipGeo = new THREE.SphereGeometry(0.25, 8, 8);
      const tipMat = new THREE.MeshBasicMaterial({ color: 0xffffff });
      const tip = new THREE.Mesh(tipGeo, tipMat);
      tip.position.set(-1.4, 0.6, 0);
      fox.add(tip);

      // Space helmet
      const helmetGeo = new THREE.SphereGeometry(0.65, 16, 12);
      const helmetMat = new THREE.MeshBasicMaterial({ color: 0x88ccff, transparent: true, opacity: 0.3 });
      const helmet = new THREE.Mesh(helmetGeo, helmetMat);
      helmet.position.set(0.9, 0.3, 0);
      fox.add(helmet);

      // Jetpack
      const jetpackGeo = new THREE.BoxGeometry(0.4, 0.6, 0.3);
      const jetpackMat = new THREE.MeshBasicMaterial({ color: 0x444466 });
      const jetpack = new THREE.Mesh(jetpackGeo, jetpackMat);
      jetpack.position.set(-0.3, 0, -0.5);
      fox.add(jetpack);

      // Jetpack flames
      const flameGeo = new THREE.ConeGeometry(0.15, 0.5, 8);
      const flameMat = new THREE.MeshBasicMaterial({ color: 0x00ffff, transparent: true, opacity: 0.8 });
      const flame1 = new THREE.Mesh(flameGeo, flameMat);
      flame1.rotation.x = Math.PI;
      flame1.position.set(-0.2, -0.5, -0.5);
      fox.add(flame1);
      const flame2 = flame1.clone();
      flame2.position.set(-0.4, -0.5, -0.5);
      fox.add(flame2);

      return fox;
    }

    function spawnFox() {
      const fox = createSpaceFox();
      fox.position.set(
        15 + Math.random() * 5,
        (Math.random() - 0.5) * 12,
        0
      );
      fox.userData = {
        speed: 0.03 + Math.random() * 0.03,
        wobblePhase: Math.random() * Math.PI * 2,
        health: 1
      };
      scene.add(fox);
      foxes.push(fox);
    }

    function shootSalsa() {
      if (gameOver || salsaPower < 10) return;

      salsaPower -= 10;
      updateSalsaMeter();

      const salsa = new THREE.Group();

      // Salsa blob
      const blobGeo = new THREE.SphereGeometry(0.25, 8, 8);
      const blobMat = new THREE.MeshBasicMaterial({ color: 0xff0044 });
      const blob = new THREE.Mesh(blobGeo, blobMat);
      salsa.add(blob);

      // Salsa glow
      const glowGeo = new THREE.SphereGeometry(0.4, 8, 8);
      const glowMat = new THREE.MeshBasicMaterial({ color: 0xff6600, transparent: true, opacity: 0.5 });
      const glow = new THREE.Mesh(glowGeo, glowMat);
      salsa.add(glow);

      // Trail particles
      for (let i = 0; i < 5; i++) {
        const particleGeo = new THREE.SphereGeometry(0.08, 4, 4);
        const particleMat = new THREE.MeshBasicMaterial({ color: 0xffff00, transparent: true, opacity: 0.6 });
        const particle = new THREE.Mesh(particleGeo, particleMat);
        particle.position.x = -0.2 * (i + 1);
        salsa.add(particle);
      }

      salsa.position.copy(taco.position);
      salsa.position.x += 1.5;
      salsa.userData = { speed: 0.5 };

      scene.add(salsa);
      salsaShots.push(salsa);
    }

    function updateSalsaMeter() {
      document.getElementById('salsa-fill').style.width = salsaPower + '%';
    }

    function showCombo(text) {
      const combo = document.getElementById('combo');
      combo.textContent = text;
      combo.classList.add('show');
      setTimeout(() => combo.classList.remove('show'), 500);
    }

    function createSalsaExplosion(position) {
      for (let i = 0; i < 15; i++) {
        const particle = new THREE.Mesh(
          new THREE.SphereGeometry(0.1 + Math.random() * 0.1, 6, 6),
          new THREE.MeshBasicMaterial({
            color: Math.random() > 0.5 ? 0xff0044 : 0xff6600,
            transparent: true,
            opacity: 1
          })
        );
        particle.position.copy(position);
        particle.userData = {
          velocity: new THREE.Vector3(
            (Math.random() - 0.5) * 0.3,
            (Math.random() - 0.5) * 0.3,
            (Math.random() - 0.5) * 0.1
          ),
          life: 1
        };
        scene.add(particle);

        // Animate particle
        const animateParticle = () => {
          particle.position.add(particle.userData.velocity);
          particle.userData.life -= 0.02;
          particle.material.opacity = particle.userData.life;
          particle.scale.setScalar(particle.userData.life);
          if (particle.userData.life > 0) {
            requestAnimationFrame(animateParticle);
          } else {
            scene.remove(particle);
          }
        };
        animateParticle();
      }
    }

    function endGame() {
      gameOver = true;
      document.getElementById('final-score').textContent = score;
      document.getElementById('final-foxes').textContent = foxesHit;
      document.getElementById('game-over').classList.add('show');
    }

    function restartGame() {
      gameOver = false;
      score = 0;
      foxesHit = 0;
      salsaPower = 100;
      comboCount = 0;

      // Remove all foxes and salsa
      foxes.forEach(f => scene.remove(f));
      salsaShots.forEach(s => scene.remove(s));
      foxes = [];
      salsaShots = [];

      // Reset taco position
      taco.position.set(-6, 0, 0);

      // Update UI
      document.getElementById('score').textContent = '0';
      document.getElementById('foxes').textContent = '0';
      document.getElementById('game-over').classList.remove('show');
      updateSalsaMeter();
    }

    function onKeyDown(e) {
      if (e.code === 'KeyW' || e.code === 'ArrowUp') keys.w = true;
      if (e.code === 'KeyS' || e.code === 'ArrowDown') keys.s = true;
      if (e.code === 'KeyA' || e.code === 'ArrowLeft') keys.a = true;
      if (e.code === 'KeyD' || e.code === 'ArrowRight') keys.d = true;
      if (e.code === 'Space') shootSalsa();
    }

    function onKeyUp(e) {
      if (e.code === 'KeyW' || e.code === 'ArrowUp') keys.w = false;
      if (e.code === 'KeyS' || e.code === 'ArrowDown') keys.s = false;
      if (e.code === 'KeyA' || e.code === 'ArrowLeft') keys.a = false;
      if (e.code === 'KeyD' || e.code === 'ArrowRight') keys.d = false;
    }

    function animate() {
      requestAnimationFrame(animate);
      if (gameOver) {
        renderer.render(scene, camera);
        return;
      }

      const time = performance.now() * 0.001;

      // Move taco
      const speed = 0.15;
      if (keys.w) taco.position.y = Math.min(8, taco.position.y + speed);
      if (keys.s) taco.position.y = Math.max(-8, taco.position.y - speed);
      if (keys.a) taco.position.x = Math.max(-10, taco.position.x - speed);
      if (keys.d) taco.position.x = Math.min(5, taco.position.x + speed);

      // Taco wobble
      taco.rotation.x = Math.sin(time * 3) * 0.1;

      // Move foxes
      foxes.forEach((fox, i) => {
        fox.position.x -= fox.userData.speed;
        fox.position.y += Math.sin(time * 2 + fox.userData.wobblePhase) * 0.02;
        fox.rotation.y = Math.sin(time * 3 + fox.userData.wobblePhase) * 0.2;

        // Check collision with taco
        if (fox.position.distanceTo(taco.position) < 1.5) {
          endGame();
        }

        // Remove if off screen
        if (fox.position.x < -15) {
          scene.remove(fox);
          foxes.splice(i, 1);
        }
      });

      // Move salsa shots
      for (let i = salsaShots.length - 1; i >= 0; i--) {
        const salsa = salsaShots[i];
        salsa.position.x += salsa.userData.speed;
        salsa.rotation.x += 0.2;
        salsa.rotation.y += 0.1;

        // Check collision with foxes
        for (let j = foxes.length - 1; j >= 0; j--) {
          const fox = foxes[j];
          if (salsa.position.distanceTo(fox.position) < 1.2) {
            createSalsaExplosion(fox.position.clone());
            scene.remove(fox);
            scene.remove(salsa);
            foxes.splice(j, 1);
            salsaShots.splice(i, 1);

            // Score
            const now = Date.now();
            if (now - lastHitTime < 1000) {
              comboCount++;
              if (comboCount >= 3) showCombo('üî• SPICY x' + comboCount + '!');
            } else {
              comboCount = 1;
            }
            lastHitTime = now;

            score += 100 * comboCount;
            foxesHit++;
            document.getElementById('score').textContent = score;
            document.getElementById('foxes').textContent = foxesHit;
            break;
          }
        }

        // Remove if off screen
        if (salsa.position.x > 20) {
          scene.remove(salsa);
          salsaShots.splice(i, 1);
        }
      }

      // Twinkle jalape√±os
      jalapenos.forEach(j => {
        const twinkle = 0.5 + Math.sin(time * 3 + j.userData.twinklePhase) * 0.5;
        // Glow is now at index 4 (cylinder, topCap, bottomCap, stem, glow)
        if (j.children[4]) j.children[4].material.opacity = twinkle * 0.4;
        j.rotation.y += 0.005;
      });

      renderer.render(scene, camera);
    }

    function onResize() {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    }

    init();
  </script>
<script src="/sloppy-header/sloppy-bar.js"></script>
</body>
</html>
