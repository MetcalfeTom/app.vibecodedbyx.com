<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Abstract Tower Defense</title>
  <link rel="icon" href="https://emojicdn.elk.sh/ðŸ”º">

  <meta property="og:title" content="Abstract Tower Defense">
  <meta property="og:description" content="Defend with triangles. Destroy the circles. Minimalist chaos.">
  <meta property="og:url" content="https://app.sloppy.live/abstract-tower-defense">
  <meta property="og:image" content="https://app.sloppy.live/abstract-tower-defense/og-image.png">
  <meta property="og:type" content="website">

  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&display=swap" rel="stylesheet">

  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: 'Orbitron', sans-serif;
      background: #0a0a0f;
      color: #fff;
      min-height: 100vh;
      overflow: hidden;
    }

    #game-container {
      display: flex;
      flex-direction: column;
      align-items: center;
      padding: 15px;
      height: 100vh;
    }

    h1 {
      font-size: 1.2rem;
      font-weight: 400;
      letter-spacing: 4px;
      color: #0ff;
      text-shadow: 0 0 20px rgba(0, 255, 255, 0.5);
      margin-bottom: 10px;
    }

    /* HUD */
    .hud {
      display: flex;
      gap: 30px;
      margin-bottom: 10px;
      font-size: 12px;
      letter-spacing: 2px;
    }

    .hud-item {
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .hud-label {
      color: #666;
    }

    .hud-value {
      color: #0ff;
      text-shadow: 0 0 10px rgba(0, 255, 255, 0.5);
    }

    .hud-value.health {
      color: #f0f;
      text-shadow: 0 0 10px rgba(255, 0, 255, 0.5);
    }

    .hud-value.credits {
      color: #ff0;
      text-shadow: 0 0 10px rgba(255, 255, 0, 0.5);
    }

    /* Canvas */
    #gameCanvas {
      border: 1px solid #1a1a2e;
      border-radius: 4px;
      cursor: crosshair;
      box-shadow: 0 0 40px rgba(0, 255, 255, 0.1);
    }

    /* Tower selection */
    .tower-select {
      display: flex;
      gap: 15px;
      margin-top: 15px;
    }

    .tower-btn {
      background: rgba(255,255,255,0.03);
      border: 1px solid #333;
      border-radius: 8px;
      padding: 10px 20px;
      color: #888;
      font-family: 'Orbitron', sans-serif;
      font-size: 10px;
      cursor: pointer;
      transition: all 0.2s;
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 5px;
    }

    .tower-btn:hover {
      border-color: #0ff;
      color: #0ff;
      box-shadow: 0 0 20px rgba(0, 255, 255, 0.2);
    }

    .tower-btn.selected {
      border-color: #0ff;
      background: rgba(0, 255, 255, 0.1);
      color: #0ff;
    }

    .tower-btn.disabled {
      opacity: 0.3;
      cursor: not-allowed;
    }

    .tower-icon {
      font-size: 20px;
    }

    .tower-cost {
      color: #ff0;
      font-size: 9px;
    }

    /* Controls */
    .controls {
      display: flex;
      gap: 15px;
      margin-top: 15px;
    }

    .control-btn {
      background: none;
      border: 1px solid #333;
      border-radius: 4px;
      padding: 8px 20px;
      color: #666;
      font-family: 'Orbitron', sans-serif;
      font-size: 10px;
      letter-spacing: 2px;
      cursor: pointer;
      transition: all 0.2s;
    }

    .control-btn:hover {
      border-color: #f0f;
      color: #f0f;
    }

    .control-btn.start {
      border-color: #0f0;
      color: #0f0;
    }

    .control-btn.start:hover {
      background: rgba(0, 255, 0, 0.1);
      box-shadow: 0 0 20px rgba(0, 255, 0, 0.3);
    }

    /* Game over overlay */
    .overlay {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0, 0, 0, 0.9);
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      z-index: 100;
      display: none;
    }

    .overlay.show {
      display: flex;
    }

    .overlay h2 {
      font-size: 2rem;
      color: #f0f;
      text-shadow: 0 0 30px rgba(255, 0, 255, 0.8);
      margin-bottom: 20px;
      letter-spacing: 8px;
    }

    .overlay p {
      color: #666;
      font-size: 12px;
      margin-bottom: 30px;
    }

    .overlay button {
      background: none;
      border: 2px solid #0ff;
      color: #0ff;
      padding: 15px 40px;
      font-family: 'Orbitron', sans-serif;
      font-size: 12px;
      letter-spacing: 3px;
      cursor: pointer;
      transition: all 0.2s;
    }

    .overlay button:hover {
      background: rgba(0, 255, 255, 0.1);
      box-shadow: 0 0 30px rgba(0, 255, 255, 0.5);
    }

    /* Instructions */
    .instructions {
      position: fixed;
      bottom: 15px;
      left: 15px;
      font-size: 9px;
      color: #333;
      letter-spacing: 1px;
    }

    /* Backlink */
    #backlink {
      position: fixed;
      bottom: 15px;
      right: 15px;
      color: rgba(255,255,255,0.3);
      font-size: 10px;
      text-decoration: none;
      letter-spacing: 1px;
    }

    #backlink:hover {
      color: #0ff;
    }

    /* Responsive */
    @media (max-width: 800px) {
      h1 {
        font-size: 1rem;
        letter-spacing: 2px;
      }

      .hud {
        gap: 15px;
        font-size: 10px;
      }

      .tower-select {
        gap: 10px;
      }

      .tower-btn {
        padding: 8px 15px;
        font-size: 9px;
      }

      .tower-icon {
        font-size: 16px;
      }
    }
  </style>
</head>
<body>
  <div id="game-container">
    <h1>ABSTRACT DEFENSE</h1>

    <div class="hud">
      <div class="hud-item">
        <span class="hud-label">WAVE</span>
        <span class="hud-value" id="wave">1</span>
      </div>
      <div class="hud-item">
        <span class="hud-label">HEALTH</span>
        <span class="hud-value health" id="health">20</span>
      </div>
      <div class="hud-item">
        <span class="hud-label">CREDITS</span>
        <span class="hud-value credits" id="credits">250</span>
      </div>
    </div>

    <canvas id="gameCanvas"></canvas>

    <div class="tower-select">
      <button class="tower-btn selected" data-tower="basic" data-cost="50">
        <span class="tower-icon">â–²</span>
        <span>BASIC</span>
        <span class="tower-cost">50c</span>
      </button>
      <button class="tower-btn" data-tower="rapid" data-cost="100">
        <span class="tower-icon">â–²â–²</span>
        <span>RAPID</span>
        <span class="tower-cost">100c</span>
      </button>
      <button class="tower-btn" data-tower="sniper" data-cost="150">
        <span class="tower-icon">â—†</span>
        <span>SNIPER</span>
        <span class="tower-cost">150c</span>
      </button>
    </div>

    <div class="controls">
      <button class="control-btn start" id="startWave">START WAVE</button>
    </div>
  </div>

  <div class="overlay" id="gameOver">
    <h2>SYSTEM FAILURE</h2>
    <p>WAVES SURVIVED: <span id="finalWave">0</span></p>
    <button id="restartBtn">REINITIALIZE</button>
  </div>

  <div class="instructions">CLICK TO PLACE TOWERS ON DARK AREAS</div>
  <a href="https://sloppy.live" id="backlink">sloppy.live</a>

  <script>
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');

    // Responsive canvas size
    function resizeCanvas() {
      const maxWidth = Math.min(window.innerWidth - 30, 800);
      const maxHeight = Math.min(window.innerHeight - 250, 500);
      canvas.width = maxWidth;
      canvas.height = maxHeight;
    }
    resizeCanvas();
    window.addEventListener('resize', resizeCanvas);

    // Game state
    let gameState = {
      wave: 1,
      health: 20,
      credits: 250,
      waveActive: false,
      gameOver: false,
      selectedTower: 'basic',
      towers: [],
      enemies: [],
      projectiles: [],
      particles: [],
      enemiesSpawned: 0,
      enemiesToSpawn: 0
    };

    // Tower types
    const towerTypes = {
      basic: { range: 100, damage: 1, fireRate: 60, color: '#0ff', cost: 50 },
      rapid: { range: 80, damage: 0.5, fireRate: 20, color: '#0f0', cost: 100 },
      sniper: { range: 200, damage: 3, fireRate: 120, color: '#f0f', cost: 150 }
    };

    // Path waypoints (relative to canvas size)
    function getPath() {
      const w = canvas.width;
      const h = canvas.height;
      return [
        { x: 0, y: h * 0.3 },
        { x: w * 0.25, y: h * 0.3 },
        { x: w * 0.25, y: h * 0.7 },
        { x: w * 0.5, y: h * 0.7 },
        { x: w * 0.5, y: h * 0.3 },
        { x: w * 0.75, y: h * 0.3 },
        { x: w * 0.75, y: h * 0.7 },
        { x: w, y: h * 0.7 }
      ];
    }

    // DOM elements
    const waveEl = document.getElementById('wave');
    const healthEl = document.getElementById('health');
    const creditsEl = document.getElementById('credits');
    const startWaveBtn = document.getElementById('startWave');
    const gameOverEl = document.getElementById('gameOver');
    const finalWaveEl = document.getElementById('finalWave');
    const restartBtn = document.getElementById('restartBtn');
    const towerBtns = document.querySelectorAll('.tower-btn');

    // Update HUD
    function updateHUD() {
      waveEl.textContent = gameState.wave;
      healthEl.textContent = gameState.health;
      creditsEl.textContent = gameState.credits;

      // Update tower button states
      towerBtns.forEach(btn => {
        const cost = parseInt(btn.dataset.cost);
        if (gameState.credits < cost) {
          btn.classList.add('disabled');
        } else {
          btn.classList.remove('disabled');
        }
      });
    }

    // Draw path
    function drawPath() {
      const path = getPath();
      ctx.strokeStyle = '#1a1a2e';
      ctx.lineWidth = 40;
      ctx.lineCap = 'round';
      ctx.lineJoin = 'round';
      ctx.beginPath();
      ctx.moveTo(path[0].x, path[0].y);
      for (let i = 1; i < path.length; i++) {
        ctx.lineTo(path[i].x, path[i].y);
      }
      ctx.stroke();

      // Path glow
      ctx.strokeStyle = 'rgba(100, 100, 150, 0.1)';
      ctx.lineWidth = 60;
      ctx.stroke();
    }

    // Draw tower
    function drawTower(tower) {
      const type = towerTypes[tower.type];
      ctx.save();
      ctx.translate(tower.x, tower.y);
      ctx.rotate(tower.angle);

      // Glow
      ctx.shadowColor = type.color;
      ctx.shadowBlur = 15;

      // Triangle shape
      ctx.fillStyle = type.color;
      ctx.beginPath();
      if (tower.type === 'sniper') {
        // Diamond for sniper
        ctx.moveTo(0, -15);
        ctx.lineTo(12, 0);
        ctx.lineTo(0, 15);
        ctx.lineTo(-12, 0);
      } else {
        ctx.moveTo(0, -15);
        ctx.lineTo(12, 12);
        ctx.lineTo(-12, 12);
      }
      ctx.closePath();
      ctx.fill();

      // Range indicator when placing
      if (tower.showRange) {
        ctx.strokeStyle = `${type.color}33`;
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.arc(0, 0, type.range, 0, Math.PI * 2);
        ctx.stroke();
      }

      ctx.restore();
    }

    // Draw enemy
    function drawEnemy(enemy) {
      ctx.save();

      // Glow
      ctx.shadowColor = enemy.color;
      ctx.shadowBlur = 20;

      // Circle
      ctx.fillStyle = enemy.color;
      ctx.beginPath();
      ctx.arc(enemy.x, enemy.y, enemy.radius, 0, Math.PI * 2);
      ctx.fill();

      // Health bar
      if (enemy.health < enemy.maxHealth) {
        ctx.shadowBlur = 0;
        ctx.fillStyle = '#333';
        ctx.fillRect(enemy.x - 15, enemy.y - enemy.radius - 8, 30, 4);
        ctx.fillStyle = enemy.color;
        ctx.fillRect(enemy.x - 15, enemy.y - enemy.radius - 8, 30 * (enemy.health / enemy.maxHealth), 4);
      }

      ctx.restore();
    }

    // Draw projectile
    function drawProjectile(proj) {
      ctx.save();
      ctx.shadowColor = proj.color;
      ctx.shadowBlur = 10;
      ctx.fillStyle = proj.color;
      ctx.beginPath();
      ctx.arc(proj.x, proj.y, 3, 0, Math.PI * 2);
      ctx.fill();
      ctx.restore();
    }

    // Draw particle
    function drawParticle(particle) {
      ctx.save();
      ctx.globalAlpha = particle.life;
      ctx.fillStyle = particle.color;
      ctx.beginPath();
      ctx.arc(particle.x, particle.y, particle.size, 0, Math.PI * 2);
      ctx.fill();
      ctx.restore();
    }

    // Spawn enemy
    function spawnEnemy() {
      const path = getPath();
      const baseHealth = 3 + gameState.wave * 2;
      const speed = 1 + gameState.wave * 0.1;
      const colors = ['#f00', '#f80', '#ff0', '#f0f'];

      gameState.enemies.push({
        x: path[0].x,
        y: path[0].y,
        radius: 10 + Math.random() * 5,
        health: baseHealth,
        maxHealth: baseHealth,
        speed: speed,
        pathIndex: 0,
        color: colors[Math.floor(Math.random() * colors.length)],
        reward: 10 + gameState.wave * 2
      });
    }

    // Move enemy along path
    function moveEnemy(enemy) {
      const path = getPath();
      if (enemy.pathIndex >= path.length - 1) {
        // Reached end
        gameState.health--;
        createParticles(enemy.x, enemy.y, '#f00', 10);
        return false;
      }

      const target = path[enemy.pathIndex + 1];
      const dx = target.x - enemy.x;
      const dy = target.y - enemy.y;
      const dist = Math.sqrt(dx * dx + dy * dy);

      if (dist < enemy.speed) {
        enemy.pathIndex++;
      } else {
        enemy.x += (dx / dist) * enemy.speed;
        enemy.y += (dy / dist) * enemy.speed;
      }

      return true;
    }

    // Tower targeting and shooting
    function updateTower(tower) {
      const type = towerTypes[tower.type];
      tower.cooldown--;

      // Find target
      let target = null;
      let minDist = type.range;

      gameState.enemies.forEach(enemy => {
        const dx = enemy.x - tower.x;
        const dy = enemy.y - tower.y;
        const dist = Math.sqrt(dx * dx + dy * dy);
        if (dist < minDist) {
          minDist = dist;
          target = enemy;
        }
      });

      if (target) {
        // Rotate towards target
        tower.angle = Math.atan2(target.y - tower.y, target.x - tower.x) + Math.PI / 2;

        // Shoot
        if (tower.cooldown <= 0) {
          tower.cooldown = type.fireRate;
          gameState.projectiles.push({
            x: tower.x,
            y: tower.y,
            targetX: target.x,
            targetY: target.y,
            speed: 8,
            damage: type.damage,
            color: type.color
          });
        }
      }
    }

    // Update projectile
    function updateProjectile(proj) {
      const dx = proj.targetX - proj.x;
      const dy = proj.targetY - proj.y;
      const dist = Math.sqrt(dx * dx + dy * dy);

      if (dist < proj.speed) {
        // Hit check
        gameState.enemies.forEach(enemy => {
          const edx = enemy.x - proj.x;
          const edy = enemy.y - proj.y;
          const edist = Math.sqrt(edx * edx + edy * edy);
          if (edist < enemy.radius + 5) {
            enemy.health -= proj.damage;
            createParticles(enemy.x, enemy.y, proj.color, 3);
          }
        });
        return false;
      }

      proj.x += (dx / dist) * proj.speed;
      proj.y += (dy / dist) * proj.speed;
      return true;
    }

    // Create particles
    function createParticles(x, y, color, count) {
      for (let i = 0; i < count; i++) {
        gameState.particles.push({
          x: x,
          y: y,
          vx: (Math.random() - 0.5) * 4,
          vy: (Math.random() - 0.5) * 4,
          life: 1,
          color: color,
          size: 2 + Math.random() * 3
        });
      }
    }

    // Update particle
    function updateParticle(particle) {
      particle.x += particle.vx;
      particle.y += particle.vy;
      particle.life -= 0.03;
      return particle.life > 0;
    }

    // Check if position is on path
    function isOnPath(x, y) {
      const path = getPath();
      for (let i = 0; i < path.length - 1; i++) {
        const p1 = path[i];
        const p2 = path[i + 1];
        const dist = pointToSegmentDist(x, y, p1.x, p1.y, p2.x, p2.y);
        if (dist < 30) return true;
      }
      return false;
    }

    // Point to line segment distance
    function pointToSegmentDist(px, py, x1, y1, x2, y2) {
      const dx = x2 - x1;
      const dy = y2 - y1;
      const t = Math.max(0, Math.min(1, ((px - x1) * dx + (py - y1) * dy) / (dx * dx + dy * dy)));
      const nearX = x1 + t * dx;
      const nearY = y1 + t * dy;
      return Math.sqrt((px - nearX) ** 2 + (py - nearY) ** 2);
    }

    // Place tower
    function placeTower(x, y) {
      const type = towerTypes[gameState.selectedTower];
      if (gameState.credits < type.cost) return;
      if (isOnPath(x, y)) return;

      // Check not too close to other towers
      for (const tower of gameState.towers) {
        const dx = tower.x - x;
        const dy = tower.y - y;
        if (Math.sqrt(dx * dx + dy * dy) < 40) return;
      }

      gameState.towers.push({
        x: x,
        y: y,
        type: gameState.selectedTower,
        angle: 0,
        cooldown: 0,
        showRange: false
      });

      gameState.credits -= type.cost;
      updateHUD();
    }

    // Canvas click handler
    canvas.addEventListener('click', (e) => {
      if (gameState.gameOver) return;
      const rect = canvas.getBoundingClientRect();
      const x = e.clientX - rect.left;
      const y = e.clientY - rect.top;
      placeTower(x, y);
    });

    // Tower selection
    towerBtns.forEach(btn => {
      btn.addEventListener('click', () => {
        if (btn.classList.contains('disabled')) return;
        towerBtns.forEach(b => b.classList.remove('selected'));
        btn.classList.add('selected');
        gameState.selectedTower = btn.dataset.tower;
      });
    });

    // Start wave
    startWaveBtn.addEventListener('click', () => {
      if (gameState.waveActive) return;
      gameState.waveActive = true;
      gameState.enemiesSpawned = 0;
      gameState.enemiesToSpawn = 5 + gameState.wave * 3;
      startWaveBtn.style.opacity = '0.5';
    });

    // Restart game
    restartBtn.addEventListener('click', () => {
      gameState = {
        wave: 1,
        health: 20,
        credits: 250,
        waveActive: false,
        gameOver: false,
        selectedTower: 'basic',
        towers: [],
        enemies: [],
        projectiles: [],
        particles: [],
        enemiesSpawned: 0,
        enemiesToSpawn: 0
      };
      gameOverEl.classList.remove('show');
      startWaveBtn.style.opacity = '1';
      updateHUD();
    });

    // Main game loop
    let spawnTimer = 0;
    function gameLoop() {
      // Clear
      ctx.fillStyle = '#0a0a0f';
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      // Draw path
      drawPath();

      // Spawn enemies
      if (gameState.waveActive && gameState.enemiesSpawned < gameState.enemiesToSpawn) {
        spawnTimer++;
        if (spawnTimer > 40) {
          spawnEnemy();
          gameState.enemiesSpawned++;
          spawnTimer = 0;
        }
      }

      // Update and draw enemies
      gameState.enemies = gameState.enemies.filter(enemy => {
        if (enemy.health <= 0) {
          gameState.credits += enemy.reward;
          createParticles(enemy.x, enemy.y, enemy.color, 15);
          updateHUD();
          return false;
        }
        const alive = moveEnemy(enemy);
        if (alive) drawEnemy(enemy);
        return alive;
      });

      // Check wave complete
      if (gameState.waveActive && gameState.enemiesSpawned >= gameState.enemiesToSpawn && gameState.enemies.length === 0) {
        gameState.waveActive = false;
        gameState.wave++;
        gameState.credits += 25; // Wave bonus
        startWaveBtn.style.opacity = '1';
        updateHUD();
      }

      // Update and draw towers
      gameState.towers.forEach(tower => {
        updateTower(tower);
        drawTower(tower);
      });

      // Update and draw projectiles
      gameState.projectiles = gameState.projectiles.filter(proj => {
        const alive = updateProjectile(proj);
        if (alive) drawProjectile(proj);
        return alive;
      });

      // Update and draw particles
      gameState.particles = gameState.particles.filter(particle => {
        const alive = updateParticle(particle);
        if (alive) drawParticle(particle);
        return alive;
      });

      // Check game over
      if (gameState.health <= 0 && !gameState.gameOver) {
        gameState.gameOver = true;
        finalWaveEl.textContent = gameState.wave;
        gameOverEl.classList.add('show');
      }

      updateHUD();
      requestAnimationFrame(gameLoop);
    }

    // Start
    updateHUD();
    gameLoop();
  </script>
<script src="/sloppy-header/sloppy-bar.js"></script>
</body>
</html>
