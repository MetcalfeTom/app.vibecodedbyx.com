<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
  <title>The Purple Trap</title>
  <meta name="description" content="Dodge neon ghosts and collect springlocks in a glitchy factory">
  <meta property="og:title" content="The Purple Trap">
  <meta property="og:description" content="2D arcade game - dodge ghosts, collect springlocks, survive the factory">
  <meta property="og:url" content="https://sloppy.live/purple-trap/">
  <meta property="og:image" content="https://emojicdn.elk.sh/üëæ">
  <link rel="icon" href="https://emojicdn.elk.sh/üíú">
  <style>
    @import url('https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap');

    * { margin: 0; padding: 0; box-sizing: border-box; }

    body {
      background: #0a0a12;
      min-height: 100vh;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      font-family: 'Press Start 2P', monospace;
      overflow: hidden;
    }

    #game-container {
      position: relative;
      border: 4px solid #6600aa;
      box-shadow: 0 0 30px #6600aa, 0 0 60px #6600aa44, inset 0 0 30px #00000088;
    }

    #gameCanvas {
      display: block;
      background: #0a0a12;
    }

    #ui {
      position: absolute;
      top: 10px;
      left: 10px;
      right: 10px;
      display: flex;
      justify-content: space-between;
      color: #0ff;
      font-size: 12px;
      text-shadow: 0 0 10px #0ff;
      pointer-events: none;
      z-index: 10;
    }

    #score { color: #ff0; text-shadow: 0 0 10px #ff0; }
    #lives { color: #f0f; text-shadow: 0 0 10px #f0f; }
    #level { color: #0f0; text-shadow: 0 0 10px #0f0; }

    #start-screen, #game-over-screen {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(10, 10, 18, 0.95);
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      z-index: 100;
      text-align: center;
      padding: 20px;
    }

    #start-screen h1, #game-over-screen h1 {
      color: #6600aa;
      font-size: 24px;
      text-shadow: 0 0 20px #6600aa, 0 0 40px #6600aa;
      margin-bottom: 20px;
      animation: pulse 2s ease-in-out infinite;
    }

    @keyframes pulse {
      0%, 100% { text-shadow: 0 0 20px #6600aa, 0 0 40px #6600aa; }
      50% { text-shadow: 0 0 30px #9900ff, 0 0 60px #9900ff; }
    }

    #start-screen p, #game-over-screen p {
      color: #888;
      font-size: 10px;
      margin: 10px 0;
      line-height: 1.8;
    }

    .btn {
      background: linear-gradient(180deg, #6600aa, #440066);
      border: 2px solid #9900ff;
      color: #fff;
      padding: 15px 30px;
      font-family: 'Press Start 2P', monospace;
      font-size: 14px;
      cursor: pointer;
      margin-top: 20px;
      text-shadow: 0 0 10px #fff;
      box-shadow: 0 0 20px #6600aa;
      transition: all 0.2s;
    }

    .btn:hover {
      background: linear-gradient(180deg, #9900ff, #6600aa);
      box-shadow: 0 0 30px #9900ff;
      transform: scale(1.05);
    }

    #final-score {
      color: #ff0;
      font-size: 18px;
      text-shadow: 0 0 20px #ff0;
      margin: 15px 0;
    }

    #controls-hint {
      color: #666;
      font-size: 8px;
      margin-top: 20px;
    }

    #mobile-controls {
      display: none;
      position: fixed;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      z-index: 200;
    }

    .mobile-btn {
      width: 60px;
      height: 60px;
      background: rgba(102, 0, 170, 0.5);
      border: 2px solid #9900ff;
      border-radius: 10px;
      color: #fff;
      font-size: 24px;
      margin: 5px;
      touch-action: manipulation;
    }

    .mobile-row {
      display: flex;
      justify-content: center;
    }

    #backlink {
      position: fixed;
      bottom: 10px;
      left: 10px;
      z-index: 100;
    }

    #backlink a {
      color: #6600aa;
      text-decoration: none;
      font-size: 8px;
      opacity: 0.7;
    }

    @media (max-width: 600px) {
      #ui { font-size: 10px; }
      #start-screen h1, #game-over-screen h1 { font-size: 18px; }
      #start-screen p, #game-over-screen p { font-size: 8px; }
      .btn { font-size: 12px; padding: 12px 24px; }
      #mobile-controls { display: block; }
    }

    /* Glitch effect */
    @keyframes glitch {
      0%, 90%, 100% { transform: translate(0); }
      92% { transform: translate(-2px, 1px); }
      94% { transform: translate(2px, -1px); }
      96% { transform: translate(-1px, 2px); }
      98% { transform: translate(1px, -2px); }
    }

    .glitch {
      animation: glitch 3s infinite;
    }
  </style>
</head>
<body>
  <div id="game-container">
    <canvas id="gameCanvas"></canvas>

    <div id="ui">
      <span id="score">SCORE: 0</span>
      <span id="level">LEVEL 1</span>
      <span id="lives">LIVES: 3</span>
    </div>

    <div id="start-screen">
      <h1 class="glitch">THE PURPLE TRAP</h1>
      <p>You are the PURPLE GUY</p>
      <p>Collect SPRINGLOCKS to score</p>
      <p>Avoid the GHOST CHILDREN</p>
      <p style="color:#ff0;">KEEP MOVING or suffer SPRINGLOCK FAILURE!</p>
      <p>They remember what you did...</p>
      <button class="btn" onclick="startGame()">START GAME</button>
      <div id="controls-hint">Arrow Keys / WASD to move</div>
    </div>

    <div id="game-over-screen" style="display: none;">
      <h1>GAME OVER</h1>
      <p>The children got their revenge...</p>
      <div id="final-score">SCORE: 0</div>
      <button class="btn" onclick="startGame()">TRY AGAIN</button>
    </div>
  </div>

  <div id="mobile-controls">
    <div class="mobile-row">
      <button class="mobile-btn" id="btn-up">‚ñ≤</button>
    </div>
    <div class="mobile-row">
      <button class="mobile-btn" id="btn-left">‚óÄ</button>
      <button class="mobile-btn" id="btn-down">‚ñº</button>
      <button class="mobile-btn" id="btn-right">‚ñ∂</button>
    </div>
  </div>

  <div id="backlink">
    <a href="https://sloppy.live">‚Üê sloppy.live</a>
  </div>

  <script>
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');

    // Responsive canvas size
    const maxWidth = Math.min(800, window.innerWidth - 20);
    const maxHeight = Math.min(600, window.innerHeight - 150);
    canvas.width = maxWidth;
    canvas.height = maxHeight;

    // Game state
    let gameRunning = false;
    let score = 0;
    let lives = 3;
    let level = 1;
    let glitchIntensity = 0;
    let frameCount = 0;

    // Player (Purple Guy)
    const player = {
      x: canvas.width / 2,
      y: canvas.height / 2,
      width: 30,
      height: 40,
      speed: 4,
      color: '#6600aa',
      dx: 0,
      dy: 0,
      stillTimer: 0,
      maxStillTime: 180, // 3 seconds at 60fps
      springlockWarning: false,
      springlockFailure: false,
      failureFrame: 0
    };

    // Audio context for crunch sound
    let audioCtx = null;

    function playSpringlockCrunch() {
      if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();

      // Create brutal crunch sound
      const duration = 0.8;
      const now = audioCtx.currentTime;

      // Multiple noise bursts for crunch effect
      for (let i = 0; i < 5; i++) {
        const noise = audioCtx.createBufferSource();
        const bufferSize = audioCtx.sampleRate * 0.15;
        const buffer = audioCtx.createBuffer(1, bufferSize, audioCtx.sampleRate);
        const data = buffer.getChannelData(0);

        for (let j = 0; j < bufferSize; j++) {
          data[j] = (Math.random() * 2 - 1) * Math.exp(-j / (bufferSize * 0.3));
        }

        noise.buffer = buffer;

        const filter = audioCtx.createBiquadFilter();
        filter.type = 'lowpass';
        filter.frequency.value = 800 - i * 100;

        const gain = audioCtx.createGain();
        gain.gain.setValueAtTime(0.8 - i * 0.1, now + i * 0.1);
        gain.gain.exponentialDecayTo = 0.01;
        gain.gain.setValueAtTime(0.01, now + i * 0.1 + 0.15);

        noise.connect(filter);
        filter.connect(gain);
        gain.connect(audioCtx.destination);

        noise.start(now + i * 0.08);
      }

      // Low thud
      const osc = audioCtx.createOscillator();
      osc.type = 'sine';
      osc.frequency.setValueAtTime(60, now);
      osc.frequency.exponentialRampToValueAtTime(20, now + 0.3);

      const oscGain = audioCtx.createGain();
      oscGain.gain.setValueAtTime(0.8, now);
      oscGain.gain.exponentialRampToValueAtTime(0.01, now + 0.4);

      osc.connect(oscGain);
      oscGain.connect(audioCtx.destination);
      osc.start(now);
      osc.stop(now + 0.5);

      // Metal screech
      const screech = audioCtx.createOscillator();
      screech.type = 'sawtooth';
      screech.frequency.setValueAtTime(2000, now + 0.1);
      screech.frequency.exponentialRampToValueAtTime(500, now + 0.4);

      const screechGain = audioCtx.createGain();
      screechGain.gain.setValueAtTime(0.15, now + 0.1);
      screechGain.gain.exponentialRampToValueAtTime(0.01, now + 0.5);

      screech.connect(screechGain);
      screechGain.connect(audioCtx.destination);
      screech.start(now + 0.1);
      screech.stop(now + 0.5);
    }

    // Ghost children (the 5 victims)
    const ghostData = [
      { color: '#00ffff', name: 'Gabriel' },
      { color: '#ff00ff', name: 'Jeremy' },
      { color: '#ffff00', name: 'Susie' },
      { color: '#ff0000', name: 'Fritz' },
      { color: '#ffffff', name: 'Cassidy' }
    ];

    let ghosts = [];
    let springlocks = [];

    // Input handling
    const keys = {};

    document.addEventListener('keydown', (e) => {
      keys[e.key.toLowerCase()] = true;
      if (['arrowup', 'arrowdown', 'arrowleft', 'arrowright', 'w', 'a', 's', 'd'].includes(e.key.toLowerCase())) {
        e.preventDefault();
      }
    });

    document.addEventListener('keyup', (e) => {
      keys[e.key.toLowerCase()] = false;
    });

    // Mobile controls
    const mobileButtons = {
      'btn-up': { key: 'arrowup' },
      'btn-down': { key: 'arrowdown' },
      'btn-left': { key: 'arrowleft' },
      'btn-right': { key: 'arrowright' }
    };

    Object.keys(mobileButtons).forEach(id => {
      const btn = document.getElementById(id);
      if (btn) {
        btn.addEventListener('touchstart', (e) => {
          e.preventDefault();
          keys[mobileButtons[id].key] = true;
        });
        btn.addEventListener('touchend', (e) => {
          e.preventDefault();
          keys[mobileButtons[id].key] = false;
        });
      }
    });

    function createGhost(index) {
      const data = ghostData[index % ghostData.length];
      const side = Math.floor(Math.random() * 4);
      let x, y;

      switch(side) {
        case 0: x = Math.random() * canvas.width; y = -30; break;
        case 1: x = canvas.width + 30; y = Math.random() * canvas.height; break;
        case 2: x = Math.random() * canvas.width; y = canvas.height + 30; break;
        case 3: x = -30; y = Math.random() * canvas.height; break;
      }

      return {
        x, y,
        width: 25,
        height: 30,
        speed: 1.5 + level * 0.3 + Math.random() * 0.5,
        color: data.color,
        name: data.name,
        wobble: Math.random() * Math.PI * 2,
        alpha: 0.8
      };
    }

    function createSpringlock() {
      return {
        x: 50 + Math.random() * (canvas.width - 100),
        y: 50 + Math.random() * (canvas.height - 100),
        width: 20,
        height: 25,
        collected: false,
        glow: 0
      };
    }

    function initGame() {
      player.x = canvas.width / 2;
      player.y = canvas.height / 2;
      ghosts = [];
      springlocks = [];

      // Spawn initial ghosts based on level
      for (let i = 0; i < Math.min(level + 2, 5); i++) {
        ghosts.push(createGhost(i));
      }

      // Spawn springlocks
      for (let i = 0; i < 5; i++) {
        springlocks.push(createSpringlock());
      }
    }

    function updatePlayer() {
      // Handle springlock failure animation
      if (player.springlockFailure) {
        player.failureFrame++;
        if (player.failureFrame > 90) { // 1.5 seconds of death animation
          lives--;
          document.getElementById('lives').textContent = `LIVES: ${lives}`;

          if (lives <= 0) {
            gameOver();
            return;
          }

          // Reset player
          player.springlockFailure = false;
          player.failureFrame = 0;
          player.stillTimer = 0;
          player.x = canvas.width / 2;
          player.y = canvas.height / 2;

          // Push ghosts away
          ghosts.forEach(g => {
            g.x = g.x < canvas.width / 2 ? -30 : canvas.width + 30;
            g.y = g.y < canvas.height / 2 ? -30 : canvas.height + 30;
          });
        }
        return; // Don't process movement during failure
      }

      player.dx = 0;
      player.dy = 0;

      if (keys['arrowup'] || keys['w']) player.dy = -player.speed;
      if (keys['arrowdown'] || keys['s']) player.dy = player.speed;
      if (keys['arrowleft'] || keys['a']) player.dx = -player.speed;
      if (keys['arrowright'] || keys['d']) player.dx = player.speed;

      // Normalize diagonal movement
      if (player.dx !== 0 && player.dy !== 0) {
        player.dx *= 0.707;
        player.dy *= 0.707;
      }

      // Track stillness for springlock failure
      if (player.dx === 0 && player.dy === 0) {
        player.stillTimer++;
        player.springlockWarning = player.stillTimer > player.maxStillTime * 0.5;

        // SPRINGLOCK FAILURE!
        if (player.stillTimer >= player.maxStillTime) {
          player.springlockFailure = true;
          player.failureFrame = 0;
          glitchIntensity = 50;
          playSpringlockCrunch();
        }
      } else {
        player.stillTimer = 0;
        player.springlockWarning = false;
      }

      player.x += player.dx;
      player.y += player.dy;

      // Boundary check
      player.x = Math.max(0, Math.min(canvas.width - player.width, player.x));
      player.y = Math.max(0, Math.min(canvas.height - player.height, player.y));
    }

    function updateGhosts() {
      ghosts.forEach(ghost => {
        // Move toward player
        const dx = player.x - ghost.x;
        const dy = player.y - ghost.y;
        const dist = Math.sqrt(dx * dx + dy * dy);

        if (dist > 0) {
          ghost.x += (dx / dist) * ghost.speed;
          ghost.y += (dy / dist) * ghost.speed;
        }

        // Wobble effect
        ghost.wobble += 0.1;
        ghost.x += Math.sin(ghost.wobble) * 0.5;
        ghost.y += Math.cos(ghost.wobble * 0.7) * 0.3;

        // Flicker alpha
        ghost.alpha = 0.6 + Math.sin(frameCount * 0.1 + ghost.wobble) * 0.3;
      });
    }

    function checkCollisions() {
      // Check ghost collisions
      for (const ghost of ghosts) {
        if (rectCollision(player, ghost)) {
          lives--;
          document.getElementById('lives').textContent = `LIVES: ${lives}`;
          glitchIntensity = 20;

          if (lives <= 0) {
            gameOver();
            return;
          }

          // Reset player position
          player.x = canvas.width / 2;
          player.y = canvas.height / 2;

          // Push ghosts away
          ghosts.forEach(g => {
            g.x = g.x < canvas.width / 2 ? -30 : canvas.width + 30;
            g.y = g.y < canvas.height / 2 ? -30 : canvas.height + 30;
          });
          break;
        }
      }

      // Check springlock collection
      springlocks.forEach(spring => {
        if (!spring.collected && rectCollision(player, spring)) {
          spring.collected = true;
          score += 100 * level;
          document.getElementById('score').textContent = `SCORE: ${score}`;

          // Check level up
          if (springlocks.every(s => s.collected)) {
            levelUp();
          }
        }
      });
    }

    function rectCollision(a, b) {
      return a.x < b.x + b.width &&
             a.x + a.width > b.x &&
             a.y < b.y + b.height &&
             a.y + a.height > b.y;
    }

    function levelUp() {
      level++;
      document.getElementById('level').textContent = `LEVEL ${level}`;
      glitchIntensity = 30;

      // Reset springlocks
      springlocks = [];
      for (let i = 0; i < 5 + level; i++) {
        springlocks.push(createSpringlock());
      }

      // Add more ghosts (up to 5)
      if (ghosts.length < 5) {
        ghosts.push(createGhost(ghosts.length));
      }

      // Speed up existing ghosts
      ghosts.forEach(g => g.speed += 0.2);
    }

    // Game over animation state
    let gameOverActive = false;
    let gameOverFrame = 0;
    const gameOverDuration = 600; // 10 seconds at 60fps
    let bloodDrops = [];

    function gameOver() {
      gameRunning = false;
      gameOverActive = true;
      gameOverFrame = 0;
      bloodDrops = [];
      glitchIntensity = 30;

      // Play extended crunch sound
      playSpringlockCrunch();

      // Start the death animation loop
      requestAnimationFrame(gameOverAnimation);
    }

    function gameOverAnimation() {
      if (!gameOverActive) return;

      gameOverFrame++;

      // Draw dark background
      ctx.fillStyle = '#0a0a12';
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      // Glitch effect
      if (Math.random() < 0.1) {
        ctx.fillStyle = `rgba(255, 0, 0, 0.1)`;
        ctx.fillRect(0, Math.random() * canvas.height, canvas.width, 10 + Math.random() * 30);
      }

      // Screen shake
      ctx.save();
      if (gameOverFrame < 60) {
        ctx.translate((Math.random() - 0.5) * 15, (Math.random() - 0.5) * 15);
      } else if (Math.random() < 0.05) {
        ctx.translate((Math.random() - 0.5) * 5, (Math.random() - 0.5) * 5);
      }

      // Draw the golden suit in center
      const suitX = canvas.width / 2 - 40;
      const suitY = canvas.height / 2 - 60;
      const suitWidth = 80;
      const suitHeight = 120;

      // Suit glow
      ctx.shadowColor = '#ffd700';
      ctx.shadowBlur = 20 + Math.sin(gameOverFrame * 0.1) * 10;

      // Golden suit body
      ctx.fillStyle = '#ffd700';
      ctx.fillRect(suitX + 10, suitY + 40, suitWidth - 20, suitHeight - 40);

      // Suit head
      ctx.beginPath();
      ctx.arc(suitX + suitWidth / 2, suitY + 30, 30, 0, Math.PI * 2);
      ctx.fill();

      // Ears
      ctx.fillRect(suitX + 5, suitY - 10, 15, 35);
      ctx.fillRect(suitX + suitWidth - 20, suitY - 10, 15, 35);

      // Dark interior (showing crushed purple guy)
      ctx.fillStyle = '#1a1a1a';
      ctx.fillRect(suitX + 20, suitY + 50, suitWidth - 40, suitHeight - 60);

      // Purple remains inside
      ctx.fillStyle = '#440066';
      ctx.globalAlpha = 0.7;
      ctx.fillRect(suitX + 25, suitY + 55, suitWidth - 50, suitHeight - 70);
      ctx.globalAlpha = 1;

      // Menacing red eyes
      ctx.fillStyle = '#ff0000';
      ctx.shadowColor = '#ff0000';
      ctx.shadowBlur = 15 + Math.sin(gameOverFrame * 0.2) * 10;
      ctx.beginPath();
      ctx.arc(suitX + 28, suitY + 25, 8, 0, Math.PI * 2);
      ctx.fill();
      ctx.beginPath();
      ctx.arc(suitX + suitWidth - 28, suitY + 25, 8, 0, Math.PI * 2);
      ctx.fill();

      // Evil smile
      ctx.fillStyle = '#000';
      ctx.shadowBlur = 0;
      ctx.beginPath();
      ctx.arc(suitX + suitWidth / 2, suitY + 40, 15, 0.1 * Math.PI, 0.9 * Math.PI);
      ctx.fill();

      // === RED LIQUID POURING OUT ===
      // Create new blood drops from multiple points
      if (gameOverFrame % 3 === 0) {
        // From seams of suit
        const dropPoints = [
          { x: suitX + 15, y: suitY + 60 },
          { x: suitX + suitWidth - 15, y: suitY + 60 },
          { x: suitX + suitWidth / 2 - 10, y: suitY + suitHeight },
          { x: suitX + suitWidth / 2 + 10, y: suitY + suitHeight },
          { x: suitX + 20, y: suitY + suitHeight - 10 },
          { x: suitX + suitWidth - 20, y: suitY + suitHeight - 10 },
        ];

        dropPoints.forEach(point => {
          if (Math.random() < 0.5) {
            bloodDrops.push({
              x: point.x + (Math.random() - 0.5) * 10,
              y: point.y,
              vx: (Math.random() - 0.5) * 2,
              vy: 2 + Math.random() * 3,
              size: 3 + Math.random() * 5,
              alpha: 1
            });
          }
        });
      }

      // Update and draw blood drops
      ctx.shadowColor = '#ff0000';
      ctx.shadowBlur = 5;
      bloodDrops.forEach((drop, i) => {
        drop.x += drop.vx;
        drop.y += drop.vy;
        drop.vy += 0.2; // gravity
        drop.alpha -= 0.005;

        if (drop.alpha > 0 && drop.y < canvas.height + 50) {
          ctx.fillStyle = `rgba(180, 0, 0, ${drop.alpha})`;
          ctx.beginPath();
          ctx.ellipse(drop.x, drop.y, drop.size * 0.6, drop.size, 0, 0, Math.PI * 2);
          ctx.fill();

          // Blood trail
          ctx.fillStyle = `rgba(120, 0, 0, ${drop.alpha * 0.5})`;
          ctx.fillRect(drop.x - 1, drop.y - drop.vy * 2, 2, drop.vy * 2);
        }
      });

      // Blood pool at bottom
      const poolSize = Math.min(gameOverFrame * 0.5, 200);
      const poolAlpha = Math.min(gameOverFrame / 100, 0.8);
      ctx.fillStyle = `rgba(100, 0, 0, ${poolAlpha})`;
      ctx.beginPath();
      ctx.ellipse(canvas.width / 2, suitY + suitHeight + 30, poolSize, poolSize * 0.3, 0, 0, Math.PI * 2);
      ctx.fill();

      // Darker center of pool
      ctx.fillStyle = `rgba(60, 0, 0, ${poolAlpha})`;
      ctx.beginPath();
      ctx.ellipse(canvas.width / 2, suitY + suitHeight + 30, poolSize * 0.6, poolSize * 0.2, 0, 0, Math.PI * 2);
      ctx.fill();

      ctx.restore();

      // Draw text
      ctx.save();
      ctx.font = '24px "Press Start 2P"';
      ctx.textAlign = 'center';

      // "GAME OVER" text with glitch
      if (gameOverFrame > 30) {
        ctx.fillStyle = '#ff0000';
        ctx.shadowColor = '#ff0000';
        ctx.shadowBlur = 20;

        const glitchOffset = Math.random() < 0.1 ? (Math.random() - 0.5) * 10 : 0;
        ctx.fillText('GAME OVER', canvas.width / 2 + glitchOffset, 60);
      }

      // Creepy messages
      if (gameOverFrame > 120 && gameOverFrame < 250) {
        ctx.font = '14px "Press Start 2P"';
        ctx.fillStyle = `rgba(255, 0, 0, ${0.5 + Math.sin(gameOverFrame * 0.1) * 0.3})`;
        ctx.fillText('THE SUIT ALWAYS FINDS ITS OWNER', canvas.width / 2, canvas.height - 80);
      } else if (gameOverFrame > 250 && gameOverFrame < 400) {
        ctx.font = '14px "Press Start 2P"';
        ctx.fillStyle = `rgba(255, 255, 0, ${0.5 + Math.sin(gameOverFrame * 0.1) * 0.3})`;
        ctx.fillText('I ALWAYS COME BACK', canvas.width / 2, canvas.height - 80);
      } else if (gameOverFrame > 400) {
        ctx.font = '12px "Press Start 2P"';
        ctx.fillStyle = `rgba(255, 255, 255, ${0.5 + Math.sin(gameOverFrame * 0.1) * 0.3})`;
        ctx.fillText('IT\'S ME', canvas.width / 2, canvas.height - 80);
      }

      // Score
      ctx.font = '16px "Press Start 2P"';
      ctx.fillStyle = '#ffff00';
      ctx.shadowColor = '#ffff00';
      ctx.shadowBlur = 10;
      ctx.fillText(`FINAL SCORE: ${score}`, canvas.width / 2, canvas.height - 40);

      ctx.restore();

      // Clean up old blood drops
      bloodDrops = bloodDrops.filter(d => d.alpha > 0 && d.y < canvas.height + 50);

      // Continue animation or show restart
      if (gameOverFrame < gameOverDuration) {
        requestAnimationFrame(gameOverAnimation);
      } else {
        // Show restart button after 10 seconds
        gameOverActive = false;
        document.getElementById('game-over-screen').style.display = 'flex';
        document.getElementById('final-score').textContent = `SCORE: ${score}`;
      }
    }

    function drawBackground() {
      // Dark factory floor with grid
      ctx.fillStyle = '#0a0a12';
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      // Glitch offset
      const glitchX = glitchIntensity > 0 ? (Math.random() - 0.5) * glitchIntensity : 0;
      const glitchY = glitchIntensity > 0 ? (Math.random() - 0.5) * glitchIntensity : 0;

      ctx.save();
      ctx.translate(glitchX, glitchY);

      // Grid lines
      ctx.strokeStyle = '#1a1a2e';
      ctx.lineWidth = 1;
      for (let x = 0; x < canvas.width; x += 40) {
        ctx.beginPath();
        ctx.moveTo(x, 0);
        ctx.lineTo(x, canvas.height);
        ctx.stroke();
      }
      for (let y = 0; y < canvas.height; y += 40) {
        ctx.beginPath();
        ctx.moveTo(0, y);
        ctx.lineTo(canvas.width, y);
        ctx.stroke();
      }

      // Random glitch bars
      if (glitchIntensity > 5 || Math.random() < 0.02) {
        ctx.fillStyle = `rgba(${Math.random() > 0.5 ? '255,0,255' : '0,255,255'}, 0.1)`;
        const barY = Math.random() * canvas.height;
        const barH = 5 + Math.random() * 20;
        ctx.fillRect(0, barY, canvas.width, barH);
      }

      ctx.restore();

      // Decay glitch
      if (glitchIntensity > 0) glitchIntensity -= 0.5;
    }

    function drawPlayer() {
      ctx.save();

      // SPRINGLOCK FAILURE ANIMATION
      if (player.springlockFailure) {
        const f = player.failureFrame;

        // Screen shake during failure
        ctx.translate((Math.random() - 0.5) * 10, (Math.random() - 0.5) * 10);

        // Draw golden suit crushing the player
        const crushProgress = Math.min(1, f / 30);
        const squash = 1 - crushProgress * 0.6;

        ctx.shadowColor = '#ff0000';
        ctx.shadowBlur = 30;

        // Golden suit shell closing
        ctx.fillStyle = '#ffd700';

        // Left half of suit
        ctx.fillRect(
          player.x - 10 + crushProgress * 10,
          player.y - 5,
          15,
          50
        );

        // Right half of suit
        ctx.fillRect(
          player.x + 25 - crushProgress * 10,
          player.y - 5,
          15,
          50
        );

        // Crushed purple guy inside
        ctx.fillStyle = '#6600aa';
        ctx.globalAlpha = 1 - crushProgress * 0.5;
        ctx.fillRect(
          player.x + 5,
          player.y + 15 + (1 - squash) * 10,
          20,
          25 * squash
        );
        ctx.fillRect(
          player.x + 7,
          player.y + (1 - squash) * 5,
          16,
          18 * squash
        );

        // BLOOD splatter
        ctx.globalAlpha = crushProgress;
        ctx.fillStyle = '#ff0000';
        for (let i = 0; i < 8; i++) {
          const angle = (i / 8) * Math.PI * 2 + f * 0.1;
          const dist = 10 + f * 0.5;
          ctx.beginPath();
          ctx.arc(
            player.x + 15 + Math.cos(angle) * dist,
            player.y + 20 + Math.sin(angle) * dist,
            3 + Math.random() * 3,
            0, Math.PI * 2
          );
          ctx.fill();
        }

        // Red eyes on suit
        ctx.fillStyle = '#ff0000';
        ctx.shadowColor = '#ff0000';
        ctx.shadowBlur = 20;
        ctx.globalAlpha = 0.5 + Math.sin(f * 0.5) * 0.5;
        ctx.fillRect(player.x + 3, player.y + 5, 5, 5);
        ctx.fillRect(player.x + 22, player.y + 5, 5, 5);

        // "SPRINGLOCK FAILURE" text
        if (f > 20) {
          ctx.globalAlpha = Math.min(1, (f - 20) / 20);
          ctx.font = '12px "Press Start 2P"';
          ctx.fillStyle = '#ff0000';
          ctx.textAlign = 'center';
          ctx.fillText('SPRINGLOCK', player.x + 15, player.y - 20);
          ctx.fillText('FAILURE', player.x + 15, player.y - 5);
        }

        ctx.restore();
        return;
      }

      // Warning indicator when staying still
      if (player.springlockWarning) {
        const warningProgress = (player.stillTimer - player.maxStillTime * 0.5) /
                               (player.maxStillTime * 0.5);

        // Flashing warning border
        ctx.strokeStyle = Math.sin(frameCount * 0.3) > 0 ? '#ff0000' : '#ffff00';
        ctx.lineWidth = 3;
        ctx.strokeRect(player.x - 5, player.y - 5, player.width + 10, player.height + 10);

        // Warning bar above player
        ctx.fillStyle = '#330000';
        ctx.fillRect(player.x - 5, player.y - 15, player.width + 10, 8);
        ctx.fillStyle = '#ff0000';
        ctx.fillRect(player.x - 4, player.y - 14, (player.width + 8) * warningProgress, 6);

        // "MOVE!" text
        if (Math.sin(frameCount * 0.2) > 0) {
          ctx.font = '10px "Press Start 2P"';
          ctx.fillStyle = '#ff0000';
          ctx.textAlign = 'center';
          ctx.fillText('MOVE!', player.x + 15, player.y - 20);
        }
      }

      // Glow effect
      ctx.shadowColor = player.springlockWarning ? '#ff0000' : '#6600aa';
      ctx.shadowBlur = 15;

      // Body
      ctx.fillStyle = player.color;
      ctx.fillRect(player.x + 5, player.y + 15, 20, 25);

      // Head
      ctx.fillRect(player.x + 7, player.y, 16, 18);

      // Eyes (menacing white, or red during warning)
      ctx.fillStyle = player.springlockWarning ? '#ff0000' : '#fff';
      ctx.fillRect(player.x + 10, player.y + 6, 4, 4);
      ctx.fillRect(player.x + 16, player.y + 6, 4, 4);

      // Evil grin
      ctx.fillStyle = '#fff';
      ctx.fillRect(player.x + 10, player.y + 13, 10, 2);

      ctx.restore();
    }

    function drawGhosts() {
      ghosts.forEach(ghost => {
        ctx.save();
        ctx.globalAlpha = ghost.alpha;

        // Glow
        ctx.shadowColor = ghost.color;
        ctx.shadowBlur = 20;

        // Body (simple ghost shape)
        ctx.fillStyle = ghost.color;
        ctx.beginPath();
        ctx.ellipse(ghost.x + ghost.width/2, ghost.y + ghost.height/2,
                   ghost.width/2, ghost.height/2, 0, 0, Math.PI * 2);
        ctx.fill();

        // Wavy bottom
        ctx.beginPath();
        ctx.moveTo(ghost.x, ghost.y + ghost.height * 0.6);
        for (let i = 0; i <= ghost.width; i += 5) {
          const wave = Math.sin((i + frameCount * 3) * 0.2) * 3;
          ctx.lineTo(ghost.x + i, ghost.y + ghost.height + wave);
        }
        ctx.lineTo(ghost.x + ghost.width, ghost.y + ghost.height * 0.6);
        ctx.fill();

        // Empty eyes
        ctx.fillStyle = '#000';
        ctx.beginPath();
        ctx.ellipse(ghost.x + 8, ghost.y + 12, 4, 5, 0, 0, Math.PI * 2);
        ctx.fill();
        ctx.beginPath();
        ctx.ellipse(ghost.x + 17, ghost.y + 12, 4, 5, 0, 0, Math.PI * 2);
        ctx.fill();

        // Tear streaks
        ctx.fillStyle = ghost.color;
        ctx.globalAlpha = 0.5;
        ctx.fillRect(ghost.x + 7, ghost.y + 17, 2, 8);
        ctx.fillRect(ghost.x + 16, ghost.y + 17, 2, 8);

        ctx.restore();
      });
    }

    function drawSpringlocks() {
      springlocks.forEach(spring => {
        if (spring.collected) return;

        ctx.save();
        spring.glow = (spring.glow + 0.1) % (Math.PI * 2);
        const glowIntensity = 10 + Math.sin(spring.glow) * 5;

        ctx.shadowColor = '#ffd700';
        ctx.shadowBlur = glowIntensity;

        // Golden springlock (simplified animatronic head shape)
        ctx.fillStyle = '#ffd700';

        // Main body
        ctx.fillRect(spring.x + 2, spring.y + 8, 16, 17);

        // Head
        ctx.beginPath();
        ctx.arc(spring.x + 10, spring.y + 8, 10, 0, Math.PI * 2);
        ctx.fill();

        // Ears
        ctx.fillRect(spring.x, spring.y - 2, 4, 8);
        ctx.fillRect(spring.x + 16, spring.y - 2, 4, 8);

        // Eyes (dark, ominous)
        ctx.fillStyle = '#000';
        ctx.fillRect(spring.x + 5, spring.y + 5, 4, 4);
        ctx.fillRect(spring.x + 11, spring.y + 5, 4, 4);

        ctx.restore();
      });
    }

    function drawHUD() {
      // IT'S ME text occasionally
      if (Math.random() < 0.005 && gameRunning) {
        ctx.save();
        ctx.font = '40px "Press Start 2P"';
        ctx.fillStyle = `rgba(255, 0, 0, ${0.3 + Math.random() * 0.5})`;
        ctx.textAlign = 'center';
        ctx.fillText("IT'S ME", canvas.width / 2, canvas.height / 2);
        ctx.restore();
      }
    }

    function gameLoop() {
      if (!gameRunning) return;

      frameCount++;

      updatePlayer();
      updateGhosts();
      checkCollisions();

      drawBackground();
      drawSpringlocks();
      drawPlayer();
      drawGhosts();
      drawHUD();

      requestAnimationFrame(gameLoop);
    }

    function startGame() {
      document.getElementById('start-screen').style.display = 'none';
      document.getElementById('game-over-screen').style.display = 'none';

      score = 0;
      lives = 3;
      level = 1;
      glitchIntensity = 0;

      document.getElementById('score').textContent = 'SCORE: 0';
      document.getElementById('lives').textContent = 'LIVES: 3';
      document.getElementById('level').textContent = 'LEVEL 1';

      initGame();
      gameRunning = true;
      gameLoop();
    }

    // Handle resize
    window.addEventListener('resize', () => {
      const newWidth = Math.min(800, window.innerWidth - 20);
      const newHeight = Math.min(600, window.innerHeight - 150);
      canvas.width = newWidth;
      canvas.height = newHeight;
    });

    // Draw initial screen
    drawBackground();
  </script>
</body>
</html>
