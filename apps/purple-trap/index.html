<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
  <title>The Purple Trap</title>
  <meta name="description" content="Dodge neon ghosts and collect springlocks in a glitchy factory">
  <meta property="og:title" content="The Purple Trap">
  <meta property="og:description" content="2D arcade game - dodge ghosts, collect springlocks, survive the factory">
  <meta property="og:url" content="https://sloppy.live/purple-trap/">
  <meta property="og:image" content="https://emojicdn.elk.sh/üëæ">
  <link rel="icon" href="https://emojicdn.elk.sh/üíú">
  <style>
    @import url('https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap');

    * { margin: 0; padding: 0; box-sizing: border-box; }

    body {
      background: #0a0a12;
      min-height: 100vh;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      font-family: 'Press Start 2P', monospace;
      overflow: hidden;
    }

    #game-container {
      position: relative;
      border: 4px solid #6600aa;
      box-shadow: 0 0 30px #6600aa, 0 0 60px #6600aa44, inset 0 0 30px #00000088;
    }

    #gameCanvas {
      display: block;
      background: #0a0a12;
    }

    #ui {
      position: absolute;
      top: 10px;
      left: 10px;
      right: 10px;
      display: flex;
      justify-content: space-between;
      color: #0ff;
      font-size: 12px;
      text-shadow: 0 0 10px #0ff;
      pointer-events: none;
      z-index: 10;
    }

    #score { color: #ff0; text-shadow: 0 0 10px #ff0; }
    #lives { color: #f0f; text-shadow: 0 0 10px #f0f; }
    #level { color: #0f0; text-shadow: 0 0 10px #0f0; }

    #start-screen, #game-over-screen {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(10, 10, 18, 0.95);
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      z-index: 100;
      text-align: center;
      padding: 20px;
    }

    #start-screen h1, #game-over-screen h1 {
      color: #6600aa;
      font-size: 24px;
      text-shadow: 0 0 20px #6600aa, 0 0 40px #6600aa;
      margin-bottom: 20px;
      animation: pulse 2s ease-in-out infinite;
    }

    @keyframes pulse {
      0%, 100% { text-shadow: 0 0 20px #6600aa, 0 0 40px #6600aa; }
      50% { text-shadow: 0 0 30px #9900ff, 0 0 60px #9900ff; }
    }

    #start-screen p, #game-over-screen p {
      color: #888;
      font-size: 10px;
      margin: 10px 0;
      line-height: 1.8;
    }

    .btn {
      background: linear-gradient(180deg, #6600aa, #440066);
      border: 2px solid #9900ff;
      color: #fff;
      padding: 15px 30px;
      font-family: 'Press Start 2P', monospace;
      font-size: 14px;
      cursor: pointer;
      margin-top: 20px;
      text-shadow: 0 0 10px #fff;
      box-shadow: 0 0 20px #6600aa;
      transition: all 0.2s;
    }

    .btn:hover {
      background: linear-gradient(180deg, #9900ff, #6600aa);
      box-shadow: 0 0 30px #9900ff;
      transform: scale(1.05);
    }

    #final-score {
      color: #ff0;
      font-size: 18px;
      text-shadow: 0 0 20px #ff0;
      margin: 15px 0;
    }

    #controls-hint {
      color: #666;
      font-size: 8px;
      margin-top: 20px;
    }

    #mobile-controls {
      display: block !important;
      position: fixed;
      bottom: 15px;
      left: 0;
      right: 0;
      padding: 0 15px;
      z-index: 9999 !important;
      pointer-events: none;
    }

    #mobile-controls-inner {
      display: flex;
      justify-content: space-between;
      align-items: flex-end;
      max-width: 500px;
      margin: 0 auto;
      pointer-events: none;
    }

    #dpad-container {
      position: relative;
      width: 150px;
      height: 150px;
      pointer-events: auto;
    }

    .dpad-btn {
      position: absolute;
      width: 50px;
      height: 50px;
      background: linear-gradient(145deg, #1a0033, #0a0015);
      border: 3px solid #ff00ff;
      border-radius: 8px;
      color: #ff00ff;
      font-size: 28px;
      font-weight: bold;
      display: flex;
      align-items: center;
      justify-content: center;
      touch-action: manipulation;
      box-shadow:
        0 0 15px #ff00ff,
        0 0 30px rgba(255, 0, 255, 0.5),
        inset 0 0 10px rgba(255, 0, 255, 0.3);
      text-shadow: 0 0 10px #ff00ff;
      transition: all 0.1s;
      -webkit-tap-highlight-color: transparent;
      user-select: none;
    }

    .dpad-btn:active {
      background: linear-gradient(145deg, #440066, #220033);
      border-color: #ff66ff;
      box-shadow:
        0 0 25px #ff66ff,
        0 0 50px rgba(255, 0, 255, 0.8),
        inset 0 0 20px rgba(255, 0, 255, 0.5);
      transform: scale(0.95);
    }

    #btn-up { top: 0; left: 50px; }
    #btn-down { bottom: 0; left: 50px; }
    #btn-left { top: 50px; left: 0; }
    #btn-right { top: 50px; right: 0; }

    /* D-pad center decoration */
    #dpad-center {
      position: absolute;
      top: 50px;
      left: 50px;
      width: 50px;
      height: 50px;
      background: #0a0015;
      border: 2px solid #6600aa;
      border-radius: 50%;
      box-shadow: inset 0 0 15px #6600aa;
    }

    #jump-container {
      pointer-events: auto;
    }

    #btn-jump {
      width: 80px;
      height: 80px;
      background: linear-gradient(145deg, #003322, #001a11);
      border: 4px solid #00ff88;
      border-radius: 50%;
      color: #00ff88;
      font-family: 'Press Start 2P', monospace;
      font-size: 12px;
      display: flex;
      align-items: center;
      justify-content: center;
      touch-action: manipulation;
      box-shadow:
        0 0 20px #00ff88,
        0 0 40px rgba(0, 255, 136, 0.5),
        inset 0 0 15px rgba(0, 255, 136, 0.3);
      text-shadow: 0 0 10px #00ff88;
      transition: all 0.1s;
      -webkit-tap-highlight-color: transparent;
      user-select: none;
    }

    #btn-jump:active {
      background: linear-gradient(145deg, #006644, #003322);
      border-color: #66ffaa;
      box-shadow:
        0 0 30px #66ffaa,
        0 0 60px rgba(0, 255, 136, 0.8),
        inset 0 0 25px rgba(0, 255, 136, 0.5);
      transform: scale(0.92);
    }

    #jump-label {
      color: #00ff88;
      font-size: 8px;
      text-align: center;
      margin-top: 5px;
      text-shadow: 0 0 5px #00ff88;
    }

    #wind-container {
      pointer-events: auto;
      margin-left: 10px;
    }

    #btn-wind {
      width: 60px;
      height: 60px;
      background: linear-gradient(145deg, #002233, #001122);
      border: 3px solid #00ffff;
      border-radius: 50%;
      color: #00ffff;
      font-size: 24px;
      display: flex;
      align-items: center;
      justify-content: center;
      touch-action: manipulation;
      box-shadow:
        0 0 15px #00ffff,
        0 0 30px rgba(0, 255, 255, 0.4),
        inset 0 0 10px rgba(0, 255, 255, 0.2);
      transition: all 0.1s;
      -webkit-tap-highlight-color: transparent;
      user-select: none;
    }

    #btn-wind:active {
      background: linear-gradient(145deg, #004466, #002244);
      border-color: #66ffff;
      box-shadow:
        0 0 25px #66ffff,
        0 0 50px rgba(0, 255, 255, 0.7),
        inset 0 0 20px rgba(0, 255, 255, 0.4);
      transform: scale(0.92);
    }

    #wind-label {
      color: #00ffff;
      font-size: 8px;
      text-align: center;
      margin-top: 5px;
      text-shadow: 0 0 5px #00ffff;
    }

    #backlink {
      position: fixed;
      bottom: 10px;
      left: 10px;
      z-index: 100;
    }

    #backlink a {
      color: #6600aa;
      text-decoration: none;
      font-size: 8px;
      opacity: 0.7;
    }

    @media (max-width: 600px) {
      #ui { font-size: 10px; }
      #start-screen h1, #game-over-screen h1 { font-size: 18px; }
      #start-screen p, #game-over-screen p { font-size: 8px; }
      .btn { font-size: 12px; padding: 12px 24px; }
      #mobile-controls { display: block; }
    }

    /* Glitch effect */
    @keyframes glitch {
      0%, 90%, 100% { transform: translate(0); }
      92% { transform: translate(-2px, 1px); }
      94% { transform: translate(2px, -1px); }
      96% { transform: translate(-1px, 2px); }
      98% { transform: translate(1px, -2px); }
    }

    .glitch {
      animation: glitch 3s infinite;
    }
  </style>
</head>
<body>
  <div id="game-container">
    <canvas id="gameCanvas"></canvas>

    <div id="ui">
      <span id="score">SCORE: 0</span>
      <span id="level">LEVEL 1</span>
      <span id="lives">LIVES: 3</span>
    </div>

    <div id="start-screen">
      <h1 class="glitch">THE PURPLE TRAP</h1>
      <p>You are the PURPLE GUY</p>
      <p>Collect SPRINGLOCKS to score</p>
      <p>Avoid the GHOST CHILDREN</p>
      <p style="color:#ff0;">KEEP MOVING or suffer SPRINGLOCK FAILURE!</p>
      <p>They remember what you did...</p>
      <button class="btn" onclick="startGame()">START GAME</button>
      <div id="controls-hint">WASD: Move | SPACE: Dash | R: Wind Music Box</div>
    </div>

    <div id="game-over-screen" style="display: none;">
      <h1>GAME OVER</h1>
      <p>The children got their revenge...</p>
      <div id="final-score">SCORE: 0</div>
      <button class="btn" onclick="startGame()">TRY AGAIN</button>
    </div>
  </div>

  <div id="mobile-controls">
    <div id="mobile-controls-inner">
      <div id="dpad-container">
        <div id="dpad-center"></div>
        <button class="dpad-btn" id="btn-up">‚ñ≤</button>
        <button class="dpad-btn" id="btn-down">‚ñº</button>
        <button class="dpad-btn" id="btn-left">‚óÄ</button>
        <button class="dpad-btn" id="btn-right">‚ñ∂</button>
      </div>
      <div id="jump-container">
        <button id="btn-jump">DASH</button>
        <div id="jump-label">DODGE</div>
      </div>
      <div id="wind-container">
        <button id="btn-wind">üéµ</button>
        <div id="wind-label">WIND</div>
      </div>
    </div>
  </div>

  <div id="backlink">
    <a href="https://sloppy.live">‚Üê sloppy.live</a>
  </div>

  <script>
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');

    // Responsive canvas size
    const maxWidth = Math.min(800, window.innerWidth - 20);
    const maxHeight = Math.min(600, window.innerHeight - 150);
    canvas.width = maxWidth;
    canvas.height = maxHeight;

    // Game state
    let gameRunning = false;
    let score = 0;
    let lives = 3;
    let level = 1;
    let glitchIntensity = 0;
    let frameCount = 0;

    // Player (Purple Guy)
    const player = {
      x: canvas.width / 2,
      y: canvas.height / 2,
      width: 30,
      height: 40,
      speed: 4,
      color: '#6600aa',
      dx: 0,
      dy: 0,
      stillTimer: 0,
      maxStillTime: 180, // 3 seconds at 60fps
      springlockWarning: false,
      springlockFailure: false,
      failureFrame: 0,
      // Dash/dodge mechanic
      isDashing: false,
      dashCooldown: 0,
      dashDuration: 0,
      dashSpeed: 12,
      dashMaxDuration: 15, // frames
      dashMaxCooldown: 60, // 1 second cooldown
      dashDirection: { x: 0, y: 0 },
      isInvincible: false,
      // Golden Mask power-up
      hasMask: false,
      maskTimer: 0,
      maskMaxDuration: 600, // 10 seconds at 60fps
      // Music Box mechanic
      musicBoxTimer: 600, // 10 seconds at 60fps
      musicBoxMaxTime: 600,
      musicBoxWinding: false,
      musicBoxDead: false
    };

    // Audio context for crunch sound
    let audioCtx = null;

    function playSpringlockCrunch() {
      if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();

      // Create brutal crunch sound
      const duration = 0.8;
      const now = audioCtx.currentTime;

      // Multiple noise bursts for crunch effect
      for (let i = 0; i < 5; i++) {
        const noise = audioCtx.createBufferSource();
        const bufferSize = audioCtx.sampleRate * 0.15;
        const buffer = audioCtx.createBuffer(1, bufferSize, audioCtx.sampleRate);
        const data = buffer.getChannelData(0);

        for (let j = 0; j < bufferSize; j++) {
          data[j] = (Math.random() * 2 - 1) * Math.exp(-j / (bufferSize * 0.3));
        }

        noise.buffer = buffer;

        const filter = audioCtx.createBiquadFilter();
        filter.type = 'lowpass';
        filter.frequency.value = 800 - i * 100;

        const gain = audioCtx.createGain();
        gain.gain.setValueAtTime(0.8 - i * 0.1, now + i * 0.1);
        gain.gain.exponentialDecayTo = 0.01;
        gain.gain.setValueAtTime(0.01, now + i * 0.1 + 0.15);

        noise.connect(filter);
        filter.connect(gain);
        gain.connect(audioCtx.destination);

        noise.start(now + i * 0.08);
      }

      // Low thud
      const osc = audioCtx.createOscillator();
      osc.type = 'sine';
      osc.frequency.setValueAtTime(60, now);
      osc.frequency.exponentialRampToValueAtTime(20, now + 0.3);

      const oscGain = audioCtx.createGain();
      oscGain.gain.setValueAtTime(0.8, now);
      oscGain.gain.exponentialRampToValueAtTime(0.01, now + 0.4);

      osc.connect(oscGain);
      oscGain.connect(audioCtx.destination);
      osc.start(now);
      osc.stop(now + 0.5);

      // Metal screech
      const screech = audioCtx.createOscillator();
      screech.type = 'sawtooth';
      screech.frequency.setValueAtTime(2000, now + 0.1);
      screech.frequency.exponentialRampToValueAtTime(500, now + 0.4);

      const screechGain = audioCtx.createGain();
      screechGain.gain.setValueAtTime(0.15, now + 0.1);
      screechGain.gain.exponentialRampToValueAtTime(0.01, now + 0.5);

      screech.connect(screechGain);
      screechGain.connect(audioCtx.destination);
      screech.start(now + 0.1);
      screech.stop(now + 0.5);
    }

    // Death sequence audio
    let deathAudioInterval = null;
    let screamOscillators = [];

    function playDeathScream() {
      if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
      const now = audioCtx.currentTime;

      // Agonizing scream using multiple oscillators
      const screamFreqs = [400, 600, 800, 1000];
      screamFreqs.forEach((freq, i) => {
        const osc = audioCtx.createOscillator();
        osc.type = 'sawtooth';
        osc.frequency.setValueAtTime(freq + Math.random() * 100, now);
        osc.frequency.linearRampToValueAtTime(freq * 1.5, now + 0.1);
        osc.frequency.linearRampToValueAtTime(freq * 0.8, now + 0.3);
        osc.frequency.linearRampToValueAtTime(freq * 1.2, now + 0.5);

        const gain = audioCtx.createGain();
        gain.gain.setValueAtTime(0.08 - i * 0.015, now);
        gain.gain.linearRampToValueAtTime(0.12 - i * 0.02, now + 0.15);
        gain.gain.linearRampToValueAtTime(0.05, now + 0.4);
        gain.gain.linearRampToValueAtTime(0.01, now + 0.6);

        const filter = audioCtx.createBiquadFilter();
        filter.type = 'bandpass';
        filter.frequency.value = freq;
        filter.Q.value = 2;

        osc.connect(filter);
        filter.connect(gain);
        gain.connect(audioCtx.destination);

        osc.start(now);
        osc.stop(now + 0.7);
      });

      // Gurgling noise underneath
      const noise = audioCtx.createBufferSource();
      const bufferSize = audioCtx.sampleRate * 0.5;
      const buffer = audioCtx.createBuffer(1, bufferSize, audioCtx.sampleRate);
      const data = buffer.getChannelData(0);
      for (let i = 0; i < bufferSize; i++) {
        data[i] = (Math.random() * 2 - 1) * Math.sin(i * 0.01) * 0.5;
      }
      noise.buffer = buffer;

      const noiseGain = audioCtx.createGain();
      noiseGain.gain.setValueAtTime(0.15, now);
      noiseGain.gain.linearRampToValueAtTime(0.05, now + 0.5);

      const noiseFilter = audioCtx.createBiquadFilter();
      noiseFilter.type = 'lowpass';
      noiseFilter.frequency.value = 600;

      noise.connect(noiseFilter);
      noiseFilter.connect(noiseGain);
      noiseGain.connect(audioCtx.destination);
      noise.start(now);
    }

    function playWetCrunch() {
      if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
      const now = audioCtx.currentTime;

      // Wet squelch
      for (let i = 0; i < 3; i++) {
        const noise = audioCtx.createBufferSource();
        const bufferSize = audioCtx.sampleRate * 0.1;
        const buffer = audioCtx.createBuffer(1, bufferSize, audioCtx.sampleRate);
        const data = buffer.getChannelData(0);
        for (let j = 0; j < bufferSize; j++) {
          data[j] = (Math.random() * 2 - 1) * Math.exp(-j / (bufferSize * 0.2));
        }
        noise.buffer = buffer;

        const filter = audioCtx.createBiquadFilter();
        filter.type = 'lowpass';
        filter.frequency.value = 400 + Math.random() * 300;

        const gain = audioCtx.createGain();
        gain.gain.setValueAtTime(0.4, now + i * 0.05);
        gain.gain.exponentialRampToValueAtTime(0.01, now + i * 0.05 + 0.1);

        noise.connect(filter);
        filter.connect(gain);
        gain.connect(audioCtx.destination);
        noise.start(now + i * 0.05);
      }

      // Bone snap
      const snap = audioCtx.createOscillator();
      snap.type = 'square';
      snap.frequency.setValueAtTime(150, now);
      snap.frequency.exponentialRampToValueAtTime(50, now + 0.05);

      const snapGain = audioCtx.createGain();
      snapGain.gain.setValueAtTime(0.3, now);
      snapGain.gain.exponentialRampToValueAtTime(0.01, now + 0.08);

      snap.connect(snapGain);
      snapGain.connect(audioCtx.destination);
      snap.start(now);
      snap.stop(now + 0.1);
    }

    function startDeathAudio() {
      if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();

      // Initial scream
      playDeathScream();
      playWetCrunch();

      // Loop screams and crunches
      let audioFrame = 0;
      deathAudioInterval = setInterval(() => {
        audioFrame++;

        // Scream every ~1 second with variation
        if (audioFrame % 60 === 0 || (audioFrame % 60 === 30 && Math.random() < 0.5)) {
          playDeathScream();
        }

        // Wet crunch every ~0.5 seconds
        if (audioFrame % 30 === 0) {
          playWetCrunch();
        }

        // Random extra crunches
        if (Math.random() < 0.05) {
          playWetCrunch();
        }
      }, 1000 / 60);
    }

    function stopDeathAudio() {
      if (deathAudioInterval) {
        clearInterval(deathAudioInterval);
        deathAudioInterval = null;
      }
    }

    // Ghost children (the 5 victims)
    const ghostData = [
      { color: '#00ffff', name: 'Gabriel' },
      { color: '#ff00ff', name: 'Jeremy' },
      { color: '#ffff00', name: 'Susie' },
      { color: '#ff0000', name: 'Fritz' },
      { color: '#ffffff', name: 'Cassidy' }
    ];

    let ghosts = [];
    let springlocks = [];
    let goldenMasks = [];

    // Input handling
    const keys = {};

    document.addEventListener('keydown', (e) => {
      keys[e.key.toLowerCase()] = true;
      if (['arrowup', 'arrowdown', 'arrowleft', 'arrowright', 'w', 'a', 's', 'd', ' ', 'r'].includes(e.key.toLowerCase())) {
        e.preventDefault();
      }
      // Spacebar triggers dash
      if (e.key === ' ') {
        triggerDash();
      }
      // R key winds the music box
      if (e.key.toLowerCase() === 'r') {
        windMusicBox();
      }
    });

    document.addEventListener('keyup', (e) => {
      keys[e.key.toLowerCase()] = false;
    });

    // Mobile controls
    const mobileButtons = {
      'btn-up': { key: 'arrowup' },
      'btn-down': { key: 'arrowdown' },
      'btn-left': { key: 'arrowleft' },
      'btn-right': { key: 'arrowright' }
    };

    Object.keys(mobileButtons).forEach(id => {
      const btn = document.getElementById(id);
      if (btn) {
        btn.addEventListener('touchstart', (e) => {
          e.preventDefault();
          keys[mobileButtons[id].key] = true;
        });
        btn.addEventListener('touchend', (e) => {
          e.preventDefault();
          keys[mobileButtons[id].key] = false;
        });
      }
    });

    // Jump/Dash button
    const jumpBtn = document.getElementById('btn-jump');
    if (jumpBtn) {
      jumpBtn.addEventListener('touchstart', (e) => {
        e.preventDefault();
        triggerDash();
      });
      jumpBtn.addEventListener('click', (e) => {
        e.preventDefault();
        triggerDash();
      });
    }

    // Wind music box button
    const windBtn = document.getElementById('btn-wind');
    if (windBtn) {
      windBtn.addEventListener('touchstart', (e) => {
        e.preventDefault();
        windMusicBox();
      });
      windBtn.addEventListener('click', (e) => {
        e.preventDefault();
        windMusicBox();
      });
    }

    // Golden Freddy click detection
    canvas.addEventListener('click', (e) => {
      const rect = canvas.getBoundingClientRect();
      const x = e.clientX - rect.left;
      const y = e.clientY - rect.top;
      checkGoldenFreddyClick(x, y);
    });

    canvas.addEventListener('touchstart', (e) => {
      const rect = canvas.getBoundingClientRect();
      const touch = e.touches[0];
      const x = touch.clientX - rect.left;
      const y = touch.clientY - rect.top;
      checkGoldenFreddyClick(x, y);
    });

    // Dash function
    function triggerDash() {
      if (!gameRunning || player.isDashing || player.dashCooldown > 0 || player.springlockFailure) return;

      // Get current movement direction or default to right
      let dirX = 0, dirY = 0;
      if (keys['arrowup'] || keys['w']) dirY = -1;
      if (keys['arrowdown'] || keys['s']) dirY = 1;
      if (keys['arrowleft'] || keys['a']) dirX = -1;
      if (keys['arrowright'] || keys['d']) dirX = 1;

      // If no direction, dash in facing direction (default right)
      if (dirX === 0 && dirY === 0) {
        dirX = 1;
      }

      // Normalize
      const len = Math.sqrt(dirX * dirX + dirY * dirY);
      player.dashDirection = { x: dirX / len, y: dirY / len };

      player.isDashing = true;
      player.dashDuration = player.dashMaxDuration;
      player.isInvincible = true;

      // Play dash sound
      playDashSound();
    }

    function playDashSound() {
      if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
      const now = audioCtx.currentTime;

      // Whoosh sound
      const noise = audioCtx.createBufferSource();
      const bufferSize = audioCtx.sampleRate * 0.2;
      const buffer = audioCtx.createBuffer(1, bufferSize, audioCtx.sampleRate);
      const data = buffer.getChannelData(0);
      for (let i = 0; i < bufferSize; i++) {
        data[i] = (Math.random() * 2 - 1) * (1 - i / bufferSize);
      }
      noise.buffer = buffer;

      const filter = audioCtx.createBiquadFilter();
      filter.type = 'highpass';
      filter.frequency.setValueAtTime(500, now);
      filter.frequency.linearRampToValueAtTime(2000, now + 0.15);

      const gain = audioCtx.createGain();
      gain.gain.setValueAtTime(0.3, now);
      gain.gain.linearRampToValueAtTime(0.01, now + 0.2);

      noise.connect(filter);
      filter.connect(gain);
      gain.connect(audioCtx.destination);
      noise.start(now);
    }

    function windMusicBox() {
      if (!gameRunning || player.springlockFailure || player.musicBoxDead) return;

      // Wind the music box back to full
      player.musicBoxTimer = player.musicBoxMaxTime;
      player.musicBoxWinding = true;
      playMusicBoxWind();

      // Reset winding animation after a moment
      setTimeout(() => {
        player.musicBoxWinding = false;
      }, 300);
    }

    function createGhost(index) {
      const data = ghostData[index % ghostData.length];
      const side = Math.floor(Math.random() * 4);
      let x, y;

      switch(side) {
        case 0: x = Math.random() * canvas.width; y = -30; break;
        case 1: x = canvas.width + 30; y = Math.random() * canvas.height; break;
        case 2: x = Math.random() * canvas.width; y = canvas.height + 30; break;
        case 3: x = -30; y = Math.random() * canvas.height; break;
      }

      return {
        x, y,
        width: 25,
        height: 30,
        speed: 1.5 + level * 0.3 + Math.random() * 0.5,
        color: data.color,
        name: data.name,
        wobble: Math.random() * Math.PI * 2,
        alpha: 0.8
      };
    }

    function createSpringlock() {
      return {
        x: 50 + Math.random() * (canvas.width - 100),
        y: 50 + Math.random() * (canvas.height - 100),
        width: 20,
        height: 25,
        collected: false,
        glow: 0
      };
    }

    function createGoldenMask() {
      return {
        x: 50 + Math.random() * (canvas.width - 100),
        y: 50 + Math.random() * (canvas.height - 100),
        width: 28,
        height: 32,
        collected: false,
        glow: 0,
        floatOffset: Math.random() * Math.PI * 2
      };
    }

    function playMaskPickupSound() {
      if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
      const now = audioCtx.currentTime;

      // Magical chime sound
      const frequencies = [523, 659, 784, 1047]; // C5, E5, G5, C6
      frequencies.forEach((freq, i) => {
        const osc = audioCtx.createOscillator();
        osc.type = 'sine';
        osc.frequency.setValueAtTime(freq, now + i * 0.1);

        const gain = audioCtx.createGain();
        gain.gain.setValueAtTime(0.3, now + i * 0.1);
        gain.gain.exponentialRampToValueAtTime(0.01, now + i * 0.1 + 0.4);

        osc.connect(gain);
        gain.connect(audioCtx.destination);
        osc.start(now + i * 0.1);
        osc.stop(now + i * 0.1 + 0.5);
      });

      // Shimmering overlay
      const shimmer = audioCtx.createOscillator();
      shimmer.type = 'triangle';
      shimmer.frequency.setValueAtTime(2000, now);
      shimmer.frequency.exponentialRampToValueAtTime(4000, now + 0.3);

      const shimmerGain = audioCtx.createGain();
      shimmerGain.gain.setValueAtTime(0.1, now);
      shimmerGain.gain.exponentialRampToValueAtTime(0.01, now + 0.4);

      shimmer.connect(shimmerGain);
      shimmerGain.connect(audioCtx.destination);
      shimmer.start(now);
      shimmer.stop(now + 0.5);
    }

    function playMusicBoxWind() {
      if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
      const now = audioCtx.currentTime;

      // Creaky wind-up sound
      for (let i = 0; i < 4; i++) {
        const osc = audioCtx.createOscillator();
        osc.type = 'sawtooth';
        osc.frequency.setValueAtTime(200 + i * 50, now + i * 0.08);
        osc.frequency.linearRampToValueAtTime(300 + i * 60, now + i * 0.08 + 0.06);

        const gain = audioCtx.createGain();
        gain.gain.setValueAtTime(0.1, now + i * 0.08);
        gain.gain.exponentialRampToValueAtTime(0.01, now + i * 0.08 + 0.08);

        osc.connect(gain);
        gain.connect(audioCtx.destination);
        osc.start(now + i * 0.08);
        osc.stop(now + i * 0.08 + 0.1);
      }
    }

    function playMusicBoxWarning() {
      if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
      const now = audioCtx.currentTime;

      // Slowing music box melody (creepy)
      const notes = [392, 330, 294, 262]; // G4, E4, D4, C4
      notes.forEach((freq, i) => {
        const osc = audioCtx.createOscillator();
        osc.type = 'sine';
        osc.frequency.setValueAtTime(freq, now + i * 0.3);

        const gain = audioCtx.createGain();
        gain.gain.setValueAtTime(0.15, now + i * 0.3);
        gain.gain.exponentialRampToValueAtTime(0.01, now + i * 0.3 + 0.25);

        osc.connect(gain);
        gain.connect(audioCtx.destination);
        osc.start(now + i * 0.3);
        osc.stop(now + i * 0.3 + 0.3);
      });
    }

    function playMusicBoxDeath() {
      if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
      const now = audioCtx.currentTime;

      // Final discordant note
      const osc = audioCtx.createOscillator();
      osc.type = 'sawtooth';
      osc.frequency.setValueAtTime(150, now);
      osc.frequency.exponentialRampToValueAtTime(50, now + 1);

      const gain = audioCtx.createGain();
      gain.gain.setValueAtTime(0.4, now);
      gain.gain.exponentialRampToValueAtTime(0.01, now + 1.5);

      const filter = audioCtx.createBiquadFilter();
      filter.type = 'lowpass';
      filter.frequency.setValueAtTime(800, now);
      filter.frequency.exponentialRampToValueAtTime(100, now + 1);

      osc.connect(filter);
      filter.connect(gain);
      gain.connect(audioCtx.destination);
      osc.start(now);
      osc.stop(now + 1.5);
    }

    function initGame() {
      player.x = canvas.width / 2;
      player.y = canvas.height / 2;
      player.hasMask = false;
      player.maskTimer = 0;
      player.musicBoxTimer = player.musicBoxMaxTime;
      player.musicBoxWinding = false;
      player.musicBoxDead = false;
      ghosts = [];
      springlocks = [];
      goldenMasks = [];

      // Spawn initial ghosts based on level
      for (let i = 0; i < Math.min(level + 2, 5); i++) {
        ghosts.push(createGhost(i));
      }

      // Spawn springlocks
      for (let i = 0; i < 5; i++) {
        springlocks.push(createSpringlock());
      }

      // Spawn one golden mask per level (rare power-up)
      goldenMasks.push(createGoldenMask());
    }

    function updatePlayer() {
      // Handle springlock failure animation
      if (player.springlockFailure) {
        player.failureFrame++;
        if (player.failureFrame > 90) { // 1.5 seconds of death animation
          lives--;
          document.getElementById('lives').textContent = `LIVES: ${lives}`;

          if (lives <= 0) {
            gameOver();
            return;
          }

          // Reset player
          player.springlockFailure = false;
          player.failureFrame = 0;
          player.stillTimer = 0;
          player.x = canvas.width / 2;
          player.y = canvas.height / 2;

          // Push ghosts away
          ghosts.forEach(g => {
            g.x = g.x < canvas.width / 2 ? -30 : canvas.width + 30;
            g.y = g.y < canvas.height / 2 ? -30 : canvas.height + 30;
          });
        }
        return; // Don't process movement during failure
      }

      // Update dash cooldown
      if (player.dashCooldown > 0) {
        player.dashCooldown--;
      }

      // Update golden mask timer
      if (player.hasMask) {
        player.maskTimer--;
        if (player.maskTimer <= 0) {
          player.hasMask = false;
          player.isInvincible = false;
        }
      }

      // Update music box timer
      if (!player.musicBoxDead) {
        player.musicBoxTimer--;

        // Play warning sound at 3 seconds left
        if (player.musicBoxTimer === 180) {
          playMusicBoxWarning();
        }

        // Music box ran out - THE PUPPET GETS YOU
        if (player.musicBoxTimer <= 0) {
          player.musicBoxDead = true;
          playMusicBoxDeath();
          glitchIntensity = 40;

          // Kill the player
          lives--;
          document.getElementById('lives').textContent = `LIVES: ${lives}`;

          if (lives <= 0) {
            gameOver();
            return;
          }

          // Reset after music box death
          setTimeout(() => {
            player.musicBoxDead = false;
            player.musicBoxTimer = player.musicBoxMaxTime;
            player.x = canvas.width / 2;
            player.y = canvas.height / 2;

            // Push ghosts away
            ghosts.forEach(g => {
              g.x = g.x < canvas.width / 2 ? -30 : canvas.width + 30;
              g.y = g.y < canvas.height / 2 ? -30 : canvas.height + 30;
            });
          }, 1000);
        }
      }

      // Handle dashing
      if (player.isDashing) {
        player.dashDuration--;

        // Dash movement
        player.dx = player.dashDirection.x * player.dashSpeed;
        player.dy = player.dashDirection.y * player.dashSpeed;

        // End dash
        if (player.dashDuration <= 0) {
          player.isDashing = false;
          // Only remove invincibility if mask isn't active
          if (!player.hasMask) {
            player.isInvincible = false;
          }
          player.dashCooldown = player.dashMaxCooldown;
        }

        // Apply dash movement
        player.x += player.dx;
        player.y += player.dy;

        // Boundary check during dash
        player.x = Math.max(0, Math.min(canvas.width - player.width, player.x));
        player.y = Math.max(0, Math.min(canvas.height - player.height, player.y));

        // Dashing counts as moving (no springlock failure)
        player.stillTimer = 0;
        player.springlockWarning = false;
        return;
      }

      player.dx = 0;
      player.dy = 0;

      if (keys['arrowup'] || keys['w']) player.dy = -player.speed;
      if (keys['arrowdown'] || keys['s']) player.dy = player.speed;
      if (keys['arrowleft'] || keys['a']) player.dx = -player.speed;
      if (keys['arrowright'] || keys['d']) player.dx = player.speed;

      // Normalize diagonal movement
      if (player.dx !== 0 && player.dy !== 0) {
        player.dx *= 0.707;
        player.dy *= 0.707;
      }

      // Track stillness for springlock failure
      if (player.dx === 0 && player.dy === 0) {
        player.stillTimer++;
        player.springlockWarning = player.stillTimer > player.maxStillTime * 0.5;

        // SPRINGLOCK FAILURE!
        if (player.stillTimer >= player.maxStillTime) {
          player.springlockFailure = true;
          player.failureFrame = 0;
          glitchIntensity = 50;
          playSpringlockCrunch();
        }
      } else {
        player.stillTimer = 0;
        player.springlockWarning = false;
      }

      player.x += player.dx;
      player.y += player.dy;

      // Boundary check
      player.x = Math.max(0, Math.min(canvas.width - player.width, player.x));
      player.y = Math.max(0, Math.min(canvas.height - player.height, player.y));
    }

    function updateGhosts() {
      ghosts.forEach(ghost => {
        // Move toward player
        const dx = player.x - ghost.x;
        const dy = player.y - ghost.y;
        const dist = Math.sqrt(dx * dx + dy * dy);

        if (dist > 0) {
          ghost.x += (dx / dist) * ghost.speed;
          ghost.y += (dy / dist) * ghost.speed;
        }

        // Wobble effect
        ghost.wobble += 0.1;
        ghost.x += Math.sin(ghost.wobble) * 0.5;
        ghost.y += Math.cos(ghost.wobble * 0.7) * 0.3;

        // Flicker alpha
        ghost.alpha = 0.6 + Math.sin(frameCount * 0.1 + ghost.wobble) * 0.3;
      });
    }

    function checkCollisions() {
      // Check ghost collisions (skip if invincible from dash)
      for (const ghost of ghosts) {
        if (rectCollision(player, ghost) && !player.isInvincible) {
          lives--;
          document.getElementById('lives').textContent = `LIVES: ${lives}`;
          glitchIntensity = 20;

          if (lives <= 0) {
            gameOver();
            return;
          }

          // Reset player position
          player.x = canvas.width / 2;
          player.y = canvas.height / 2;

          // Push ghosts away
          ghosts.forEach(g => {
            g.x = g.x < canvas.width / 2 ? -30 : canvas.width + 30;
            g.y = g.y < canvas.height / 2 ? -30 : canvas.height + 30;
          });
          break;
        }
      }

      // Check springlock collection
      springlocks.forEach(spring => {
        if (!spring.collected && rectCollision(player, spring)) {
          spring.collected = true;
          score += 100 * level;
          document.getElementById('score').textContent = `SCORE: ${score}`;

          // Check level up
          if (springlocks.every(s => s.collected)) {
            levelUp();
          }
        }
      });

      // Check golden mask collection
      goldenMasks.forEach(mask => {
        if (!mask.collected && rectCollision(player, mask)) {
          mask.collected = true;
          player.hasMask = true;
          player.maskTimer = player.maskMaxDuration; // 10 seconds
          player.isInvincible = true;
          playMaskPickupSound();
          glitchIntensity = 15;
          score += 250 * level; // Bonus points
          document.getElementById('score').textContent = `SCORE: ${score}`;
        }
      });
    }

    function rectCollision(a, b) {
      return a.x < b.x + b.width &&
             a.x + a.width > b.x &&
             a.y < b.y + b.height &&
             a.y + a.height > b.y;
    }

    function levelUp() {
      level++;
      document.getElementById('level').textContent = `LEVEL ${level}`;
      glitchIntensity = 30;

      // Reset springlocks
      springlocks = [];
      for (let i = 0; i < 5 + level; i++) {
        springlocks.push(createSpringlock());
      }

      // Spawn new golden mask
      goldenMasks = [];
      goldenMasks.push(createGoldenMask());

      // Add more ghosts (up to 5)
      if (ghosts.length < 5) {
        ghosts.push(createGhost(ghosts.length));
      }

      // Speed up existing ghosts
      ghosts.forEach(g => g.speed += 0.2);
    }

    // Game over animation state
    let gameOverActive = false;
    let gameOverFrame = 0;
    const gameOverDuration = 600; // 10 seconds at 60fps
    let bloodDrops = [];
    let jumpscareActive = false;
    let jumpscareFrame = 0;

    // Golden Freddy encounter state
    let goldenFreddyActive = false;
    let goldenFreddyTimer = 0;
    const goldenFreddyMaxTime = 300; // 5 seconds at 60fps
    let goldenFreddyX = 0;
    let goldenFreddyY = 0;
    let goldenFreddyClicked = false;

    function playJumpscareSound() {
      if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
      const now = audioCtx.currentTime;

      // Loud harsh screech
      const osc = audioCtx.createOscillator();
      osc.type = 'sawtooth';
      osc.frequency.setValueAtTime(800, now);
      osc.frequency.linearRampToValueAtTime(200, now + 0.3);

      const gain = audioCtx.createGain();
      gain.gain.setValueAtTime(0.6, now);
      gain.gain.linearRampToValueAtTime(0.3, now + 0.2);
      gain.gain.linearRampToValueAtTime(0.01, now + 0.5);

      osc.connect(gain);
      gain.connect(audioCtx.destination);
      osc.start(now);
      osc.stop(now + 0.5);

      // Low rumble
      const bass = audioCtx.createOscillator();
      bass.type = 'sine';
      bass.frequency.setValueAtTime(60, now);

      const bassGain = audioCtx.createGain();
      bassGain.gain.setValueAtTime(0.5, now);
      bassGain.gain.linearRampToValueAtTime(0.01, now + 0.4);

      bass.connect(bassGain);
      bassGain.connect(audioCtx.destination);
      bass.start(now);
      bass.stop(now + 0.5);
    }

    function triggerJumpscare() {
      jumpscareActive = true;
      jumpscareFrame = 0;
      playJumpscareSound();

      // Run jumpscare for 45 frames (~0.75 sec), then continue to normal game over
      function jumpscareLoop() {
        if (!jumpscareActive) return;

        jumpscareFrame++;
        ctx.fillStyle = '#000';
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        // Flashing scary face
        if (jumpscareFrame % 4 < 2) {
          ctx.save();

          // Shake
          ctx.translate((Math.random() - 0.5) * 30, (Math.random() - 0.5) * 30);

          // Giant scary face
          const faceX = canvas.width / 2;
          const faceY = canvas.height / 2;

          // Golden head
          ctx.fillStyle = '#ffd700';
          ctx.shadowColor = '#ff0000';
          ctx.shadowBlur = 50;
          ctx.beginPath();
          ctx.ellipse(faceX, faceY, 120, 140, 0, 0, Math.PI * 2);
          ctx.fill();

          // Ears
          ctx.fillRect(faceX - 100, faceY - 130, 40, 60);
          ctx.fillRect(faceX + 60, faceY - 130, 40, 60);

          // Empty black eyes
          ctx.fillStyle = '#000';
          ctx.beginPath();
          ctx.ellipse(faceX - 40, faceY - 20, 30, 40, 0, 0, Math.PI * 2);
          ctx.fill();
          ctx.beginPath();
          ctx.ellipse(faceX + 40, faceY - 20, 30, 40, 0, 0, Math.PI * 2);
          ctx.fill();

          // Tiny red pupils
          ctx.fillStyle = '#ff0000';
          ctx.shadowColor = '#ff0000';
          ctx.shadowBlur = 20;
          ctx.beginPath();
          ctx.arc(faceX - 40, faceY - 20, 8, 0, Math.PI * 2);
          ctx.fill();
          ctx.beginPath();
          ctx.arc(faceX + 40, faceY - 20, 8, 0, Math.PI * 2);
          ctx.fill();

          // Wide mouth with teeth
          ctx.fillStyle = '#000';
          ctx.fillRect(faceX - 60, faceY + 40, 120, 50);

          // Sharp teeth
          ctx.fillStyle = '#fff';
          for (let i = 0; i < 8; i++) {
            ctx.beginPath();
            ctx.moveTo(faceX - 55 + i * 15, faceY + 40);
            ctx.lineTo(faceX - 47 + i * 15, faceY + 65);
            ctx.lineTo(faceX - 40 + i * 15, faceY + 40);
            ctx.fill();
          }

          ctx.restore();
        }

        if (jumpscareFrame < 45) {
          requestAnimationFrame(jumpscareLoop);
        } else {
          jumpscareActive = false;
          // Now proceed to normal game over
          gameOverActive = true;
          gameOverFrame = 0;
          bloodDrops = [];
          playSpringlockCrunch();
          startDeathAudio();
          requestAnimationFrame(gameOverAnimation);
        }
      }

      requestAnimationFrame(jumpscareLoop);
    }

    function gameOver() {
      gameRunning = false;
      glitchIntensity = 30;
      goldenFreddyActive = false; // Cancel any Golden Freddy encounter

      // 5% chance of jumpscare
      if (Math.random() < 0.05) {
        triggerJumpscare();
        return;
      }

      gameOverActive = true;
      gameOverFrame = 0;
      bloodDrops = [];

      // Play extended crunch sound
      playSpringlockCrunch();

      // Start looping death audio (screams + crunches)
      startDeathAudio();

      // Start the death animation loop
      requestAnimationFrame(gameOverAnimation);
    }

    function spawnGoldenFreddy() {
      if (goldenFreddyActive || !gameRunning) return;

      goldenFreddyActive = true;
      goldenFreddyTimer = goldenFreddyMaxTime;
      goldenFreddyClicked = false;

      // Random position (not too close to edges)
      goldenFreddyX = 80 + Math.random() * (canvas.width - 160);
      goldenFreddyY = 80 + Math.random() * (canvas.height - 160);

      // Play eerie sound
      if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
      const now = audioCtx.currentTime;

      // Deep drone
      const drone = audioCtx.createOscillator();
      drone.type = 'sine';
      drone.frequency.setValueAtTime(50, now);

      const droneGain = audioCtx.createGain();
      droneGain.gain.setValueAtTime(0.3, now);
      droneGain.gain.linearRampToValueAtTime(0.01, now + 2);

      drone.connect(droneGain);
      droneGain.connect(audioCtx.destination);
      drone.start(now);
      drone.stop(now + 2);

      // High-pitched static
      const noise = audioCtx.createBufferSource();
      const bufferSize = audioCtx.sampleRate * 0.5;
      const buffer = audioCtx.createBuffer(1, bufferSize, audioCtx.sampleRate);
      const data = buffer.getChannelData(0);
      for (let i = 0; i < bufferSize; i++) {
        data[i] = (Math.random() * 2 - 1) * 0.3;
      }
      noise.buffer = buffer;

      const noiseGain = audioCtx.createGain();
      noiseGain.gain.setValueAtTime(0.1, now);
      noiseGain.gain.linearRampToValueAtTime(0.01, now + 0.5);

      noise.connect(noiseGain);
      noiseGain.connect(audioCtx.destination);
      noise.start(now);
    }

    function drawGoldenFreddy() {
      if (!goldenFreddyActive) return;

      ctx.save();

      // Flicker effect
      const flicker = Math.sin(frameCount * 0.5) > 0 ? 1 : 0.7;
      ctx.globalAlpha = flicker;

      const gfX = goldenFreddyX;
      const gfY = goldenFreddyY;

      // Slumped golden figure
      ctx.fillStyle = '#ffd700';
      ctx.shadowColor = '#ffd700';
      ctx.shadowBlur = 30;

      // Body (slumped)
      ctx.beginPath();
      ctx.ellipse(gfX, gfY + 20, 40, 50, 0, 0, Math.PI * 2);
      ctx.fill();

      // Head (tilted)
      ctx.beginPath();
      ctx.ellipse(gfX - 10, gfY - 35, 30, 35, -0.2, 0, Math.PI * 2);
      ctx.fill();

      // Ears
      ctx.fillRect(gfX - 35, gfY - 70, 15, 25);
      ctx.fillRect(gfX + 10, gfY - 65, 15, 25);

      // Empty black eyes
      ctx.fillStyle = '#000';
      ctx.shadowBlur = 0;
      ctx.beginPath();
      ctx.ellipse(gfX - 20, gfY - 40, 10, 14, -0.2, 0, Math.PI * 2);
      ctx.fill();
      ctx.beginPath();
      ctx.ellipse(gfX + 5, gfY - 38, 10, 14, -0.2, 0, Math.PI * 2);
      ctx.fill();

      // Tiny white pupils (creepy)
      ctx.fillStyle = '#fff';
      ctx.beginPath();
      ctx.arc(gfX - 20, gfY - 40, 3, 0, Math.PI * 2);
      ctx.fill();
      ctx.beginPath();
      ctx.arc(gfX + 5, gfY - 38, 3, 0, Math.PI * 2);
      ctx.fill();

      // IT'S ME text
      ctx.font = '16px "Press Start 2P"';
      ctx.fillStyle = `rgba(255, 255, 0, ${0.5 + Math.sin(frameCount * 0.2) * 0.3})`;
      ctx.textAlign = 'center';
      ctx.fillText("IT'S ME", gfX, gfY - 90);

      // Timer countdown
      const secondsLeft = Math.ceil(goldenFreddyTimer / 60);
      ctx.font = '12px "Press Start 2P"';
      ctx.fillStyle = secondsLeft <= 2 ? '#ff0000' : '#fff';
      ctx.fillText(`CLICK ME: ${secondsLeft}s`, gfX, gfY + 90);

      ctx.restore();
    }

    function checkGoldenFreddyClick(x, y) {
      if (!goldenFreddyActive || goldenFreddyClicked) return false;

      // Check if click is within Golden Freddy's bounds
      const dist = Math.sqrt(
        Math.pow(x - goldenFreddyX, 2) +
        Math.pow(y - goldenFreddyY, 2)
      );

      if (dist < 60) {
        goldenFreddyClicked = true;
        goldenFreddyActive = false;

        // Bonus points!
        score += 500 * level;
        document.getElementById('score').textContent = `SCORE: ${score}`;
        glitchIntensity = 20;

        // Play dismiss sound
        if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        const now = audioCtx.currentTime;

        const osc = audioCtx.createOscillator();
        osc.type = 'sine';
        osc.frequency.setValueAtTime(800, now);
        osc.frequency.exponentialRampToValueAtTime(100, now + 0.3);

        const gain = audioCtx.createGain();
        gain.gain.setValueAtTime(0.3, now);
        gain.gain.exponentialRampToValueAtTime(0.01, now + 0.3);

        osc.connect(gain);
        gain.connect(audioCtx.destination);
        osc.start(now);
        osc.stop(now + 0.3);

        return true;
      }
      return false;
    }

    function updateGoldenFreddy() {
      if (!goldenFreddyActive) {
        // Small chance to spawn Golden Freddy each frame (about once every 30-60 seconds)
        if (Math.random() < 0.0003 && gameRunning && !player.springlockFailure) {
          spawnGoldenFreddy();
        }
        return;
      }

      goldenFreddyTimer--;

      if (goldenFreddyTimer <= 0 && !goldenFreddyClicked) {
        // Time's up - Golden Freddy kills you!
        goldenFreddyActive = false;
        lives--;
        document.getElementById('lives').textContent = `LIVES: ${lives}`;
        glitchIntensity = 50;

        // Always jumpscare when Golden Freddy gets you
        if (lives <= 0) {
          triggerJumpscare();
          setTimeout(() => {
            gameRunning = false;
          }, 100);
        } else {
          // Reset player position
          player.x = canvas.width / 2;
          player.y = canvas.height / 2;
          player.musicBoxTimer = player.musicBoxMaxTime;

          // Push ghosts away
          ghosts.forEach(g => {
            g.x = g.x < canvas.width / 2 ? -30 : canvas.width + 30;
            g.y = g.y < canvas.height / 2 ? -30 : canvas.height + 30;
          });

          playJumpscareSound();
        }
      }
    }

    function gameOverAnimation() {
      if (!gameOverActive) return;

      gameOverFrame++;

      // Draw dark background
      ctx.fillStyle = '#0a0a12';
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      // Glitch effect
      if (Math.random() < 0.1) {
        ctx.fillStyle = `rgba(255, 0, 0, 0.1)`;
        ctx.fillRect(0, Math.random() * canvas.height, canvas.width, 10 + Math.random() * 30);
      }

      // Screen shake
      ctx.save();
      if (gameOverFrame < 60) {
        ctx.translate((Math.random() - 0.5) * 15, (Math.random() - 0.5) * 15);
      } else if (Math.random() < 0.05) {
        ctx.translate((Math.random() - 0.5) * 5, (Math.random() - 0.5) * 5);
      }

      // Draw the golden suit in center
      const suitX = canvas.width / 2 - 40;
      const suitY = canvas.height / 2 - 60;
      const suitWidth = 80;
      const suitHeight = 120;

      // Suit glow
      ctx.shadowColor = '#ffd700';
      ctx.shadowBlur = 20 + Math.sin(gameOverFrame * 0.1) * 10;

      // Golden suit body
      ctx.fillStyle = '#ffd700';
      ctx.fillRect(suitX + 10, suitY + 40, suitWidth - 20, suitHeight - 40);

      // Suit head
      ctx.beginPath();
      ctx.arc(suitX + suitWidth / 2, suitY + 30, 30, 0, Math.PI * 2);
      ctx.fill();

      // Ears
      ctx.fillRect(suitX + 5, suitY - 10, 15, 35);
      ctx.fillRect(suitX + suitWidth - 20, suitY - 10, 15, 35);

      // Dark interior (showing crushed purple guy)
      ctx.fillStyle = '#1a1a1a';
      ctx.fillRect(suitX + 20, suitY + 50, suitWidth - 40, suitHeight - 60);

      // Purple remains inside
      ctx.fillStyle = '#440066';
      ctx.globalAlpha = 0.7;
      ctx.fillRect(suitX + 25, suitY + 55, suitWidth - 50, suitHeight - 70);
      ctx.globalAlpha = 1;

      // Menacing red eyes
      ctx.fillStyle = '#ff0000';
      ctx.shadowColor = '#ff0000';
      ctx.shadowBlur = 15 + Math.sin(gameOverFrame * 0.2) * 10;
      ctx.beginPath();
      ctx.arc(suitX + 28, suitY + 25, 8, 0, Math.PI * 2);
      ctx.fill();
      ctx.beginPath();
      ctx.arc(suitX + suitWidth - 28, suitY + 25, 8, 0, Math.PI * 2);
      ctx.fill();

      // Evil smile
      ctx.fillStyle = '#000';
      ctx.shadowBlur = 0;
      ctx.beginPath();
      ctx.arc(suitX + suitWidth / 2, suitY + 40, 15, 0.1 * Math.PI, 0.9 * Math.PI);
      ctx.fill();

      // === RED LIQUID POURING OUT ===
      // Create new blood drops from multiple points
      if (gameOverFrame % 3 === 0) {
        // From seams of suit
        const dropPoints = [
          { x: suitX + 15, y: suitY + 60 },
          { x: suitX + suitWidth - 15, y: suitY + 60 },
          { x: suitX + suitWidth / 2 - 10, y: suitY + suitHeight },
          { x: suitX + suitWidth / 2 + 10, y: suitY + suitHeight },
          { x: suitX + 20, y: suitY + suitHeight - 10 },
          { x: suitX + suitWidth - 20, y: suitY + suitHeight - 10 },
        ];

        dropPoints.forEach(point => {
          if (Math.random() < 0.5) {
            bloodDrops.push({
              x: point.x + (Math.random() - 0.5) * 10,
              y: point.y,
              vx: (Math.random() - 0.5) * 2,
              vy: 2 + Math.random() * 3,
              size: 3 + Math.random() * 5,
              alpha: 1
            });
          }
        });
      }

      // Update and draw blood drops
      ctx.shadowColor = '#ff0000';
      ctx.shadowBlur = 5;
      bloodDrops.forEach((drop, i) => {
        drop.x += drop.vx;
        drop.y += drop.vy;
        drop.vy += 0.2; // gravity
        drop.alpha -= 0.005;

        if (drop.alpha > 0 && drop.y < canvas.height + 50) {
          ctx.fillStyle = `rgba(180, 0, 0, ${drop.alpha})`;
          ctx.beginPath();
          ctx.ellipse(drop.x, drop.y, drop.size * 0.6, drop.size, 0, 0, Math.PI * 2);
          ctx.fill();

          // Blood trail
          ctx.fillStyle = `rgba(120, 0, 0, ${drop.alpha * 0.5})`;
          ctx.fillRect(drop.x - 1, drop.y - drop.vy * 2, 2, drop.vy * 2);
        }
      });

      // Blood pool at bottom
      const poolSize = Math.min(gameOverFrame * 0.5, 200);
      const poolAlpha = Math.min(gameOverFrame / 100, 0.8);
      ctx.fillStyle = `rgba(100, 0, 0, ${poolAlpha})`;
      ctx.beginPath();
      ctx.ellipse(canvas.width / 2, suitY + suitHeight + 30, poolSize, poolSize * 0.3, 0, 0, Math.PI * 2);
      ctx.fill();

      // Darker center of pool
      ctx.fillStyle = `rgba(60, 0, 0, ${poolAlpha})`;
      ctx.beginPath();
      ctx.ellipse(canvas.width / 2, suitY + suitHeight + 30, poolSize * 0.6, poolSize * 0.2, 0, 0, Math.PI * 2);
      ctx.fill();

      ctx.restore();

      // Draw text
      ctx.save();
      ctx.font = '24px "Press Start 2P"';
      ctx.textAlign = 'center';

      // "GAME OVER" text with glitch
      if (gameOverFrame > 30) {
        ctx.fillStyle = '#ff0000';
        ctx.shadowColor = '#ff0000';
        ctx.shadowBlur = 20;

        const glitchOffset = Math.random() < 0.1 ? (Math.random() - 0.5) * 10 : 0;
        ctx.fillText('GAME OVER', canvas.width / 2 + glitchOffset, 60);
      }

      // Creepy messages
      if (gameOverFrame > 120 && gameOverFrame < 250) {
        ctx.font = '14px "Press Start 2P"';
        ctx.fillStyle = `rgba(255, 0, 0, ${0.5 + Math.sin(gameOverFrame * 0.1) * 0.3})`;
        ctx.fillText('THE SUIT ALWAYS FINDS ITS OWNER', canvas.width / 2, canvas.height - 80);
      } else if (gameOverFrame > 250 && gameOverFrame < 400) {
        ctx.font = '14px "Press Start 2P"';
        ctx.fillStyle = `rgba(255, 255, 0, ${0.5 + Math.sin(gameOverFrame * 0.1) * 0.3})`;
        ctx.fillText('I ALWAYS COME BACK', canvas.width / 2, canvas.height - 80);
      } else if (gameOverFrame > 400) {
        ctx.font = '12px "Press Start 2P"';
        ctx.fillStyle = `rgba(255, 255, 255, ${0.5 + Math.sin(gameOverFrame * 0.1) * 0.3})`;
        ctx.fillText('IT\'S ME', canvas.width / 2, canvas.height - 80);
      }

      // Score
      ctx.font = '16px "Press Start 2P"';
      ctx.fillStyle = '#ffff00';
      ctx.shadowColor = '#ffff00';
      ctx.shadowBlur = 10;
      ctx.fillText(`FINAL SCORE: ${score}`, canvas.width / 2, canvas.height - 40);

      ctx.restore();

      // Clean up old blood drops
      bloodDrops = bloodDrops.filter(d => d.alpha > 0 && d.y < canvas.height + 50);

      // Continue animation or show restart
      if (gameOverFrame < gameOverDuration) {
        requestAnimationFrame(gameOverAnimation);
      } else {
        // Stop the death audio
        stopDeathAudio();

        // Show restart button after 10 seconds
        gameOverActive = false;
        document.getElementById('game-over-screen').style.display = 'flex';
        document.getElementById('final-score').textContent = `SCORE: ${score}`;
      }
    }

    function drawBackground() {
      // Dark factory floor with grid
      ctx.fillStyle = '#0a0a12';
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      // Glitch offset
      const glitchX = glitchIntensity > 0 ? (Math.random() - 0.5) * glitchIntensity : 0;
      const glitchY = glitchIntensity > 0 ? (Math.random() - 0.5) * glitchIntensity : 0;

      ctx.save();
      ctx.translate(glitchX, glitchY);

      // Grid lines
      ctx.strokeStyle = '#1a1a2e';
      ctx.lineWidth = 1;
      for (let x = 0; x < canvas.width; x += 40) {
        ctx.beginPath();
        ctx.moveTo(x, 0);
        ctx.lineTo(x, canvas.height);
        ctx.stroke();
      }
      for (let y = 0; y < canvas.height; y += 40) {
        ctx.beginPath();
        ctx.moveTo(0, y);
        ctx.lineTo(canvas.width, y);
        ctx.stroke();
      }

      // Random glitch bars
      if (glitchIntensity > 5 || Math.random() < 0.02) {
        ctx.fillStyle = `rgba(${Math.random() > 0.5 ? '255,0,255' : '0,255,255'}, 0.1)`;
        const barY = Math.random() * canvas.height;
        const barH = 5 + Math.random() * 20;
        ctx.fillRect(0, barY, canvas.width, barH);
      }

      ctx.restore();

      // Decay glitch
      if (glitchIntensity > 0) glitchIntensity -= 0.5;
    }

    function drawPlayer() {
      ctx.save();

      // Draw dash trail effect
      if (player.isDashing) {
        ctx.globalAlpha = 0.4;
        for (let i = 1; i <= 4; i++) {
          const trailX = player.x - player.dashDirection.x * i * 10;
          const trailY = player.y - player.dashDirection.y * i * 10;
          ctx.globalAlpha = 0.3 - i * 0.06;

          ctx.shadowColor = '#00ff88';
          ctx.shadowBlur = 15;
          ctx.fillStyle = '#00ff88';
          ctx.fillRect(trailX + 5, trailY + 15, 20, 25);
          ctx.fillRect(trailX + 7, trailY, 16, 18);
        }
        ctx.globalAlpha = 1;
      }

      // Draw dash cooldown indicator
      if (player.dashCooldown > 0 && !player.isDashing) {
        const cooldownRatio = player.dashCooldown / player.dashMaxCooldown;
        ctx.fillStyle = 'rgba(0, 255, 136, 0.3)';
        ctx.fillRect(player.x, player.y + player.height + 5, player.width * (1 - cooldownRatio), 4);
        ctx.strokeStyle = '#00ff88';
        ctx.lineWidth = 1;
        ctx.strokeRect(player.x, player.y + player.height + 5, player.width, 4);
      }

      // SPRINGLOCK FAILURE ANIMATION
      if (player.springlockFailure) {
        const f = player.failureFrame;

        // Screen shake during failure
        ctx.translate((Math.random() - 0.5) * 10, (Math.random() - 0.5) * 10);

        // Draw golden suit crushing the player
        const crushProgress = Math.min(1, f / 30);
        const squash = 1 - crushProgress * 0.6;

        ctx.shadowColor = '#ff0000';
        ctx.shadowBlur = 30;

        // Golden suit shell closing
        ctx.fillStyle = '#ffd700';

        // Left half of suit
        ctx.fillRect(
          player.x - 10 + crushProgress * 10,
          player.y - 5,
          15,
          50
        );

        // Right half of suit
        ctx.fillRect(
          player.x + 25 - crushProgress * 10,
          player.y - 5,
          15,
          50
        );

        // Crushed purple guy inside
        ctx.fillStyle = '#6600aa';
        ctx.globalAlpha = 1 - crushProgress * 0.5;
        ctx.fillRect(
          player.x + 5,
          player.y + 15 + (1 - squash) * 10,
          20,
          25 * squash
        );
        ctx.fillRect(
          player.x + 7,
          player.y + (1 - squash) * 5,
          16,
          18 * squash
        );

        // BLOOD splatter
        ctx.globalAlpha = crushProgress;
        ctx.fillStyle = '#ff0000';
        for (let i = 0; i < 8; i++) {
          const angle = (i / 8) * Math.PI * 2 + f * 0.1;
          const dist = 10 + f * 0.5;
          ctx.beginPath();
          ctx.arc(
            player.x + 15 + Math.cos(angle) * dist,
            player.y + 20 + Math.sin(angle) * dist,
            3 + Math.random() * 3,
            0, Math.PI * 2
          );
          ctx.fill();
        }

        // Red eyes on suit
        ctx.fillStyle = '#ff0000';
        ctx.shadowColor = '#ff0000';
        ctx.shadowBlur = 20;
        ctx.globalAlpha = 0.5 + Math.sin(f * 0.5) * 0.5;
        ctx.fillRect(player.x + 3, player.y + 5, 5, 5);
        ctx.fillRect(player.x + 22, player.y + 5, 5, 5);

        // "SPRINGLOCK FAILURE" text
        if (f > 20) {
          ctx.globalAlpha = Math.min(1, (f - 20) / 20);
          ctx.font = '12px "Press Start 2P"';
          ctx.fillStyle = '#ff0000';
          ctx.textAlign = 'center';
          ctx.fillText('SPRINGLOCK', player.x + 15, player.y - 20);
          ctx.fillText('FAILURE', player.x + 15, player.y - 5);
        }

        ctx.restore();
        return;
      }

      // Warning indicator when staying still
      if (player.springlockWarning) {
        const warningProgress = (player.stillTimer - player.maxStillTime * 0.5) /
                               (player.maxStillTime * 0.5);

        // Flashing warning border
        ctx.strokeStyle = Math.sin(frameCount * 0.3) > 0 ? '#ff0000' : '#ffff00';
        ctx.lineWidth = 3;
        ctx.strokeRect(player.x - 5, player.y - 5, player.width + 10, player.height + 10);

        // Warning bar above player
        ctx.fillStyle = '#330000';
        ctx.fillRect(player.x - 5, player.y - 15, player.width + 10, 8);
        ctx.fillStyle = '#ff0000';
        ctx.fillRect(player.x - 4, player.y - 14, (player.width + 8) * warningProgress, 6);

        // "MOVE!" text
        if (Math.sin(frameCount * 0.2) > 0) {
          ctx.font = '10px "Press Start 2P"';
          ctx.fillStyle = '#ff0000';
          ctx.textAlign = 'center';
          ctx.fillText('MOVE!', player.x + 15, player.y - 20);
        }
      }

      // Golden mask invisible/invincible state
      if (player.hasMask) {
        // Flickering ghost effect
        ctx.globalAlpha = 0.3 + Math.sin(frameCount * 0.2) * 0.15;

        // Golden glow
        ctx.shadowColor = '#ffd700';
        ctx.shadowBlur = 25 + Math.sin(frameCount * 0.15) * 10;

        // Golden mask overlay on body
        ctx.fillStyle = '#ffd700';
        ctx.fillRect(player.x + 5, player.y + 15, 20, 25);

        // Golden head with mask
        ctx.beginPath();
        ctx.ellipse(player.x + 15, player.y + 9, 10, 12, 0, 0, Math.PI * 2);
        ctx.fill();

        // Mask eye holes (glowing cyan)
        ctx.fillStyle = '#00ffff';
        ctx.shadowColor = '#00ffff';
        ctx.shadowBlur = 10;
        ctx.beginPath();
        ctx.arc(player.x + 11, player.y + 8, 3, 0, Math.PI * 2);
        ctx.fill();
        ctx.beginPath();
        ctx.arc(player.x + 19, player.y + 8, 3, 0, Math.PI * 2);
        ctx.fill();

        // Mask forehead gem
        ctx.fillStyle = '#ff00ff';
        ctx.shadowColor = '#ff00ff';
        ctx.beginPath();
        ctx.arc(player.x + 15, player.y + 2, 3, 0, Math.PI * 2);
        ctx.fill();

        // Ghost trail particles
        for (let i = 0; i < 3; i++) {
          ctx.globalAlpha = 0.1 + Math.random() * 0.1;
          ctx.fillStyle = '#ffd700';
          ctx.beginPath();
          ctx.arc(
            player.x + 15 + (Math.random() - 0.5) * 30,
            player.y + 20 + Math.random() * 20,
            2 + Math.random() * 3,
            0, Math.PI * 2
          );
          ctx.fill();
        }

        ctx.restore();
        return;
      }

      // Glow effect
      ctx.shadowColor = player.isDashing ? '#00ff88' : (player.springlockWarning ? '#ff0000' : '#6600aa');
      ctx.shadowBlur = player.isDashing ? 25 : 15;

      // Body
      ctx.fillStyle = player.isDashing ? '#00ff88' : player.color;
      ctx.fillRect(player.x + 5, player.y + 15, 20, 25);

      // Head
      ctx.fillRect(player.x + 7, player.y, 16, 18);

      // Eyes (menacing white, or red during warning, or green during dash)
      ctx.fillStyle = player.isDashing ? '#ffffff' : (player.springlockWarning ? '#ff0000' : '#fff');
      ctx.fillRect(player.x + 10, player.y + 6, 4, 4);
      ctx.fillRect(player.x + 16, player.y + 6, 4, 4);

      // Evil grin
      ctx.fillStyle = '#fff';
      ctx.fillRect(player.x + 10, player.y + 13, 10, 2);

      ctx.restore();
    }

    function drawGhosts() {
      ghosts.forEach(ghost => {
        ctx.save();
        ctx.globalAlpha = ghost.alpha;

        // Glow
        ctx.shadowColor = ghost.color;
        ctx.shadowBlur = 20;

        // Body (simple ghost shape)
        ctx.fillStyle = ghost.color;
        ctx.beginPath();
        ctx.ellipse(ghost.x + ghost.width/2, ghost.y + ghost.height/2,
                   ghost.width/2, ghost.height/2, 0, 0, Math.PI * 2);
        ctx.fill();

        // Wavy bottom
        ctx.beginPath();
        ctx.moveTo(ghost.x, ghost.y + ghost.height * 0.6);
        for (let i = 0; i <= ghost.width; i += 5) {
          const wave = Math.sin((i + frameCount * 3) * 0.2) * 3;
          ctx.lineTo(ghost.x + i, ghost.y + ghost.height + wave);
        }
        ctx.lineTo(ghost.x + ghost.width, ghost.y + ghost.height * 0.6);
        ctx.fill();

        // Empty eyes
        ctx.fillStyle = '#000';
        ctx.beginPath();
        ctx.ellipse(ghost.x + 8, ghost.y + 12, 4, 5, 0, 0, Math.PI * 2);
        ctx.fill();
        ctx.beginPath();
        ctx.ellipse(ghost.x + 17, ghost.y + 12, 4, 5, 0, 0, Math.PI * 2);
        ctx.fill();

        // Tear streaks
        ctx.fillStyle = ghost.color;
        ctx.globalAlpha = 0.5;
        ctx.fillRect(ghost.x + 7, ghost.y + 17, 2, 8);
        ctx.fillRect(ghost.x + 16, ghost.y + 17, 2, 8);

        ctx.restore();
      });
    }

    function drawSpringlocks() {
      springlocks.forEach(spring => {
        if (spring.collected) return;

        ctx.save();
        spring.glow = (spring.glow + 0.1) % (Math.PI * 2);
        const glowIntensity = 10 + Math.sin(spring.glow) * 5;

        ctx.shadowColor = '#ffd700';
        ctx.shadowBlur = glowIntensity;

        // Golden springlock (simplified animatronic head shape)
        ctx.fillStyle = '#ffd700';

        // Main body
        ctx.fillRect(spring.x + 2, spring.y + 8, 16, 17);

        // Head
        ctx.beginPath();
        ctx.arc(spring.x + 10, spring.y + 8, 10, 0, Math.PI * 2);
        ctx.fill();

        // Ears
        ctx.fillRect(spring.x, spring.y - 2, 4, 8);
        ctx.fillRect(spring.x + 16, spring.y - 2, 4, 8);

        // Eyes (dark, ominous)
        ctx.fillStyle = '#000';
        ctx.fillRect(spring.x + 5, spring.y + 5, 4, 4);
        ctx.fillRect(spring.x + 11, spring.y + 5, 4, 4);

        ctx.restore();
      });
    }

    function drawGoldenMasks() {
      goldenMasks.forEach(mask => {
        if (mask.collected) return;

        ctx.save();
        mask.glow = (mask.glow + 0.08) % (Math.PI * 2);
        mask.floatOffset += 0.05;
        const floatY = Math.sin(mask.floatOffset) * 5;
        const glowIntensity = 15 + Math.sin(mask.glow) * 10;

        // Intense golden glow
        ctx.shadowColor = '#ffd700';
        ctx.shadowBlur = glowIntensity;

        const mx = mask.x;
        const my = mask.y + floatY;

        // Outer glow ring
        ctx.strokeStyle = `rgba(255, 215, 0, ${0.3 + Math.sin(mask.glow) * 0.2})`;
        ctx.lineWidth = 3;
        ctx.beginPath();
        ctx.ellipse(mx + mask.width / 2, my + mask.height / 2, mask.width / 2 + 8, mask.height / 2 + 8, 0, 0, Math.PI * 2);
        ctx.stroke();

        // Golden mask face
        ctx.fillStyle = '#ffd700';
        ctx.beginPath();
        ctx.ellipse(mx + mask.width / 2, my + mask.height / 2 - 2, mask.width / 2, mask.height / 2, 0, 0, Math.PI * 2);
        ctx.fill();

        // Forehead jewel
        ctx.fillStyle = '#ff00ff';
        ctx.shadowColor = '#ff00ff';
        ctx.shadowBlur = 10;
        ctx.beginPath();
        ctx.arc(mx + mask.width / 2, my + 6, 4, 0, Math.PI * 2);
        ctx.fill();

        // Eye holes (dark, mysterious)
        ctx.fillStyle = '#000';
        ctx.shadowBlur = 0;
        ctx.beginPath();
        ctx.ellipse(mx + 8, my + 14, 4, 5, 0, 0, Math.PI * 2);
        ctx.fill();
        ctx.beginPath();
        ctx.ellipse(mx + 20, my + 14, 4, 5, 0, 0, Math.PI * 2);
        ctx.fill();

        // Inner eye glow (cyan)
        ctx.fillStyle = '#00ffff';
        ctx.shadowColor = '#00ffff';
        ctx.shadowBlur = 8;
        ctx.beginPath();
        ctx.arc(mx + 8, my + 14, 2, 0, Math.PI * 2);
        ctx.fill();
        ctx.beginPath();
        ctx.arc(mx + 20, my + 14, 2, 0, Math.PI * 2);
        ctx.fill();

        // Decorative lines
        ctx.strokeStyle = '#cc9900';
        ctx.lineWidth = 2;
        ctx.shadowBlur = 0;
        ctx.beginPath();
        ctx.moveTo(mx + 4, my + 22);
        ctx.lineTo(mx + mask.width - 4, my + 22);
        ctx.stroke();

        // "MASK" text floating above
        ctx.font = '8px "Press Start 2P"';
        ctx.fillStyle = `rgba(255, 215, 0, ${0.5 + Math.sin(mask.glow * 2) * 0.3})`;
        ctx.textAlign = 'center';
        ctx.fillText('MASK', mx + mask.width / 2, my - 8);

        ctx.restore();
      });
    }

    function drawHUD() {
      // IT'S ME text occasionally
      if (Math.random() < 0.005 && gameRunning) {
        ctx.save();
        ctx.font = '40px "Press Start 2P"';
        ctx.fillStyle = `rgba(255, 0, 0, ${0.3 + Math.random() * 0.5})`;
        ctx.textAlign = 'center';
        ctx.fillText("IT'S ME", canvas.width / 2, canvas.height / 2);
        ctx.restore();
      }

      // Golden Mask power-up timer
      if (player.hasMask && player.maskTimer > 0) {
        ctx.save();
        const timerWidth = 150;
        const timerHeight = 20;
        const timerX = (canvas.width - timerWidth) / 2;
        const timerY = canvas.height - 40;
        const progress = player.maskTimer / player.maskMaxDuration;
        const secondsLeft = Math.ceil(player.maskTimer / 60);

        // Background bar
        ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
        ctx.fillRect(timerX - 2, timerY - 2, timerWidth + 4, timerHeight + 4);

        // Timer bar (golden gradient)
        const gradient = ctx.createLinearGradient(timerX, timerY, timerX + timerWidth * progress, timerY);
        gradient.addColorStop(0, '#ffd700');
        gradient.addColorStop(1, '#ffaa00');
        ctx.fillStyle = gradient;
        ctx.shadowColor = '#ffd700';
        ctx.shadowBlur = 10;
        ctx.fillRect(timerX, timerY, timerWidth * progress, timerHeight);

        // Border
        ctx.strokeStyle = '#ffd700';
        ctx.lineWidth = 2;
        ctx.strokeRect(timerX, timerY, timerWidth, timerHeight);

        // Label
        ctx.font = '10px "Press Start 2P"';
        ctx.fillStyle = '#fff';
        ctx.textAlign = 'center';
        ctx.shadowBlur = 5;
        ctx.fillText(`INVISIBLE ${secondsLeft}s`, canvas.width / 2, timerY + 14);

        ctx.restore();
      }

      // Music Box indicator (top right)
      ctx.save();
      const mbWidth = 100;
      const mbHeight = 14;
      const mbX = canvas.width - mbWidth - 10;
      const mbY = 35;
      const mbProgress = player.musicBoxTimer / player.musicBoxMaxTime;
      const mbSecondsLeft = Math.ceil(player.musicBoxTimer / 60);
      const isWarning = mbProgress < 0.3;
      const isCritical = mbProgress < 0.15;

      // Background
      ctx.fillStyle = 'rgba(0, 0, 0, 0.6)';
      ctx.fillRect(mbX - 2, mbY - 2, mbWidth + 4, mbHeight + 4);

      // Timer bar
      let mbColor = '#00ffff';
      if (isCritical) {
        mbColor = Math.sin(frameCount * 0.5) > 0 ? '#ff0000' : '#ff6600';
      } else if (isWarning) {
        mbColor = '#ffaa00';
      }
      ctx.fillStyle = mbColor;
      ctx.shadowColor = mbColor;
      ctx.shadowBlur = isCritical ? 15 : 8;
      ctx.fillRect(mbX, mbY, mbWidth * mbProgress, mbHeight);

      // Border
      ctx.strokeStyle = isCritical ? '#ff0000' : '#00aaaa';
      ctx.lineWidth = 2;
      ctx.strokeRect(mbX, mbY, mbWidth, mbHeight);

      // Label
      ctx.font = '8px "Press Start 2P"';
      ctx.fillStyle = isCritical ? '#ff0000' : '#00ffff';
      ctx.textAlign = 'right';
      ctx.shadowBlur = 5;
      const mbLabel = player.musicBoxWinding ? 'WINDING...' : `MUSIC BOX [R]`;
      ctx.fillText(mbLabel, canvas.width - 10, mbY - 5);

      // Critical warning text
      if (isCritical && Math.sin(frameCount * 0.3) > 0) {
        ctx.font = '10px "Press Start 2P"';
        ctx.fillStyle = '#ff0000';
        ctx.textAlign = 'center';
        ctx.fillText('WIND THE BOX!', canvas.width / 2, 80);
      }

      ctx.restore();
    }

    function gameLoop() {
      if (!gameRunning) return;

      frameCount++;

      updatePlayer();
      updateGhosts();
      updateGoldenFreddy();
      checkCollisions();

      drawBackground();
      drawSpringlocks();
      drawGoldenMasks();
      drawPlayer();
      drawGhosts();
      drawGoldenFreddy();
      drawHUD();

      requestAnimationFrame(gameLoop);
    }

    function startGame() {
      document.getElementById('start-screen').style.display = 'none';
      document.getElementById('game-over-screen').style.display = 'none';

      // Stop any playing death audio
      stopDeathAudio();

      score = 0;
      lives = 3;
      level = 1;
      glitchIntensity = 0;

      document.getElementById('score').textContent = 'SCORE: 0';
      document.getElementById('lives').textContent = 'LIVES: 3';
      document.getElementById('level').textContent = 'LEVEL 1';

      initGame();
      gameRunning = true;
      gameLoop();
    }

    // Handle resize
    window.addEventListener('resize', () => {
      const newWidth = Math.min(800, window.innerWidth - 20);
      const newHeight = Math.min(600, window.innerHeight - 150);
      canvas.width = newWidth;
      canvas.height = newHeight;
    });

    // Draw initial screen
    drawBackground();
  </script>
</body>
</html>
