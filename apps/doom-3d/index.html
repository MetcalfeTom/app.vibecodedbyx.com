<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>DOOM 3D - First Person Shooter</title>
    <link rel="icon" href="https://emojicdn.elk.sh/ðŸ’€">

    <meta property="og:title" content="DOOM 3D">
    <meta property="og:description" content="First-person 3D shooter with Three.js">
    <meta property="og:url" content="https://app.vibecodedbyx.com/doom-3d">
    <meta property="og:image" content="https://emojicdn.elk.sh/ðŸ’€.png">

    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Courier New', monospace;
            background: #000;
            color: #0f0;
            overflow: hidden;
        }

        #gameContainer {
            width: 100vw;
            height: 100vh;
            position: relative;
        }

        .hud {
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            background: linear-gradient(to top, rgba(0,0,0,0.9), transparent);
            padding: 20px;
            display: flex;
            justify-content: space-around;
            align-items: center;
            z-index: 100;
            pointer-events: none;
        }

        .hud-item {
            font-size: 24px;
            font-weight: bold;
            text-shadow: 2px 2px 4px #000;
            color: #0f0;
        }

        .hud-item.low {
            color: #f00;
            animation: blink 0.5s infinite;
        }

        @keyframes blink {
            0%, 50% { opacity: 1; }
            51%, 100% { opacity: 0.3; }
        }

        .crosshair {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 20px;
            height: 20px;
            pointer-events: none;
            z-index: 99;
        }

        .crosshair::before,
        .crosshair::after {
            content: '';
            position: absolute;
            background: #0f0;
        }

        .crosshair::before {
            width: 2px;
            height: 20px;
            left: 9px;
            top: 0;
        }

        .crosshair::after {
            width: 20px;
            height: 2px;
            left: 0;
            top: 9px;
        }

        .start-screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.95);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }

        .start-screen h1 {
            font-size: 72px;
            color: #f00;
            margin-bottom: 30px;
            text-shadow: 0 0 20px #f00;
            animation: pulse 2s infinite;
        }

        @keyframes pulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.05); }
        }

        .start-btn {
            padding: 20px 60px;
            background: #8b0000;
            border: 3px solid #f00;
            color: #fff;
            font-size: 28px;
            font-weight: bold;
            cursor: pointer;
            font-family: 'Courier New', monospace;
            transition: all 0.3s;
        }

        .start-btn:hover {
            background: #f00;
            box-shadow: 0 0 30px #f00;
        }

        .instructions {
            margin-top: 40px;
            color: #ff6666;
            text-align: center;
            line-height: 2;
            font-size: 18px;
        }

        .game-over {
            display: none;
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(139, 0, 0, 0.95);
            padding: 60px;
            border: 5px solid #f00;
            text-align: center;
            z-index: 1000;
        }

        .game-over.show {
            display: block;
        }

        .game-over h2 {
            font-size: 64px;
            color: #f00;
            margin-bottom: 30px;
            text-shadow: 0 0 20px #f00;
        }

        .back-link {
            position: fixed;
            top: 20px;
            right: 20px;
            background: #8b0000;
            color: #fff;
            text-decoration: none;
            padding: 12px 24px;
            border: 2px solid #f00;
            font-weight: bold;
            z-index: 1001;
            transition: all 0.3s;
        }

        .back-link:hover {
            background: #f00;
            box-shadow: 0 0 20px #f00;
        }
    </style>
</head>
<body>
    <a href="https://www.vibecodedbyx.com" class="back-link">EXIT</a>

    <div id="gameContainer"></div>

    <div class="crosshair"></div>

    <div class="hud">
        <div class="hud-item" id="health">HEALTH: 100</div>
        <div class="hud-item" id="ammo">AMMO: 50</div>
        <div class="hud-item" id="kills">KILLS: 0</div>
    </div>

    <div class="start-screen" id="startScreen">
        <h1>ðŸ’€ DOOM 3D ðŸ’€</h1>
        <button class="start-btn" onclick="startGame()">START GAME</button>
        <div class="instructions">
            <div>WASD - MOVE</div>
            <div>MOUSE - LOOK AROUND</div>
            <div>CLICK - SHOOT</div>
            <div>RIP AND TEAR</div>
        </div>
    </div>

    <div class="game-over" id="gameOver">
        <h2>YOU DIED</h2>
        <div style="color: #ff6666; margin-bottom: 30px; font-size: 28px;">
            KILLS: <span id="finalKills">0</span>
        </div>
        <button class="start-btn" onclick="restartGame()">RESTART</button>
    </div>

    <script type="importmap">
    {
        "imports": {
            "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js"
        }
    }
    </script>

    <script type="module">
        import * as THREE from 'three';

        let scene, camera, renderer, clock;
        let gameRunning = false;
        let player = {
            health: 100,
            ammo: 50,
            speed: 0.15,
            height: 1.6
        };
        let enemies = [];
        let bullets = [];
        let kills = 0;
        let keys = {};
        let mouseX = 0, mouseY = 0;
        let velocity = new THREE.Vector3();
        let direction = new THREE.Vector3();
        let enemySpawnTimer = 0;

        // Initialize Three.js scene
        function initScene() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x1a0000);
            scene.fog = new THREE.Fog(0x1a0000, 0, 50);

            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, player.height, 0);

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            document.getElementById('gameContainer').appendChild(renderer.domElement);

            clock = new THREE.Clock();

            // Lighting
            const ambientLight = new THREE.AmbientLight(0x330000, 0.5);
            scene.add(ambientLight);

            const pointLight = new THREE.PointLight(0xff0000, 1, 50);
            pointLight.position.set(0, 10, 0);
            pointLight.castShadow = true;
            scene.add(pointLight);

            // Floor
            const floorGeometry = new THREE.PlaneGeometry(100, 100, 20, 20);
            const floorTexture = createCheckerTexture();
            const floorMaterial = new THREE.MeshStandardMaterial({
                map: floorTexture,
                roughness: 0.8,
                metalness: 0.2
            });
            const floor = new THREE.Mesh(floorGeometry, floorMaterial);
            floor.rotation.x = -Math.PI / 2;
            floor.receiveShadow = true;
            scene.add(floor);

            // Walls
            createWalls();

            window.addEventListener('resize', onWindowResize);
        }

        function createCheckerTexture() {
            const size = 512;
            const canvas = document.createElement('canvas');
            canvas.width = size;
            canvas.height = size;
            const ctx = canvas.getContext('2d');

            const tileSize = size / 8;
            for (let i = 0; i < 8; i++) {
                for (let j = 0; j < 8; j++) {
                    ctx.fillStyle = (i + j) % 2 === 0 ? '#2a0000' : '#1a0000';
                    ctx.fillRect(i * tileSize, j * tileSize, tileSize, tileSize);
                }
            }

            const texture = new THREE.CanvasTexture(canvas);
            texture.wrapS = THREE.RepeatWrapping;
            texture.wrapT = THREE.RepeatWrapping;
            texture.repeat.set(10, 10);
            return texture;
        }

        function createBrickTexture() {
            const size = 512;
            const canvas = document.createElement('canvas');
            canvas.width = size;
            canvas.height = size;
            const ctx = canvas.getContext('2d');

            ctx.fillStyle = '#3d0000';
            ctx.fillRect(0, 0, size, size);

            ctx.strokeStyle = '#1a0000';
            ctx.lineWidth = 4;

            const brickWidth = size / 8;
            const brickHeight = size / 16;

            for (let row = 0; row < 16; row++) {
                for (let col = 0; col < 8; col++) {
                    const offset = row % 2 === 0 ? 0 : brickWidth / 2;
                    ctx.strokeRect(col * brickWidth + offset, row * brickHeight, brickWidth, brickHeight);
                }
            }

            const texture = new THREE.CanvasTexture(canvas);
            texture.wrapS = THREE.RepeatWrapping;
            texture.wrapT = THREE.RepeatWrapping;
            texture.repeat.set(5, 5);
            return texture;
        }

        function createWalls() {
            const wallTexture = createBrickTexture();
            const wallMaterial = new THREE.MeshStandardMaterial({
                map: wallTexture,
                roughness: 0.9,
                metalness: 0.1
            });

            const wallHeight = 5;
            const wallThickness = 1;
            const arenaSize = 50;

            // North wall
            const northWall = new THREE.Mesh(
                new THREE.BoxGeometry(arenaSize, wallHeight, wallThickness),
                wallMaterial
            );
            northWall.position.set(0, wallHeight / 2, -arenaSize / 2);
            northWall.castShadow = true;
            northWall.receiveShadow = true;
            scene.add(northWall);

            // South wall
            const southWall = new THREE.Mesh(
                new THREE.BoxGeometry(arenaSize, wallHeight, wallThickness),
                wallMaterial
            );
            southWall.position.set(0, wallHeight / 2, arenaSize / 2);
            southWall.castShadow = true;
            southWall.receiveShadow = true;
            scene.add(southWall);

            // East wall
            const eastWall = new THREE.Mesh(
                new THREE.BoxGeometry(wallThickness, wallHeight, arenaSize),
                wallMaterial
            );
            eastWall.position.set(arenaSize / 2, wallHeight / 2, 0);
            eastWall.castShadow = true;
            eastWall.receiveShadow = true;
            scene.add(eastWall);

            // West wall
            const westWall = new THREE.Mesh(
                new THREE.BoxGeometry(wallThickness, wallHeight, arenaSize),
                wallMaterial
            );
            westWall.position.set(-arenaSize / 2, wallHeight / 2, 0);
            westWall.castShadow = true;
            westWall.receiveShadow = true;
            scene.add(westWall);
        }

        function createEnemy() {
            const geometry = new THREE.SphereGeometry(0.8, 16, 16);
            const material = new THREE.MeshStandardMaterial({
                color: 0xff0000,
                emissive: 0x440000,
                roughness: 0.7,
                metalness: 0.3
            });
            const mesh = new THREE.Mesh(geometry, material);
            mesh.castShadow = true;

            // Spawn at random edge
            const side = Math.floor(Math.random() * 4);
            const pos = 20;
            switch(side) {
                case 0: mesh.position.set(Math.random() * 40 - 20, 0.8, -pos); break;
                case 1: mesh.position.set(pos, 0.8, Math.random() * 40 - 20); break;
                case 2: mesh.position.set(Math.random() * 40 - 20, 0.8, pos); break;
                case 3: mesh.position.set(-pos, 0.8, Math.random() * 40 - 20); break;
            }

            scene.add(mesh);

            const enemy = {
                mesh: mesh,
                health: 3,
                speed: 0.05 + Math.random() * 0.03
            };

            enemies.push(enemy);
        }

        function spawnEnemies() {
            enemySpawnTimer++;
            const spawnRate = 60 - Math.min(kills, 40);
            if (enemySpawnTimer > spawnRate) {
                createEnemy();
                enemySpawnTimer = 0;
            }
        }

        function shoot() {
            if (player.ammo <= 0) return;

            player.ammo--;
            updateHUD();

            // Create bullet
            const bulletGeometry = new THREE.SphereGeometry(0.1, 8, 8);
            const bulletMaterial = new THREE.MeshBasicMaterial({
                color: 0xffff00,
                emissive: 0xffff00
            });
            const bulletMesh = new THREE.Mesh(bulletGeometry, bulletMaterial);
            bulletMesh.position.copy(camera.position);

            const direction = new THREE.Vector3();
            camera.getWorldDirection(direction);

            scene.add(bulletMesh);

            bullets.push({
                mesh: bulletMesh,
                direction: direction.clone(),
                speed: 0.8,
                life: 100
            });
        }

        function updateBullets() {
            for (let i = bullets.length - 1; i >= 0; i--) {
                const bullet = bullets[i];
                bullet.mesh.position.addScaledVector(bullet.direction, bullet.speed);
                bullet.life--;

                if (bullet.life <= 0) {
                    scene.remove(bullet.mesh);
                    bullets.splice(i, 1);
                    continue;
                }

                // Check collision with enemies
                for (let j = enemies.length - 1; j >= 0; j--) {
                    const enemy = enemies[j];
                    const dist = bullet.mesh.position.distanceTo(enemy.mesh.position);
                    if (dist < 0.8) {
                        enemy.health--;
                        scene.remove(bullet.mesh);
                        bullets.splice(i, 1);

                        if (enemy.health <= 0) {
                            scene.remove(enemy.mesh);
                            enemies.splice(j, 1);
                            kills++;
                            player.ammo += 5;
                            updateHUD();
                        }
                        break;
                    }
                }
            }
        }

        function updateEnemies() {
            for (let i = enemies.length - 1; i >= 0; i--) {
                const enemy = enemies[i];
                const direction = new THREE.Vector3();
                direction.subVectors(camera.position, enemy.mesh.position).normalize();
                enemy.mesh.position.addScaledVector(direction, enemy.speed);

                // Check collision with player
                const dist = enemy.mesh.position.distanceTo(camera.position);
                if (dist < 1.5) {
                    player.health -= 1;
                    updateHUD();
                    if (player.health <= 0) {
                        gameOver();
                    }
                }
            }
        }

        function updateHUD() {
            document.getElementById('health').textContent = `HEALTH: ${player.health}`;
            document.getElementById('health').className = player.health < 30 ? 'hud-item low' : 'hud-item';
            document.getElementById('ammo').textContent = `AMMO: ${player.ammo}`;
            document.getElementById('kills').textContent = `KILLS: ${kills}`;
        }

        function animate() {
            if (!gameRunning) return;

            requestAnimationFrame(animate);

            const delta = clock.getDelta();

            // Movement
            velocity.x = 0;
            velocity.z = 0;

            direction.z = Number(keys['w']) - Number(keys['s']);
            direction.x = Number(keys['d']) - Number(keys['a']);
            direction.normalize();

            if (keys['w']) velocity.z -= player.speed;
            if (keys['s']) velocity.z += player.speed;
            if (keys['a']) velocity.x -= player.speed;
            if (keys['d']) velocity.x += player.speed;

            camera.position.add(velocity.applyEuler(camera.rotation));

            // Keep in bounds
            camera.position.x = Math.max(-23, Math.min(23, camera.position.x));
            camera.position.z = Math.max(-23, Math.min(23, camera.position.z));

            spawnEnemies();
            updateBullets();
            updateEnemies();

            renderer.render(scene, camera);
        }

        function startGame() {
            document.getElementById('startScreen').style.display = 'none';
            gameRunning = true;
            player.health = 100;
            player.ammo = 50;
            kills = 0;
            enemySpawnTimer = 0;
            updateHUD();

            if (!scene) {
                initScene();
            }

            // Clear enemies and bullets
            enemies.forEach(e => scene.remove(e.mesh));
            bullets.forEach(b => scene.remove(b.mesh));
            enemies = [];
            bullets = [];

            camera.position.set(0, player.height, 0);
            camera.rotation.set(0, 0, 0);

            document.body.requestPointerLock();
            animate();
        }

        function restartGame() {
            document.getElementById('gameOver').classList.remove('show');
            startGame();
        }

        function gameOver() {
            gameRunning = false;
            document.getElementById('finalKills').textContent = kills;
            document.getElementById('gameOver').classList.add('show');
            document.exitPointerLock();
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        // Controls
        document.addEventListener('keydown', (e) => {
            keys[e.key.toLowerCase()] = true;
        });

        document.addEventListener('keyup', (e) => {
            keys[e.key.toLowerCase()] = false;
        });

        document.addEventListener('mousemove', (e) => {
            if (document.pointerLockElement === renderer.domElement) {
                camera.rotation.y -= e.movementX * 0.002;
                camera.rotation.x -= e.movementY * 0.002;
                camera.rotation.x = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, camera.rotation.x));
            }
        });

        document.addEventListener('click', () => {
            if (gameRunning) {
                shoot();
            }
        });

        window.startGame = startGame;
        window.restartGame = restartGame;
    </script>
</body>
</html>
