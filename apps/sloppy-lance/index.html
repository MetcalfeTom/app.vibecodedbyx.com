<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Sloppy-Lance</title>
  <link rel="icon" href="https://emojicdn.elk.sh/üõ°Ô∏è">
  <meta property="og:title" content="Sloppy-Lance">
  <meta property="og:description" content="Cybersecurity dashboard with A* intrusion tracing">
  <meta property="og:url" content="https://sloppy.live/sloppy-lance">
  <meta property="og:image" content="https://emojicdn.elk.sh/üõ°Ô∏è?style=apple&size=512">
  <link href="https://fonts.googleapis.com/css2?family=Rajdhani:wght@400;600;700&family=Share+Tech+Mono&display=swap" rel="stylesheet">
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }

    :root {
      --bg: #0a0e14;
      --panel: #0d1219;
      --border: #1a2332;
      --red: #ff3333;
      --orange: #ff8c00;
      --yellow: #ffd700;
      --green: #00ff88;
      --cyan: #00d4ff;
      --blue: #0066ff;
      --purple: #9945ff;
      --text: #e4e8ef;
      --muted: #4a5568;
    }

    body {
      background: var(--bg);
      font-family: 'Rajdhani', sans-serif;
      color: var(--text);
      overflow: hidden;
      height: 100vh;
    }

    .dashboard {
      display: grid;
      grid-template-columns: 280px 1fr 320px;
      grid-template-rows: 60px 1fr 200px;
      height: 100vh;
      gap: 1px;
      background: var(--border);
    }

    @media (max-width: 1200px) {
      .dashboard {
        grid-template-columns: 1fr;
        grid-template-rows: 60px 1fr auto auto;
      }
      .left-panel, .right-panel { display: none; }
    }

    /* Header */
    .header {
      grid-column: 1 / -1;
      background: var(--panel);
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 0 20px;
    }

    .logo {
      display: flex;
      align-items: center;
      gap: 12px;
    }

    .logo-icon {
      width: 40px;
      height: 40px;
      background: linear-gradient(135deg, var(--red), var(--purple));
      border-radius: 8px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 1.3rem;
      animation: logo-pulse 2s ease-in-out infinite;
    }

    @keyframes logo-pulse {
      0%, 100% { box-shadow: 0 0 15px var(--red); }
      50% { box-shadow: 0 0 25px var(--purple); }
    }

    .logo h1 {
      font-size: 1.5rem;
      font-weight: 700;
      letter-spacing: 2px;
    }

    .logo h1 span {
      color: var(--red);
    }

    .header-stats {
      display: flex;
      gap: 30px;
    }

    .stat {
      text-align: center;
    }

    .stat-value {
      font-family: 'Share Tech Mono', monospace;
      font-size: 1.4rem;
      font-weight: 700;
    }

    .stat-value.danger { color: var(--red); text-shadow: 0 0 10px var(--red); }
    .stat-value.warning { color: var(--orange); text-shadow: 0 0 10px var(--orange); }
    .stat-value.safe { color: var(--green); text-shadow: 0 0 10px var(--green); }

    .stat-label {
      font-size: 0.7rem;
      color: var(--muted);
      text-transform: uppercase;
      letter-spacing: 1px;
    }

    .threat-level {
      display: flex;
      align-items: center;
      gap: 15px;
      padding: 10px 20px;
      background: rgba(255, 51, 51, 0.1);
      border: 1px solid var(--red);
      border-radius: 8px;
    }

    .threat-indicator {
      width: 12px;
      height: 12px;
      border-radius: 50%;
      background: var(--red);
      animation: threat-blink 0.5s ease-in-out infinite;
    }

    @keyframes threat-blink {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.3; }
    }

    .threat-text {
      font-weight: 700;
      color: var(--red);
      letter-spacing: 1px;
    }

    /* Panels */
    .panel {
      background: var(--panel);
      padding: 15px;
      overflow: hidden;
      display: flex;
      flex-direction: column;
    }

    .panel-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 15px;
      padding-bottom: 10px;
      border-bottom: 1px solid var(--border);
    }

    .panel-title {
      font-size: 0.85rem;
      font-weight: 600;
      color: var(--cyan);
      text-transform: uppercase;
      letter-spacing: 1px;
    }

    .panel-badge {
      font-family: 'Share Tech Mono', monospace;
      font-size: 0.7rem;
      padding: 3px 8px;
      border-radius: 4px;
      background: var(--border);
    }

    /* Left Panel - Nodes */
    .node-list {
      flex: 1;
      overflow-y: auto;
      display: flex;
      flex-direction: column;
      gap: 8px;
    }

    .node-item {
      background: var(--bg);
      border: 1px solid var(--border);
      border-radius: 6px;
      padding: 10px;
      cursor: pointer;
      transition: all 0.2s;
    }

    .node-item:hover {
      border-color: var(--cyan);
    }

    .node-item.compromised {
      border-color: var(--red);
      background: rgba(255, 51, 51, 0.1);
    }

    .node-item.target {
      border-color: var(--yellow);
      background: rgba(255, 215, 0, 0.1);
    }

    .node-item.safe {
      border-color: var(--green);
    }

    .node-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 5px;
    }

    .node-name {
      font-weight: 600;
      font-size: 0.9rem;
    }

    .node-type {
      font-size: 0.7rem;
      color: var(--muted);
    }

    .node-ip {
      font-family: 'Share Tech Mono', monospace;
      font-size: 0.75rem;
      color: var(--muted);
    }

    .node-status {
      display: inline-block;
      width: 8px;
      height: 8px;
      border-radius: 50%;
      margin-right: 5px;
    }

    .node-status.online { background: var(--green); }
    .node-status.offline { background: var(--muted); }
    .node-status.compromised { background: var(--red); animation: threat-blink 0.5s infinite; }

    /* Network Canvas */
    .network-panel {
      position: relative;
    }

    .network-canvas {
      width: 100%;
      height: 100%;
    }

    .canvas-controls {
      position: absolute;
      bottom: 15px;
      left: 15px;
      display: flex;
      gap: 10px;
    }

    .canvas-btn {
      background: rgba(0, 0, 0, 0.7);
      border: 1px solid var(--border);
      color: var(--text);
      padding: 8px 15px;
      border-radius: 6px;
      cursor: pointer;
      font-family: inherit;
      font-size: 0.8rem;
      transition: all 0.2s;
    }

    .canvas-btn:hover {
      border-color: var(--cyan);
      background: rgba(0, 212, 255, 0.1);
    }

    .canvas-btn.active {
      border-color: var(--red);
      background: rgba(255, 51, 51, 0.2);
      color: var(--red);
    }

    /* Right Panel - A* Info */
    .algorithm-display {
      background: var(--bg);
      border: 1px solid var(--border);
      border-radius: 6px;
      padding: 12px;
      margin-bottom: 15px;
      font-family: 'Share Tech Mono', monospace;
      font-size: 0.75rem;
    }

    .algo-row {
      display: flex;
      justify-content: space-between;
      padding: 5px 0;
      border-bottom: 1px solid var(--border);
    }

    .algo-row:last-child {
      border-bottom: none;
    }

    .algo-label {
      color: var(--muted);
    }

    .algo-value {
      color: var(--cyan);
    }

    .algo-value.highlight {
      color: var(--yellow);
      text-shadow: 0 0 5px var(--yellow);
    }

    /* Path Display */
    .path-display {
      background: var(--bg);
      border: 1px solid var(--border);
      border-radius: 6px;
      padding: 12px;
      flex: 1;
      overflow-y: auto;
    }

    .path-step {
      display: flex;
      align-items: center;
      gap: 10px;
      padding: 8px;
      margin-bottom: 5px;
      background: rgba(255, 255, 255, 0.02);
      border-radius: 4px;
      font-size: 0.8rem;
      animation: path-reveal 0.3s ease-out;
    }

    @keyframes path-reveal {
      from { opacity: 0; transform: translateX(-10px); }
      to { opacity: 1; transform: translateX(0); }
    }

    .path-step-num {
      width: 24px;
      height: 24px;
      background: var(--red);
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      font-weight: 700;
      font-size: 0.7rem;
    }

    .path-step-info {
      flex: 1;
    }

    .path-step-name {
      font-weight: 600;
    }

    .path-step-cost {
      font-family: 'Share Tech Mono', monospace;
      font-size: 0.7rem;
      color: var(--muted);
    }

    /* Bottom Panel - Logs */
    .bottom-panel {
      grid-column: 1 / -1;
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 1px;
      background: var(--border);
    }

    @media (max-width: 800px) {
      .bottom-panel {
        grid-template-columns: 1fr;
      }
    }

    .log-panel {
      background: var(--panel);
      padding: 15px;
      overflow: hidden;
      display: flex;
      flex-direction: column;
    }

    .log-list {
      flex: 1;
      overflow-y: auto;
      font-family: 'Share Tech Mono', monospace;
      font-size: 0.75rem;
    }

    .log-entry {
      padding: 6px 0;
      border-bottom: 1px solid var(--border);
      display: flex;
      gap: 10px;
    }

    .log-time {
      color: var(--muted);
      min-width: 70px;
    }

    .log-level {
      min-width: 60px;
      font-weight: 700;
    }

    .log-level.critical { color: var(--red); }
    .log-level.warning { color: var(--orange); }
    .log-level.info { color: var(--cyan); }
    .log-level.success { color: var(--green); }

    .log-message {
      flex: 1;
    }

    /* Controls Panel */
    .controls-grid {
      display: grid;
      grid-template-columns: repeat(2, 1fr);
      gap: 10px;
      margin-bottom: 15px;
    }

    .ctrl-btn {
      background: linear-gradient(135deg, var(--cyan), var(--blue));
      border: none;
      color: white;
      padding: 12px;
      border-radius: 6px;
      cursor: pointer;
      font-family: inherit;
      font-size: 0.85rem;
      font-weight: 600;
      transition: all 0.2s;
    }

    .ctrl-btn:hover {
      transform: translateY(-2px);
      box-shadow: 0 5px 20px rgba(0, 212, 255, 0.3);
    }

    .ctrl-btn.danger {
      background: linear-gradient(135deg, var(--red), var(--orange));
    }

    .ctrl-btn.success {
      background: linear-gradient(135deg, var(--green), var(--cyan));
    }

    .ctrl-btn:disabled {
      opacity: 0.5;
      cursor: not-allowed;
      transform: none;
    }

    .speed-control {
      display: flex;
      align-items: center;
      gap: 10px;
      font-size: 0.8rem;
    }

    .speed-control input {
      flex: 1;
    }

    .back-link {
      position: fixed;
      bottom: 10px;
      right: 10px;
      color: var(--muted);
      text-decoration: none;
      font-size: 0.7rem;
      z-index: 100;
    }

    .back-link:hover { color: var(--cyan); }
  </style>
</head>
<body>
  <div class="dashboard">
    <header class="header">
      <div class="logo">
        <div class="logo-icon">üõ°Ô∏è</div>
        <h1>SLOPPY-<span>LANCE</span></h1>
      </div>
      <div class="header-stats">
        <div class="stat">
          <div class="stat-value danger" id="threat-count">0</div>
          <div class="stat-label">Active Threats</div>
        </div>
        <div class="stat">
          <div class="stat-value warning" id="node-count">0</div>
          <div class="stat-label">Network Nodes</div>
        </div>
        <div class="stat">
          <div class="stat-value safe" id="traced-count">0</div>
          <div class="stat-label">Paths Traced</div>
        </div>
      </div>
      <div class="threat-level" id="threat-level">
        <div class="threat-indicator"></div>
        <span class="threat-text">THREAT DETECTED</span>
      </div>
    </header>

    <div class="panel left-panel">
      <div class="panel-header">
        <span class="panel-title">Network Nodes</span>
        <span class="panel-badge" id="nodes-online">0 Online</span>
      </div>
      <div class="node-list" id="node-list"></div>
    </div>

    <div class="panel network-panel">
      <canvas class="network-canvas" id="network-canvas"></canvas>
      <div class="canvas-controls">
        <button class="canvas-btn" onclick="resetView()">Reset View</button>
        <button class="canvas-btn" id="trace-btn" onclick="startTrace()">üîç Trace Attack</button>
        <button class="canvas-btn" onclick="simulateAttack()">‚ö° Simulate Attack</button>
      </div>
    </div>

    <div class="panel right-panel">
      <div class="panel-header">
        <span class="panel-title">A* Pathfinder</span>
        <span class="panel-badge">ALGORITHM</span>
      </div>

      <div class="algorithm-display">
        <div class="algo-row">
          <span class="algo-label">Status:</span>
          <span class="algo-value" id="algo-status">Idle</span>
        </div>
        <div class="algo-row">
          <span class="algo-label">Open Set:</span>
          <span class="algo-value" id="algo-open">0</span>
        </div>
        <div class="algo-row">
          <span class="algo-label">Closed Set:</span>
          <span class="algo-value" id="algo-closed">0</span>
        </div>
        <div class="algo-row">
          <span class="algo-label">Current f(n):</span>
          <span class="algo-value highlight" id="algo-fn">‚Äî</span>
        </div>
        <div class="algo-row">
          <span class="algo-label">Path Cost:</span>
          <span class="algo-value" id="algo-cost">‚Äî</span>
        </div>
      </div>

      <div class="panel-header" style="margin-top: 10px;">
        <span class="panel-title">Attack Path</span>
        <span class="panel-badge" id="path-length">0 hops</span>
      </div>
      <div class="path-display" id="path-display">
        <div style="color: var(--muted); text-align: center; padding: 20px;">
          Run trace to reveal attack path
        </div>
      </div>
    </div>

    <div class="bottom-panel">
      <div class="log-panel">
        <div class="panel-header">
          <span class="panel-title">Security Events</span>
          <span class="panel-badge">LIVE</span>
        </div>
        <div class="log-list" id="event-log"></div>
      </div>

      <div class="log-panel">
        <div class="panel-header">
          <span class="panel-title">Controls</span>
        </div>
        <div class="controls-grid">
          <button class="ctrl-btn" onclick="startTrace()">üîç Trace Path</button>
          <button class="ctrl-btn danger" onclick="isolateNode()">üîí Isolate Node</button>
          <button class="ctrl-btn" onclick="generateNetwork()">üîÑ New Network</button>
          <button class="ctrl-btn success" onclick="clearThreats()">‚úì Clear Threats</button>
        </div>
        <div class="speed-control">
          <span>Trace Speed:</span>
          <input type="range" id="speed-slider" min="1" max="10" value="5">
          <span id="speed-label">5x</span>
        </div>
      </div>
    </div>
  </div>

  <a href="https://sloppy.live" class="back-link">‚Üê sloppy.live</a>

  <script>
    // ========================================
    // SLOPPY-LANCE: A* Network Intrusion Tracer
    // ========================================

    const canvas = document.getElementById('network-canvas');
    const ctx = canvas.getContext('2d');

    // Network state
    let network = {
      nodes: [],
      edges: [],
      attackSource: null,
      attackTarget: null,
      currentPath: [],
      openSet: [],
      closedSet: [],
      tracing: false
    };

    let stats = {
      threats: 0,
      traced: 0
    };

    let logs = [];

    // Node types with security weights
    const NODE_TYPES = {
      FIREWALL: { name: 'Firewall', color: '#00ff88', weight: 5, icon: 'üõ°Ô∏è' },
      ROUTER: { name: 'Router', color: '#00d4ff', weight: 2, icon: 'üì°' },
      SERVER: { name: 'Server', color: '#9945ff', weight: 3, icon: 'üñ•Ô∏è' },
      DATABASE: { name: 'Database', color: '#ffd700', weight: 4, icon: 'üóÑÔ∏è' },
      WORKSTATION: { name: 'Workstation', color: '#ff8c00', weight: 1, icon: 'üíª' },
      IOT: { name: 'IoT Device', color: '#ff3333', weight: 1, icon: 'üì±' }
    };

    // A* Algorithm Implementation
    class AStarPathfinder {
      constructor(nodes, edges) {
        this.nodes = nodes;
        this.edges = edges;
      }

      heuristic(a, b) {
        // Euclidean distance as heuristic
        const dx = a.x - b.x;
        const dy = a.y - b.y;
        return Math.sqrt(dx * dx + dy * dy) / 100;
      }

      getNeighbors(node) {
        const neighbors = [];
        this.edges.forEach(edge => {
          if (edge.from === node.id) {
            neighbors.push(this.nodes.find(n => n.id === edge.to));
          } else if (edge.to === node.id) {
            neighbors.push(this.nodes.find(n => n.id === edge.from));
          }
        });
        return neighbors.filter(n => n && !n.isolated);
      }

      getCost(from, to) {
        // Cost based on target node's security weight
        const typeInfo = NODE_TYPES[to.type];
        return typeInfo ? typeInfo.weight : 1;
      }

      async findPath(start, goal, onStep) {
        const openSet = [start];
        const closedSet = [];
        const cameFrom = new Map();
        const gScore = new Map();
        const fScore = new Map();

        gScore.set(start.id, 0);
        fScore.set(start.id, this.heuristic(start, goal));

        while (openSet.length > 0) {
          // Get node with lowest fScore
          openSet.sort((a, b) => (fScore.get(a.id) || Infinity) - (fScore.get(b.id) || Infinity));
          const current = openSet.shift();

          // Update visualization
          if (onStep) {
            await onStep({
              current,
              openSet: [...openSet],
              closedSet: [...closedSet],
              fScore: fScore.get(current.id),
              gScore: gScore.get(current.id)
            });
          }

          if (current.id === goal.id) {
            // Reconstruct path
            const path = [current];
            let node = current;
            while (cameFrom.has(node.id)) {
              node = cameFrom.get(node.id);
              path.unshift(node);
            }
            return { path, cost: gScore.get(goal.id) };
          }

          closedSet.push(current);

          for (const neighbor of this.getNeighbors(current)) {
            if (closedSet.find(n => n.id === neighbor.id)) continue;

            const tentativeG = (gScore.get(current.id) || 0) + this.getCost(current, neighbor);

            if (!openSet.find(n => n.id === neighbor.id)) {
              openSet.push(neighbor);
            } else if (tentativeG >= (gScore.get(neighbor.id) || Infinity)) {
              continue;
            }

            cameFrom.set(neighbor.id, current);
            gScore.set(neighbor.id, tentativeG);
            fScore.set(neighbor.id, tentativeG + this.heuristic(neighbor, goal));
          }
        }

        return null; // No path found
      }
    }

    // Generate network topology
    function generateNetwork() {
      network.nodes = [];
      network.edges = [];
      network.currentPath = [];
      network.openSet = [];
      network.closedSet = [];

      const types = Object.keys(NODE_TYPES);
      const nodeCount = 12 + Math.floor(Math.random() * 6);

      // Create nodes
      for (let i = 0; i < nodeCount; i++) {
        const type = types[Math.floor(Math.random() * types.length)];
        const angle = (i / nodeCount) * Math.PI * 2;
        const radius = 150 + Math.random() * 100;

        network.nodes.push({
          id: i,
          name: `${NODE_TYPES[type].name}-${i.toString().padStart(2, '0')}`,
          type,
          ip: `192.168.${Math.floor(Math.random() * 255)}.${Math.floor(Math.random() * 255)}`,
          x: canvas.width / 2 + Math.cos(angle) * radius,
          y: canvas.height / 2 + Math.sin(angle) * radius,
          compromised: false,
          isolated: false,
          online: Math.random() > 0.1
        });
      }

      // Create edges (connections)
      for (let i = 0; i < network.nodes.length; i++) {
        const connections = 1 + Math.floor(Math.random() * 3);
        for (let c = 0; c < connections; c++) {
          const target = Math.floor(Math.random() * network.nodes.length);
          if (target !== i && !network.edges.find(e =>
            (e.from === i && e.to === target) || (e.from === target && e.to === i)
          )) {
            network.edges.push({ from: i, to: target });
          }
        }
      }

      // Ensure connectivity
      for (let i = 1; i < network.nodes.length; i++) {
        if (!network.edges.find(e => e.from === i || e.to === i)) {
          const target = Math.floor(Math.random() * i);
          network.edges.push({ from: i, to: target });
        }
      }

      // Set random attack source (compromised external node)
      const iotNodes = network.nodes.filter(n => n.type === 'IOT' || n.type === 'WORKSTATION');
      if (iotNodes.length > 0) {
        network.attackSource = iotNodes[Math.floor(Math.random() * iotNodes.length)];
        network.attackSource.compromised = true;
      } else {
        network.attackSource = network.nodes[0];
        network.attackSource.compromised = true;
      }

      // Set target (valuable asset)
      const targets = network.nodes.filter(n => n.type === 'DATABASE' || n.type === 'SERVER');
      if (targets.length > 0) {
        network.attackTarget = targets[Math.floor(Math.random() * targets.length)];
      } else {
        network.attackTarget = network.nodes[network.nodes.length - 1];
      }

      stats.threats = 1;
      updateStats();
      renderNodeList();
      log('warning', `Intrusion detected from ${network.attackSource.name}`);
      log('info', `Target identified: ${network.attackTarget.name}`);
      render();
    }

    // Canvas rendering
    function resizeCanvas() {
      canvas.width = canvas.parentElement.clientWidth;
      canvas.height = canvas.parentElement.clientHeight;
      render();
    }

    function render() {
      ctx.fillStyle = '#0a0e14';
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      // Draw grid
      ctx.strokeStyle = 'rgba(26, 35, 50, 0.5)';
      ctx.lineWidth = 1;
      for (let x = 0; x < canvas.width; x += 50) {
        ctx.beginPath();
        ctx.moveTo(x, 0);
        ctx.lineTo(x, canvas.height);
        ctx.stroke();
      }
      for (let y = 0; y < canvas.height; y += 50) {
        ctx.beginPath();
        ctx.moveTo(0, y);
        ctx.lineTo(canvas.width, y);
        ctx.stroke();
      }

      // Draw edges
      network.edges.forEach(edge => {
        const from = network.nodes[edge.from];
        const to = network.nodes[edge.to];
        if (!from || !to) return;

        const isOnPath = network.currentPath.length > 1 &&
          network.currentPath.some((n, i) =>
            i < network.currentPath.length - 1 &&
            ((n.id === edge.from && network.currentPath[i + 1].id === edge.to) ||
             (n.id === edge.to && network.currentPath[i + 1].id === edge.from))
          );

        ctx.beginPath();
        ctx.moveTo(from.x, from.y);
        ctx.lineTo(to.x, to.y);

        if (isOnPath) {
          ctx.strokeStyle = '#ff3333';
          ctx.lineWidth = 3;
          ctx.shadowColor = '#ff3333';
          ctx.shadowBlur = 10;
        } else {
          ctx.strokeStyle = 'rgba(0, 212, 255, 0.3)';
          ctx.lineWidth = 1;
          ctx.shadowBlur = 0;
        }
        ctx.stroke();
        ctx.shadowBlur = 0;
      });

      // Draw open/closed sets during A*
      network.openSet.forEach(node => {
        ctx.beginPath();
        ctx.arc(node.x, node.y, 25, 0, Math.PI * 2);
        ctx.strokeStyle = '#ffd700';
        ctx.lineWidth = 2;
        ctx.stroke();
      });

      network.closedSet.forEach(node => {
        ctx.beginPath();
        ctx.arc(node.x, node.y, 25, 0, Math.PI * 2);
        ctx.strokeStyle = '#9945ff';
        ctx.lineWidth = 2;
        ctx.stroke();
      });

      // Draw nodes
      network.nodes.forEach(node => {
        const typeInfo = NODE_TYPES[node.type];

        // Node circle
        ctx.beginPath();
        ctx.arc(node.x, node.y, 20, 0, Math.PI * 2);

        if (node.isolated) {
          ctx.fillStyle = '#1a2332';
          ctx.strokeStyle = '#4a5568';
        } else if (node.compromised) {
          ctx.fillStyle = 'rgba(255, 51, 51, 0.3)';
          ctx.strokeStyle = '#ff3333';
          ctx.shadowColor = '#ff3333';
          ctx.shadowBlur = 15;
        } else if (node === network.attackTarget) {
          ctx.fillStyle = 'rgba(255, 215, 0, 0.3)';
          ctx.strokeStyle = '#ffd700';
          ctx.shadowColor = '#ffd700';
          ctx.shadowBlur = 15;
        } else {
          ctx.fillStyle = 'rgba(0, 212, 255, 0.1)';
          ctx.strokeStyle = typeInfo.color;
        }

        ctx.fill();
        ctx.lineWidth = 2;
        ctx.stroke();
        ctx.shadowBlur = 0;

        // Icon
        ctx.font = '16px sans-serif';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText(typeInfo.icon, node.x, node.y);

        // Label
        ctx.font = '10px Share Tech Mono';
        ctx.fillStyle = '#e4e8ef';
        ctx.fillText(node.name, node.x, node.y + 32);
      });

      // Draw attack path animation
      if (network.currentPath.length > 1) {
        ctx.setLineDash([5, 5]);
        ctx.strokeStyle = '#ff3333';
        ctx.lineWidth = 2;
        ctx.beginPath();
        network.currentPath.forEach((node, i) => {
          if (i === 0) ctx.moveTo(node.x, node.y);
          else ctx.lineTo(node.x, node.y);
        });
        ctx.stroke();
        ctx.setLineDash([]);
      }
    }

    // A* Trace execution
    async function startTrace() {
      if (network.tracing || !network.attackSource || !network.attackTarget) return;

      network.tracing = true;
      network.currentPath = [];
      network.openSet = [];
      network.closedSet = [];

      document.getElementById('trace-btn').classList.add('active');
      document.getElementById('algo-status').textContent = 'Running...';
      document.getElementById('path-display').innerHTML = '';

      log('info', 'Starting A* pathfinding algorithm');

      const pathfinder = new AStarPathfinder(network.nodes, network.edges);
      const speed = 11 - parseInt(document.getElementById('speed-slider').value);

      const result = await pathfinder.findPath(
        network.attackSource,
        network.attackTarget,
        async (step) => {
          network.openSet = step.openSet;
          network.closedSet = step.closedSet;

          document.getElementById('algo-open').textContent = step.openSet.length;
          document.getElementById('algo-closed').textContent = step.closedSet.length;
          document.getElementById('algo-fn').textContent = step.fScore?.toFixed(2) || '‚Äî';

          render();
          await new Promise(r => setTimeout(r, speed * 50));
        }
      );

      if (result) {
        network.currentPath = result.path;
        document.getElementById('algo-status').textContent = 'Complete';
        document.getElementById('algo-cost').textContent = result.cost.toFixed(2);
        document.getElementById('path-length').textContent = `${result.path.length} hops`;

        // Display path
        const pathDisplay = document.getElementById('path-display');
        pathDisplay.innerHTML = result.path.map((node, i) => `
          <div class="path-step">
            <div class="path-step-num">${i + 1}</div>
            <div class="path-step-info">
              <div class="path-step-name">${node.name}</div>
              <div class="path-step-cost">${node.ip} ‚Ä¢ ${NODE_TYPES[node.type].name}</div>
            </div>
          </div>
        `).join('');

        stats.traced++;
        updateStats();
        log('critical', `Attack path traced: ${result.path.length} hops, cost ${result.cost.toFixed(2)}`);

        // Mark path nodes
        result.path.forEach(node => {
          if (node !== network.attackSource) {
            node.compromised = true;
          }
        });
        renderNodeList();
      } else {
        document.getElementById('algo-status').textContent = 'No Path';
        log('success', 'No viable attack path found - network secure');
      }

      network.openSet = [];
      network.closedSet = [];
      network.tracing = false;
      document.getElementById('trace-btn').classList.remove('active');
      render();
    }

    // Simulate new attack
    function simulateAttack() {
      // Pick new attack source
      const candidates = network.nodes.filter(n => !n.compromised && !n.isolated && n.online);
      if (candidates.length === 0) return;

      network.attackSource = candidates[Math.floor(Math.random() * candidates.length)];
      network.attackSource.compromised = true;
      network.currentPath = [];

      stats.threats++;
      updateStats();
      log('critical', `New intrusion detected: ${network.attackSource.name} (${network.attackSource.ip})`);
      renderNodeList();
      render();
    }

    // Isolate compromised node
    function isolateNode() {
      const compromised = network.nodes.filter(n => n.compromised && !n.isolated);
      if (compromised.length === 0) return;

      const node = compromised[0];
      node.isolated = true;
      node.compromised = false;
      log('success', `Node isolated: ${node.name}`);

      if (node === network.attackSource) {
        network.attackSource = null;
        stats.threats = Math.max(0, stats.threats - 1);
      }

      updateStats();
      renderNodeList();
      render();
    }

    // Clear all threats
    function clearThreats() {
      network.nodes.forEach(n => {
        n.compromised = false;
        n.isolated = false;
      });
      network.currentPath = [];
      network.attackSource = null;
      stats.threats = 0;
      updateStats();
      log('success', 'All threats cleared - network secure');
      renderNodeList();
      render();
    }

    function resetView() {
      resizeCanvas();
    }

    // UI Updates
    function renderNodeList() {
      const container = document.getElementById('node-list');
      container.innerHTML = network.nodes.map(node => {
        let statusClass = node.online ? 'online' : 'offline';
        let itemClass = '';
        if (node.compromised) { statusClass = 'compromised'; itemClass = 'compromised'; }
        if (node === network.attackTarget) itemClass = 'target';
        if (node.isolated) itemClass = '';

        return `
          <div class="node-item ${itemClass}">
            <div class="node-header">
              <span class="node-name">
                <span class="node-status ${statusClass}"></span>
                ${NODE_TYPES[node.type].icon} ${node.name}
              </span>
            </div>
            <div class="node-type">${NODE_TYPES[node.type].name}</div>
            <div class="node-ip">${node.ip}</div>
          </div>
        `;
      }).join('');

      document.getElementById('nodes-online').textContent =
        `${network.nodes.filter(n => n.online).length} Online`;
    }

    function updateStats() {
      document.getElementById('threat-count').textContent = stats.threats;
      document.getElementById('node-count').textContent = network.nodes.length;
      document.getElementById('traced-count').textContent = stats.traced;

      const threatLevel = document.getElementById('threat-level');
      if (stats.threats === 0) {
        threatLevel.style.borderColor = 'var(--green)';
        threatLevel.style.background = 'rgba(0, 255, 136, 0.1)';
        threatLevel.querySelector('.threat-indicator').style.background = 'var(--green)';
        threatLevel.querySelector('.threat-text').style.color = 'var(--green)';
        threatLevel.querySelector('.threat-text').textContent = 'NETWORK SECURE';
      } else {
        threatLevel.style.borderColor = 'var(--red)';
        threatLevel.style.background = 'rgba(255, 51, 51, 0.1)';
        threatLevel.querySelector('.threat-indicator').style.background = 'var(--red)';
        threatLevel.querySelector('.threat-text').style.color = 'var(--red)';
        threatLevel.querySelector('.threat-text').textContent = 'THREAT DETECTED';
      }
    }

    function log(level, message) {
      const time = new Date().toLocaleTimeString();
      logs.unshift({ time, level, message });
      if (logs.length > 50) logs.pop();

      const container = document.getElementById('event-log');
      container.innerHTML = logs.slice(0, 15).map(l => `
        <div class="log-entry">
          <span class="log-time">${l.time}</span>
          <span class="log-level ${l.level}">${l.level.toUpperCase()}</span>
          <span class="log-message">${l.message}</span>
        </div>
      `).join('');
    }

    // Speed slider
    document.getElementById('speed-slider').addEventListener('input', (e) => {
      document.getElementById('speed-label').textContent = e.target.value + 'x';
    });

    // Initialize
    window.addEventListener('resize', resizeCanvas);
    resizeCanvas();
    generateNetwork();
    log('info', 'Sloppy-Lance initialized');
    log('info', 'A* pathfinding engine ready');
  </script>
</body>
</html>
