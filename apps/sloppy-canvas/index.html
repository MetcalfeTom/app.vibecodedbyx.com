<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Sloppy Canvas - Infinite Whiteboard</title>
    <link rel="icon" href="https://emojicdn.elk.sh/üé®">
    <meta property="og:title" content="Sloppy Canvas">
    <meta property="og:description" content="Real-time infinite whiteboard ‚Äî draw together with anyone">
    <meta property="og:url" content="https://sloppy.live/sloppy-canvas">
    <meta property="og:image" content="https://emojicdn.elk.sh/üé®?style=google">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link href="https://fonts.googleapis.com/css2?family=Space+Mono:wght@400;700&display=swap" rel="stylesheet">
    <style>
        *{margin:0;padding:0;box-sizing:border-box}
        :root{
            --bg:#0a0a0f;--surface:#111118;--border:#222233;
            --text:#d8d8e0;--dim:#5a5a70;--accent:#ff5caa;--accent2:#5cf0ff;
        }
        html,body{height:100%;overflow:hidden;background:var(--bg);color:var(--text);font-family:'Space Mono',monospace}

        /* Main canvas fills the screen */
        .canvas-wrap{position:absolute;inset:0;overflow:hidden;cursor:crosshair}
        #canvas{position:absolute;top:0;left:0;transform-origin:0 0;image-rendering:pixelated}

        /* Remote cursors overlay */
        .cursors{position:absolute;inset:0;pointer-events:none;overflow:hidden}
        .remote-cursor{position:absolute;transition:transform 0.06s linear;z-index:5}
        .rc-dot{width:10px;height:10px;border-radius:50%;border:2px solid #fff;box-shadow:0 0 6px currentColor}
        .rc-name{font-size:0.5rem;color:var(--text);background:rgba(0,0,0,0.7);padding:1px 5px;border-radius:3px;
            white-space:nowrap;margin-top:2px;font-family:'Space Mono',monospace}

        /* Top HUD */
        .hud{position:fixed;top:0;left:0;right:0;display:flex;align-items:center;justify-content:space-between;
            padding:10px 14px;z-index:20;pointer-events:none;background:linear-gradient(var(--bg),transparent)}
        .hud>*{pointer-events:auto}
        .hud-title{font-weight:700;font-size:0.85rem;color:var(--accent);letter-spacing:1px}
        .hud-pills{display:flex;gap:6px;align-items:center}
        .pill{background:var(--surface);border:1px solid var(--border);border-radius:6px;padding:4px 10px;
            font-size:0.6rem;color:var(--dim)}
        .pill span{color:var(--text);font-weight:700}

        /* Bottom toolbar */
        .toolbar{position:fixed;bottom:0;left:0;right:0;display:flex;align-items:center;justify-content:center;
            padding:10px 14px;gap:8px;z-index:20;background:linear-gradient(transparent,var(--bg) 40%);flex-wrap:wrap}

        .color-btn{width:28px;height:28px;border-radius:50%;border:2px solid transparent;cursor:pointer;
            transition:all 0.15s;flex-shrink:0}
        .color-btn:hover{transform:scale(1.15)}
        .color-btn.active{border-color:#fff;box-shadow:0 0 10px currentColor}

        .eraser-btn{width:28px;height:28px;border-radius:50%;border:2px solid transparent;cursor:pointer;
            background:linear-gradient(135deg,#222,#444);display:flex;align-items:center;justify-content:center;
            font-size:0.7rem;transition:all 0.15s;flex-shrink:0}
        .eraser-btn:hover{transform:scale(1.15)}
        .eraser-btn.active{border-color:#fff;box-shadow:0 0 8px rgba(255,255,255,0.3)}

        .tool-sep{width:1px;height:20px;background:var(--border);flex-shrink:0}

        .tool-btn{background:var(--surface);border:1px solid var(--border);color:var(--dim);
            padding:5px 12px;border-radius:6px;cursor:pointer;font-family:inherit;font-size:0.6rem;
            transition:all 0.15s;flex-shrink:0}
        .tool-btn:hover{border-color:var(--accent);color:var(--text)}
        .tool-btn.danger{border-color:rgba(255,68,68,0.3);color:rgba(255,68,68,0.7)}
        .tool-btn.danger:hover{border-color:#ff4444;color:#ff4444}
        .tool-btn.accent{background:var(--accent);color:#fff;border-color:var(--accent);font-weight:700}
        .tool-btn.accent:hover{opacity:0.85}

        /* Brush size */
        .brush-size{display:flex;align-items:center;gap:4px}
        .brush-size input[type=range]{width:60px;accent-color:var(--accent);height:4px}
        .brush-size-label{font-size:0.55rem;color:var(--dim);width:18px;text-align:center}

        /* Toast */
        .toast{position:fixed;top:50px;left:50%;transform:translateX(-50%);background:var(--surface);
            border:1px solid var(--border);border-radius:8px;padding:8px 18px;font-size:0.7rem;color:var(--text);
            z-index:100;opacity:0;transition:opacity 0.3s;pointer-events:none}
        .toast.show{opacity:1}

        /* Minimap */
        .minimap{position:fixed;bottom:60px;right:14px;width:120px;height:90px;background:var(--surface);
            border:1px solid var(--border);border-radius:6px;z-index:15;overflow:hidden;cursor:pointer;opacity:0.7;
            transition:opacity 0.2s}
        .minimap:hover{opacity:1}
        .minimap canvas{width:100%;height:100%}
        .minimap-viewport{position:absolute;border:1px solid var(--accent);pointer-events:none}

        .backlink{position:fixed;bottom:52px;left:14px;z-index:15;font-size:0.55rem}
        .backlink a{color:var(--dim);text-decoration:none}.backlink a:hover{color:var(--accent)}

        @media(max-width:600px){
            .minimap{display:none}
            .hud-title{font-size:0.7rem}
            .toolbar{padding:8px 8px;gap:5px}
            .color-btn,.eraser-btn{width:24px;height:24px}
        }
    </style>
<script>
(function(){var Q=[],N=0,MAX=10;function send(e){var sb=window.supabase;if(!sb){Q.push(e);return;}if(N>=MAX)return;N++;try{sb.from('ai_events').insert({event_type:'client_error',entity_type:'app',username:location.pathname.split('/').filter(Boolean)[0]||'unknown',metadata:e}).then(function(){});}catch(x){}}window.onerror=function(m,s,l,c,e){send({type:'error',msg:String(m).slice(0,500),src:s||'',line:l,col:c,stack:e?String(e.stack).slice(0,1000):''});};window.addEventListener('unhandledrejection',function(ev){var r=ev.reason;send({type:'promise',msg:String(r&&r.message||r).slice(0,500),stack:r?String(r.stack||'').slice(0,1000):''});});var fi=setInterval(function(){if(window.supabase){Q.splice(0).forEach(send);clearInterval(fi);}},1000);setTimeout(function(){clearInterval(fi);},30000);})();
</script>
</head>
<body>
    <div class="canvas-wrap" id="canvasWrap">
        <canvas id="canvas" width="4000" height="3000"></canvas>
        <div class="cursors" id="cursors"></div>
    </div>

    <div class="hud">
        <div class="hud-title">SLOPPY CANVAS</div>
        <div class="hud-pills">
            <div class="pill">üë• <span id="userCount">1</span></div>
            <div class="pill">üîç <span id="zoomLevel">100%</span></div>
            <div class="pill" id="strokePill">‚úèÔ∏è <span id="strokeCount">0</span></div>
        </div>
    </div>

    <div class="toolbar" id="toolbar"></div>

    <div class="minimap" id="minimap" onclick="minimapClick(event)">
        <canvas id="minimapCanvas" width="120" height="90"></canvas>
        <div class="minimap-viewport" id="minimapViewport"></div>
    </div>

    <div class="backlink"><a href="https://sloppy.live">‚Üê sloppy.live</a></div>
    <div class="toast" id="toast"></div>

    <script src="/sloppy-header/sloppy-bar.js" data-position="bottom" data-minimized="true"></script>
    <script type="module">
        import { createBrowserClient } from "https://cdn.jsdelivr.net/npm/@supabase/ssr@0.7.0/+esm";

        const SUPABASE_URL = 'https://yjyxteqzhhmtrgcaekgz.supabase.co';
        const SUPABASE_ANON_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InlqeXh0ZXF6aGhtdHJnY2Fla2d6Iiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTczNTg3NDIsImV4cCI6MjA3MjkzNDc0Mn0.G8SRde7IN2QFW1EnASM8IS32IUYR2eenCCjdDdioiBU';
        const supabase = createBrowserClient(SUPABASE_URL, SUPABASE_ANON_KEY, {
            cookieOptions: { name: 'sb-auth-token', domain: location.hostname.includes('sloppy.live') ? '.sloppy.live' : location.hostname, path: '/', sameSite: 'lax' }
        });

        // === Constants ===
        const CANVAS_W = 4000, CANVAS_H = 3000;
        const BG_COLOR = '#0a0a0f';
        const ERASER_COLOR = BG_COLOR;
        const BATCH_SIZE = 10;
        const BATCH_DELAY = 1000;
        const MAX_STROKES = 15000;
        const CURSOR_THROTTLE = 16;
        const ZOOM_MIN = 0.15, ZOOM_MAX = 5, ZOOM_STEP = 0.15;

        const COLORS = [
            '#ff5caa','#5cf0ff','#00ff41','#ffff00','#ff6600',
            '#ff0066','#aa66ff','#ffffff','#888888'
        ];

        // === State ===
        let currentUser = null;
        let username = 'Anonymous';
        let userColor = COLORS[0];

        let strokes = [];         // {x1,y1,x2,y2,color,width,username}
        let strokeBatch = [];
        let batchTimeout = null;

        let drawing = false;
        let lastX = 0, lastY = 0;
        let currentColor = COLORS[0];
        let isEraser = false;
        let brushSize = 3;

        // Camera: pan + zoom
        let camX = 0, camY = 0, zoom = 1;
        let isPanning = false;
        let panStartX, panStartY, camStartX, camStartY;

        // Touch state
        let lastTouchDist = 0;
        let touchPanId = null;

        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const wrap = document.getElementById('canvasWrap');

        // === Auth ===
        async function initAuth() {
            const sessRes = await supabase.auth.getSession();
            let session = sessRes.data.session;
            if (!session) {
                const res = await supabase.auth.signInAnonymously();
                session = res.data.session;
            }
            currentUser = session?.user;

            // Get username
            if (currentUser) {
                const { data: prof } = await supabase.from('sloppygram_profiles').select('username,color').eq('user_id', currentUser.id).single();
                if (prof && prof.username) { username = prof.username; userColor = prof.color || COLORS[0]; }
            }
        }

        // === Canvas Setup ===
        function initCanvas() {
            canvas.width = CANVAS_W;
            canvas.height = CANVAS_H;
            ctx.fillStyle = BG_COLOR;
            ctx.fillRect(0, 0, CANVAS_W, CANVAS_H);
            ctx.lineCap = 'round';
            ctx.lineJoin = 'round';
            applyCamera();
        }

        function applyCamera() {
            canvas.style.transform = `translate(${camX}px, ${camY}px) scale(${zoom})`;
            document.getElementById('zoomLevel').textContent = Math.round(zoom * 100) + '%';
            updateMinimap();
        }

        // === Drawing ===
        function canvasCoords(clientX, clientY) {
            const rect = wrap.getBoundingClientRect();
            return {
                x: (clientX - rect.left - camX) / zoom,
                y: (clientY - rect.top - camY) / zoom
            };
        }

        function startDraw(x, y) {
            drawing = true;
            lastX = x; lastY = y;
            ctx.beginPath();
            ctx.moveTo(x, y);
        }

        function drawStroke(x, y) {
            if (!drawing) return;
            const w = isEraser ? Math.max(brushSize * 4, 16) : brushSize;
            const col = isEraser ? ERASER_COLOR : currentColor;

            ctx.strokeStyle = col;
            ctx.lineWidth = w;
            ctx.lineTo(x, y);
            ctx.stroke();
            ctx.beginPath();
            ctx.moveTo(x, y);

            const stroke = { x1: lastX, y1: lastY, x2: x, y2: y, color: col, width: w, username };
            strokes.push(stroke);
            if (strokes.length > MAX_STROKES) strokes.splice(0, strokes.length - MAX_STROKES);

            queueStroke(stroke);
            broadcastStroke(stroke);

            lastX = x; lastY = y;
        }

        function stopDraw() {
            drawing = false;
            flushStrokes();
        }

        function redrawCanvas() {
            ctx.fillStyle = BG_COLOR;
            ctx.fillRect(0, 0, CANVAS_W, CANVAS_H);
            ctx.lineCap = 'round';
            ctx.lineJoin = 'round';
            for (const s of strokes) {
                ctx.strokeStyle = s.color;
                ctx.lineWidth = s.width || (s.color === ERASER_COLOR ? 16 : 3);
                ctx.beginPath();
                ctx.moveTo(s.x1, s.y1);
                ctx.lineTo(s.x2, s.y2);
                ctx.stroke();
            }
            updateMinimap();
        }

        // === Stroke Persistence ===
        function queueStroke(stroke) {
            strokeBatch.push(stroke);
            clearTimeout(batchTimeout);
            if (strokeBatch.length >= BATCH_SIZE) { flushStrokes(); return; }
            batchTimeout = setTimeout(flushStrokes, BATCH_DELAY);
        }

        async function flushStrokes() {
            if (strokeBatch.length === 0) return;
            const batch = strokeBatch.splice(0);
            clearTimeout(batchTimeout);

            const rows = batch.map(s => ({
                start_x: Math.round(s.x1), start_y: Math.round(s.y1),
                end_x: Math.round(s.x2), end_y: Math.round(s.y2),
                color: s.color, username, user_id: currentUser.id
            }));

            try {
                await supabase.from('sloppygram_collab_strokes').insert(rows);
            } catch (e) { console.warn('[Canvas] Flush error:', e); }

            document.getElementById('strokeCount').textContent = strokes.length;
        }

        async function loadStrokes() {
            const { data, error } = await supabase.from('sloppygram_collab_strokes')
                .select('start_x, start_y, end_x, end_y, color, username')
                .order('created_at', { ascending: true })
                .limit(MAX_STROKES);

            if (data) {
                strokes = data.map(r => ({
                    x1: r.start_x, y1: r.start_y, x2: r.end_x, y2: r.end_y,
                    color: r.color, width: r.color === ERASER_COLOR ? 16 : 3, username: r.username
                }));
                redrawCanvas();
                document.getElementById('strokeCount').textContent = strokes.length;
            }
        }

        // === Realtime ===
        let channel = null;

        function setupRealtime() {
            channel = supabase.channel('sloppygram-collab-canvas', { config: { broadcast: { self: false } } });

            channel.on('broadcast', { event: 'stroke' }, ({ payload }) => {
                if (!payload) return;
                const s = { x1: payload.x1, y1: payload.y1, x2: payload.x2, y2: payload.y2,
                    color: payload.color, width: payload.width || (payload.color === ERASER_COLOR ? 16 : 3),
                    username: payload.username };
                strokes.push(s);
                if (strokes.length > MAX_STROKES) strokes.splice(0, strokes.length - MAX_STROKES);

                // Draw immediately
                ctx.strokeStyle = s.color;
                ctx.lineWidth = s.width;
                ctx.beginPath();
                ctx.moveTo(s.x1, s.y1);
                ctx.lineTo(s.x2, s.y2);
                ctx.stroke();
            });

            channel.on('broadcast', { event: 'cursor' }, ({ payload }) => {
                if (!payload || payload.username === username) return;
                updateRemoteCursor(payload);
            });

            channel.on('broadcast', { event: 'clear_all' }, () => {
                strokes = [];
                redrawCanvas();
                showToast('Canvas cleared');
            });

            channel.on('presence', { event: 'sync' }, () => {
                const state = channel.presenceState();
                const count = Object.keys(state).length;
                document.getElementById('userCount').textContent = Math.max(1, count);
            });

            channel.subscribe(async (status) => {
                if (status === 'SUBSCRIBED') {
                    await channel.track({ username, color: userColor });
                }
            });
        }

        function broadcastStroke(s) {
            if (!channel) return;
            channel.send({ type: 'broadcast', event: 'stroke', payload: {
                x1: s.x1, y1: s.y1, x2: s.x2, y2: s.y2, color: s.color, width: s.width, username
            }});
        }

        let lastCursorBroadcast = 0;
        function broadcastCursor(x, y) {
            const now = Date.now();
            if (now - lastCursorBroadcast < CURSOR_THROTTLE || !channel) return;
            lastCursorBroadcast = now;
            channel.send({ type: 'broadcast', event: 'cursor', payload: { x, y, username, color: userColor } });
        }

        function updateRemoteCursor(p) {
            const id = 'cursor-' + p.username.replace(/\W/g, '_');
            let el = document.getElementById(id);
            if (!el) {
                el = document.createElement('div');
                el.className = 'remote-cursor';
                el.id = id;
                el.innerHTML = `<div class="rc-dot" style="background:${p.color};color:${p.color}"></div>
                    <div class="rc-name">${escapeHtml(p.username)}</div>`;
                document.getElementById('cursors').appendChild(el);
            }
            const sx = p.x * zoom + camX;
            const sy = p.y * zoom + camY;
            el.style.transform = `translate(${sx}px, ${sy}px)`;

            // Auto-remove stale cursors after 10s
            el._lastUpdate = Date.now();
        }

        // Clean stale cursors
        setInterval(() => {
            document.querySelectorAll('.remote-cursor').forEach(el => {
                if (Date.now() - (el._lastUpdate || 0) > 10000) el.remove();
            });
        }, 5000);

        // === Mouse Events ===
        wrap.addEventListener('mousedown', e => {
            if (e.button === 1 || e.button === 2 || (e.button === 0 && e.altKey)) {
                // Middle click or Alt+click = pan
                isPanning = true;
                panStartX = e.clientX; panStartY = e.clientY;
                camStartX = camX; camStartY = camY;
                wrap.style.cursor = 'grabbing';
                e.preventDefault();
                return;
            }
            const p = canvasCoords(e.clientX, e.clientY);
            startDraw(p.x, p.y);
        });

        wrap.addEventListener('mousemove', e => {
            const p = canvasCoords(e.clientX, e.clientY);
            broadcastCursor(p.x, p.y);

            if (isPanning) {
                camX = camStartX + (e.clientX - panStartX);
                camY = camStartY + (e.clientY - panStartY);
                applyCamera();
                return;
            }
            drawStroke(p.x, p.y);
        });

        wrap.addEventListener('mouseup', () => { stopDraw(); isPanning = false; wrap.style.cursor = 'crosshair'; });
        wrap.addEventListener('mouseleave', () => { stopDraw(); isPanning = false; });

        wrap.addEventListener('wheel', e => {
            e.preventDefault();
            const oldZoom = zoom;
            zoom = Math.max(ZOOM_MIN, Math.min(ZOOM_MAX, zoom + (e.deltaY > 0 ? -ZOOM_STEP : ZOOM_STEP)));
            // Zoom toward cursor
            const rect = wrap.getBoundingClientRect();
            const mx = e.clientX - rect.left;
            const my = e.clientY - rect.top;
            camX = mx - (mx - camX) * (zoom / oldZoom);
            camY = my - (my - camY) * (zoom / oldZoom);
            applyCamera();
        }, { passive: false });

        // Prevent context menu on canvas
        wrap.addEventListener('contextmenu', e => e.preventDefault());

        // === Touch Events ===
        wrap.addEventListener('touchstart', e => {
            if (e.touches.length === 1) {
                const t = e.touches[0];
                const p = canvasCoords(t.clientX, t.clientY);
                startDraw(p.x, p.y);
                touchPanId = null;
            } else if (e.touches.length === 2) {
                // Pinch zoom / 2-finger pan
                drawing = false;
                const dx = e.touches[0].clientX - e.touches[1].clientX;
                const dy = e.touches[0].clientY - e.touches[1].clientY;
                lastTouchDist = Math.sqrt(dx * dx + dy * dy);
                panStartX = (e.touches[0].clientX + e.touches[1].clientX) / 2;
                panStartY = (e.touches[0].clientY + e.touches[1].clientY) / 2;
                camStartX = camX; camStartY = camY;
            }
            e.preventDefault();
        }, { passive: false });

        wrap.addEventListener('touchmove', e => {
            if (e.touches.length === 1 && !isPanning) {
                const t = e.touches[0];
                const p = canvasCoords(t.clientX, t.clientY);
                broadcastCursor(p.x, p.y);
                drawStroke(p.x, p.y);
            } else if (e.touches.length === 2) {
                const dx = e.touches[0].clientX - e.touches[1].clientX;
                const dy = e.touches[0].clientY - e.touches[1].clientY;
                const dist = Math.sqrt(dx * dx + dy * dy);
                const midX = (e.touches[0].clientX + e.touches[1].clientX) / 2;
                const midY = (e.touches[0].clientY + e.touches[1].clientY) / 2;

                // Zoom
                if (lastTouchDist > 0) {
                    const oldZoom = zoom;
                    zoom = Math.max(ZOOM_MIN, Math.min(ZOOM_MAX, zoom * (dist / lastTouchDist)));
                    const rect = wrap.getBoundingClientRect();
                    const mx = midX - rect.left;
                    const my = midY - rect.top;
                    camX = mx - (mx - camStartX) * (zoom / oldZoom);
                    camY = my - (my - camStartY) * (zoom / oldZoom);
                }
                lastTouchDist = dist;

                // Pan
                camX = camStartX + (midX - panStartX);
                camY = camStartY + (midY - panStartY);
                applyCamera();
            }
            e.preventDefault();
        }, { passive: false });

        wrap.addEventListener('touchend', e => {
            stopDraw();
            lastTouchDist = 0;
        });

        // === Minimap ===
        function updateMinimap() {
            const mc = document.getElementById('minimapCanvas');
            const mctx = mc.getContext('2d');
            mc.width = 120; mc.height = 90;
            mctx.fillStyle = '#111';
            mctx.fillRect(0, 0, 120, 90);

            // Draw strokes scaled down
            const sx = 120 / CANVAS_W, sy = 90 / CANVAS_H;
            for (const s of strokes) {
                if (s.color === ERASER_COLOR) continue;
                mctx.strokeStyle = s.color;
                mctx.lineWidth = 0.5;
                mctx.beginPath();
                mctx.moveTo(s.x1 * sx, s.y1 * sy);
                mctx.lineTo(s.x2 * sx, s.y2 * sy);
                mctx.stroke();
            }

            // Viewport rect
            const vp = document.getElementById('minimapViewport');
            const ww = wrap.clientWidth, wh = wrap.clientHeight;
            const vpW = (ww / zoom) * sx;
            const vpH = (wh / zoom) * sy;
            const vpX = (-camX / zoom) * sx;
            const vpY = (-camY / zoom) * sy;
            vp.style.left = vpX + 'px';
            vp.style.top = vpY + 'px';
            vp.style.width = vpW + 'px';
            vp.style.height = vpH + 'px';
        }

        window.minimapClick = function(e) {
            const rect = e.currentTarget.getBoundingClientRect();
            const mx = e.clientX - rect.left;
            const my = e.clientY - rect.top;
            const targetX = (mx / 120) * CANVAS_W;
            const targetY = (my / 90) * CANVAS_H;
            camX = -targetX * zoom + wrap.clientWidth / 2;
            camY = -targetY * zoom + wrap.clientHeight / 2;
            applyCamera();
        };

        // === Toolbar ===
        function buildToolbar() {
            const tb = document.getElementById('toolbar');
            let html = '';

            // Colors
            COLORS.forEach((c, i) => {
                const active = i === 0 ? ' active' : '';
                html += `<div class="color-btn${active}" style="background:${c};color:${c}" data-color="${c}"
                    onclick="window._setColor('${c}',this)"></div>`;
            });

            // Eraser
            html += `<div class="eraser-btn" onclick="window._setEraser(this)">üßΩ</div>`;
            html += `<div class="tool-sep"></div>`;

            // Brush size
            html += `<div class="brush-size">
                <span class="brush-size-label" id="brushLabel">3</span>
                <input type="range" min="1" max="20" value="3" oninput="window._setBrush(this.value)">
            </div>`;
            html += `<div class="tool-sep"></div>`;

            // Actions
            html += `<button class="tool-btn" onclick="window._zoomIn()">üîç+</button>`;
            html += `<button class="tool-btn" onclick="window._zoomOut()">üîç‚àí</button>`;
            html += `<button class="tool-btn" onclick="window._zoomReset()">‚ü≤</button>`;
            html += `<div class="tool-sep"></div>`;
            html += `<button class="tool-btn accent" onclick="window._snapshot()">üì∏ Save</button>`;
            html += `<button class="tool-btn danger" onclick="window._clearMine()">üóëÔ∏è Clear Mine</button>`;

            tb.innerHTML = html;
        }

        window._setColor = function(color, el) {
            currentColor = color;
            isEraser = false;
            document.querySelectorAll('.color-btn').forEach(b => b.classList.remove('active'));
            document.querySelector('.eraser-btn').classList.remove('active');
            el.classList.add('active');
            wrap.style.cursor = 'crosshair';
        };

        window._setEraser = function(el) {
            isEraser = true;
            document.querySelectorAll('.color-btn').forEach(b => b.classList.remove('active'));
            el.classList.add('active');
            wrap.style.cursor = 'cell';
        };

        window._setBrush = function(val) {
            brushSize = parseInt(val);
            document.getElementById('brushLabel').textContent = val;
        };

        window._zoomIn = function() {
            zoom = Math.min(ZOOM_MAX, zoom + ZOOM_STEP);
            applyCamera();
        };
        window._zoomOut = function() {
            zoom = Math.max(ZOOM_MIN, zoom - ZOOM_STEP);
            applyCamera();
        };
        window._zoomReset = function() {
            zoom = 1; camX = 0; camY = 0;
            applyCamera();
        };

        window._snapshot = function() {
            const tempCanvas = document.createElement('canvas');
            tempCanvas.width = CANVAS_W;
            tempCanvas.height = CANVAS_H;
            const tctx = tempCanvas.getContext('2d');
            tctx.fillStyle = BG_COLOR;
            tctx.fillRect(0, 0, CANVAS_W, CANVAS_H);
            tctx.drawImage(canvas, 0, 0);

            tempCanvas.toBlob(blob => {
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `sloppy-canvas-${Date.now()}.png`;
                a.click();
                URL.revokeObjectURL(url);
                showToast('Canvas saved as PNG');
            }, 'image/png');
        };

        window._clearMine = async function() {
            if (!confirm('Clear all YOUR strokes from the canvas?')) return;
            if (!currentUser) return;

            try {
                await supabase.from('sloppygram_collab_strokes').delete().eq('user_id', currentUser.id);
                strokes = strokes.filter(s => s.username !== username);
                redrawCanvas();
                showToast('Your strokes cleared');
                channel?.send({ type: 'broadcast', event: 'clear_all', payload: {} });
            } catch (e) {
                console.error('[Canvas] Clear error:', e);
            }
        };

        // === Keyboard shortcuts ===
        document.addEventListener('keydown', e => {
            if (e.target.tagName === 'INPUT') return;
            if (e.key === '+' || e.key === '=') { window._zoomIn(); e.preventDefault(); }
            if (e.key === '-') { window._zoomOut(); e.preventDefault(); }
            if (e.key === '0') { window._zoomReset(); e.preventDefault(); }
            if (e.key === 'e' || e.key === 'E') {
                const eb = document.querySelector('.eraser-btn');
                if (isEraser) {
                    window._setColor(currentColor, document.querySelector(`.color-btn[data-color="${currentColor}"]`) || document.querySelector('.color-btn'));
                } else {
                    window._setEraser(eb);
                }
            }
        });

        // === Helpers ===
        function escapeHtml(s) { const d = document.createElement('div'); d.textContent = s; return d.innerHTML; }
        function showToast(msg) {
            const t = document.getElementById('toast');
            t.textContent = msg;
            t.classList.add('show');
            setTimeout(() => t.classList.remove('show'), 2000);
        }

        // === Init ===
        async function init() {
            buildToolbar();
            initCanvas();
            await initAuth();
            await loadStrokes();
            setupRealtime();

            // Center viewport
            camX = -(CANVAS_W * zoom - wrap.clientWidth) / 2;
            camY = -(CANVAS_H * zoom - wrap.clientHeight) / 2;
            applyCamera();
        }

        init();
    </script>
</body>
</html>
