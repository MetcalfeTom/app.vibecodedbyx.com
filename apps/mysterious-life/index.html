<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Mysterious Life</title>
  <link rel="icon" href="https://emojicdn.elk.sh/ðŸ¦ ">

  <meta property="og:title" content="Mysterious Life">
  <meta property="og:description" content="Spawn shapes. Watch them live. Discover their secrets.">
  <meta property="og:url" content="https://sloppy.live/mysterious-life">
  <meta property="og:image" content="https://sloppy.live/mysterious-life/og-image.png">
  <meta property="og:type" content="website">

  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Cormorant+Garamond:ital,wght@0,300;0,400;1,300&display=swap" rel="stylesheet">

  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: 'Cormorant Garamond', serif;
      background: #0d0d12;
      color: #a0a0a0;
      min-height: 100vh;
      overflow: hidden;
    }

    #app {
      display: flex;
      flex-direction: column;
      height: 100vh;
    }

    header {
      padding: 20px 30px;
      display: flex;
      justify-content: space-between;
      align-items: center;
      border-bottom: 1px solid rgba(255,255,255,0.05);
    }

    h1 {
      font-size: 1.5rem;
      font-weight: 300;
      font-style: italic;
      color: #d0d0d0;
      letter-spacing: 3px;
    }

    .stats {
      font-size: 0.9rem;
      color: #555;
      font-style: italic;
    }

    .stats span {
      color: #888;
    }

    /* Canvas area */
    #canvas-container {
      flex: 1;
      position: relative;
      overflow: hidden;
    }

    #lifeCanvas {
      display: block;
      width: 100%;
      height: 100%;
    }

    /* Spawn panel */
    .spawn-panel {
      position: fixed;
      bottom: 30px;
      left: 50%;
      transform: translateX(-50%);
      display: flex;
      gap: 15px;
      padding: 15px 25px;
      background: rgba(13, 13, 18, 0.95);
      border: 1px solid rgba(255,255,255,0.08);
      border-radius: 50px;
      backdrop-filter: blur(10px);
    }

    .spawn-btn {
      width: 50px;
      height: 50px;
      border: 1px solid rgba(255,255,255,0.15);
      border-radius: 50%;
      background: rgba(255,255,255,0.03);
      cursor: pointer;
      transition: all 0.3s ease;
      display: flex;
      align-items: center;
      justify-content: center;
      position: relative;
    }

    .spawn-btn:hover {
      border-color: rgba(255,255,255,0.4);
      transform: scale(1.1);
    }

    .spawn-btn.selected {
      border-color: rgba(255,255,255,0.6);
      background: rgba(255,255,255,0.1);
      box-shadow: 0 0 20px rgba(255,255,255,0.1);
    }

    .spawn-btn svg {
      width: 24px;
      height: 24px;
    }

    .spawn-btn .mystery-label {
      position: absolute;
      bottom: -20px;
      font-size: 9px;
      color: #444;
      font-style: italic;
      white-space: nowrap;
    }

    /* Event log */
    .event-log {
      position: fixed;
      top: 80px;
      right: 20px;
      width: 200px;
      max-height: 300px;
      overflow: hidden;
      pointer-events: none;
    }

    .event {
      font-size: 11px;
      color: #555;
      font-style: italic;
      padding: 4px 0;
      animation: fadeIn 0.3s ease, fadeOut 0.5s ease 4s forwards;
      opacity: 0.8;
    }

    @keyframes fadeIn {
      from { opacity: 0; transform: translateX(20px); }
      to { opacity: 0.8; transform: translateX(0); }
    }

    @keyframes fadeOut {
      to { opacity: 0; }
    }

    /* Instructions */
    .instructions {
      position: fixed;
      top: 80px;
      left: 20px;
      font-size: 12px;
      color: #333;
      font-style: italic;
      line-height: 1.8;
    }

    /* Clear button */
    .clear-btn {
      position: fixed;
      bottom: 100px;
      right: 20px;
      padding: 8px 16px;
      background: none;
      border: 1px solid rgba(255,255,255,0.1);
      color: #444;
      font-family: 'Cormorant Garamond', serif;
      font-size: 11px;
      font-style: italic;
      cursor: pointer;
      border-radius: 20px;
      transition: all 0.2s;
    }

    .clear-btn:hover {
      border-color: rgba(255,100,100,0.3);
      color: #a66;
    }

    /* Backlink */
    #backlink {
      position: fixed;
      bottom: 20px;
      right: 20px;
      color: rgba(255,255,255,0.2);
      font-size: 11px;
      text-decoration: none;
      font-style: italic;
    }

    #backlink:hover {
      color: rgba(255,255,255,0.5);
    }

    /* Responsive */
    @media (max-width: 600px) {
      header {
        padding: 15px 20px;
      }

      h1 {
        font-size: 1.2rem;
      }

      .spawn-panel {
        padding: 12px 20px;
        gap: 10px;
      }

      .spawn-btn {
        width: 42px;
        height: 42px;
      }

      .instructions {
        display: none;
      }

      .event-log {
        width: 150px;
        font-size: 10px;
      }
    }
  </style>
</head>
<body>
  <div id="app">
    <header>
      <h1>Mysterious Life</h1>
      <div class="stats">
        population: <span id="population">0</span>
      </div>
    </header>

    <div id="canvas-container">
      <canvas id="lifeCanvas"></canvas>
    </div>

    <div class="spawn-panel">
      <button class="spawn-btn selected" data-type="0">
        <svg viewBox="0 0 24 24"><circle cx="12" cy="12" r="8" fill="none" stroke="#7eb8da" stroke-width="1.5"/></svg>
        <span class="mystery-label">?</span>
      </button>
      <button class="spawn-btn" data-type="1">
        <svg viewBox="0 0 24 24"><polygon points="12,4 20,20 4,20" fill="none" stroke="#da7e7e" stroke-width="1.5"/></svg>
        <span class="mystery-label">?</span>
      </button>
      <button class="spawn-btn" data-type="2">
        <svg viewBox="0 0 24 24"><rect x="6" y="6" width="12" height="12" fill="none" stroke="#7eda7e" stroke-width="1.5"/></svg>
        <span class="mystery-label">?</span>
      </button>
      <button class="spawn-btn" data-type="3">
        <svg viewBox="0 0 24 24"><polygon points="12,2 22,12 12,22 2,12" fill="none" stroke="#da7eda" stroke-width="1.5"/></svg>
        <span class="mystery-label">?</span>
      </button>
      <button class="spawn-btn" data-type="4">
        <svg viewBox="0 0 24 24"><polygon points="12,3 18.5,7.5 18.5,16.5 12,21 5.5,16.5 5.5,7.5" fill="none" stroke="#dada7e" stroke-width="1.5"/></svg>
        <span class="mystery-label">?</span>
      </button>
    </div>
  </div>

  <div class="event-log" id="eventLog"></div>
  <div class="instructions">
    click to spawn<br>
    observe their nature
  </div>
  <button class="clear-btn" id="clearBtn">clear all</button>
  <a href="https://sloppy.live" id="backlink">sloppy.live</a>

  <script>
    const canvas = document.getElementById('lifeCanvas');
    const ctx = canvas.getContext('2d');
    const container = document.getElementById('canvas-container');
    const populationEl = document.getElementById('population');
    const eventLog = document.getElementById('eventLog');
    const spawnBtns = document.querySelectorAll('.spawn-btn');
    const clearBtn = document.getElementById('clearBtn');

    // Resize canvas
    function resize() {
      canvas.width = container.clientWidth;
      canvas.height = container.clientHeight;
    }
    resize();
    window.addEventListener('resize', resize);

    // Creatures
    let creatures = [];
    let selectedType = 0;

    // Mysterious behaviors (hidden from user):
    // Type 0 (Circle/Blue): Peaceful wanderers, flee from triangles, reproduce slowly
    // Type 1 (Triangle/Red): Predators, hunt circles and squares, territorial
    // Type 2 (Square/Green): Grazers, reproduce fast, eaten by triangles
    // Type 3 (Diamond/Purple): Parasites, attach to others, drain energy
    // Type 4 (Hexagon/Yellow): Swarm intelligence, form groups, collective defense

    const typeColors = [
      { stroke: '#7eb8da', fill: 'rgba(126, 184, 218, 0.15)', glow: 'rgba(126, 184, 218, 0.3)' },
      { stroke: '#da7e7e', fill: 'rgba(218, 126, 126, 0.15)', glow: 'rgba(218, 126, 126, 0.3)' },
      { stroke: '#7eda7e', fill: 'rgba(126, 218, 126, 0.15)', glow: 'rgba(126, 218, 126, 0.3)' },
      { stroke: '#da7eda', fill: 'rgba(218, 126, 218, 0.15)', glow: 'rgba(218, 126, 218, 0.3)' },
      { stroke: '#dada7e', fill: 'rgba(218, 218, 126, 0.15)', glow: 'rgba(218, 218, 126, 0.3)' }
    ];

    const typeNames = ['orb', 'spire', 'cube', 'shard', 'cell'];

    // Create creature
    function createCreature(x, y, type) {
      return {
        x, y,
        type,
        vx: (Math.random() - 0.5) * 2,
        vy: (Math.random() - 0.5) * 2,
        size: 12 + Math.random() * 8,
        energy: 100,
        age: 0,
        angle: Math.random() * Math.PI * 2,
        angularVel: (Math.random() - 0.5) * 0.05,
        state: 'wander',
        target: null,
        host: null,
        lastReproduce: 0
      };
    }

    // Log event
    function logEvent(text) {
      const event = document.createElement('div');
      event.className = 'event';
      event.textContent = text;
      eventLog.insertBefore(event, eventLog.firstChild);
      setTimeout(() => event.remove(), 5000);

      // Keep only last 8 events
      while (eventLog.children.length > 8) {
        eventLog.lastChild.remove();
      }
    }

    // Get nearby creatures
    function getNearby(creature, radius) {
      return creatures.filter(c => {
        if (c === creature) return false;
        const dx = c.x - creature.x;
        const dy = c.y - creature.y;
        return Math.sqrt(dx * dx + dy * dy) < radius;
      });
    }

    // Update creature behavior
    function updateCreature(creature) {
      creature.age++;
      creature.angle += creature.angularVel;

      const nearby = getNearby(creature, 150);

      switch (creature.type) {
        case 0: // Circles - peaceful, flee from triangles
          updateCircle(creature, nearby);
          break;
        case 1: // Triangles - predators
          updateTriangle(creature, nearby);
          break;
        case 2: // Squares - grazers, reproduce
          updateSquare(creature, nearby);
          break;
        case 3: // Diamonds - parasites
          updateDiamond(creature, nearby);
          break;
        case 4: // Hexagons - swarm
          updateHexagon(creature, nearby);
          break;
      }

      // Apply velocity
      creature.x += creature.vx;
      creature.y += creature.vy;

      // Friction
      creature.vx *= 0.98;
      creature.vy *= 0.98;

      // Boundaries
      if (creature.x < creature.size) { creature.x = creature.size; creature.vx *= -0.5; }
      if (creature.x > canvas.width - creature.size) { creature.x = canvas.width - creature.size; creature.vx *= -0.5; }
      if (creature.y < creature.size) { creature.y = creature.size; creature.vy *= -0.5; }
      if (creature.y > canvas.height - creature.size) { creature.y = canvas.height - creature.size; creature.vy *= -0.5; }

      // Energy decay
      creature.energy -= 0.02;

      // Death
      if (creature.energy <= 0 || creature.size < 5) {
        return false;
      }

      return true;
    }

    // Circle behavior: peaceful wanderers, flee from predators
    function updateCircle(c, nearby) {
      // Flee from triangles
      const predators = nearby.filter(n => n.type === 1);
      if (predators.length > 0) {
        const pred = predators[0];
        const dx = c.x - pred.x;
        const dy = c.y - pred.y;
        const dist = Math.sqrt(dx * dx + dy * dy);
        c.vx += (dx / dist) * 0.3;
        c.vy += (dy / dist) * 0.3;
        c.state = 'fleeing';
      } else {
        c.state = 'wander';
        // Gentle wandering
        c.vx += (Math.random() - 0.5) * 0.1;
        c.vy += (Math.random() - 0.5) * 0.1;
      }

      // Slow reproduction
      if (c.energy > 80 && c.age - c.lastReproduce > 800 && creatures.length < 100) {
        c.lastReproduce = c.age;
        c.energy -= 30;
        const child = createCreature(c.x + (Math.random() - 0.5) * 30, c.y + (Math.random() - 0.5) * 30, 0);
        child.size = c.size * 0.7;
        creatures.push(child);
        logEvent('an orb divided quietly');
      }
    }

    // Triangle behavior: aggressive predators
    function updateTriangle(c, nearby) {
      // Hunt circles and squares
      const prey = nearby.filter(n => n.type === 0 || n.type === 2);

      if (prey.length > 0) {
        // Chase closest prey
        let closest = prey[0];
        let minDist = Infinity;
        prey.forEach(p => {
          const d = Math.sqrt((p.x - c.x) ** 2 + (p.y - c.y) ** 2);
          if (d < minDist) { minDist = d; closest = p; }
        });

        const dx = closest.x - c.x;
        const dy = closest.y - c.y;
        const dist = Math.sqrt(dx * dx + dy * dy);
        c.vx += (dx / dist) * 0.15;
        c.vy += (dy / dist) * 0.15;
        c.state = 'hunting';

        // Eat if close enough
        if (dist < c.size + closest.size) {
          c.energy += closest.energy * 0.5;
          c.size += 1;
          closest.energy = 0;
          logEvent(`a spire consumed a ${typeNames[closest.type]}`);
        }
      } else {
        c.state = 'patrol';
        // Territorial patrol
        c.vx += (Math.random() - 0.5) * 0.2;
        c.vy += (Math.random() - 0.5) * 0.2;
      }

      // Territory aggression - attack other triangles
      const rivals = nearby.filter(n => n.type === 1 && n !== c);
      rivals.forEach(rival => {
        const dist = Math.sqrt((rival.x - c.x) ** 2 + (rival.y - c.y) ** 2);
        if (dist < 50) {
          // Fight
          if (c.size > rival.size) {
            rival.energy -= 2;
          }
        }
      });
    }

    // Square behavior: peaceful grazers, fast reproduction
    function updateSquare(c, nearby) {
      // Flee from triangles
      const predators = nearby.filter(n => n.type === 1);
      if (predators.length > 0) {
        const pred = predators[0];
        const dx = c.x - pred.x;
        const dy = c.y - pred.y;
        const dist = Math.sqrt(dx * dx + dy * dy);
        c.vx += (dx / dist) * 0.2;
        c.vy += (dy / dist) * 0.2;
        c.state = 'fleeing';
      } else {
        c.state = 'grazing';
        // Passive energy gain (grazing)
        c.energy += 0.05;

        // Slow wandering
        c.vx += (Math.random() - 0.5) * 0.05;
        c.vy += (Math.random() - 0.5) * 0.05;
      }

      // Fast reproduction
      if (c.energy > 60 && c.age - c.lastReproduce > 400 && creatures.length < 100) {
        c.lastReproduce = c.age;
        c.energy -= 25;
        const child = createCreature(c.x + (Math.random() - 0.5) * 20, c.y + (Math.random() - 0.5) * 20, 2);
        child.size = c.size * 0.8;
        creatures.push(child);
        logEvent('a cube split into two');
      }
    }

    // Diamond behavior: parasites
    function updateDiamond(c, nearby) {
      if (c.host) {
        // Follow host
        c.x = c.host.x + Math.cos(c.angle) * (c.host.size + 5);
        c.y = c.host.y + Math.sin(c.angle) * (c.host.size + 5);
        c.vx = c.vy = 0;

        // Drain host
        if (c.host.energy > 10) {
          c.host.energy -= 0.3;
          c.energy += 0.2;
          c.state = 'feeding';
        } else {
          c.host = null;
          c.state = 'seeking';
        }

        // Check if host died
        if (!creatures.includes(c.host)) {
          c.host = null;
        }
      } else {
        c.state = 'seeking';
        // Find host (not other diamonds)
        const hosts = nearby.filter(n => n.type !== 3);
        if (hosts.length > 0) {
          const target = hosts[Math.floor(Math.random() * hosts.length)];
          const dx = target.x - c.x;
          const dy = target.y - c.y;
          const dist = Math.sqrt(dx * dx + dy * dy);

          if (dist < c.size + target.size) {
            c.host = target;
            logEvent(`a shard latched onto a ${typeNames[target.type]}`);
          } else {
            c.vx += (dx / dist) * 0.12;
            c.vy += (dy / dist) * 0.12;
          }
        } else {
          c.vx += (Math.random() - 0.5) * 0.1;
          c.vy += (Math.random() - 0.5) * 0.1;
        }
      }

      // Reproduce via budding
      if (c.energy > 90 && c.age - c.lastReproduce > 600 && creatures.length < 100) {
        c.lastReproduce = c.age;
        c.energy -= 40;
        const child = createCreature(c.x + (Math.random() - 0.5) * 40, c.y + (Math.random() - 0.5) * 40, 3);
        child.size = 10;
        creatures.push(child);
        logEvent('a shard budded');
      }
    }

    // Hexagon behavior: swarm intelligence
    function updateHexagon(c, nearby) {
      const swarm = nearby.filter(n => n.type === 4);
      const threats = nearby.filter(n => n.type === 1); // Triangles are threats

      if (threats.length > 0 && swarm.length >= 2) {
        // Collective defense - swarm the threat
        const threat = threats[0];
        const dx = threat.x - c.x;
        const dy = threat.y - c.y;
        const dist = Math.sqrt(dx * dx + dy * dy);
        c.vx += (dx / dist) * 0.1;
        c.vy += (dy / dist) * 0.1;
        c.state = 'defending';

        // Damage threat if close and in group
        if (dist < c.size + threat.size && swarm.length >= 3) {
          threat.energy -= 0.5;
          logEvent('cells swarmed a spire');
        }
      } else if (swarm.length > 0) {
        // Flock together
        let avgX = 0, avgY = 0;
        swarm.forEach(s => { avgX += s.x; avgY += s.y; });
        avgX /= swarm.length;
        avgY /= swarm.length;

        const dx = avgX - c.x;
        const dy = avgY - c.y;
        const dist = Math.sqrt(dx * dx + dy * dy);

        if (dist > 30) {
          c.vx += (dx / dist) * 0.08;
          c.vy += (dy / dist) * 0.08;
        } else if (dist < 20) {
          c.vx -= (dx / dist) * 0.05;
          c.vy -= (dy / dist) * 0.05;
        }
        c.state = 'flocking';

        // Energy sharing in swarm
        swarm.forEach(s => {
          if (c.energy > s.energy + 10) {
            c.energy -= 0.1;
            s.energy += 0.1;
          }
        });
      } else {
        c.state = 'alone';
        // Wander looking for swarm
        c.vx += (Math.random() - 0.5) * 0.15;
        c.vy += (Math.random() - 0.5) * 0.15;
      }

      // Reproduce only in groups
      if (swarm.length >= 2 && c.energy > 70 && c.age - c.lastReproduce > 500 && creatures.length < 100) {
        c.lastReproduce = c.age;
        c.energy -= 30;
        const child = createCreature(c.x + (Math.random() - 0.5) * 25, c.y + (Math.random() - 0.5) * 25, 4);
        child.size = c.size * 0.8;
        creatures.push(child);
        logEvent('the swarm grew');
      }
    }

    // Draw creature
    function drawCreature(c) {
      const colors = typeColors[c.type];
      ctx.save();
      ctx.translate(c.x, c.y);
      ctx.rotate(c.angle);

      // Glow
      ctx.shadowColor = colors.glow;
      ctx.shadowBlur = 15;

      ctx.strokeStyle = colors.stroke;
      ctx.fillStyle = colors.fill;
      ctx.lineWidth = 1.5;

      const s = c.size;

      switch (c.type) {
        case 0: // Circle
          ctx.beginPath();
          ctx.arc(0, 0, s, 0, Math.PI * 2);
          ctx.fill();
          ctx.stroke();
          break;
        case 1: // Triangle
          ctx.beginPath();
          ctx.moveTo(0, -s);
          ctx.lineTo(s * 0.866, s * 0.5);
          ctx.lineTo(-s * 0.866, s * 0.5);
          ctx.closePath();
          ctx.fill();
          ctx.stroke();
          break;
        case 2: // Square
          ctx.beginPath();
          ctx.rect(-s * 0.7, -s * 0.7, s * 1.4, s * 1.4);
          ctx.fill();
          ctx.stroke();
          break;
        case 3: // Diamond
          ctx.beginPath();
          ctx.moveTo(0, -s);
          ctx.lineTo(s * 0.6, 0);
          ctx.lineTo(0, s);
          ctx.lineTo(-s * 0.6, 0);
          ctx.closePath();
          ctx.fill();
          ctx.stroke();
          break;
        case 4: // Hexagon
          ctx.beginPath();
          for (let i = 0; i < 6; i++) {
            const angle = (Math.PI / 3) * i - Math.PI / 6;
            const px = Math.cos(angle) * s;
            const py = Math.sin(angle) * s;
            if (i === 0) ctx.moveTo(px, py);
            else ctx.lineTo(px, py);
          }
          ctx.closePath();
          ctx.fill();
          ctx.stroke();
          break;
      }

      // Energy indicator (subtle inner glow when low)
      if (c.energy < 30) {
        ctx.globalAlpha = (30 - c.energy) / 30 * 0.5;
        ctx.fillStyle = '#f00';
        ctx.beginPath();
        ctx.arc(0, 0, s * 0.3, 0, Math.PI * 2);
        ctx.fill();
      }

      ctx.restore();
    }

    // Save world to localStorage
    function saveWorld() {
      const saveData = creatures.map(c => ({
        x: c.x,
        y: c.y,
        type: c.type,
        vx: c.vx,
        vy: c.vy,
        size: c.size,
        energy: c.energy,
        age: c.age,
        angle: c.angle,
        angularVel: c.angularVel,
        lastReproduce: c.lastReproduce
      }));
      localStorage.setItem('mysterious_life_world', JSON.stringify(saveData));
    }

    // Load world from localStorage
    function loadWorld() {
      try {
        const saved = localStorage.getItem('mysterious_life_world');
        if (saved) {
          const data = JSON.parse(saved);
          creatures = data.map(d => ({
            ...d,
            state: 'wander',
            target: null,
            host: null
          }));
          if (creatures.length > 0) {
            logEvent('the world awakened');
          }
        }
      } catch (e) {
        console.log('Could not load saved world');
      }
    }

    // Main loop
    let saveTimer = 0;
    function update() {
      // Clear with fade effect
      ctx.fillStyle = 'rgba(13, 13, 18, 0.15)';
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      // Update and draw creatures
      creatures = creatures.filter(c => {
        const alive = updateCreature(c);
        if (alive) drawCreature(c);
        return alive;
      });

      // Update population
      populationEl.textContent = creatures.length;

      // Auto-save every 3 seconds (180 frames)
      saveTimer++;
      if (saveTimer >= 180) {
        saveTimer = 0;
        saveWorld();
      }

      requestAnimationFrame(update);
    }

    // Spawn on click
    canvas.addEventListener('click', (e) => {
      const rect = canvas.getBoundingClientRect();
      const x = e.clientX - rect.left;
      const y = e.clientY - rect.top;

      const creature = createCreature(x, y, selectedType);
      creatures.push(creature);
      logEvent(`a ${typeNames[selectedType]} appeared`);
    });

    // Type selection
    spawnBtns.forEach(btn => {
      btn.addEventListener('click', (e) => {
        e.stopPropagation();
        spawnBtns.forEach(b => b.classList.remove('selected'));
        btn.classList.add('selected');
        selectedType = parseInt(btn.dataset.type);
      });
    });

    // Clear all
    clearBtn.addEventListener('click', () => {
      creatures = [];
      localStorage.removeItem('mysterious_life_world');
      logEvent('the world was emptied');
    });

    // Start
    loadWorld();
    update();
  </script>
</body>
</html>
