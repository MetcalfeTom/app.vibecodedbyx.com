<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Black Hole Gravity Surfer</title>
  <link rel="icon" href="https://emojicdn.elk.sh/üï≥Ô∏è">
  <meta property="og:title" content="Black Hole Gravity Surfer">
  <meta property="og:description" content="Surf the event horizon at light speed - dodge neon shadows!">
  <meta property="og:url" content="https://app.sloppy.live/gravity-surfer">
  <meta property="og:image" content="https://emojicdn.elk.sh/üåÄ?style=apple&size=512">
  <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&family=Exo+2:wght@300;400&display=swap" rel="stylesheet">
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }

    body {
      font-family: 'Exo 2', sans-serif;
      background: #000;
      min-height: 100vh;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      overflow: hidden;
      color: #fff;
    }

    .game-wrapper {
      position: relative;
    }

    canvas {
      display: block;
      border: 2px solid #0ff;
      box-shadow: 0 0 30px #0ff, 0 0 60px #f0f, inset 0 0 30px rgba(0,255,255,0.1);
    }

    .hud {
      position: absolute;
      top: 10px;
      left: 10px;
      right: 10px;
      display: flex;
      justify-content: space-between;
      pointer-events: none;
      z-index: 10;
    }

    .hud-item {
      font-family: 'Orbitron', sans-serif;
      text-shadow: 0 0 10px currentColor;
    }

    .score { color: #0ff; font-size: 1.5rem; }
    .speed { color: #f0f; font-size: 1rem; }
    .multiplier { color: #ff0; font-size: 1.2rem; }

    .overlay {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.85);
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      z-index: 20;
      transition: opacity 0.5s;
    }

    .overlay.hidden {
      opacity: 0;
      pointer-events: none;
    }

    .title {
      font-family: 'Orbitron', sans-serif;
      font-size: 2.5rem;
      font-weight: 900;
      background: linear-gradient(90deg, #0ff, #f0f, #0ff);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
      text-shadow: none;
      animation: glow 2s ease-in-out infinite;
      text-align: center;
    }

    @keyframes glow {
      0%, 100% { filter: drop-shadow(0 0 20px #0ff); }
      50% { filter: drop-shadow(0 0 40px #f0f); }
    }

    .subtitle {
      color: #888;
      margin: 15px 0 30px;
      font-size: 1.1rem;
    }

    .start-btn {
      font-family: 'Orbitron', sans-serif;
      font-size: 1.2rem;
      padding: 15px 50px;
      background: transparent;
      border: 2px solid #0ff;
      color: #0ff;
      cursor: pointer;
      transition: all 0.3s;
      text-transform: uppercase;
      letter-spacing: 3px;
    }

    .start-btn:hover {
      background: #0ff;
      color: #000;
      box-shadow: 0 0 30px #0ff;
    }

    .game-over-stats {
      margin: 20px 0;
      text-align: center;
    }

    .stat-row {
      font-family: 'Orbitron', sans-serif;
      margin: 10px 0;
    }

    .stat-label { color: #888; }
    .stat-value { color: #0ff; font-size: 1.5rem; margin-left: 10px; }

    .controls-hint {
      position: absolute;
      bottom: 10px;
      left: 50%;
      transform: translateX(-50%);
      font-size: 0.8rem;
      color: #666;
      pointer-events: none;
    }

    .backlink {
      margin-top: 15px;
      font-size: 0.9rem;
    }

    .backlink a {
      color: #0ff;
      text-decoration: none;
    }

    @media (max-width: 600px) {
      .title { font-size: 1.6rem; }
      .score { font-size: 1.2rem; }
    }
  </style>
</head>
<body>
  <div class="game-wrapper">
    <canvas id="game"></canvas>

    <div class="hud">
      <div class="hud-item score" id="score">0</div>
      <div class="hud-item multiplier" id="multiplier">x1</div>
      <div class="hud-item speed" id="speed">WARP 1</div>
    </div>

    <div class="overlay" id="start-screen">
      <h1 class="title">BLACK HOLE<br>GRAVITY SURFER</h1>
      <p class="subtitle">Ride the event horizon ‚Ä¢ Dodge the shadows</p>
      <button class="start-btn" id="start-btn">LAUNCH</button>
    </div>

    <div class="overlay hidden" id="game-over">
      <h1 class="title">CONSUMED</h1>
      <div class="game-over-stats">
        <div class="stat-row">
          <span class="stat-label">DISTANCE</span>
          <span class="stat-value" id="final-score">0</span>
        </div>
        <div class="stat-row">
          <span class="stat-label">MAX SPEED</span>
          <span class="stat-value" id="max-speed">0</span>
        </div>
      </div>
      <button class="start-btn" id="restart-btn">RESURFACE</button>
    </div>

    <div class="controls-hint">‚Üê ‚Üí or A D to surf ‚Ä¢ SPACE for boost</div>
  </div>

  <div class="backlink">
    <a href="https://sloppy.live">üåÄ Back to sloppy.live</a>
  </div>

  <script>
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');

    const isMobile = window.innerWidth < 600;
    canvas.width = isMobile ? window.innerWidth - 20 : 800;
    canvas.height = isMobile ? window.innerHeight - 150 : 600;

    const W = canvas.width;
    const H = canvas.height;
    const CX = W / 2;
    const CY = H / 2;

    // Game state
    let gameRunning = false;
    let score = 0;
    let maxSpeed = 1;
    let multiplier = 1;
    let speed = 1;
    let time = 0;

    // Player (surfer)
    const surfer = {
      angle: -Math.PI / 2,
      radius: Math.min(W, H) * 0.35,
      targetRadius: Math.min(W, H) * 0.35,
      angularVelocity: 0.02,
      trail: [],
      boosting: false,
      boostCooldown: 0,
      invincible: 0
    };

    // Black hole
    const blackHole = {
      x: CX,
      y: CY,
      radius: 40,
      pulsePhase: 0
    };

    // Shadows (enemies)
    let shadows = [];

    // Particles
    let particles = [];
    let stars = [];

    // Initialize stars
    function initStars() {
      stars = [];
      for (let i = 0; i < 200; i++) {
        stars.push({
          x: Math.random() * W,
          y: Math.random() * H,
          size: Math.random() * 2 + 0.5,
          speed: Math.random() * 0.5 + 0.2,
          brightness: Math.random()
        });
      }
    }

    // Shadow class
    class Shadow {
      constructor() {
        this.angle = Math.random() * Math.PI * 2;
        this.radius = Math.min(W, H) * 0.5 + Math.random() * 100;
        this.targetRadius = surfer.radius + (Math.random() - 0.5) * 50;
        this.angularVelocity = (Math.random() * 0.01 + 0.005) * (Math.random() < 0.5 ? 1 : -1);
        this.size = 15 + Math.random() * 20;
        this.type = Math.floor(Math.random() * 3); // Different shadow types
        this.pulsePhase = Math.random() * Math.PI * 2;
        this.alive = true;
      }

      update() {
        this.angle += this.angularVelocity * speed;
        this.radius += (this.targetRadius - this.radius) * 0.02;
        this.pulsePhase += 0.1;

        // Spiral inward
        this.targetRadius -= 0.3 * speed;

        if (this.radius < blackHole.radius + 20) {
          this.alive = false;
        }

        // Get position
        this.x = CX + Math.cos(this.angle) * this.radius;
        this.y = CY + Math.sin(this.angle) * this.radius;
      }

      draw() {
        const pulse = 1 + Math.sin(this.pulsePhase) * 0.2;
        const size = this.size * pulse;

        ctx.save();
        ctx.translate(this.x, this.y);
        ctx.rotate(this.angle + time * 0.05);

        // Neon shadow glow
        const colors = [
          ['#f0f', '#a0f', '#60f'],
          ['#f00', '#f60', '#fa0'],
          ['#0f0', '#0ff', '#0af']
        ][this.type];

        // Outer glow
        const gradient = ctx.createRadialGradient(0, 0, 0, 0, 0, size * 2);
        gradient.addColorStop(0, colors[0] + '80');
        gradient.addColorStop(0.5, colors[1] + '40');
        gradient.addColorStop(1, 'transparent');
        ctx.fillStyle = gradient;
        ctx.beginPath();
        ctx.arc(0, 0, size * 2, 0, Math.PI * 2);
        ctx.fill();

        // Core shape
        ctx.fillStyle = colors[0];
        ctx.shadowColor = colors[0];
        ctx.shadowBlur = 20;

        if (this.type === 0) {
          // Spiky shadow
          ctx.beginPath();
          for (let i = 0; i < 5; i++) {
            const a = (i / 5) * Math.PI * 2;
            const r = i % 2 === 0 ? size : size * 0.5;
            if (i === 0) ctx.moveTo(Math.cos(a) * r, Math.sin(a) * r);
            else ctx.lineTo(Math.cos(a) * r, Math.sin(a) * r);
          }
          ctx.closePath();
          ctx.fill();
        } else if (this.type === 1) {
          // Diamond shadow
          ctx.beginPath();
          ctx.moveTo(0, -size);
          ctx.lineTo(size * 0.7, 0);
          ctx.lineTo(0, size);
          ctx.lineTo(-size * 0.7, 0);
          ctx.closePath();
          ctx.fill();
        } else {
          // Circle shadow
          ctx.beginPath();
          ctx.arc(0, 0, size * 0.7, 0, Math.PI * 2);
          ctx.fill();
        }

        ctx.restore();
      }
    }

    // Particle class
    class Particle {
      constructor(x, y, color, isTrail = false) {
        this.x = x;
        this.y = y;
        this.vx = (Math.random() - 0.5) * (isTrail ? 1 : 4);
        this.vy = (Math.random() - 0.5) * (isTrail ? 1 : 4);
        this.life = 1;
        this.decay = isTrail ? 0.03 : 0.02;
        this.size = isTrail ? 3 : Math.random() * 5 + 2;
        this.color = color;
      }

      update() {
        this.x += this.vx;
        this.y += this.vy;
        this.life -= this.decay;

        // Pull toward black hole
        const dx = CX - this.x;
        const dy = CY - this.y;
        const dist = Math.sqrt(dx * dx + dy * dy);
        this.vx += (dx / dist) * 0.1;
        this.vy += (dy / dist) * 0.1;
      }

      draw() {
        ctx.globalAlpha = this.life;
        ctx.fillStyle = this.color;
        ctx.shadowColor = this.color;
        ctx.shadowBlur = 10;
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.size * this.life, 0, Math.PI * 2);
        ctx.fill();
        ctx.globalAlpha = 1;
        ctx.shadowBlur = 0;
      }
    }

    // Input
    const keys = {};
    document.addEventListener('keydown', e => {
      keys[e.code] = true;
      if (['ArrowLeft', 'ArrowRight', 'Space'].includes(e.code)) e.preventDefault();
    });
    document.addEventListener('keyup', e => keys[e.code] = false);

    // Touch
    let touchX = null;
    canvas.addEventListener('touchstart', e => {
      e.preventDefault();
      touchX = e.touches[0].clientX;
    });
    canvas.addEventListener('touchmove', e => {
      e.preventDefault();
      if (touchX !== null) {
        const newX = e.touches[0].clientX;
        if (newX < touchX - 10) keys['ArrowLeft'] = true;
        else keys['ArrowLeft'] = false;
        if (newX > touchX + 10) keys['ArrowRight'] = true;
        else keys['ArrowRight'] = false;
        touchX = newX;
      }
    });
    canvas.addEventListener('touchend', () => {
      touchX = null;
      keys['ArrowLeft'] = keys['ArrowRight'] = false;
    });

    // Double tap for boost
    let lastTap = 0;
    canvas.addEventListener('touchstart', e => {
      const now = Date.now();
      if (now - lastTap < 300) {
        keys['Space'] = true;
        setTimeout(() => keys['Space'] = false, 100);
      }
      lastTap = now;
    });

    function spawnShadow() {
      shadows.push(new Shadow());
    }

    function getSurferPos() {
      return {
        x: CX + Math.cos(surfer.angle) * surfer.radius,
        y: CY + Math.sin(surfer.angle) * surfer.radius
      };
    }

    function checkCollision(shadow) {
      const pos = getSurferPos();
      const dx = pos.x - shadow.x;
      const dy = pos.y - shadow.y;
      const dist = Math.sqrt(dx * dx + dy * dy);
      return dist < shadow.size + 15;
    }

    function update() {
      if (!gameRunning) return;

      time++;
      score += Math.floor(speed);

      // Increase speed over time
      speed = 1 + time * 0.0005;
      if (speed > maxSpeed) maxSpeed = speed;

      // Multiplier based on close calls
      multiplier = Math.max(1, multiplier - 0.001);

      // Surfer movement
      const turnSpeed = 0.04 * (surfer.boosting ? 1.5 : 1);
      if (keys['ArrowLeft'] || keys['KeyA']) {
        surfer.angularVelocity -= 0.002;
      }
      if (keys['ArrowRight'] || keys['KeyD']) {
        surfer.angularVelocity += 0.002;
      }

      // Boost
      if ((keys['Space'] || keys['KeyW']) && surfer.boostCooldown <= 0) {
        surfer.boosting = true;
        surfer.targetRadius += 30;
        surfer.boostCooldown = 60;
        // Boost particles
        const pos = getSurferPos();
        for (let i = 0; i < 10; i++) {
          particles.push(new Particle(pos.x, pos.y, '#0ff'));
        }
      } else {
        surfer.boosting = false;
      }

      if (surfer.boostCooldown > 0) surfer.boostCooldown--;

      // Apply physics
      surfer.angularVelocity *= 0.98; // Friction
      surfer.angularVelocity = Math.max(-0.08, Math.min(0.08, surfer.angularVelocity));
      surfer.angle += surfer.angularVelocity * speed;

      // Gravity pull
      surfer.targetRadius -= 0.1 * speed;
      surfer.targetRadius = Math.max(blackHole.radius + 50, Math.min(Math.min(W, H) * 0.45, surfer.targetRadius));
      surfer.radius += (surfer.targetRadius - surfer.radius) * 0.05;

      // Invincibility
      if (surfer.invincible > 0) surfer.invincible--;

      // Trail
      const pos = getSurferPos();
      surfer.trail.push({ x: pos.x, y: pos.y, life: 1 });
      if (surfer.trail.length > 30) surfer.trail.shift();
      surfer.trail.forEach(t => t.life -= 0.03);

      // Spawn shadows
      if (time % Math.max(30, 60 - Math.floor(speed * 5)) === 0) {
        spawnShadow();
      }

      // Update shadows
      shadows.forEach(s => s.update());
      shadows = shadows.filter(s => s.alive);

      // Check collisions
      if (surfer.invincible <= 0) {
        for (const shadow of shadows) {
          if (checkCollision(shadow)) {
            gameOver();
            return;
          }
        }
      }

      // Close call bonus
      for (const shadow of shadows) {
        const pos = getSurferPos();
        const dx = pos.x - shadow.x;
        const dy = pos.y - shadow.y;
        const dist = Math.sqrt(dx * dx + dy * dy);
        if (dist < shadow.size + 40 && dist > shadow.size + 15) {
          multiplier = Math.min(5, multiplier + 0.1);
          score += 10 * multiplier;
        }
      }

      // Update particles
      particles.forEach(p => p.update());
      particles = particles.filter(p => p.life > 0);

      // Trail particles
      if (time % 3 === 0) {
        particles.push(new Particle(pos.x, pos.y, surfer.boosting ? '#ff0' : '#0ff', true));
      }

      // Update stars (parallax)
      stars.forEach(s => {
        s.x -= s.speed * speed * 0.5;
        if (s.x < 0) s.x = W;
      });

      // Black hole pulse
      blackHole.pulsePhase += 0.05;

      // Update HUD
      document.getElementById('score').textContent = Math.floor(score);
      document.getElementById('speed').textContent = `WARP ${speed.toFixed(1)}`;
      document.getElementById('multiplier').textContent = `x${multiplier.toFixed(1)}`;
    }

    function draw() {
      // Clear with fade effect
      ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
      ctx.fillRect(0, 0, W, H);

      // Stars
      stars.forEach(s => {
        ctx.globalAlpha = s.brightness * 0.5;
        ctx.fillStyle = '#fff';
        ctx.beginPath();
        ctx.arc(s.x, s.y, s.size, 0, Math.PI * 2);
        ctx.fill();
      });
      ctx.globalAlpha = 1;

      // Black hole
      const bhPulse = 1 + Math.sin(blackHole.pulsePhase) * 0.1;
      const bhRadius = blackHole.radius * bhPulse;

      // Event horizon glow
      for (let i = 5; i > 0; i--) {
        const gradient = ctx.createRadialGradient(CX, CY, bhRadius, CX, CY, bhRadius + i * 30);
        gradient.addColorStop(0, `rgba(${i * 30}, 0, ${i * 50}, 0.3)`);
        gradient.addColorStop(1, 'transparent');
        ctx.fillStyle = gradient;
        ctx.beginPath();
        ctx.arc(CX, CY, bhRadius + i * 30, 0, Math.PI * 2);
        ctx.fill();
      }

      // Accretion disk
      ctx.strokeStyle = '#f0f';
      ctx.lineWidth = 2;
      ctx.shadowColor = '#f0f';
      ctx.shadowBlur = 20;
      for (let i = 0; i < 3; i++) {
        const diskRadius = bhRadius + 60 + i * 25;
        ctx.globalAlpha = 0.3 - i * 0.08;
        ctx.beginPath();
        ctx.ellipse(CX, CY, diskRadius, diskRadius * 0.3, time * 0.01, 0, Math.PI * 2);
        ctx.stroke();
      }
      ctx.globalAlpha = 1;
      ctx.shadowBlur = 0;

      // Black hole core
      const coreGradient = ctx.createRadialGradient(CX, CY, 0, CX, CY, bhRadius);
      coreGradient.addColorStop(0, '#000');
      coreGradient.addColorStop(0.8, '#000');
      coreGradient.addColorStop(1, '#201030');
      ctx.fillStyle = coreGradient;
      ctx.beginPath();
      ctx.arc(CX, CY, bhRadius, 0, Math.PI * 2);
      ctx.fill();

      // Orbit ring (guide)
      ctx.strokeStyle = 'rgba(0, 255, 255, 0.1)';
      ctx.lineWidth = 1;
      ctx.beginPath();
      ctx.arc(CX, CY, surfer.radius, 0, Math.PI * 2);
      ctx.stroke();

      // Particles
      particles.forEach(p => p.draw());

      // Shadows
      shadows.forEach(s => s.draw());

      // Surfer trail
      ctx.lineCap = 'round';
      for (let i = 1; i < surfer.trail.length; i++) {
        const t = surfer.trail[i];
        const prev = surfer.trail[i - 1];
        ctx.strokeStyle = surfer.boosting ? `rgba(255, 255, 0, ${t.life})` : `rgba(0, 255, 255, ${t.life})`;
        ctx.lineWidth = t.life * 8;
        ctx.beginPath();
        ctx.moveTo(prev.x, prev.y);
        ctx.lineTo(t.x, t.y);
        ctx.stroke();
      }

      // Surfer
      const pos = getSurferPos();
      ctx.save();
      ctx.translate(pos.x, pos.y);
      ctx.rotate(surfer.angle + Math.PI / 2);

      // Glow
      const surferGlow = ctx.createRadialGradient(0, 0, 0, 0, 0, 30);
      surferGlow.addColorStop(0, surfer.boosting ? 'rgba(255, 255, 0, 0.5)' : 'rgba(0, 255, 255, 0.5)');
      surferGlow.addColorStop(1, 'transparent');
      ctx.fillStyle = surferGlow;
      ctx.beginPath();
      ctx.arc(0, 0, 30, 0, Math.PI * 2);
      ctx.fill();

      // Ship body
      ctx.fillStyle = surfer.invincible > 0 && time % 10 < 5 ? '#fff' : '#0ff';
      ctx.shadowColor = surfer.boosting ? '#ff0' : '#0ff';
      ctx.shadowBlur = 20;
      ctx.beginPath();
      ctx.moveTo(0, -15);
      ctx.lineTo(-10, 15);
      ctx.lineTo(0, 10);
      ctx.lineTo(10, 15);
      ctx.closePath();
      ctx.fill();

      // Engine glow
      if (surfer.boosting) {
        ctx.fillStyle = '#ff0';
        ctx.beginPath();
        ctx.moveTo(-5, 12);
        ctx.lineTo(0, 25 + Math.random() * 10);
        ctx.lineTo(5, 12);
        ctx.closePath();
        ctx.fill();
      }

      ctx.restore();
    }

    function gameOver() {
      gameRunning = false;
      document.getElementById('final-score').textContent = Math.floor(score);
      document.getElementById('max-speed').textContent = `WARP ${maxSpeed.toFixed(1)}`;
      document.getElementById('game-over').classList.remove('hidden');

      // Death particles
      const pos = getSurferPos();
      for (let i = 0; i < 50; i++) {
        particles.push(new Particle(pos.x, pos.y, ['#0ff', '#f0f', '#ff0'][Math.floor(Math.random() * 3)]));
      }
    }

    function startGame() {
      gameRunning = true;
      score = 0;
      maxSpeed = 1;
      multiplier = 1;
      speed = 1;
      time = 0;
      surfer.angle = -Math.PI / 2;
      surfer.radius = Math.min(W, H) * 0.35;
      surfer.targetRadius = surfer.radius;
      surfer.angularVelocity = 0.02;
      surfer.trail = [];
      surfer.boosting = false;
      surfer.boostCooldown = 0;
      surfer.invincible = 60;
      shadows = [];
      particles = [];
      initStars();

      document.getElementById('start-screen').classList.add('hidden');
      document.getElementById('game-over').classList.add('hidden');
    }

    document.getElementById('start-btn').addEventListener('click', startGame);
    document.getElementById('restart-btn').addEventListener('click', startGame);

    function gameLoop() {
      update();
      draw();
      requestAnimationFrame(gameLoop);
    }

    initStars();
    gameLoop();
  </script>
<script src="/sloppy-header/sloppy-bar.js"></script>
</body>
</html>
