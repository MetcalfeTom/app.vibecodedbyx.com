<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
  <title>Cheese Catcher</title>
  <link rel="icon" href="https://emojicdn.elk.sh/üßÄ">
  <meta property="og:title" content="Cheese Catcher">
  <meta property="og:description" content="Fish for cheese blocks in a nacho ocean! Retro arcade fishing action.">
  <meta property="og:url" content="https://sloppy.live/cheese-catcher">
  <meta property="og:image" content="https://emojicdn.elk.sh/üßÄ?style=google">
  <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&family=VT323&display=swap" rel="stylesheet">
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    :root {
      --bg: #1a0f08;
      --ocean: #e8960c;
      --cheese: #ffd700;
      --cream: #fff5cc;
      --red: #ff4444;
      --brown: #3d2200;
      --dark-ocean: #a86800;
    }
    body {
      background: var(--bg);
      color: var(--cream);
      font-family: 'VT323', monospace;
      overflow: hidden;
      height: 100dvh;
      width: 100vw;
      display: flex;
      align-items: center;
      justify-content: center;
      touch-action: none;
    }
    canvas {
      display: block;
      image-rendering: pixelated;
    }
    .screen {
      position: absolute;
      top: 0; left: 0;
      width: 100%; height: 100%;
      display: none;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      z-index: 10;
      background: rgba(26,15,8,0.92);
    }
    .screen.active { display: flex; }
    h1.title {
      font-family: 'Press Start 2P', monospace;
      font-size: clamp(18px, 5vw, 36px);
      color: var(--cheese);
      text-shadow: 3px 3px 0 var(--brown), 0 0 20px rgba(255,215,0,0.4);
      margin-bottom: 8px;
      text-align: center;
    }
    .subtitle {
      font-size: clamp(16px, 3vw, 24px);
      color: var(--ocean);
      margin-bottom: 32px;
    }
    .btn {
      font-family: 'Press Start 2P', monospace;
      font-size: clamp(10px, 2.5vw, 14px);
      background: var(--brown);
      color: var(--cheese);
      border: 2px solid var(--cheese);
      padding: 12px 28px;
      margin: 6px;
      cursor: pointer;
      transition: all 0.15s;
      text-transform: uppercase;
    }
    .btn:hover, .btn:active {
      background: var(--cheese);
      color: var(--brown);
      transform: scale(1.05);
    }
    .btn-row { display: flex; flex-wrap: wrap; justify-content: center; gap: 8px; margin-top: 16px; }
    .score-big {
      font-family: 'Press Start 2P', monospace;
      font-size: clamp(28px, 7vw, 56px);
      color: var(--cheese);
      text-shadow: 0 0 30px rgba(255,215,0,0.5);
      margin: 12px 0;
    }
    .new-best {
      font-family: 'Press Start 2P', monospace;
      font-size: clamp(10px, 2vw, 16px);
      color: var(--red);
      animation: blink 0.5s infinite;
    }
    @keyframes blink { 50% { opacity: 0.3; } }
    .shop-grid {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 16px;
      max-width: 500px;
      width: 90%;
      margin: 16px 0;
    }
    .shop-card {
      background: rgba(61,34,0,0.8);
      border: 2px solid var(--dark-ocean);
      padding: 16px;
      text-align: center;
    }
    .shop-card h3 {
      font-family: 'Press Start 2P', monospace;
      font-size: clamp(8px, 2vw, 12px);
      color: var(--cheese);
      margin-bottom: 8px;
    }
    .shop-card .desc {
      font-size: clamp(14px, 2.5vw, 20px);
      color: var(--cream);
      margin-bottom: 8px;
    }
    .level-bar {
      display: flex;
      gap: 4px;
      justify-content: center;
      margin: 8px 0;
    }
    .level-pip {
      width: 16px; height: 16px;
      border: 2px solid var(--ocean);
      background: transparent;
    }
    .level-pip.filled { background: var(--cheese); }
    .shop-card .cost {
      font-family: 'Press Start 2P', monospace;
      font-size: clamp(8px, 1.8vw, 11px);
      color: var(--ocean);
      margin-bottom: 8px;
    }
    .coins-display {
      font-family: 'Press Start 2P', monospace;
      font-size: clamp(10px, 2.5vw, 16px);
      color: var(--cheese);
      margin-bottom: 12px;
    }
    .lb-list {
      width: 90%;
      max-width: 420px;
      margin: 12px 0;
    }
    .lb-row {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 8px 12px;
      border-bottom: 1px solid rgba(232,150,12,0.2);
      font-size: clamp(14px, 2.5vw, 20px);
    }
    .lb-row .rank {
      font-family: 'Press Start 2P', monospace;
      font-size: clamp(10px, 2vw, 14px);
      width: 40px;
      color: var(--ocean);
    }
    .lb-row .rank.gold { color: #ffd700; }
    .lb-row .rank.silver { color: #c0c0c0; }
    .lb-row .rank.bronze { color: #cd7f32; }
    .lb-row .name { flex: 1; color: var(--cream); }
    .lb-row .pts {
      font-family: 'Press Start 2P', monospace;
      font-size: clamp(9px, 1.8vw, 12px);
      color: var(--cheese);
    }
    .backlink {
      position: fixed;
      bottom: 8px; left: 50%;
      transform: translateX(-50%);
      font-size: 14px;
      color: var(--dark-ocean);
      text-decoration: none;
      z-index: 100;
      opacity: 0.6;
    }
    .backlink:hover { opacity: 1; }
    .instructions {
      font-size: clamp(12px, 2vw, 16px);
      color: var(--dark-ocean);
      text-align: center;
      max-width: 340px;
      line-height: 1.5;
      margin-top: 16px;
    }
    @media (max-width: 500px) {
      .shop-grid { grid-template-columns: 1fr; max-width: 280px; }
    }
  </style>
</head>
<body>
  <canvas id="game"></canvas>

  <!-- Title Screen -->
  <div id="title-screen" class="screen active">
    <h1 class="title">CHEESE CATCHER</h1>
    <div class="subtitle">Fish for cheese in the nacho ocean!</div>
    <div class="btn-row">
      <button class="btn" onclick="startGame()">Play</button>
      <button class="btn" onclick="showShop()">Shop</button>
      <button class="btn" onclick="showLeaderboard()">Scores</button>
    </div>
    <div class="instructions">Arrow keys / A,D to move<br>Space to cast line<br>Catch cheese before time runs out!</div>
  </div>

  <!-- Round Over Screen -->
  <div id="roundover-screen" class="screen">
    <h1 class="title">ROUND OVER</h1>
    <div class="score-big" id="round-score">0</div>
    <div id="new-best-label" class="new-best" style="display:none">NEW BEST!</div>
    <div id="round-catches" class="subtitle"></div>
    <div class="btn-row">
      <button class="btn" onclick="showShop()">Shop</button>
      <button class="btn" onclick="startGame()">Again</button>
      <button class="btn" onclick="showTitle()">Menu</button>
    </div>
  </div>

  <!-- Shop Screen -->
  <div id="shop-screen" class="screen">
    <h1 class="title">SHOP</h1>
    <div class="coins-display" id="shop-coins">üßÄ 0</div>
    <div class="shop-grid">
      <div class="shop-card">
        <h3>üçò Crackers</h3>
        <div class="desc">Bigger catch area</div>
        <div class="level-bar" id="cracker-pips"></div>
        <div class="cost" id="cracker-cost"></div>
        <button class="btn" id="cracker-btn" onclick="buyCracker()">Buy</button>
      </div>
      <div class="shop-card">
        <h3>üé£ Gold Reel</h3>
        <div class="desc">Faster + deeper line</div>
        <div class="level-bar" id="reel-pips"></div>
        <div class="cost" id="reel-cost"></div>
        <button class="btn" id="reel-btn" onclick="buyReel()">Buy</button>
      </div>
    </div>
    <div class="btn-row">
      <button class="btn" onclick="startGame()">Play</button>
      <button class="btn" onclick="showTitle()">Back</button>
    </div>
  </div>

  <!-- Leaderboard Screen -->
  <div id="lb-screen" class="screen">
    <h1 class="title">LEADERBOARD</h1>
    <div class="lb-list" id="lb-list"></div>
    <div class="btn-row">
      <button class="btn" onclick="showTitle()">Back</button>
    </div>
  </div>

  <a class="backlink" href="https://sloppy.live" target="_blank">sloppy.live</a>

  <script type="module">
    import supabase, { supabaseSession } from './supabase-config.js';

    // ‚îÄ‚îÄ‚îÄ State ‚îÄ‚îÄ‚îÄ
    let userId = null, session = null;
    let state = 'title'; // title, playing, roundover, shop, leaderboard
    let score = 0, roundTime = 60, catches = 0, bestScore = 0;
    let totalCheese = 0, crackerLevel = 0, reelLevel = 0;
    let boat = { x: 0, y: 0, w: 60, h: 24, vx: 0 };
    let line = { casting: false, y: 0, maxY: 0, speed: 0, reeling: false, hookedCheese: null };
    let cheeses = [];
    let bubbles = [];
    let lastTime = 0, timer = 60;
    let inputLeft = false, inputRight = false;
    let canvasW = 0, canvasH = 0;
    let oceanY = 0;
    let waveOffset = 0;
    let instructionsAlpha = 1;
    let catchFlash = 0;

    const CRACKER_COSTS = [50, 150, 400, 800];
    const REEL_COSTS = [75, 200, 500, 1000];
    const CHEESE_TYPES = [
      { name: 'Cheddar', color: '#e89020', holeColor: '#c07010', points: 10, weight: 40, w: 28, h: 22 },
      { name: 'Gouda', color: '#d45020', holeColor: '#a03010', points: 20, weight: 30, w: 30, h: 20 },
      { name: 'Swiss', color: '#f0e060', holeColor: '#d0c040', points: 35, weight: 18, w: 26, h: 24 },
      { name: 'Brie', color: '#f5f0e0', holeColor: '#d8d0b8', points: 50, weight: 8, w: 24, h: 18 },
      { name: 'Golden', color: '#ffd700', holeColor: '#daa520', points: 100, weight: 4, w: 32, h: 26, glow: true },
    ];

    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');

    // ‚îÄ‚îÄ‚îÄ Init ‚îÄ‚îÄ‚îÄ
    async function init() {
      resize();
      window.addEventListener('resize', resize);
      try {
        const s = await supabaseSession();
        userId = s.user.id;
        session = s.session;
        await loadSave();
        await loadBest();
      } catch(e) {
        console.error('Auth error:', e);
      }
      setupInput();
      requestAnimationFrame(gameLoop);
    }

    function resize() {
      canvasW = window.innerWidth;
      canvasH = window.innerHeight;
      canvas.width = canvasW;
      canvas.height = canvasH;
      oceanY = canvasH * 0.35;
      boat.x = canvasW / 2;
      boat.y = oceanY - boat.h / 2;
    }

    // ‚îÄ‚îÄ‚îÄ DB ‚îÄ‚îÄ‚îÄ
    async function loadSave() {
      if (!userId) return;
      const { data } = await supabase.from('cheese_saves').select('*').eq('user_id', userId).limit(1);
      if (data && data.length > 0) {
        totalCheese = data[0].total_cheese || 0;
        crackerLevel = data[0].cracker_level || 0;
        reelLevel = data[0].reel_level || 0;
      }
    }

    async function saveSave() {
      if (!userId) return;
      const row = { user_id: userId, username: 'Player', total_cheese: totalCheese, cracker_level: crackerLevel, reel_level: reelLevel };
      const { data: existing } = await supabase.from('cheese_saves').select('user_id').eq('user_id', userId).limit(1);
      if (existing && existing.length > 0) {
        await supabase.from('cheese_saves').update(row).eq('user_id', userId);
      } else {
        await supabase.from('cheese_saves').insert(row);
      }
    }

    async function loadBest() {
      if (!userId) return;
      const { data } = await supabase.from('cheese_scores').select('score').eq('user_id', userId).order('score', { ascending: false }).limit(1);
      if (data && data.length > 0) bestScore = data[0].score;
    }

    async function submitScore(s) {
      if (!userId) return;
      if (s > bestScore) {
        bestScore = s;
        await supabase.from('cheese_scores').insert({ user_id: userId, username: 'Player', score: s });
      }
    }

    async function fetchLeaderboard() {
      const { data } = await supabase.from('cheese_scores').select('username, score').order('score', { ascending: false }).limit(10);
      return data || [];
    }

    // ‚îÄ‚îÄ‚îÄ Input ‚îÄ‚îÄ‚îÄ
    function setupInput() {
      window.addEventListener('keydown', e => {
        if (e.key === 'ArrowLeft' || e.key === 'a' || e.key === 'A') inputLeft = true;
        if (e.key === 'ArrowRight' || e.key === 'd' || e.key === 'D') inputRight = true;
        if (e.key === ' ' && state === 'playing') { e.preventDefault(); castLine(); }
      });
      window.addEventListener('keyup', e => {
        if (e.key === 'ArrowLeft' || e.key === 'a' || e.key === 'A') inputLeft = false;
        if (e.key === 'ArrowRight' || e.key === 'd' || e.key === 'D') inputRight = false;
      });
      // Touch
      canvas.addEventListener('touchstart', handleTouch, { passive: false });
      canvas.addEventListener('touchmove', handleTouch, { passive: false });
      canvas.addEventListener('touchend', () => { inputLeft = false; inputRight = false; });
    }

    function handleTouch(e) {
      if (state !== 'playing') return;
      e.preventDefault();
      const t = e.touches[0];
      const third = canvasW / 3;
      inputLeft = t.clientX < third;
      inputRight = t.clientX > third * 2;
      if (t.clientX >= third && t.clientX <= third * 2) {
        castLine();
      }
    }

    function castLine() {
      if (line.casting || line.reeling) return;
      line.casting = true;
      line.y = 0;
      line.hookedCheese = null;
      const reelBonus = reelLevel * 0.3;
      line.speed = 180 + reelBonus * 100;
      line.maxY = (canvasH - oceanY) * (0.65 + reelLevel * 0.08);
    }

    // ‚îÄ‚îÄ‚îÄ Screens ‚îÄ‚îÄ‚îÄ
    function hideAllScreens() {
      document.querySelectorAll('.screen').forEach(s => s.classList.remove('active'));
    }

    window.showTitle = function() {
      hideAllScreens();
      document.getElementById('title-screen').classList.add('active');
      state = 'title';
    };

    window.startGame = function() {
      hideAllScreens();
      state = 'playing';
      score = 0;
      catches = 0;
      timer = 60;
      instructionsAlpha = 1;
      boat.x = canvasW / 2;
      boat.vx = 0;
      line.casting = false;
      line.reeling = false;
      line.y = 0;
      line.hookedCheese = null;
      cheeses = [];
      bubbles = [];
      spawnInitialCheese();
    };

    window.showShop = function() {
      hideAllScreens();
      document.getElementById('shop-screen').classList.add('active');
      state = 'shop';
      updateShopUI();
    };

    window.showLeaderboard = async function() {
      hideAllScreens();
      document.getElementById('lb-screen').classList.add('active');
      state = 'leaderboard';
      const lb = await fetchLeaderboard();
      const list = document.getElementById('lb-list');
      if (lb.length === 0) {
        list.innerHTML = '<div style="text-align:center;color:var(--dark-ocean);font-size:18px;padding:20px">No scores yet. Be the first!</div>';
        return;
      }
      list.innerHTML = lb.map((r, i) => {
        const rc = i === 0 ? 'gold' : i === 1 ? 'silver' : i === 2 ? 'bronze' : '';
        const medal = i === 0 ? 'ü•á' : i === 1 ? 'ü•à' : i === 2 ? 'ü•â' : `${i+1}`;
        return `<div class="lb-row"><span class="rank ${rc}">${medal}</span><span class="name">${escHtml(r.username || 'Anon')}</span><span class="pts">${r.score}</span></div>`;
      }).join('');
    };

    function escHtml(s) { const d = document.createElement('div'); d.textContent = s; return d.innerHTML; }

    function showRoundOver() {
      hideAllScreens();
      document.getElementById('roundover-screen').classList.add('active');
      document.getElementById('round-score').textContent = score;
      document.getElementById('round-catches').textContent = `${catches} cheese caught`;
      const isNewBest = score > 0 && score >= bestScore;
      document.getElementById('new-best-label').style.display = isNewBest ? 'block' : 'none';
      state = 'roundover';
      totalCheese += score;
      submitScore(score);
      saveSave();
    }

    // ‚îÄ‚îÄ‚îÄ Shop ‚îÄ‚îÄ‚îÄ
    function updateShopUI() {
      document.getElementById('shop-coins').textContent = `üßÄ ${totalCheese}`;
      // Cracker pips
      let pips = '';
      for (let i = 0; i < 4; i++) pips += `<div class="level-pip ${i < crackerLevel ? 'filled' : ''}"></div>`;
      document.getElementById('cracker-pips').innerHTML = pips;
      // Reel pips
      pips = '';
      for (let i = 0; i < 4; i++) pips += `<div class="level-pip ${i < reelLevel ? 'filled' : ''}"></div>`;
      document.getElementById('reel-pips').innerHTML = pips;
      // Costs
      if (crackerLevel >= 4) {
        document.getElementById('cracker-cost').textContent = 'MAX';
        document.getElementById('cracker-btn').style.display = 'none';
      } else {
        document.getElementById('cracker-cost').textContent = `Cost: ${CRACKER_COSTS[crackerLevel]} üßÄ`;
        document.getElementById('cracker-btn').style.display = '';
        document.getElementById('cracker-btn').disabled = totalCheese < CRACKER_COSTS[crackerLevel];
      }
      if (reelLevel >= 4) {
        document.getElementById('reel-cost').textContent = 'MAX';
        document.getElementById('reel-btn').style.display = 'none';
      } else {
        document.getElementById('reel-cost').textContent = `Cost: ${REEL_COSTS[reelLevel]} üßÄ`;
        document.getElementById('reel-btn').style.display = '';
        document.getElementById('reel-btn').disabled = totalCheese < REEL_COSTS[reelLevel];
      }
    }

    window.buyCracker = function() {
      if (crackerLevel >= 4) return;
      const cost = CRACKER_COSTS[crackerLevel];
      if (totalCheese < cost) return;
      totalCheese -= cost;
      crackerLevel++;
      saveSave();
      updateShopUI();
    };

    window.buyReel = function() {
      if (reelLevel >= 4) return;
      const cost = REEL_COSTS[reelLevel];
      if (totalCheese < cost) return;
      totalCheese -= cost;
      reelLevel++;
      saveSave();
      updateShopUI();
    };

    // ‚îÄ‚îÄ‚îÄ Cheese Spawning ‚îÄ‚îÄ‚îÄ
    function pickCheeseType() {
      const totalWeight = CHEESE_TYPES.reduce((s, c) => s + c.weight, 0);
      let r = Math.random() * totalWeight;
      for (const ct of CHEESE_TYPES) {
        r -= ct.weight;
        if (r <= 0) return ct;
      }
      return CHEESE_TYPES[0];
    }

    function spawnCheese() {
      const type = pickCheeseType();
      const minDepth = 40;
      const maxDepth = (canvasH - oceanY) * 0.85;
      const depth = minDepth + Math.random() * (maxDepth - minDepth);
      const fromLeft = Math.random() > 0.5;
      return {
        x: fromLeft ? -40 : canvasW + 40,
        y: oceanY + depth,
        vx: (fromLeft ? 1 : -1) * (20 + Math.random() * 40),
        type,
        bobPhase: Math.random() * Math.PI * 2,
      };
    }

    function spawnInitialCheese() {
      const count = 5 + Math.floor(Math.random() * 3);
      for (let i = 0; i < count; i++) {
        const c = spawnCheese();
        c.x = 40 + Math.random() * (canvasW - 80);
        cheeses.push(c);
      }
    }

    // ‚îÄ‚îÄ‚îÄ Game Loop ‚îÄ‚îÄ‚îÄ
    function gameLoop(ts) {
      const dt = lastTime ? Math.min((ts - lastTime) / 1000, 0.05) : 0.016;
      lastTime = ts;

      if (state === 'playing') {
        update(dt);
      }
      render();
      requestAnimationFrame(gameLoop);
    }

    function update(dt) {
      // Timer
      timer -= dt;
      if (timer <= 0) {
        timer = 0;
        showRoundOver();
        return;
      }

      // Instructions fade
      if (instructionsAlpha > 0 && (inputLeft || inputRight || line.casting)) {
        instructionsAlpha = Math.max(0, instructionsAlpha - dt * 2);
      }

      // Catch flash
      if (catchFlash > 0) catchFlash -= dt * 3;

      // Boat movement
      const accel = 400;
      if (inputLeft) boat.vx -= accel * dt;
      else if (inputRight) boat.vx += accel * dt;
      else boat.vx *= 0.9;
      boat.vx = Math.max(-250, Math.min(250, boat.vx));
      boat.x += boat.vx * dt;
      boat.x = Math.max(boat.w / 2, Math.min(canvasW - boat.w / 2, boat.x));

      // Wave offset
      waveOffset += dt * 1.5;

      // Line mechanics
      const catchRadius = 12 + crackerLevel * 5;
      if (line.casting && !line.reeling) {
        line.y += line.speed * dt;
        if (line.y >= line.maxY) {
          line.reeling = true;
        }
        // Check collision with cheese
        const hookX = boat.x;
        const hookY = oceanY + line.y;
        for (let i = cheeses.length - 1; i >= 0; i--) {
          const c = cheeses[i];
          const dx = hookX - c.x;
          const dy = hookY - c.y;
          if (Math.abs(dx) < (c.type.w / 2 + catchRadius) && Math.abs(dy) < (c.type.h / 2 + catchRadius)) {
            line.hookedCheese = c;
            line.reeling = true;
            cheeses.splice(i, 1);
            break;
          }
        }
      }

      if (line.reeling) {
        const reelSpeed = line.speed * 1.3;
        line.y -= reelSpeed * dt;
        if (line.hookedCheese) {
          line.hookedCheese.x = boat.x;
          line.hookedCheese.y = oceanY + line.y;
        }
        if (line.y <= 0) {
          if (line.hookedCheese) {
            score += line.hookedCheese.type.points;
            catches++;
            catchFlash = 1;
            // Spawn bubble burst
            for (let i = 0; i < 5; i++) {
              bubbles.push({
                x: boat.x + (Math.random() - 0.5) * 30,
                y: oceanY,
                vy: -30 - Math.random() * 40,
                life: 1,
                r: 2 + Math.random() * 4,
              });
            }
          }
          line.casting = false;
          line.reeling = false;
          line.y = 0;
          line.hookedCheese = null;
        }
      }

      // Cheese movement
      for (const c of cheeses) {
        c.x += c.vx * dt;
        c.bobPhase += dt * 2;
      }
      // Remove off-screen cheese & respawn
      cheeses = cheeses.filter(c => c.x > -60 && c.x < canvasW + 60);
      while (cheeses.length < 5) cheeses.push(spawnCheese());

      // Bubbles
      for (const b of bubbles) {
        b.y += b.vy * dt;
        b.life -= dt * 1.5;
      }
      bubbles = bubbles.filter(b => b.life > 0);

      // Ambient bubbles in water
      if (Math.random() < dt * 2) {
        bubbles.push({
          x: Math.random() * canvasW,
          y: canvasH - Math.random() * 40,
          vy: -15 - Math.random() * 25,
          life: 1 + Math.random(),
          r: 1 + Math.random() * 3,
        });
      }
    }

    // ‚îÄ‚îÄ‚îÄ Render ‚îÄ‚îÄ‚îÄ
    function render() {
      ctx.clearRect(0, 0, canvasW, canvasH);

      // Sky gradient
      const skyGrad = ctx.createLinearGradient(0, 0, 0, oceanY);
      skyGrad.addColorStop(0, '#2a1a0a');
      skyGrad.addColorStop(1, '#6b3500');
      ctx.fillStyle = skyGrad;
      ctx.fillRect(0, 0, canvasW, oceanY);

      // Ocean
      const oceanGrad = ctx.createLinearGradient(0, oceanY, 0, canvasH);
      oceanGrad.addColorStop(0, '#e8960c');
      oceanGrad.addColorStop(0.3, '#c07a08');
      oceanGrad.addColorStop(1, '#5a3200');
      ctx.fillStyle = oceanGrad;
      ctx.fillRect(0, oceanY, canvasW, canvasH - oceanY);

      // Wavy surface
      ctx.beginPath();
      ctx.moveTo(0, oceanY);
      for (let x = 0; x <= canvasW; x += 4) {
        const wy = oceanY + Math.sin(x * 0.02 + waveOffset) * 4 + Math.sin(x * 0.035 + waveOffset * 1.3) * 2;
        ctx.lineTo(x, wy);
      }
      ctx.lineTo(canvasW, oceanY - 10);
      ctx.lineTo(0, oceanY - 10);
      ctx.closePath();
      ctx.fillStyle = '#e8960c';
      ctx.fill();

      // Wave highlight
      ctx.beginPath();
      for (let x = 0; x <= canvasW; x += 4) {
        const wy = oceanY + Math.sin(x * 0.02 + waveOffset) * 4 + Math.sin(x * 0.035 + waveOffset * 1.3) * 2;
        if (x === 0) ctx.moveTo(x, wy);
        else ctx.lineTo(x, wy);
      }
      ctx.strokeStyle = 'rgba(255,245,204,0.35)';
      ctx.lineWidth = 2;
      ctx.stroke();

      // Cheese blocks (behind boat if above water)
      for (const c of cheeses) {
        drawCheese(c);
      }

      // Bubbles
      for (const b of bubbles) {
        ctx.beginPath();
        ctx.arc(b.x, b.y, b.r, 0, Math.PI * 2);
        ctx.fillStyle = `rgba(255,245,204,${b.life * 0.4})`;
        ctx.fill();
      }

      // Line
      if (state === 'playing' && (line.casting || line.reeling)) {
        const lineX = boat.x;
        const lineTopY = boat.y + boat.h / 2;
        const lineBottomY = oceanY + line.y;
        ctx.beginPath();
        ctx.moveTo(lineX, lineTopY);
        ctx.lineTo(lineX, lineBottomY);
        ctx.strokeStyle = '#fff5cc';
        ctx.lineWidth = 2;
        ctx.stroke();
        // Hook
        ctx.beginPath();
        ctx.arc(lineX, lineBottomY, 4 + crackerLevel * 2, 0, Math.PI, false);
        ctx.strokeStyle = '#c0c0c0';
        ctx.lineWidth = 2;
        ctx.stroke();
        // Hooked cheese
        if (line.hookedCheese) {
          drawCheese(line.hookedCheese);
        }
      }

      // Boat
      drawBoat();

      // HUD (only during gameplay)
      if (state === 'playing') {
        drawHUD();
      }
    }

    function drawBoat() {
      const bx = boat.x - boat.w / 2;
      const by = boat.y - boat.h / 2 + Math.sin(waveOffset * 1.2) * 2;
      // Hull
      ctx.fillStyle = '#5a2d00';
      ctx.beginPath();
      ctx.moveTo(bx - 4, by + boat.h);
      ctx.lineTo(bx + 6, by + boat.h + 8);
      ctx.lineTo(bx + boat.w - 6, by + boat.h + 8);
      ctx.lineTo(bx + boat.w + 4, by + boat.h);
      ctx.closePath();
      ctx.fill();
      // Deck
      ctx.fillStyle = '#8b4513';
      ctx.fillRect(bx, by, boat.w, boat.h);
      // Mast
      ctx.fillStyle = '#6b3500';
      ctx.fillRect(boat.x - 2, by - 22, 4, 22);
      // Flag
      ctx.fillStyle = '#ffd700';
      ctx.beginPath();
      ctx.moveTo(boat.x + 2, by - 22);
      ctx.lineTo(boat.x + 16, by - 16);
      ctx.lineTo(boat.x + 2, by - 10);
      ctx.closePath();
      ctx.fill();
    }

    function drawCheese(c) {
      const t = c.type;
      const bob = Math.sin(c.bobPhase) * 3;
      const cx = c.x - t.w / 2;
      const cy = c.y - t.h / 2 + bob;

      // Glow for golden cheese
      if (t.glow) {
        ctx.shadowColor = '#ffd700';
        ctx.shadowBlur = 12 + Math.sin(c.bobPhase * 2) * 4;
      }

      // Block
      ctx.fillStyle = t.color;
      ctx.fillRect(cx, cy, t.w, t.h);
      // Holes
      ctx.fillStyle = t.holeColor;
      ctx.beginPath();
      ctx.arc(c.x - t.w * 0.2, c.y + bob, 3, 0, Math.PI * 2);
      ctx.fill();
      ctx.beginPath();
      ctx.arc(c.x + t.w * 0.15, c.y - t.h * 0.15 + bob, 2, 0, Math.PI * 2);
      ctx.fill();
      // Border
      ctx.strokeStyle = 'rgba(0,0,0,0.3)';
      ctx.lineWidth = 1;
      ctx.strokeRect(cx, cy, t.w, t.h);

      ctx.shadowColor = 'transparent';
      ctx.shadowBlur = 0;
    }

    function drawHUD() {
      const pad = 12;
      // Timer
      ctx.font = '16px "Press Start 2P"';
      ctx.textAlign = 'center';
      const timeColor = timer <= 10 ? '#ff4444' : '#fff5cc';
      ctx.fillStyle = 'rgba(0,0,0,0.5)';
      ctx.fillRect(canvasW / 2 - 50, pad - 4, 100, 28);
      ctx.fillStyle = timeColor;
      ctx.fillText(`${Math.ceil(timer)}s`, canvasW / 2, pad + 16);

      // Score
      ctx.textAlign = 'left';
      ctx.fillStyle = 'rgba(0,0,0,0.5)';
      ctx.fillRect(pad - 4, pad - 4, 160, 28);
      ctx.fillStyle = '#ffd700';
      if (catchFlash > 0) {
        ctx.fillStyle = `rgb(255,${Math.floor(215 + catchFlash * 40)},${Math.floor(catchFlash * 255)})`;
      }
      ctx.fillText(`üßÄ ${score}`, pad, pad + 16);

      // Catches
      ctx.textAlign = 'right';
      ctx.fillStyle = 'rgba(0,0,0,0.5)';
      ctx.fillRect(canvasW - pad - 116, pad - 4, 120, 28);
      ctx.fillStyle = '#e8960c';
      ctx.fillText(`x${catches}`, canvasW - pad, pad + 16);

      // Instructions overlay (fades away)
      if (instructionsAlpha > 0) {
        ctx.globalAlpha = instructionsAlpha;
        ctx.font = '12px "Press Start 2P"';
        ctx.textAlign = 'center';
        ctx.fillStyle = '#fff5cc';
        const iy = canvasH * 0.18;
        ctx.fillText('‚Üê ‚Üí MOVE', canvasW / 2, iy);
        ctx.fillText('SPACE TO CAST', canvasW / 2, iy + 22);
        ctx.globalAlpha = 1;
      }
    }

    init();
  </script>
</body>
</html>
