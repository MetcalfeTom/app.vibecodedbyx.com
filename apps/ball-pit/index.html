<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Neon Ball Pit</title>
  <link rel="icon" href="https://emojicdn.elk.sh/ðŸ”®">
  <meta property="og:title" content="Neon Ball Pit">
  <meta property="og:description" content="Run and jump through a physics-powered neon ball pit">
  <meta property="og:url" content="https://sloppy.live/ball-pit">
  <meta property="og:image" content="https://emojicdn.elk.sh/ðŸ”®?style=apple&size=512">
  <script src="https://cdn.babylonjs.com/babylon.js"></script>
  <script src="https://cdn.babylonjs.com/cannon.js"></script>
  <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700&display=swap" rel="stylesheet">
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      background: #0a0a0f;
      overflow: hidden;
      font-family: 'Orbitron', sans-serif;
    }
    #renderCanvas {
      width: 100%;
      height: 100vh;
      display: block;
      touch-action: none;
    }
    .controls {
      position: fixed;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      display: flex;
      gap: 12px;
      z-index: 100;
      flex-wrap: wrap;
      justify-content: center;
      padding: 0 10px;
    }
    .btn {
      padding: 12px 24px;
      background: rgba(0, 0, 0, 0.7);
      border: 2px solid #00ffff;
      color: #00ffff;
      font-family: 'Orbitron', sans-serif;
      font-size: 0.8rem;
      cursor: pointer;
      transition: all 0.2s;
      text-transform: uppercase;
      letter-spacing: 1px;
    }
    .btn:hover {
      background: rgba(0, 255, 255, 0.2);
      box-shadow: 0 0 20px #00ffff;
    }
    .btn.active {
      background: #00ffff;
      color: #000;
    }
    .btn.add { border-color: #ff00ff; color: #ff00ff; }
    .btn.add:hover { background: rgba(255, 0, 255, 0.2); box-shadow: 0 0 20px #ff00ff; }
    .btn.reset { border-color: #ff4444; color: #ff4444; }
    .btn.reset:hover { background: rgba(255, 68, 68, 0.2); box-shadow: 0 0 20px #ff4444; }

    .stats {
      position: fixed;
      top: 20px;
      left: 20px;
      color: #00ffff;
      font-size: 0.75rem;
      background: rgba(0, 0, 0, 0.6);
      padding: 15px;
      border: 1px solid rgba(0, 255, 255, 0.3);
    }
    .stats div { margin: 5px 0; }
    .stats span { color: #ff00ff; }

    .title {
      position: fixed;
      top: 20px;
      left: 50%;
      transform: translateX(-50%);
      color: #00ffff;
      font-size: 1.5rem;
      font-weight: 700;
      text-shadow: 0 0 30px #00ffff, 0 0 60px #00ffff;
      letter-spacing: 4px;
    }

    .back-link {
      position: fixed;
      top: 20px;
      right: 20px;
      color: #666;
      text-decoration: none;
      font-size: 0.7rem;
      transition: color 0.3s;
    }
    .back-link:hover { color: #00ffff; }

    .instructions {
      position: fixed;
      bottom: 80px;
      left: 50%;
      transform: translateX(-50%);
      color: #666;
      font-size: 0.65rem;
      text-align: center;
      line-height: 1.6;
    }

    /* Mobile joystick */
    .mobile-controls {
      display: none;
      position: fixed;
      bottom: 100px;
      left: 20px;
      z-index: 100;
    }
    .joystick {
      width: 120px;
      height: 120px;
      background: rgba(0, 255, 255, 0.1);
      border: 2px solid rgba(0, 255, 255, 0.4);
      border-radius: 50%;
      position: relative;
    }
    .joystick-knob {
      width: 50px;
      height: 50px;
      background: rgba(0, 255, 255, 0.5);
      border-radius: 50%;
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      pointer-events: none;
    }
    .jump-btn {
      position: fixed;
      bottom: 130px;
      right: 30px;
      width: 80px;
      height: 80px;
      background: rgba(255, 0, 255, 0.2);
      border: 3px solid #ff00ff;
      border-radius: 50%;
      color: #ff00ff;
      font-family: 'Orbitron', sans-serif;
      font-size: 0.7rem;
      display: none;
      align-items: center;
      justify-content: center;
      z-index: 100;
    }

    @media (max-width: 600px) {
      .title { font-size: 1rem; }
      .btn { padding: 10px 16px; font-size: 0.7rem; }
      .stats { font-size: 0.65rem; padding: 10px; }
      .mobile-controls { display: block; }
      .jump-btn { display: flex; }
      .instructions { bottom: 240px; font-size: 0.6rem; }
    }

    @media (pointer: coarse) {
      .mobile-controls { display: block; }
      .jump-btn { display: flex; }
    }
  </style>
</head>
<body>
  <canvas id="renderCanvas"></canvas>

  <div class="title">NEON BALL PIT</div>

  <div class="stats">
    <div>BALLS: <span id="ball-count">0</span></div>
    <div>GRAVITY: <span id="gravity-status">ON</span></div>
  </div>

  <a href="https://sloppy.live" class="back-link">sloppy.live</a>

  <div class="instructions">WASD/Arrows to move | SPACE to jump | Mouse to look</div>

  <div class="mobile-controls">
    <div class="joystick" id="joystick">
      <div class="joystick-knob" id="joystick-knob"></div>
    </div>
  </div>
  <button class="jump-btn" id="jump-btn">JUMP</button>

  <div class="controls">
    <button class="btn add" onclick="spawnBalls(10)">+10 Balls</button>
    <button class="btn" id="gravity-btn" onclick="toggleGravity()">Gravity: ON</button>
    <button class="btn" id="antigrav-btn" onclick="setAntiGravity()">Anti-Gravity</button>
    <button class="btn" id="chaos-btn" onclick="toggleChaos()">Chaos Mode</button>
    <button class="btn reset" onclick="resetPit()">Reset</button>
  </div>

  <script>
    const canvas = document.getElementById('renderCanvas');
    const engine = new BABYLON.Engine(canvas, true);

    let scene, camera, physicsPlugin;
    let balls = [];
    let gravityOn = true;
    let chaosMode = false;
    let chaosInterval = null;

    // Character variables
    let character, characterBody;
    let moveForward = false, moveBackward = false, moveLeft = false, moveRight = false;
    let canJump = true;
    let cameraAngle = 0;
    const moveSpeed = 8;
    const jumpForce = 12;

    // Mobile joystick
    let joystickActive = false;
    let joystickX = 0, joystickY = 0;

    const neonColors = [
      new BABYLON.Color3(0, 1, 1),      // Cyan
      new BABYLON.Color3(1, 0, 1),      // Magenta
      new BABYLON.Color3(0, 1, 0.5),    // Mint
      new BABYLON.Color3(1, 0.3, 0.5),  // Hot pink
      new BABYLON.Color3(0.5, 0, 1),    // Purple
      new BABYLON.Color3(1, 1, 0),      // Yellow
      new BABYLON.Color3(1, 0.5, 0),    // Orange
      new BABYLON.Color3(0, 0.5, 1),    // Blue
    ];

    function createScene() {
      scene = new BABYLON.Scene(engine);
      scene.clearColor = new BABYLON.Color4(0.02, 0.02, 0.05, 1);

      // Enable physics
      scene.enablePhysics(new BABYLON.Vector3(0, -9.81, 0), new BABYLON.CannonJSPlugin());
      physicsPlugin = scene.getPhysicsEngine();

      // Create character first
      createCharacter();

      // Third-person camera following character
      camera = new BABYLON.ArcRotateCamera('camera', Math.PI, Math.PI / 3, 12, character.position, scene);
      camera.attachControl(canvas, true);
      camera.lowerRadiusLimit = 5;
      camera.upperRadiusLimit = 20;
      camera.lowerBetaLimit = 0.3;
      camera.upperBetaLimit = Math.PI / 2.2;

      // Ambient light
      const ambient = new BABYLON.HemisphericLight('ambient', new BABYLON.Vector3(0, 1, 0), scene);
      ambient.intensity = 0.3;

      // Point lights for glow effect
      const light1 = new BABYLON.PointLight('light1', new BABYLON.Vector3(10, 10, 10), scene);
      light1.diffuse = new BABYLON.Color3(0, 1, 1);
      light1.intensity = 0.8;

      const light2 = new BABYLON.PointLight('light2', new BABYLON.Vector3(-10, 10, -10), scene);
      light2.diffuse = new BABYLON.Color3(1, 0, 1);
      light2.intensity = 0.8;

      // Create pit container
      createPit();

      // Spawn initial balls
      spawnBalls(30);

      // Character movement update
      scene.registerBeforeRender(() => {
        updateCharacter();
        camera.target = character.position.clone();
      });

      return scene;
    }

    function createCharacter() {
      // Character group
      character = new BABYLON.TransformNode('character', scene);
      character.position = new BABYLON.Vector3(0, 0, 0);

      // Neon material for character
      const bodyMat = new BABYLON.StandardMaterial('bodyMat', scene);
      bodyMat.diffuseColor = new BABYLON.Color3(1, 0, 1);
      bodyMat.emissiveColor = new BABYLON.Color3(0.5, 0, 0.5);

      const headMat = new BABYLON.StandardMaterial('headMat', scene);
      headMat.diffuseColor = new BABYLON.Color3(0, 1, 1);
      headMat.emissiveColor = new BABYLON.Color3(0, 0.5, 0.5);

      const limbMat = new BABYLON.StandardMaterial('limbMat', scene);
      limbMat.diffuseColor = new BABYLON.Color3(1, 1, 0);
      limbMat.emissiveColor = new BABYLON.Color3(0.5, 0.5, 0);

      // Body (cylinder)
      const body = BABYLON.MeshBuilder.CreateCylinder('body', { height: 1.2, diameter: 0.7 }, scene);
      body.material = bodyMat;
      body.parent = character;
      body.position.y = 0.6;

      // Head (sphere)
      const head = BABYLON.MeshBuilder.CreateSphere('head', { diameter: 0.6 }, scene);
      head.material = headMat;
      head.parent = character;
      head.position.y = 1.5;

      // Eyes
      const eyeMat = new BABYLON.StandardMaterial('eyeMat', scene);
      eyeMat.emissiveColor = new BABYLON.Color3(1, 1, 1);

      const leftEye = BABYLON.MeshBuilder.CreateSphere('leftEye', { diameter: 0.12 }, scene);
      leftEye.material = eyeMat;
      leftEye.parent = head;
      leftEye.position = new BABYLON.Vector3(-0.12, 0.05, 0.25);

      const rightEye = BABYLON.MeshBuilder.CreateSphere('rightEye', { diameter: 0.12 }, scene);
      rightEye.material = eyeMat;
      rightEye.parent = head;
      rightEye.position = new BABYLON.Vector3(0.12, 0.05, 0.25);

      // Arms
      const leftArm = BABYLON.MeshBuilder.CreateCylinder('leftArm', { height: 0.8, diameter: 0.2 }, scene);
      leftArm.material = limbMat;
      leftArm.parent = character;
      leftArm.position = new BABYLON.Vector3(-0.5, 0.8, 0);
      leftArm.rotation.z = Math.PI / 6;

      const rightArm = BABYLON.MeshBuilder.CreateCylinder('rightArm', { height: 0.8, diameter: 0.2 }, scene);
      rightArm.material = limbMat;
      rightArm.parent = character;
      rightArm.position = new BABYLON.Vector3(0.5, 0.8, 0);
      rightArm.rotation.z = -Math.PI / 6;

      // Legs
      const leftLeg = BABYLON.MeshBuilder.CreateCylinder('leftLeg', { height: 0.7, diameter: 0.25 }, scene);
      leftLeg.material = limbMat;
      leftLeg.parent = character;
      leftLeg.position = new BABYLON.Vector3(-0.2, -0.1, 0);

      const rightLeg = BABYLON.MeshBuilder.CreateCylinder('rightLeg', { height: 0.7, diameter: 0.25 }, scene);
      rightLeg.material = limbMat;
      rightLeg.parent = character;
      rightLeg.position = new BABYLON.Vector3(0.2, -0.1, 0);

      // Physics body (invisible cylinder) - raised hitbox to prevent leg clipping
      characterBody = BABYLON.MeshBuilder.CreateCylinder('charBody', { height: 1.6, diameter: 0.8 }, scene);
      characterBody.position.y = 0.5;
      characterBody.visibility = 0;
      characterBody.physicsImpostor = new BABYLON.PhysicsImpostor(
        characterBody,
        BABYLON.PhysicsImpostor.CylinderImpostor,
        { mass: 5, restitution: 0.1, friction: 0.5 },
        scene
      );

      // Prevent rotation on physics body
      characterBody.physicsImpostor.physicsBody.angularDamping = 1;
      characterBody.physicsImpostor.physicsBody.fixedRotation = true;
      characterBody.physicsImpostor.physicsBody.updateMassProperties();
    }

    function updateCharacter() {
      if (!characterBody || !characterBody.physicsImpostor) return;

      const velocity = characterBody.physicsImpostor.getLinearVelocity();

      // Get camera forward direction (flattened to XZ plane)
      const forward = camera.getForwardRay().direction;
      forward.y = 0;
      forward.normalize();

      const right = BABYLON.Vector3.Cross(BABYLON.Axis.Y, forward).normalize();

      let moveDir = BABYLON.Vector3.Zero();

      // Keyboard input
      if (moveForward) moveDir.addInPlace(forward);
      if (moveBackward) moveDir.subtractInPlace(forward);
      if (moveLeft) moveDir.subtractInPlace(right);
      if (moveRight) moveDir.addInPlace(right);

      // Joystick input
      if (joystickActive) {
        moveDir.addInPlace(forward.scale(-joystickY));
        moveDir.addInPlace(right.scale(joystickX));
      }

      if (moveDir.length() > 0) {
        moveDir.normalize();

        // Apply movement
        characterBody.physicsImpostor.setLinearVelocity(new BABYLON.Vector3(
          moveDir.x * moveSpeed,
          velocity.y,
          moveDir.z * moveSpeed
        ));

        // Rotate character to face movement direction
        const targetAngle = Math.atan2(moveDir.x, moveDir.z);
        character.rotation.y = targetAngle;
      } else {
        // Apply friction when not moving
        characterBody.physicsImpostor.setLinearVelocity(new BABYLON.Vector3(
          velocity.x * 0.9,
          velocity.y,
          velocity.z * 0.9
        ));
      }

      // Sync visual character with physics body (offset adjusted so legs don't clip)
      character.position.x = characterBody.position.x;
      character.position.y = characterBody.position.y - 0.35;
      character.position.z = characterBody.position.z;

      // Check if grounded (can jump)
      // Allow jump if: near ground level OR standing still on something (like balls)
      const groundLevel = -1.9; // Physics body center when standing on floor
      const isNearGround = characterBody.position.y < groundLevel + 0.5;
      const isStandingStill = Math.abs(velocity.y) < 0.3;

      if (isNearGround || isStandingStill) {
        canJump = true;
      }
    }

    function jump() {
      if (canJump && characterBody && characterBody.physicsImpostor) {
        const velocity = characterBody.physicsImpostor.getLinearVelocity();
        characterBody.physicsImpostor.setLinearVelocity(new BABYLON.Vector3(
          velocity.x,
          jumpForce,
          velocity.z
        ));
        canJump = false;
      }
    }

    function createPit() {
      const wallMat = new BABYLON.StandardMaterial('wallMat', scene);
      wallMat.diffuseColor = new BABYLON.Color3(0.1, 0.1, 0.15);
      wallMat.emissiveColor = new BABYLON.Color3(0.02, 0.02, 0.05);
      wallMat.alpha = 0.6;

      const floorMat = new BABYLON.StandardMaterial('floorMat', scene);
      floorMat.diffuseColor = new BABYLON.Color3(0.05, 0.05, 0.1);
      floorMat.emissiveColor = new BABYLON.Color3(0, 0.05, 0.05);

      // Floor
      const floor = BABYLON.MeshBuilder.CreateBox('floor', { width: 16, height: 0.5, depth: 16 }, scene);
      floor.position.y = -3;
      floor.material = floorMat;
      floor.physicsImpostor = new BABYLON.PhysicsImpostor(floor, BABYLON.PhysicsImpostor.BoxImpostor, { mass: 0, restitution: 0.6 }, scene);

      // Walls (larger pit)
      const wallConfigs = [
        { w: 16, h: 8, d: 0.3, x: 0, y: 0, z: 8 },
        { w: 16, h: 8, d: 0.3, x: 0, y: 0, z: -8 },
        { w: 0.3, h: 8, d: 16, x: 8, y: 0, z: 0 },
        { w: 0.3, h: 8, d: 16, x: -8, y: 0, z: 0 },
      ];

      wallConfigs.forEach((cfg, i) => {
        const wall = BABYLON.MeshBuilder.CreateBox(`wall${i}`, { width: cfg.w, height: cfg.h, depth: cfg.d }, scene);
        wall.position = new BABYLON.Vector3(cfg.x, cfg.y, cfg.z);
        wall.material = wallMat;
        wall.physicsImpostor = new BABYLON.PhysicsImpostor(wall, BABYLON.PhysicsImpostor.BoxImpostor, { mass: 0, restitution: 0.5 }, scene);
      });

      // Neon edge lines
      const edges = [
        [[-8, -2.75, -8], [8, -2.75, -8]],
        [[8, -2.75, -8], [8, -2.75, 8]],
        [[8, -2.75, 8], [-8, -2.75, 8]],
        [[-8, -2.75, 8], [-8, -2.75, -8]],
        [[-8, 4, -8], [8, 4, -8]],
        [[8, 4, -8], [8, 4, 8]],
        [[8, 4, 8], [-8, 4, 8]],
        [[-8, 4, 8], [-8, 4, -8]],
      ];

      edges.forEach((edge, i) => {
        const points = edge.map(p => new BABYLON.Vector3(p[0], p[1], p[2]));
        const line = BABYLON.MeshBuilder.CreateLines(`edge${i}`, { points }, scene);
        line.color = i < 4 ? new BABYLON.Color3(0, 1, 1) : new BABYLON.Color3(1, 0, 1);
      });
    }

    function spawnBall(x, y, z) {
      const radius = 0.3 + Math.random() * 0.3;
      const ball = BABYLON.MeshBuilder.CreateSphere(`ball${balls.length}`, { diameter: radius * 2 }, scene);
      ball.position = new BABYLON.Vector3(x, y, z);

      const mat = new BABYLON.StandardMaterial(`ballMat${balls.length}`, scene);
      const color = neonColors[Math.floor(Math.random() * neonColors.length)];
      mat.diffuseColor = color;
      mat.emissiveColor = color.scale(0.5);
      mat.specularColor = new BABYLON.Color3(1, 1, 1);
      ball.material = mat;

      ball.physicsImpostor = new BABYLON.PhysicsImpostor(
        ball,
        BABYLON.PhysicsImpostor.SphereImpostor,
        { mass: 1, restitution: 0.7, friction: 0.3 },
        scene
      );

      ball.physicsImpostor.setLinearVelocity(new BABYLON.Vector3(
        (Math.random() - 0.5) * 5,
        Math.random() * 2,
        (Math.random() - 0.5) * 5
      ));

      balls.push(ball);
      updateStats();
    }

    function spawnBalls(count) {
      for (let i = 0; i < count; i++) {
        const x = (Math.random() - 0.5) * 10;
        const y = 5 + Math.random() * 5;
        const z = (Math.random() - 0.5) * 10;
        spawnBall(x, y, z);
      }
    }

    function toggleGravity() {
      gravityOn = !gravityOn;
      physicsPlugin.setGravity(new BABYLON.Vector3(0, gravityOn ? -9.81 : 0, 0));
      document.getElementById('gravity-btn').textContent = `Gravity: ${gravityOn ? 'ON' : 'OFF'}`;
      document.getElementById('gravity-btn').classList.toggle('active', gravityOn);
      document.getElementById('antigrav-btn').classList.remove('active');
      updateStats();
    }

    function setAntiGravity() {
      gravityOn = false;
      physicsPlugin.setGravity(new BABYLON.Vector3(0, 5, 0));
      document.getElementById('gravity-btn').textContent = 'Gravity: OFF';
      document.getElementById('gravity-btn').classList.remove('active');
      document.getElementById('antigrav-btn').classList.add('active');
      document.getElementById('gravity-status').textContent = 'REVERSE';
    }

    function toggleChaos() {
      chaosMode = !chaosMode;
      document.getElementById('chaos-btn').classList.toggle('active', chaosMode);

      if (chaosMode) {
        chaosInterval = setInterval(() => {
          balls.forEach(ball => {
            if (ball.physicsImpostor) {
              ball.physicsImpostor.applyImpulse(
                new BABYLON.Vector3(
                  (Math.random() - 0.5) * 8,
                  Math.random() * 6,
                  (Math.random() - 0.5) * 8
                ),
                ball.getAbsolutePosition()
              );
            }
          });
        }, 500);
      } else {
        clearInterval(chaosInterval);
      }
    }

    function resetPit() {
      balls.forEach(ball => {
        ball.physicsImpostor.dispose();
        ball.dispose();
      });
      balls = [];

      gravityOn = true;
      physicsPlugin.setGravity(new BABYLON.Vector3(0, -9.81, 0));
      document.getElementById('gravity-btn').textContent = 'Gravity: ON';
      document.getElementById('gravity-btn').classList.add('active');
      document.getElementById('antigrav-btn').classList.remove('active');

      chaosMode = false;
      clearInterval(chaosInterval);
      document.getElementById('chaos-btn').classList.remove('active');

      // Reset character position
      if (characterBody) {
        characterBody.position = new BABYLON.Vector3(0, 1, 0);
        characterBody.physicsImpostor.setLinearVelocity(BABYLON.Vector3.Zero());
      }

      spawnBalls(30);
      updateStats();
    }

    function updateStats() {
      document.getElementById('ball-count').textContent = balls.length;
      document.getElementById('gravity-status').textContent = gravityOn ? 'ON' : 'OFF';
    }

    // Keyboard controls
    document.addEventListener('keydown', (e) => {
      switch (e.code) {
        case 'KeyW': case 'ArrowUp': moveForward = true; break;
        case 'KeyS': case 'ArrowDown': moveBackward = true; break;
        case 'KeyA': case 'ArrowLeft': moveLeft = true; break;
        case 'KeyD': case 'ArrowRight': moveRight = true; break;
        case 'Space': jump(); e.preventDefault(); break;
      }
    });

    document.addEventListener('keyup', (e) => {
      switch (e.code) {
        case 'KeyW': case 'ArrowUp': moveForward = false; break;
        case 'KeyS': case 'ArrowDown': moveBackward = false; break;
        case 'KeyA': case 'ArrowLeft': moveLeft = false; break;
        case 'KeyD': case 'ArrowRight': moveRight = false; break;
      }
    });

    // Mobile joystick
    const joystick = document.getElementById('joystick');
    const joystickKnob = document.getElementById('joystick-knob');
    const jumpBtn = document.getElementById('jump-btn');

    joystick.addEventListener('touchstart', (e) => {
      joystickActive = true;
      e.preventDefault();
    });

    joystick.addEventListener('touchmove', (e) => {
      if (!joystickActive) return;
      const touch = e.touches[0];
      const rect = joystick.getBoundingClientRect();
      const centerX = rect.left + rect.width / 2;
      const centerY = rect.top + rect.height / 2;

      let dx = touch.clientX - centerX;
      let dy = touch.clientY - centerY;
      const dist = Math.sqrt(dx * dx + dy * dy);
      const maxDist = rect.width / 2 - 25;

      if (dist > maxDist) {
        dx = (dx / dist) * maxDist;
        dy = (dy / dist) * maxDist;
      }

      joystickKnob.style.transform = `translate(calc(-50% + ${dx}px), calc(-50% + ${dy}px))`;
      joystickX = dx / maxDist;
      joystickY = dy / maxDist;
      e.preventDefault();
    });

    joystick.addEventListener('touchend', () => {
      joystickActive = false;
      joystickX = 0;
      joystickY = 0;
      joystickKnob.style.transform = 'translate(-50%, -50%)';
    });

    jumpBtn.addEventListener('touchstart', (e) => {
      jump();
      e.preventDefault();
    });

    // Initialize
    createScene();

    engine.runRenderLoop(() => {
      scene.render();
    });

    window.addEventListener('resize', () => {
      engine.resize();
    });
  </script>
</body>
</html>
