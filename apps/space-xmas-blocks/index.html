<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
  <title>Space Xmas Blocks - Fly Through Christmas</title>
  <link rel="icon" href="https://emojicdn.elk.sh/ðŸš€">

  <meta property="og:title" content="Space Xmas Blocks">
  <meta property="og:description" content="Fly a spaceship through floating Christmas blocks in space!">
  <meta property="og:url" content="https://app.sloppy.live/space-xmas-blocks">
  <meta property="og:image" content="https://app.sloppy.live/space-xmas-blocks/og-image.png">

  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700&display=swap" rel="stylesheet">

  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: 'Orbitron', sans-serif;
      background: #000;
      overflow: hidden;
      color: white;
    }

    #game-container {
      position: fixed;
      inset: 0;
    }

    canvas {
      display: block;
    }

    #ui {
      position: fixed;
      top: 20px;
      left: 50%;
      transform: translateX(-50%);
      text-align: center;
      z-index: 10;
      pointer-events: none;
    }

    #title {
      font-size: 1.5rem;
      font-weight: 700;
      text-shadow: 0 0 20px #ff0040, 0 0 40px #00ff88;
      background: linear-gradient(90deg, #ff0040, #00ff88, #00aaff);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
    }

    #speed {
      font-size: 0.9rem;
      margin-top: 8px;
      opacity: 0.8;
    }

    #instructions {
      position: fixed;
      bottom: 80px;
      left: 50%;
      transform: translateX(-50%);
      font-size: 0.8rem;
      opacity: 0.6;
      text-align: center;
      z-index: 10;
      transition: opacity 0.5s;
      pointer-events: none;
    }

    #instructions.hidden {
      opacity: 0;
    }

    #crosshair {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      width: 20px;
      height: 20px;
      border: 2px solid rgba(255,255,255,0.4);
      border-radius: 50%;
      z-index: 10;
      pointer-events: none;
    }

    #crosshair::before,
    #crosshair::after {
      content: '';
      position: absolute;
      background: rgba(255,255,255,0.4);
    }

    #crosshair::before {
      width: 10px;
      height: 2px;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
    }

    #crosshair::after {
      width: 2px;
      height: 10px;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
    }

    #mobile-controls {
      display: none;
      position: fixed;
      bottom: 20px;
      left: 0;
      right: 0;
      z-index: 20;
      padding: 0 20px;
    }

    @media (max-width: 768px), (pointer: coarse) {
      #mobile-controls {
        display: flex;
        justify-content: space-between;
      }
    }

    .control-pad {
      display: grid;
      grid-template-columns: repeat(3, 50px);
      grid-template-rows: repeat(2, 50px);
      gap: 5px;
    }

    .control-btn {
      width: 50px;
      height: 50px;
      background: rgba(255,255,255,0.15);
      border: 1px solid rgba(255,255,255,0.3);
      border-radius: 10px;
      color: white;
      font-size: 1.2rem;
      display: flex;
      align-items: center;
      justify-content: center;
      user-select: none;
      -webkit-user-select: none;
      touch-action: manipulation;
    }

    .control-btn:active {
      background: rgba(255,255,255,0.3);
    }

    #boost-btn {
      grid-column: 2;
      background: rgba(255,100,100,0.2);
      border-color: rgba(255,100,100,0.5);
    }

    #back-link {
      position: fixed;
      bottom: 15px;
      left: 50%;
      transform: translateX(-50%);
      color: rgba(255,255,255,0.4);
      text-decoration: none;
      font-size: 0.75rem;
      z-index: 10;
    }

    #back-link:hover {
      color: rgba(255,255,255,0.7);
    }
  </style>
</head>
<body>
  <div id="game-container"></div>

  <div id="ui">
    <div id="title">SPACE XMAS BLOCKS</div>
    <div id="speed">Speed: <span id="speed-val">0</span></div>
  </div>

  <div id="crosshair"></div>

  <div id="instructions">
    WASD / Arrows to fly â€¢ Mouse to look â€¢ SHIFT to boost
  </div>

  <div id="mobile-controls">
    <div class="control-pad">
      <div></div>
      <button class="control-btn" id="up-btn">â–²</button>
      <div></div>
      <button class="control-btn" id="left-btn">â—€</button>
      <button class="control-btn" id="boost-btn">ðŸš€</button>
      <button class="control-btn" id="right-btn">â–¶</button>
    </div>
    <div class="control-pad">
      <div></div>
      <button class="control-btn" id="pitch-up-btn">â†‘</button>
      <div></div>
      <button class="control-btn" id="yaw-left-btn">â†º</button>
      <button class="control-btn" id="down-btn">â–¼</button>
      <button class="control-btn" id="yaw-right-btn">â†»</button>
    </div>
  </div>

  <a id="back-link" href="https://sloppy.live">sloppy.live</a>

  <script type="importmap">
  {
    "imports": {
      "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
      "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
    }
  }
  </script>

  <script type="module">
    import * as THREE from 'three';

    const container = document.getElementById('game-container');
    const speedVal = document.getElementById('speed-val');
    const instructions = document.getElementById('instructions');

    // Scene setup
    const scene = new THREE.Scene();
    scene.fog = new THREE.FogExp2(0x000814, 0.0015);

    const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 2000);
    camera.position.set(0, 50, 100);

    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    renderer.setClearColor(0x000814);
    container.appendChild(renderer.domElement);

    // Lighting - enhanced for landscapes
    const ambientLight = new THREE.AmbientLight(0x303050, 0.6);
    scene.add(ambientLight);

    const directionalLight = new THREE.DirectionalLight(0xffeedd, 1.2);
    directionalLight.position.set(100, 200, 100);
    scene.add(directionalLight);

    const backLight = new THREE.DirectionalLight(0x4488ff, 0.3);
    backLight.position.set(-100, -50, -100);
    scene.add(backLight);

    // Point lights for festive glow
    const redLight = new THREE.PointLight(0xff0040, 3, 300);
    redLight.position.set(-50, 20, -50);
    scene.add(redLight);

    const greenLight = new THREE.PointLight(0x00ff88, 3, 300);
    greenLight.position.set(50, -20, 50);
    scene.add(greenLight);

    // Collision flash overlay
    const flashOverlay = document.createElement('div');
    flashOverlay.style.cssText = 'position:fixed;inset:0;background:white;opacity:0;pointer-events:none;z-index:5;transition:opacity 0.1s';
    container.appendChild(flashOverlay);

    // Camera shake system
    let shakeIntensity = 0;
    let shakeDecay = 0.9;
    const shakeOffset = new THREE.Vector3();

    // Starfield
    function createStarfield() {
      const geometry = new THREE.BufferGeometry();
      const vertices = [];
      const colors = [];

      for (let i = 0; i < 5000; i++) {
        const x = (Math.random() - 0.5) * 2000;
        const y = (Math.random() - 0.5) * 2000;
        const z = (Math.random() - 0.5) * 2000;
        vertices.push(x, y, z);

        // Slight color variation
        const color = new THREE.Color();
        color.setHSL(Math.random() * 0.1 + 0.55, 0.5, 0.8 + Math.random() * 0.2);
        colors.push(color.r, color.g, color.b);
      }

      geometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
      geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));

      const material = new THREE.PointsMaterial({
        size: 2,
        vertexColors: true,
        transparent: true,
        opacity: 0.8
      });

      return new THREE.Points(geometry, material);
    }

    const starfield = createStarfield();
    scene.add(starfield);

    // Simple noise function for terrain
    function noise2D(x, z, seed = 0) {
      const X = Math.floor(x) & 255;
      const Z = Math.floor(z) & 255;
      const xf = x - Math.floor(x);
      const zf = z - Math.floor(z);
      const u = xf * xf * (3 - 2 * xf);
      const v = zf * zf * (3 - 2 * zf);

      const hash = (a, b) => {
        const n = Math.sin(a * 12.9898 + b * 78.233 + seed) * 43758.5453;
        return n - Math.floor(n);
      };

      const aa = hash(X, Z);
      const ab = hash(X, Z + 1);
      const ba = hash(X + 1, Z);
      const bb = hash(X + 1, Z + 1);

      return aa * (1 - u) * (1 - v) + ba * u * (1 - v) + ab * (1 - u) * v + bb * u * v;
    }

    function fbm(x, z, octaves = 4) {
      let value = 0;
      let amplitude = 1;
      let frequency = 1;
      let maxValue = 0;

      for (let i = 0; i < octaves; i++) {
        value += noise2D(x * frequency, z * frequency) * amplitude;
        maxValue += amplitude;
        amplitude *= 0.5;
        frequency *= 2;
      }

      return value / maxValue;
    }

    // Christmas block types - expanded palette
    const BLOCK_TYPES = {
      present: { colors: [0xff0040, 0x00cc66, 0xffaa00, 0x0088ff, 0xff66aa, 0xaa00ff] },
      snow: { colors: [0xffffff, 0xe8f4ff, 0xd0e8ff, 0xf0f8ff] },
      candy: { colors: [0xff3366, 0xffffff, 0xff99cc, 0xffccdd] },
      gold: { colors: [0xffd700, 0xffaa00, 0xffcc33] },
      ice: { colors: [0x88ddff, 0x44aaff, 0xaaeeff, 0x66ccff] },
      tree: { colors: [0x228b22, 0x006400, 0x32cd32, 0x2e8b57] },
      stone: { colors: [0x666677, 0x555566, 0x777788] },
      dirt: { colors: [0x8b4513, 0x654321, 0x7a5230] }
    };

    // Create voxel-style blocks
    const blocks = [];
    const blockGroup = new THREE.Group();

    function createBlock(type, size) {
      const colors = BLOCK_TYPES[type].colors;
      const color = colors[Math.floor(Math.random() * colors.length)];

      const geometry = new THREE.BoxGeometry(size, size, size);
      const material = new THREE.MeshPhongMaterial({
        color: color,
        shininess: type === 'ice' || type === 'gold' ? 100 : 30,
        emissive: new THREE.Color(color).multiplyScalar(0.1)
      });

      const mesh = new THREE.Mesh(geometry, material);

      // Add ribbon for presents
      if (type === 'present') {
        const ribbonMat = new THREE.MeshPhongMaterial({ color: 0xffd700, emissive: 0x332200 });
        const ribbonH = new THREE.Mesh(new THREE.BoxGeometry(size * 1.02, size * 0.1, size * 0.1), ribbonMat);
        const ribbonV = new THREE.Mesh(new THREE.BoxGeometry(size * 0.1, size * 0.1, size * 1.02), ribbonMat);
        ribbonH.position.y = size * 0.5;
        ribbonV.position.y = size * 0.5;
        mesh.add(ribbonH);
        mesh.add(ribbonV);
      }

      return mesh;
    }

    function createChristmasTree(baseSize) {
      const group = new THREE.Group();

      // Trunk
      const trunkGeo = new THREE.BoxGeometry(baseSize * 0.3, baseSize * 0.4, baseSize * 0.3);
      const trunkMat = new THREE.MeshPhongMaterial({ color: 0x4a3728 });
      const trunk = new THREE.Mesh(trunkGeo, trunkMat);
      trunk.position.y = -baseSize * 0.5;
      group.add(trunk);

      // Tree layers (stacked blocks)
      const layers = 4;
      for (let i = 0; i < layers; i++) {
        const layerSize = baseSize * (1 - i * 0.2);
        const geo = new THREE.BoxGeometry(layerSize, baseSize * 0.3, layerSize);
        const mat = new THREE.MeshPhongMaterial({
          color: BLOCK_TYPES.tree.colors[i % BLOCK_TYPES.tree.colors.length],
          emissive: 0x001100
        });
        const layer = new THREE.Mesh(geo, mat);
        layer.position.y = i * baseSize * 0.25;
        group.add(layer);
      }

      // Star on top
      const starGeo = new THREE.OctahedronGeometry(baseSize * 0.15);
      const starMat = new THREE.MeshPhongMaterial({ color: 0xffd700, emissive: 0x664400 });
      const star = new THREE.Mesh(starGeo, starMat);
      star.position.y = layers * baseSize * 0.25 + baseSize * 0.1;
      group.add(star);

      return group;
    }

    function createOrnament(size) {
      const geo = new THREE.SphereGeometry(size, 16, 16);
      const colors = [0xff0040, 0x00cc66, 0xffaa00, 0x0088ff, 0xff66aa, 0xaa00ff];
      const color = colors[Math.floor(Math.random() * colors.length)];
      const mat = new THREE.MeshPhongMaterial({
        color: color,
        shininess: 100,
        emissive: new THREE.Color(color).multiplyScalar(0.2)
      });
      return new THREE.Mesh(geo, mat);
    }

    // Generate a floating island at a position
    function generateFloatingIsland(centerX, centerY, centerZ, radius, biome) {
      const island = new THREE.Group();
      const blockSize = 4;
      const islandBlocks = [];

      // Determine biome colors
      const biomeTypes = {
        snow: ['snow', 'ice', 'snow', 'stone'],
        forest: ['tree', 'dirt', 'tree', 'stone'],
        candy: ['candy', 'present', 'candy', 'gold'],
        present: ['present', 'gold', 'present', 'candy']
      };

      const blockPalette = biomeTypes[biome] || biomeTypes.snow;

      // Generate island shape with noise
      const gridSize = Math.ceil(radius / blockSize) * 2;

      for (let gx = -gridSize; gx <= gridSize; gx++) {
        for (let gz = -gridSize; gz <= gridSize; gz++) {
          const wx = gx * blockSize;
          const wz = gz * blockSize;
          const dist = Math.sqrt(wx * wx + wz * wz);

          if (dist > radius) continue;

          // Height based on distance from center + noise
          const falloff = 1 - (dist / radius);
          const noiseVal = fbm(centerX + gx * 0.3, centerZ + gz * 0.3, 3);
          const height = Math.floor(falloff * falloff * 8 + noiseVal * 4);

          if (height <= 0) continue;

          // Stack blocks vertically
          for (let y = -2; y <= height; y++) {
            // Skip some blocks on the bottom for irregular shape
            if (y < 0 && Math.random() > 0.6 + falloff * 0.3) continue;

            let blockType;
            if (y === height) {
              blockType = blockPalette[0]; // Top layer
            } else if (y >= height - 2) {
              blockType = blockPalette[1]; // Middle layer
            } else {
              blockType = blockPalette[3]; // Bottom/stone
            }

            const block = createBlock(blockType, blockSize);
            block.position.set(wx, y * blockSize, wz);

            block.userData = {
              isCollider: true,
              blockSize: blockSize,
              worldPos: new THREE.Vector3(centerX + wx, centerY + y * blockSize, centerZ + wz)
            };

            island.add(block);
            islandBlocks.push(block);
          }

          // Add trees on top for forest biome
          if (biome === 'forest' && height > 2 && Math.random() > 0.85) {
            const tree = createChristmasTree(blockSize * 1.5);
            tree.position.set(wx, (height + 1) * blockSize, wz);
            island.add(tree);
          }

          // Add presents/ornaments on other biomes
          if ((biome === 'present' || biome === 'candy') && height > 1 && Math.random() > 0.9) {
            const decor = Math.random() > 0.5 ? createOrnament(blockSize * 0.4) : createBlock('present', blockSize * 0.6);
            decor.position.set(wx, (height + 0.5) * blockSize, wz);
            island.add(decor);
          }
        }
      }

      island.position.set(centerX, centerY, centerZ);

      // Gentle floating animation data
      island.userData = {
        bobSpeed: 0.2 + Math.random() * 0.3,
        bobOffset: Math.random() * Math.PI * 2,
        originalY: centerY,
        rotSpeed: (Math.random() - 0.5) * 0.001,
        blocks: islandBlocks
      };

      return island;
    }

    // Generate world with multiple floating islands
    function generateWorld() {
      const biomes = ['snow', 'forest', 'candy', 'present'];
      const numIslands = 25;

      for (let i = 0; i < numIslands; i++) {
        const angle = (i / numIslands) * Math.PI * 2 + Math.random() * 0.5;
        const distance = 80 + Math.random() * 400;
        const x = Math.cos(angle) * distance + (Math.random() - 0.5) * 200;
        const z = Math.sin(angle) * distance + (Math.random() - 0.5) * 200;
        const y = (Math.random() - 0.5) * 200;

        const radius = 30 + Math.random() * 50;
        const biome = biomes[Math.floor(Math.random() * biomes.length)];

        const island = generateFloatingIsland(x, y, z, radius, biome);
        blocks.push(island);
        blockGroup.add(island);
      }

      // Add scattered decorative elements
      for (let i = 0; i < 100; i++) {
        const type = Math.random() > 0.5 ? 'ornament' : 'present';
        const size = 2 + Math.random() * 4;

        let mesh;
        if (type === 'ornament') {
          mesh = createOrnament(size);
        } else {
          mesh = createBlock('present', size);
        }

        mesh.position.set(
          (Math.random() - 0.5) * 1000,
          (Math.random() - 0.5) * 400,
          (Math.random() - 0.5) * 1000
        );

        mesh.userData = {
          rotSpeed: {
            x: (Math.random() - 0.5) * 0.02,
            y: (Math.random() - 0.5) * 0.02,
            z: (Math.random() - 0.5) * 0.02
          },
          bobSpeed: 0.5 + Math.random() * 1,
          bobOffset: Math.random() * Math.PI * 2,
          originalY: mesh.position.y,
          isDecor: true
        };

        blocks.push(mesh);
        blockGroup.add(mesh);
      }
    }

    generateWorld();
    scene.add(blockGroup);

    // Spaceship (simple shape at camera)
    const shipGroup = new THREE.Group();

    // Ship body
    const bodyGeo = new THREE.ConeGeometry(0.3, 1, 8);
    bodyGeo.rotateX(Math.PI / 2);
    const bodyMat = new THREE.MeshPhongMaterial({ color: 0x888899, shininess: 80 });
    const body = new THREE.Mesh(bodyGeo, bodyMat);
    body.position.z = -1.5;
    shipGroup.add(body);

    // Wings
    const wingGeo = new THREE.BoxGeometry(1.5, 0.05, 0.4);
    const wingMat = new THREE.MeshPhongMaterial({ color: 0xff3344, emissive: 0x220000 });
    const wings = new THREE.Mesh(wingGeo, wingMat);
    wings.position.z = -1.2;
    shipGroup.add(wings);

    // Engine glow
    const engineGeo = new THREE.SphereGeometry(0.15, 8, 8);
    const engineMat = new THREE.MeshBasicMaterial({ color: 0x00ffff });
    const engineL = new THREE.Mesh(engineGeo, engineMat);
    const engineR = new THREE.Mesh(engineGeo, engineMat.clone());
    engineL.position.set(-0.4, 0, -0.9);
    engineR.position.set(0.4, 0, -0.9);
    shipGroup.add(engineL, engineR);

    camera.add(shipGroup);
    scene.add(camera);

    // Trail particles
    const trailParticles = [];
    const trailGroup = new THREE.Group();
    scene.add(trailGroup);

    function spawnTrailParticle() {
      const geo = new THREE.SphereGeometry(0.1, 4, 4);
      const mat = new THREE.MeshBasicMaterial({
        color: Math.random() > 0.5 ? 0x00ffff : 0xff4400,
        transparent: true,
        opacity: 1
      });
      const particle = new THREE.Mesh(geo, mat);

      // Position behind ship
      const worldPos = new THREE.Vector3(
        (Math.random() - 0.5) * 0.3,
        (Math.random() - 0.5) * 0.3,
        -0.8
      );
      camera.localToWorld(worldPos);
      particle.position.copy(worldPos);

      particle.userData = { life: 1, decay: 0.02 + Math.random() * 0.02 };
      trailParticles.push(particle);
      trailGroup.add(particle);
    }

    // Controls - smooth physics-based system
    const keys = {};
    const mouse = { x: 0, y: 0 };
    const targetMouse = { x: 0, y: 0 };
    let isPointerLocked = false;
    let hasInteracted = false;

    // Velocity-based movement
    const velocity = new THREE.Vector3();
    const angularVelocity = new THREE.Vector3();
    const euler = new THREE.Euler(0, 0, 0, 'YXZ');

    // Physics constants
    const ACCELERATION = 0.08;
    const MAX_SPEED = 1.8;
    const BOOST_MAX_SPEED = 4.5;
    const DRAG = 0.985;
    const STRAFE_SPEED = 0.06;
    const MOUSE_SENSITIVITY = 0.0018;
    const MOUSE_SMOOTHING = 0.12;
    const ROLL_AMOUNT = 0.4;
    const ROLL_SMOOTHING = 0.08;

    let currentSpeed = 0;
    let targetSpeed = 0;
    let currentRoll = 0;
    let targetRoll = 0;

    // Collision particles
    const collisionParticles = [];
    const collisionGroup = new THREE.Group();
    scene.add(collisionGroup);

    function spawnCollisionParticles(position, color, count = 15) {
      for (let i = 0; i < count; i++) {
        const geo = new THREE.BoxGeometry(0.5, 0.5, 0.5);
        const mat = new THREE.MeshBasicMaterial({
          color: color,
          transparent: true,
          opacity: 1
        });
        const particle = new THREE.Mesh(geo, mat);

        particle.position.copy(position);
        particle.velocity = new THREE.Vector3(
          (Math.random() - 0.5) * 2,
          (Math.random() - 0.5) * 2,
          (Math.random() - 0.5) * 2
        );
        particle.rotVel = new THREE.Vector3(
          Math.random() * 0.3,
          Math.random() * 0.3,
          Math.random() * 0.3
        );
        particle.userData = { life: 1, decay: 0.02 + Math.random() * 0.02 };

        collisionParticles.push(particle);
        collisionGroup.add(particle);
      }
    }

    function triggerCollision(intensity = 1) {
      shakeIntensity = Math.min(shakeIntensity + intensity * 0.8, 2);
      flashOverlay.style.opacity = 0.3 * intensity;
      setTimeout(() => flashOverlay.style.opacity = 0, 100);

      // Bounce back velocity
      velocity.multiplyScalar(-0.3);
      currentSpeed *= 0.3;
    }

    document.addEventListener('keydown', (e) => {
      keys[e.code] = true;
      if (!hasInteracted) {
        hasInteracted = true;
        instructions.classList.add('hidden');
      }
    });
    document.addEventListener('keyup', (e) => keys[e.code] = false);

    document.addEventListener('click', () => {
      if (!isPointerLocked) {
        renderer.domElement.requestPointerLock();
      }
    });

    document.addEventListener('pointerlockchange', () => {
      isPointerLocked = document.pointerLockElement === renderer.domElement;
    });

    document.addEventListener('mousemove', (e) => {
      if (isPointerLocked) {
        targetMouse.x += e.movementX * MOUSE_SENSITIVITY;
        targetMouse.y += e.movementY * MOUSE_SENSITIVITY;
        targetMouse.y = Math.max(-Math.PI / 2 + 0.1, Math.min(Math.PI / 2 - 0.1, targetMouse.y));
      }
    });

    // Mobile controls
    const mobileState = { up: false, down: false, left: false, right: false, boost: false, pitchUp: false, yawLeft: false, yawRight: false };

    function setupMobileBtn(id, stateKey) {
      const btn = document.getElementById(id);
      if (!btn) return;
      btn.addEventListener('touchstart', (e) => { e.preventDefault(); mobileState[stateKey] = true; hasInteracted = true; instructions.classList.add('hidden'); });
      btn.addEventListener('touchend', (e) => { e.preventDefault(); mobileState[stateKey] = false; });
    }

    setupMobileBtn('up-btn', 'up');
    setupMobileBtn('down-btn', 'down');
    setupMobileBtn('left-btn', 'left');
    setupMobileBtn('right-btn', 'right');
    setupMobileBtn('boost-btn', 'boost');
    setupMobileBtn('pitch-up-btn', 'pitchUp');
    setupMobileBtn('yaw-left-btn', 'yawLeft');
    setupMobileBtn('yaw-right-btn', 'yawRight');

    // Collision detection helper
    function checkCollision(position, radius = 3) {
      for (const island of blocks) {
        if (!island.userData.blocks) continue;

        const islandPos = island.position;
        const toIsland = position.clone().sub(islandPos);

        // Quick bounds check
        if (toIsland.length() > 100) continue;

        for (const block of island.userData.blocks) {
          if (!block.userData.isCollider) continue;

          const blockWorldPos = block.position.clone().add(islandPos);
          const blockSize = block.userData.blockSize || 4;
          const halfSize = blockSize / 2 + radius;

          // AABB collision
          if (Math.abs(position.x - blockWorldPos.x) < halfSize &&
              Math.abs(position.y - blockWorldPos.y) < halfSize &&
              Math.abs(position.z - blockWorldPos.z) < halfSize) {
            return { hit: true, position: blockWorldPos, block: block };
          }
        }
      }
      return { hit: false };
    }

    // Animation loop
    function animate() {
      requestAnimationFrame(animate);
      const time = Date.now() * 0.001;

      // Smooth mouse interpolation
      mouse.x += (targetMouse.x - mouse.x) * MOUSE_SMOOTHING;
      mouse.y += (targetMouse.y - mouse.y) * MOUSE_SMOOTHING;

      // Update camera rotation from smoothed mouse
      euler.setFromQuaternion(camera.quaternion);
      euler.y = -mouse.x;
      euler.x = -mouse.y;

      // Mobile rotation
      if (mobileState.yawLeft) targetMouse.x -= 0.025;
      if (mobileState.yawRight) targetMouse.x += 0.025;
      if (mobileState.pitchUp) targetMouse.y -= 0.015;

      // Calculate roll based on strafing
      const strafingLeft = keys['KeyA'] || keys['ArrowLeft'] || mobileState.left;
      const strafingRight = keys['KeyD'] || keys['ArrowRight'] || mobileState.right;

      if (strafingLeft) {
        targetRoll = ROLL_AMOUNT;
      } else if (strafingRight) {
        targetRoll = -ROLL_AMOUNT;
      } else {
        targetRoll = 0;
      }

      currentRoll += (targetRoll - currentRoll) * ROLL_SMOOTHING;
      euler.z = currentRoll;

      camera.quaternion.setFromEuler(euler);

      // Movement physics
      const direction = new THREE.Vector3();
      camera.getWorldDirection(direction);

      const isBoosting = keys['ShiftLeft'] || keys['ShiftRight'] || mobileState.boost;
      const maxSpeed = isBoosting ? BOOST_MAX_SPEED : MAX_SPEED;

      // Forward/backward thrust
      if (keys['KeyW'] || keys['ArrowUp'] || mobileState.up) {
        targetSpeed = maxSpeed;
      } else if (keys['KeyS'] || keys['ArrowDown'] || mobileState.down) {
        targetSpeed = -maxSpeed * 0.4;
      } else {
        targetSpeed = 0;
      }

      // Smooth speed changes
      const accel = targetSpeed !== 0 ? ACCELERATION : ACCELERATION * 0.5;
      currentSpeed += (targetSpeed - currentSpeed) * accel;

      // Apply velocity
      velocity.copy(direction).multiplyScalar(currentSpeed);

      // Strafe movement
      const right = new THREE.Vector3();
      right.crossVectors(direction, camera.up).normalize();

      if (strafingLeft) {
        velocity.addScaledVector(right, -STRAFE_SPEED * (1 + Math.abs(currentSpeed) * 0.5));
      }
      if (strafingRight) {
        velocity.addScaledVector(right, STRAFE_SPEED * (1 + Math.abs(currentSpeed) * 0.5));
      }

      // Apply drag
      velocity.multiplyScalar(DRAG);

      // Store old position for collision
      const oldPosition = camera.position.clone();

      // Move camera
      camera.position.add(velocity);

      // Collision detection
      const collision = checkCollision(camera.position);
      if (collision.hit) {
        camera.position.copy(oldPosition);

        // Spawn particles at collision point
        const impactColor = collision.block.material?.color?.getHex() || 0xffffff;
        spawnCollisionParticles(collision.position, impactColor, 12);

        // Trigger collision effects
        const impactForce = velocity.length();
        if (impactForce > 0.1) {
          triggerCollision(Math.min(impactForce, 1.5));
        }
      }

      // Camera shake
      if (shakeIntensity > 0.01) {
        shakeOffset.set(
          (Math.random() - 0.5) * shakeIntensity,
          (Math.random() - 0.5) * shakeIntensity,
          (Math.random() - 0.5) * shakeIntensity * 0.5
        );
        camera.position.add(shakeOffset);
        shakeIntensity *= shakeDecay;
      }

      // Update speed display
      speedVal.textContent = Math.abs(currentSpeed * 55).toFixed(0);

      // Update blocks/islands (gentle floating)
      blocks.forEach(block => {
        if (block.userData.isDecor) {
          // Decorative items rotate more
          if (block.userData.rotSpeed) {
            block.rotation.x += block.userData.rotSpeed.x;
            block.rotation.y += block.userData.rotSpeed.y;
            block.rotation.z += block.userData.rotSpeed.z;
          }
          block.position.y = block.userData.originalY + Math.sin(time * block.userData.bobSpeed + block.userData.bobOffset) * 3;
        } else if (block.userData.bobSpeed) {
          // Islands bob gently
          block.position.y = block.userData.originalY + Math.sin(time * block.userData.bobSpeed + block.userData.bobOffset) * 4;
          if (block.userData.rotSpeed) {
            block.rotation.y += block.userData.rotSpeed;
          }
        }
      });

      // Move lights with camera
      redLight.position.copy(camera.position).add(new THREE.Vector3(-40, 15, -40));
      greenLight.position.copy(camera.position).add(new THREE.Vector3(40, -15, 40));

      // Spawn trail when moving
      if (Math.abs(currentSpeed) > 0.15) {
        const trailRate = 0.2 + Math.abs(currentSpeed) * 0.15;
        if (Math.random() < trailRate) spawnTrailParticle();
      }

      // Update trail particles
      for (let i = trailParticles.length - 1; i >= 0; i--) {
        const p = trailParticles[i];
        p.userData.life -= p.userData.decay;
        p.material.opacity = p.userData.life;
        p.scale.setScalar(p.userData.life);

        if (p.userData.life <= 0) {
          trailGroup.remove(p);
          trailParticles.splice(i, 1);
        }
      }

      // Update collision particles
      for (let i = collisionParticles.length - 1; i >= 0; i--) {
        const p = collisionParticles[i];
        p.position.add(p.velocity);
        p.velocity.multiplyScalar(0.95);
        p.velocity.y -= 0.02; // Gravity
        p.rotation.x += p.rotVel.x;
        p.rotation.y += p.rotVel.y;
        p.rotation.z += p.rotVel.z;
        p.userData.life -= p.userData.decay;
        p.material.opacity = p.userData.life;

        if (p.userData.life <= 0) {
          collisionGroup.remove(p);
          collisionParticles.splice(i, 1);
        }
      }

      // Engine glow pulse - more responsive to speed
      const speedFactor = Math.abs(currentSpeed) / MAX_SPEED;
      const pulse = 0.4 + speedFactor * 0.6 + Math.sin(time * 12) * 0.1 * (1 + speedFactor);
      const boostGlow = isBoosting ? 1.3 : 1;
      engineL.scale.setScalar(pulse * boostGlow);
      engineR.scale.setScalar(pulse * boostGlow);

      // Change engine color when boosting
      if (isBoosting) {
        engineL.material.color.setHex(0xff6600);
        engineR.material.color.setHex(0xff6600);
      } else {
        engineL.material.color.setHex(0x00ffff);
        engineR.material.color.setHex(0x00ffff);
      }

      // Ship tilt based on movement - smoother
      const tiltTarget = strafingLeft ? 0.35 : strafingRight ? -0.35 : 0;
      shipGroup.rotation.z = THREE.MathUtils.lerp(shipGroup.rotation.z, tiltTarget, 0.08);

      // Subtle pitch based on speed
      const pitchTarget = currentSpeed * 0.03;
      shipGroup.rotation.x = THREE.MathUtils.lerp(shipGroup.rotation.x, pitchTarget, 0.05);

      renderer.render(scene, camera);
    }

    animate();

    // Resize
    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });
  </script>
<script src="/sloppy-header/sloppy-bar.js"></script>
</body>
</html>
