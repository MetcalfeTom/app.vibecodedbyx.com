<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ðŸ§± Minecraft 3D - Block Building Game</title>
    <link rel="icon" href="https://emojicdn.elk.sh/ðŸ§±">

    <!-- Open Graph Meta Tags -->
    <meta property="og:title" content="ðŸ§± Minecraft 3D - Block Building Game">
    <meta property="og:description" content="Build and explore in 3D! Place blocks, mine terrain, and create your world in this Minecraft-inspired browser game.">
    <meta property="og:url" content="https://sloppy.live/minecraft">
    <meta property="og:image" content="https://sloppy.live/minecraft/minecraft-preview.png">
    <meta property="og:type" content="website">

    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Arial', sans-serif;
            background: linear-gradient(135deg, #87CEEB 0%, #98FB98 100%);
            overflow: hidden;
            user-select: none;
        }

        #gameContainer {
            width: 100vw;
            height: 100vh;
            position: relative;
        }

        #ui {
            position: absolute;
            top: 20px;
            left: 20px;
            color: white;
            font-size: 16px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
            z-index: 100;
            pointer-events: none;
        }

        #controls {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 15px;
            border-radius: 10px;
            font-size: 14px;
            max-width: 250px;
            z-index: 100;
        }

        #inventory {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 5px;
            z-index: 100;
        }

        .inventory-slot {
            width: 60px;
            height: 60px;
            background: rgba(0, 0, 0, 0.8);
            border: 3px solid #666;
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.2s ease;
            font-size: 24px;
            color: white;
        }

        .inventory-slot:hover {
            border-color: #fff;
            background: rgba(0, 0, 0, 0.9);
        }

        .inventory-slot.active {
            border-color: #4CAF50;
            background: rgba(76, 175, 80, 0.3);
            box-shadow: 0 0 10px rgba(76, 175, 80, 0.5);
        }

        #crosshair {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 20px;
            height: 20px;
            z-index: 100;
            pointer-events: none;
        }

        #crosshair::before,
        #crosshair::after {
            content: '';
            position: absolute;
            background: white;
            box-shadow: 0 0 2px black;
        }

        #crosshair::before {
            width: 2px;
            height: 20px;
            left: 9px;
            top: 0;
        }

        #crosshair::after {
            width: 20px;
            height: 2px;
            left: 0;
            top: 9px;
        }

        #loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-size: 24px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
            z-index: 200;
        }

        .backlink {
            position: absolute;
            bottom: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 10px;
            border-radius: 5px;
            font-size: 12px;
            z-index: 100;
        }

        .backlink a {
            color: #87CEEB;
            text-decoration: none;
        }

        .color-toggle {
            position: absolute;
            top: 20px;
            left: 300px;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            border: none;
            padding: 10px 15px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 14px;
            font-weight: bold;
            transition: all 0.3s ease;
            z-index: 100;
        }

        .color-toggle:hover {
            background: rgba(0, 0, 0, 0.9);
            transform: translateY(-2px);
        }

        .inverted {
            filter: invert(1) hue-rotate(180deg);
        }

        .inverted .color-toggle {
            filter: invert(1) hue-rotate(180deg);
        }

        @media (max-width: 768px) {
            #controls {
                position: fixed;
                top: 10px;
                right: 10px;
                font-size: 12px;
                padding: 10px;
                max-width: 200px;
            }

            #inventory {
                bottom: 10px;
                gap: 3px;
            }

            .inventory-slot {
                width: 50px;
                height: 50px;
                font-size: 20px;
            }

            .color-toggle {
                top: 10px;
                left: 10px;
                padding: 8px 12px;
                font-size: 12px;
            }
        }
    </style>
</head>
<body>
    <div id="gameContainer">
        <div id="loading">ðŸ§± Loading Minecraft World...</div>

        <div id="ui">
            <div>Position: <span id="position">0, 0, 0</span></div>
            <div>Blocks Placed: <span id="blocksPlaced">0</span></div>
            <div>Blocks Mined: <span id="blocksMined">0</span></div>
        </div>

        <button class="color-toggle" onclick="toggleColorInversion()">ðŸŽ¨ Invert Colors</button>

        <div id="controls">
            <div><strong>ðŸŽ® Controls:</strong></div>
            <div>WASD - Move</div>
            <div>Mouse - Look Around</div>
            <div>Left Click - Mine Block</div>
            <div>Right Click - Place Block</div>
            <div>Space - Jump</div>
            <div>Shift - Crouch</div>
            <div>1-6 - Select Block Type</div>
            <div>I - Toggle Color Inversion</div>
        </div>

        <div id="inventory">
            <div class="inventory-slot active" data-block="grass" title="Grass">ðŸŸ©</div>
            <div class="inventory-slot" data-block="stone" title="Stone">â¬œ</div>
            <div class="inventory-slot" data-block="wood" title="Wood">ðŸŸ«</div>
            <div class="inventory-slot" data-block="leaves" title="Leaves">ðŸŸ¢</div>
            <div class="inventory-slot" data-block="sand" title="Sand">ðŸŸ¨</div>
            <div class="inventory-slot" data-block="water" title="Water">ðŸŸ¦</div>
        </div>

        <div id="crosshair"></div>

        <div class="backlink">
            ðŸŽ¬ Built live at <a href="https://sloppy.live" target="_blank">sloppy.live</a> | <a href="https://sloppy.live/overview" style="color:#4ecdc4;text-decoration:none">ðŸŽ¨ View All Apps</a>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // Game variables
        let scene, camera, renderer, raycaster, mouse;
        let world = {};
        let player = {
            position: new THREE.Vector3(0, 20, 0),
            velocity: new THREE.Vector3(0, 0, 0),
            onGround: false,
            speed: 0.1,
            jumpPower: 0.3
        };
        let selectedBlock = 'grass';
        let blocksPlaced = 0;
        let blocksMined = 0;

        // Controls
        const keys = {};
        let mouseX = 0, mouseY = 0;
        let pitch = 0, yaw = 0;
        let isInverted = false;

        // Block types and materials
        const blockTypes = {
            grass: { color: 0x4CAF50, emoji: 'ðŸŸ©' },
            stone: { color: 0x888888, emoji: 'â¬œ' },
            wood: { color: 0x8B4513, emoji: 'ðŸŸ«' },
            leaves: { color: 0x228B22, emoji: 'ðŸŸ¢' },
            sand: { color: 0xF4E4BC, emoji: 'ðŸŸ¨' },
            water: { color: 0x1E90FF, emoji: 'ðŸŸ¦', transparent: true, opacity: 0.7 }
        };

        // Initialize the game
        function init() {
            // Create scene
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x87CEEB);
            scene.fog = new THREE.Fog(0x87CEEB, 50, 200);

            // Create camera
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.copy(player.position);

            // Create renderer
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            document.getElementById('gameContainer').appendChild(renderer.domElement);

            // Create raycaster for block interaction
            raycaster = new THREE.Raycaster();
            mouse = new THREE.Vector2();

            // Create lighting
            const ambientLight = new THREE.AmbientLight(0x404040, 0.6);
            scene.add(ambientLight);

            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(50, 100, 50);
            directionalLight.castShadow = true;
            directionalLight.shadow.mapSize.width = 2048;
            directionalLight.shadow.mapSize.height = 2048;
            directionalLight.shadow.camera.near = 0.5;
            directionalLight.shadow.camera.far = 500;
            directionalLight.shadow.camera.left = -100;
            directionalLight.shadow.camera.right = 100;
            directionalLight.shadow.camera.top = 100;
            directionalLight.shadow.camera.bottom = -100;
            scene.add(directionalLight);

            // Generate initial terrain
            generateTerrain();

            // Set up event listeners
            setupEventListeners();

            // Hide loading screen
            document.getElementById('loading').style.display = 'none';

            // Start game loop
            animate();
        }

        // Generate terrain
        function generateTerrain() {
            const size = 20;
            const height = 5;

            for (let x = -size; x <= size; x++) {
                for (let z = -size; z <= size; z++) {
                    // Generate height using noise-like function
                    const terrainHeight = Math.floor(
                        Math.sin(x * 0.1) * Math.cos(z * 0.1) * 3 +
                        Math.sin(x * 0.05) * Math.cos(z * 0.05) * 5 +
                        height
                    );

                    // Place blocks from bottom to terrain height
                    for (let y = 0; y <= terrainHeight; y++) {
                        let blockType = 'stone';

                        if (y === terrainHeight) {
                            blockType = 'grass';
                        } else if (y > terrainHeight - 3) {
                            blockType = Math.random() > 0.7 ? 'stone' : 'grass';
                        }

                        placeBlock(x, y, z, blockType, false);
                    }

                    // Add some trees
                    if (Math.random() > 0.95 && terrainHeight > 3) {
                        // Tree trunk
                        for (let y = terrainHeight + 1; y <= terrainHeight + 4; y++) {
                            placeBlock(x, y, z, 'wood', false);
                        }
                        // Tree leaves
                        for (let dx = -1; dx <= 1; dx++) {
                            for (let dz = -1; dz <= 1; dz++) {
                                for (let dy = 0; dy <= 2; dy++) {
                                    if (Math.random() > 0.3) {
                                        placeBlock(x + dx, terrainHeight + 4 + dy, z + dz, 'leaves', false);
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }

        // Place a block
        function placeBlock(x, y, z, type = selectedBlock, updateStats = true) {
            const key = `${x},${y},${z}`;

            // Remove existing block
            if (world[key]) {
                scene.remove(world[key]);
            }

            // Create new block
            const geometry = new THREE.BoxGeometry(1, 1, 1);
            const blockData = blockTypes[type];

            let material;
            if (blockData.transparent) {
                material = new THREE.MeshLambertMaterial({
                    color: blockData.color,
                    transparent: true,
                    opacity: blockData.opacity
                });
            } else {
                material = new THREE.MeshLambertMaterial({ color: blockData.color });
            }

            const block = new THREE.Mesh(geometry, material);
            block.position.set(x, y, z);
            block.castShadow = true;
            block.receiveShadow = true;
            block.userData = { type: type, x: x, y: y, z: z };

            scene.add(block);
            world[key] = block;

            if (updateStats) {
                blocksPlaced++;
                document.getElementById('blocksPlaced').textContent = blocksPlaced;
            }
        }

        // Remove a block
        function removeBlock(x, y, z) {
            const key = `${x},${y},${z}`;
            if (world[key]) {
                scene.remove(world[key]);
                delete world[key];
                blocksMined++;
                document.getElementById('blocksMined').textContent = blocksMined;
            }
        }

        // Check if position is solid (has a block)
        function isSolid(x, y, z) {
            const key = `${Math.floor(x)},${Math.floor(y)},${Math.floor(z)}`;
            return world[key] !== undefined;
        }

        // Handle mouse interaction
        function onMouseClick(event) {
            if (event.button === 0) { // Left click - mine
                handleBlockInteraction(true);
            } else if (event.button === 2) { // Right click - place
                handleBlockInteraction(false);
            }
        }

        function handleBlockInteraction(isMining) {
            raycaster.setFromCamera(new THREE.Vector2(0, 0), camera);
            const intersects = raycaster.intersectObjects(Object.values(world));

            if (intersects.length > 0) {
                const intersect = intersects[0];
                const block = intersect.object;

                if (isMining) {
                    // Mine block
                    removeBlock(block.userData.x, block.userData.y, block.userData.z);
                } else {
                    // Place block adjacent to clicked face
                    const face = intersect.face;
                    const normal = face.normal.clone();
                    normal.multiplyScalar(1);
                    normal.add(intersect.point);
                    normal.add(intersect.object.position);
                    normal.floor();

                    // Don't place block inside player
                    const playerPos = player.position.clone().floor();
                    if (normal.x !== playerPos.x || normal.y !== playerPos.y || normal.z !== playerPos.z) {
                        placeBlock(normal.x, normal.y, normal.z, selectedBlock);
                    }
                }
            }
        }

        // Set up event listeners
        function setupEventListeners() {
            // Mouse events
            document.addEventListener('click', onMouseClick);
            document.addEventListener('contextmenu', (e) => e.preventDefault());

            document.addEventListener('mousemove', (event) => {
                if (document.pointerLockElement) {
                    mouseX += event.movementX * 0.002;
                    mouseY -= event.movementY * 0.002;
                    mouseY = Math.max(-Math.PI/2, Math.min(Math.PI/2, mouseY));
                }
            });

            // Pointer lock
            document.addEventListener('click', () => {
                if (!document.pointerLockElement) {
                    renderer.domElement.requestPointerLock();
                }
            });

            // Keyboard events
            document.addEventListener('keydown', (event) => {
                keys[event.code] = true;

                // Number keys for inventory
                if (event.code >= 'Digit1' && event.code <= 'Digit6') {
                    const index = parseInt(event.code.slice(-1)) - 1;
                    const slots = document.querySelectorAll('.inventory-slot');
                    if (slots[index]) {
                        selectInventorySlot(index);
                    }
                }
            });

            document.addEventListener('keyup', (event) => {
                keys[event.code] = false;
            });

            // Color inversion toggle with 'I' key
            document.addEventListener('keydown', (event) => {
                if (event.code === 'KeyI') {
                    toggleColorInversion();
                }
            });

            // Inventory clicks
            document.querySelectorAll('.inventory-slot').forEach((slot, index) => {
                slot.addEventListener('click', () => selectInventorySlot(index));
            });

            // Window resize
            window.addEventListener('resize', onWindowResize);
        }

        function selectInventorySlot(index) {
            document.querySelectorAll('.inventory-slot').forEach(slot => {
                slot.classList.remove('active');
            });

            const slots = document.querySelectorAll('.inventory-slot');
            slots[index].classList.add('active');
            selectedBlock = slots[index].dataset.block;
        }

        // Handle window resize
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        // Update player physics
        function updatePlayer() {
            // Handle input
            const moveVector = new THREE.Vector3();

            if (keys['KeyW']) moveVector.z -= 1;
            if (keys['KeyS']) moveVector.z += 1;
            if (keys['KeyA']) moveVector.x -= 1;
            if (keys['KeyD']) moveVector.x += 1;

            // Apply camera rotation to movement
            moveVector.applyAxisAngle(new THREE.Vector3(0, 1, 0), mouseX);
            moveVector.multiplyScalar(player.speed);

            // Apply movement
            player.velocity.x = moveVector.x;
            player.velocity.z = moveVector.z;

            // Jumping
            if (keys['Space'] && player.onGround) {
                player.velocity.y = player.jumpPower;
                player.onGround = false;
            }

            // Crouching
            if (keys['ShiftLeft']) {
                player.velocity.multiplyScalar(0.5);
            }

            // Apply gravity
            player.velocity.y -= 0.015;

            // Check collisions and update position
            const newPosition = player.position.clone().add(player.velocity);

            // Ground collision
            if (newPosition.y <= 0 || isSolid(newPosition.x, newPosition.y - 1, newPosition.z)) {
                if (player.velocity.y <= 0) {
                    player.onGround = true;
                    player.velocity.y = 0;
                    newPosition.y = Math.max(1, Math.floor(newPosition.y) + 1);
                }
            } else {
                player.onGround = false;
            }

            // Wall collisions
            if (!isSolid(newPosition.x, newPosition.y, player.position.z) &&
                !isSolid(newPosition.x, newPosition.y + 1, player.position.z)) {
                player.position.x = newPosition.x;
            }

            if (!isSolid(player.position.x, newPosition.y, newPosition.z) &&
                !isSolid(player.position.x, newPosition.y + 1, newPosition.z)) {
                player.position.z = newPosition.z;
            }

            player.position.y = newPosition.y;

            // Update camera
            camera.position.copy(player.position);
            camera.position.y += 1.6; // Eye height
            camera.rotation.x = mouseY;
            camera.rotation.y = mouseX;

            // Update UI
            const pos = player.position;
            document.getElementById('position').textContent =
                `${Math.floor(pos.x)}, ${Math.floor(pos.y)}, ${Math.floor(pos.z)}`;
        }

        // Animation loop
        function animate() {
            requestAnimationFrame(animate);
            updatePlayer();
            renderer.render(scene, camera);
        }

        // Color inversion toggle
        function toggleColorInversion() {
            isInverted = !isInverted;
            const gameContainer = document.getElementById('gameContainer');
            const toggleBtn = document.querySelector('.color-toggle');

            if (isInverted) {
                gameContainer.classList.add('inverted');
                toggleBtn.textContent = 'ðŸŒˆ Normal Colors';
                toggleBtn.title = 'Switch back to normal colors';
            } else {
                gameContainer.classList.remove('inverted');
                toggleBtn.textContent = 'ðŸŽ¨ Invert Colors';
                toggleBtn.title = 'Invert all colors for a psychedelic effect';
            }
        }

        // Start the game
        init();
    </script>
</body>
</html>