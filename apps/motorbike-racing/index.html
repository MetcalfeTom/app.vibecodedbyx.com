<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <meta name="description" content="3D Motorbike Racing Simulator - Feel the thrill of high-speed racing!" />
  <meta property="og:title" content="3D Motorbike Racing Sim" />
  <meta property="og:description" content="Experience high-speed 3D motorbike racing with realistic physics and stunning graphics!" />
  <meta property="og:url" content="https://app.vibecodedbyx.com/motorbike-racing/" />
  <meta property="og:type" content="website" />
  <meta property="og:image" content="https://app.vibecodedbyx.com/motorbike-racing/og.svg" />
  <meta name="twitter:card" content="summary_large_image" />
  <meta name="twitter:title" content="3D Motorbike Racing Sim" />
  <meta name="twitter:description" content="Experience high-speed 3D motorbike racing with realistic physics!" />
  <meta name="twitter:image" content="https://app.vibecodedbyx.com/motorbike-racing/og.svg" />
  <title>3D Motorbike Racing</title>
  <link rel="icon" href="data:image/svg+xml;base64,PHN2ZyB4bWxucz0naHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmcnIHZpZXdCb3g9JzAgMCAxMDAgMTAwJz48dGV4dCB5PScuOWVtJyBmb250LXNpemU9JzkwJz7wn42aPDogdGV4dD48L3N2Zz4=" />
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      background: linear-gradient(135deg, #1e3c72 0%, #2a5298 100%);
      font-family: 'Arial', sans-serif;
      overflow: hidden;
      user-select: none;
    }

    #gameContainer {
      position: relative;
      width: 100vw;
      height: 100vh;
    }

    #gameCanvas {
      display: block;
      width: 100%;
      height: 100%;
    }

    #ui {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
      z-index: 100;
    }

    #speedometer {
      position: absolute;
      bottom: 30px;
      right: 30px;
      width: 150px;
      height: 150px;
      border: 4px solid #fff;
      border-radius: 50%;
      background: rgba(0, 0, 0, 0.7);
      display: flex;
      align-items: center;
      justify-content: center;
      flex-direction: column;
      color: white;
      font-weight: bold;
    }

    #speed {
      font-size: 32px;
      color: #00ff00;
    }

    #speedLabel {
      font-size: 14px;
      color: #ccc;
    }

    #controls {
      position: absolute;
      top: 20px;
      left: 20px;
      background: rgba(0, 0, 0, 0.7);
      color: white;
      padding: 15px;
      border-radius: 10px;
      font-size: 14px;
      line-height: 1.6;
    }

    #raceInfo {
      position: absolute;
      top: 20px;
      right: 20px;
      background: rgba(0, 0, 0, 0.7);
      color: white;
      padding: 15px;
      border-radius: 10px;
      font-size: 16px;
      text-align: right;
    }

    #startScreen {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.8);
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      color: white;
      pointer-events: all;
      z-index: 200;
    }

    #title {
      font-size: 48px;
      font-weight: bold;
      margin-bottom: 20px;
      text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
      background: linear-gradient(45deg, #ff6b6b, #4ecdc4, #45b7d1);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
    }

    #subtitle {
      font-size: 20px;
      margin-bottom: 30px;
      color: #ccc;
    }

    #startButton {
      padding: 15px 30px;
      font-size: 20px;
      background: linear-gradient(45deg, #ff6b6b, #4ecdc4);
      color: white;
      border: none;
      border-radius: 25px;
      cursor: pointer;
      transition: transform 0.2s;
      font-weight: bold;
      text-transform: uppercase;
      letter-spacing: 1px;
    }

    #startButton:hover {
      transform: scale(1.05);
    }

    #lap {
      color: #00ff00;
      font-weight: bold;
    }

    #time {
      color: #ffff00;
    }

    .mobile-controls {
      position: absolute;
      bottom: 20px;
      left: 20px;
      display: none;
      gap: 10px;
    }

    .control-btn {
      width: 60px;
      height: 60px;
      background: rgba(255, 255, 255, 0.2);
      border: 2px solid white;
      border-radius: 50%;
      color: white;
      font-size: 18px;
      font-weight: bold;
      cursor: pointer;
      user-select: none;
      pointer-events: all;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .control-btn:active {
      background: rgba(255, 255, 255, 0.4);
    }

    @media (max-width: 768px) {
      .mobile-controls {
        display: flex;
      }

      #controls {
        display: none;
      }

      #title {
        font-size: 32px;
      }

      #speedometer {
        width: 120px;
        height: 120px;
        bottom: 20px;
        right: 20px;
      }

      #speed {
        font-size: 24px;
      }
    }

    a {
      position: absolute;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      color: rgba(255, 255, 255, 0.7);
      text-decoration: none;
      font-size: 14px;
      pointer-events: all;
    }

    a:hover {
      color: white;
    }
  </style>
  <script src="supabase-config.js"></script>
</head>
<body>
  <div id="gameContainer">
    <canvas id="gameCanvas"></canvas>

    <div id="startScreen">
      <div id="title">üèçÔ∏è MOTORBIKE RACING</div>
      <div id="subtitle">Experience the thrill of high-speed 3D racing!</div>
      <button id="startButton">START RACE</button>
    </div>

    <div id="ui">
      <div id="controls">
        <strong>Controls:</strong><br>
        W / ‚Üë - Accelerate<br>
        S / ‚Üì - Brake/Reverse<br>
        A / ‚Üê - Turn Left<br>
        D / ‚Üí - Turn Right<br>
        Space - Handbrake
      </div>

      <div id="raceInfo">
        <div>Lap: <span id="lap">1 / 3</span></div>
        <div>Time: <span id="time">00:00</span></div>
        <div>Best: <span id="bestTime">--:--</span></div>
      </div>

      <div id="speedometer">
        <div id="speed">0</div>
        <div id="speedLabel">KM/H</div>
      </div>

      <div class="mobile-controls">
        <div class="control-btn" id="leftBtn">L</div>
        <div class="control-btn" id="accelerateBtn">^</div>
        <div class="control-btn" id="brakeBtn">v</div>
        <div class="control-btn" id="rightBtn">R</div>
      </div>
    </div>

    <a href="https://www.vibecodedbyx.com">Watch the livestream</a>
  </div>

  <script>
    // Game variables
    let scene, camera, renderer, motorbike, track;
    let gameStarted = false;
    let gameTime = 0;
    let currentLap = 1;
    let totalLaps = 3;
    let bestTime = null;
    let lastCheckpoint = 0;
    let checkpointsPassed = 0;

    // Physics variables
    let velocity = 0;
    let acceleration = 0;
    let rotation = 0;
    let maxSpeed = 200;
    let accelerationRate = 0.8;
    let decelerationRate = 0.95;
    let turnSpeed = 0.02;

    // Controls
    let keys = {};
    let mobileControls = {
      left: false,
      right: false,
      accelerate: false,
      brake: false
    };

    // Initialize the game
    function init() {
      // Create scene
      scene = new THREE.Scene();
      scene.fog = new THREE.Fog(0x87CEEB, 100, 1000);

      // Create camera
      camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 2000);

      // Create renderer
      const canvas = document.getElementById('gameCanvas');
      renderer = new THREE.WebGLRenderer({ canvas: canvas, antialias: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.shadowMap.enabled = true;
      renderer.shadowMap.type = THREE.PCFSoftShadowMap;
      renderer.setClearColor(0x87CEEB);

      // Create lighting
      createLighting();

      // Create environment
      createEnvironment();

      // Create track
      createTrack();

      // Create motorbike
      createMotorbike();

      // Setup controls
      setupControls();

      // Setup mobile controls
      setupMobileControls();

      // Start render loop
      animate();
    }

    function createLighting() {
      // Ambient light
      const ambientLight = new THREE.AmbientLight(0x404040, 0.6);
      scene.add(ambientLight);

      // Directional light (sun)
      const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
      directionalLight.position.set(100, 100, 50);
      directionalLight.castShadow = true;
      directionalLight.shadow.mapSize.width = 2048;
      directionalLight.shadow.mapSize.height = 2048;
      directionalLight.shadow.camera.near = 0.5;
      directionalLight.shadow.camera.far = 500;
      directionalLight.shadow.camera.left = -100;
      directionalLight.shadow.camera.right = 100;
      directionalLight.shadow.camera.top = 100;
      directionalLight.shadow.camera.bottom = -100;
      scene.add(directionalLight);
    }

    function createEnvironment() {
      // Sky
      const skyGeometry = new THREE.SphereGeometry(1000, 32, 32);
      const skyMaterial = new THREE.MeshBasicMaterial({
        color: 0x87CEEB,
        side: THREE.BackSide
      });
      const sky = new THREE.Mesh(skyGeometry, skyMaterial);
      scene.add(sky);

      // Ground
      const groundGeometry = new THREE.PlaneGeometry(2000, 2000);
      const groundMaterial = new THREE.MeshLambertMaterial({ color: 0x228B22 });
      const ground = new THREE.Mesh(groundGeometry, groundMaterial);
      ground.rotation.x = -Math.PI / 2;
      ground.receiveShadow = true;
      scene.add(ground);

      // Add some trees and buildings for atmosphere
      createScenery();
    }

    function createScenery() {
      // Trees
      for (let i = 0; i < 50; i++) {
        const treeGroup = new THREE.Group();

        // Tree trunk
        const trunkGeometry = new THREE.CylinderGeometry(2, 3, 15);
        const trunkMaterial = new THREE.MeshLambertMaterial({ color: 0x8B4513 });
        const trunk = new THREE.Mesh(trunkGeometry, trunkMaterial);
        trunk.position.y = 7.5;
        treeGroup.add(trunk);

        // Tree crown
        const crownGeometry = new THREE.SphereGeometry(8);
        const crownMaterial = new THREE.MeshLambertMaterial({ color: 0x228B22 });
        const crown = new THREE.Mesh(crownGeometry, crownMaterial);
        crown.position.y = 20;
        treeGroup.add(crown);

        // Random position around track
        const angle = Math.random() * Math.PI * 2;
        const distance = 150 + Math.random() * 300;
        treeGroup.position.x = Math.cos(angle) * distance;
        treeGroup.position.z = Math.sin(angle) * distance;

        treeGroup.castShadow = true;
        scene.add(treeGroup);
      }

      // Buildings
      for (let i = 0; i < 20; i++) {
        const buildingGeometry = new THREE.BoxGeometry(
          10 + Math.random() * 20,
          20 + Math.random() * 30,
          10 + Math.random() * 20
        );
        const buildingMaterial = new THREE.MeshLambertMaterial({
          color: new THREE.Color().setHSL(Math.random(), 0.3, 0.7)
        });
        const building = new THREE.Mesh(buildingGeometry, buildingMaterial);

        const angle = Math.random() * Math.PI * 2;
        const distance = 200 + Math.random() * 400;
        building.position.x = Math.cos(angle) * distance;
        building.position.z = Math.sin(angle) * distance;
        building.position.y = building.geometry.parameters.height / 2;

        building.castShadow = true;
        scene.add(building);
      }
    }

    function createTrack() {
      track = new THREE.Group();

      // Create a circular track
      const trackRadius = 100;
      const trackWidth = 20;
      const segments = 64;

      // Track surface
      const trackGeometry = new THREE.RingGeometry(trackRadius - trackWidth/2, trackRadius + trackWidth/2, segments);
      const trackMaterial = new THREE.MeshLambertMaterial({ color: 0x333333 });
      const trackSurface = new THREE.Mesh(trackGeometry, trackMaterial);
      trackSurface.rotation.x = -Math.PI / 2;
      trackSurface.position.y = 0.1;
      trackSurface.receiveShadow = true;
      track.add(trackSurface);

      // Track barriers
      for (let i = 0; i <= segments; i++) {
        const angle = (i / segments) * Math.PI * 2;

        // Outer barrier
        const outerBarrierGeometry = new THREE.BoxGeometry(2, 3, 2);
        const barrierMaterial = new THREE.MeshLambertMaterial({ color: 0xff0000 });
        const outerBarrier = new THREE.Mesh(outerBarrierGeometry, barrierMaterial);
        outerBarrier.position.x = Math.cos(angle) * (trackRadius + trackWidth/2 + 3);
        outerBarrier.position.z = Math.sin(angle) * (trackRadius + trackWidth/2 + 3);
        outerBarrier.position.y = 1.5;
        outerBarrier.castShadow = true;
        track.add(outerBarrier);

        // Inner barrier (every 4th segment)
        if (i % 4 === 0) {
          const innerBarrier = outerBarrier.clone();
          innerBarrier.position.x = Math.cos(angle) * (trackRadius - trackWidth/2 - 3);
          innerBarrier.position.z = Math.sin(angle) * (trackRadius - trackWidth/2 - 3);
          track.add(innerBarrier);
        }
      }

      // Checkpoints
      for (let i = 0; i < 4; i++) {
        const angle = (i / 4) * Math.PI * 2;
        const checkpointGeometry = new THREE.BoxGeometry(1, 8, trackWidth * 1.5);
        const checkpointMaterial = new THREE.MeshLambertMaterial({
          color: i === 0 ? 0x00ff00 : 0xffff00,
          transparent: true,
          opacity: 0.7
        });
        const checkpoint = new THREE.Mesh(checkpointGeometry, checkpointMaterial);
        checkpoint.position.x = Math.cos(angle) * trackRadius;
        checkpoint.position.z = Math.sin(angle) * trackRadius;
        checkpoint.position.y = 4;
        checkpoint.userData = { id: i, isCheckpoint: true };
        track.add(checkpoint);
      }

      scene.add(track);
    }

    function createMotorbike() {
      motorbike = new THREE.Group();

      // Main body
      const bodyGeometry = new THREE.BoxGeometry(6, 2, 2);
      const bodyMaterial = new THREE.MeshLambertMaterial({ color: 0xff0000 });
      const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
      body.position.y = 3;
      body.castShadow = true;
      motorbike.add(body);

      // Seat
      const seatGeometry = new THREE.BoxGeometry(2, 1, 1.5);
      const seatMaterial = new THREE.MeshLambertMaterial({ color: 0x000000 });
      const seat = new THREE.Mesh(seatGeometry, seatMaterial);
      seat.position.y = 4;
      seat.position.x = -1;
      motorbike.add(seat);

      // Handlebars
      const handlebarGeometry = new THREE.CylinderGeometry(0.1, 0.1, 3);
      const handlebarMaterial = new THREE.MeshLambertMaterial({ color: 0x333333 });
      const handlebar = new THREE.Mesh(handlebarGeometry, handlebarMaterial);
      handlebar.rotation.z = Math.PI / 2;
      handlebar.position.y = 4.5;
      handlebar.position.x = 2;
      motorbike.add(handlebar);

      // Wheels
      const wheelGeometry = new THREE.CylinderGeometry(1.5, 1.5, 0.5);
      const wheelMaterial = new THREE.MeshLambertMaterial({ color: 0x222222 });

      // Front wheel
      const frontWheel = new THREE.Mesh(wheelGeometry, wheelMaterial);
      frontWheel.rotation.z = Math.PI / 2;
      frontWheel.position.x = 3;
      frontWheel.position.y = 1.5;
      frontWheel.castShadow = true;
      motorbike.add(frontWheel);

      // Rear wheel
      const rearWheel = new THREE.Mesh(wheelGeometry, wheelMaterial);
      rearWheel.rotation.z = Math.PI / 2;
      rearWheel.position.x = -2;
      rearWheel.position.y = 1.5;
      rearWheel.castShadow = true;
      motorbike.add(rearWheel);

      // Position motorbike on track
      motorbike.position.set(100, 0, 0);
      motorbike.userData = { wheels: [frontWheel, rearWheel] };

      scene.add(motorbike);

      // Position camera behind motorbike
      camera.position.set(110, 8, 0);
      camera.lookAt(motorbike.position);
    }

    function setupControls() {
      // Keyboard controls
      document.addEventListener('keydown', (event) => {
        keys[event.code] = true;
      });

      document.addEventListener('keyup', (event) => {
        keys[event.code] = false;
      });

      // Start button
      document.getElementById('startButton').addEventListener('click', startGame);
    }

    function setupMobileControls() {
      const leftBtn = document.getElementById('leftBtn');
      const rightBtn = document.getElementById('rightBtn');
      const accelerateBtn = document.getElementById('accelerateBtn');
      const brakeBtn = document.getElementById('brakeBtn');

      // Touch events for mobile controls
      leftBtn.addEventListener('touchstart', () => mobileControls.left = true);
      leftBtn.addEventListener('touchend', () => mobileControls.left = false);
      leftBtn.addEventListener('mousedown', () => mobileControls.left = true);
      leftBtn.addEventListener('mouseup', () => mobileControls.left = false);

      rightBtn.addEventListener('touchstart', () => mobileControls.right = true);
      rightBtn.addEventListener('touchend', () => mobileControls.right = false);
      rightBtn.addEventListener('mousedown', () => mobileControls.right = true);
      rightBtn.addEventListener('mouseup', () => mobileControls.right = false);

      accelerateBtn.addEventListener('touchstart', () => mobileControls.accelerate = true);
      accelerateBtn.addEventListener('touchend', () => mobileControls.accelerate = false);
      accelerateBtn.addEventListener('mousedown', () => mobileControls.accelerate = true);
      accelerateBtn.addEventListener('mouseup', () => mobileControls.accelerate = false);

      brakeBtn.addEventListener('touchstart', () => mobileControls.brake = true);
      brakeBtn.addEventListener('touchend', () => mobileControls.brake = false);
      brakeBtn.addEventListener('mousedown', () => mobileControls.brake = true);
      brakeBtn.addEventListener('mouseup', () => mobileControls.brake = false);
    }

    function startGame() {
      document.getElementById('startScreen').style.display = 'none';
      gameStarted = true;
      gameTime = 0;
    }

    function updateControls() {
      if (!gameStarted) return;

      const isAccelerating = keys['KeyW'] || keys['ArrowUp'] || mobileControls.accelerate;
      const isBraking = keys['KeyS'] || keys['ArrowDown'] || mobileControls.brake;
      const isTurningLeft = keys['KeyA'] || keys['ArrowLeft'] || mobileControls.left;
      const isTurningRight = keys['KeyD'] || keys['ArrowRight'] || mobileControls.right;
      const isHandbrake = keys['Space'];

      // Acceleration
      if (isAccelerating) {
        acceleration = accelerationRate;
      } else if (isBraking) {
        acceleration = -accelerationRate * 1.5;
      } else {
        acceleration = 0;
      }

      // Apply acceleration
      velocity += acceleration;

      // Apply deceleration/friction
      velocity *= decelerationRate;

      // Clamp velocity
      velocity = Math.max(-maxSpeed * 0.5, Math.min(maxSpeed, velocity));

      // Handbrake
      if (isHandbrake) {
        velocity *= 0.9;
      }

      // Turning (only when moving)
      if (Math.abs(velocity) > 1) {
        if (isTurningLeft) {
          rotation -= turnSpeed * (velocity / maxSpeed);
        }
        if (isTurningRight) {
          rotation += turnSpeed * (velocity / maxSpeed);
        }
      }

      // Update motorbike position and rotation
      motorbike.rotation.y = rotation;

      const moveX = Math.cos(rotation) * velocity * 0.1;
      const moveZ = Math.sin(rotation) * velocity * 0.1;

      motorbike.position.x += moveX;
      motorbike.position.z += moveZ;

      // Animate wheels
      if (motorbike.userData.wheels) {
        const wheelRotation = velocity * 0.01;
        motorbike.userData.wheels.forEach(wheel => {
          wheel.rotation.x += wheelRotation;
        });
      }

      // Keep motorbike on track (basic collision)
      const distanceFromCenter = Math.sqrt(
        motorbike.position.x * motorbike.position.x +
        motorbike.position.z * motorbike.position.z
      );

      if (distanceFromCenter > 120 || distanceFromCenter < 80) {
        velocity *= 0.8; // Slow down when off track
      }

      // Update camera to follow motorbike
      const cameraDistance = 15;
      const cameraHeight = 8;
      const targetX = motorbike.position.x - Math.cos(rotation) * cameraDistance;
      const targetZ = motorbike.position.z - Math.sin(rotation) * cameraDistance;

      camera.position.x += (targetX - camera.position.x) * 0.1;
      camera.position.z += (targetZ - camera.position.z) * 0.1;
      camera.position.y = motorbike.position.y + cameraHeight;

      camera.lookAt(motorbike.position);
    }

    function updateUI() {
      if (!gameStarted) return;

      // Update speedometer
      const speed = Math.abs(velocity * 5); // Convert to km/h-like value
      document.getElementById('speed').textContent = Math.round(speed);

      // Update time
      gameTime += 1/60; // Assuming 60 FPS
      const minutes = Math.floor(gameTime / 60);
      const seconds = Math.floor(gameTime % 60);
      const timeString = `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
      document.getElementById('time').textContent = timeString;

      // Check for checkpoint passing
      checkCheckpoints();
    }

    function checkCheckpoints() {
      const motorbike2D = new THREE.Vector2(motorbike.position.x, motorbike.position.z);

      track.children.forEach(child => {
        if (child.userData.isCheckpoint) {
          const checkpoint2D = new THREE.Vector2(child.position.x, child.position.z);
          const distance = motorbike2D.distanceTo(checkpoint2D);

          if (distance < 15 && child.userData.id === lastCheckpoint) {
            lastCheckpoint = (lastCheckpoint + 1) % 4;
            checkpointsPassed++;

            if (lastCheckpoint === 0 && checkpointsPassed > 3) {
              // Completed a lap
              currentLap++;
              document.getElementById('lap').textContent = `${currentLap} / ${totalLaps}`;

              if (currentLap > totalLaps) {
                // Race finished
                finishRace();
              }
            }
          }
        }
      });
    }

    function finishRace() {
      const finalTime = gameTime;
      if (!bestTime || finalTime < bestTime) {
        bestTime = finalTime;
        const minutes = Math.floor(bestTime / 60);
        const seconds = Math.floor(bestTime % 60);
        document.getElementById('bestTime').textContent =
          `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
      }

      // Reset race
      currentLap = 1;
      gameTime = 0;
      checkpointsPassed = 0;
      lastCheckpoint = 0;
      motorbike.position.set(100, 0, 0);
      motorbike.rotation.y = 0;
      velocity = 0;
      rotation = 0;

      document.getElementById('lap').textContent = '1 / 3';
      document.getElementById('startScreen').style.display = 'flex';
      gameStarted = false;
    }

    function animate() {
      requestAnimationFrame(animate);

      updateControls();
      updateUI();

      renderer.render(scene, camera);
    }

    // Handle window resize
    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });

    // Initialize the game when page loads
    init();
  </script>
</body>
</html>