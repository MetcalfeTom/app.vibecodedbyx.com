<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Moon Explorer - Walk on the Moon in 3D</title>
    <link rel="icon" href="https://emojicdn.elk.sh/üåô" type="image/png">

    <!-- Open Graph tags -->
    <meta property="og:title" content="Moon Explorer - Walk on the Moon in 3D">
    <meta property="og:description" content="Experience walking on the lunar surface in stunning 3D. See Earth from the moon and explore craters!">
    <meta property="og:url" content="https://app.vibecodedbyx.com/moon-explorer">
    <meta property="og:image" content="https://app.vibecodedbyx.com/moon-explorer/preview.png">
    <meta name="description" content="Experience walking on the lunar surface in stunning 3D. See Earth from the moon and explore craters!">

    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Arial', sans-serif;
            overflow: hidden;
            background: #000;
            color: white;
        }

        #canvas-container {
            width: 100vw;
            height: 100vh;
            position: relative;
        }

        .overlay {
            position: absolute;
            top: 20px;
            left: 20px;
            z-index: 10;
            background: rgba(0, 0, 0, 0.8);
            padding: 20px;
            border-radius: 15px;
            backdrop-filter: blur(10px);
            max-width: 320px;
            border: 2px solid rgba(255, 255, 255, 0.2);
        }

        h1 {
            font-size: 1.8rem;
            margin-bottom: 10px;
            background: linear-gradient(45deg, #ffffff, #a0a0a0, #ffffff);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        p {
            font-size: 0.9rem;
            line-height: 1.5;
            color: #ccc;
        }

        .instructions {
            margin-top: 15px;
            padding-top: 15px;
            border-top: 1px solid rgba(255, 255, 255, 0.2);
            font-size: 0.85rem;
            color: #aaa;
        }

        .controls {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 10;
            background: rgba(0, 0, 0, 0.8);
            padding: 15px 25px;
            border-radius: 30px;
            backdrop-filter: blur(10px);
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            justify-content: center;
            border: 2px solid rgba(255, 255, 255, 0.2);
        }

        button {
            padding: 10px 20px;
            background: linear-gradient(45deg, #4a4a4a, #2a2a2a);
            border: 1px solid rgba(255, 255, 255, 0.3);
            border-radius: 20px;
            color: white;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s;
        }

        button:hover {
            transform: scale(1.05);
            box-shadow: 0 0 20px rgba(255, 255, 255, 0.3);
            background: linear-gradient(45deg, #5a5a5a, #3a3a3a);
        }

        button:active {
            transform: scale(0.95);
        }

        .footer {
            position: absolute;
            bottom: 80px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 10;
            text-align: center;
        }

        .footer a {
            color: #a0a0a0;
            text-decoration: none;
            font-weight: bold;
        }

        .footer a:hover {
            color: #fff;
            text-decoration: underline;
        }

        @media (max-width: 768px) {
            .overlay {
                max-width: calc(100vw - 40px);
            }

            h1 {
                font-size: 1.4rem;
            }

            p {
                font-size: 0.8rem;
            }

            .controls {
                bottom: 10px;
                padding: 10px 15px;
            }

            button {
                padding: 8px 15px;
                font-size: 0.85rem;
            }

            .footer {
                bottom: 70px;
                font-size: 0.8rem;
            }
        }
    </style>
</head>
<body>
    <div id="canvas-container"></div>

    <div class="overlay">
        <h1>üåô Moon Explorer</h1>
        <p>You're standing on the lunar surface. Look around to see Earth in the distance!</p>
        <div class="instructions">
            üñ±Ô∏è <strong>Mouse:</strong> Look around<br>
            üì± <strong>Touch:</strong> Drag to rotate view
        </div>
    </div>

    <div class="controls">
        <button id="jumpBtn">üöÄ Jump</button>
        <button id="earthBtn">üåç Look at Earth</button>
        <button id="resetBtn">‚Üª Reset View</button>
    </div>

    <div class="footer">
        <a href="https://www.vibecodedbyx.com" target="_blank">‚Üê Back to VibeCodedByX.com</a>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // Scene setup
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 10000);
        const renderer = new THREE.WebGLRenderer({ antialias: true });

        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setClearColor(0x000000, 1);
        document.getElementById('canvas-container').appendChild(renderer.domElement);

        // Camera starting position (raised higher to avoid seeing through surface)
        camera.position.set(0, 5, 0);
        let cameraRotationY = 0;
        let cameraRotationX = 0;
        let isJumping = false;
        let jumpVelocity = 0;
        const cameraHeight = 5;

        // Create stars
        const starsGeometry = new THREE.BufferGeometry();
        const starsMaterial = new THREE.PointsMaterial({ color: 0xffffff, size: 0.7 });

        const starsVertices = [];
        for (let i = 0; i < 10000; i++) {
            const x = (Math.random() - 0.5) * 10000;
            const y = (Math.random() - 0.5) * 10000;
            const z = (Math.random() - 0.5) * 10000;
            starsVertices.push(x, y, z);
        }

        starsGeometry.setAttribute('position', new THREE.Float32BufferAttribute(starsVertices, 3));
        const stars = new THREE.Points(starsGeometry, starsMaterial);
        scene.add(stars);

        // Create moon surface
        const moonGeometry = new THREE.PlaneGeometry(2000, 2000, 100, 100);

        // Add crater-like terrain
        const positions = moonGeometry.attributes.position;
        for (let i = 0; i < positions.count; i++) {
            const x = positions.getX(i);
            const y = positions.getY(i);

            // Create random craters
            let z = Math.sin(x * 0.01) * 2 + Math.cos(y * 0.01) * 2;
            z += Math.random() * 0.5;

            // Add some larger craters
            const dist1 = Math.sqrt((x - 50) * (x - 50) + (y - 50) * (y - 50));
            const dist2 = Math.sqrt((x + 70) * (x + 70) + (y - 30) * (y - 30));
            const dist3 = Math.sqrt((x - 20) * (x - 20) + (y + 60) * (y + 60));

            if (dist1 < 20) z -= (20 - dist1) * 0.3;
            if (dist2 < 30) z -= (30 - dist2) * 0.2;
            if (dist3 < 25) z -= (25 - dist3) * 0.25;

            positions.setZ(i, z);
        }

        moonGeometry.computeVertexNormals();

        const moonMaterial = new THREE.MeshStandardMaterial({
            color: 0x8a8a8a,
            roughness: 0.9,
            metalness: 0.1
        });

        const moonSurface = new THREE.Mesh(moonGeometry, moonMaterial);
        moonSurface.rotation.x = -Math.PI / 2;
        scene.add(moonSurface);

        // Add some rocks
        for (let i = 0; i < 50; i++) {
            const rockSize = Math.random() * 2 + 0.5;
            const rockGeometry = new THREE.DodecahedronGeometry(rockSize, 0);
            const rockMaterial = new THREE.MeshStandardMaterial({
                color: 0x6a6a6a,
                roughness: 1
            });
            const rock = new THREE.Mesh(rockGeometry, rockMaterial);

            rock.position.set(
                (Math.random() - 0.5) * 200,
                rockSize / 2,
                (Math.random() - 0.5) * 200
            );

            rock.rotation.set(
                Math.random() * Math.PI,
                Math.random() * Math.PI,
                Math.random() * Math.PI
            );

            scene.add(rock);
        }

        // Create Earth
        const earthGeometry = new THREE.SphereGeometry(20, 32, 32);
        const earthMaterial = new THREE.MeshStandardMaterial({
            color: 0x2233ff,
            emissive: 0x112244,
            emissiveIntensity: 0.5
        });
        const earth = new THREE.Mesh(earthGeometry, earthMaterial);
        earth.position.set(0, 50, -300);
        scene.add(earth);

        // Add clouds to Earth
        const cloudsGeometry = new THREE.SphereGeometry(20.5, 32, 32);
        const cloudsMaterial = new THREE.MeshStandardMaterial({
            color: 0xffffff,
            transparent: true,
            opacity: 0.4
        });
        const clouds = new THREE.Mesh(cloudsGeometry, cloudsMaterial);
        earth.add(clouds);

        // Create 3D Mario
        const mario = new THREE.Group();

        // Body (blue overalls)
        const bodyGeometry = new THREE.BoxGeometry(1.2, 1.5, 0.8);
        const bodyMaterial = new THREE.MeshStandardMaterial({ color: 0x0000ff });
        const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
        body.position.y = 1.5;
        mario.add(body);

        // Head (skin color)
        const headGeometry = new THREE.BoxGeometry(1, 1, 1);
        const headMaterial = new THREE.MeshStandardMaterial({ color: 0xffdbac });
        const head = new THREE.Mesh(headGeometry, headMaterial);
        head.position.y = 2.8;
        mario.add(head);

        // Hat (red)
        const hatBrimGeometry = new THREE.CylinderGeometry(0.7, 0.7, 0.15, 16);
        const hatMaterial = new THREE.MeshStandardMaterial({ color: 0xff0000 });
        const hatBrim = new THREE.Mesh(hatBrimGeometry, hatMaterial);
        hatBrim.position.y = 3.3;
        mario.add(hatBrim);

        const hatTopGeometry = new THREE.CylinderGeometry(0.5, 0.5, 0.5, 16);
        const hatTop = new THREE.Mesh(hatTopGeometry, hatMaterial);
        hatTop.position.y = 3.6;
        mario.add(hatTop);

        // Mustache (black)
        const mustacheGeometry = new THREE.BoxGeometry(0.8, 0.15, 0.2);
        const mustacheMaterial = new THREE.MeshStandardMaterial({ color: 0x000000 });
        const mustache = new THREE.Mesh(mustacheGeometry, mustacheMaterial);
        mustache.position.set(0, 2.6, 0.5);
        mario.add(mustache);

        // Nose (bigger)
        const noseGeometry = new THREE.SphereGeometry(0.2, 16, 16);
        const nose = new THREE.Mesh(noseGeometry, headMaterial);
        nose.position.set(0, 2.7, 0.6);
        mario.add(nose);

        // Arms (red shirt)
        const armMaterial = new THREE.MeshStandardMaterial({ color: 0xff0000 });
        const armGeometry = new THREE.BoxGeometry(0.3, 1.2, 0.3);

        const leftArm = new THREE.Mesh(armGeometry, armMaterial);
        leftArm.position.set(-0.75, 1.5, 0);
        mario.add(leftArm);

        const rightArm = new THREE.Mesh(armGeometry, armMaterial);
        rightArm.position.set(0.75, 1.5, 0);
        mario.add(rightArm);

        // Hands (white gloves)
        const handMaterial = new THREE.MeshStandardMaterial({ color: 0xffffff });
        const handGeometry = new THREE.SphereGeometry(0.25, 16, 16);

        const leftHand = new THREE.Mesh(handGeometry, handMaterial);
        leftHand.position.set(-0.75, 0.8, 0);
        mario.add(leftHand);

        const rightHand = new THREE.Mesh(handGeometry, handMaterial);
        rightHand.position.set(0.75, 0.8, 0);
        mario.add(rightHand);

        // Legs (blue overalls)
        const legGeometry = new THREE.BoxGeometry(0.4, 1, 0.4);

        const leftLeg = new THREE.Mesh(legGeometry, bodyMaterial);
        leftLeg.position.set(-0.35, 0.25, 0);
        mario.add(leftLeg);

        const rightLeg = new THREE.Mesh(legGeometry, bodyMaterial);
        rightLeg.position.set(0.35, 0.25, 0);
        mario.add(rightLeg);

        // Shoes (brown)
        const shoeMaterial = new THREE.MeshStandardMaterial({ color: 0x8b4513 });
        const shoeGeometry = new THREE.BoxGeometry(0.45, 0.3, 0.7);

        const leftShoe = new THREE.Mesh(shoeGeometry, shoeMaterial);
        leftShoe.position.set(-0.35, -0.3, 0.15);
        mario.add(leftShoe);

        const rightShoe = new THREE.Mesh(shoeGeometry, shoeMaterial);
        rightShoe.position.set(0.35, -0.3, 0.15);
        mario.add(rightShoe);

        // Position Mario on the moon
        mario.position.set(5, 0.5, -10);
        mario.rotation.y = Math.PI / 4;
        scene.add(mario);

        // Lights
        const ambientLight = new THREE.AmbientLight(0x404040, 0.5);
        scene.add(ambientLight);

        const sunLight = new THREE.DirectionalLight(0xffffff, 1);
        sunLight.position.set(100, 100, 50);
        scene.add(sunLight);

        // Mouse controls
        let isDragging = false;
        let previousMouseX = 0;
        let previousMouseY = 0;

        document.addEventListener('mousedown', (e) => {
            if (e.target.tagName !== 'BUTTON') {
                isDragging = true;
                previousMouseX = e.clientX;
                previousMouseY = e.clientY;
            }
        });

        document.addEventListener('mouseup', () => {
            isDragging = false;
        });

        document.addEventListener('mousemove', (e) => {
            if (isDragging) {
                const deltaX = e.clientX - previousMouseX;
                const deltaY = e.clientY - previousMouseY;

                cameraRotationY -= deltaX * 0.005;
                cameraRotationX -= deltaY * 0.005;

                // Clamp vertical rotation
                cameraRotationX = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, cameraRotationX));

                previousMouseX = e.clientX;
                previousMouseY = e.clientY;
            }
        });

        // Touch controls
        let touchStartX = 0;
        let touchStartY = 0;

        document.addEventListener('touchstart', (e) => {
            if (e.target.tagName !== 'BUTTON' && e.touches.length > 0) {
                touchStartX = e.touches[0].clientX;
                touchStartY = e.touches[0].clientY;
            }
        });

        document.addEventListener('touchmove', (e) => {
            if (e.target.tagName !== 'BUTTON' && e.touches.length > 0) {
                const deltaX = e.touches[0].clientX - touchStartX;
                const deltaY = e.touches[0].clientY - touchStartY;

                cameraRotationY -= deltaX * 0.005;
                cameraRotationX -= deltaY * 0.005;

                cameraRotationX = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, cameraRotationX));

                touchStartX = e.touches[0].clientX;
                touchStartY = e.touches[0].clientY;
            }
        });

        // Button controls
        document.getElementById('jumpBtn').addEventListener('click', () => {
            if (!isJumping) {
                isJumping = true;
                jumpVelocity = 0.3; // Low gravity jump
            }
        });

        document.getElementById('earthBtn').addEventListener('click', () => {
            // Look towards Earth
            const earthDirection = new THREE.Vector3();
            earth.getWorldPosition(earthDirection);
            earthDirection.sub(camera.position);

            cameraRotationY = Math.atan2(earthDirection.x, earthDirection.z);
            cameraRotationX = Math.atan2(earthDirection.y, Math.sqrt(earthDirection.x * earthDirection.x + earthDirection.z * earthDirection.z));
        });

        document.getElementById('resetBtn').addEventListener('click', () => {
            camera.position.set(0, cameraHeight, 0);
            cameraRotationY = 0;
            cameraRotationX = 0;
        });

        // Animation loop
        function animate() {
            requestAnimationFrame(animate);

            // Apply camera rotation
            camera.rotation.order = 'YXZ';
            camera.rotation.y = cameraRotationY;
            camera.rotation.x = cameraRotationX;

            // Handle jumping
            if (isJumping) {
                camera.position.y += jumpVelocity;
                jumpVelocity -= 0.01; // Low gravity

                if (camera.position.y <= cameraHeight) {
                    camera.position.y = cameraHeight;
                    isJumping = false;
                    jumpVelocity = 0;
                }
            }

            // Rotate Earth and clouds
            earth.rotation.y += 0.001;
            clouds.rotation.y += 0.0015;

            // Animate Mario (idle bounce and wave)
            mario.position.y = 0.5 + Math.sin(Date.now() * 0.002) * 0.2;
            mario.rotation.y = Math.PI / 4 + Math.sin(Date.now() * 0.001) * 0.1;

            renderer.render(scene, camera);
        }

        // Handle window resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        // Start animation
        animate();
    </script>
</body>
</html>
