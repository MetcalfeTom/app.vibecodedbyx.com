<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Moon Explorer - Walk on the Moon in 3D</title>
    <link rel="icon" href="https://emojicdn.elk.sh/üåô" type="image/png">

    <!-- Open Graph tags -->
    <meta property="og:title" content="Moon Explorer - Walk on the Moon in 3D">
    <meta property="og:description" content="Experience walking on the lunar surface in stunning 3D. See Earth from the moon and explore craters!">
    <meta property="og:url" content="https://sloppy.live/moon-explorer">
    <meta property="og:image" content="https://sloppy.live/moon-explorer/preview.png">
    <meta name="description" content="Experience walking on the lunar surface in stunning 3D. See Earth from the moon and explore craters!">

    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Arial', sans-serif;
            overflow: hidden;
            background: #000;
            color: white;
        }

        #canvas-container {
            width: 100vw;
            height: 100vh;
            position: relative;
        }

        .overlay {
            position: absolute;
            top: 20px;
            left: 20px;
            z-index: 10;
            background: rgba(0, 0, 0, 0.8);
            padding: 20px;
            border-radius: 15px;
            backdrop-filter: blur(10px);
            max-width: 320px;
            border: 2px solid rgba(255, 255, 255, 0.2);
        }

        h1 {
            font-size: 1.8rem;
            margin-bottom: 10px;
            background: linear-gradient(45deg, #ffffff, #a0a0a0, #ffffff);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        p {
            font-size: 0.9rem;
            line-height: 1.5;
            color: #ccc;
        }

        .instructions {
            margin-top: 15px;
            padding-top: 15px;
            border-top: 1px solid rgba(255, 255, 255, 0.2);
            font-size: 0.85rem;
            color: #aaa;
        }

        .controls {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 10;
            background: rgba(0, 0, 0, 0.8);
            padding: 15px 25px;
            border-radius: 30px;
            backdrop-filter: blur(10px);
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            justify-content: center;
            border: 2px solid rgba(255, 255, 255, 0.2);
        }

        button {
            padding: 10px 20px;
            background: linear-gradient(45deg, #4a4a4a, #2a2a2a);
            border: 1px solid rgba(255, 255, 255, 0.3);
            border-radius: 20px;
            color: white;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s;
        }

        button:hover {
            transform: scale(1.05);
            box-shadow: 0 0 20px rgba(255, 255, 255, 0.3);
            background: linear-gradient(45deg, #5a5a5a, #3a3a3a);
        }

        button:active {
            transform: scale(0.95);
        }

        .footer {
            position: absolute;
            bottom: 80px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 10;
            text-align: center;
        }

        .footer a {
            color: #a0a0a0;
            text-decoration: none;
            font-weight: bold;
        }

        .footer a:hover {
            color: #fff;
            text-decoration: underline;
        }

        @media (max-width: 768px) {
            .overlay {
                max-width: calc(100vw - 40px);
            }

            h1 {
                font-size: 1.4rem;
            }

            p {
                font-size: 0.8rem;
            }

            .controls {
                bottom: 10px;
                padding: 10px 15px;
            }

            button {
                padding: 8px 15px;
                font-size: 0.85rem;
            }

            .footer {
                bottom: 70px;
                font-size: 0.8rem;
            }
        }
    </style>
</head>
<body>
    <div id="canvas-container"></div>

    <div class="overlay">
        <h1>üåô Moon Explorer</h1>
        <p>Walk around the moon, collect coins, and explore! Mario is here too!</p>
        <div class="instructions">
            <strong>WASD:</strong> Move around<br>
            <strong>Space:</strong> Jump<br>
            üñ±Ô∏è <strong>Mouse:</strong> Look around<br>
            <strong id="scoreDisplay">Coins: 0/20</strong>
        </div>
    </div>

    <div class="controls">
        <button id="earthBtn">üåç Look at Earth</button>
        <button id="resetBtn">‚Üª Reset View</button>
    </div>

    <div class="footer">
        <a href="https://sloppy.live" target="_blank">‚Üê Back to sloppy.live</a> | <a href="https://sloppy.live/overview" style="color:#4ecdc4;text-decoration:none">üé® View All Apps</a>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // Scene setup
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 10000);
        const renderer = new THREE.WebGLRenderer({ antialias: true });

        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setClearColor(0x000000, 1);
        document.getElementById('canvas-container').appendChild(renderer.domElement);

        // Camera starting position (raised higher to avoid seeing through surface)
        camera.position.set(0, 5, 0);
        let cameraRotationY = 0;
        let cameraRotationX = 0;
        let isJumping = false;
        let jumpVelocity = 0;
        const cameraHeight = 5;

        // Movement controls
        const keys = { w: false, a: false, s: false, d: false, space: false };
        const moveSpeed = 0.2;
        let coinsCollected = 0;

        // Create stars
        const starsGeometry = new THREE.BufferGeometry();
        const starsMaterial = new THREE.PointsMaterial({ color: 0xffffff, size: 0.7 });

        const starsVertices = [];
        for (let i = 0; i < 10000; i++) {
            const x = (Math.random() - 0.5) * 10000;
            const y = (Math.random() - 0.5) * 10000;
            const z = (Math.random() - 0.5) * 10000;
            starsVertices.push(x, y, z);
        }

        starsGeometry.setAttribute('position', new THREE.Float32BufferAttribute(starsVertices, 3));
        const stars = new THREE.Points(starsGeometry, starsMaterial);
        scene.add(stars);

        // Create moon surface
        const moonGeometry = new THREE.PlaneGeometry(2000, 2000, 100, 100);

        // Add crater-like terrain
        const positions = moonGeometry.attributes.position;
        for (let i = 0; i < positions.count; i++) {
            const x = positions.getX(i);
            const y = positions.getY(i);

            // Create random craters
            let z = Math.sin(x * 0.01) * 2 + Math.cos(y * 0.01) * 2;
            z += Math.random() * 0.5;

            // Add some larger craters
            const dist1 = Math.sqrt((x - 50) * (x - 50) + (y - 50) * (y - 50));
            const dist2 = Math.sqrt((x + 70) * (x + 70) + (y - 30) * (y - 30));
            const dist3 = Math.sqrt((x - 20) * (x - 20) + (y + 60) * (y + 60));

            if (dist1 < 20) z -= (20 - dist1) * 0.3;
            if (dist2 < 30) z -= (30 - dist2) * 0.2;
            if (dist3 < 25) z -= (25 - dist3) * 0.25;

            positions.setZ(i, z);
        }

        moonGeometry.computeVertexNormals();

        const moonMaterial = new THREE.MeshStandardMaterial({
            color: 0x8a8a8a,
            roughness: 0.9,
            metalness: 0.1
        });

        const moonSurface = new THREE.Mesh(moonGeometry, moonMaterial);
        moonSurface.rotation.x = -Math.PI / 2;
        scene.add(moonSurface);

        // Add some rocks
        for (let i = 0; i < 50; i++) {
            const rockSize = Math.random() * 2 + 0.5;
            const rockGeometry = new THREE.DodecahedronGeometry(rockSize, 0);
            const rockMaterial = new THREE.MeshStandardMaterial({
                color: 0x6a6a6a,
                roughness: 1
            });
            const rock = new THREE.Mesh(rockGeometry, rockMaterial);

            rock.position.set(
                (Math.random() - 0.5) * 200,
                rockSize / 2,
                (Math.random() - 0.5) * 200
            );

            rock.rotation.set(
                Math.random() * Math.PI,
                Math.random() * Math.PI,
                Math.random() * Math.PI
            );

            scene.add(rock);
        }

        // Create Earth
        const earthGeometry = new THREE.SphereGeometry(20, 32, 32);
        const earthMaterial = new THREE.MeshStandardMaterial({
            color: 0x2233ff,
            emissive: 0x112244,
            emissiveIntensity: 0.5
        });
        const earth = new THREE.Mesh(earthGeometry, earthMaterial);
        earth.position.set(0, 50, -300);
        scene.add(earth);

        // Add clouds to Earth
        const cloudsGeometry = new THREE.SphereGeometry(20.5, 32, 32);
        const cloudsMaterial = new THREE.MeshStandardMaterial({
            color: 0xffffff,
            transparent: true,
            opacity: 0.4
        });
        const clouds = new THREE.Mesh(cloudsGeometry, cloudsMaterial);
        earth.add(clouds);

        // Create 3D Mario
        const mario = new THREE.Group();

        // Body (blue overalls)
        const bodyGeometry = new THREE.BoxGeometry(1.2, 1.5, 0.8);
        const bodyMaterial = new THREE.MeshStandardMaterial({ color: 0x0000ff });
        const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
        body.position.y = 1.5;
        mario.add(body);

        // Head (skin color)
        const headGeometry = new THREE.BoxGeometry(1, 1, 1);
        const headMaterial = new THREE.MeshStandardMaterial({ color: 0xffdbac });
        const head = new THREE.Mesh(headGeometry, headMaterial);
        head.position.y = 2.8;
        mario.add(head);

        // Hat (red)
        const hatBrimGeometry = new THREE.CylinderGeometry(0.7, 0.7, 0.15, 16);
        const hatMaterial = new THREE.MeshStandardMaterial({ color: 0xff0000 });
        const hatBrim = new THREE.Mesh(hatBrimGeometry, hatMaterial);
        hatBrim.position.y = 3.3;
        mario.add(hatBrim);

        const hatTopGeometry = new THREE.CylinderGeometry(0.5, 0.5, 0.5, 16);
        const hatTop = new THREE.Mesh(hatTopGeometry, hatMaterial);
        hatTop.position.y = 3.6;
        mario.add(hatTop);

        // Mustache (black)
        const mustacheGeometry = new THREE.BoxGeometry(0.8, 0.15, 0.2);
        const mustacheMaterial = new THREE.MeshStandardMaterial({ color: 0x000000 });
        const mustache = new THREE.Mesh(mustacheGeometry, mustacheMaterial);
        mustache.position.set(0, 2.6, 0.5);
        mario.add(mustache);

        // Nose (bigger)
        const noseGeometry = new THREE.SphereGeometry(0.2, 16, 16);
        const nose = new THREE.Mesh(noseGeometry, headMaterial);
        nose.position.set(0, 2.7, 0.6);
        mario.add(nose);

        // Arms (red shirt)
        const armMaterial = new THREE.MeshStandardMaterial({ color: 0xff0000 });
        const armGeometry = new THREE.BoxGeometry(0.3, 1.2, 0.3);

        const leftArm = new THREE.Mesh(armGeometry, armMaterial);
        leftArm.position.set(-0.75, 1.5, 0);
        mario.add(leftArm);

        const rightArm = new THREE.Mesh(armGeometry, armMaterial);
        rightArm.position.set(0.75, 1.5, 0);
        mario.add(rightArm);

        // Hands (white gloves)
        const handMaterial = new THREE.MeshStandardMaterial({ color: 0xffffff });
        const handGeometry = new THREE.SphereGeometry(0.25, 16, 16);

        const leftHand = new THREE.Mesh(handGeometry, handMaterial);
        leftHand.position.set(-0.75, 0.8, 0);
        mario.add(leftHand);

        const rightHand = new THREE.Mesh(handGeometry, handMaterial);
        rightHand.position.set(0.75, 0.8, 0);
        mario.add(rightHand);

        // Legs (blue overalls)
        const legGeometry = new THREE.BoxGeometry(0.4, 1, 0.4);

        const leftLeg = new THREE.Mesh(legGeometry, bodyMaterial);
        leftLeg.position.set(-0.35, 0.25, 0);
        mario.add(leftLeg);

        const rightLeg = new THREE.Mesh(legGeometry, bodyMaterial);
        rightLeg.position.set(0.35, 0.25, 0);
        mario.add(rightLeg);

        // Shoes (brown)
        const shoeMaterial = new THREE.MeshStandardMaterial({ color: 0x8b4513 });
        const shoeGeometry = new THREE.BoxGeometry(0.45, 0.3, 0.7);

        const leftShoe = new THREE.Mesh(shoeGeometry, shoeMaterial);
        leftShoe.position.set(-0.35, -0.3, 0.15);
        mario.add(leftShoe);

        const rightShoe = new THREE.Mesh(shoeGeometry, shoeMaterial);
        rightShoe.position.set(0.35, -0.3, 0.15);
        mario.add(rightShoe);

        // Position Mario on the moon
        mario.position.set(5, 0.5, -10);
        mario.rotation.y = Math.PI / 4;
        scene.add(mario);

        // Create coins
        const coins = [];
        const coinGeometry = new THREE.CylinderGeometry(0.8, 0.8, 0.2, 20);
        const coinMaterial = new THREE.MeshStandardMaterial({
            color: 0xffd700,
            metalness: 0.8,
            roughness: 0.2,
            emissive: 0xffaa00,
            emissiveIntensity: 0.5
        });

        for (let i = 0; i < 20; i++) {
            const coin = new THREE.Mesh(coinGeometry, coinMaterial);
            coin.position.set(
                (Math.random() - 0.5) * 100,
                2,
                (Math.random() - 0.5) * 100
            );
            coin.rotation.x = Math.PI / 2;
            coin.userData = { collected: false, initialY: 2, rotationSpeed: Math.random() * 0.05 + 0.02 };
            scene.add(coin);
            coins.push(coin);
        }

        // Create floating shapes
        const shapes = [];
        const shapeGeometries = [
            new THREE.BoxGeometry(1.5, 1.5, 1.5),
            new THREE.SphereGeometry(1, 20, 20),
            new THREE.ConeGeometry(1, 2, 20),
            new THREE.TorusGeometry(1, 0.4, 16, 100),
            new THREE.OctahedronGeometry(1)
        ];

        const shapeColors = [0xff6b6b, 0x4ecdc4, 0x45b7d1, 0xffa07a, 0x98d8c8];

        for (let i = 0; i < 10; i++) {
            const geometry = shapeGeometries[Math.floor(Math.random() * shapeGeometries.length)];
            const color = shapeColors[Math.floor(Math.random() * shapeColors.length)];
            const material = new THREE.MeshStandardMaterial({
                color: color,
                metalness: 0.5,
                roughness: 0.3,
                emissive: color,
                emissiveIntensity: 0.3
            });

            const shape = new THREE.Mesh(geometry, material);
            shape.position.set(
                (Math.random() - 0.5) * 150,
                Math.random() * 20 + 10,
                (Math.random() - 0.5) * 150
            );
            shape.userData = {
                velocity: {
                    x: (Math.random() - 0.5) * 0.03,
                    y: (Math.random() - 0.5) * 0.02,
                    z: (Math.random() - 0.5) * 0.03
                },
                rotationSpeed: {
                    x: (Math.random() - 0.5) * 0.02,
                    y: (Math.random() - 0.5) * 0.02,
                    z: (Math.random() - 0.5) * 0.02
                }
            };
            scene.add(shape);
            shapes.push(shape);
        }

        // Lights
        const ambientLight = new THREE.AmbientLight(0x404040, 0.5);
        scene.add(ambientLight);

        const sunLight = new THREE.DirectionalLight(0xffffff, 1);
        sunLight.position.set(100, 100, 50);
        scene.add(sunLight);

        // Mouse controls
        let isDragging = false;
        let previousMouseX = 0;
        let previousMouseY = 0;

        document.addEventListener('mousedown', (e) => {
            if (e.target.tagName !== 'BUTTON') {
                isDragging = true;
                previousMouseX = e.clientX;
                previousMouseY = e.clientY;
            }
        });

        document.addEventListener('mouseup', () => {
            isDragging = false;
        });

        document.addEventListener('mousemove', (e) => {
            if (isDragging) {
                const deltaX = e.clientX - previousMouseX;
                const deltaY = e.clientY - previousMouseY;

                cameraRotationY -= deltaX * 0.005;
                cameraRotationX -= deltaY * 0.005;

                // Clamp vertical rotation
                cameraRotationX = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, cameraRotationX));

                previousMouseX = e.clientX;
                previousMouseY = e.clientY;
            }
        });

        // Touch controls
        let touchStartX = 0;
        let touchStartY = 0;

        document.addEventListener('touchstart', (e) => {
            if (e.target.tagName !== 'BUTTON' && e.touches.length > 0) {
                touchStartX = e.touches[0].clientX;
                touchStartY = e.touches[0].clientY;
            }
        });

        document.addEventListener('touchmove', (e) => {
            if (e.target.tagName !== 'BUTTON' && e.touches.length > 0) {
                const deltaX = e.touches[0].clientX - touchStartX;
                const deltaY = e.touches[0].clientY - touchStartY;

                cameraRotationY -= deltaX * 0.005;
                cameraRotationX -= deltaY * 0.005;

                cameraRotationX = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, cameraRotationX));

                touchStartX = e.touches[0].clientX;
                touchStartY = e.touches[0].clientY;
            }
        });

        // Button controls
        document.getElementById('earthBtn').addEventListener('click', () => {
            // Look towards Earth
            const earthDirection = new THREE.Vector3();
            earth.getWorldPosition(earthDirection);
            earthDirection.sub(camera.position);

            cameraRotationY = Math.atan2(earthDirection.x, earthDirection.z);
            cameraRotationX = Math.atan2(earthDirection.y, Math.sqrt(earthDirection.x * earthDirection.x + earthDirection.z * earthDirection.z));
        });

        document.getElementById('resetBtn').addEventListener('click', () => {
            camera.position.set(0, cameraHeight, 0);
            cameraRotationY = 0;
            cameraRotationX = 0;
        });

        // Update score display
        function updateScoreDisplay() {
            const scoreEl = document.getElementById('scoreDisplay');
            if (scoreEl) {
                scoreEl.textContent = `Coins: ${coinsCollected}/20`;
            }
        }

        // Keyboard controls
        document.addEventListener('keydown', (e) => {
            const key = e.key.toLowerCase();
            if (keys.hasOwnProperty(key)) {
                keys[key] = true;
            }
            if (key === ' ' || key === 'space') {
                keys.space = true;
                if (!isJumping) {
                    isJumping = true;
                    jumpVelocity = 0.4;
                }
                e.preventDefault();
            }
        });

        document.addEventListener('keyup', (e) => {
            const key = e.key.toLowerCase();
            if (keys.hasOwnProperty(key)) {
                keys[key] = false;
            }
            if (key === ' ' || key === 'space') {
                keys.space = false;
            }
        });

        // Animation loop
        function animate() {
            requestAnimationFrame(animate);

            // Apply camera rotation
            camera.rotation.order = 'YXZ';
            camera.rotation.y = cameraRotationY;
            camera.rotation.x = cameraRotationX;

            // Handle WASD movement
            const forward = new THREE.Vector3(0, 0, -1);
            const right = new THREE.Vector3(1, 0, 0);

            forward.applyQuaternion(camera.quaternion);
            forward.y = 0;
            forward.normalize();

            right.applyQuaternion(camera.quaternion);
            right.y = 0;
            right.normalize();

            if (keys.w) {
                camera.position.x += forward.x * moveSpeed;
                camera.position.z += forward.z * moveSpeed;
            }
            if (keys.s) {
                camera.position.x -= forward.x * moveSpeed;
                camera.position.z -= forward.z * moveSpeed;
            }
            if (keys.a) {
                camera.position.x -= right.x * moveSpeed;
                camera.position.z -= right.z * moveSpeed;
            }
            if (keys.d) {
                camera.position.x += right.x * moveSpeed;
                camera.position.z += right.z * moveSpeed;
            }

            // Handle jumping
            if (isJumping) {
                camera.position.y += jumpVelocity;
                jumpVelocity -= 0.01; // Low gravity

                if (camera.position.y <= cameraHeight) {
                    camera.position.y = cameraHeight;
                    isJumping = false;
                    jumpVelocity = 0;
                }
            }

            // Rotate Earth and clouds
            earth.rotation.y += 0.001;
            clouds.rotation.y += 0.0015;

            // Animate Mario (idle bounce and wave)
            mario.position.y = 0.5 + Math.sin(Date.now() * 0.002) * 0.2;
            mario.rotation.y = Math.PI / 4 + Math.sin(Date.now() * 0.001) * 0.1;

            // Animate and check coin collection
            coins.forEach((coin) => {
                if (!coin.userData.collected) {
                    // Animate coin (float and spin)
                    coin.position.y = coin.userData.initialY + Math.sin(Date.now() * 0.003 + coin.id) * 0.3;
                    coin.rotation.y += coin.userData.rotationSpeed;

                    // Check distance to camera
                    const dist = camera.position.distanceTo(coin.position);
                    if (dist < 3) {
                        coin.userData.collected = true;
                        coinsCollected++;
                        updateScoreDisplay();
                        scene.remove(coin);
                    }
                }
            });

            // Animate floating shapes
            shapes.forEach((shape) => {
                // Move shapes
                shape.position.x += shape.userData.velocity.x;
                shape.position.y += shape.userData.velocity.y;
                shape.position.z += shape.userData.velocity.z;

                // Boundary bounce
                if (Math.abs(shape.position.x) > 100) shape.userData.velocity.x *= -1;
                if (shape.position.y > 30 || shape.position.y < 5) shape.userData.velocity.y *= -1;
                if (Math.abs(shape.position.z) > 100) shape.userData.velocity.z *= -1;

                // Rotate shapes
                shape.rotation.x += shape.userData.rotationSpeed.x;
                shape.rotation.y += shape.userData.rotationSpeed.y;
                shape.rotation.z += shape.userData.rotationSpeed.z;
            });

            renderer.render(scene, camera);
        }

        // Handle window resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        // Start animation
        animate();
    </script>
<script src="/sloppy-header/sloppy-bar.js"></script>
</body>
</html>
