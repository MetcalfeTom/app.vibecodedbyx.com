<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Moon Explorer - Walk on the Moon in 3D</title>
    <link rel="icon" href="https://emojicdn.elk.sh/üåô" type="image/png">

    <!-- Open Graph tags -->
    <meta property="og:title" content="Moon Explorer - Walk on the Moon in 3D">
    <meta property="og:description" content="Experience walking on the lunar surface in stunning 3D. See Earth from the moon and explore craters!">
    <meta property="og:url" content="https://app.vibecodedbyx.com/moon-explorer">
    <meta property="og:image" content="https://app.vibecodedbyx.com/moon-explorer/preview.png">
    <meta name="description" content="Experience walking on the lunar surface in stunning 3D. See Earth from the moon and explore craters!">

    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Arial', sans-serif;
            overflow: hidden;
            background: #000;
            color: white;
        }

        #canvas-container {
            width: 100vw;
            height: 100vh;
            position: relative;
        }

        .overlay {
            position: absolute;
            top: 20px;
            left: 20px;
            z-index: 10;
            background: rgba(0, 0, 0, 0.8);
            padding: 20px;
            border-radius: 15px;
            backdrop-filter: blur(10px);
            max-width: 320px;
            border: 2px solid rgba(255, 255, 255, 0.2);
        }

        h1 {
            font-size: 1.8rem;
            margin-bottom: 10px;
            background: linear-gradient(45deg, #ffffff, #a0a0a0, #ffffff);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        p {
            font-size: 0.9rem;
            line-height: 1.5;
            color: #ccc;
        }

        .instructions {
            margin-top: 15px;
            padding-top: 15px;
            border-top: 1px solid rgba(255, 255, 255, 0.2);
            font-size: 0.85rem;
            color: #aaa;
        }

        .controls {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 10;
            background: rgba(0, 0, 0, 0.8);
            padding: 15px 25px;
            border-radius: 30px;
            backdrop-filter: blur(10px);
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            justify-content: center;
            border: 2px solid rgba(255, 255, 255, 0.2);
        }

        button {
            padding: 10px 20px;
            background: linear-gradient(45deg, #4a4a4a, #2a2a2a);
            border: 1px solid rgba(255, 255, 255, 0.3);
            border-radius: 20px;
            color: white;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s;
        }

        button:hover {
            transform: scale(1.05);
            box-shadow: 0 0 20px rgba(255, 255, 255, 0.3);
            background: linear-gradient(45deg, #5a5a5a, #3a3a3a);
        }

        button:active {
            transform: scale(0.95);
        }

        .footer {
            position: absolute;
            bottom: 80px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 10;
            text-align: center;
        }

        .footer a {
            color: #a0a0a0;
            text-decoration: none;
            font-weight: bold;
        }

        .footer a:hover {
            color: #fff;
            text-decoration: underline;
        }

        @media (max-width: 768px) {
            .overlay {
                max-width: calc(100vw - 40px);
            }

            h1 {
                font-size: 1.4rem;
            }

            p {
                font-size: 0.8rem;
            }

            .controls {
                bottom: 10px;
                padding: 10px 15px;
            }

            button {
                padding: 8px 15px;
                font-size: 0.85rem;
            }

            .footer {
                bottom: 70px;
                font-size: 0.8rem;
            }
        }
    </style>
</head>
<body>
    <div id="canvas-container"></div>

    <div class="overlay">
        <h1>üåô Moon Explorer</h1>
        <p>You're standing on the lunar surface. Look around to see Earth in the distance!</p>
        <div class="instructions">
            üñ±Ô∏è <strong>Mouse:</strong> Look around<br>
            üì± <strong>Touch:</strong> Drag to rotate view
        </div>
    </div>

    <div class="controls">
        <button id="jumpBtn">üöÄ Jump</button>
        <button id="earthBtn">üåç Look at Earth</button>
        <button id="resetBtn">‚Üª Reset View</button>
    </div>

    <div class="footer">
        <a href="https://www.vibecodedbyx.com" target="_blank">‚Üê Back to VibeCodedByX.com</a>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // Scene setup
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 10000);
        const renderer = new THREE.WebGLRenderer({ antialias: true });

        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setClearColor(0x000000, 1);
        document.getElementById('canvas-container').appendChild(renderer.domElement);

        // Camera starting position
        camera.position.set(0, 2, 0);
        let cameraRotationY = 0;
        let cameraRotationX = 0;
        let isJumping = false;
        let jumpVelocity = 0;

        // Create stars
        const starsGeometry = new THREE.BufferGeometry();
        const starsMaterial = new THREE.PointsMaterial({ color: 0xffffff, size: 0.7 });

        const starsVertices = [];
        for (let i = 0; i < 10000; i++) {
            const x = (Math.random() - 0.5) * 10000;
            const y = (Math.random() - 0.5) * 10000;
            const z = (Math.random() - 0.5) * 10000;
            starsVertices.push(x, y, z);
        }

        starsGeometry.setAttribute('position', new THREE.Float32BufferAttribute(starsVertices, 3));
        const stars = new THREE.Points(starsGeometry, starsMaterial);
        scene.add(stars);

        // Create moon surface
        const moonGeometry = new THREE.PlaneGeometry(2000, 2000, 100, 100);

        // Add crater-like terrain
        const positions = moonGeometry.attributes.position;
        for (let i = 0; i < positions.count; i++) {
            const x = positions.getX(i);
            const y = positions.getY(i);

            // Create random craters
            let z = Math.sin(x * 0.01) * 2 + Math.cos(y * 0.01) * 2;
            z += Math.random() * 0.5;

            // Add some larger craters
            const dist1 = Math.sqrt((x - 50) * (x - 50) + (y - 50) * (y - 50));
            const dist2 = Math.sqrt((x + 70) * (x + 70) + (y - 30) * (y - 30));
            const dist3 = Math.sqrt((x - 20) * (x - 20) + (y + 60) * (y + 60));

            if (dist1 < 20) z -= (20 - dist1) * 0.3;
            if (dist2 < 30) z -= (30 - dist2) * 0.2;
            if (dist3 < 25) z -= (25 - dist3) * 0.25;

            positions.setZ(i, z);
        }

        moonGeometry.computeVertexNormals();

        const moonMaterial = new THREE.MeshStandardMaterial({
            color: 0x8a8a8a,
            roughness: 0.9,
            metalness: 0.1
        });

        const moonSurface = new THREE.Mesh(moonGeometry, moonMaterial);
        moonSurface.rotation.x = -Math.PI / 2;
        scene.add(moonSurface);

        // Add some rocks
        for (let i = 0; i < 50; i++) {
            const rockSize = Math.random() * 2 + 0.5;
            const rockGeometry = new THREE.DodecahedronGeometry(rockSize, 0);
            const rockMaterial = new THREE.MeshStandardMaterial({
                color: 0x6a6a6a,
                roughness: 1
            });
            const rock = new THREE.Mesh(rockGeometry, rockMaterial);

            rock.position.set(
                (Math.random() - 0.5) * 200,
                rockSize / 2,
                (Math.random() - 0.5) * 200
            );

            rock.rotation.set(
                Math.random() * Math.PI,
                Math.random() * Math.PI,
                Math.random() * Math.PI
            );

            scene.add(rock);
        }

        // Create Earth
        const earthGeometry = new THREE.SphereGeometry(20, 32, 32);
        const earthMaterial = new THREE.MeshStandardMaterial({
            color: 0x2233ff,
            emissive: 0x112244,
            emissiveIntensity: 0.5
        });
        const earth = new THREE.Mesh(earthGeometry, earthMaterial);
        earth.position.set(0, 50, -300);
        scene.add(earth);

        // Add clouds to Earth
        const cloudsGeometry = new THREE.SphereGeometry(20.5, 32, 32);
        const cloudsMaterial = new THREE.MeshStandardMaterial({
            color: 0xffffff,
            transparent: true,
            opacity: 0.4
        });
        const clouds = new THREE.Mesh(cloudsGeometry, cloudsMaterial);
        earth.add(clouds);

        // Lights
        const ambientLight = new THREE.AmbientLight(0x404040, 0.5);
        scene.add(ambientLight);

        const sunLight = new THREE.DirectionalLight(0xffffff, 1);
        sunLight.position.set(100, 100, 50);
        scene.add(sunLight);

        // Mouse controls
        let isDragging = false;
        let previousMouseX = 0;
        let previousMouseY = 0;

        document.addEventListener('mousedown', (e) => {
            if (e.target.tagName !== 'BUTTON') {
                isDragging = true;
                previousMouseX = e.clientX;
                previousMouseY = e.clientY;
            }
        });

        document.addEventListener('mouseup', () => {
            isDragging = false;
        });

        document.addEventListener('mousemove', (e) => {
            if (isDragging) {
                const deltaX = e.clientX - previousMouseX;
                const deltaY = e.clientY - previousMouseY;

                cameraRotationY -= deltaX * 0.005;
                cameraRotationX -= deltaY * 0.005;

                // Clamp vertical rotation
                cameraRotationX = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, cameraRotationX));

                previousMouseX = e.clientX;
                previousMouseY = e.clientY;
            }
        });

        // Touch controls
        let touchStartX = 0;
        let touchStartY = 0;

        document.addEventListener('touchstart', (e) => {
            if (e.target.tagName !== 'BUTTON' && e.touches.length > 0) {
                touchStartX = e.touches[0].clientX;
                touchStartY = e.touches[0].clientY;
            }
        });

        document.addEventListener('touchmove', (e) => {
            if (e.target.tagName !== 'BUTTON' && e.touches.length > 0) {
                const deltaX = e.touches[0].clientX - touchStartX;
                const deltaY = e.touches[0].clientY - touchStartY;

                cameraRotationY -= deltaX * 0.005;
                cameraRotationX -= deltaY * 0.005;

                cameraRotationX = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, cameraRotationX));

                touchStartX = e.touches[0].clientX;
                touchStartY = e.touches[0].clientY;
            }
        });

        // Button controls
        document.getElementById('jumpBtn').addEventListener('click', () => {
            if (!isJumping) {
                isJumping = true;
                jumpVelocity = 0.3; // Low gravity jump
            }
        });

        document.getElementById('earthBtn').addEventListener('click', () => {
            // Look towards Earth
            const earthDirection = new THREE.Vector3();
            earth.getWorldPosition(earthDirection);
            earthDirection.sub(camera.position);

            cameraRotationY = Math.atan2(earthDirection.x, earthDirection.z);
            cameraRotationX = Math.atan2(earthDirection.y, Math.sqrt(earthDirection.x * earthDirection.x + earthDirection.z * earthDirection.z));
        });

        document.getElementById('resetBtn').addEventListener('click', () => {
            camera.position.set(0, 2, 0);
            cameraRotationY = 0;
            cameraRotationX = 0;
        });

        // Animation loop
        function animate() {
            requestAnimationFrame(animate);

            // Apply camera rotation
            camera.rotation.order = 'YXZ';
            camera.rotation.y = cameraRotationY;
            camera.rotation.x = cameraRotationX;

            // Handle jumping
            if (isJumping) {
                camera.position.y += jumpVelocity;
                jumpVelocity -= 0.01; // Low gravity

                if (camera.position.y <= 2) {
                    camera.position.y = 2;
                    isJumping = false;
                    jumpVelocity = 0;
                }
            }

            // Rotate Earth and clouds
            earth.rotation.y += 0.001;
            clouds.rotation.y += 0.0015;

            renderer.render(scene, camera);
        }

        // Handle window resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        // Start animation
        animate();
    </script>
</body>
</html>
