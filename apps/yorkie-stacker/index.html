<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Yorkshire Pudding Stacker</title>
  <meta name="description" content="Stack giant Yorkshire puddings and pour gravy on top!">
  <meta property="og:title" content="Yorkshire Pudding Stacker">
  <meta property="og:description" content="Stack 'em high and drown 'em in gravy!">
  <meta property="og:url" content="https://app.sloppy.live/yorkie-stacker">
  <meta property="og:image" content="https://app.sloppy.live/yorkie-stacker/og-image.png">
  <link rel="icon" href="https://emojicdn.elk.sh/ðŸ¥§">
  <link href="https://fonts.googleapis.com/css2?family=Fredoka:wght@400;600;700&family=Playfair+Display:wght@700&display=swap" rel="stylesheet">
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      min-height: 100vh;
      background: linear-gradient(180deg, #8B4513 0%, #654321 50%, #3D2314 100%);
      font-family: 'Fredoka', sans-serif;
      overflow: hidden;
      user-select: none;
    }

    canvas {
      display: block;
    }

    .ui {
      position: absolute;
      top: 20px;
      left: 20px;
      right: 20px;
      display: flex;
      justify-content: space-between;
      pointer-events: none;
      z-index: 10;
    }

    .panel {
      background: rgba(61, 35, 20, 0.9);
      border: 3px solid #C9A962;
      border-radius: 15px;
      padding: 15px 25px;
      color: #F5E6D3;
    }

    .panel-label {
      font-size: 0.75rem;
      text-transform: uppercase;
      letter-spacing: 1px;
      color: #C9A962;
      margin-bottom: 5px;
    }

    .panel-value {
      font-size: 1.8rem;
      font-weight: 700;
    }

    .gravy-meter {
      position: absolute;
      top: 100px;
      right: 20px;
      background: rgba(61, 35, 20, 0.9);
      border: 3px solid #C9A962;
      border-radius: 15px;
      padding: 15px;
      pointer-events: none;
      z-index: 10;
    }

    .gravy-label {
      font-size: 0.75rem;
      text-transform: uppercase;
      letter-spacing: 1px;
      color: #C9A962;
      margin-bottom: 8px;
      text-align: center;
    }

    .gravy-bar {
      width: 30px;
      height: 150px;
      background: #1a0f0a;
      border-radius: 15px;
      overflow: hidden;
      position: relative;
      border: 2px solid #5a3d2a;
    }

    .gravy-fill {
      position: absolute;
      bottom: 0;
      width: 100%;
      background: linear-gradient(180deg, #4a3728 0%, #2d1f14 100%);
      border-radius: 0 0 12px 12px;
      transition: height 0.1s;
    }

    .gravy-icon {
      text-align: center;
      font-size: 1.5rem;
      margin-top: 8px;
    }

    .start-screen, .game-over-screen {
      position: absolute;
      inset: 0;
      background: rgba(29, 17, 10, 0.95);
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      z-index: 100;
    }

    .title {
      font-family: 'Playfair Display', serif;
      font-size: 3rem;
      color: #C9A962;
      text-shadow: 3px 3px 0 #1a0f0a;
      text-align: center;
      margin-bottom: 10px;
    }

    .subtitle {
      color: #F5E6D3;
      font-size: 1.2rem;
      margin-bottom: 30px;
      text-align: center;
    }

    .pudding-preview {
      font-size: 4rem;
      margin-bottom: 20px;
    }

    .btn {
      background: linear-gradient(180deg, #C9A962 0%, #9a7d3d 100%);
      color: #1a0f0a;
      border: none;
      padding: 18px 50px;
      font-size: 1.3rem;
      font-family: 'Fredoka', sans-serif;
      font-weight: 600;
      border-radius: 50px;
      cursor: pointer;
      box-shadow: 0 6px 20px rgba(0,0,0,0.4);
      transition: transform 0.2s;
      pointer-events: auto;
    }

    .btn:hover {
      transform: translateY(-3px);
    }

    .btn:active {
      transform: translateY(0);
    }

    .instructions {
      color: rgba(245, 230, 211, 0.7);
      font-size: 0.9rem;
      margin-top: 25px;
      text-align: center;
      line-height: 1.6;
    }

    .final-stats {
      color: #F5E6D3;
      font-size: 1.3rem;
      margin-bottom: 25px;
      text-align: center;
    }

    .final-stats span {
      color: #C9A962;
      font-weight: 700;
    }

    .hidden {
      display: none !important;
    }

    .drop-hint {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      color: #C9A962;
      font-size: 1.5rem;
      opacity: 0;
      transition: opacity 0.3s;
      pointer-events: none;
      text-align: center;
      z-index: 5;
    }

    .drop-hint.show {
      opacity: 1;
    }

    .gravy-splash {
      position: absolute;
      font-size: 2rem;
      pointer-events: none;
      animation: splash 0.6s ease-out forwards;
      z-index: 20;
    }

    @keyframes splash {
      0% { transform: scale(0.5); opacity: 1; }
      100% { transform: scale(1.5) translateY(-30px); opacity: 0; }
    }

    .score-popup {
      position: absolute;
      font-size: 1.5rem;
      font-weight: 700;
      color: #C9A962;
      text-shadow: 2px 2px 0 #1a0f0a;
      pointer-events: none;
      animation: popup 0.8s ease-out forwards;
      z-index: 20;
    }

    @keyframes popup {
      0% { transform: scale(0.5); opacity: 1; }
      50% { transform: scale(1.2); }
      100% { transform: scale(1) translateY(-40px); opacity: 0; }
    }

    .back-link {
      position: fixed;
      bottom: 15px;
      left: 50%;
      transform: translateX(-50%);
      color: rgba(201, 169, 98, 0.6);
      text-decoration: none;
      font-size: 0.8rem;
      z-index: 50;
    }

    .back-link:hover {
      color: #C9A962;
    }

    @media (max-width: 600px) {
      .title {
        font-size: 2rem;
      }

      .panel {
        padding: 10px 15px;
      }

      .panel-value {
        font-size: 1.4rem;
      }

      .gravy-meter {
        top: 80px;
        padding: 10px;
      }

      .gravy-bar {
        height: 100px;
        width: 25px;
      }
    }
  </style>
</head>
<body>
  <canvas id="game"></canvas>

  <div class="ui">
    <div class="panel">
      <div class="panel-label">Score</div>
      <div class="panel-value" id="score">0</div>
    </div>
    <div class="panel">
      <div class="panel-label">Puddings</div>
      <div class="panel-value" id="puddings">0</div>
    </div>
  </div>

  <div class="gravy-meter">
    <div class="gravy-label">Gravy</div>
    <div class="gravy-bar">
      <div class="gravy-fill" id="gravyFill" style="height: 100%"></div>
    </div>
    <div class="gravy-icon">ðŸ«—</div>
  </div>

  <div class="drop-hint" id="dropHint">Click or Space to drop!</div>

  <div class="start-screen" id="startScreen">
    <div class="pudding-preview">ðŸ¥§</div>
    <h1 class="title">Yorkshire Pudding Stacker</h1>
    <p class="subtitle">Stack 'em high, drown 'em in gravy!</p>
    <button class="btn" id="startBtn">Start Stacking!</button>
    <p class="instructions">
      Move: Mouse or Arrow Keys<br>
      Drop Pudding: Click or Space<br>
      Pour Gravy: Hold G or Right-Click
    </p>
  </div>

  <div class="game-over-screen hidden" id="gameOverScreen">
    <div class="pudding-preview">ðŸ˜­</div>
    <h1 class="title">Tower Collapsed!</h1>
    <p class="final-stats">
      Puddings Stacked: <span id="finalPuddings">0</span><br>
      Total Score: <span id="finalScore">0</span>
    </p>
    <button class="btn" id="restartBtn">Try Again</button>
  </div>

  <a href="https://sloppy.live" class="back-link">sloppy.live</a>

  <script>
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');

    let width, height;
    let gameRunning = false;
    let score = 0;
    let puddingCount = 0;
    let gravy = 100;
    let gravyParticles = [];

    // Plate
    let plate = { x: 0, y: 0, width: 180, height: 25, baseY: 0 };

    // Current pudding being positioned
    let currentPudding = null;
    let puddings = []; // Stacked puddings

    // Physics
    const GRAVITY = 0.4;
    const FRICTION = 0.85;
    const BOUNCE = 0.3;

    // Input
    let mouseX = null;
    let pouringGravy = false;

    function resize() {
      width = window.innerWidth;
      height = window.innerHeight;
      canvas.width = width;
      canvas.height = height;
      plate.baseY = height - 100;
      plate.y = plate.baseY;
      plate.x = width / 2 - plate.width / 2;
    }

    // Yorkshire pudding class
    class Pudding {
      constructor(x, y) {
        this.x = x;
        this.y = y;
        this.width = 80 + Math.random() * 40;
        this.height = 35 + Math.random() * 15;
        this.vx = 0;
        this.vy = 0;
        this.rotation = 0;
        this.vr = 0;
        this.grounded = false;
        this.gravy = 0; // Gravy amount on this pudding
        this.wobble = 0;
        this.wobbleSpeed = 0;
      }

      update() {
        if (!this.grounded) {
          // Apply gravity
          this.vy += GRAVITY;
          this.y += this.vy;
          this.x += this.vx;
          this.rotation += this.vr;

          // Check landing
          this.checkLanding();
        } else {
          // Apply wobble physics
          this.wobbleSpeed += -this.wobble * 0.1;
          this.wobbleSpeed *= 0.95;
          this.wobble += this.wobbleSpeed;
          this.rotation = this.wobble * 0.1;

          // Check if fell off
          if (Math.abs(this.wobble) > 5) {
            this.grounded = false;
            this.vx = this.wobble * 2;
            this.vy = -5;
            this.vr = this.wobble * 0.05;
          }
        }

        // Bounds
        if (this.x < 0) {
          this.x = 0;
          this.vx *= -BOUNCE;
        }
        if (this.x + this.width > width) {
          this.x = width - this.width;
          this.vx *= -BOUNCE;
        }

        // Fell off bottom = game over
        if (this.y > height + 100 && this.grounded === false && puddings.includes(this)) {
          return true; // Signal game over
        }

        return false;
      }

      checkLanding() {
        // Get landing surface
        const landingY = this.getLandingY();
        const landingInfo = this.getLandingInfo();

        if (this.y + this.height >= landingY && this.vy > 0) {
          this.y = landingY - this.height;
          this.grounded = true;
          this.vy = 0;
          this.vx *= FRICTION;
          this.vr = 0;
          this.rotation = 0;

          // Calculate wobble based on landing position
          if (landingInfo.type === 'pudding') {
            const centerDiff = (this.x + this.width / 2) - (landingInfo.pudding.x + landingInfo.pudding.width / 2);
            this.wobble = centerDiff * 0.05;
            landingInfo.pudding.wobble += centerDiff * 0.03;
          }

          // Add to stack if not already
          if (!puddings.includes(this)) {
            puddings.push(this);
            puddingCount++;
            const points = 100 + puddingCount * 10;
            score += points;
            updateUI();
            showScorePopup(points, this.x + this.width / 2, this.y);

            // Spawn new pudding
            setTimeout(spawnPudding, 500);
          }
        }
      }

      getLandingY() {
        let landingY = plate.y;

        // Check other puddings
        puddings.forEach(p => {
          if (p === this) return;
          // Check if we're above this pudding
          if (this.x + this.width > p.x && this.x < p.x + p.width) {
            if (p.y < landingY && p.grounded) {
              landingY = p.y;
            }
          }
        });

        return landingY;
      }

      getLandingInfo() {
        let landingY = plate.y;
        let info = { type: 'plate', pudding: null };

        puddings.forEach(p => {
          if (p === this) return;
          if (this.x + this.width > p.x && this.x < p.x + p.width) {
            if (p.y < landingY && p.grounded) {
              landingY = p.y;
              info = { type: 'pudding', pudding: p };
            }
          }
        });

        return info;
      }

      draw() {
        ctx.save();
        ctx.translate(this.x + this.width / 2, this.y + this.height / 2);
        ctx.rotate(this.rotation);

        // Shadow
        ctx.fillStyle = 'rgba(0,0,0,0.2)';
        ctx.beginPath();
        ctx.ellipse(3, this.height / 2 - 5, this.width / 2, this.height / 4, 0, 0, Math.PI * 2);
        ctx.fill();

        // Pudding base (golden brown)
        const gradient = ctx.createRadialGradient(0, 0, 0, 0, 0, this.width / 2);
        gradient.addColorStop(0, '#D4A574');
        gradient.addColorStop(0.7, '#B8860B');
        gradient.addColorStop(1, '#8B6914');

        // Draw pudding shape (puffy bowl shape)
        ctx.fillStyle = gradient;
        ctx.beginPath();
        ctx.moveTo(-this.width / 2, this.height / 2);
        ctx.quadraticCurveTo(-this.width / 2 - 5, 0, -this.width / 3, -this.height / 2);
        ctx.quadraticCurveTo(0, -this.height / 2 - 10, this.width / 3, -this.height / 2);
        ctx.quadraticCurveTo(this.width / 2 + 5, 0, this.width / 2, this.height / 2);
        ctx.quadraticCurveTo(0, this.height / 2 + 5, -this.width / 2, this.height / 2);
        ctx.fill();

        // Inner bowl (darker)
        ctx.fillStyle = '#A67C52';
        ctx.beginPath();
        ctx.ellipse(0, -5, this.width / 3, this.height / 3, 0, 0, Math.PI * 2);
        ctx.fill();

        // Crispy edges highlight
        ctx.strokeStyle = '#DAA520';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(-this.width / 3, -this.height / 2);
        ctx.quadraticCurveTo(0, -this.height / 2 - 8, this.width / 3, -this.height / 2);
        ctx.stroke();

        // Gravy pool in the middle
        if (this.gravy > 0) {
          const gravySize = Math.min(this.gravy / 20, 1);
          ctx.fillStyle = '#3D2817';
          ctx.beginPath();
          ctx.ellipse(0, -5, this.width / 3 * gravySize, this.height / 4 * gravySize, 0, 0, Math.PI * 2);
          ctx.fill();

          // Gravy shine
          ctx.fillStyle = 'rgba(80, 50, 30, 0.6)';
          ctx.beginPath();
          ctx.ellipse(-5, -8, this.width / 6 * gravySize, this.height / 8 * gravySize, 0, 0, Math.PI * 2);
          ctx.fill();
        }

        ctx.restore();
      }
    }

    // Gravy particle
    class GravyParticle {
      constructor(x, y) {
        this.x = x;
        this.y = y;
        this.vy = 2 + Math.random() * 3;
        this.vx = (Math.random() - 0.5) * 2;
        this.size = 4 + Math.random() * 4;
        this.life = 1;
      }

      update() {
        this.vy += 0.3;
        this.y += this.vy;
        this.x += this.vx;

        // Check if hits a pudding
        for (let p of puddings) {
          if (p.grounded &&
              this.x > p.x && this.x < p.x + p.width &&
              this.y > p.y && this.y < p.y + p.height) {
            p.gravy += 0.5;
            score += 5;
            updateUI();
            return false;
          }
        }

        // Check if hits plate
        if (this.y > plate.y) {
          return false;
        }

        return this.y < height + 50;
      }

      draw() {
        ctx.fillStyle = '#3D2817';
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
        ctx.fill();

        ctx.fillStyle = '#5a3d2a';
        ctx.beginPath();
        ctx.arc(this.x - 1, this.y - 1, this.size * 0.5, 0, Math.PI * 2);
        ctx.fill();
      }
    }

    function spawnPudding() {
      if (!gameRunning) return;
      currentPudding = new Pudding(width / 2 - 50, 50);
      document.getElementById('dropHint').classList.add('show');
    }

    function dropPudding() {
      if (!currentPudding || !gameRunning) return;
      currentPudding.vy = 2;
      puddings.push(currentPudding);
      currentPudding = null;
      document.getElementById('dropHint').classList.remove('show');
    }

    function pourGravy() {
      if (gravy <= 0 || !gameRunning) return;

      gravy -= 0.5;
      updateGravyMeter();

      // Spawn gravy particles from top
      const pourX = mouseX || width / 2;
      for (let i = 0; i < 2; i++) {
        gravyParticles.push(new GravyParticle(
          pourX + (Math.random() - 0.5) * 30,
          50
        ));
      }
    }

    function updateUI() {
      document.getElementById('score').textContent = score;
      document.getElementById('puddings').textContent = puddingCount;
    }

    function updateGravyMeter() {
      document.getElementById('gravyFill').style.height = `${gravy}%`;
    }

    function showScorePopup(points, x, y) {
      const popup = document.createElement('div');
      popup.className = 'score-popup';
      popup.textContent = `+${points}`;
      popup.style.left = `${x}px`;
      popup.style.top = `${y}px`;
      document.body.appendChild(popup);
      setTimeout(() => popup.remove(), 800);
    }

    function showGravySplash(x, y) {
      const splash = document.createElement('div');
      splash.className = 'gravy-splash';
      splash.textContent = 'ðŸ«—';
      splash.style.left = `${x}px`;
      splash.style.top = `${y}px`;
      document.body.appendChild(splash);
      setTimeout(() => splash.remove(), 600);
    }

    function update() {
      if (!gameRunning) return;

      // Update plate position
      if (keys['ArrowLeft'] || keys['a']) {
        plate.x -= 6;
      }
      if (keys['ArrowRight'] || keys['d']) {
        plate.x += 6;
      }
      if (mouseX !== null && !currentPudding) {
        plate.x += (mouseX - plate.width / 2 - plate.x) * 0.1;
      }
      plate.x = Math.max(0, Math.min(width - plate.width, plate.x));

      // Update current pudding position (follows mouse/plate)
      if (currentPudding) {
        const targetX = mouseX !== null ? mouseX - currentPudding.width / 2 : plate.x + plate.width / 2 - currentPudding.width / 2;
        currentPudding.x += (targetX - currentPudding.x) * 0.15;
        currentPudding.x = Math.max(0, Math.min(width - currentPudding.width, currentPudding.x));
      }

      // Update stacked puddings
      for (let i = puddings.length - 1; i >= 0; i--) {
        const fell = puddings[i].update();
        if (fell && puddings.length > 1) {
          // Pudding fell off - game over if it was stacked
          gameOver();
          return;
        }
      }

      // Pour gravy
      if (pouringGravy) {
        pourGravy();
      }

      // Update gravy particles
      for (let i = gravyParticles.length - 1; i >= 0; i--) {
        if (!gravyParticles[i].update()) {
          gravyParticles.splice(i, 1);
        }
      }

      // Refill gravy slowly
      if (!pouringGravy && gravy < 100) {
        gravy += 0.1;
        updateGravyMeter();
      }
    }

    function draw() {
      // Clear with wood background
      ctx.fillStyle = '#4a3222';
      ctx.fillRect(0, 0, width, height);

      // Wood grain pattern
      ctx.strokeStyle = 'rgba(0,0,0,0.1)';
      ctx.lineWidth = 1;
      for (let i = 0; i < height; i += 20) {
        ctx.beginPath();
        ctx.moveTo(0, i + Math.sin(i * 0.1) * 5);
        ctx.lineTo(width, i + Math.sin(i * 0.1 + 2) * 5);
        ctx.stroke();
      }

      // Draw table surface
      ctx.fillStyle = '#3D2314';
      ctx.fillRect(0, height - 60, width, 60);
      ctx.fillStyle = '#2a1810';
      ctx.fillRect(0, height - 60, width, 5);

      // Draw plate
      drawPlate();

      // Draw stacked puddings
      puddings.forEach(p => p.draw());

      // Draw current pudding (being positioned)
      if (currentPudding) {
        ctx.globalAlpha = 0.8;
        currentPudding.draw();
        ctx.globalAlpha = 1;

        // Draw drop guide
        ctx.setLineDash([5, 5]);
        ctx.strokeStyle = 'rgba(201, 169, 98, 0.5)';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(currentPudding.x + currentPudding.width / 2, currentPudding.y + currentPudding.height);
        ctx.lineTo(currentPudding.x + currentPudding.width / 2, plate.y);
        ctx.stroke();
        ctx.setLineDash([]);
      }

      // Draw gravy particles
      gravyParticles.forEach(p => p.draw());

      // Draw gravy pouring stream
      if (pouringGravy && gravy > 0) {
        const pourX = mouseX || width / 2;
        ctx.strokeStyle = '#3D2817';
        ctx.lineWidth = 8;
        ctx.lineCap = 'round';
        ctx.beginPath();
        ctx.moveTo(pourX, 0);
        ctx.quadraticCurveTo(pourX + Math.sin(Date.now() / 100) * 10, 80, pourX, 120);
        ctx.stroke();

        ctx.strokeStyle = '#5a3d2a';
        ctx.lineWidth = 4;
        ctx.beginPath();
        ctx.moveTo(pourX - 2, 0);
        ctx.quadraticCurveTo(pourX - 2 + Math.sin(Date.now() / 100) * 8, 80, pourX - 2, 100);
        ctx.stroke();
      }
    }

    function drawPlate() {
      // Plate shadow
      ctx.fillStyle = 'rgba(0,0,0,0.3)';
      ctx.beginPath();
      ctx.ellipse(plate.x + plate.width / 2, plate.y + 15, plate.width / 2 + 15, 12, 0, 0, Math.PI * 2);
      ctx.fill();

      // Plate base
      ctx.fillStyle = '#E8E0D5';
      ctx.beginPath();
      ctx.ellipse(plate.x + plate.width / 2, plate.y + 5, plate.width / 2 + 10, 15, 0, 0, Math.PI * 2);
      ctx.fill();

      // Plate top
      ctx.fillStyle = '#F5F0E6';
      ctx.beginPath();
      ctx.ellipse(plate.x + plate.width / 2, plate.y, plate.width / 2 + 5, 10, 0, 0, Math.PI * 2);
      ctx.fill();

      // Plate inner
      ctx.fillStyle = '#FAFAFA';
      ctx.beginPath();
      ctx.ellipse(plate.x + plate.width / 2, plate.y - 2, plate.width / 2 - 10, 6, 0, 0, Math.PI * 2);
      ctx.fill();

      // Plate rim
      ctx.strokeStyle = '#C9C0B5';
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.ellipse(plate.x + plate.width / 2, plate.y, plate.width / 2 + 5, 10, 0, 0, Math.PI * 2);
      ctx.stroke();

      // Gold rim decoration
      ctx.strokeStyle = '#C9A962';
      ctx.lineWidth = 1;
      ctx.beginPath();
      ctx.ellipse(plate.x + plate.width / 2, plate.y - 1, plate.width / 2, 8, 0, 0, Math.PI * 2);
      ctx.stroke();
    }

    function gameLoop() {
      update();
      draw();
      requestAnimationFrame(gameLoop);
    }

    function startGame() {
      gameRunning = true;
      score = 0;
      puddingCount = 0;
      gravy = 100;
      puddings = [];
      gravyParticles = [];
      currentPudding = null;

      updateUI();
      updateGravyMeter();

      document.getElementById('startScreen').classList.add('hidden');
      document.getElementById('gameOverScreen').classList.add('hidden');

      setTimeout(spawnPudding, 500);
    }

    function gameOver() {
      gameRunning = false;
      currentPudding = null;
      document.getElementById('dropHint').classList.remove('show');
      document.getElementById('finalPuddings').textContent = puddingCount;
      document.getElementById('finalScore').textContent = score;
      document.getElementById('gameOverScreen').classList.remove('hidden');
    }

    // Input handling
    const keys = {};
    document.addEventListener('keydown', e => {
      keys[e.key] = true;
      if (e.key === ' ' || e.key === 'Enter') {
        e.preventDefault();
        if (!gameRunning) {
          startGame();
        } else {
          dropPudding();
        }
      }
      if (e.key === 'g' || e.key === 'G') {
        pouringGravy = true;
      }
    });

    document.addEventListener('keyup', e => {
      keys[e.key] = false;
      if (e.key === 'g' || e.key === 'G') {
        pouringGravy = false;
      }
    });

    canvas.addEventListener('mousemove', e => {
      mouseX = e.clientX;
    });

    canvas.addEventListener('mousedown', e => {
      if (e.button === 0) { // Left click
        dropPudding();
      } else if (e.button === 2) { // Right click
        pouringGravy = true;
      }
    });

    canvas.addEventListener('mouseup', e => {
      if (e.button === 2) {
        pouringGravy = false;
      }
    });

    canvas.addEventListener('contextmenu', e => e.preventDefault());

    canvas.addEventListener('touchstart', e => {
      e.preventDefault();
      mouseX = e.touches[0].clientX;
      if (e.touches.length === 2) {
        pouringGravy = true;
      }
    });

    canvas.addEventListener('touchmove', e => {
      e.preventDefault();
      mouseX = e.touches[0].clientX;
    });

    canvas.addEventListener('touchend', e => {
      if (e.touches.length === 0) {
        dropPudding();
        pouringGravy = false;
      }
    });

    // Buttons
    document.getElementById('startBtn').addEventListener('click', startGame);
    document.getElementById('restartBtn').addEventListener('click', startGame);

    // Init
    window.addEventListener('resize', resize);
    resize();
    gameLoop();
  </script>
<script src="/sloppy-header/sloppy-bar.js"></script>
<script src="/vibelib-extended.js"></script>
<script>
  // Compatibility Patch for Legacy Apps
  window.addEventListener("load", () => {
    if (window.SloppyKarma && window.VibeLib.Economy) {
      // Redirect old calls to new engine
      window.SloppyKarma.track = window.VibeLib.Economy.track;
    }
  });
</script>
</body>
</html>
