<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>NEON FLUID</title>
  <link rel="icon" href="https://emojicdn.elk.sh/ðŸ’§">
  <meta property="og:title" content="NEON FLUID">
  <meta property="og:description" content="Splash glowing liquid and control gravity">
  <meta property="og:image" content="https://app.sloppy.live/fluid-sim/og-image.png">
  <meta property="og:url" content="https://app.sloppy.live/fluid-sim">
  <link href="https://fonts.googleapis.com/css2?family=Rajdhani:wght@400;600;700&display=swap" rel="stylesheet">
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }

    :root {
      --cyan: #0ff;
      --magenta: #f0f;
      --purple: #a0f;
      --bg: #050510;
    }

    body {
      background: var(--bg);
      min-height: 100vh;
      font-family: 'Rajdhani', sans-serif;
      color: #fff;
      overflow: hidden;
      user-select: none;
    }

    #canvas {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      cursor: crosshair;
    }

    .ui {
      position: fixed;
      top: 20px;
      left: 50%;
      transform: translateX(-50%);
      z-index: 100;
      text-align: center;
    }

    h1 {
      font-size: 2em;
      font-weight: 700;
      letter-spacing: 8px;
      background: linear-gradient(90deg, var(--cyan), var(--magenta));
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
      text-shadow: 0 0 30px rgba(0, 255, 255, 0.5);
      margin-bottom: 15px;
    }

    .controls {
      display: flex;
      gap: 25px;
      align-items: center;
      justify-content: center;
      background: rgba(0, 0, 0, 0.6);
      padding: 15px 25px;
      border-radius: 30px;
      border: 1px solid rgba(0, 255, 255, 0.3);
      backdrop-filter: blur(10px);
      flex-wrap: wrap;
    }

    .control-group {
      display: flex;
      align-items: center;
      gap: 10px;
    }

    .control-group label {
      font-size: 0.85em;
      font-weight: 600;
      letter-spacing: 2px;
      color: var(--cyan);
      text-transform: uppercase;
    }

    .slider {
      -webkit-appearance: none;
      width: 120px;
      height: 6px;
      background: #222;
      border-radius: 3px;
      outline: none;
    }

    .slider::-webkit-slider-thumb {
      -webkit-appearance: none;
      width: 18px;
      height: 18px;
      background: var(--cyan);
      border-radius: 50%;
      cursor: pointer;
      box-shadow: 0 0 15px var(--cyan);
    }

    .slider.gravity::-webkit-slider-thumb {
      background: var(--magenta);
      box-shadow: 0 0 15px var(--magenta);
    }

    .slider.viscosity::-webkit-slider-thumb {
      background: var(--purple);
      box-shadow: 0 0 15px var(--purple);
    }

    .value-display {
      font-size: 0.9em;
      color: var(--cyan);
      min-width: 40px;
      text-align: left;
    }

    .value-display.gravity { color: var(--magenta); }
    .value-display.viscosity { color: var(--purple); }

    .btn {
      padding: 8px 16px;
      background: transparent;
      border: 2px solid var(--cyan);
      color: var(--cyan);
      font-family: inherit;
      font-size: 0.8em;
      font-weight: 600;
      letter-spacing: 1px;
      cursor: pointer;
      border-radius: 20px;
      transition: all 0.2s;
    }

    .btn:hover {
      background: var(--cyan);
      color: #000;
      box-shadow: 0 0 20px var(--cyan);
    }

    .btn.obstacle {
      border-color: #f80;
      color: #f80;
    }

    .btn.obstacle:hover {
      background: #f80;
      box-shadow: 0 0 20px #f80;
    }

    .btn.obstacle.active {
      background: #f80;
      color: #000;
      box-shadow: 0 0 20px #f80;
    }

    .color-picker {
      display: flex;
      gap: 6px;
    }

    .color-btn {
      width: 24px;
      height: 24px;
      border-radius: 50%;
      border: 2px solid transparent;
      cursor: pointer;
      transition: all 0.2s;
    }

    .color-btn:hover, .color-btn.active {
      transform: scale(1.2);
      border-color: #fff;
      box-shadow: 0 0 10px currentColor;
    }

    .color-btn.cyan { background: var(--cyan); }
    .color-btn.magenta { background: var(--magenta); }
    .color-btn.purple { background: var(--purple); }
    .color-btn.green { background: #0f0; }
    .color-btn.orange { background: #f80; }
    .color-btn.rainbow { background: linear-gradient(45deg, #f00, #ff0, #0f0, #0ff, #00f, #f0f); }

    .instructions {
      position: fixed;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      font-size: 0.8em;
      color: #666;
      letter-spacing: 1px;
      opacity: 1;
      transition: opacity 2s;
    }

    .instructions.fade {
      opacity: 0;
    }

    .backlink {
      position: fixed;
      bottom: 5px;
      right: 10px;
      color: #333;
      text-decoration: none;
      font-size: 0.6em;
      z-index: 100;
    }

    .particle-count {
      position: fixed;
      bottom: 20px;
      left: 20px;
      font-size: 0.75em;
      color: #444;
      letter-spacing: 1px;
    }

    @media (max-width: 700px) {
      h1 { font-size: 1.4em; letter-spacing: 4px; }
      .controls {
        gap: 15px;
        padding: 12px 18px;
        flex-direction: column;
      }
      .slider { width: 100px; }
      .control-group label { font-size: 0.75em; }
    }
  </style>
</head>
<body>
  <canvas id="canvas"></canvas>

  <div class="ui">
    <h1>NEON FLUID</h1>
    <div class="controls">
      <div class="control-group">
        <label>GRAVITY</label>
        <input type="range" class="slider gravity" id="gravity" min="-100" max="100" value="50">
        <span class="value-display gravity" id="gravityVal">0.5</span>
      </div>
      <div class="control-group">
        <label>VISCOSITY</label>
        <input type="range" class="slider viscosity" id="viscosity" min="0" max="100" value="20">
        <span class="value-display viscosity" id="viscosityVal">0.2</span>
      </div>
      <div class="control-group">
        <label>COLOR</label>
        <div class="color-picker">
          <div class="color-btn cyan active" data-color="cyan" onclick="setColor('cyan')"></div>
          <div class="color-btn magenta" data-color="magenta" onclick="setColor('magenta')"></div>
          <div class="color-btn purple" data-color="purple" onclick="setColor('purple')"></div>
          <div class="color-btn green" data-color="green" onclick="setColor('green')"></div>
          <div class="color-btn orange" data-color="orange" onclick="setColor('orange')"></div>
          <div class="color-btn rainbow" data-color="rainbow" onclick="setColor('rainbow')"></div>
        </div>
      </div>
      <button class="btn obstacle" id="addObstacleBtn" onclick="toggleObstacleMode()">+ OBSTACLE</button>
      <button class="btn" onclick="clearFluid()">CLEAR</button>
      <button class="btn" onclick="clearObstacles()">CLEAR OBS</button>
    </div>
  </div>

  <div class="instructions" id="instructions">CLICK & DRAG TO SPLASH FLUID | CLICK + OBSTACLE TO PLACE</div>
  <div class="particle-count" id="particleCount">PARTICLES: 0</div>

  <a href="https://sloppy.live" class="backlink">sloppy.live</a>

  <script>
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');

    let width, height;
    let particles = [];
    let obstacles = [];
    let mouseDown = false;
    let mouseX = 0, mouseY = 0;
    let lastMouseX = 0, lastMouseY = 0;
    let currentColor = 'cyan';
    let instructionsFaded = false;

    // Obstacle interaction state
    let obstacleMode = false;
    let draggingObstacle = null;
    let dragOffsetX = 0, dragOffsetY = 0;

    // Obstacle colors (neon)
    const obstacleColors = [
      { r: 255, g: 136, b: 0 },   // orange
      { r: 255, g: 0, b: 128 },   // pink
      { r: 0, g: 255, b: 128 },   // mint
      { r: 128, g: 0, b: 255 },   // violet
      { r: 255, g: 255, b: 0 }    // yellow
    ];

    const colors = {
      cyan: { r: 0, g: 255, b: 255 },
      magenta: { r: 255, g: 0, b: 255 },
      purple: { r: 170, g: 0, b: 255 },
      green: { r: 0, g: 255, b: 0 },
      orange: { r: 255, g: 136, b: 0 }
    };

    const MAX_PARTICLES = 3000;
    const PARTICLE_RADIUS = 8;

    class Particle {
      constructor(x, y, vx, vy, color) {
        this.x = x;
        this.y = y;
        this.vx = vx;
        this.vy = vy;
        this.color = color;
        this.life = 1;
        this.radius = PARTICLE_RADIUS + Math.random() * 4;
      }

      update(gravity, viscosity) {
        // Apply gravity
        this.vy += gravity;

        // Apply viscosity (damping)
        const damping = 1 - viscosity;
        this.vx *= damping;
        this.vy *= damping;

        // Update position
        this.x += this.vx;
        this.y += this.vy;

        // Bounce off walls
        if (this.x < this.radius) {
          this.x = this.radius;
          this.vx *= -0.6;
        }
        if (this.x > width - this.radius) {
          this.x = width - this.radius;
          this.vx *= -0.6;
        }
        if (this.y < this.radius) {
          this.y = this.radius;
          this.vy *= -0.6;
        }
        if (this.y > height - this.radius) {
          this.y = height - this.radius;
          this.vy *= -0.5;
          // Add friction on ground
          this.vx *= 0.95;
        }

        // Bounce off obstacles
        for (const obs of obstacles) {
          const dx = this.x - obs.x;
          const dy = this.y - obs.y;
          const dist = Math.sqrt(dx * dx + dy * dy);
          const minDist = this.radius + obs.radius;

          if (dist < minDist && dist > 0) {
            // Normalize direction
            const nx = dx / dist;
            const ny = dy / dist;

            // Push particle out
            this.x = obs.x + nx * minDist;
            this.y = obs.y + ny * minDist;

            // Reflect velocity
            const dot = this.vx * nx + this.vy * ny;
            this.vx = (this.vx - 2 * dot * nx) * 0.7;
            this.vy = (this.vy - 2 * dot * ny) * 0.7;
          }
        }

        // Slowly fade if too many particles
        if (particles.length > MAX_PARTICLES * 0.8) {
          this.life -= 0.002;
        }
      }

      draw() {
        const alpha = Math.min(1, this.life);
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.radius * alpha, 0, Math.PI * 2);
        ctx.fillStyle = `rgba(${this.color.r}, ${this.color.g}, ${this.color.b}, ${alpha * 0.8})`;
        ctx.fill();
      }
    }

    class Obstacle {
      constructor(x, y, radius) {
        this.x = x;
        this.y = y;
        this.radius = radius || 40 + Math.random() * 30;
        this.color = obstacleColors[Math.floor(Math.random() * obstacleColors.length)];
        this.pulsePhase = Math.random() * Math.PI * 2;
      }

      contains(px, py) {
        const dx = px - this.x;
        const dy = py - this.y;
        return Math.sqrt(dx * dx + dy * dy) <= this.radius;
      }

      draw() {
        // Pulsing glow effect
        const pulse = Math.sin(Date.now() / 500 + this.pulsePhase) * 0.2 + 0.8;

        // Outer glow
        ctx.shadowBlur = 30 * pulse;
        ctx.shadowColor = `rgb(${this.color.r}, ${this.color.g}, ${this.color.b})`;

        // Main circle with gradient
        const gradient = ctx.createRadialGradient(
          this.x - this.radius * 0.3, this.y - this.radius * 0.3, 0,
          this.x, this.y, this.radius
        );
        gradient.addColorStop(0, `rgba(${this.color.r}, ${this.color.g}, ${this.color.b}, 0.4)`);
        gradient.addColorStop(0.7, `rgba(${this.color.r}, ${this.color.g}, ${this.color.b}, 0.2)`);
        gradient.addColorStop(1, `rgba(${this.color.r}, ${this.color.g}, ${this.color.b}, 0.1)`);

        ctx.beginPath();
        ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
        ctx.fillStyle = gradient;
        ctx.fill();

        // Neon ring
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
        ctx.strokeStyle = `rgba(${this.color.r}, ${this.color.g}, ${this.color.b}, ${0.8 * pulse})`;
        ctx.lineWidth = 3;
        ctx.stroke();

        // Inner ring
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.radius * 0.7, 0, Math.PI * 2);
        ctx.strokeStyle = `rgba(${this.color.r}, ${this.color.g}, ${this.color.b}, ${0.3 * pulse})`;
        ctx.lineWidth = 1;
        ctx.stroke();

        ctx.shadowBlur = 0;
      }
    }

    function resize() {
      width = canvas.width = window.innerWidth;
      height = canvas.height = window.innerHeight;
    }

    function getGravity() {
      return parseFloat(document.getElementById('gravity').value) / 100;
    }

    function getViscosity() {
      return parseFloat(document.getElementById('viscosity').value) / 1000;
    }

    function getCurrentColor() {
      if (currentColor === 'rainbow') {
        const hue = (Date.now() / 20) % 360;
        return hslToRgb(hue, 100, 50);
      }
      return colors[currentColor];
    }

    function hslToRgb(h, s, l) {
      s /= 100;
      l /= 100;
      const k = n => (n + h / 30) % 12;
      const a = s * Math.min(l, 1 - l);
      const f = n => l - a * Math.max(-1, Math.min(k(n) - 3, Math.min(9 - k(n), 1)));
      return {
        r: Math.round(255 * f(0)),
        g: Math.round(255 * f(8)),
        b: Math.round(255 * f(4))
      };
    }

    function setColor(color) {
      currentColor = color;
      document.querySelectorAll('.color-btn').forEach(btn => {
        btn.classList.toggle('active', btn.dataset.color === color);
      });
    }

    function spawnParticles(x, y, vx, vy, count) {
      const color = getCurrentColor();
      for (let i = 0; i < count; i++) {
        if (particles.length >= MAX_PARTICLES) {
          // Remove oldest particles
          particles.shift();
        }

        const angle = Math.random() * Math.PI * 2;
        const speed = Math.random() * 3 + 1;
        const pvx = vx * 0.3 + Math.cos(angle) * speed;
        const pvy = vy * 0.3 + Math.sin(angle) * speed;

        particles.push(new Particle(
          x + (Math.random() - 0.5) * 20,
          y + (Math.random() - 0.5) * 20,
          pvx,
          pvy,
          { ...color }
        ));
      }
    }

    function clearFluid() {
      particles = [];
    }

    function clearObstacles() {
      obstacles = [];
    }

    function toggleObstacleMode() {
      obstacleMode = !obstacleMode;
      document.getElementById('addObstacleBtn').classList.toggle('active', obstacleMode);
      canvas.style.cursor = obstacleMode ? 'copy' : 'crosshair';
    }

    function getObstacleAt(x, y) {
      for (let i = obstacles.length - 1; i >= 0; i--) {
        if (obstacles[i].contains(x, y)) {
          return obstacles[i];
        }
      }
      return null;
    }

    function update() {
      const gravity = getGravity();
      const viscosity = getViscosity();

      // Spawn particles when dragging
      if (mouseDown) {
        const vx = (mouseX - lastMouseX) * 0.5;
        const vy = (mouseY - lastMouseY) * 0.5;
        spawnParticles(mouseX, mouseY, vx, vy, 5);
      }

      lastMouseX = mouseX;
      lastMouseY = mouseY;

      // Update particles
      for (let i = particles.length - 1; i >= 0; i--) {
        particles[i].update(gravity, viscosity);
        if (particles[i].life <= 0) {
          particles.splice(i, 1);
        }
      }

      // Simple particle interaction (push apart)
      for (let i = 0; i < particles.length; i++) {
        for (let j = i + 1; j < particles.length; j++) {
          const dx = particles[j].x - particles[i].x;
          const dy = particles[j].y - particles[i].y;
          const dist = Math.sqrt(dx * dx + dy * dy);
          const minDist = (particles[i].radius + particles[j].radius) * 0.8;

          if (dist < minDist && dist > 0) {
            const force = (minDist - dist) / dist * 0.03;
            const fx = dx * force;
            const fy = dy * force;

            particles[i].vx -= fx;
            particles[i].vy -= fy;
            particles[j].vx += fx;
            particles[j].vy += fy;
          }
        }
      }

      // Update particle count display
      document.getElementById('particleCount').textContent = `PARTICLES: ${particles.length}`;
    }

    function draw() {
      // Clear with fade effect
      ctx.fillStyle = 'rgba(5, 5, 16, 0.15)';
      ctx.fillRect(0, 0, width, height);

      // Draw obstacles first (behind particles)
      for (const obs of obstacles) {
        obs.draw();
      }

      // Enable glow
      ctx.shadowBlur = 20;

      // Draw particles
      for (const p of particles) {
        ctx.shadowColor = `rgb(${p.color.r}, ${p.color.g}, ${p.color.b})`;
        p.draw();
      }

      // Draw metaball-style blending
      ctx.globalCompositeOperation = 'lighter';
      ctx.shadowBlur = 30;

      for (const p of particles) {
        const gradient = ctx.createRadialGradient(p.x, p.y, 0, p.x, p.y, p.radius * 2);
        gradient.addColorStop(0, `rgba(${p.color.r}, ${p.color.g}, ${p.color.b}, ${p.life * 0.3})`);
        gradient.addColorStop(1, 'rgba(0, 0, 0, 0)');

        ctx.beginPath();
        ctx.arc(p.x, p.y, p.radius * 2, 0, Math.PI * 2);
        ctx.fillStyle = gradient;
        ctx.fill();
      }

      ctx.globalCompositeOperation = 'source-over';
      ctx.shadowBlur = 0;
    }

    function animate() {
      update();
      draw();
      requestAnimationFrame(animate);
    }

    // Event listeners
    function handleMouseDown(e) {
      const rect = canvas.getBoundingClientRect();
      mouseX = e.clientX - rect.left;
      mouseY = e.clientY - rect.top;
      lastMouseX = mouseX;
      lastMouseY = mouseY;

      // Check if clicking on an obstacle (for dragging)
      const clickedObstacle = getObstacleAt(mouseX, mouseY);

      if (clickedObstacle && !obstacleMode) {
        // Start dragging obstacle
        draggingObstacle = clickedObstacle;
        dragOffsetX = mouseX - clickedObstacle.x;
        dragOffsetY = mouseY - clickedObstacle.y;
        canvas.style.cursor = 'grabbing';
        return;
      }

      if (obstacleMode) {
        // Add new obstacle
        obstacles.push(new Obstacle(mouseX, mouseY));
        return;
      }

      // Normal fluid splash mode
      mouseDown = true;
      spawnParticles(mouseX, mouseY, 0, 0, 15);

      if (!instructionsFaded) {
        document.getElementById('instructions').classList.add('fade');
        instructionsFaded = true;
      }
    }

    function handleMouseMove(e) {
      const rect = canvas.getBoundingClientRect();
      mouseX = e.clientX - rect.left;
      mouseY = e.clientY - rect.top;

      // If dragging an obstacle, move it
      if (draggingObstacle) {
        draggingObstacle.x = mouseX - dragOffsetX;
        draggingObstacle.y = mouseY - dragOffsetY;
        return;
      }

      // Update cursor based on what's under it
      if (!mouseDown && !obstacleMode) {
        const hoverObstacle = getObstacleAt(mouseX, mouseY);
        canvas.style.cursor = hoverObstacle ? 'grab' : 'crosshair';
      }
    }

    function handleMouseUp() {
      mouseDown = false;
      if (draggingObstacle) {
        draggingObstacle = null;
        canvas.style.cursor = obstacleMode ? 'copy' : 'crosshair';
      }
    }

    canvas.addEventListener('mousedown', handleMouseDown);
    canvas.addEventListener('mousemove', handleMouseMove);
    canvas.addEventListener('mouseup', handleMouseUp);
    canvas.addEventListener('mouseleave', handleMouseUp);

    // Touch support
    canvas.addEventListener('touchstart', (e) => {
      e.preventDefault();
      const touch = e.touches[0];
      handleMouseDown({ clientX: touch.clientX, clientY: touch.clientY });
    }, { passive: false });

    canvas.addEventListener('touchmove', (e) => {
      e.preventDefault();
      const touch = e.touches[0];
      handleMouseMove({ clientX: touch.clientX, clientY: touch.clientY });
    }, { passive: false });

    canvas.addEventListener('touchend', (e) => {
      e.preventDefault();
      handleMouseUp();
    }, { passive: false });

    // Slider value displays
    document.getElementById('gravity').addEventListener('input', (e) => {
      document.getElementById('gravityVal').textContent = (e.target.value / 100).toFixed(1);
    });

    document.getElementById('viscosity').addEventListener('input', (e) => {
      document.getElementById('viscosityVal').textContent = (e.target.value / 100).toFixed(1);
    });

    window.addEventListener('resize', resize);

    // Initialize
    resize();
    animate();
  </script>
<script src="/sloppy-header/sloppy-bar.js"></script>
<script src="/vibelib-extended.js"></script>
<script>
  // Compatibility Patch for Legacy Apps
  window.addEventListener("load", () => {
    if (window.SloppyKarma && window.VibeLib.Economy) {
      // Redirect old calls to new engine
      window.SloppyKarma.track = window.VibeLib.Economy.track;
    }
  });
</script>
</body>
</html>
