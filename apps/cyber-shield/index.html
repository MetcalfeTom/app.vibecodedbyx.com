<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Cyber Shield</title>
  <link rel="icon" href="https://emojicdn.elk.sh/üõ°Ô∏è">
  <meta property="og:title" content="Cyber Shield">
  <meta property="og:description" content="Watch incoming pings splash against the mansion shield">
  <meta property="og:url" content="https://sloppy.live/cyber-shield">
  <meta property="og:image" content="https://emojicdn.elk.sh/üõ°Ô∏è?style=apple&size=512">
  <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&family=Share+Tech+Mono&display=swap" rel="stylesheet">
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body { background: #000; overflow: hidden; font-family: 'Share Tech Mono', monospace; }

    #canvas-container { position: fixed; top: 0; left: 0; width: 100%; height: 100%; }
    canvas { display: block; }

    .hud {
      position: fixed; top: 0; left: 0; width: 100%; padding: 20px;
      pointer-events: none; z-index: 100;
    }

    .title {
      font-family: 'Orbitron', sans-serif; font-size: 1.6rem; font-weight: 900;
      color: #00ffff; text-shadow: 0 0 20px #00ffff, 0 0 40px #00ffff;
      letter-spacing: 4px;
    }

    .subtitle { color: #666; font-size: 0.8rem; margin-top: 5px; }

    .dashboard {
      position: fixed; top: 20px; right: 20px;
      background: rgba(5, 10, 20, 0.9); border: 2px solid #00ffff;
      border-radius: 15px; padding: 20px; min-width: 240px; z-index: 100;
    }

    .dashboard h3 {
      font-family: 'Orbitron', sans-serif; color: #00ffff;
      font-size: 0.85rem; margin-bottom: 15px;
      text-shadow: 0 0 10px #00ffff; text-align: center;
    }

    .stat-row {
      display: flex; justify-content: space-between; align-items: center;
      padding: 8px 0; border-bottom: 1px solid rgba(0,255,255,0.2);
    }
    .stat-row:last-child { border-bottom: none; }

    .stat-label { color: #888; font-size: 0.75rem; }
    .stat-value {
      font-family: 'Orbitron', sans-serif; font-weight: 700;
      font-size: 1rem; color: #fff;
    }

    .threat-level {
      margin-top: 15px; padding: 12px; border-radius: 10px;
      text-align: center; font-family: 'Orbitron', sans-serif;
      font-weight: 700; font-size: 0.9rem;
    }
    .threat-low { background: rgba(0,255,136,0.2); color: #00ff88; border: 1px solid #00ff88; }
    .threat-medium { background: rgba(255,255,0,0.2); color: #ffff00; border: 1px solid #ffff00; }
    .threat-high { background: rgba(255,0,68,0.2); color: #ff0044; border: 1px solid #ff0044; }

    .shield-status {
      margin-top: 15px; text-align: center;
    }
    .shield-bar {
      height: 8px; background: rgba(0,255,255,0.2); border-radius: 4px;
      overflow: hidden; margin-top: 8px;
    }
    .shield-fill {
      height: 100%; background: linear-gradient(90deg, #00ffff, #00ff88);
      border-radius: 4px; transition: width 0.3s;
    }
    .shield-label { color: #00ffff; font-size: 0.7rem; }

    .ping-log {
      position: fixed; bottom: 20px; left: 20px;
      background: rgba(5, 10, 20, 0.9); border: 1px solid #ff00ff;
      border-radius: 10px; padding: 15px; width: 300px;
      max-height: 180px; overflow: hidden; z-index: 100;
    }
    .ping-log h4 {
      font-family: 'Orbitron', sans-serif; color: #ff00ff;
      font-size: 0.7rem; margin-bottom: 10px;
    }
    .ping-list { list-style: none; }
    .ping-item {
      font-size: 0.65rem; color: #aaa; padding: 4px 0;
      border-bottom: 1px solid rgba(255,0,255,0.1);
      animation: fadeIn 0.3s ease;
    }
    .ping-item .ip { color: #ff00ff; }
    .ping-item .status { color: #00ff88; }
    .ping-item .blocked { color: #ff0044; }

    @keyframes fadeIn { from { opacity: 0; transform: translateX(-10px); } to { opacity: 1; transform: translateX(0); } }

    .back-link {
      position: fixed; bottom: 20px; left: 50%; transform: translateX(-50%);
      color: #444; font-size: 0.7rem; text-decoration: none; z-index: 100;
    }
    .back-link:hover { color: #00ffff; }

    .scanlines {
      position: fixed; top: 0; left: 0; width: 100%; height: 100%;
      pointer-events: none; z-index: 9999;
      background: repeating-linear-gradient(0deg, rgba(0,0,0,0.03) 0px, rgba(0,0,0,0.03) 1px, transparent 1px, transparent 2px);
    }
  </style>
</head>
<body>
  <div id="canvas-container"></div>

  <div class="hud">
    <div class="title">CYBER SHIELD</div>
    <div class="subtitle">Mansion Defense System v2.0</div>
  </div>

  <div class="dashboard">
    <h3>üõ°Ô∏è SHIELD STATUS</h3>
    <div class="stat-row">
      <span class="stat-label">Pings Blocked</span>
      <span class="stat-value" id="pings-blocked">0</span>
    </div>
    <div class="stat-row">
      <span class="stat-label">Active Threats</span>
      <span class="stat-value" id="active-threats">0</span>
    </div>
    <div class="stat-row">
      <span class="stat-label">Ping Rate</span>
      <span class="stat-value" id="ping-rate">0/s</span>
    </div>
    <div class="stat-row">
      <span class="stat-label">Shield Uptime</span>
      <span class="stat-value" id="uptime">00:00:00</span>
    </div>
    <div class="shield-status">
      <span class="shield-label">SHIELD INTEGRITY</span>
      <div class="shield-bar">
        <div class="shield-fill" id="shield-fill" style="width: 100%"></div>
      </div>
    </div>
    <div class="threat-level threat-low" id="threat-level">THREAT: LOW</div>
  </div>

  <div class="ping-log">
    <h4>üì° INCOMING PING LOG</h4>
    <ul class="ping-list" id="ping-list"></ul>
  </div>

  <a href="https://sloppy.live" class="back-link">sloppy.live</a>
  <div class="scanlines"></div>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script>
    let scene, camera, renderer;
    let windows = [];
    let pings = [];
    let splashes = [];
    let stats = { blocked: 0, activeThreats: 0, pingsPerSecond: 0, startTime: Date.now() };
    let recentPings = [];

    // Fake IP generator
    function randomIP() {
      return `${Math.floor(Math.random()*255)}.${Math.floor(Math.random()*255)}.${Math.floor(Math.random()*255)}.${Math.floor(Math.random()*255)}`;
    }

    function init() {
      scene = new THREE.Scene();
      scene.background = new THREE.Color(0x050510);
      scene.fog = new THREE.FogExp2(0x050510, 0.02);

      camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
      camera.position.set(0, 2, 8);
      camera.lookAt(0, 2, 0);

      renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
      document.getElementById('canvas-container').appendChild(renderer.domElement);

      createMansionInterior();
      createWindows();
      createShieldDome();
      createAmbientParticles();

      // Start spawning pings
      spawnPing();

      window.addEventListener('resize', onResize);
      animate();
      updateDashboard();
    }

    function createMansionInterior() {
      // Floor
      const floorGeo = new THREE.PlaneGeometry(30, 30);
      const floorMat = new THREE.MeshBasicMaterial({ color: 0x0a0a15 });
      const floor = new THREE.Mesh(floorGeo, floorMat);
      floor.rotation.x = -Math.PI / 2;
      scene.add(floor);

      // Back wall with gothic texture
      const wallGeo = new THREE.PlaneGeometry(20, 10);
      const wallMat = new THREE.MeshBasicMaterial({ color: 0x0f0f1a });
      const wall = new THREE.Mesh(wallGeo, wallMat);
      wall.position.set(0, 5, -5);
      scene.add(wall);

      // Side walls
      const leftWall = new THREE.Mesh(new THREE.PlaneGeometry(15, 10), wallMat);
      leftWall.rotation.y = Math.PI / 2;
      leftWall.position.set(-10, 5, 0);
      scene.add(leftWall);

      const rightWall = new THREE.Mesh(new THREE.PlaneGeometry(15, 10), wallMat);
      rightWall.rotation.y = -Math.PI / 2;
      rightWall.position.set(10, 5, 0);
      scene.add(rightWall);
    }

    function createWindows() {
      const windowPositions = [
        { x: -6, y: 4, z: -4.9 },
        { x: 0, y: 4, z: -4.9 },
        { x: 6, y: 4, z: -4.9 }
      ];

      windowPositions.forEach((pos, i) => {
        const group = new THREE.Group();
        group.position.set(pos.x, pos.y, pos.z);

        // Window frame
        const frameGeo = new THREE.BoxGeometry(3.5, 5, 0.3);
        const frameMat = new THREE.MeshBasicMaterial({ color: 0x1a1a2e });
        const frame = new THREE.Mesh(frameGeo, frameMat);
        group.add(frame);

        // Window glass (shield surface)
        const glassGeo = new THREE.PlaneGeometry(3, 4.5);
        const glassMat = new THREE.MeshBasicMaterial({
          color: 0x00ffff,
          transparent: true,
          opacity: 0.15,
          side: THREE.DoubleSide
        });
        const glass = new THREE.Mesh(glassGeo, glassMat);
        glass.position.z = 0.2;
        glass.userData.isWindow = true;
        glass.userData.windowIndex = i;
        group.add(glass);
        windows.push(glass);

        // Window glow border
        const glowGeo = new THREE.EdgesGeometry(new THREE.PlaneGeometry(3.2, 4.7));
        const glowMat = new THREE.LineBasicMaterial({ color: 0x00ffff, transparent: true, opacity: 0.8 });
        const glow = new THREE.LineSegments(glowGeo, glowMat);
        glow.position.z = 0.25;
        group.add(glow);

        // Gothic arch top
        const archGeo = new THREE.RingGeometry(1.4, 1.6, 16, 1, 0, Math.PI);
        const archMat = new THREE.MeshBasicMaterial({ color: 0x1a1a2e, side: THREE.DoubleSide });
        const arch = new THREE.Mesh(archGeo, archMat);
        arch.position.set(0, 2.25, 0.1);
        group.add(arch);

        scene.add(group);
      });
    }

    function createShieldDome() {
      // Outer shield visualization
      const shieldGeo = new THREE.SphereGeometry(15, 32, 32, 0, Math.PI * 2, 0, Math.PI / 2);
      const shieldMat = new THREE.MeshBasicMaterial({
        color: 0x00ffff,
        transparent: true,
        opacity: 0.05,
        wireframe: true
      });
      const shield = new THREE.Mesh(shieldGeo, shieldMat);
      shield.position.y = 0;
      scene.add(shield);
    }

    function createAmbientParticles() {
      const particleCount = 100;
      const geometry = new THREE.BufferGeometry();
      const positions = new Float32Array(particleCount * 3);

      for (let i = 0; i < particleCount; i++) {
        positions[i * 3] = (Math.random() - 0.5) * 30;
        positions[i * 3 + 1] = Math.random() * 10;
        positions[i * 3 + 2] = (Math.random() - 0.5) * 20;
      }

      geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
      const material = new THREE.PointsMaterial({
        color: 0x00ffff, size: 0.1, transparent: true, opacity: 0.5
      });
      scene.add(new THREE.Points(geometry, material));
    }

    function spawnPing() {
      // Random origin from "outside"
      const angle = Math.random() * Math.PI * 2;
      const distance = 20 + Math.random() * 10;
      const height = 3 + Math.random() * 4;

      const ping = new THREE.Group();

      // Ping core (shooting star)
      const coreGeo = new THREE.SphereGeometry(0.15, 8, 8);
      const threatLevel = Math.random();
      let coreColor = 0x00ff88; // green - safe
      if (threatLevel > 0.7) coreColor = 0xff0044; // red - threat
      else if (threatLevel > 0.4) coreColor = 0xffff00; // yellow - caution

      const coreMat = new THREE.MeshBasicMaterial({ color: coreColor });
      const core = new THREE.Mesh(coreGeo, coreMat);
      ping.add(core);

      // Glow
      const glowGeo = new THREE.SphereGeometry(0.3, 8, 8);
      const glowMat = new THREE.MeshBasicMaterial({
        color: coreColor, transparent: true, opacity: 0.4
      });
      ping.add(new THREE.Mesh(glowGeo, glowMat));

      // Trail
      const trailGeo = new THREE.CylinderGeometry(0.02, 0.1, 2, 8);
      const trailMat = new THREE.MeshBasicMaterial({
        color: coreColor, transparent: true, opacity: 0.6
      });
      const trail = new THREE.Mesh(trailGeo, trailMat);
      trail.rotation.x = Math.PI / 2;
      trail.position.z = 1;
      ping.add(trail);

      // Position and target
      ping.position.set(
        Math.cos(angle) * distance,
        height,
        Math.sin(angle) * distance
      );

      // Target a random window
      const targetWindow = windows[Math.floor(Math.random() * windows.length)];
      const targetPos = new THREE.Vector3();
      targetWindow.getWorldPosition(targetPos);
      targetPos.x += (Math.random() - 0.5) * 2;
      targetPos.y += (Math.random() - 0.5) * 3;

      ping.userData = {
        velocity: new THREE.Vector3().subVectors(targetPos, ping.position).normalize().multiplyScalar(0.3 + Math.random() * 0.2),
        target: targetPos,
        threatLevel,
        color: coreColor,
        ip: randomIP()
      };

      // Look at target
      ping.lookAt(targetPos);

      scene.add(ping);
      pings.push(ping);

      // Log the ping
      addPingLog(ping.userData.ip, threatLevel > 0.7);

      // Schedule next ping
      const delay = 200 + Math.random() * 800;
      setTimeout(spawnPing, delay);
    }

    function createSplash(position, color) {
      const splash = new THREE.Group();
      splash.position.copy(position);

      // Splash particles
      const particleCount = 12;
      for (let i = 0; i < particleCount; i++) {
        const particleGeo = new THREE.SphereGeometry(0.08, 4, 4);
        const particleMat = new THREE.MeshBasicMaterial({
          color, transparent: true, opacity: 1
        });
        const particle = new THREE.Mesh(particleGeo, particleMat);

        const angle = (i / particleCount) * Math.PI * 2;
        const speed = 0.1 + Math.random() * 0.1;
        particle.userData.velocity = new THREE.Vector3(
          Math.cos(angle) * speed,
          (Math.random() - 0.3) * speed,
          Math.sin(angle) * speed * 0.3
        );
        splash.add(particle);
      }

      // Shockwave ring
      const ringGeo = new THREE.RingGeometry(0.1, 0.2, 16);
      const ringMat = new THREE.MeshBasicMaterial({
        color, transparent: true, opacity: 0.8, side: THREE.DoubleSide
      });
      const ring = new THREE.Mesh(ringGeo, ringMat);
      ring.userData.isRing = true;
      splash.add(ring);

      splash.userData = { age: 0, maxAge: 60 };
      scene.add(splash);
      splashes.push(splash);

      // Update stats
      stats.blocked++;
      stats.activeThreats = pings.length;
    }

    function addPingLog(ip, blocked) {
      const list = document.getElementById('ping-list');
      const item = document.createElement('li');
      item.className = 'ping-item';
      const time = new Date().toLocaleTimeString();
      item.innerHTML = `[${time}] <span class="ip">${ip}</span> ‚Üí <span class="${blocked ? 'blocked' : 'status'}">${blocked ? 'BLOCKED' : 'DEFLECTED'}</span>`;
      list.insertBefore(item, list.firstChild);

      while (list.children.length > 8) {
        list.removeChild(list.lastChild);
      }

      recentPings.push(Date.now());
    }

    function updateDashboard() {
      // Pings blocked
      document.getElementById('pings-blocked').textContent = stats.blocked.toLocaleString();

      // Active threats
      document.getElementById('active-threats').textContent = pings.length;

      // Ping rate
      const now = Date.now();
      recentPings = recentPings.filter(t => now - t < 1000);
      document.getElementById('ping-rate').textContent = recentPings.length + '/s';

      // Uptime
      const elapsed = Math.floor((now - stats.startTime) / 1000);
      const hours = Math.floor(elapsed / 3600).toString().padStart(2, '0');
      const mins = Math.floor((elapsed % 3600) / 60).toString().padStart(2, '0');
      const secs = (elapsed % 60).toString().padStart(2, '0');
      document.getElementById('uptime').textContent = `${hours}:${mins}:${secs}`;

      // Shield integrity (based on ping rate)
      const integrity = Math.max(50, 100 - recentPings.length * 5);
      document.getElementById('shield-fill').style.width = integrity + '%';

      // Threat level
      const threatEl = document.getElementById('threat-level');
      if (recentPings.length > 8) {
        threatEl.className = 'threat-level threat-high';
        threatEl.textContent = 'THREAT: HIGH';
      } else if (recentPings.length > 4) {
        threatEl.className = 'threat-level threat-medium';
        threatEl.textContent = 'THREAT: MEDIUM';
      } else {
        threatEl.className = 'threat-level threat-low';
        threatEl.textContent = 'THREAT: LOW';
      }

      setTimeout(updateDashboard, 100);
    }

    function animate() {
      requestAnimationFrame(animate);

      // Update pings
      for (let i = pings.length - 1; i >= 0; i--) {
        const ping = pings[i];
        ping.position.add(ping.userData.velocity);

        // Check if hit shield (near windows)
        const distToTarget = ping.position.distanceTo(ping.userData.target);
        if (distToTarget < 1) {
          createSplash(ping.position.clone(), ping.userData.color);
          scene.remove(ping);
          pings.splice(i, 1);
        }

        // Remove if too far
        if (ping.position.length() > 50) {
          scene.remove(ping);
          pings.splice(i, 1);
        }
      }

      // Update splashes
      for (let i = splashes.length - 1; i >= 0; i--) {
        const splash = splashes[i];
        splash.userData.age++;

        const progress = splash.userData.age / splash.userData.maxAge;

        splash.children.forEach(child => {
          if (child.userData.isRing) {
            child.scale.setScalar(1 + progress * 3);
            child.material.opacity = 0.8 * (1 - progress);
          } else if (child.userData.velocity) {
            child.position.add(child.userData.velocity);
            child.userData.velocity.multiplyScalar(0.95);
            child.material.opacity = 1 - progress;
          }
        });

        if (splash.userData.age >= splash.userData.maxAge) {
          scene.remove(splash);
          splashes.splice(i, 1);
        }
      }

      // Pulse window shields
      const time = performance.now() * 0.001;
      windows.forEach((w, i) => {
        w.material.opacity = 0.1 + Math.sin(time * 2 + i) * 0.05;
      });

      renderer.render(scene, camera);
    }

    function onResize() {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    }

    init();
  </script>
</body>
</html>
