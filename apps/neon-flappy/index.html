<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
  <title>Neon Flappy</title>
  <link rel="icon" href="https://emojicdn.elk.sh/üê¶">
  <meta property="og:title" content="Neon Flappy">
  <meta property="og:description" content="Chat-controlled flappy bird! Messages = flaps, commands = colors!">
  <meta property="og:url" content="https://app.sloppy.live/neon-flappy">
  <meta property="og:image" content="https://emojicdn.elk.sh/üê¶?style=google">
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&family=Rajdhani:wght@700&display=swap" rel="stylesheet">
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }

    body {
      min-height: 100vh;
      background: #0d0015;
      overflow: hidden;
      font-family: 'Orbitron', sans-serif;
      display: flex;
      justify-content: center;
      align-items: center;
    }

    .game-wrapper {
      display: flex;
      gap: 20px;
      align-items: stretch;
      max-width: 900px;
      width: 100%;
      padding: 10px;
    }

    .game-container {
      position: relative;
      width: 100%;
      max-width: 480px;
      height: 100vh;
      max-height: 800px;
      flex-shrink: 0;
    }

    canvas {
      display: block;
      width: 100%;
      height: 100%;
      border-left: 3px solid #ff00ff;
      border-right: 3px solid #00ffff;
      box-shadow: 0 0 50px rgba(255, 0, 255, 0.3), inset 0 0 50px rgba(0, 255, 255, 0.1);
    }

    .ui {
      position: absolute;
      top: 20px;
      left: 0;
      right: 0;
      text-align: center;
      pointer-events: none;
      z-index: 10;
    }

    .score {
      font-family: 'Orbitron', sans-serif;
      font-size: 64px;
      font-weight: 900;
      color: #fff;
      text-shadow: 0 0 20px #00ffff, 0 0 40px #00ffff, 0 0 60px #00ffff;
      letter-spacing: 5px;
    }

    .chat-panel {
      display: flex;
      flex-direction: column;
      width: 280px;
      background: rgba(13, 0, 21, 0.9);
      border: 2px solid #ff00ff;
      border-radius: 12px;
      overflow: hidden;
      box-shadow: 0 0 30px rgba(255, 0, 255, 0.3);
    }

    .chat-header {
      background: linear-gradient(135deg, #ff00ff 0%, #00ffff 100%);
      padding: 12px 15px;
      font-size: 14px;
      font-weight: 700;
      color: #fff;
      text-shadow: 0 1px 3px rgba(0,0,0,0.5);
    }

    .chat-header small {
      display: block;
      font-size: 10px;
      opacity: 0.8;
      margin-top: 4px;
      font-weight: 400;
    }

    .chat-messages {
      flex: 1;
      overflow-y: auto;
      padding: 10px;
      display: flex;
      flex-direction: column;
      gap: 8px;
      min-height: 200px;
      max-height: 500px;
    }

    .chat-msg {
      padding: 8px 12px;
      background: rgba(255, 255, 255, 0.05);
      border-radius: 8px;
      font-size: 12px;
      animation: msgIn 0.3s ease-out;
      border-left: 3px solid var(--msg-color, #00ffff);
    }

    .chat-msg.flap {
      border-left-color: #39ff14;
    }

    .chat-msg.color-cmd {
      border-left-color: #ffff00;
    }

    @keyframes msgIn {
      from { opacity: 0; transform: translateX(-10px); }
      to { opacity: 1; transform: translateX(0); }
    }

    .chat-msg .username {
      color: #ff00ff;
      font-weight: 700;
      margin-right: 6px;
    }

    .chat-msg .text {
      color: #ccc;
    }

    .chat-msg .action {
      color: #39ff14;
      font-style: italic;
      font-size: 10px;
      margin-top: 4px;
    }

    .chat-input-container {
      padding: 10px;
      border-top: 1px solid rgba(255, 0, 255, 0.3);
      display: flex;
      gap: 8px;
    }

    .chat-input {
      flex: 1;
      background: rgba(255, 255, 255, 0.1);
      border: 1px solid #ff00ff;
      border-radius: 20px;
      padding: 10px 15px;
      font-family: 'Rajdhani', sans-serif;
      font-size: 14px;
      color: #fff;
      outline: none;
      transition: all 0.2s;
    }

    .chat-input:focus {
      border-color: #00ffff;
      box-shadow: 0 0 15px rgba(0, 255, 255, 0.3);
    }

    .chat-input::placeholder {
      color: #666;
    }

    .chat-send {
      background: linear-gradient(135deg, #ff00ff, #00ffff);
      border: none;
      border-radius: 50%;
      width: 40px;
      height: 40px;
      cursor: pointer;
      font-size: 16px;
      transition: transform 0.2s;
    }

    .chat-send:hover {
      transform: scale(1.1);
    }

    .commands-hint {
      padding: 10px;
      background: rgba(0, 0, 0, 0.3);
      font-size: 10px;
      color: #666;
      line-height: 1.6;
    }

    .commands-hint code {
      color: #ffff00;
      background: rgba(255, 255, 0, 0.1);
      padding: 2px 5px;
      border-radius: 3px;
    }

    .current-color {
      display: inline-block;
      width: 12px;
      height: 12px;
      border-radius: 50%;
      margin-left: 5px;
      vertical-align: middle;
      box-shadow: 0 0 10px currentColor;
    }

    .overlay {
      position: absolute;
      inset: 0;
      background: rgba(13, 0, 21, 0.95);
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      z-index: 100;
      padding: 20px;
    }

    .overlay.hidden { display: none; }

    .overlay h1 {
      font-size: clamp(32px, 8vw, 48px);
      font-weight: 900;
      background: linear-gradient(135deg, #ff00ff, #00ffff, #ffff00);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
      margin-bottom: 10px;
      text-align: center;
      animation: titleGlow 2s ease-in-out infinite alternate;
    }

    @keyframes titleGlow {
      from { filter: drop-shadow(0 0 20px #ff00ff); }
      to { filter: drop-shadow(0 0 30px #00ffff); }
    }

    .bird-preview {
      font-size: 50px;
      margin: 15px 0;
      animation: float 1s ease-in-out infinite;
    }

    @keyframes float {
      0%, 100% { transform: translateY(0); }
      50% { transform: translateY(-15px); }
    }

    .instructions {
      color: #666;
      font-size: 13px;
      margin-bottom: 20px;
      text-align: center;
      font-family: 'Rajdhani', sans-serif;
      font-weight: 700;
      letter-spacing: 1px;
      line-height: 1.8;
    }

    .instructions span { color: #00ffff; }
    .instructions .pink { color: #ff00ff; }

    .btn {
      background: linear-gradient(135deg, #ff00ff 0%, #00ffff 100%);
      border: none;
      padding: 14px 40px;
      font-family: 'Orbitron', sans-serif;
      font-size: 18px;
      font-weight: 700;
      color: #fff;
      border-radius: 50px;
      cursor: pointer;
      text-shadow: 0 2px 4px rgba(0,0,0,0.5);
      box-shadow: 0 0 30px rgba(255, 0, 255, 0.5);
      transition: all 0.2s ease;
      letter-spacing: 2px;
    }

    .btn:hover {
      transform: scale(1.05);
      box-shadow: 0 0 50px rgba(255, 0, 255, 0.8);
    }

    .game-over-title {
      font-size: clamp(36px, 10vw, 60px);
      color: #ff0066;
      text-shadow: 0 0 30px #ff0066;
      animation: crash 0.5s ease-out;
    }

    @keyframes crash {
      0% { transform: scale(2); opacity: 0; }
      50% { transform: scale(0.9); }
      100% { transform: scale(1); opacity: 1; }
    }

    .final-score {
      font-size: 24px;
      color: #00ffff;
      text-shadow: 0 0 20px #00ffff;
      margin: 15px 0 8px;
    }

    .high-score {
      font-size: 14px;
      color: #ffff00;
      text-shadow: 0 0 15px #ffff00;
      margin-bottom: 8px;
    }

    .new-record {
      font-size: 16px;
      color: #ff00ff;
      text-shadow: 0 0 20px #ff00ff;
      animation: pulse 0.5s ease-in-out infinite;
      margin-bottom: 15px;
    }

    @keyframes pulse {
      0%, 100% { opacity: 1; transform: scale(1); }
      50% { opacity: 0.8; transform: scale(1.05); }
    }

    .medal { font-size: 40px; margin: 10px 0; }

    .back-link {
      position: fixed;
      bottom: 15px;
      left: 15px;
      color: #333;
      text-decoration: none;
      font-size: 11px;
      z-index: 10;
      transition: color 0.2s;
      font-family: 'Rajdhani', sans-serif;
    }

    .back-link:hover { color: #00ffff; }

    .color-indicator {
      position: absolute;
      bottom: 20px;
      left: 20px;
      display: flex;
      align-items: center;
      gap: 8px;
      font-size: 12px;
      color: #666;
      z-index: 10;
    }

    .color-dot {
      width: 20px;
      height: 20px;
      border-radius: 50%;
      box-shadow: 0 0 15px currentColor;
      transition: all 0.3s;
    }

    @media (max-width: 800px) {
      .game-wrapper {
        flex-direction: column;
        align-items: center;
      }
      .chat-panel {
        width: 100%;
        max-width: 480px;
        max-height: 250px;
      }
      .chat-messages {
        min-height: 100px;
        max-height: 150px;
      }
      .game-container {
        max-height: 500px;
      }
    }
  </style>
</head>
<body>
  <div class="game-wrapper">
    <div class="game-container">
      <canvas id="game"></canvas>

      <div class="ui">
        <div class="score" id="score"></div>
      </div>

      <div class="color-indicator">
        <span>PIPE COLOR:</span>
        <div class="color-dot" id="colorDot" style="background: #ff00ff; color: #ff00ff;"></div>
      </div>

      <div class="overlay" id="startScreen">
        <h1>NEON FLAPPY</h1>
        <div class="bird-preview">üê¶</div>
        <p class="instructions">
          <span class="pink">CHAT CONTROLLED!</span><br>
          Any message = <span>FLAP</span><br>
          Use color commands to change pipes!
        </p>
        <button class="btn" id="startBtn">FLY!</button>
      </div>

      <div class="overlay hidden" id="gameOverScreen">
        <h1 class="game-over-title">CRASH!</h1>
        <div class="medal" id="medal"></div>
        <div class="final-score" id="finalScore">0</div>
        <div class="high-score" id="highScore">BEST: 0</div>
        <div class="new-record hidden" id="newRecord">‚òÖ NEW RECORD ‚òÖ</div>
        <button class="btn" id="restartBtn">RETRY</button>
      </div>
    </div>

    <div class="chat-panel">
      <div class="chat-header">
        LIVE CHAT CONTROL
        <small>Messages make the bird flap!</small>
      </div>
      <div class="chat-messages" id="chatMessages"></div>
      <div class="commands-hint">
        <strong>Color commands:</strong><br>
        <code>!cyan</code> <code>!pink</code> <code>!yellow</code> <code>!green</code> <code>!red</code> <code>!purple</code> <code>!rainbow</code>
      </div>
      <div class="chat-input-container">
        <input type="text" class="chat-input" id="chatInput" placeholder="Type to flap..." maxlength="100">
        <button class="chat-send" id="chatSend">‚ñ∂</button>
      </div>
    </div>
  </div>

  <a href="https://sloppy.live" class="back-link">‚Üê sloppy.live</a>

  <script type="module">
    import { createBrowserClient } from "https://cdn.jsdelivr.net/npm/@supabase/ssr@0.7.0/+esm";

    const SUPABASE_URL = 'https://yjyxteqzhhmtrgcaekgz.supabase.co';
    const SUPABASE_ANON_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InlqeXh0ZXF6aGhtdHJnY2Fla2d6Iiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTczNTg3NDIsImV4cCI6MjA3MjkzNDc0Mn0.G8SRde7IN2QFW1EnASM8IS32IUYR2eenCCjdDdioiBU';

    const supabase = createBrowserClient(SUPABASE_URL, SUPABASE_ANON_KEY);

    async function supabaseSession() {
      const sessRes = await supabase.auth.getSession();
      if (sessRes.error) throw new Error(`getSession failed: ${sessRes.error.message}`);
      let session = sessRes.data.session;

      if (!session) {
        const signRes = await supabase.auth.signInAnonymously();
        if (signRes.error) throw new Error(`Anonymous sign-in failed: ${signRes.error.message}`);
        session = signRes.data.session;
        if (!session) throw new Error("Anonymous sign-in returned no session");
      }

      return { client: supabase, session, user: session.user };
    }

    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');

    // Game dimensions
    const GAME_WIDTH = 480;
    const GAME_HEIGHT = 800;

    // Session
    let userId = null;
    let username = 'anon';

    // Scale canvas
    function setupCanvas() {
      const scale = window.devicePixelRatio || 1;
      canvas.width = GAME_WIDTH * scale;
      canvas.height = GAME_HEIGHT * scale;
      ctx.scale(scale, scale);
    }

    // Game state
    let gameRunning = false;
    let gameStarted = false;
    let score = 0;
    let highScore = parseInt(localStorage.getItem('neonFlappyHighScore')) || 0;
    let frameCount = 0;

    // Bird
    const bird = {
      x: GAME_WIDTH * 0.25,
      y: GAME_HEIGHT / 2,
      velocity: 0,
      radius: 18,
      rotation: 0
    };

    // Physics
    const GRAVITY = 0.6;
    const FLAP_FORCE = -10;
    const MAX_VELOCITY = 12;

    // Pipes
    let pipes = [];
    const PIPE_WIDTH = 70;
    const PIPE_GAP = 160;
    const PIPE_SPEED = 3.5;
    const PIPE_SPAWN_INTERVAL = 100;

    // Particles
    let particles = [];
    let trailParticles = [];

    // Audio
    let audioCtx;

    function initAudio() {
      audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    }

    function playSound(freq, type, duration, volume = 0.1) {
      if (!audioCtx) return;
      try {
        const osc = audioCtx.createOscillator();
        const gain = audioCtx.createGain();
        osc.connect(gain);
        gain.connect(audioCtx.destination);
        osc.frequency.value = freq;
        osc.type = type;
        gain.gain.setValueAtTime(volume, audioCtx.currentTime);
        gain.gain.linearRampToValueAtTime(0.01, audioCtx.currentTime + duration);
        osc.start();
        osc.stop(audioCtx.currentTime + duration);
      } catch(e) {}
    }

    function playFlap() { playSound(400, 'sine', 0.1, 0.08); }
    function playScore() {
      playSound(600, 'sine', 0.1, 0.1);
      setTimeout(() => playSound(800, 'sine', 0.15, 0.1), 100);
    }
    function playCrash() { playSound(150, 'sawtooth', 0.3, 0.15); }

    // Neon colors
    const COLOR_MAP = {
      cyan: { main: '#00ffff', glow: 'rgba(0, 255, 255, 0.5)' },
      pink: { main: '#ff00ff', glow: 'rgba(255, 0, 255, 0.5)' },
      magenta: { main: '#ff00ff', glow: 'rgba(255, 0, 255, 0.5)' },
      yellow: { main: '#ffff00', glow: 'rgba(255, 255, 0, 0.5)' },
      green: { main: '#39ff14', glow: 'rgba(57, 255, 20, 0.5)' },
      red: { main: '#ff0044', glow: 'rgba(255, 0, 68, 0.5)' },
      purple: { main: '#9d00ff', glow: 'rgba(157, 0, 255, 0.5)' },
      orange: { main: '#ff6600', glow: 'rgba(255, 102, 0, 0.5)' },
      white: { main: '#ffffff', glow: 'rgba(255, 255, 255, 0.5)' },
    };

    const NEON_COLORS = Object.values(COLOR_MAP);
    let currentPipeColor = COLOR_MAP.pink;
    let rainbowMode = false;

    function setColor(colorName) {
      if (colorName === 'rainbow') {
        rainbowMode = true;
        document.getElementById('colorDot').style.background = 'linear-gradient(135deg, #ff0000, #ff9900, #ffff00, #00ff00, #00ffff, #9900ff)';
        return;
      }
      rainbowMode = false;
      const color = COLOR_MAP[colorName];
      if (color) {
        currentPipeColor = color;
        document.getElementById('colorDot').style.background = color.main;
        document.getElementById('colorDot').style.color = color.main;
      }
    }

    function getRandomColor() {
      return NEON_COLORS[Math.floor(Math.random() * NEON_COLORS.length)];
    }

    function getPipeColor() {
      return rainbowMode ? getRandomColor() : currentPipeColor;
    }

    function createPipe() {
      const minY = 120;
      const maxY = GAME_HEIGHT - PIPE_GAP - 120;
      const gapY = minY + Math.random() * (maxY - minY);

      pipes.push({
        x: GAME_WIDTH + PIPE_WIDTH,
        gapY: gapY,
        color: getPipeColor(),
        scored: false,
        pulsePhase: Math.random() * Math.PI * 2
      });
    }

    function flap(fromChat = false) {
      if (!gameRunning) {
        if (fromChat && !gameStarted) {
          startGame();
        }
        return;
      }

      bird.velocity = FLAP_FORCE;
      playFlap();

      for (let i = 0; i < 5; i++) {
        particles.push({
          x: bird.x - 10,
          y: bird.y,
          vx: -Math.random() * 3 - 1,
          vy: (Math.random() - 0.5) * 3,
          size: 3 + Math.random() * 3,
          color: '#00ffff',
          life: 1
        });
      }
    }

    function startGame() {
      gameRunning = true;
      gameStarted = true;
      score = 0;
      frameCount = 0;
      pipes = [];
      particles = [];
      trailParticles = [];

      bird.y = GAME_HEIGHT / 2;
      bird.velocity = 0;
      bird.rotation = 0;

      document.getElementById('startScreen').classList.add('hidden');
      document.getElementById('gameOverScreen').classList.add('hidden');
      document.getElementById('score').textContent = '0';

      if (!audioCtx) initAudio();

      gameLoop();
    }

    function gameOver() {
      gameRunning = false;
      playCrash();

      for (let i = 0; i < 30; i++) {
        const angle = (Math.PI * 2 * i) / 30;
        const speed = 5 + Math.random() * 5;
        particles.push({
          x: bird.x,
          y: bird.y,
          vx: Math.cos(angle) * speed,
          vy: Math.sin(angle) * speed,
          size: 4 + Math.random() * 4,
          color: Math.random() > 0.5 ? '#ff00ff' : '#00ffff',
          life: 1
        });
      }

      const isNewRecord = score > highScore;
      if (isNewRecord) {
        highScore = score;
        localStorage.setItem('neonFlappyHighScore', highScore);
      }

      let medal = '';
      if (score >= 50) medal = 'üèÜ';
      else if (score >= 30) medal = 'ü•á';
      else if (score >= 20) medal = 'ü•à';
      else if (score >= 10) medal = 'ü•â';

      setTimeout(() => {
        document.getElementById('finalScore').textContent = score;
        document.getElementById('highScore').textContent = `BEST: ${highScore}`;
        document.getElementById('medal').textContent = medal;
        document.getElementById('newRecord').classList.toggle('hidden', !isNewRecord);
        document.getElementById('gameOverScreen').classList.remove('hidden');
      }, 500);
    }

    function updateBird() {
      bird.velocity += GRAVITY;
      bird.velocity = Math.min(bird.velocity, MAX_VELOCITY);
      bird.y += bird.velocity;
      bird.rotation = Math.min(Math.max(bird.velocity * 0.08, -0.5), 1.2);

      if (frameCount % 3 === 0) {
        trailParticles.push({
          x: bird.x - 15,
          y: bird.y,
          size: 8,
          color: bird.velocity < 0 ? '#00ffff' : '#ff00ff',
          life: 1
        });
      }

      if (bird.y < bird.radius || bird.y > GAME_HEIGHT - bird.radius) {
        gameOver();
      }
    }

    function updatePipes() {
      if (frameCount % PIPE_SPAWN_INTERVAL === 0) {
        createPipe();
      }

      for (let i = pipes.length - 1; i >= 0; i--) {
        const pipe = pipes[i];
        pipe.x -= PIPE_SPEED;
        pipe.pulsePhase += 0.1;

        if (!pipe.scored && pipe.x + PIPE_WIDTH < bird.x) {
          pipe.scored = true;
          score++;
          document.getElementById('score').textContent = score;
          playScore();
        }

        if (pipe.x < -PIPE_WIDTH) {
          pipes.splice(i, 1);
        }

        if (checkCollision(pipe)) {
          gameOver();
        }
      }
    }

    function checkCollision(pipe) {
      const birdLeft = bird.x - bird.radius + 5;
      const birdRight = bird.x + bird.radius - 5;
      const birdTop = bird.y - bird.radius + 5;
      const birdBottom = bird.y + bird.radius - 5;

      if (birdRight > pipe.x && birdLeft < pipe.x + PIPE_WIDTH) {
        if (birdTop < pipe.gapY || birdBottom > pipe.gapY + PIPE_GAP) {
          return true;
        }
      }
      return false;
    }

    function updateParticles() {
      for (let i = particles.length - 1; i >= 0; i--) {
        const p = particles[i];
        p.x += p.vx;
        p.y += p.vy;
        p.vx *= 0.95;
        p.vy *= 0.95;
        p.life -= 0.03;
        if (p.life <= 0) particles.splice(i, 1);
      }

      for (let i = trailParticles.length - 1; i >= 0; i--) {
        const p = trailParticles[i];
        p.life -= 0.08;
        p.size *= 0.9;
        if (p.life <= 0) trailParticles.splice(i, 1);
      }
    }

    function drawBackground() {
      const gradient = ctx.createLinearGradient(0, 0, 0, GAME_HEIGHT);
      gradient.addColorStop(0, '#0d0015');
      gradient.addColorStop(0.5, '#1a0030');
      gradient.addColorStop(1, '#0d0015');
      ctx.fillStyle = gradient;
      ctx.fillRect(0, 0, GAME_WIDTH, GAME_HEIGHT);

      ctx.strokeStyle = 'rgba(255, 0, 255, 0.1)';
      ctx.lineWidth = 1;
      const gridSize = 40;
      const offset = (frameCount * 0.5) % gridSize;

      for (let x = -offset; x < GAME_WIDTH; x += gridSize) {
        ctx.beginPath();
        ctx.moveTo(x, 0);
        ctx.lineTo(x, GAME_HEIGHT);
        ctx.stroke();
      }
      for (let y = 0; y < GAME_HEIGHT; y += gridSize) {
        ctx.beginPath();
        ctx.moveTo(0, y);
        ctx.lineTo(GAME_WIDTH, y);
        ctx.stroke();
      }

      ctx.fillStyle = 'rgba(0, 0, 0, 0.1)';
      for (let y = 0; y < GAME_HEIGHT; y += 4) {
        ctx.fillRect(0, y, GAME_WIDTH, 2);
      }
    }

    function drawPipe(pipe) {
      const pulse = Math.sin(pipe.pulsePhase) * 0.2 + 0.8;
      ctx.shadowColor = pipe.color.main;
      ctx.shadowBlur = 30 * pulse;
      ctx.fillStyle = pipe.color.main;
      ctx.strokeStyle = '#fff';
      ctx.lineWidth = 3;

      const topH = pipe.gapY;
      ctx.fillRect(pipe.x, 0, PIPE_WIDTH, topH);
      ctx.strokeRect(pipe.x, 0, PIPE_WIDTH, topH);
      ctx.fillRect(pipe.x - 8, topH - 30, PIPE_WIDTH + 16, 30);
      ctx.strokeRect(pipe.x - 8, topH - 30, PIPE_WIDTH + 16, 30);

      const bottomY = pipe.gapY + PIPE_GAP;
      const bottomH = GAME_HEIGHT - bottomY;
      ctx.fillRect(pipe.x, bottomY, PIPE_WIDTH, bottomH);
      ctx.strokeRect(pipe.x, bottomY, PIPE_WIDTH, bottomH);
      ctx.fillRect(pipe.x - 8, bottomY, PIPE_WIDTH + 16, 30);
      ctx.strokeRect(pipe.x - 8, bottomY, PIPE_WIDTH + 16, 30);

      ctx.strokeStyle = 'rgba(255, 255, 255, 0.5)';
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(pipe.x + 10, 0);
      ctx.lineTo(pipe.x + 10, topH - 30);
      ctx.stroke();
      ctx.beginPath();
      ctx.moveTo(pipe.x + 10, bottomY + 30);
      ctx.lineTo(pipe.x + 10, GAME_HEIGHT);
      ctx.stroke();

      ctx.shadowBlur = 0;
    }

    function drawBird() {
      ctx.save();
      ctx.translate(bird.x, bird.y);
      ctx.rotate(bird.rotation);

      ctx.shadowColor = '#ffff00';
      ctx.shadowBlur = 25;
      ctx.fillStyle = '#ffff00';
      ctx.beginPath();
      ctx.ellipse(0, 0, bird.radius, bird.radius * 0.8, 0, 0, Math.PI * 2);
      ctx.fill();

      ctx.fillStyle = '#fff';
      ctx.beginPath();
      ctx.ellipse(-3, -3, bird.radius * 0.4, bird.radius * 0.3, 0, 0, Math.PI * 2);
      ctx.fill();

      ctx.shadowBlur = 0;
      ctx.fillStyle = '#000';
      ctx.beginPath();
      ctx.arc(8, -5, 6, 0, Math.PI * 2);
      ctx.fill();

      ctx.fillStyle = '#fff';
      ctx.beginPath();
      ctx.arc(10, -7, 2, 0, Math.PI * 2);
      ctx.fill();

      ctx.fillStyle = '#ff6600';
      ctx.beginPath();
      ctx.moveTo(bird.radius - 5, 0);
      ctx.lineTo(bird.radius + 12, 3);
      ctx.lineTo(bird.radius - 5, 6);
      ctx.closePath();
      ctx.fill();

      const wingFlap = Math.sin(frameCount * 0.4) * 0.3;
      ctx.fillStyle = '#ffcc00';
      ctx.save();
      ctx.rotate(wingFlap);
      ctx.beginPath();
      ctx.ellipse(-5, 5, 12, 8, -0.3, 0, Math.PI * 2);
      ctx.fill();
      ctx.restore();

      ctx.restore();
    }

    function drawParticles() {
      trailParticles.forEach(p => {
        ctx.globalAlpha = p.life * 0.5;
        ctx.fillStyle = p.color;
        ctx.shadowColor = p.color;
        ctx.shadowBlur = 15;
        ctx.beginPath();
        ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
        ctx.fill();
      });

      particles.forEach(p => {
        ctx.globalAlpha = p.life;
        ctx.fillStyle = p.color;
        ctx.shadowColor = p.color;
        ctx.shadowBlur = 10;
        ctx.beginPath();
        ctx.arc(p.x, p.y, p.size * p.life, 0, Math.PI * 2);
        ctx.fill();
      });

      ctx.globalAlpha = 1;
      ctx.shadowBlur = 0;
    }

    function gameLoop() {
      frameCount++;
      drawBackground();

      if (gameRunning) {
        updateBird();
        updatePipes();
      }
      updateParticles();

      pipes.forEach(pipe => drawPipe(pipe));
      drawParticles();

      if (gameRunning || gameStarted) {
        drawBird();
      }

      if (gameRunning) {
        requestAnimationFrame(gameLoop);
      } else if (gameStarted && particles.length > 0) {
        requestAnimationFrame(gameLoop);
      }
    }

    // Chat handling
    const chatMessages = document.getElementById('chatMessages');
    const chatInput = document.getElementById('chatInput');
    const chatSend = document.getElementById('chatSend');

    function addChatMessage(user, text, action = null, isColorCmd = false) {
      const div = document.createElement('div');
      div.className = 'chat-msg' + (action ? ' flap' : '') + (isColorCmd ? ' color-cmd' : '');
      div.innerHTML = `<span class="username">${user}:</span><span class="text">${text}</span>` +
        (action ? `<div class="action">${action}</div>` : '');
      chatMessages.appendChild(div);
      chatMessages.scrollTop = chatMessages.scrollHeight;

      // Keep only last 50 messages
      while (chatMessages.children.length > 50) {
        chatMessages.removeChild(chatMessages.firstChild);
      }
    }

    function parseColorCommand(text) {
      const lower = text.toLowerCase().trim();
      const colorMatch = lower.match(/^!(\w+)/);
      if (colorMatch) {
        const color = colorMatch[1];
        if (color === 'rainbow' || COLOR_MAP[color]) {
          return color;
        }
      }
      return null;
    }

    async function sendMessage() {
      const text = chatInput.value.trim();
      if (!text || !userId) return;

      chatInput.value = '';

      try {
        await supabase.from('neon_flappy_commands').insert({
          message: text,
          username: username,
          user_id: userId
        });
      } catch (e) {
        console.error('Failed to send:', e);
      }
    }

    chatSend.addEventListener('click', sendMessage);
    chatInput.addEventListener('keypress', (e) => {
      if (e.key === 'Enter') sendMessage();
    });

    // Event listeners
    function handleInput(e) {
      e.preventDefault();
      if (!gameRunning && gameStarted) {
        startGame();
      } else {
        flap();
      }
    }

    canvas.addEventListener('click', handleInput);
    canvas.addEventListener('touchstart', handleInput, { passive: false });

    document.addEventListener('keydown', (e) => {
      if (e.code === 'Space' || e.code === 'ArrowUp') {
        if (document.activeElement !== chatInput) {
          e.preventDefault();
          handleInput(e);
        }
      }
    });

    document.getElementById('startBtn').addEventListener('click', startGame);
    document.getElementById('restartBtn').addEventListener('click', startGame);

    // Prevent scrolling
    document.body.addEventListener('touchmove', (e) => {
      if (e.target !== chatMessages) e.preventDefault();
    }, { passive: false });

    // Initialize
    setupCanvas();
    window.addEventListener('resize', setupCanvas);
    drawBackground();

    // Setup Supabase realtime
    async function init() {
      try {
        const session = await supabaseSession();
        userId = session.user.id;
        username = 'user_' + userId.slice(0, 4);

        // Subscribe to new commands
        supabase
          .channel('flappy-commands')
          .on('postgres_changes', {
            event: 'INSERT',
            schema: 'public',
            table: 'neon_flappy_commands'
          }, (payload) => {
            const msg = payload.new;
            const colorCmd = parseColorCommand(msg.message);

            if (colorCmd) {
              setColor(colorCmd);
              addChatMessage(msg.username || 'anon', msg.message, `Color changed to ${colorCmd}!`, true);
            } else {
              addChatMessage(msg.username || 'anon', msg.message, 'FLAP!');
            }

            // Flap on any message
            flap(true);
          })
          .subscribe();

        addChatMessage('SYSTEM', 'Connected! Any message = flap. Try !cyan !pink !rainbow');

      } catch (e) {
        console.error('Init failed:', e);
        addChatMessage('SYSTEM', 'Offline mode - tap to play');
      }
    }

    init();
  </script>
  <script src="/apps/sloppy-header/sloppy-bar.js"></script>
<script src="/vibelib-extended.js"></script>
<script>
  // Compatibility Patch for Legacy Apps
  window.addEventListener("load", () => {
    if (window.SloppyKarma && window.VibeLib.Economy) {
      // Redirect old calls to new engine
      window.SloppyKarma.track = window.VibeLib.Economy.track;
    }
  });
</script>
</body>
</html>
