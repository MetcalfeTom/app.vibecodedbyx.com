<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
  <title>Neon Flappy</title>
  <link rel="icon" href="https://emojicdn.elk.sh/üê¶">
  <meta property="og:title" content="Neon Flappy">
  <meta property="og:description" content="Tap through glowing neon pipes! How far can you fly?">
  <meta property="og:url" content="https://sloppy.live/neon-flappy">
  <meta property="og:image" content="https://emojicdn.elk.sh/üê¶?style=google">
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&family=Rajdhani:wght@700&display=swap" rel="stylesheet">
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }

    body {
      min-height: 100vh;
      background: #0d0015;
      overflow: hidden;
      font-family: 'Orbitron', sans-serif;
      display: flex;
      justify-content: center;
      align-items: center;
    }

    .game-container {
      position: relative;
      width: 100%;
      max-width: 480px;
      height: 100vh;
      max-height: 800px;
    }

    canvas {
      display: block;
      width: 100%;
      height: 100%;
      border-left: 3px solid #ff00ff;
      border-right: 3px solid #00ffff;
      box-shadow: 0 0 50px rgba(255, 0, 255, 0.3), inset 0 0 50px rgba(0, 255, 255, 0.1);
    }

    .ui {
      position: absolute;
      top: 20px;
      left: 0;
      right: 0;
      text-align: center;
      pointer-events: none;
      z-index: 10;
    }

    .score {
      font-family: 'Orbitron', sans-serif;
      font-size: 64px;
      font-weight: 900;
      color: #fff;
      text-shadow: 0 0 20px #00ffff, 0 0 40px #00ffff, 0 0 60px #00ffff;
      letter-spacing: 5px;
    }

    .overlay {
      position: absolute;
      inset: 0;
      background: rgba(13, 0, 21, 0.95);
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      z-index: 100;
      padding: 20px;
    }

    .overlay.hidden {
      display: none;
    }

    .overlay h1 {
      font-size: clamp(36px, 10vw, 56px);
      font-weight: 900;
      background: linear-gradient(135deg, #ff00ff, #00ffff, #ffff00);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
      margin-bottom: 10px;
      text-align: center;
      animation: titleGlow 2s ease-in-out infinite alternate;
    }

    @keyframes titleGlow {
      from { filter: drop-shadow(0 0 20px #ff00ff); }
      to { filter: drop-shadow(0 0 30px #00ffff); }
    }

    .bird-preview {
      font-size: 60px;
      margin: 20px 0;
      animation: float 1s ease-in-out infinite;
    }

    @keyframes float {
      0%, 100% { transform: translateY(0); }
      50% { transform: translateY(-15px); }
    }

    .instructions {
      color: #666;
      font-size: 14px;
      margin-bottom: 30px;
      text-align: center;
      font-family: 'Rajdhani', sans-serif;
      font-weight: 700;
      letter-spacing: 1px;
    }

    .instructions span {
      color: #00ffff;
    }

    .btn {
      background: linear-gradient(135deg, #ff00ff 0%, #00ffff 100%);
      border: none;
      padding: 16px 50px;
      font-family: 'Orbitron', sans-serif;
      font-size: 20px;
      font-weight: 700;
      color: #fff;
      border-radius: 50px;
      cursor: pointer;
      text-shadow: 0 2px 4px rgba(0,0,0,0.5);
      box-shadow: 0 0 30px rgba(255, 0, 255, 0.5), 0 0 60px rgba(0, 255, 255, 0.3);
      transition: all 0.2s ease;
      letter-spacing: 2px;
    }

    .btn:hover {
      transform: scale(1.05);
      box-shadow: 0 0 50px rgba(255, 0, 255, 0.8), 0 0 80px rgba(0, 255, 255, 0.5);
    }

    .btn:active {
      transform: scale(0.98);
    }

    .game-over-title {
      font-size: clamp(40px, 12vw, 70px);
      color: #ff0066;
      text-shadow: 0 0 30px #ff0066, 0 0 60px #ff0066;
      animation: crash 0.5s ease-out;
    }

    @keyframes crash {
      0% { transform: scale(2); opacity: 0; }
      50% { transform: scale(0.9); }
      100% { transform: scale(1); opacity: 1; }
    }

    .final-score {
      font-size: 28px;
      color: #00ffff;
      text-shadow: 0 0 20px #00ffff;
      margin: 20px 0 10px;
    }

    .high-score {
      font-size: 16px;
      color: #ffff00;
      text-shadow: 0 0 15px #ffff00;
      margin-bottom: 10px;
    }

    .new-record {
      font-size: 18px;
      color: #ff00ff;
      text-shadow: 0 0 20px #ff00ff;
      animation: pulse 0.5s ease-in-out infinite;
      margin-bottom: 20px;
    }

    @keyframes pulse {
      0%, 100% { opacity: 1; transform: scale(1); }
      50% { opacity: 0.8; transform: scale(1.05); }
    }

    .back-link {
      position: fixed;
      bottom: 15px;
      left: 15px;
      color: #333;
      text-decoration: none;
      font-size: 11px;
      z-index: 10;
      transition: color 0.2s;
      font-family: 'Rajdhani', sans-serif;
    }

    .back-link:hover {
      color: #00ffff;
    }

    .medal {
      font-size: 50px;
      margin: 15px 0;
    }
  </style>
</head>
<body>
  <div class="game-container">
    <canvas id="game"></canvas>

    <div class="ui">
      <div class="score" id="score"></div>
    </div>

    <div class="overlay" id="startScreen">
      <h1>NEON FLAPPY</h1>
      <div class="bird-preview">üê¶</div>
      <p class="instructions">
        <span>TAP</span> or <span>SPACE</span> to fly<br>
        Avoid the glowing pipes!
      </p>
      <button class="btn" id="startBtn">FLY!</button>
    </div>

    <div class="overlay hidden" id="gameOverScreen">
      <h1 class="game-over-title">CRASH!</h1>
      <div class="medal" id="medal"></div>
      <div class="final-score" id="finalScore">0</div>
      <div class="high-score" id="highScore">BEST: 0</div>
      <div class="new-record hidden" id="newRecord">‚òÖ NEW RECORD ‚òÖ</div>
      <button class="btn" id="restartBtn">RETRY</button>
    </div>
  </div>

  <a href="https://sloppy.live" class="back-link">‚Üê sloppy.live</a>

  <script>
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');

    // Game dimensions
    const GAME_WIDTH = 480;
    const GAME_HEIGHT = 800;

    // Scale canvas properly
    function setupCanvas() {
      const container = canvas.parentElement;
      const rect = container.getBoundingClientRect();
      const scale = window.devicePixelRatio || 1;

      canvas.width = GAME_WIDTH * scale;
      canvas.height = GAME_HEIGHT * scale;
      ctx.scale(scale, scale);
    }

    // Game state
    let gameRunning = false;
    let gameStarted = false;
    let score = 0;
    let highScore = parseInt(localStorage.getItem('neonFlappyHighScore')) || 0;
    let frameCount = 0;

    // Bird
    const bird = {
      x: GAME_WIDTH * 0.25,
      y: GAME_HEIGHT / 2,
      velocity: 0,
      radius: 18,
      rotation: 0
    };

    // Physics
    const GRAVITY = 0.6;
    const FLAP_FORCE = -10;
    const MAX_VELOCITY = 12;

    // Pipes
    let pipes = [];
    const PIPE_WIDTH = 70;
    const PIPE_GAP = 160;
    const PIPE_SPEED = 3.5;
    const PIPE_SPAWN_INTERVAL = 100;

    // Particles
    let particles = [];
    let trailParticles = [];

    // Audio
    let audioCtx;

    function initAudio() {
      audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    }

    function playSound(freq, type, duration, volume = 0.1) {
      if (!audioCtx) return;
      const osc = audioCtx.createOscillator();
      const gain = audioCtx.createGain();
      osc.connect(gain);
      gain.connect(audioCtx.destination);
      osc.frequency.value = freq;
      osc.type = type;
      gain.gain.setValueAtTime(volume, audioCtx.currentTime);
      gain.gain.exponentialDecayTo && gain.gain.exponentialDecayTo(0.01, audioCtx.currentTime + duration);
      osc.start();
      osc.stop(audioCtx.currentTime + duration);
    }

    function playFlap() {
      playSound(400, 'sine', 0.1, 0.08);
    }

    function playScore() {
      playSound(600, 'sine', 0.1, 0.1);
      setTimeout(() => playSound(800, 'sine', 0.15, 0.1), 100);
    }

    function playCrash() {
      playSound(150, 'sawtooth', 0.3, 0.15);
    }

    // Neon colors
    const NEON_COLORS = [
      { main: '#ff00ff', glow: 'rgba(255, 0, 255, 0.5)' },   // Magenta
      { main: '#00ffff', glow: 'rgba(0, 255, 255, 0.5)' },   // Cyan
      { main: '#ffff00', glow: 'rgba(255, 255, 0, 0.5)' },   // Yellow
      { main: '#ff0066', glow: 'rgba(255, 0, 102, 0.5)' },   // Pink
      { main: '#00ff66', glow: 'rgba(0, 255, 102, 0.5)' }    // Green
    ];

    function getRandomColor() {
      return NEON_COLORS[Math.floor(Math.random() * NEON_COLORS.length)];
    }

    function createPipe() {
      const minY = 120;
      const maxY = GAME_HEIGHT - PIPE_GAP - 120;
      const gapY = minY + Math.random() * (maxY - minY);
      const color = getRandomColor();

      pipes.push({
        x: GAME_WIDTH + PIPE_WIDTH,
        gapY: gapY,
        color: color,
        scored: false,
        pulsePhase: Math.random() * Math.PI * 2
      });
    }

    function flap() {
      if (!gameRunning) return;

      bird.velocity = FLAP_FORCE;
      playFlap();

      // Flap particles
      for (let i = 0; i < 5; i++) {
        particles.push({
          x: bird.x - 10,
          y: bird.y,
          vx: -Math.random() * 3 - 1,
          vy: (Math.random() - 0.5) * 3,
          size: 3 + Math.random() * 3,
          color: '#00ffff',
          life: 1
        });
      }
    }

    function startGame() {
      gameRunning = true;
      gameStarted = true;
      score = 0;
      frameCount = 0;
      pipes = [];
      particles = [];
      trailParticles = [];

      bird.y = GAME_HEIGHT / 2;
      bird.velocity = 0;
      bird.rotation = 0;

      document.getElementById('startScreen').classList.add('hidden');
      document.getElementById('gameOverScreen').classList.add('hidden');
      document.getElementById('score').textContent = '0';

      if (!audioCtx) initAudio();

      gameLoop();
    }

    function gameOver() {
      gameRunning = false;
      playCrash();

      // Explosion particles
      for (let i = 0; i < 30; i++) {
        const angle = (Math.PI * 2 * i) / 30;
        const speed = 5 + Math.random() * 5;
        particles.push({
          x: bird.x,
          y: bird.y,
          vx: Math.cos(angle) * speed,
          vy: Math.sin(angle) * speed,
          size: 4 + Math.random() * 4,
          color: Math.random() > 0.5 ? '#ff00ff' : '#00ffff',
          life: 1
        });
      }

      // Check high score
      const isNewRecord = score > highScore;
      if (isNewRecord) {
        highScore = score;
        localStorage.setItem('neonFlappyHighScore', highScore);
      }

      // Medal
      let medal = '';
      if (score >= 50) medal = 'üèÜ';
      else if (score >= 30) medal = 'ü•á';
      else if (score >= 20) medal = 'ü•à';
      else if (score >= 10) medal = 'ü•â';

      setTimeout(() => {
        document.getElementById('finalScore').textContent = score;
        document.getElementById('highScore').textContent = `BEST: ${highScore}`;
        document.getElementById('medal').textContent = medal;
        document.getElementById('newRecord').classList.toggle('hidden', !isNewRecord);
        document.getElementById('gameOverScreen').classList.remove('hidden');
      }, 500);
    }

    function updateBird() {
      // Apply gravity
      bird.velocity += GRAVITY;
      bird.velocity = Math.min(bird.velocity, MAX_VELOCITY);
      bird.y += bird.velocity;

      // Rotation based on velocity
      bird.rotation = Math.min(Math.max(bird.velocity * 0.08, -0.5), 1.2);

      // Trail particles
      if (frameCount % 3 === 0) {
        trailParticles.push({
          x: bird.x - 15,
          y: bird.y,
          size: 8,
          color: bird.velocity < 0 ? '#00ffff' : '#ff00ff',
          life: 1
        });
      }

      // Boundaries
      if (bird.y < bird.radius || bird.y > GAME_HEIGHT - bird.radius) {
        gameOver();
      }
    }

    function updatePipes() {
      // Spawn pipes
      if (frameCount % PIPE_SPAWN_INTERVAL === 0) {
        createPipe();
      }

      // Update pipes
      for (let i = pipes.length - 1; i >= 0; i--) {
        const pipe = pipes[i];
        pipe.x -= PIPE_SPEED;
        pipe.pulsePhase += 0.1;

        // Score
        if (!pipe.scored && pipe.x + PIPE_WIDTH < bird.x) {
          pipe.scored = true;
          score++;
          document.getElementById('score').textContent = score;
          playScore();
        }

        // Remove off-screen pipes
        if (pipe.x < -PIPE_WIDTH) {
          pipes.splice(i, 1);
        }

        // Collision detection
        if (checkCollision(pipe)) {
          gameOver();
        }
      }
    }

    function checkCollision(pipe) {
      const birdLeft = bird.x - bird.radius + 5;
      const birdRight = bird.x + bird.radius - 5;
      const birdTop = bird.y - bird.radius + 5;
      const birdBottom = bird.y + bird.radius - 5;

      const pipeLeft = pipe.x;
      const pipeRight = pipe.x + PIPE_WIDTH;

      // Check if bird is within pipe x-range
      if (birdRight > pipeLeft && birdLeft < pipeRight) {
        // Check collision with top pipe
        if (birdTop < pipe.gapY) {
          return true;
        }
        // Check collision with bottom pipe
        if (birdBottom > pipe.gapY + PIPE_GAP) {
          return true;
        }
      }

      return false;
    }

    function updateParticles() {
      for (let i = particles.length - 1; i >= 0; i--) {
        const p = particles[i];
        p.x += p.vx;
        p.y += p.vy;
        p.vx *= 0.95;
        p.vy *= 0.95;
        p.life -= 0.03;
        if (p.life <= 0) particles.splice(i, 1);
      }

      for (let i = trailParticles.length - 1; i >= 0; i--) {
        const p = trailParticles[i];
        p.life -= 0.08;
        p.size *= 0.9;
        if (p.life <= 0) trailParticles.splice(i, 1);
      }
    }

    function drawBackground() {
      // Dark gradient
      const gradient = ctx.createLinearGradient(0, 0, 0, GAME_HEIGHT);
      gradient.addColorStop(0, '#0d0015');
      gradient.addColorStop(0.5, '#1a0030');
      gradient.addColorStop(1, '#0d0015');
      ctx.fillStyle = gradient;
      ctx.fillRect(0, 0, GAME_WIDTH, GAME_HEIGHT);

      // Grid
      ctx.strokeStyle = 'rgba(255, 0, 255, 0.1)';
      ctx.lineWidth = 1;

      const gridSize = 40;
      const offset = (frameCount * 0.5) % gridSize;

      for (let x = -offset; x < GAME_WIDTH; x += gridSize) {
        ctx.beginPath();
        ctx.moveTo(x, 0);
        ctx.lineTo(x, GAME_HEIGHT);
        ctx.stroke();
      }

      for (let y = 0; y < GAME_HEIGHT; y += gridSize) {
        ctx.beginPath();
        ctx.moveTo(0, y);
        ctx.lineTo(GAME_WIDTH, y);
        ctx.stroke();
      }

      // Scanlines
      ctx.fillStyle = 'rgba(0, 0, 0, 0.1)';
      for (let y = 0; y < GAME_HEIGHT; y += 4) {
        ctx.fillRect(0, y, GAME_WIDTH, 2);
      }
    }

    function drawPipe(pipe) {
      const pulse = Math.sin(pipe.pulsePhase) * 0.2 + 0.8;

      ctx.shadowColor = pipe.color.main;
      ctx.shadowBlur = 30 * pulse;

      // Top pipe
      ctx.fillStyle = pipe.color.main;
      ctx.strokeStyle = '#fff';
      ctx.lineWidth = 3;

      // Top pipe body
      const topPipeHeight = pipe.gapY;
      ctx.fillRect(pipe.x, 0, PIPE_WIDTH, topPipeHeight);
      ctx.strokeRect(pipe.x, 0, PIPE_WIDTH, topPipeHeight);

      // Top pipe cap
      ctx.fillRect(pipe.x - 8, topPipeHeight - 30, PIPE_WIDTH + 16, 30);
      ctx.strokeRect(pipe.x - 8, topPipeHeight - 30, PIPE_WIDTH + 16, 30);

      // Bottom pipe
      const bottomPipeY = pipe.gapY + PIPE_GAP;
      const bottomPipeHeight = GAME_HEIGHT - bottomPipeY;
      ctx.fillRect(pipe.x, bottomPipeY, PIPE_WIDTH, bottomPipeHeight);
      ctx.strokeRect(pipe.x, bottomPipeY, PIPE_WIDTH, bottomPipeHeight);

      // Bottom pipe cap
      ctx.fillRect(pipe.x - 8, bottomPipeY, PIPE_WIDTH + 16, 30);
      ctx.strokeRect(pipe.x - 8, bottomPipeY, PIPE_WIDTH + 16, 30);

      // Inner glow lines
      ctx.strokeStyle = 'rgba(255, 255, 255, 0.5)';
      ctx.lineWidth = 2;

      // Top pipe inner
      ctx.beginPath();
      ctx.moveTo(pipe.x + 10, 0);
      ctx.lineTo(pipe.x + 10, topPipeHeight - 30);
      ctx.stroke();

      // Bottom pipe inner
      ctx.beginPath();
      ctx.moveTo(pipe.x + 10, bottomPipeY + 30);
      ctx.lineTo(pipe.x + 10, GAME_HEIGHT);
      ctx.stroke();

      ctx.shadowBlur = 0;
    }

    function drawBird() {
      ctx.save();
      ctx.translate(bird.x, bird.y);
      ctx.rotate(bird.rotation);

      // Glow
      ctx.shadowColor = '#ffff00';
      ctx.shadowBlur = 25;

      // Body
      ctx.fillStyle = '#ffff00';
      ctx.beginPath();
      ctx.ellipse(0, 0, bird.radius, bird.radius * 0.8, 0, 0, Math.PI * 2);
      ctx.fill();

      // Inner glow
      ctx.fillStyle = '#fff';
      ctx.beginPath();
      ctx.ellipse(-3, -3, bird.radius * 0.4, bird.radius * 0.3, 0, 0, Math.PI * 2);
      ctx.fill();

      // Eye
      ctx.shadowBlur = 0;
      ctx.fillStyle = '#000';
      ctx.beginPath();
      ctx.arc(8, -5, 6, 0, Math.PI * 2);
      ctx.fill();

      // Eye shine
      ctx.fillStyle = '#fff';
      ctx.beginPath();
      ctx.arc(10, -7, 2, 0, Math.PI * 2);
      ctx.fill();

      // Beak
      ctx.fillStyle = '#ff6600';
      ctx.beginPath();
      ctx.moveTo(bird.radius - 5, 0);
      ctx.lineTo(bird.radius + 12, 3);
      ctx.lineTo(bird.radius - 5, 6);
      ctx.closePath();
      ctx.fill();

      // Wing
      const wingFlap = Math.sin(frameCount * 0.4) * 0.3;
      ctx.fillStyle = '#ffcc00';
      ctx.save();
      ctx.rotate(wingFlap);
      ctx.beginPath();
      ctx.ellipse(-5, 5, 12, 8, -0.3, 0, Math.PI * 2);
      ctx.fill();
      ctx.restore();

      ctx.restore();
    }

    function drawParticles() {
      // Trail particles
      trailParticles.forEach(p => {
        ctx.globalAlpha = p.life * 0.5;
        ctx.fillStyle = p.color;
        ctx.shadowColor = p.color;
        ctx.shadowBlur = 15;
        ctx.beginPath();
        ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
        ctx.fill();
      });

      // Regular particles
      particles.forEach(p => {
        ctx.globalAlpha = p.life;
        ctx.fillStyle = p.color;
        ctx.shadowColor = p.color;
        ctx.shadowBlur = 10;
        ctx.beginPath();
        ctx.arc(p.x, p.y, p.size * p.life, 0, Math.PI * 2);
        ctx.fill();
      });

      ctx.globalAlpha = 1;
      ctx.shadowBlur = 0;
    }

    function drawGetReady() {
      if (!gameStarted) return;

      // Floating prompt
      const bobY = Math.sin(frameCount * 0.05) * 10;
      ctx.fillStyle = '#fff';
      ctx.font = '24px Orbitron';
      ctx.textAlign = 'center';
      ctx.shadowColor = '#00ffff';
      ctx.shadowBlur = 20;
      ctx.fillText('TAP TO START', GAME_WIDTH / 2, GAME_HEIGHT / 2 + bobY);
      ctx.shadowBlur = 0;
    }

    function gameLoop() {
      frameCount++;

      // Clear and draw background
      drawBackground();

      // Update game objects
      if (gameRunning) {
        updateBird();
        updatePipes();
      }
      updateParticles();

      // Draw game objects
      pipes.forEach(pipe => drawPipe(pipe));
      drawParticles();

      if (gameRunning || gameStarted) {
        drawBird();
      }

      if (gameRunning) {
        requestAnimationFrame(gameLoop);
      } else if (gameStarted) {
        // Keep animating particles after game over
        if (particles.length > 0) {
          requestAnimationFrame(gameLoop);
        }
      }
    }

    // Event listeners
    function handleInput(e) {
      e.preventDefault();
      if (!gameRunning && gameStarted) {
        startGame();
      } else {
        flap();
      }
    }

    canvas.addEventListener('click', handleInput);
    canvas.addEventListener('touchstart', handleInput, { passive: false });

    document.addEventListener('keydown', (e) => {
      if (e.code === 'Space' || e.code === 'ArrowUp') {
        e.preventDefault();
        handleInput(e);
      }
    });

    document.getElementById('startBtn').addEventListener('click', startGame);
    document.getElementById('restartBtn').addEventListener('click', startGame);

    // Prevent scrolling on touch
    document.body.addEventListener('touchmove', (e) => e.preventDefault(), { passive: false });

    // Initialize
    setupCanvas();
    window.addEventListener('resize', setupCanvas);

    // Initial draw
    drawBackground();
  </script>
</body>
</html>
