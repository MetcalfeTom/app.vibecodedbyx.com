<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
  <title>Farting Gorilla</title>
  <link rel="icon" href="https://emojicdn.elk.sh/ü¶ç">
  <meta name="description" content="HEY GUYS ITS ME FARTING GORILLA">
  <meta property="og:title" content="Farting Gorilla">
  <meta property="og:description" content="HEY GUYS ITS ME FARTING GORILLA">
  <meta property="og:image" content="https://emojicdn.elk.sh/ü¶ç?style=google">
  <meta property="og:url" content="https://sloppy.live/gorilla-fart">
  <style>
    @import url('https://fonts.googleapis.com/css2?family=Bangers&display=swap');

    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      background: #000;
      min-height: 100vh;
      display: flex;
      flex-direction: column;
      align-items: center;
      font-family: 'Bangers', cursive;
      overflow: hidden;
      touch-action: none;
    }

    header {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      padding: 10px;
      text-align: center;
      z-index: 100;
      background: linear-gradient(180deg, rgba(0,0,0,0.8) 0%, transparent 100%);
    }

    h1 {
      font-size: 1.8rem;
      color: #00ff88;
      text-shadow: 0 0 20px #00ff88, 0 0 40px #00ff44;
      letter-spacing: 3px;
    }

    .stats {
      color: #ffff00;
      font-size: 1.1rem;
      text-shadow: 0 0 10px #ffff00;
      margin-top: 5px;
    }

    #gameCanvas {
      display: block;
      cursor: none;
    }

    .instructions {
      position: fixed;
      bottom: 15px;
      left: 50%;
      transform: translateX(-50%);
      color: #00ffaa;
      font-size: 1rem;
      text-align: center;
      text-shadow: 0 0 10px #00ff88;
      z-index: 100;
    }

    .back-link {
      position: fixed;
      top: 10px;
      left: 10px;
      color: #00ff88;
      text-decoration: none;
      font-size: 0.9rem;
      opacity: 0.7;
      z-index: 101;
    }

    .win-screen {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: rgba(0, 20, 10, 0.95);
      border: 4px solid #00ff88;
      border-radius: 20px;
      padding: 40px 60px;
      text-align: center;
      z-index: 200;
      display: none;
      box-shadow: 0 0 60px #00ff8866;
    }

    .win-screen h2 {
      color: #00ff88;
      font-size: 2.5rem;
      text-shadow: 0 0 30px #00ff88;
      margin-bottom: 15px;
    }

    .win-screen p {
      color: #88ffaa;
      font-size: 1.3rem;
      margin-bottom: 25px;
    }

    .restart-btn {
      background: linear-gradient(180deg, #00ff88, #00aa55);
      border: none;
      color: #000;
      padding: 15px 40px;
      font-size: 1.3rem;
      font-family: 'Bangers', cursive;
      letter-spacing: 2px;
      border-radius: 30px;
      cursor: pointer;
      box-shadow: 0 0 30px #00ff8866;
      transition: transform 0.1s, box-shadow 0.1s;
    }

    .restart-btn:hover {
      transform: scale(1.05);
      box-shadow: 0 0 50px #00ff88aa;
    }
  </style>
</head>
<body>
  <a href="https://sloppy.live" class="back-link">‚Üê sloppy.live</a>

  <header>
    <h1>ü¶ç FARTING GORILLA üí®</h1>
    <div class="stats">Void Cleared: <span id="percent">0</span>% | Farts: <span id="farts">0</span></div>
  </header>

  <canvas id="gameCanvas"></canvas>

  <div class="instructions">Move mouse/finger to control gorilla - Click/tap to FART!</div>

  <div class="win-screen" id="winScreen">
    <h2>üéâ VOID CLEARED! üéâ</h2>
    <p>You farted <span id="totalFarts">0</span> times!</p>
    <button class="restart-btn" onclick="restartGame()">FART AGAIN!</button>
  </div>

  <script>
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');

    function resize() {
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
    }
    resize();
    window.addEventListener('resize', resize);

    // Audio context
    let audioCtx = null;

    function playFart() {
      if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();

      // Epic gorilla fart
      const osc = audioCtx.createOscillator();
      const osc2 = audioCtx.createOscillator();
      const gain = audioCtx.createGain();
      const filter = audioCtx.createBiquadFilter();

      osc.type = 'sawtooth';
      osc.frequency.setValueAtTime(80, audioCtx.currentTime);
      osc.frequency.exponentialRampToValueAtTime(40, audioCtx.currentTime + 0.2);
      osc.frequency.exponentialRampToValueAtTime(25, audioCtx.currentTime + 0.5);

      osc2.type = 'square';
      osc2.frequency.setValueAtTime(60, audioCtx.currentTime);
      osc2.frequency.exponentialRampToValueAtTime(30, audioCtx.currentTime + 0.3);

      filter.type = 'lowpass';
      filter.frequency.value = 300;
      filter.Q.value = 5;

      gain.gain.setValueAtTime(0.5, audioCtx.currentTime);
      gain.gain.exponentialRampToValueAtTime(0.3, audioCtx.currentTime + 0.2);
      gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.6);

      osc.connect(filter);
      osc2.connect(filter);
      filter.connect(gain);
      gain.connect(audioCtx.destination);

      osc.start();
      osc2.start();
      osc.stop(audioCtx.currentTime + 0.6);
      osc2.stop(audioCtx.currentTime + 0.6);

      // Add rumble
      const rumble = audioCtx.createOscillator();
      const rumbleGain = audioCtx.createGain();
      rumble.type = 'sine';
      rumble.frequency.value = 20;
      rumbleGain.gain.setValueAtTime(0.3, audioCtx.currentTime);
      rumbleGain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.4);
      rumble.connect(rumbleGain);
      rumbleGain.connect(audioCtx.destination);
      rumble.start();
      rumble.stop(audioCtx.currentTime + 0.4);
    }

    function playConstipationStrain() {
      if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();

      // Straining grunt sound
      const osc = audioCtx.createOscillator();
      const gain = audioCtx.createGain();
      const filter = audioCtx.createBiquadFilter();

      osc.type = 'sawtooth';
      osc.frequency.setValueAtTime(150, audioCtx.currentTime);
      osc.frequency.linearRampToValueAtTime(200, audioCtx.currentTime + 0.3);
      osc.frequency.linearRampToValueAtTime(120, audioCtx.currentTime + 0.6);

      filter.type = 'lowpass';
      filter.frequency.value = 400;

      gain.gain.setValueAtTime(0.3, audioCtx.currentTime);
      gain.gain.linearRampToValueAtTime(0.4, audioCtx.currentTime + 0.3);
      gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.8);

      osc.connect(filter);
      filter.connect(gain);
      gain.connect(audioCtx.destination);

      osc.start();
      osc.stop(audioCtx.currentTime + 0.8);
    }

    function playDeathScream() {
      if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();

      // Horrifying gorilla death scream
      for (let i = 0; i < 3; i++) {
        const osc = audioCtx.createOscillator();
        const gain = audioCtx.createGain();
        const filter = audioCtx.createBiquadFilter();

        osc.type = 'sawtooth';
        osc.frequency.setValueAtTime(300 + i * 100, audioCtx.currentTime + i * 0.5);
        osc.frequency.exponentialRampToValueAtTime(100, audioCtx.currentTime + i * 0.5 + 1);

        filter.type = 'lowpass';
        filter.frequency.value = 800;
        filter.Q.value = 5;

        gain.gain.setValueAtTime(0, audioCtx.currentTime + i * 0.5);
        gain.gain.linearRampToValueAtTime(0.5, audioCtx.currentTime + i * 0.5 + 0.1);
        gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + i * 0.5 + 1.5);

        osc.connect(filter);
        filter.connect(gain);
        gain.connect(audioCtx.destination);

        osc.start(audioCtx.currentTime + i * 0.5);
        osc.stop(audioCtx.currentTime + i * 0.5 + 1.5);
      }
    }

    function playDeathSplat() {
      if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();

      // Wet splat sound
      const bufferSize = audioCtx.sampleRate * 0.5;
      const buffer = audioCtx.createBuffer(1, bufferSize, audioCtx.sampleRate);
      const data = buffer.getChannelData(0);

      for (let i = 0; i < bufferSize; i++) {
        data[i] = (Math.random() * 2 - 1) * Math.exp(-i / (bufferSize * 0.1));
      }

      const noise = audioCtx.createBufferSource();
      noise.buffer = buffer;

      const filter = audioCtx.createBiquadFilter();
      filter.type = 'lowpass';
      filter.frequency.value = 500;

      const gain = audioCtx.createGain();
      gain.gain.setValueAtTime(0.6, audioCtx.currentTime);
      gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.5);

      noise.connect(filter);
      filter.connect(gain);
      gain.connect(audioCtx.destination);

      noise.start();
    }

    function playJumpscareSound() {
      if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();

      // Loud, terrifying jumpscare sound
      const osc1 = audioCtx.createOscillator();
      const osc2 = audioCtx.createOscillator();
      const osc3 = audioCtx.createOscillator();
      const gain = audioCtx.createGain();
      const distortion = audioCtx.createWaveShaper();

      // Create harsh distortion
      const curve = new Float32Array(256);
      for (let i = 0; i < 256; i++) {
        const x = (i / 128) - 1;
        curve[i] = Math.tanh(x * 10);
      }
      distortion.curve = curve;

      // Dissonant frequencies
      osc1.type = 'sawtooth';
      osc1.frequency.value = 180;
      osc2.type = 'square';
      osc2.frequency.value = 220;
      osc3.type = 'sawtooth';
      osc3.frequency.value = 440;

      gain.gain.setValueAtTime(0.8, audioCtx.currentTime);
      gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.5);

      osc1.connect(distortion);
      osc2.connect(distortion);
      osc3.connect(distortion);
      distortion.connect(gain);
      gain.connect(audioCtx.destination);

      osc1.start();
      osc2.start();
      osc3.start();
      osc1.stop(audioCtx.currentTime + 0.5);
      osc2.stop(audioCtx.currentTime + 0.5);
      osc3.stop(audioCtx.currentTime + 0.5);

      // Add a harsh noise burst
      const noiseBuffer = audioCtx.createBuffer(1, audioCtx.sampleRate * 0.3, audioCtx.sampleRate);
      const noiseData = noiseBuffer.getChannelData(0);
      for (let i = 0; i < noiseData.length; i++) {
        noiseData[i] = (Math.random() * 2 - 1);
      }
      const noise = audioCtx.createBufferSource();
      noise.buffer = noiseBuffer;
      const noiseGain = audioCtx.createGain();
      noiseGain.gain.setValueAtTime(0.6, audioCtx.currentTime);
      noiseGain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.3);
      noise.connect(noiseGain);
      noiseGain.connect(audioCtx.destination);
      noise.start();
    }

    // Blood particle system for death sequence
    function spawnBlood(x, y, amount = 20) {
      for (let i = 0; i < amount; i++) {
        const angle = Math.random() * Math.PI * 2;
        const speed = 2 + Math.random() * 8;
        bloodParticles.push({
          x: x,
          y: y,
          vx: Math.cos(angle) * speed,
          vy: Math.sin(angle) * speed - 3,
          size: 5 + Math.random() * 15,
          life: 1,
          color: Math.random() > 0.3 ? '#ff0000' : '#880000'
        });
      }
    }

    function updateBloodParticles() {
      for (let i = bloodParticles.length - 1; i >= 0; i--) {
        const p = bloodParticles[i];
        p.x += p.vx;
        p.y += p.vy;
        p.vy += 0.3;
        p.vx *= 0.99;
        p.life -= 0.008;
        if (p.life <= 0 || p.y > canvas.height + 50) {
          bloodParticles.splice(i, 1);
        }
      }
    }

    function drawBloodParticles() {
      bloodParticles.forEach(p => {
        ctx.save();
        ctx.globalAlpha = p.life;
        ctx.fillStyle = p.color;
        ctx.shadowColor = '#ff0000';
        ctx.shadowBlur = 10;
        ctx.beginPath();
        ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
        ctx.fill();
        ctx.restore();
      });
    }

    // Game state
    const gorilla = {
      x: 0,
      y: 0,
      targetX: 0,
      targetY: 0,
      size: 120,
      armAngle: 0,
      legAngle: 0
    };

    let voidPixels = [];
    let fartClouds = [];
    let projectiles = [];
    let bloodParticles = [];
    let fartCount = 0;
    let clearedPercent = 0;
    let gameWon = false;
    let throwTimer = 0;
    const VOID_SIZE = 20;

    // Constipation and death state
    let isConstipated = false;
    let constipationTimer = 0;
    let isDying = false;
    let deathTimer = 0;
    const DEATH_DURATION = 20 * 60; // 20 seconds at 60fps
    let isJumpscare = false;
    let jumpscareTimer = 0;
    const JUMPSCARE_DURATION = 90; // 1.5 seconds of flashing skeleton

    // Initialize void grid
    function initVoid() {
      voidPixels = [];
      const cols = Math.ceil(canvas.width / VOID_SIZE);
      const rows = Math.ceil(canvas.height / VOID_SIZE);

      for (let y = 0; y < rows; y++) {
        for (let x = 0; x < cols; x++) {
          voidPixels.push({
            x: x * VOID_SIZE,
            y: y * VOID_SIZE,
            alive: true,
            opacity: 1
          });
        }
      }
    }

    // Fart cloud class
    class FartCloud {
      constructor(x, y) {
        this.x = x;
        this.y = y;
        this.particles = [];
        this.maxRadius = 150;
        this.currentRadius = 0;
        this.expanding = true;

        // Create particles
        for (let i = 0; i < 30; i++) {
          const angle = Math.random() * Math.PI * 2;
          const speed = 2 + Math.random() * 5;
          this.particles.push({
            x: x,
            y: y,
            vx: Math.cos(angle) * speed,
            vy: Math.sin(angle) * speed,
            size: 20 + Math.random() * 40,
            life: 1,
            hue: 80 + Math.random() * 60 // Green to yellow
          });
        }
      }

      update() {
        if (this.expanding) {
          this.currentRadius += 15;
          if (this.currentRadius >= this.maxRadius) {
            this.expanding = false;
          }
        }

        // Clear void pixels in radius
        voidPixels.forEach(pixel => {
          if (pixel.alive) {
            const dx = (pixel.x + VOID_SIZE / 2) - this.x;
            const dy = (pixel.y + VOID_SIZE / 2) - this.y;
            const dist = Math.sqrt(dx * dx + dy * dy);

            if (dist < this.currentRadius) {
              pixel.alive = false;
              pixel.opacity = 0;
            }
          }
        });

        // Update particles
        this.particles.forEach(p => {
          p.x += p.vx;
          p.y += p.vy;
          p.vx *= 0.96;
          p.vy *= 0.96;
          p.vy -= 0.1; // Rise up
          p.life -= 0.02;
          p.size *= 1.02;
        });

        this.particles = this.particles.filter(p => p.life > 0);
        return this.particles.length > 0;
      }

      draw() {
        this.particles.forEach(p => {
          ctx.save();
          ctx.globalAlpha = p.life * 0.6;
          ctx.fillStyle = `hsl(${p.hue}, 100%, 50%)`;
          ctx.shadowColor = `hsl(${p.hue}, 100%, 50%)`;
          ctx.shadowBlur = 20;
          ctx.beginPath();
          ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
          ctx.fill();
          ctx.restore();
        });
      }
    }

    // Neon brown projectile class
    class Projectile {
      constructor(x, y, targetX, targetY) {
        this.x = x;
        this.y = y;
        const dx = targetX - x;
        const dy = targetY - y;
        const dist = Math.sqrt(dx * dx + dy * dy);
        const speed = 12;
        this.vx = (dx / dist) * speed;
        this.vy = (dy / dist) * speed;
        this.size = 15 + Math.random() * 10;
        this.rotation = Math.random() * Math.PI * 2;
        this.rotSpeed = (Math.random() - 0.5) * 0.3;
        this.trail = [];
      }

      update() {
        // Add trail
        this.trail.push({ x: this.x, y: this.y, size: this.size * 0.8 });
        if (this.trail.length > 8) this.trail.shift();

        this.x += this.vx;
        this.y += this.vy;
        this.vy += 0.2; // Gravity
        this.rotation += this.rotSpeed;

        // Clear void pixels on impact
        voidPixels.forEach(pixel => {
          if (pixel.alive) {
            const dx = (pixel.x + VOID_SIZE / 2) - this.x;
            const dy = (pixel.y + VOID_SIZE / 2) - this.y;
            const dist = Math.sqrt(dx * dx + dy * dy);
            if (dist < this.size + VOID_SIZE) {
              pixel.alive = false;
              pixel.opacity = 0;
            }
          }
        });

        // Remove if off screen
        return this.x > -50 && this.x < canvas.width + 50 && this.y < canvas.height + 50;
      }

      draw() {
        // Draw trail
        this.trail.forEach((t, i) => {
          const alpha = i / this.trail.length * 0.5;
          ctx.save();
          ctx.globalAlpha = alpha;
          ctx.fillStyle = '#8B4513';
          ctx.shadowColor = '#aa6633';
          ctx.shadowBlur = 10;
          ctx.beginPath();
          ctx.arc(t.x, t.y, t.size * (i / this.trail.length), 0, Math.PI * 2);
          ctx.fill();
          ctx.restore();
        });

        // Draw projectile
        ctx.save();
        ctx.translate(this.x, this.y);
        ctx.rotate(this.rotation);

        // Neon brown glow
        ctx.shadowColor = '#cc8844';
        ctx.shadowBlur = 20;

        // Main body
        ctx.fillStyle = '#8B4513';
        ctx.beginPath();
        ctx.ellipse(0, 0, this.size, this.size * 0.8, 0, 0, Math.PI * 2);
        ctx.fill();

        // Highlight
        ctx.fillStyle = '#a0522d';
        ctx.beginPath();
        ctx.ellipse(-this.size * 0.3, -this.size * 0.2, this.size * 0.4, this.size * 0.3, 0, 0, Math.PI * 2);
        ctx.fill();

        // Neon outline
        ctx.strokeStyle = '#ddaa66';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.ellipse(0, 0, this.size, this.size * 0.8, 0, 0, Math.PI * 2);
        ctx.stroke();

        ctx.restore();
      }
    }

    function throwProjectile() {
      if (gameWon) return;
      const startX = gorilla.x;
      const startY = gorilla.y - gorilla.size * 0.2;
      projectiles.push(new Projectile(startX, startY, gorilla.targetX, gorilla.targetY));
    }

    function drawGorilla() {
      const g = gorilla;
      ctx.save();
      ctx.translate(g.x, g.y);

      // Animate
      g.armAngle = Math.sin(Date.now() * 0.005) * 0.2;
      g.legAngle = Math.sin(Date.now() * 0.004) * 0.15;

      // Glow effect
      ctx.shadowColor = '#00ff88';
      ctx.shadowBlur = 40;

      // Body
      ctx.fillStyle = '#00dd66';
      ctx.beginPath();
      ctx.ellipse(0, 0, g.size * 0.5, g.size * 0.6, 0, 0, Math.PI * 2);
      ctx.fill();

      // Chest
      ctx.fillStyle = '#00ff88';
      ctx.beginPath();
      ctx.ellipse(0, g.size * 0.1, g.size * 0.3, g.size * 0.35, 0, 0, Math.PI * 2);
      ctx.fill();

      // Head
      ctx.fillStyle = '#00dd66';
      ctx.beginPath();
      ctx.arc(0, -g.size * 0.55, g.size * 0.35, 0, Math.PI * 2);
      ctx.fill();

      // Face
      ctx.fillStyle = '#00aa44';
      ctx.beginPath();
      ctx.ellipse(0, -g.size * 0.45, g.size * 0.2, g.size * 0.15, 0, 0, Math.PI * 2);
      ctx.fill();

      // Eyes
      ctx.fillStyle = '#ffffff';
      ctx.shadowColor = '#ffffff';
      ctx.shadowBlur = 10;
      ctx.beginPath();
      ctx.ellipse(-g.size * 0.12, -g.size * 0.6, g.size * 0.08, g.size * 0.1, 0, 0, Math.PI * 2);
      ctx.fill();
      ctx.beginPath();
      ctx.ellipse(g.size * 0.12, -g.size * 0.6, g.size * 0.08, g.size * 0.1, 0, 0, Math.PI * 2);
      ctx.fill();

      // Pupils
      ctx.fillStyle = '#000';
      ctx.shadowBlur = 0;
      ctx.beginPath();
      ctx.arc(-g.size * 0.12, -g.size * 0.58, g.size * 0.04, 0, Math.PI * 2);
      ctx.fill();
      ctx.beginPath();
      ctx.arc(g.size * 0.12, -g.size * 0.58, g.size * 0.04, 0, Math.PI * 2);
      ctx.fill();

      // Nostrils
      ctx.fillStyle = '#006633';
      ctx.beginPath();
      ctx.ellipse(-g.size * 0.06, -g.size * 0.42, g.size * 0.03, g.size * 0.04, 0, 0, Math.PI * 2);
      ctx.fill();
      ctx.beginPath();
      ctx.ellipse(g.size * 0.06, -g.size * 0.42, g.size * 0.03, g.size * 0.04, 0, 0, Math.PI * 2);
      ctx.fill();

      // Mouth (grin)
      ctx.strokeStyle = '#006633';
      ctx.lineWidth = 3;
      ctx.beginPath();
      ctx.arc(0, -g.size * 0.38, g.size * 0.1, 0.2, Math.PI - 0.2);
      ctx.stroke();

      // Arms
      ctx.fillStyle = '#00dd66';
      ctx.shadowColor = '#00ff88';
      ctx.shadowBlur = 20;

      // Left arm
      ctx.save();
      ctx.translate(-g.size * 0.45, -g.size * 0.1);
      ctx.rotate(-0.5 + g.armAngle);
      ctx.fillRect(-g.size * 0.12, 0, g.size * 0.24, g.size * 0.7);
      ctx.beginPath();
      ctx.arc(0, g.size * 0.7, g.size * 0.15, 0, Math.PI * 2);
      ctx.fill();
      ctx.restore();

      // Right arm
      ctx.save();
      ctx.translate(g.size * 0.45, -g.size * 0.1);
      ctx.rotate(0.5 - g.armAngle);
      ctx.fillRect(-g.size * 0.12, 0, g.size * 0.24, g.size * 0.7);
      ctx.beginPath();
      ctx.arc(0, g.size * 0.7, g.size * 0.15, 0, Math.PI * 2);
      ctx.fill();
      ctx.restore();

      // Legs
      // Left leg
      ctx.save();
      ctx.translate(-g.size * 0.2, g.size * 0.5);
      ctx.rotate(g.legAngle);
      ctx.fillRect(-g.size * 0.12, 0, g.size * 0.24, g.size * 0.4);
      ctx.beginPath();
      ctx.ellipse(0, g.size * 0.45, g.size * 0.18, g.size * 0.1, 0, 0, Math.PI * 2);
      ctx.fill();
      ctx.restore();

      // Right leg
      ctx.save();
      ctx.translate(g.size * 0.2, g.size * 0.5);
      ctx.rotate(-g.legAngle);
      ctx.fillRect(-g.size * 0.12, 0, g.size * 0.24, g.size * 0.4);
      ctx.beginPath();
      ctx.ellipse(0, g.size * 0.45, g.size * 0.18, g.size * 0.1, 0, 0, Math.PI * 2);
      ctx.fill();
      ctx.restore();

      // Butt (where farts come from!)
      ctx.fillStyle = '#00bb55';
      ctx.beginPath();
      ctx.ellipse(0, g.size * 0.55, g.size * 0.25, g.size * 0.15, 0, 0, Math.PI * 2);
      ctx.fill();

      ctx.restore();
    }

    function drawVoid() {
      voidPixels.forEach(pixel => {
        if (pixel.alive) {
          ctx.fillStyle = `rgba(0, 0, 0, ${pixel.opacity})`;
          ctx.fillRect(pixel.x, pixel.y, VOID_SIZE + 1, VOID_SIZE + 1);
        }
      });
    }

    function drawBackground() {
      // Colorful neon background revealed under void
      const gradient = ctx.createLinearGradient(0, 0, canvas.width, canvas.height);
      gradient.addColorStop(0, '#ff0066');
      gradient.addColorStop(0.25, '#ff6600');
      gradient.addColorStop(0.5, '#ffff00');
      gradient.addColorStop(0.75, '#00ffff');
      gradient.addColorStop(1, '#ff00ff');
      ctx.fillStyle = gradient;
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      // Add some stars/sparkles
      ctx.fillStyle = '#fff';
      for (let i = 0; i < 100; i++) {
        const x = (Math.sin(i * 123.456) * 0.5 + 0.5) * canvas.width;
        const y = (Math.cos(i * 789.012) * 0.5 + 0.5) * canvas.height;
        const size = 2 + Math.sin(Date.now() * 0.01 + i) * 2;
        ctx.beginPath();
        ctx.arc(x, y, size, 0, Math.PI * 2);
        ctx.fill();
      }
    }

    function updateStats() {
      const totalPixels = voidPixels.length;
      const clearedPixels = voidPixels.filter(p => !p.alive).length;
      clearedPercent = Math.round((clearedPixels / totalPixels) * 100);

      document.getElementById('percent').textContent = clearedPercent;
      document.getElementById('farts').textContent = fartCount;

      if (clearedPercent >= 95 && !gameWon) {
        gameWon = true;
        document.getElementById('totalFarts').textContent = fartCount;
        document.getElementById('winScreen').style.display = 'block';
      }
    }

    function doFart() {
      if (gameWon || isDying || isConstipated) return;

      // 1/50 chance of DEATH SEQUENCE
      if (Math.random() < 1/50) {
        triggerDeath();
        return;
      }

      // 1/20 chance of CONSTIPATION
      if (Math.random() < 1/20) {
        triggerConstipation();
        return;
      }

      fartCount++;
      playFart();

      // Create fart cloud at gorilla's butt
      const fartX = gorilla.x;
      const fartY = gorilla.y + gorilla.size * 0.6;
      fartClouds.push(new FartCloud(fartX, fartY));
    }

    function triggerConstipation() {
      isConstipated = true;
      constipationTimer = 90; // 1.5 seconds
      playConstipationStrain();
    }

    function triggerDeath() {
      isDying = true;
      deathTimer = 0;
      playDeathScream();
      playDeathSplat();
    }

    function updateDeathSequence() {
      if (!isDying) return;

      deathTimer++;

      // Spawn blood continuously during death
      if (deathTimer % 3 === 0) {
        spawnBlood(
          gorilla.x + (Math.random() - 0.5) * gorilla.size,
          gorilla.y + (Math.random() - 0.5) * gorilla.size,
          5
        );
      }

      // Periodic death sounds
      if (deathTimer % 120 === 0 && deathTimer < DEATH_DURATION - 60) {
        playDeathSplat();
      }

      // End death sequence after 20 seconds - trigger jumpscare
      if (deathTimer >= DEATH_DURATION && !isJumpscare) {
        isJumpscare = true;
        jumpscareTimer = 0;
        playJumpscareSound();
      }
    }

    function updateJumpscare() {
      if (!isJumpscare) return;

      jumpscareTimer++;

      // Play sound again partway through for extra terror
      if (jumpscareTimer === 30) {
        playJumpscareSound();
      }

      // End jumpscare and restart
      if (jumpscareTimer >= JUMPSCARE_DURATION) {
        isJumpscare = false;
        isDying = false;
        restartGame();
      }
    }

    function drawJumpscare() {
      if (!isJumpscare) return;

      const cx = canvas.width / 2;
      const cy = canvas.height / 2;

      // Flashing black/white background
      const flash = Math.floor(jumpscareTimer / 3) % 2 === 0;
      ctx.fillStyle = flash ? '#ffffff' : '#000000';
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      // Pixelated gorilla skeleton
      const pixelSize = 12;
      const skeletonPixels = [
        // Skull
        { x: -2, y: -5, c: '#ffffff' }, { x: -1, y: -5, c: '#ffffff' }, { x: 0, y: -5, c: '#ffffff' },
        { x: 1, y: -5, c: '#ffffff' }, { x: 2, y: -5, c: '#ffffff' },
        { x: -3, y: -4, c: '#ffffff' }, { x: -2, y: -4, c: '#ffffff' }, { x: -1, y: -4, c: '#000000' },
        { x: 0, y: -4, c: '#ffffff' }, { x: 1, y: -4, c: '#000000' }, { x: 2, y: -4, c: '#ffffff' },
        { x: 3, y: -4, c: '#ffffff' },
        { x: -3, y: -3, c: '#ffffff' }, { x: -2, y: -3, c: '#ffffff' }, { x: -1, y: -3, c: '#000000' },
        { x: 0, y: -3, c: '#ffffff' }, { x: 1, y: -3, c: '#000000' }, { x: 2, y: -3, c: '#ffffff' },
        { x: 3, y: -3, c: '#ffffff' },
        { x: -2, y: -2, c: '#ffffff' }, { x: -1, y: -2, c: '#ffffff' }, { x: 0, y: -2, c: '#333333' },
        { x: 1, y: -2, c: '#ffffff' }, { x: 2, y: -2, c: '#ffffff' },
        { x: -1, y: -1, c: '#ffffff' }, { x: 0, y: -1, c: '#000000' }, { x: 1, y: -1, c: '#ffffff' },

        // Teeth
        { x: -2, y: 0, c: '#ffffff' }, { x: -1, y: 0, c: '#000000' }, { x: 0, y: 0, c: '#ffffff' },
        { x: 1, y: 0, c: '#000000' }, { x: 2, y: 0, c: '#ffffff' },

        // Spine
        { x: 0, y: 1, c: '#dddddd' }, { x: 0, y: 2, c: '#dddddd' }, { x: 0, y: 3, c: '#dddddd' },
        { x: 0, y: 4, c: '#dddddd' },

        // Ribs
        { x: -2, y: 2, c: '#cccccc' }, { x: -1, y: 2, c: '#dddddd' }, { x: 1, y: 2, c: '#dddddd' },
        { x: 2, y: 2, c: '#cccccc' },
        { x: -3, y: 3, c: '#bbbbbb' }, { x: -2, y: 3, c: '#cccccc' }, { x: -1, y: 3, c: '#dddddd' },
        { x: 1, y: 3, c: '#dddddd' }, { x: 2, y: 3, c: '#cccccc' }, { x: 3, y: 3, c: '#bbbbbb' },
        { x: -2, y: 4, c: '#cccccc' }, { x: -1, y: 4, c: '#dddddd' }, { x: 1, y: 4, c: '#dddddd' },
        { x: 2, y: 4, c: '#cccccc' },

        // Arms (bones)
        { x: -4, y: 2, c: '#aaaaaa' }, { x: -5, y: 3, c: '#aaaaaa' }, { x: -6, y: 4, c: '#999999' },
        { x: 4, y: 2, c: '#aaaaaa' }, { x: 5, y: 3, c: '#aaaaaa' }, { x: 6, y: 4, c: '#999999' },

        // Pelvis
        { x: -1, y: 5, c: '#dddddd' }, { x: 0, y: 5, c: '#dddddd' }, { x: 1, y: 5, c: '#dddddd' },

        // Legs (bones)
        { x: -1, y: 6, c: '#cccccc' }, { x: -1, y: 7, c: '#bbbbbb' }, { x: -1, y: 8, c: '#aaaaaa' },
        { x: 1, y: 6, c: '#cccccc' }, { x: 1, y: 7, c: '#bbbbbb' }, { x: 1, y: 8, c: '#aaaaaa' },
      ];

      // Draw skeleton with shake effect
      const shake = (Math.random() - 0.5) * 15;
      skeletonPixels.forEach(p => {
        ctx.fillStyle = flash ? '#000000' : p.c;
        ctx.fillRect(
          cx + p.x * pixelSize + shake,
          cy + p.y * pixelSize + shake,
          pixelSize,
          pixelSize
        );
      });

      // Red eye glow in sockets
      ctx.fillStyle = '#ff0000';
      ctx.shadowColor = '#ff0000';
      ctx.shadowBlur = 20;
      ctx.beginPath();
      ctx.arc(cx - 1 * pixelSize + shake, cy - 3.5 * pixelSize + shake, 6, 0, Math.PI * 2);
      ctx.fill();
      ctx.beginPath();
      ctx.arc(cx + 1 * pixelSize + shake, cy - 3.5 * pixelSize + shake, 6, 0, Math.PI * 2);
      ctx.fill();
      ctx.shadowBlur = 0;
    }

    function drawDeathOverlay() {
      if (!isDying) return;

      const progress = deathTimer / DEATH_DURATION;

      // Final corpse phase (last 5 seconds)
      if (deathTimer > DEATH_DURATION - 300) {
        drawCorpseScreen();
        return;
      }

      // Dark red overlay
      ctx.fillStyle = `rgba(50, 0, 0, ${0.3 + progress * 0.5})`;
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      // Pulsing vignette
      const pulse = Math.sin(deathTimer * 0.1) * 0.2 + 0.8;
      const gradient = ctx.createRadialGradient(
        canvas.width / 2, canvas.height / 2, 0,
        canvas.width / 2, canvas.height / 2, canvas.width * 0.7
      );
      gradient.addColorStop(0, 'rgba(0, 0, 0, 0)');
      gradient.addColorStop(1, `rgba(100, 0, 0, ${pulse})`);
      ctx.fillStyle = gradient;
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      // Death text
      ctx.save();
      ctx.fillStyle = '#ff0000';
      ctx.shadowColor = '#ff0000';
      ctx.shadowBlur = 30;
      ctx.font = 'bold 48px Bangers';
      ctx.textAlign = 'center';

      const shake = isDying ? (Math.random() - 0.5) * 10 : 0;

      if (deathTimer < 180) {
        ctx.fillText('FATAL FART FAILURE', canvas.width / 2 + shake, canvas.height / 2 - 50);
      } else if (deathTimer < 360) {
        ctx.fillText('INTERNAL RUPTURE', canvas.width / 2 + shake, canvas.height / 2 - 50);
      } else if (deathTimer < 540) {
        ctx.fillText('CATASTROPHIC BLEEDING', canvas.width / 2 + shake, canvas.height / 2 - 50);
      } else if (deathTimer < 720) {
        ctx.fillText('ORGANS FAILING', canvas.width / 2 + shake, canvas.height / 2 - 50);
      } else if (deathTimer < 900) {
        ctx.fillText('GOODBYE GORILLA', canvas.width / 2 + shake, canvas.height / 2 - 50);
      } else {
        ctx.fillText('...', canvas.width / 2, canvas.height / 2 - 50);
      }

      // Timer countdown
      const remaining = Math.ceil((DEATH_DURATION - deathTimer) / 60);
      ctx.font = '24px Bangers';
      ctx.fillStyle = '#880000';
      ctx.fillText(`${remaining}s`, canvas.width / 2, canvas.height / 2 + 20);

      ctx.restore();
    }

    function drawCorpseScreen() {
      // Pure black background
      ctx.fillStyle = '#000000';
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      const cx = canvas.width / 2;
      const cy = canvas.height / 2;
      const pixelSize = 8;

      // Disturbing pixelated gorilla corpse
      const corpsePixels = [
        // Pool of blood underneath
        { x: -8, y: 6, c: '#440000' }, { x: -7, y: 6, c: '#550000' }, { x: -6, y: 6, c: '#660000' },
        { x: -5, y: 6, c: '#770000' }, { x: -4, y: 6, c: '#660000' }, { x: -3, y: 6, c: '#550000' },
        { x: -2, y: 6, c: '#660000' }, { x: -1, y: 6, c: '#770000' }, { x: 0, y: 6, c: '#880000' },
        { x: 1, y: 6, c: '#770000' }, { x: 2, y: 6, c: '#660000' }, { x: 3, y: 6, c: '#550000' },
        { x: 4, y: 6, c: '#660000' }, { x: 5, y: 6, c: '#770000' }, { x: 6, y: 6, c: '#660000' },
        { x: 7, y: 6, c: '#550000' }, { x: 8, y: 6, c: '#440000' },
        { x: -6, y: 7, c: '#330000' }, { x: -5, y: 7, c: '#440000' }, { x: -4, y: 7, c: '#550000' },
        { x: -3, y: 7, c: '#440000' }, { x: -2, y: 7, c: '#550000' }, { x: -1, y: 7, c: '#660000' },
        { x: 0, y: 7, c: '#770000' }, { x: 1, y: 7, c: '#660000' }, { x: 2, y: 7, c: '#550000' },
        { x: 3, y: 7, c: '#440000' }, { x: 4, y: 7, c: '#550000' }, { x: 5, y: 7, c: '#440000' },
        { x: 6, y: 7, c: '#330000' },

        // Collapsed body (dark green/grey - dead)
        { x: -4, y: 3, c: '#1a3322' }, { x: -3, y: 3, c: '#1a3322' }, { x: -2, y: 3, c: '#223828' },
        { x: -1, y: 3, c: '#223828' }, { x: 0, y: 3, c: '#223828' }, { x: 1, y: 3, c: '#223828' },
        { x: 2, y: 3, c: '#1a3322' }, { x: 3, y: 3, c: '#1a3322' }, { x: 4, y: 3, c: '#1a3322' },
        { x: -5, y: 4, c: '#152a1c' }, { x: -4, y: 4, c: '#1a3322' }, { x: -3, y: 4, c: '#223828' },
        { x: -2, y: 4, c: '#2a4430' }, { x: -1, y: 4, c: '#2a4430' }, { x: 0, y: 4, c: '#2a4430' },
        { x: 1, y: 4, c: '#2a4430' }, { x: 2, y: 4, c: '#223828' }, { x: 3, y: 4, c: '#1a3322' },
        { x: 4, y: 4, c: '#1a3322' }, { x: 5, y: 4, c: '#152a1c' },
        { x: -5, y: 5, c: '#152a1c' }, { x: -4, y: 5, c: '#1a3322' }, { x: -3, y: 5, c: '#1a3322' },
        { x: -2, y: 5, c: '#223828' }, { x: -1, y: 5, c: '#223828' }, { x: 0, y: 5, c: '#223828' },
        { x: 1, y: 5, c: '#223828' }, { x: 2, y: 5, c: '#1a3322' }, { x: 3, y: 5, c: '#1a3322' },
        { x: 4, y: 5, c: '#152a1c' },

        // Head (tilted, dead)
        { x: -7, y: 1, c: '#152a1c' }, { x: -6, y: 1, c: '#1a3322' }, { x: -5, y: 1, c: '#1a3322' },
        { x: -7, y: 2, c: '#1a3322' }, { x: -6, y: 2, c: '#223828' }, { x: -5, y: 2, c: '#223828' },
        { x: -4, y: 2, c: '#1a3322' },
        { x: -7, y: 3, c: '#152a1c' }, { x: -6, y: 3, c: '#1a3322' }, { x: -5, y: 3, c: '#1a3322' },

        // Dead X eyes
        { x: -6, y: 1, c: '#000000' }, { x: -5, y: 2, c: '#000000' },
        { x: -5, y: 1, c: '#000000' }, { x: -6, y: 2, c: '#000000' },

        // Limp arm
        { x: 5, y: 4, c: '#152a1c' }, { x: 6, y: 4, c: '#152a1c' }, { x: 7, y: 5, c: '#152a1c' },
        { x: 8, y: 5, c: '#111' },

        // Blood splatter from body
        { x: -2, y: 5, c: '#880000' }, { x: 0, y: 5, c: '#990000' }, { x: 2, y: 4, c: '#770000' },
        { x: -3, y: 4, c: '#880000' }, { x: 1, y: 5, c: '#aa0000' },
      ];

      // Draw each pixel
      corpsePixels.forEach(p => {
        ctx.fillStyle = p.c;
        ctx.fillRect(cx + p.x * pixelSize, cy + p.y * pixelSize, pixelSize, pixelSize);
      });

      // Occasional screen flicker
      if (Math.random() < 0.05) {
        ctx.fillStyle = `rgba(255, 0, 0, ${Math.random() * 0.1})`;
        ctx.fillRect(0, 0, canvas.width, canvas.height);
      }

      // Scanlines effect
      ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
      for (let y = 0; y < canvas.height; y += 4) {
        ctx.fillRect(0, y, canvas.width, 2);
      }

      // Disturbing text
      ctx.save();
      ctx.fillStyle = '#440000';
      ctx.font = '24px Bangers';
      ctx.textAlign = 'center';

      const flicker = Math.random() > 0.9;
      if (flicker) {
        ctx.fillStyle = '#660000';
      }

      ctx.fillText('R.I.P.', cx, cy - 80);

      // Countdown in corner
      const remaining = Math.ceil((DEATH_DURATION - deathTimer) / 60);
      ctx.fillStyle = '#220000';
      ctx.font = '16px Bangers';
      ctx.fillText(`${remaining}`, cx, canvas.height - 30);

      ctx.restore();
    }

    function drawConstipatedGorilla() {
      if (!isConstipated) return;

      // Draw strain effect
      ctx.save();
      ctx.translate(gorilla.x, gorilla.y);

      // Red straining face overlay
      ctx.fillStyle = 'rgba(255, 0, 0, 0.3)';
      ctx.beginPath();
      ctx.arc(0, -gorilla.size * 0.55, gorilla.size * 0.4, 0, Math.PI * 2);
      ctx.fill();

      // Strain lines
      ctx.strokeStyle = '#ff0000';
      ctx.lineWidth = 3;
      for (let i = 0; i < 6; i++) {
        const angle = (i / 6) * Math.PI * 2;
        const r1 = gorilla.size * 0.5;
        const r2 = gorilla.size * 0.7;
        ctx.beginPath();
        ctx.moveTo(Math.cos(angle) * r1, -gorilla.size * 0.55 + Math.sin(angle) * r1);
        ctx.lineTo(Math.cos(angle) * r2, -gorilla.size * 0.55 + Math.sin(angle) * r2);
        ctx.stroke();
      }

      ctx.restore();

      // "CONSTIPATED!" text
      ctx.save();
      ctx.fillStyle = '#ffff00';
      ctx.shadowColor = '#ff6600';
      ctx.shadowBlur = 20;
      ctx.font = 'bold 32px Bangers';
      ctx.textAlign = 'center';
      ctx.fillText('CONSTIPATED!', gorilla.x, gorilla.y - gorilla.size - 20);
      ctx.restore();
    }

    function restartGame() {
      initVoid();
      fartClouds = [];
      projectiles = [];
      bloodParticles = [];
      fartCount = 0;
      clearedPercent = 0;
      gameWon = false;
      throwTimer = 0;
      isConstipated = false;
      constipationTimer = 0;
      isDying = false;
      deathTimer = 0;
      isJumpscare = false;
      jumpscareTimer = 0;
      document.getElementById('winScreen').style.display = 'none';
    }

    // Input handling
    function updateGorillaTarget(x, y) {
      gorilla.targetX = x;
      gorilla.targetY = y;
    }

    canvas.addEventListener('mousemove', (e) => {
      updateGorillaTarget(e.clientX, e.clientY);
    });

    canvas.addEventListener('click', doFart);

    canvas.addEventListener('touchmove', (e) => {
      e.preventDefault();
      const touch = e.touches[0];
      updateGorillaTarget(touch.clientX, touch.clientY);
    });

    canvas.addEventListener('touchstart', (e) => {
      e.preventDefault();
      const touch = e.touches[0];
      updateGorillaTarget(touch.clientX, touch.clientY);
      doFart();
    });

    // Initialize
    initVoid();
    gorilla.x = canvas.width / 2;
    gorilla.y = canvas.height / 2;
    gorilla.targetX = gorilla.x;
    gorilla.targetY = gorilla.y;

    // Game loop
    function gameLoop() {
      // Update constipation timer
      if (isConstipated) {
        constipationTimer--;
        if (constipationTimer <= 0) {
          isConstipated = false;
        }
      }

      // Update death sequence and jumpscare
      updateDeathSequence();
      updateJumpscare();

      // Smooth gorilla movement (slower when dying)
      const moveSpeed = isDying ? 0.02 : 0.1;
      gorilla.x += (gorilla.targetX - gorilla.x) * moveSpeed;
      gorilla.y += (gorilla.targetY - gorilla.y) * moveSpeed;

      // Auto-throw projectiles at cursor (not when dying/constipated)
      if (!isDying && !isConstipated) {
        throwTimer++;
        if (throwTimer >= 15 && !gameWon) {
          throwTimer = 0;
          throwProjectile();
        }
      }

      // Draw
      drawBackground();
      drawVoid();

      // Update and draw fart clouds
      fartClouds = fartClouds.filter(cloud => cloud.update());
      fartClouds.forEach(cloud => cloud.draw());

      // Update and draw projectiles
      projectiles = projectiles.filter(p => p.update());
      projectiles.forEach(p => p.draw());

      // Update and draw blood particles
      updateBloodParticles();
      drawBloodParticles();

      drawGorilla();

      // Draw constipation effect on top
      drawConstipatedGorilla();

      // Draw death overlay on top of everything
      drawDeathOverlay();

      // Draw jumpscare on top of absolutely everything
      drawJumpscare();

      if (!isDying && !isJumpscare) {
        updateStats();
      }

      requestAnimationFrame(gameLoop);
    }

    gameLoop();
  </script>
</body>
</html>
