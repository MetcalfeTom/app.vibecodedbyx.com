<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Modern Node TypeScript Developer Agent</title>
<link rel="icon" href="https://emojicdn.elk.sh/ü§ñ">
<meta property="og:title" content="Modern Node TypeScript Developer Agent">
<meta property="og:description" content="An opinionated AI agent that helps you write modern TypeScript code">
<meta property="og:url" content="https://sloppy.live/modern-node-typescript-developer">
<meta property="og:image" content="https://sloppy.live/modern-node-typescript-developer/og-image.png">
<link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;700&family=Inter:wght@400;600;700&display=swap" rel="stylesheet">
<style>
*{margin:0;padding:0;box-sizing:border-box}
body{font-family:'Inter',sans-serif;background:linear-gradient(135deg,#0f172a 0%,#1e1b4b 100%);min-height:100vh;color:#e2e8f0}
.back-link{position:fixed;top:20px;left:20px;color:#3b82f6;text-decoration:none;padding:8px 16px;background:rgba(59,130,246,0.1);border:1px solid #3b82f6;border-radius:6px;font-size:12px;z-index:100;font-family:'JetBrains Mono',monospace}
.back-link:hover{background:rgba(59,130,246,0.2);box-shadow:0 0 20px rgba(59,130,246,0.3)}
.container{max-width:900px;margin:0 auto;padding:80px 20px 20px}
.header{text-align:center;margin-bottom:30px}
.agent-avatar{width:80px;height:80px;background:linear-gradient(135deg,#3b82f6,#8b5cf6);border-radius:20px;display:flex;align-items:center;justify-content:center;font-size:2.5rem;margin:0 auto 15px;box-shadow:0 0 30px rgba(59,130,246,0.4);animation:pulse 2s infinite}
@keyframes pulse{0%,100%{box-shadow:0 0 30px rgba(59,130,246,0.4)}50%{box-shadow:0 0 50px rgba(139,92,246,0.6)}}
h1{font-size:1.8rem;font-weight:700;background:linear-gradient(90deg,#3b82f6,#8b5cf6);-webkit-background-clip:text;-webkit-text-fill-color:transparent;margin-bottom:8px}
.subtitle{color:#94a3b8;font-size:0.9rem}
.status{display:flex;align-items:center;justify-content:center;gap:8px;margin-top:10px;font-size:0.8rem;color:#22c55e}
.status-dot{width:8px;height:8px;background:#22c55e;border-radius:50%;animation:blink 1s infinite}
@keyframes blink{0%,100%{opacity:1}50%{opacity:0.5}}
.chat-container{background:rgba(15,23,42,0.8);border:1px solid #334155;border-radius:12px;overflow:hidden;box-shadow:0 4px 30px rgba(0,0,0,0.3)}
.chat-messages{height:400px;overflow-y:auto;padding:20px}
.chat-messages::-webkit-scrollbar{width:6px}
.chat-messages::-webkit-scrollbar-track{background:#1e293b}
.chat-messages::-webkit-scrollbar-thumb{background:#475569;border-radius:3px}
.message{margin-bottom:15px;display:flex;gap:12px}
.message.user{flex-direction:row-reverse}
.message-avatar{width:36px;height:36px;border-radius:10px;display:flex;align-items:center;justify-content:center;font-size:1.2rem;flex-shrink:0}
.message.agent .message-avatar{background:linear-gradient(135deg,#3b82f6,#8b5cf6)}
.message.user .message-avatar{background:#475569}
.message-content{max-width:75%;padding:12px 16px;border-radius:12px;font-size:0.9rem;line-height:1.5}
.message.agent .message-content{background:#1e293b;border:1px solid #334155;border-top-left-radius:4px}
.message.user .message-content{background:#3b82f6;border-top-right-radius:4px}
.code-block{background:#0f172a;border:1px solid #334155;border-radius:8px;padding:12px;margin:10px 0;font-family:'JetBrains Mono',monospace;font-size:0.8rem;overflow-x:auto;position:relative}
.code-block::before{content:'TypeScript';position:absolute;top:0;right:0;background:#3b82f6;color:#fff;font-size:0.6rem;padding:2px 8px;border-radius:0 8px 0 8px}
.code-block code{color:#e2e8f0}
.keyword{color:#c084fc}
.string{color:#4ade80}
.type{color:#60a5fa}
.comment{color:#64748b}
.function{color:#fbbf24}
.input-container{display:flex;gap:10px;padding:15px;background:#1e293b;border-top:1px solid #334155}
.input-field{flex:1;background:#0f172a;border:1px solid #334155;border-radius:8px;padding:12px 16px;color:#e2e8f0;font-family:inherit;font-size:0.9rem;outline:none;transition:border-color 0.2s}
.input-field:focus{border-color:#3b82f6}
.input-field::placeholder{color:#64748b}
.send-btn{background:linear-gradient(135deg,#3b82f6,#8b5cf6);border:none;border-radius:8px;padding:12px 24px;color:#fff;font-weight:600;cursor:pointer;transition:transform 0.2s,box-shadow 0.2s}
.send-btn:hover{transform:scale(1.05);box-shadow:0 0 20px rgba(59,130,246,0.4)}
.send-btn:disabled{opacity:0.5;cursor:not-allowed;transform:none}
.quick-actions{display:flex;flex-wrap:wrap;gap:8px;padding:15px;background:#1e293b;border-top:1px solid #334155}
.quick-btn{background:#0f172a;border:1px solid #334155;border-radius:6px;padding:8px 12px;color:#94a3b8;font-size:0.75rem;cursor:pointer;transition:all 0.2s}
.quick-btn:hover{border-color:#3b82f6;color:#3b82f6}
.typing{display:flex;gap:4px;padding:8px 12px}
.typing span{width:8px;height:8px;background:#3b82f6;border-radius:50%;animation:typing 1s infinite}
.typing span:nth-child(2){animation-delay:0.2s}
.typing span:nth-child(3){animation-delay:0.4s}
@keyframes typing{0%,100%{transform:translateY(0)}50%{transform:translateY(-5px)}}
.opinions{margin-top:20px;background:rgba(15,23,42,0.8);border:1px solid #334155;border-radius:12px;padding:20px}
.opinions-title{font-size:0.9rem;color:#94a3b8;margin-bottom:15px;display:flex;align-items:center;gap:8px}
.opinion-list{display:flex;flex-wrap:wrap;gap:10px}
.opinion{background:#1e293b;border:1px solid #334155;border-radius:8px;padding:10px 15px;font-size:0.8rem;display:flex;align-items:center;gap:8px}
.opinion.good{border-color:#22c55e;color:#22c55e}
.opinion.bad{border-color:#ef4444;color:#ef4444}
</style>
</head>
<body>
<a href="https://sloppy.live" class="back-link">‚Üê sloppy.live</a>

<div class="container">
  <div class="header">
    <div class="agent-avatar">ü§ñ</div>
    <h1>Modern Node TypeScript Developer</h1>
    <p class="subtitle">An opinionated AI agent for modern TypeScript development</p>
    <div class="status"><div class="status-dot"></div>Agent Online</div>
  </div>

  <div class="chat-container">
    <div class="chat-messages" id="chatMessages"></div>
    <div class="quick-actions">
      <button class="quick-btn" onclick="askQuestion('Generate a typed API client')">API Client</button>
      <button class="quick-btn" onclick="askQuestion('Create a Zod schema')">Zod Schema</button>
      <button class="quick-btn" onclick="askQuestion('Setup ESLint config')">ESLint Config</button>
      <button class="quick-btn" onclick="askQuestion('Create a custom hook')">Custom Hook</button>
      <button class="quick-btn" onclick="askQuestion('Error handling pattern')">Error Handling</button>
      <button class="quick-btn" onclick="askQuestion('What should I use for state management?')">State Mgmt</button>
    </div>
    <div class="input-container">
      <input type="text" class="input-field" id="inputField" placeholder="Ask me about TypeScript, Node.js, or modern dev practices..." onkeypress="handleKeyPress(event)">
      <button class="send-btn" id="sendBtn" onclick="sendMessage()">Send</button>
    </div>
  </div>

  <div class="opinions">
    <div class="opinions-title">üéØ Strong Opinions (Loosely Held)</div>
    <div class="opinion-list">
      <div class="opinion good">‚úì TypeScript strict mode</div>
      <div class="opinion good">‚úì Zod for validation</div>
      <div class="opinion good">‚úì pnpm over npm</div>
      <div class="opinion good">‚úì Biome over ESLint</div>
      <div class="opinion good">‚úì Bun for scripts</div>
      <div class="opinion bad">‚úó any type</div>
      <div class="opinion bad">‚úó Default exports</div>
      <div class="opinion bad">‚úó Moment.js</div>
      <div class="opinion bad">‚úó Class components</div>
    </div>
  </div>
</div>

<script>
const responses = {
  greetings: [
    "Hey! I'm your modern TypeScript agent. I have strong opinions about code quality and I'm not afraid to share them. What can I help you build today?",
    "Welcome! Ready to write some type-safe, maintainable code? Let's do this.",
    "Hi there! I believe in strict TypeScript, functional patterns, and zero `any` types. How can I assist?"
  ],
  api_client: {
    text: "Here's a modern typed API client using fetch with proper error handling:",
    code: `<span class="keyword">import</span> { z } <span class="keyword">from</span> <span class="string">'zod'</span>;

<span class="comment">// Define your response schema</span>
<span class="keyword">const</span> UserSchema = z.object({
  id: z.string().uuid(),
  name: z.string(),
  email: z.string().email(),
});

<span class="keyword">type</span> <span class="type">User</span> = z.infer<<span class="keyword">typeof</span> UserSchema>;

<span class="comment">// Type-safe API client</span>
<span class="keyword">export const</span> <span class="function">fetchUser</span> = <span class="keyword">async</span> (id: <span class="type">string</span>): <span class="type">Promise</span><<span class="type">User</span>> => {
  <span class="keyword">const</span> res = <span class="keyword">await</span> fetch(\`/api/users/\${id}\`);

  <span class="keyword">if</span> (!res.ok) {
    <span class="keyword">throw new</span> <span class="type">Error</span>(\`Failed: \${res.status}\`);
  }

  <span class="keyword">const</span> data = <span class="keyword">await</span> res.json();
  <span class="keyword">return</span> UserSchema.parse(data); <span class="comment">// Runtime validation!</span>
};`
  },
  zod_schema: {
    text: "Zod is THE way to do runtime validation. Here's a comprehensive schema:",
    code: `<span class="keyword">import</span> { z } <span class="keyword">from</span> <span class="string">'zod'</span>;

<span class="keyword">export const</span> CreateUserSchema = z.object({
  name: z.string().min(2).max(100),
  email: z.string().email(),
  age: z.number().int().positive().optional(),
  role: z.enum([<span class="string">'admin'</span>, <span class="string">'user'</span>, <span class="string">'guest'</span>]),
  preferences: z.object({
    theme: z.enum([<span class="string">'light'</span>, <span class="string">'dark'</span>]).default(<span class="string">'dark'</span>),
    notifications: z.boolean().default(<span class="keyword">true</span>),
  }).optional(),
  tags: z.array(z.string()).default([]),
});

<span class="comment">// Infer the type - no duplication!</span>
<span class="keyword">export type</span> <span class="type">CreateUser</span> = z.infer<<span class="keyword">typeof</span> CreateUserSchema>;

<span class="comment">// Use it:</span>
<span class="keyword">const</span> validated = CreateUserSchema.parse(unknownData);`
  },
  eslint: {
    text: "Hot take: Use Biome instead of ESLint. It's faster and simpler. But if you must use ESLint:",
    code: `<span class="comment">// eslint.config.js (flat config - the new way)</span>
<span class="keyword">import</span> tseslint <span class="keyword">from</span> <span class="string">'typescript-eslint'</span>;

<span class="keyword">export default</span> tseslint.config(
  tseslint.configs.strictTypeChecked,
  {
    languageOptions: {
      parserOptions: {
        project: <span class="keyword">true</span>,
      },
    },
    rules: {
      <span class="string">'@typescript-eslint/no-explicit-any'</span>: <span class="string">'error'</span>,
      <span class="string">'@typescript-eslint/strict-boolean-expressions'</span>: <span class="string">'error'</span>,
      <span class="string">'@typescript-eslint/no-floating-promises'</span>: <span class="string">'error'</span>,
    },
  }
);`
  },
  custom_hook: {
    text: "Here's a properly typed custom hook with loading and error states:",
    code: `<span class="keyword">import</span> { useState, useEffect } <span class="keyword">from</span> <span class="string">'react'</span>;

<span class="keyword">type</span> <span class="type">AsyncState</span><<span class="type">T</span>> =
  | { status: <span class="string">'idle'</span> }
  | { status: <span class="string">'loading'</span> }
  | { status: <span class="string">'success'</span>; data: <span class="type">T</span> }
  | { status: <span class="string">'error'</span>; error: <span class="type">Error</span> };

<span class="keyword">export const</span> <span class="function">useAsync</span> = <<span class="type">T</span>>(
  asyncFn: () => <span class="type">Promise</span><<span class="type">T</span>>,
  deps: <span class="type">unknown</span>[] = []
): <span class="type">AsyncState</span><<span class="type">T</span>> => {
  <span class="keyword">const</span> [state, setState] = useState<<span class="type">AsyncState</span><<span class="type">T</span>>>({
    status: <span class="string">'idle'</span>
  });

  useEffect(() => {
    setState({ status: <span class="string">'loading'</span> });

    asyncFn()
      .then(data => setState({ status: <span class="string">'success'</span>, data }))
      .catch(error => setState({ status: <span class="string">'error'</span>, error }));
  }, deps);

  <span class="keyword">return</span> state;
};`
  },
  error_handling: {
    text: "Use discriminated unions for type-safe error handling. Never throw raw errors!",
    code: `<span class="comment">// Result type - like Rust!</span>
<span class="keyword">type</span> <span class="type">Result</span><<span class="type">T</span>, <span class="type">E</span> = <span class="type">Error</span>> =
  | { ok: <span class="keyword">true</span>; value: <span class="type">T</span> }
  | { ok: <span class="keyword">false</span>; error: <span class="type">E</span> };

<span class="comment">// Helper functions</span>
<span class="keyword">export const</span> <span class="function">ok</span> = <<span class="type">T</span>>(value: <span class="type">T</span>): <span class="type">Result</span><<span class="type">T</span>> =>
  ({ ok: <span class="keyword">true</span>, value });

<span class="keyword">export const</span> <span class="function">err</span> = <<span class="type">E</span>>(error: <span class="type">E</span>): <span class="type">Result</span><<span class="keyword">never</span>, <span class="type">E</span>> =>
  ({ ok: <span class="keyword">false</span>, error });

<span class="comment">// Usage</span>
<span class="keyword">const</span> <span class="function">parseJSON</span> = <<span class="type">T</span>>(str: <span class="type">string</span>): <span class="type">Result</span><<span class="type">T</span>> => {
  <span class="keyword">try</span> {
    <span class="keyword">return</span> ok(JSON.parse(str));
  } <span class="keyword">catch</span> (e) {
    <span class="keyword">return</span> err(<span class="keyword">new</span> <span class="type">Error</span>(<span class="string">'Invalid JSON'</span>));
  }
};

<span class="comment">// Type narrowing works perfectly!</span>
<span class="keyword">const</span> result = parseJSON<<span class="type">User</span>>(input);
<span class="keyword">if</span> (result.ok) {
  console.log(result.value.name); <span class="comment">// ‚úì typed!</span>
} <span class="keyword">else</span> {
  console.error(result.error.message);
}`
  },
  state_management: {
    text: "Hot take incoming! For most apps, you DON'T need Redux. Here's my tier list:",
    code: `<span class="comment">// üèÜ S-Tier: React Query / TanStack Query</span>
<span class="comment">// For server state - it's not even close</span>

<span class="comment">// ü•á A-Tier: Zustand</span>
<span class="comment">// Simple, TypeScript-first, no boilerplate</span>
<span class="keyword">import</span> { create } <span class="keyword">from</span> <span class="string">'zustand'</span>;

<span class="keyword">interface</span> <span class="type">Store</span> {
  count: <span class="type">number</span>;
  increment: () => <span class="type">void</span>;
}

<span class="keyword">export const</span> useStore = create<<span class="type">Store</span>>((set) => ({
  count: 0,
  increment: () => set((s) => ({ count: s.count + 1 })),
}));

<span class="comment">// ü•à B-Tier: Jotai (atomic state)</span>
<span class="comment">// ü•â C-Tier: Redux Toolkit (only if you NEED it)</span>
<span class="comment">// ‚ùå F-Tier: Plain Redux, MobX, Recoil</span>`
  },
  default: [
    "That's a great question! As a modern TypeScript dev, I'd say: always prefer strict types, use Zod for runtime validation, and remember - if you're using `any`, you're doing it wrong.",
    "Interesting! My philosophy: write code that's self-documenting through types. If your types are good, you need fewer tests and comments.",
    "I'd approach this with functional patterns and immutability. TypeScript shines when you embrace its type system fully.",
    "Good question! The key is to let TypeScript's inference work for you. Don't over-annotate, but never use `any`."
  ]
};

const chatMessages = document.getElementById('chatMessages');
const inputField = document.getElementById('inputField');
const sendBtn = document.getElementById('sendBtn');

let isTyping = false;

const addMessage = (content, isUser = false, isCode = false) => {
  const msg = document.createElement('div');
  msg.className = `message ${isUser ? 'user' : 'agent'}`;

  let contentHtml = content;
  if (isCode) {
    contentHtml = `<div class="code-block"><code>${content}</code></div>`;
  }

  msg.innerHTML = `
    <div class="message-avatar">${isUser ? 'üë§' : 'ü§ñ'}</div>
    <div class="message-content">${contentHtml}</div>
  `;
  chatMessages.appendChild(msg);
  chatMessages.scrollTop = chatMessages.scrollHeight;
};

const showTyping = () => {
  const typing = document.createElement('div');
  typing.className = 'message agent';
  typing.id = 'typingIndicator';
  typing.innerHTML = `
    <div class="message-avatar">ü§ñ</div>
    <div class="message-content"><div class="typing"><span></span><span></span><span></span></div></div>
  `;
  chatMessages.appendChild(typing);
  chatMessages.scrollTop = chatMessages.scrollHeight;
};

const hideTyping = () => {
  const typing = document.getElementById('typingIndicator');
  if (typing) typing.remove();
};

const getResponse = (input) => {
  const lower = input.toLowerCase();

  if (lower.includes('api') && lower.includes('client')) return responses.api_client;
  if (lower.includes('zod') || lower.includes('schema') || lower.includes('validation')) return responses.zod_schema;
  if (lower.includes('eslint') || lower.includes('lint')) return responses.eslint;
  if (lower.includes('hook')) return responses.custom_hook;
  if (lower.includes('error') && lower.includes('handl')) return responses.error_handling;
  if (lower.includes('state') || lower.includes('redux') || lower.includes('zustand')) return responses.state_management;
  if (lower.includes('hello') || lower.includes('hi') || lower.includes('hey')) {
    return { text: responses.greetings[Math.floor(Math.random() * responses.greetings.length)] };
  }

  return { text: responses.default[Math.floor(Math.random() * responses.default.length)] };
};

const sendMessage = async () => {
  const input = inputField.value.trim();
  if (!input || isTyping) return;

  inputField.value = '';
  addMessage(input, true);

  isTyping = true;
  sendBtn.disabled = true;
  showTyping();

  // Simulate thinking time
  await new Promise(r => setTimeout(r, 1000 + Math.random() * 1000));

  hideTyping();
  const response = getResponse(input);
  addMessage(response.text);

  if (response.code) {
    await new Promise(r => setTimeout(r, 500));
    addMessage(response.code, false, true);
  }

  isTyping = false;
  sendBtn.disabled = false;
  inputField.focus();
};

const askQuestion = (question) => {
  inputField.value = question;
  sendMessage();
};

const handleKeyPress = (e) => {
  if (e.key === 'Enter') sendMessage();
};

// Initial greeting
setTimeout(() => {
  addMessage(responses.greetings[0]);
}, 500);
</script>
</body>
</html>
