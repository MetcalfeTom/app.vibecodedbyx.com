<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Mesh Relaxation - Manifolds</title>
  <link rel="icon" href="https://emojicdn.elk.sh/ðŸ”º">
  <meta property="og:title" content="Mesh Relaxation - Manifolds">
  <meta property="og:description" content="Relax vertices on MÃ¶bius strips, tori, and more">
  <meta property="og:url" content="https://sloppy.live/mesh-relax">
  <meta property="og:image" content="https://emojicdn.elk.sh/ðŸ”º?style=apple&size=512">
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link href="https://fonts.googleapis.com/css2?family=Space+Grotesk:wght@400;600&family=JetBrains+Mono:wght@400&display=swap" rel="stylesheet">
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }

    body {
      min-height: 100vh;
      background: #0a0a12;
      font-family: 'Space Grotesk', sans-serif;
      color: #e0e0e0;
      overflow: hidden;
    }

    .header {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      padding: 0.8rem 1.5rem;
      background: linear-gradient(to bottom, rgba(10, 10, 18, 0.95), rgba(10, 10, 18, 0.7));
      display: flex;
      justify-content: space-between;
      align-items: center;
      flex-wrap: wrap;
      gap: 0.8rem;
      z-index: 100;
    }

    h1 {
      font-size: 1.2rem;
      font-weight: 600;
      color: #60a5fa;
      text-shadow: 0 0 20px rgba(96, 165, 250, 0.5);
    }

    .stats {
      font-family: 'JetBrains Mono', monospace;
      font-size: 0.7rem;
      color: #94a3b8;
      display: flex;
      gap: 1rem;
      flex-wrap: wrap;
    }

    .stat-value { color: #34d399; }

    .controls {
      display: flex;
      gap: 0.4rem;
      flex-wrap: wrap;
      align-items: center;
    }

    .btn {
      font-family: 'Space Grotesk', sans-serif;
      font-size: 0.75rem;
      padding: 0.4rem 0.8rem;
      background: rgba(96, 165, 250, 0.1);
      border: 1px solid #60a5fa;
      color: #60a5fa;
      cursor: pointer;
      transition: all 0.2s;
      border-radius: 4px;
    }

    .btn:hover {
      background: rgba(96, 165, 250, 0.3);
      box-shadow: 0 0 15px rgba(96, 165, 250, 0.3);
    }

    .btn.active {
      background: #60a5fa;
      color: #0a0a12;
    }

    select {
      font-family: 'Space Grotesk', sans-serif;
      font-size: 0.75rem;
      padding: 0.4rem 0.6rem;
      background: rgba(96, 165, 250, 0.1);
      border: 1px solid #60a5fa;
      color: #60a5fa;
      border-radius: 4px;
      cursor: pointer;
    }

    select option {
      background: #1a1a2e;
      color: #60a5fa;
    }

    .slider-group {
      display: flex;
      align-items: center;
      gap: 0.3rem;
      font-size: 0.7rem;
      color: #94a3b8;
    }

    input[type="range"] {
      width: 60px;
      accent-color: #60a5fa;
    }

    canvas { display: block; }

    .info {
      position: fixed;
      bottom: 0.8rem;
      left: 50%;
      transform: translateX(-50%);
      font-size: 0.65rem;
      color: #475569;
      text-align: center;
    }

    .info a { color: #64748b; text-decoration: none; }

    .quality-bar {
      position: fixed;
      bottom: 2.5rem;
      left: 50%;
      transform: translateX(-50%);
      width: min(280px, 70%);
      text-align: center;
    }

    .quality-label {
      font-size: 0.65rem;
      color: #64748b;
      margin-bottom: 0.2rem;
    }

    .quality-track {
      height: 5px;
      background: #1e293b;
      border-radius: 3px;
      overflow: hidden;
    }

    .quality-fill {
      height: 100%;
      background: linear-gradient(90deg, #f472b6, #60a5fa, #34d399);
      transition: width 0.3s;
    }

    .surface-info {
      position: fixed;
      top: 70px;
      left: 1rem;
      font-size: 0.7rem;
      color: #64748b;
      background: rgba(10, 10, 18, 0.8);
      padding: 0.5rem;
      border-radius: 4px;
      max-width: 200px;
    }

    .surface-info strong { color: #60a5fa; }
  </style>
</head>
<body>
  <div class="header">
    <h1>ðŸ”º Mesh Relaxation</h1>
    <div class="stats">
      <span>Vertices: <span class="stat-value" id="vertCount">0</span></span>
      <span>Faces: <span class="stat-value" id="faceCount">0</span></span>
      <span>Iterations: <span class="stat-value" id="iterCount">0</span></span>
      <span>Quality: <span class="stat-value" id="qualityPct">0%</span></span>
    </div>
    <div class="controls">
      <select id="surfaceSelect">
        <option value="plane">Plane</option>
        <option value="cylinder">Cylinder</option>
        <option value="torus" selected>Torus</option>
        <option value="mobius">MÃ¶bius Strip</option>
        <option value="klein">Klein Bottle</option>
        <option value="sphere">Sphere</option>
      </select>
      <button class="btn" id="stepBtn">Step</button>
      <button class="btn" id="runBtn">Run</button>
      <div class="slider-group">
        <label>Str:</label>
        <input type="range" id="strengthSlider" min="1" max="100" value="25">
      </div>
      <button class="btn" id="distortBtn">Distort</button>
      <button class="btn" id="resetBtn">Reset</button>
    </div>
  </div>

  <div class="surface-info" id="surfaceInfo">
    <strong>Torus</strong><br>
    Orientable manifold with genus 1. Edges wrap in both U and V directions.
  </div>

  <div class="quality-bar">
    <div class="quality-label">Equilateral Convergence</div>
    <div class="quality-track">
      <div class="quality-fill" id="qualityFill" style="width: 0%"></div>
    </div>
  </div>

  <div class="info">
    Drag to rotate â€¢ Scroll to zoom â€¢ Relaxation preserves manifold topology<br>
    <a href="https://sloppy.live">sloppy.live</a>
  </div>

  <script type="importmap">
    {
      "imports": {
        "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
        "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
      }
    }
  </script>

  <script type="module">
    import * as THREE from 'three';
    import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

    // Scene setup
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x0a0a12);

    const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 100);
    camera.position.set(3, 2, 3);

    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    document.body.appendChild(renderer.domElement);

    const controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;
    controls.dampingFactor = 0.05;

    // Lighting
    const ambientLight = new THREE.AmbientLight(0x404060, 0.5);
    scene.add(ambientLight);

    const light1 = new THREE.DirectionalLight(0x60a5fa, 0.8);
    light1.position.set(5, 5, 5);
    scene.add(light1);

    const light2 = new THREE.DirectionalLight(0xf472b6, 0.4);
    light2.position.set(-5, -5, -5);
    scene.add(light2);

    // Mesh data
    let vertices = [];      // Array of {x, y, z, neighbors: Set}
    let faces = [];         // Array of [i, j, k] vertex indices
    let edges = new Map();  // edge key -> {v1, v2, faces: []}
    let mesh = null;
    let wireframe = null;
    let running = false;
    let iterations = 0;

    // UI elements
    const vertCountEl = document.getElementById('vertCount');
    const faceCountEl = document.getElementById('faceCount');
    const iterCountEl = document.getElementById('iterCount');
    const qualityPctEl = document.getElementById('qualityPct');
    const qualityFill = document.getElementById('qualityFill');
    const surfaceInfo = document.getElementById('surfaceInfo');

    const surfaceDescriptions = {
      plane: '<strong>Plane</strong><br>Simple flat surface with no wrapping. Open boundary.',
      cylinder: '<strong>Cylinder</strong><br>Surface wraps in U direction. Two open boundaries.',
      torus: '<strong>Torus</strong><br>Orientable manifold with genus 1. Edges wrap in both U and V directions.',
      mobius: '<strong>MÃ¶bius Strip</strong><br>Non-orientable surface with 180Â° twist. Single boundary curve.',
      klein: '<strong>Klein Bottle</strong><br>Non-orientable closed surface. Self-intersects in 3D embedding.',
      sphere: '<strong>Sphere</strong><br>Orientable closed surface with genus 0. No boundaries.'
    };

    // Generate parametric surface mesh with proper topology
    function generateSurface(type, uSegments = 24, vSegments = 16) {
      vertices = [];
      faces = [];
      edges.clear();
      iterations = 0;

      const uWrap = ['cylinder', 'torus', 'mobius', 'klein'].includes(type);
      const vWrap = ['torus', 'klein', 'sphere'].includes(type);
      const mobiusTwist = type === 'mobius';
      const kleinTwist = type === 'klein';

      // Generate vertices
      const vertexGrid = [];
      for (let v = 0; v <= vSegments; v++) {
        vertexGrid[v] = [];
        for (let u = 0; u <= uSegments; u++) {
          const uRatio = u / uSegments;
          const vRatio = v / vSegments;

          let pos;
          switch (type) {
            case 'plane':
              pos = { x: uRatio * 2 - 1, y: 0, z: vRatio * 2 - 1 };
              break;

            case 'cylinder':
              const cylTheta = uRatio * Math.PI * 2;
              pos = {
                x: Math.cos(cylTheta),
                y: vRatio * 2 - 1,
                z: Math.sin(cylTheta)
              };
              break;

            case 'torus':
              const torU = uRatio * Math.PI * 2;
              const torV = vRatio * Math.PI * 2;
              const R = 1, r = 0.4;
              pos = {
                x: (R + r * Math.cos(torV)) * Math.cos(torU),
                y: r * Math.sin(torV),
                z: (R + r * Math.cos(torV)) * Math.sin(torU)
              };
              break;

            case 'mobius':
              const mobU = uRatio * Math.PI * 2;
              const mobV = vRatio - 0.5;
              const mobTwist = mobU / 2;
              pos = {
                x: (1 + mobV * Math.cos(mobTwist)) * Math.cos(mobU),
                y: mobV * Math.sin(mobTwist),
                z: (1 + mobV * Math.cos(mobTwist)) * Math.sin(mobU)
              };
              break;

            case 'klein':
              // Klein bottle immersion
              const klU = uRatio * Math.PI * 2;
              const klV = vRatio * Math.PI * 2;
              const a = 2;
              if (klU < Math.PI) {
                pos = {
                  x: 3 * Math.cos(klU) * (1 + Math.sin(klU)) + a * (1 - Math.cos(klU) / 2) * Math.cos(klU) * Math.cos(klV),
                  y: a * (1 - Math.cos(klU) / 2) * Math.sin(klV),
                  z: 8 * Math.sin(klU) + a * (1 - Math.cos(klU) / 2) * Math.sin(klU) * Math.cos(klV)
                };
              } else {
                pos = {
                  x: 3 * Math.cos(klU) * (1 + Math.sin(klU)) + a * (1 - Math.cos(klU) / 2) * Math.cos(klV + Math.PI),
                  y: a * (1 - Math.cos(klU) / 2) * Math.sin(klV),
                  z: 8 * Math.sin(klU)
                };
              }
              // Scale down
              pos.x *= 0.1; pos.y *= 0.1; pos.z *= 0.1;
              break;

            case 'sphere':
              const sphU = uRatio * Math.PI * 2;
              const sphV = vRatio * Math.PI;
              pos = {
                x: Math.sin(sphV) * Math.cos(sphU),
                y: Math.cos(sphV),
                z: Math.sin(sphV) * Math.sin(sphU)
              };
              break;
          }

          // Check if this vertex should be identified with another (wrapping)
          let existingIdx = -1;

          if (uWrap && u === uSegments) {
            // Wrap U: identify with u=0, possibly with V flip for MÃ¶bius/Klein
            let targetV = v;
            if (mobiusTwist || kleinTwist) {
              targetV = vSegments - v;
            }
            existingIdx = vertexGrid[targetV][0];
          }

          if (vWrap && v === vSegments && existingIdx === -1) {
            // Wrap V: identify with v=0
            existingIdx = vertexGrid[0][u];
          }

          if (existingIdx !== -1) {
            vertexGrid[v][u] = existingIdx;
          } else {
            const idx = vertices.length;
            vertices.push({
              x: pos.x,
              y: pos.y,
              z: pos.z,
              origX: pos.x,
              origY: pos.y,
              origZ: pos.z,
              neighbors: new Set()
            });
            vertexGrid[v][u] = idx;
          }
        }
      }

      // Generate faces with proper connectivity
      for (let v = 0; v < vSegments; v++) {
        for (let u = 0; u < uSegments; u++) {
          const i00 = vertexGrid[v][u];
          const i10 = vertexGrid[v][u + 1];
          const i01 = vertexGrid[v + 1][u];
          const i11 = vertexGrid[v + 1][u + 1];

          // Skip degenerate faces (can happen at poles)
          if (i00 !== i10 && i10 !== i11 && i11 !== i00) {
            faces.push([i00, i10, i11]);
            addEdge(i00, i10);
            addEdge(i10, i11);
            addEdge(i11, i00);
          }

          if (i00 !== i01 && i01 !== i11 && i11 !== i00) {
            faces.push([i00, i11, i01]);
            addEdge(i00, i11);
            addEdge(i11, i01);
            addEdge(i01, i00);
          }
        }
      }

      // Build neighbor lists
      for (const [key, edge] of edges) {
        vertices[edge.v1].neighbors.add(edge.v2);
        vertices[edge.v2].neighbors.add(edge.v1);
      }

      surfaceInfo.innerHTML = surfaceDescriptions[type];
      updateStats();
      buildMesh();
    }

    function addEdge(v1, v2) {
      const key = v1 < v2 ? `${v1}-${v2}` : `${v2}-${v1}`;
      if (!edges.has(key)) {
        edges.set(key, { v1, v2 });
      }
    }

    function buildMesh() {
      // Remove old mesh
      if (mesh) scene.remove(mesh);
      if (wireframe) scene.remove(wireframe);

      // Create geometry
      const geometry = new THREE.BufferGeometry();
      const positions = new Float32Array(faces.length * 9);
      const colors = new Float32Array(faces.length * 9);

      for (let f = 0; f < faces.length; f++) {
        const [i, j, k] = faces[f];
        const quality = faceQuality(faces[f]);

        // Positions
        positions[f * 9 + 0] = vertices[i].x;
        positions[f * 9 + 1] = vertices[i].y;
        positions[f * 9 + 2] = vertices[i].z;
        positions[f * 9 + 3] = vertices[j].x;
        positions[f * 9 + 4] = vertices[j].y;
        positions[f * 9 + 5] = vertices[j].z;
        positions[f * 9 + 6] = vertices[k].x;
        positions[f * 9 + 7] = vertices[k].y;
        positions[f * 9 + 8] = vertices[k].z;

        // Color based on quality
        const color = new THREE.Color();
        color.setHSL(quality * 0.35, 0.8, 0.5);

        for (let c = 0; c < 3; c++) {
          colors[f * 9 + c * 3 + 0] = color.r;
          colors[f * 9 + c * 3 + 1] = color.g;
          colors[f * 9 + c * 3 + 2] = color.b;
        }
      }

      geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
      geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
      geometry.computeVertexNormals();

      const material = new THREE.MeshPhongMaterial({
        vertexColors: true,
        side: THREE.DoubleSide,
        flatShading: true,
        transparent: true,
        opacity: 0.85
      });

      mesh = new THREE.Mesh(geometry, material);
      scene.add(mesh);

      // Wireframe
      const wireMaterial = new THREE.LineBasicMaterial({
        color: 0x60a5fa,
        transparent: true,
        opacity: 0.3
      });
      wireframe = new THREE.LineSegments(
        new THREE.WireframeGeometry(geometry),
        wireMaterial
      );
      scene.add(wireframe);
    }

    function faceQuality(face) {
      const [i, j, k] = face;
      const a = vertices[i], b = vertices[j], c = vertices[k];

      const ab = Math.hypot(b.x - a.x, b.y - a.y, b.z - a.z);
      const bc = Math.hypot(c.x - b.x, c.y - b.y, c.z - b.z);
      const ca = Math.hypot(a.x - c.x, a.y - c.y, a.z - c.z);

      if (ab === 0 || bc === 0 || ca === 0) return 0;

      // Quality = ratio of min edge to max edge (1 = equilateral)
      const minEdge = Math.min(ab, bc, ca);
      const maxEdge = Math.max(ab, bc, ca);

      return minEdge / maxEdge;
    }

    function averageQuality() {
      if (faces.length === 0) return 0;
      let total = 0;
      for (const face of faces) {
        total += faceQuality(face);
      }
      return total / faces.length;
    }

    // Relaxation step - moves vertices toward equilateral triangles
    // while preserving manifold topology (edges/neighbors stay fixed)
    function relaxStep() {
      const strength = document.getElementById('strengthSlider').value / 2000;
      const forces = vertices.map(() => ({ x: 0, y: 0, z: 0 }));

      // For each edge, apply spring force toward average edge length
      let totalEdgeLength = 0;
      for (const edge of edges.values()) {
        const v1 = vertices[edge.v1];
        const v2 = vertices[edge.v2];
        totalEdgeLength += Math.hypot(v2.x - v1.x, v2.y - v1.y, v2.z - v1.z);
      }
      const avgEdgeLength = totalEdgeLength / edges.size;

      for (const edge of edges.values()) {
        const v1 = vertices[edge.v1];
        const v2 = vertices[edge.v2];

        const dx = v2.x - v1.x;
        const dy = v2.y - v1.y;
        const dz = v2.z - v1.z;
        const dist = Math.hypot(dx, dy, dz);

        if (dist === 0) continue;

        // Spring force toward average length
        const diff = dist - avgEdgeLength;
        const fx = (dx / dist) * diff * strength;
        const fy = (dy / dist) * diff * strength;
        const fz = (dz / dist) * diff * strength;

        forces[edge.v1].x += fx;
        forces[edge.v1].y += fy;
        forces[edge.v1].z += fz;
        forces[edge.v2].x -= fx;
        forces[edge.v2].y -= fy;
        forces[edge.v2].z -= fz;
      }

      // Laplacian smoothing - move toward centroid of neighbors
      for (let i = 0; i < vertices.length; i++) {
        const v = vertices[i];
        if (v.neighbors.size === 0) continue;

        let cx = 0, cy = 0, cz = 0;
        for (const ni of v.neighbors) {
          cx += vertices[ni].x;
          cy += vertices[ni].y;
          cz += vertices[ni].z;
        }
        cx /= v.neighbors.size;
        cy /= v.neighbors.size;
        cz /= v.neighbors.size;

        forces[i].x += (cx - v.x) * strength * 2;
        forces[i].y += (cy - v.y) * strength * 2;
        forces[i].z += (cz - v.z) * strength * 2;
      }

      // Apply forces
      for (let i = 0; i < vertices.length; i++) {
        vertices[i].x += forces[i].x;
        vertices[i].y += forces[i].y;
        vertices[i].z += forces[i].z;
      }

      iterations++;
      updateStats();
      buildMesh();
    }

    function distortMesh() {
      for (const v of vertices) {
        v.x += (Math.random() - 0.5) * 0.15;
        v.y += (Math.random() - 0.5) * 0.15;
        v.z += (Math.random() - 0.5) * 0.15;
      }
      buildMesh();
      updateStats();
    }

    function resetMesh() {
      for (const v of vertices) {
        v.x = v.origX;
        v.y = v.origY;
        v.z = v.origZ;
      }
      iterations = 0;
      buildMesh();
      updateStats();
    }

    function updateStats() {
      vertCountEl.textContent = vertices.length;
      faceCountEl.textContent = faces.length;
      iterCountEl.textContent = iterations;

      const quality = averageQuality();
      const pct = Math.round(quality * 100);
      qualityPctEl.textContent = pct + '%';
      qualityFill.style.width = pct + '%';
    }

    // Animation
    function animate() {
      requestAnimationFrame(animate);

      if (running) {
        relaxStep();
      }

      controls.update();
      renderer.render(scene, camera);
    }

    // Event handlers
    document.getElementById('surfaceSelect').addEventListener('change', (e) => {
      generateSurface(e.target.value);
      running = false;
      document.getElementById('runBtn').textContent = 'Run';
      document.getElementById('runBtn').classList.remove('active');
    });

    document.getElementById('stepBtn').addEventListener('click', relaxStep);

    document.getElementById('runBtn').addEventListener('click', function() {
      running = !running;
      this.textContent = running ? 'Pause' : 'Run';
      this.classList.toggle('active', running);
    });

    document.getElementById('distortBtn').addEventListener('click', distortMesh);

    document.getElementById('resetBtn').addEventListener('click', () => {
      running = false;
      document.getElementById('runBtn').textContent = 'Run';
      document.getElementById('runBtn').classList.remove('active');
      resetMesh();
    });

    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });

    // Initialize
    generateSurface('torus');
    animate();
  </script>
<script src="/sloppy-header/sloppy-bar.js"></script>
</body>
</html>
