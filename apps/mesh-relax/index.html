<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Mesh Relaxation</title>
  <link rel="icon" href="https://emojicdn.elk.sh/ðŸ”º">
  <meta property="og:title" content="Mesh Relaxation">
  <meta property="og:description" content="Watch vertices relax toward equilateral triangles">
  <meta property="og:url" content="https://sloppy.live/mesh-relax">
  <meta property="og:image" content="https://emojicdn.elk.sh/ðŸ”º?style=apple&size=512">
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link href="https://fonts.googleapis.com/css2?family=Space+Grotesk:wght@400;600&family=JetBrains+Mono:wght@400&display=swap" rel="stylesheet">
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      min-height: 100vh;
      background: #0f0f1a;
      font-family: 'Space Grotesk', sans-serif;
      color: #e0e0e0;
      display: flex;
      flex-direction: column;
    }

    .header {
      padding: 1rem 2rem;
      background: linear-gradient(to bottom, rgba(15, 15, 26, 1), rgba(15, 15, 26, 0.8));
      display: flex;
      justify-content: space-between;
      align-items: center;
      flex-wrap: wrap;
      gap: 1rem;
      z-index: 10;
    }

    h1 {
      font-size: 1.4rem;
      font-weight: 600;
      color: #60a5fa;
      text-shadow: 0 0 20px rgba(96, 165, 250, 0.5);
    }

    .stats {
      font-family: 'JetBrains Mono', monospace;
      font-size: 0.75rem;
      color: #94a3b8;
      display: flex;
      gap: 1.5rem;
      flex-wrap: wrap;
    }

    .stat-value {
      color: #34d399;
    }

    .controls {
      display: flex;
      gap: 0.5rem;
      flex-wrap: wrap;
    }

    .btn {
      font-family: 'Space Grotesk', sans-serif;
      font-size: 0.8rem;
      padding: 0.5rem 1rem;
      background: rgba(96, 165, 250, 0.1);
      border: 1px solid #60a5fa;
      color: #60a5fa;
      cursor: pointer;
      transition: all 0.2s;
      border-radius: 4px;
    }

    .btn:hover {
      background: rgba(96, 165, 250, 0.3);
      box-shadow: 0 0 15px rgba(96, 165, 250, 0.3);
    }

    .btn.active {
      background: #60a5fa;
      color: #0f0f1a;
    }

    .btn.reset {
      border-color: #f472b6;
      color: #f472b6;
    }

    .btn.reset:hover {
      background: rgba(244, 114, 182, 0.3);
    }

    canvas {
      flex: 1;
      display: block;
      cursor: crosshair;
    }

    .info {
      position: fixed;
      bottom: 1rem;
      left: 50%;
      transform: translateX(-50%);
      font-size: 0.7rem;
      color: #475569;
      text-align: center;
    }

    .info a {
      color: #64748b;
      text-decoration: none;
    }

    .slider-group {
      display: flex;
      align-items: center;
      gap: 0.5rem;
      font-size: 0.75rem;
      color: #94a3b8;
    }

    .slider-group input[type="range"] {
      width: 80px;
      accent-color: #60a5fa;
    }

    .quality-bar {
      position: fixed;
      bottom: 3rem;
      left: 50%;
      transform: translateX(-50%);
      width: min(300px, 80%);
      text-align: center;
    }

    .quality-label {
      font-size: 0.7rem;
      color: #64748b;
      margin-bottom: 0.3rem;
    }

    .quality-track {
      height: 6px;
      background: #1e293b;
      border-radius: 3px;
      overflow: hidden;
    }

    .quality-fill {
      height: 100%;
      background: linear-gradient(90deg, #f472b6, #60a5fa, #34d399);
      transition: width 0.3s;
    }
  </style>
</head>
<body>
  <div class="header">
    <h1>ðŸ”º Mesh Relaxation</h1>
    <div class="stats">
      <span>Vertices: <span class="stat-value" id="vertCount">0</span></span>
      <span>Triangles: <span class="stat-value" id="triCount">0</span></span>
      <span>Iterations: <span class="stat-value" id="iterCount">0</span></span>
      <span>Quality: <span class="stat-value" id="qualityPct">0%</span></span>
    </div>
    <div class="controls">
      <button class="btn" id="stepBtn">Step</button>
      <button class="btn" id="runBtn">Run</button>
      <div class="slider-group">
        <label>Speed:</label>
        <input type="range" id="speedSlider" min="1" max="60" value="30">
      </div>
      <div class="slider-group">
        <label>Strength:</label>
        <input type="range" id="strengthSlider" min="1" max="100" value="30">
      </div>
      <button class="btn reset" id="resetBtn">Reset</button>
    </div>
  </div>

  <canvas id="canvas"></canvas>

  <div class="quality-bar">
    <div class="quality-label">Mesh Quality (equilateral convergence)</div>
    <div class="quality-track">
      <div class="quality-fill" id="qualityFill" style="width: 0%"></div>
    </div>
  </div>

  <div class="info">
    Click to add vertices â€¢ Drag to move â€¢ Algorithm relaxes toward equilateral triangles<br>
    <a href="https://sloppy.live">sloppy.live</a>
  </div>

  <script>
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');

    // Stats elements
    const vertCountEl = document.getElementById('vertCount');
    const triCountEl = document.getElementById('triCount');
    const iterCountEl = document.getElementById('iterCount');
    const qualityPctEl = document.getElementById('qualityPct');
    const qualityFill = document.getElementById('qualityFill');

    // Controls
    const stepBtn = document.getElementById('stepBtn');
    const runBtn = document.getElementById('runBtn');
    const resetBtn = document.getElementById('resetBtn');
    const speedSlider = document.getElementById('speedSlider');
    const strengthSlider = document.getElementById('strengthSlider');

    let width, height;
    let vertices = [];
    let triangles = [];
    let edges = new Map();
    let running = false;
    let iterations = 0;
    let animationId = null;
    let draggingVertex = null;

    function resize() {
      const rect = canvas.getBoundingClientRect();
      width = canvas.width = rect.width * window.devicePixelRatio;
      height = canvas.height = rect.height * window.devicePixelRatio;
      ctx.scale(window.devicePixelRatio, window.devicePixelRatio);
    }

    // Delaunay triangulation using Bowyer-Watson algorithm
    function triangulate() {
      if (vertices.length < 3) {
        triangles = [];
        return;
      }

      // Create super triangle
      const margin = 1000;
      const superTriangle = [
        { x: -margin, y: -margin, super: true },
        { x: width / window.devicePixelRatio + margin * 2, y: -margin, super: true },
        { x: width / (2 * window.devicePixelRatio), y: height / window.devicePixelRatio + margin * 2, super: true }
      ];

      let tris = [superTriangle];

      // Add each vertex
      for (const vertex of vertices) {
        const badTriangles = [];

        // Find triangles whose circumcircle contains the vertex
        for (const tri of tris) {
          if (inCircumcircle(vertex, tri)) {
            badTriangles.push(tri);
          }
        }

        // Find boundary polygon
        const polygon = [];
        for (const tri of badTriangles) {
          for (let i = 0; i < 3; i++) {
            const edge = [tri[i], tri[(i + 1) % 3]];
            let shared = false;

            for (const other of badTriangles) {
              if (other === tri) continue;
              for (let j = 0; j < 3; j++) {
                const otherEdge = [other[j], other[(j + 1) % 3]];
                if (edgesEqual(edge, otherEdge)) {
                  shared = true;
                  break;
                }
              }
              if (shared) break;
            }

            if (!shared) {
              polygon.push(edge);
            }
          }
        }

        // Remove bad triangles
        tris = tris.filter(t => !badTriangles.includes(t));

        // Create new triangles
        for (const edge of polygon) {
          tris.push([edge[0], edge[1], vertex]);
        }
      }

      // Remove triangles with super triangle vertices
      triangles = tris.filter(tri =>
        !tri.some(v => v.super)
      );

      updateEdges();
      updateStats();
    }

    function edgesEqual(e1, e2) {
      return (e1[0] === e2[0] && e1[1] === e2[1]) ||
             (e1[0] === e2[1] && e1[1] === e2[0]);
    }

    function inCircumcircle(p, tri) {
      const [a, b, c] = tri;
      const ax = a.x - p.x;
      const ay = a.y - p.y;
      const bx = b.x - p.x;
      const by = b.y - p.y;
      const cx = c.x - p.x;
      const cy = c.y - p.y;

      const det = (ax * ax + ay * ay) * (bx * cy - cx * by) -
                  (bx * bx + by * by) * (ax * cy - cx * ay) +
                  (cx * cx + cy * cy) * (ax * by - bx * ay);

      // Check orientation
      const orient = (a.x - c.x) * (b.y - c.y) - (a.y - c.y) * (b.x - c.x);

      return orient > 0 ? det > 0 : det < 0;
    }

    function updateEdges() {
      edges.clear();
      for (const tri of triangles) {
        for (let i = 0; i < 3; i++) {
          const v1 = tri[i];
          const v2 = tri[(i + 1) % 3];
          const key = edgeKey(v1, v2);
          if (!edges.has(key)) {
            edges.set(key, { v1, v2, triangles: [] });
          }
          edges.get(key).triangles.push(tri);
        }
      }
    }

    function edgeKey(v1, v2) {
      const i1 = vertices.indexOf(v1);
      const i2 = vertices.indexOf(v2);
      return i1 < i2 ? `${i1}-${i2}` : `${i2}-${i1}`;
    }

    // Calculate triangle quality (0 = degenerate, 1 = equilateral)
    function triangleQuality(tri) {
      const [a, b, c] = tri;
      const ab = Math.hypot(b.x - a.x, b.y - a.y);
      const bc = Math.hypot(c.x - b.x, c.y - b.y);
      const ca = Math.hypot(a.x - c.x, a.y - c.y);

      const s = (ab + bc + ca) / 2;
      const area = Math.sqrt(Math.max(0, s * (s - ab) * (s - bc) * (s - ca)));

      // Ideal area for equilateral triangle with same perimeter
      const avgEdge = (ab + bc + ca) / 3;
      const idealArea = (Math.sqrt(3) / 4) * avgEdge * avgEdge;

      if (idealArea === 0) return 0;
      return Math.min(1, area / idealArea);
    }

    function averageQuality() {
      if (triangles.length === 0) return 0;
      let total = 0;
      for (const tri of triangles) {
        total += triangleQuality(tri);
      }
      return total / triangles.length;
    }

    // Mesh relaxation step - move vertices toward equilateral constraints
    function relaxStep() {
      if (vertices.length < 3) return;

      const strength = strengthSlider.value / 1000;
      const forces = vertices.map(() => ({ x: 0, y: 0 }));

      // For each edge, apply spring force toward ideal length
      for (const edge of edges.values()) {
        const { v1, v2 } = edge;
        const i1 = vertices.indexOf(v1);
        const i2 = vertices.indexOf(v2);

        if (i1 === -1 || i2 === -1) continue;

        const dx = v2.x - v1.x;
        const dy = v2.y - v1.y;
        const dist = Math.hypot(dx, dy);

        if (dist === 0) continue;

        // Calculate ideal edge length based on connected triangles
        let idealLength = 0;
        let count = 0;

        for (const tri of edge.triangles) {
          // For equilateral: all edges same length
          // Use average of other edges as target
          const [a, b, c] = tri;
          const ab = Math.hypot(b.x - a.x, b.y - a.y);
          const bc = Math.hypot(c.x - b.x, c.y - b.y);
          const ca = Math.hypot(a.x - c.x, a.y - c.y);
          idealLength += (ab + bc + ca) / 3;
          count++;
        }

        if (count > 0) {
          idealLength /= count;
        } else {
          idealLength = dist;
        }

        // Spring force
        const diff = dist - idealLength;
        const fx = (dx / dist) * diff * strength;
        const fy = (dy / dist) * diff * strength;

        forces[i1].x += fx;
        forces[i1].y += fy;
        forces[i2].x -= fx;
        forces[i2].y -= fy;
      }

      // Apply Laplacian smoothing component
      for (const tri of triangles) {
        const [a, b, c] = tri;
        const centroid = {
          x: (a.x + b.x + c.x) / 3,
          y: (a.y + b.y + c.y) / 3
        };

        for (const v of [a, b, c]) {
          const i = vertices.indexOf(v);
          if (i === -1) continue;

          const toCentroid = {
            x: centroid.x - v.x,
            y: centroid.y - v.y
          };

          forces[i].x += toCentroid.x * strength * 0.3;
          forces[i].y += toCentroid.y * strength * 0.3;
        }
      }

      // Apply forces with boundary constraints
      const padding = 20;
      const maxW = width / window.devicePixelRatio - padding;
      const maxH = height / window.devicePixelRatio - padding;

      for (let i = 0; i < vertices.length; i++) {
        if (vertices[i] === draggingVertex) continue;

        vertices[i].x += forces[i].x;
        vertices[i].y += forces[i].y;

        // Keep in bounds
        vertices[i].x = Math.max(padding, Math.min(maxW, vertices[i].x));
        vertices[i].y = Math.max(padding, Math.min(maxH, vertices[i].y));
      }

      // Re-triangulate to maintain Delaunay property
      triangulate();
      iterations++;
      updateStats();
    }

    function updateStats() {
      vertCountEl.textContent = vertices.length;
      triCountEl.textContent = triangles.length;
      iterCountEl.textContent = iterations;

      const quality = averageQuality();
      const pct = Math.round(quality * 100);
      qualityPctEl.textContent = pct + '%';
      qualityFill.style.width = pct + '%';
    }

    function draw() {
      const w = width / window.devicePixelRatio;
      const h = height / window.devicePixelRatio;

      ctx.fillStyle = '#0f0f1a';
      ctx.fillRect(0, 0, w, h);

      // Draw triangles with quality-based coloring
      for (const tri of triangles) {
        const quality = triangleQuality(tri);
        const [a, b, c] = tri;

        // Color based on quality
        const hue = quality * 120; // Red (0) to Green (120)
        ctx.fillStyle = `hsla(${hue}, 70%, 40%, 0.3)`;
        ctx.strokeStyle = `hsla(${hue}, 80%, 60%, 0.8)`;
        ctx.lineWidth = 1;

        ctx.beginPath();
        ctx.moveTo(a.x, a.y);
        ctx.lineTo(b.x, b.y);
        ctx.lineTo(c.x, c.y);
        ctx.closePath();
        ctx.fill();
        ctx.stroke();
      }

      // Draw vertices
      for (const v of vertices) {
        ctx.beginPath();
        ctx.arc(v.x, v.y, 5, 0, Math.PI * 2);
        ctx.fillStyle = v === draggingVertex ? '#f472b6' : '#60a5fa';
        ctx.fill();

        ctx.beginPath();
        ctx.arc(v.x, v.y, 5, 0, Math.PI * 2);
        ctx.strokeStyle = 'rgba(255, 255, 255, 0.5)';
        ctx.lineWidth = 1;
        ctx.stroke();
      }
    }

    function animate() {
      if (running) {
        const speed = parseInt(speedSlider.value);
        for (let i = 0; i < Math.ceil(speed / 10); i++) {
          relaxStep();
        }
      }
      draw();
      animationId = requestAnimationFrame(animate);
    }

    // Generate initial random mesh
    function generateRandomMesh(count = 30) {
      vertices = [];
      const padding = 50;
      const w = width / window.devicePixelRatio - padding * 2;
      const h = height / window.devicePixelRatio - padding * 2;

      for (let i = 0; i < count; i++) {
        vertices.push({
          x: padding + Math.random() * w,
          y: padding + Math.random() * h
        });
      }

      iterations = 0;
      triangulate();
    }

    // Event handlers
    function getMousePos(e) {
      const rect = canvas.getBoundingClientRect();
      return {
        x: e.clientX - rect.left,
        y: e.clientY - rect.top
      };
    }

    function findNearestVertex(pos, threshold = 15) {
      let nearest = null;
      let minDist = threshold;

      for (const v of vertices) {
        const dist = Math.hypot(v.x - pos.x, v.y - pos.y);
        if (dist < minDist) {
          minDist = dist;
          nearest = v;
        }
      }

      return nearest;
    }

    canvas.addEventListener('mousedown', (e) => {
      const pos = getMousePos(e);
      const nearest = findNearestVertex(pos);

      if (nearest) {
        draggingVertex = nearest;
      } else {
        // Add new vertex
        vertices.push({ x: pos.x, y: pos.y });
        triangulate();
      }
    });

    canvas.addEventListener('mousemove', (e) => {
      if (draggingVertex) {
        const pos = getMousePos(e);
        draggingVertex.x = pos.x;
        draggingVertex.y = pos.y;
        triangulate();
      }
    });

    canvas.addEventListener('mouseup', () => {
      draggingVertex = null;
    });

    canvas.addEventListener('mouseleave', () => {
      draggingVertex = null;
    });

    // Touch support
    canvas.addEventListener('touchstart', (e) => {
      e.preventDefault();
      const touch = e.touches[0];
      const pos = getMousePos(touch);
      const nearest = findNearestVertex(pos);

      if (nearest) {
        draggingVertex = nearest;
      } else {
        vertices.push({ x: pos.x, y: pos.y });
        triangulate();
      }
    }, { passive: false });

    canvas.addEventListener('touchmove', (e) => {
      e.preventDefault();
      if (draggingVertex) {
        const touch = e.touches[0];
        const pos = getMousePos(touch);
        draggingVertex.x = pos.x;
        draggingVertex.y = pos.y;
        triangulate();
      }
    }, { passive: false });

    canvas.addEventListener('touchend', () => {
      draggingVertex = null;
    });

    // Button handlers
    stepBtn.addEventListener('click', () => {
      relaxStep();
    });

    runBtn.addEventListener('click', () => {
      running = !running;
      runBtn.textContent = running ? 'Pause' : 'Run';
      runBtn.classList.toggle('active', running);
    });

    resetBtn.addEventListener('click', () => {
      running = false;
      runBtn.textContent = 'Run';
      runBtn.classList.remove('active');
      generateRandomMesh();
    });

    // Initialize
    window.addEventListener('resize', () => {
      resize();
      draw();
    });

    resize();
    generateRandomMesh();
    animate();
  </script>
</body>
</html>
