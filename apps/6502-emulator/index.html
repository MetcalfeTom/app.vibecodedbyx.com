<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>6502 Emulator - Assembly & Memory Visualization</title>
  <link rel="icon" href="https://emojicdn.elk.sh/ðŸ–¥ï¸">
  <meta name="description" content="Visual 6502 CPU emulator with live register tracking and memory map.">
  <meta property="og:title" content="6502 Emulator - Assembly & Memory Visualization">
  <meta property="og:description" content="Visual 6502 CPU emulator with live register tracking and memory map.">
  <meta property="og:url" content="https://sloppy.live/6502-emulator">
  <meta property="og:image" content="https://emojicdn.elk.sh/ðŸ–¥ï¸?style=twitter">
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;500;700&family=Space+Grotesk:wght@400;500;700&display=swap" rel="stylesheet">
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      background: #0a0a0f;
      color: #e0e0e0;
      font-family: 'JetBrains Mono', monospace;
      min-height: 100vh;
    }

    /* CRT Screen Effects */
    .crt-wrapper {
      position: relative;
      min-height: 100vh;
      overflow: hidden;
    }

    /* Scanlines */
    .crt-wrapper::before {
      content: '';
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: repeating-linear-gradient(
        0deg,
        rgba(0, 0, 0, 0.15),
        rgba(0, 0, 0, 0.15) 1px,
        transparent 1px,
        transparent 2px
      );
      pointer-events: none;
      z-index: 1000;
    }

    /* Screen curvature and vignette */
    .crt-wrapper::after {
      content: '';
      position: fixed;
      top: -5%;
      left: -5%;
      right: -5%;
      bottom: -5%;
      background: radial-gradient(
        ellipse at center,
        transparent 0%,
        transparent 60%,
        rgba(0, 0, 0, 0.4) 90%,
        rgba(0, 0, 0, 0.8) 100%
      );
      pointer-events: none;
      z-index: 999;
      border-radius: 50% / 10%;
    }

    /* Phosphor glow on text */
    .crt-wrapper {
      text-shadow: 0 0 2px rgba(100, 255, 100, 0.3);
    }

    /* Subtle screen flicker */
    @keyframes crt-flicker {
      0% { opacity: 1; }
      5% { opacity: 0.98; }
      10% { opacity: 1; }
      15% { opacity: 0.97; }
      20% { opacity: 1; }
      50% { opacity: 0.99; }
      80% { opacity: 1; }
      85% { opacity: 0.98; }
      90% { opacity: 1; }
    }

    .crt-wrapper > * {
      animation: crt-flicker 4s infinite;
    }

    /* RGB split effect on hover */
    .panel:hover {
      text-shadow:
        -1px 0 rgba(255, 0, 0, 0.2),
        1px 0 rgba(0, 255, 255, 0.2);
    }

    /* Glowing elements */
    .register-value, .memory-byte.nonzero, .memory-byte.pc {
      text-shadow: 0 0 8px currentColor;
    }

    .flag.set {
      box-shadow: 0 0 10px rgba(34, 197, 94, 0.5), inset 0 0 5px rgba(34, 197, 94, 0.3);
    }

    /* Enhanced button glow */
    .btn:hover {
      box-shadow: 0 0 15px currentColor;
    }

    /* CRT curved corners on panels */
    .panel {
      box-shadow:
        inset 0 0 50px rgba(0, 0, 0, 0.5),
        0 0 20px rgba(168, 85, 247, 0.1);
    }

    .header {
      background: linear-gradient(135deg, #1a0a2e 0%, #0a0a0f 100%);
      border-bottom: 2px solid #6b21a8;
      padding: 15px 20px;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

    .logo {
      display: flex;
      align-items: center;
      gap: 12px;
    }

    .logo h1 {
      font-family: 'Space Grotesk', sans-serif;
      font-size: 22px;
      font-weight: 700;
      color: #a855f7;
    }

    .logo span {
      font-size: 12px;
      color: #666;
    }

    .container {
      display: grid;
      grid-template-columns: 350px 1fr 280px;
      gap: 15px;
      padding: 15px;
      height: calc(100vh - 60px);
    }

    .panel {
      background: #111118;
      border: 1px solid #2a2a3a;
      border-radius: 8px;
      overflow: hidden;
      display: flex;
      flex-direction: column;
    }

    .panel-header {
      background: #1a1a25;
      padding: 10px 15px;
      font-size: 12px;
      font-weight: 700;
      color: #888;
      text-transform: uppercase;
      letter-spacing: 1px;
      border-bottom: 1px solid #2a2a3a;
    }

    .panel-content {
      flex: 1;
      overflow: auto;
      padding: 10px;
    }

    /* Code Editor */
    .code-editor {
      width: 100%;
      height: 100%;
      background: transparent;
      border: none;
      color: #e0e0e0;
      font-family: 'JetBrains Mono', monospace;
      font-size: 13px;
      line-height: 1.6;
      resize: none;
      outline: none;
    }

    .code-editor::placeholder {
      color: #444;
    }

    /* Controls */
    .controls {
      display: flex;
      gap: 8px;
      padding: 10px 15px;
      background: #1a1a25;
      border-top: 1px solid #2a2a3a;
    }

    .btn {
      padding: 8px 16px;
      font-family: 'JetBrains Mono', monospace;
      font-size: 12px;
      font-weight: 500;
      border: 1px solid #2a2a3a;
      border-radius: 4px;
      cursor: pointer;
      transition: all 0.2s;
    }

    .btn-run {
      background: #166534;
      border-color: #22c55e;
      color: #22c55e;
    }

    .btn-run:hover {
      background: #22c55e;
      color: #000;
    }

    .btn-step {
      background: #1e3a5f;
      border-color: #3b82f6;
      color: #3b82f6;
    }

    .btn-step:hover {
      background: #3b82f6;
      color: #fff;
    }

    .btn-reset {
      background: #4a1515;
      border-color: #ef4444;
      color: #ef4444;
    }

    .btn-reset:hover {
      background: #ef4444;
      color: #fff;
    }

    .btn-assemble {
      background: #4a3415;
      border-color: #f59e0b;
      color: #f59e0b;
    }

    .btn-assemble:hover {
      background: #f59e0b;
      color: #000;
    }

    /* Registers */
    .registers {
      display: grid;
      gap: 8px;
    }

    .register-row {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 8px 12px;
      background: #0a0a0f;
      border-radius: 4px;
    }

    .register-name {
      font-size: 14px;
      font-weight: 700;
      color: #a855f7;
    }

    .register-value {
      font-size: 14px;
      color: #22c55e;
    }

    .register-value.changed {
      color: #f59e0b;
      animation: flash 0.3s;
    }

    @keyframes flash {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.5; }
    }

    /* Flags */
    .flags {
      display: flex;
      gap: 6px;
      margin-top: 10px;
      flex-wrap: wrap;
    }

    .flag {
      width: 32px;
      height: 32px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 12px;
      font-weight: 700;
      border-radius: 4px;
      background: #1a1a25;
      color: #444;
      border: 1px solid #2a2a3a;
    }

    .flag.set {
      background: #166534;
      color: #22c55e;
      border-color: #22c55e;
    }

    /* Memory Map */
    .memory-map {
      font-size: 11px;
      line-height: 1.4;
    }

    .memory-row {
      display: flex;
      gap: 8px;
      padding: 2px 0;
    }

    .memory-addr {
      color: #6b7280;
      min-width: 45px;
    }

    .memory-bytes {
      display: flex;
      gap: 6px;
      flex: 1;
    }

    .memory-byte {
      color: #9ca3af;
      min-width: 20px;
      text-align: center;
    }

    .memory-byte.nonzero {
      color: #22c55e;
    }

    .memory-byte.pc {
      background: #6b21a8;
      color: #fff;
      border-radius: 2px;
    }

    .memory-byte.changed {
      background: #f59e0b;
      color: #000;
      border-radius: 2px;
    }

    .memory-ascii {
      color: #6b7280;
      min-width: 70px;
      font-size: 10px;
    }

    /* Memory Controls */
    .memory-controls {
      display: flex;
      gap: 10px;
      padding: 10px;
      background: #1a1a25;
      border-bottom: 1px solid #2a2a3a;
      align-items: center;
    }

    .memory-controls label {
      font-size: 11px;
      color: #888;
    }

    .memory-controls input {
      width: 60px;
      padding: 4px 8px;
      font-family: 'JetBrains Mono', monospace;
      font-size: 12px;
      background: #0a0a0f;
      border: 1px solid #2a2a3a;
      color: #fff;
      border-radius: 4px;
    }

    /* Status Bar */
    .status-bar {
      background: #1a1a25;
      padding: 8px 15px;
      font-size: 11px;
      color: #666;
      border-top: 1px solid #2a2a3a;
      display: flex;
      justify-content: space-between;
    }

    .status-bar .cycles {
      color: #a855f7;
    }

    /* Output */
    .output {
      font-size: 12px;
      padding: 10px;
      background: #0a0a0f;
      border-radius: 4px;
      margin-top: 10px;
      max-height: 100px;
      overflow-y: auto;
    }

    .output-line {
      color: #22c55e;
    }

    .output-line.error {
      color: #ef4444;
    }

    .stack-display {
      margin-top: 15px;
      padding-top: 15px;
      border-top: 1px solid #2a2a3a;
    }

    .stack-title {
      font-size: 11px;
      color: #888;
      margin-bottom: 8px;
      text-transform: uppercase;
    }

    .stack-values {
      display: flex;
      flex-wrap: wrap;
      gap: 4px;
    }

    .stack-byte {
      padding: 2px 6px;
      background: #1a1a25;
      border-radius: 2px;
      font-size: 11px;
      color: #9ca3af;
    }

    .backlink {
      color: #444;
      font-size: 11px;
      text-decoration: none;
    }

    .backlink:hover {
      color: #a855f7;
    }

    .examples {
      padding: 10px;
      background: #1a1a25;
      border-bottom: 1px solid #2a2a3a;
    }

    .examples select {
      width: 100%;
      padding: 6px;
      font-family: 'JetBrains Mono', monospace;
      font-size: 11px;
      background: #0a0a0f;
      border: 1px solid #2a2a3a;
      color: #fff;
      border-radius: 4px;
    }

    @media (max-width: 1000px) {
      .container {
        grid-template-columns: 1fr;
        grid-template-rows: auto auto auto;
      }
    }
  </style>
</head>
<body>
  <div class="crt-wrapper">
  <header class="header">
    <div class="logo">
      <h1>6502 Emulator</h1>
      <span>MOS Technology 6502 CPU</span>
    </div>
    <a href="https://sloppy.live" class="backlink">sloppy.live</a>
  </header>

  <div class="container">
    <!-- Code Panel -->
    <div class="panel">
      <div class="panel-header">Assembly Code</div>
      <div class="examples">
        <select id="exampleSelect">
          <option value="">-- Load Example --</option>
          <option value="counter">Counter Loop</option>
          <option value="fibonacci">Fibonacci</option>
          <option value="multiply">Multiply</option>
          <option value="flags">Flag Demo</option>
        </select>
      </div>
      <div class="panel-content">
        <textarea class="code-editor" id="codeEditor" placeholder="; Enter 6502 assembly here
; Example:
  LDA #$05    ; Load 5 into A
  STA $0200   ; Store at $0200
  LDX #$00    ; Clear X
loop:
  INX         ; Increment X
  CPX #$10    ; Compare with 16
  BNE loop    ; Branch if not equal
  BRK         ; Break"></textarea>
      </div>
      <div class="controls">
        <button class="btn btn-assemble" id="assembleBtn">Assemble</button>
        <button class="btn btn-run" id="runBtn">Run</button>
        <button class="btn btn-step" id="stepBtn">Step</button>
        <button class="btn btn-reset" id="resetBtn">Reset</button>
      </div>
      <div class="output" id="output"></div>
    </div>

    <!-- Memory Map Panel -->
    <div class="panel">
      <div class="panel-header">Memory Map</div>
      <div class="memory-controls">
        <label>Start:</label>
        <input type="text" id="memStart" value="0000">
        <label>Rows:</label>
        <input type="number" id="memRows" value="32" min="8" max="64">
        <button class="btn btn-step" id="followPC">Follow PC</button>
      </div>
      <div class="panel-content">
        <div class="memory-map" id="memoryMap"></div>
      </div>
      <div class="status-bar">
        <span>64KB Address Space</span>
        <span class="cycles">Cycles: <span id="cycleCount">0</span></span>
      </div>
    </div>

    <!-- Registers Panel -->
    <div class="panel">
      <div class="panel-header">Registers</div>
      <div class="panel-content">
        <div class="registers">
          <div class="register-row">
            <span class="register-name">A</span>
            <span class="register-value" id="regA">$00</span>
          </div>
          <div class="register-row">
            <span class="register-name">X</span>
            <span class="register-value" id="regX">$00</span>
          </div>
          <div class="register-row">
            <span class="register-name">Y</span>
            <span class="register-value" id="regY">$00</span>
          </div>
          <div class="register-row">
            <span class="register-name">SP</span>
            <span class="register-value" id="regSP">$FF</span>
          </div>
          <div class="register-row">
            <span class="register-name">PC</span>
            <span class="register-value" id="regPC">$0600</span>
          </div>
        </div>

        <div style="margin-top:15px">
          <div class="panel-header" style="margin:-10px -10px 10px -10px;padding:8px 12px">Status Flags (P)</div>
          <div class="flags">
            <div class="flag" id="flagN" title="Negative">N</div>
            <div class="flag" id="flagV" title="Overflow">V</div>
            <div class="flag" id="flagU" title="Unused">-</div>
            <div class="flag" id="flagB" title="Break">B</div>
            <div class="flag" id="flagD" title="Decimal">D</div>
            <div class="flag" id="flagI" title="Interrupt">I</div>
            <div class="flag" id="flagZ" title="Zero">Z</div>
            <div class="flag" id="flagC" title="Carry">C</div>
          </div>
        </div>

        <div class="stack-display">
          <div class="stack-title">Stack ($0100-$01FF)</div>
          <div class="stack-values" id="stackDisplay"></div>
        </div>
      </div>
    </div>
  </div>

  <script>
    // 6502 CPU Emulator
    class CPU6502 {
      constructor() {
        this.reset();
      }

      reset() {
        // Registers
        this.A = 0;      // Accumulator
        this.X = 0;      // X Index
        this.Y = 0;      // Y Index
        this.SP = 0xFF;  // Stack Pointer
        this.PC = 0x0600; // Program Counter (start at $0600)

        // Status flags
        this.N = false;  // Negative
        this.V = false;  // Overflow
        this.B = false;  // Break
        this.D = false;  // Decimal
        this.I = false;  // Interrupt Disable
        this.Z = false;  // Zero
        this.C = false;  // Carry

        // Memory (64KB)
        this.memory = new Uint8Array(0x10000);

        // State
        this.cycles = 0;
        this.halted = false;
        this.changedAddrs = new Set();
      }

      // Memory access
      read(addr) {
        return this.memory[addr & 0xFFFF];
      }

      write(addr, value) {
        addr = addr & 0xFFFF;
        this.memory[addr] = value & 0xFF;
        this.changedAddrs.add(addr);
      }

      // Stack operations
      push(value) {
        this.write(0x0100 + this.SP, value);
        this.SP = (this.SP - 1) & 0xFF;
      }

      pull() {
        this.SP = (this.SP + 1) & 0xFF;
        return this.read(0x0100 + this.SP);
      }

      pushWord(value) {
        this.push((value >> 8) & 0xFF);
        this.push(value & 0xFF);
      }

      pullWord() {
        const lo = this.pull();
        const hi = this.pull();
        return (hi << 8) | lo;
      }

      // Flag helpers
      setNZ(value) {
        this.N = (value & 0x80) !== 0;
        this.Z = (value & 0xFF) === 0;
      }

      getStatus() {
        return (this.N ? 0x80 : 0) |
               (this.V ? 0x40 : 0) |
               0x20 |
               (this.B ? 0x10 : 0) |
               (this.D ? 0x08 : 0) |
               (this.I ? 0x04 : 0) |
               (this.Z ? 0x02 : 0) |
               (this.C ? 0x01 : 0);
      }

      setStatus(value) {
        this.N = (value & 0x80) !== 0;
        this.V = (value & 0x40) !== 0;
        this.B = (value & 0x10) !== 0;
        this.D = (value & 0x08) !== 0;
        this.I = (value & 0x04) !== 0;
        this.Z = (value & 0x02) !== 0;
        this.C = (value & 0x01) !== 0;
      }

      // Addressing modes
      immediate() { return this.PC++; }
      zeroPage() { return this.read(this.PC++); }
      zeroPageX() { return (this.read(this.PC++) + this.X) & 0xFF; }
      zeroPageY() { return (this.read(this.PC++) + this.Y) & 0xFF; }
      absolute() {
        const lo = this.read(this.PC++);
        const hi = this.read(this.PC++);
        return (hi << 8) | lo;
      }
      absoluteX() { return (this.absolute() + this.X) & 0xFFFF; }
      absoluteY() { return (this.absolute() + this.Y) & 0xFFFF; }
      indirectX() {
        const ptr = (this.read(this.PC++) + this.X) & 0xFF;
        return this.read(ptr) | (this.read((ptr + 1) & 0xFF) << 8);
      }
      indirectY() {
        const ptr = this.read(this.PC++);
        const base = this.read(ptr) | (this.read((ptr + 1) & 0xFF) << 8);
        return (base + this.Y) & 0xFFFF;
      }
      relative() {
        const offset = this.read(this.PC++);
        return offset < 128 ? offset : offset - 256;
      }

      // Execute one instruction
      step() {
        if (this.halted) return false;
        this.changedAddrs.clear();

        const opcode = this.read(this.PC++);
        this.cycles++;

        switch (opcode) {
          // LDA
          case 0xA9: this.A = this.read(this.immediate()); this.setNZ(this.A); break;
          case 0xA5: this.A = this.read(this.zeroPage()); this.setNZ(this.A); break;
          case 0xB5: this.A = this.read(this.zeroPageX()); this.setNZ(this.A); break;
          case 0xAD: this.A = this.read(this.absolute()); this.setNZ(this.A); break;
          case 0xBD: this.A = this.read(this.absoluteX()); this.setNZ(this.A); break;
          case 0xB9: this.A = this.read(this.absoluteY()); this.setNZ(this.A); break;
          case 0xA1: this.A = this.read(this.indirectX()); this.setNZ(this.A); break;
          case 0xB1: this.A = this.read(this.indirectY()); this.setNZ(this.A); break;

          // LDX
          case 0xA2: this.X = this.read(this.immediate()); this.setNZ(this.X); break;
          case 0xA6: this.X = this.read(this.zeroPage()); this.setNZ(this.X); break;
          case 0xB6: this.X = this.read(this.zeroPageY()); this.setNZ(this.X); break;
          case 0xAE: this.X = this.read(this.absolute()); this.setNZ(this.X); break;
          case 0xBE: this.X = this.read(this.absoluteY()); this.setNZ(this.X); break;

          // LDY
          case 0xA0: this.Y = this.read(this.immediate()); this.setNZ(this.Y); break;
          case 0xA4: this.Y = this.read(this.zeroPage()); this.setNZ(this.Y); break;
          case 0xB4: this.Y = this.read(this.zeroPageX()); this.setNZ(this.Y); break;
          case 0xAC: this.Y = this.read(this.absolute()); this.setNZ(this.Y); break;
          case 0xBC: this.Y = this.read(this.absoluteX()); this.setNZ(this.Y); break;

          // STA
          case 0x85: this.write(this.zeroPage(), this.A); break;
          case 0x95: this.write(this.zeroPageX(), this.A); break;
          case 0x8D: this.write(this.absolute(), this.A); break;
          case 0x9D: this.write(this.absoluteX(), this.A); break;
          case 0x99: this.write(this.absoluteY(), this.A); break;
          case 0x81: this.write(this.indirectX(), this.A); break;
          case 0x91: this.write(this.indirectY(), this.A); break;

          // STX
          case 0x86: this.write(this.zeroPage(), this.X); break;
          case 0x96: this.write(this.zeroPageY(), this.X); break;
          case 0x8E: this.write(this.absolute(), this.X); break;

          // STY
          case 0x84: this.write(this.zeroPage(), this.Y); break;
          case 0x94: this.write(this.zeroPageX(), this.Y); break;
          case 0x8C: this.write(this.absolute(), this.Y); break;

          // Transfer
          case 0xAA: this.X = this.A; this.setNZ(this.X); break; // TAX
          case 0xA8: this.Y = this.A; this.setNZ(this.Y); break; // TAY
          case 0x8A: this.A = this.X; this.setNZ(this.A); break; // TXA
          case 0x98: this.A = this.Y; this.setNZ(this.A); break; // TYA
          case 0xBA: this.X = this.SP; this.setNZ(this.X); break; // TSX
          case 0x9A: this.SP = this.X; break; // TXS

          // Stack
          case 0x48: this.push(this.A); break; // PHA
          case 0x08: this.push(this.getStatus() | 0x10); break; // PHP
          case 0x68: this.A = this.pull(); this.setNZ(this.A); break; // PLA
          case 0x28: this.setStatus(this.pull()); break; // PLP

          // Arithmetic
          case 0x69: { // ADC immediate
            const val = this.read(this.immediate());
            const sum = this.A + val + (this.C ? 1 : 0);
            this.V = (~(this.A ^ val) & (this.A ^ sum) & 0x80) !== 0;
            this.C = sum > 0xFF;
            this.A = sum & 0xFF;
            this.setNZ(this.A);
            break;
          }
          case 0x65: case 0x75: case 0x6D: case 0x7D: case 0x79: case 0x61: case 0x71: {
            let addr;
            switch (opcode) {
              case 0x65: addr = this.zeroPage(); break;
              case 0x75: addr = this.zeroPageX(); break;
              case 0x6D: addr = this.absolute(); break;
              case 0x7D: addr = this.absoluteX(); break;
              case 0x79: addr = this.absoluteY(); break;
              case 0x61: addr = this.indirectX(); break;
              case 0x71: addr = this.indirectY(); break;
            }
            const val = this.read(addr);
            const sum = this.A + val + (this.C ? 1 : 0);
            this.V = (~(this.A ^ val) & (this.A ^ sum) & 0x80) !== 0;
            this.C = sum > 0xFF;
            this.A = sum & 0xFF;
            this.setNZ(this.A);
            break;
          }

          case 0xE9: { // SBC immediate
            const val = this.read(this.immediate());
            const diff = this.A - val - (this.C ? 0 : 1);
            this.V = ((this.A ^ val) & (this.A ^ diff) & 0x80) !== 0;
            this.C = diff >= 0;
            this.A = diff & 0xFF;
            this.setNZ(this.A);
            break;
          }
          case 0xE5: case 0xF5: case 0xED: case 0xFD: case 0xF9: case 0xE1: case 0xF1: {
            let addr;
            switch (opcode) {
              case 0xE5: addr = this.zeroPage(); break;
              case 0xF5: addr = this.zeroPageX(); break;
              case 0xED: addr = this.absolute(); break;
              case 0xFD: addr = this.absoluteX(); break;
              case 0xF9: addr = this.absoluteY(); break;
              case 0xE1: addr = this.indirectX(); break;
              case 0xF1: addr = this.indirectY(); break;
            }
            const val = this.read(addr);
            const diff = this.A - val - (this.C ? 0 : 1);
            this.V = ((this.A ^ val) & (this.A ^ diff) & 0x80) !== 0;
            this.C = diff >= 0;
            this.A = diff & 0xFF;
            this.setNZ(this.A);
            break;
          }

          // Compare
          case 0xC9: case 0xC5: case 0xD5: case 0xCD: case 0xDD: case 0xD9: case 0xC1: case 0xD1: {
            let addr;
            switch (opcode) {
              case 0xC9: addr = this.immediate(); break;
              case 0xC5: addr = this.zeroPage(); break;
              case 0xD5: addr = this.zeroPageX(); break;
              case 0xCD: addr = this.absolute(); break;
              case 0xDD: addr = this.absoluteX(); break;
              case 0xD9: addr = this.absoluteY(); break;
              case 0xC1: addr = this.indirectX(); break;
              case 0xD1: addr = this.indirectY(); break;
            }
            const val = this.read(addr);
            const diff = this.A - val;
            this.C = this.A >= val;
            this.setNZ(diff & 0xFF);
            break;
          }

          case 0xE0: case 0xE4: case 0xEC: { // CPX
            let addr;
            switch (opcode) {
              case 0xE0: addr = this.immediate(); break;
              case 0xE4: addr = this.zeroPage(); break;
              case 0xEC: addr = this.absolute(); break;
            }
            const val = this.read(addr);
            this.C = this.X >= val;
            this.setNZ((this.X - val) & 0xFF);
            break;
          }

          case 0xC0: case 0xC4: case 0xCC: { // CPY
            let addr;
            switch (opcode) {
              case 0xC0: addr = this.immediate(); break;
              case 0xC4: addr = this.zeroPage(); break;
              case 0xCC: addr = this.absolute(); break;
            }
            const val = this.read(addr);
            this.C = this.Y >= val;
            this.setNZ((this.Y - val) & 0xFF);
            break;
          }

          // Increment/Decrement
          case 0xE6: case 0xF6: case 0xEE: case 0xFE: { // INC
            let addr;
            switch (opcode) {
              case 0xE6: addr = this.zeroPage(); break;
              case 0xF6: addr = this.zeroPageX(); break;
              case 0xEE: addr = this.absolute(); break;
              case 0xFE: addr = this.absoluteX(); break;
            }
            const val = (this.read(addr) + 1) & 0xFF;
            this.write(addr, val);
            this.setNZ(val);
            break;
          }

          case 0xC6: case 0xD6: case 0xCE: case 0xDE: { // DEC
            let addr;
            switch (opcode) {
              case 0xC6: addr = this.zeroPage(); break;
              case 0xD6: addr = this.zeroPageX(); break;
              case 0xCE: addr = this.absolute(); break;
              case 0xDE: addr = this.absoluteX(); break;
            }
            const val = (this.read(addr) - 1) & 0xFF;
            this.write(addr, val);
            this.setNZ(val);
            break;
          }

          case 0xE8: this.X = (this.X + 1) & 0xFF; this.setNZ(this.X); break; // INX
          case 0xC8: this.Y = (this.Y + 1) & 0xFF; this.setNZ(this.Y); break; // INY
          case 0xCA: this.X = (this.X - 1) & 0xFF; this.setNZ(this.X); break; // DEX
          case 0x88: this.Y = (this.Y - 1) & 0xFF; this.setNZ(this.Y); break; // DEY

          // Logical
          case 0x29: this.A &= this.read(this.immediate()); this.setNZ(this.A); break; // AND imm
          case 0x25: case 0x35: case 0x2D: case 0x3D: case 0x39: case 0x21: case 0x31: {
            let addr;
            switch (opcode) {
              case 0x25: addr = this.zeroPage(); break;
              case 0x35: addr = this.zeroPageX(); break;
              case 0x2D: addr = this.absolute(); break;
              case 0x3D: addr = this.absoluteX(); break;
              case 0x39: addr = this.absoluteY(); break;
              case 0x21: addr = this.indirectX(); break;
              case 0x31: addr = this.indirectY(); break;
            }
            this.A &= this.read(addr);
            this.setNZ(this.A);
            break;
          }

          case 0x09: this.A |= this.read(this.immediate()); this.setNZ(this.A); break; // ORA imm
          case 0x05: case 0x15: case 0x0D: case 0x1D: case 0x19: case 0x01: case 0x11: {
            let addr;
            switch (opcode) {
              case 0x05: addr = this.zeroPage(); break;
              case 0x15: addr = this.zeroPageX(); break;
              case 0x0D: addr = this.absolute(); break;
              case 0x1D: addr = this.absoluteX(); break;
              case 0x19: addr = this.absoluteY(); break;
              case 0x01: addr = this.indirectX(); break;
              case 0x11: addr = this.indirectY(); break;
            }
            this.A |= this.read(addr);
            this.setNZ(this.A);
            break;
          }

          case 0x49: this.A ^= this.read(this.immediate()); this.setNZ(this.A); break; // EOR imm
          case 0x45: case 0x55: case 0x4D: case 0x5D: case 0x59: case 0x41: case 0x51: {
            let addr;
            switch (opcode) {
              case 0x45: addr = this.zeroPage(); break;
              case 0x55: addr = this.zeroPageX(); break;
              case 0x4D: addr = this.absolute(); break;
              case 0x5D: addr = this.absoluteX(); break;
              case 0x59: addr = this.absoluteY(); break;
              case 0x41: addr = this.indirectX(); break;
              case 0x51: addr = this.indirectY(); break;
            }
            this.A ^= this.read(addr);
            this.setNZ(this.A);
            break;
          }

          // Shifts
          case 0x0A: this.C = (this.A & 0x80) !== 0; this.A = (this.A << 1) & 0xFF; this.setNZ(this.A); break; // ASL A
          case 0x4A: this.C = (this.A & 0x01) !== 0; this.A = this.A >> 1; this.setNZ(this.A); break; // LSR A
          case 0x2A: { // ROL A
            const c = this.C ? 1 : 0;
            this.C = (this.A & 0x80) !== 0;
            this.A = ((this.A << 1) | c) & 0xFF;
            this.setNZ(this.A);
            break;
          }
          case 0x6A: { // ROR A
            const c = this.C ? 0x80 : 0;
            this.C = (this.A & 0x01) !== 0;
            this.A = (this.A >> 1) | c;
            this.setNZ(this.A);
            break;
          }

          // Branches
          case 0x10: { const off = this.relative(); if (!this.N) this.PC += off; break; } // BPL
          case 0x30: { const off = this.relative(); if (this.N) this.PC += off; break; }  // BMI
          case 0x50: { const off = this.relative(); if (!this.V) this.PC += off; break; } // BVC
          case 0x70: { const off = this.relative(); if (this.V) this.PC += off; break; }  // BVS
          case 0x90: { const off = this.relative(); if (!this.C) this.PC += off; break; } // BCC
          case 0xB0: { const off = this.relative(); if (this.C) this.PC += off; break; }  // BCS
          case 0xD0: { const off = this.relative(); if (!this.Z) this.PC += off; break; } // BNE
          case 0xF0: { const off = this.relative(); if (this.Z) this.PC += off; break; }  // BEQ

          // Jump/Call
          case 0x4C: this.PC = this.absolute(); break; // JMP abs
          case 0x6C: { // JMP indirect
            const ptr = this.absolute();
            const lo = this.read(ptr);
            const hi = this.read((ptr & 0xFF00) | ((ptr + 1) & 0xFF));
            this.PC = (hi << 8) | lo;
            break;
          }
          case 0x20: { // JSR
            const addr = this.absolute();
            this.pushWord(this.PC - 1);
            this.PC = addr;
            break;
          }
          case 0x60: this.PC = this.pullWord() + 1; break; // RTS
          case 0x40: { // RTI
            this.setStatus(this.pull());
            this.PC = this.pullWord();
            break;
          }

          // Flag operations
          case 0x18: this.C = false; break; // CLC
          case 0x38: this.C = true; break;  // SEC
          case 0x58: this.I = false; break; // CLI
          case 0x78: this.I = true; break;  // SEI
          case 0xB8: this.V = false; break; // CLV
          case 0xD8: this.D = false; break; // CLD
          case 0xF8: this.D = true; break;  // SED

          // BIT
          case 0x24: case 0x2C: {
            const addr = opcode === 0x24 ? this.zeroPage() : this.absolute();
            const val = this.read(addr);
            this.N = (val & 0x80) !== 0;
            this.V = (val & 0x40) !== 0;
            this.Z = (this.A & val) === 0;
            break;
          }

          // NOP
          case 0xEA: break;

          // BRK
          case 0x00:
            this.halted = true;
            break;

          default:
            console.log(`Unknown opcode: $${opcode.toString(16).toUpperCase()}`);
            this.halted = true;
        }

        return !this.halted;
      }
    }

    // Simple Assembler
    class Assembler {
      constructor() {
        this.opcodes = {
          'BRK': { impl: 0x00 },
          'ORA': { indX: 0x01, zpg: 0x05, imm: 0x09, abs: 0x0D, indY: 0x11, zpgX: 0x15, absY: 0x19, absX: 0x1D },
          'ASL': { impl: 0x0A, zpg: 0x06, abs: 0x0E, zpgX: 0x16, absX: 0x1E },
          'PHP': { impl: 0x08 },
          'BPL': { rel: 0x10 },
          'CLC': { impl: 0x18 },
          'JSR': { abs: 0x20 },
          'AND': { indX: 0x21, zpg: 0x25, imm: 0x29, abs: 0x2D, indY: 0x31, zpgX: 0x35, absY: 0x39, absX: 0x3D },
          'BIT': { zpg: 0x24, abs: 0x2C },
          'ROL': { impl: 0x2A, zpg: 0x26, abs: 0x2E, zpgX: 0x36, absX: 0x3E },
          'PLP': { impl: 0x28 },
          'BMI': { rel: 0x30 },
          'SEC': { impl: 0x38 },
          'RTI': { impl: 0x40 },
          'EOR': { indX: 0x41, zpg: 0x45, imm: 0x49, abs: 0x4D, indY: 0x51, zpgX: 0x55, absY: 0x59, absX: 0x5D },
          'LSR': { impl: 0x4A, zpg: 0x46, abs: 0x4E, zpgX: 0x56, absX: 0x5E },
          'PHA': { impl: 0x48 },
          'JMP': { abs: 0x4C, ind: 0x6C },
          'BVC': { rel: 0x50 },
          'CLI': { impl: 0x58 },
          'RTS': { impl: 0x60 },
          'ADC': { indX: 0x61, zpg: 0x65, imm: 0x69, abs: 0x6D, indY: 0x71, zpgX: 0x75, absY: 0x79, absX: 0x7D },
          'ROR': { impl: 0x6A, zpg: 0x66, abs: 0x6E, zpgX: 0x76, absX: 0x7E },
          'PLA': { impl: 0x68 },
          'BVS': { rel: 0x70 },
          'SEI': { impl: 0x78 },
          'STA': { indX: 0x81, zpg: 0x85, abs: 0x8D, indY: 0x91, zpgX: 0x95, absY: 0x99, absX: 0x9D },
          'STY': { zpg: 0x84, abs: 0x8C, zpgX: 0x94 },
          'STX': { zpg: 0x86, abs: 0x8E, zpgY: 0x96 },
          'DEY': { impl: 0x88 },
          'TXA': { impl: 0x8A },
          'BCC': { rel: 0x90 },
          'TYA': { impl: 0x98 },
          'TXS': { impl: 0x9A },
          'LDY': { imm: 0xA0, zpg: 0xA4, abs: 0xAC, zpgX: 0xB4, absX: 0xBC },
          'LDA': { indX: 0xA1, zpg: 0xA5, imm: 0xA9, abs: 0xAD, indY: 0xB1, zpgX: 0xB5, absY: 0xB9, absX: 0xBD },
          'LDX': { imm: 0xA2, zpg: 0xA6, abs: 0xAE, zpgY: 0xB6, absY: 0xBE },
          'TAY': { impl: 0xA8 },
          'TAX': { impl: 0xAA },
          'BCS': { rel: 0xB0 },
          'CLV': { impl: 0xB8 },
          'TSX': { impl: 0xBA },
          'CPY': { imm: 0xC0, zpg: 0xC4, abs: 0xCC },
          'CMP': { indX: 0xC1, zpg: 0xC5, imm: 0xC9, abs: 0xCD, indY: 0xD1, zpgX: 0xD5, absY: 0xD9, absX: 0xDD },
          'DEC': { zpg: 0xC6, abs: 0xCE, zpgX: 0xD6, absX: 0xDE },
          'INY': { impl: 0xC8 },
          'DEX': { impl: 0xCA },
          'BNE': { rel: 0xD0 },
          'CLD': { impl: 0xD8 },
          'CPX': { imm: 0xE0, zpg: 0xE4, abs: 0xEC },
          'SBC': { indX: 0xE1, zpg: 0xE5, imm: 0xE9, abs: 0xED, indY: 0xF1, zpgX: 0xF5, absY: 0xF9, absX: 0xFD },
          'INC': { zpg: 0xE6, abs: 0xEE, zpgX: 0xF6, absX: 0xFE },
          'INX': { impl: 0xE8 },
          'NOP': { impl: 0xEA },
          'BEQ': { rel: 0xF0 },
          'SED': { impl: 0xF8 }
        };
      }

      assemble(code, startAddr = 0x0600) {
        const lines = code.split('\n');
        const bytes = [];
        const labels = {};
        const refs = [];
        let addr = startAddr;

        // First pass - find labels
        for (const line of lines) {
          const clean = line.split(';')[0].trim();
          if (!clean) continue;

          const labelMatch = clean.match(/^(\w+):$/);
          if (labelMatch) {
            labels[labelMatch[1]] = addr;
            continue;
          }

          const parts = clean.split(/\s+/);
          const mnemonic = parts[0].toUpperCase();

          if (this.opcodes[mnemonic]) {
            const operand = parts.slice(1).join(' ');
            const size = this.getInstructionSize(mnemonic, operand);
            addr += size;
          }
        }

        // Second pass - generate bytes
        addr = startAddr;
        for (const line of lines) {
          const clean = line.split(';')[0].trim();
          if (!clean) continue;
          if (clean.match(/^(\w+):$/)) continue;

          const parts = clean.split(/\s+/);
          const mnemonic = parts[0].toUpperCase();
          const operand = parts.slice(1).join(' ');

          if (this.opcodes[mnemonic]) {
            const result = this.assembleInstruction(mnemonic, operand, addr, labels);
            if (result.error) return { error: result.error };
            bytes.push(...result.bytes);
            addr += result.bytes.length;
          }
        }

        return { bytes, startAddr };
      }

      getInstructionSize(mnemonic, operand) {
        if (!operand || operand === 'A') return 1;
        if (operand.startsWith('#')) return 2;
        if (operand.match(/^\$[0-9A-Fa-f]{1,2}$/)) return 2;
        if (operand.match(/^\$[0-9A-Fa-f]{3,4}/)) return 3;
        if (operand.match(/^\(/)) return operand.includes(',Y') ? 2 : 3;
        // Branch or label
        const op = this.opcodes[mnemonic];
        if (op && op.rel) return 2;
        return 3; // Default to absolute for labels
      }

      assembleInstruction(mnemonic, operand, currentAddr, labels) {
        const op = this.opcodes[mnemonic];
        if (!op) return { error: `Unknown mnemonic: ${mnemonic}` };

        // Implied
        if (!operand || operand === '') {
          if (op.impl !== undefined) return { bytes: [op.impl] };
          return { error: `${mnemonic} requires an operand` };
        }

        // Accumulator
        if (operand === 'A') {
          if (op.impl !== undefined) return { bytes: [op.impl] };
          return { error: `${mnemonic} A not supported` };
        }

        // Immediate
        if (operand.startsWith('#')) {
          if (op.imm === undefined) return { error: `${mnemonic} doesn't support immediate mode` };
          const val = this.parseValue(operand.substring(1));
          return { bytes: [op.imm, val & 0xFF] };
        }

        // Indirect X: ($nn,X)
        if (operand.match(/^\(\$[0-9A-Fa-f]+,\s*X\)$/i)) {
          if (op.indX === undefined) return { error: `${mnemonic} doesn't support (indirect,X) mode` };
          const val = this.parseValue(operand.match(/\$[0-9A-Fa-f]+/)[0]);
          return { bytes: [op.indX, val & 0xFF] };
        }

        // Indirect Y: ($nn),Y
        if (operand.match(/^\(\$[0-9A-Fa-f]+\),\s*Y$/i)) {
          if (op.indY === undefined) return { error: `${mnemonic} doesn't support (indirect),Y mode` };
          const val = this.parseValue(operand.match(/\$[0-9A-Fa-f]+/)[0]);
          return { bytes: [op.indY, val & 0xFF] };
        }

        // Indirect: ($nnnn)
        if (operand.match(/^\(\$[0-9A-Fa-f]+\)$/)) {
          if (op.ind === undefined) return { error: `${mnemonic} doesn't support indirect mode` };
          const val = this.parseValue(operand.match(/\$[0-9A-Fa-f]+/)[0]);
          return { bytes: [op.ind, val & 0xFF, (val >> 8) & 0xFF] };
        }

        // Zero page X: $nn,X
        if (operand.match(/^\$[0-9A-Fa-f]{1,2},\s*X$/i)) {
          if (op.zpgX === undefined) return { error: `${mnemonic} doesn't support zero page,X mode` };
          const val = this.parseValue(operand.split(',')[0]);
          return { bytes: [op.zpgX, val & 0xFF] };
        }

        // Zero page Y: $nn,Y
        if (operand.match(/^\$[0-9A-Fa-f]{1,2},\s*Y$/i)) {
          if (op.zpgY === undefined) return { error: `${mnemonic} doesn't support zero page,Y mode` };
          const val = this.parseValue(operand.split(',')[0]);
          return { bytes: [op.zpgY, val & 0xFF] };
        }

        // Absolute X: $nnnn,X
        if (operand.match(/^\$[0-9A-Fa-f]{3,4},\s*X$/i)) {
          if (op.absX === undefined) return { error: `${mnemonic} doesn't support absolute,X mode` };
          const val = this.parseValue(operand.split(',')[0]);
          return { bytes: [op.absX, val & 0xFF, (val >> 8) & 0xFF] };
        }

        // Absolute Y: $nnnn,Y
        if (operand.match(/^\$[0-9A-Fa-f]{3,4},\s*Y$/i)) {
          if (op.absY === undefined) return { error: `${mnemonic} doesn't support absolute,Y mode` };
          const val = this.parseValue(operand.split(',')[0]);
          return { bytes: [op.absY, val & 0xFF, (val >> 8) & 0xFF] };
        }

        // Zero page: $nn
        if (operand.match(/^\$[0-9A-Fa-f]{1,2}$/)) {
          if (op.zpg === undefined) return { error: `${mnemonic} doesn't support zero page mode` };
          const val = this.parseValue(operand);
          return { bytes: [op.zpg, val & 0xFF] };
        }

        // Absolute: $nnnn
        if (operand.match(/^\$[0-9A-Fa-f]{3,4}$/)) {
          if (op.abs === undefined) return { error: `${mnemonic} doesn't support absolute mode` };
          const val = this.parseValue(operand);
          return { bytes: [op.abs, val & 0xFF, (val >> 8) & 0xFF] };
        }

        // Label (for branches or jumps)
        if (operand.match(/^\w+$/)) {
          const labelAddr = labels[operand];
          if (labelAddr === undefined) return { error: `Unknown label: ${operand}` };

          if (op.rel !== undefined) {
            // Relative branch
            const offset = labelAddr - (currentAddr + 2);
            if (offset < -128 || offset > 127) return { error: `Branch target too far: ${operand}` };
            return { bytes: [op.rel, offset & 0xFF] };
          } else if (op.abs !== undefined) {
            // Absolute jump
            return { bytes: [op.abs, labelAddr & 0xFF, (labelAddr >> 8) & 0xFF] };
          }
          return { error: `${mnemonic} can't use label` };
        }

        return { error: `Invalid operand: ${operand}` };
      }

      parseValue(str) {
        if (str.startsWith('$')) return parseInt(str.substring(1), 16);
        if (str.startsWith('%')) return parseInt(str.substring(1), 2);
        return parseInt(str, 10);
      }
    }

    // UI
    const cpu = new CPU6502();
    const assembler = new Assembler();
    let running = false;
    let runInterval = null;

    const codeEditor = document.getElementById('codeEditor');
    const output = document.getElementById('output');

    function log(msg, isError = false) {
      const line = document.createElement('div');
      line.className = 'output-line' + (isError ? ' error' : '');
      line.textContent = msg;
      output.appendChild(line);
      output.scrollTop = output.scrollHeight;
    }

    function clearOutput() {
      output.innerHTML = '';
    }

    function updateDisplay() {
      // Registers
      document.getElementById('regA').textContent = '$' + cpu.A.toString(16).toUpperCase().padStart(2, '0');
      document.getElementById('regX').textContent = '$' + cpu.X.toString(16).toUpperCase().padStart(2, '0');
      document.getElementById('regY').textContent = '$' + cpu.Y.toString(16).toUpperCase().padStart(2, '0');
      document.getElementById('regSP').textContent = '$' + cpu.SP.toString(16).toUpperCase().padStart(2, '0');
      document.getElementById('regPC').textContent = '$' + cpu.PC.toString(16).toUpperCase().padStart(4, '0');

      // Flags
      document.getElementById('flagN').className = 'flag' + (cpu.N ? ' set' : '');
      document.getElementById('flagV').className = 'flag' + (cpu.V ? ' set' : '');
      document.getElementById('flagB').className = 'flag' + (cpu.B ? ' set' : '');
      document.getElementById('flagD').className = 'flag' + (cpu.D ? ' set' : '');
      document.getElementById('flagI').className = 'flag' + (cpu.I ? ' set' : '');
      document.getElementById('flagZ').className = 'flag' + (cpu.Z ? ' set' : '');
      document.getElementById('flagC').className = 'flag' + (cpu.C ? ' set' : '');

      // Cycles
      document.getElementById('cycleCount').textContent = cpu.cycles;

      // Stack
      const stackDisplay = document.getElementById('stackDisplay');
      stackDisplay.innerHTML = '';
      for (let i = 0xFF; i > cpu.SP && i > cpu.SP - 8; i--) {
        const byte = document.createElement('span');
        byte.className = 'stack-byte';
        byte.textContent = '$' + cpu.read(0x0100 + i).toString(16).toUpperCase().padStart(2, '0');
        stackDisplay.appendChild(byte);
      }
      if (cpu.SP === 0xFF) {
        stackDisplay.innerHTML = '<span style="color:#666">Empty</span>';
      }

      // Memory
      updateMemoryMap();
    }

    function updateMemoryMap() {
      const memMap = document.getElementById('memoryMap');
      const startInput = document.getElementById('memStart');
      const rowsInput = document.getElementById('memRows');

      let start = parseInt(startInput.value, 16) || 0;
      const rows = parseInt(rowsInput.value) || 32;

      let html = '';
      for (let row = 0; row < rows; row++) {
        const addr = (start + row * 16) & 0xFFFF;
        let bytesHtml = '';
        let ascii = '';

        for (let col = 0; col < 16; col++) {
          const a = (addr + col) & 0xFFFF;
          const byte = cpu.read(a);
          let cls = 'memory-byte';
          if (byte !== 0) cls += ' nonzero';
          if (a === cpu.PC) cls += ' pc';
          if (cpu.changedAddrs.has(a)) cls += ' changed';

          bytesHtml += `<span class="${cls}">${byte.toString(16).toUpperCase().padStart(2, '0')}</span>`;

          const char = byte >= 32 && byte < 127 ? String.fromCharCode(byte) : '.';
          ascii += char;
        }

        html += `<div class="memory-row">
          <span class="memory-addr">${addr.toString(16).toUpperCase().padStart(4, '0')}</span>
          <span class="memory-bytes">${bytesHtml}</span>
          <span class="memory-ascii">${ascii}</span>
        </div>`;
      }

      memMap.innerHTML = html;
    }

    // Event handlers
    document.getElementById('assembleBtn').addEventListener('click', () => {
      clearOutput();
      cpu.reset();

      const result = assembler.assemble(codeEditor.value);
      if (result.error) {
        log('Error: ' + result.error, true);
        return;
      }

      // Load into memory
      for (let i = 0; i < result.bytes.length; i++) {
        cpu.memory[result.startAddr + i] = result.bytes[i];
      }

      log(`Assembled ${result.bytes.length} bytes at $${result.startAddr.toString(16).toUpperCase()}`);
      updateDisplay();
    });

    document.getElementById('stepBtn').addEventListener('click', () => {
      if (cpu.halted) {
        log('CPU halted (BRK)');
        return;
      }
      cpu.step();
      updateDisplay();
    });

    document.getElementById('runBtn').addEventListener('click', () => {
      if (running) {
        running = false;
        clearInterval(runInterval);
        document.getElementById('runBtn').textContent = 'Run';
        return;
      }

      running = true;
      document.getElementById('runBtn').textContent = 'Stop';

      runInterval = setInterval(() => {
        for (let i = 0; i < 100; i++) {
          if (!cpu.step()) {
            running = false;
            clearInterval(runInterval);
            document.getElementById('runBtn').textContent = 'Run';
            log('CPU halted');
            break;
          }
        }
        updateDisplay();
      }, 16);
    });

    document.getElementById('resetBtn').addEventListener('click', () => {
      running = false;
      clearInterval(runInterval);
      document.getElementById('runBtn').textContent = 'Run';
      cpu.reset();
      clearOutput();
      log('CPU reset');
      updateDisplay();
    });

    document.getElementById('followPC').addEventListener('click', () => {
      document.getElementById('memStart').value = (cpu.PC & 0xFFF0).toString(16).toUpperCase().padStart(4, '0');
      updateMemoryMap();
    });

    document.getElementById('memStart').addEventListener('change', updateMemoryMap);
    document.getElementById('memRows').addEventListener('change', updateMemoryMap);

    // Examples
    const examples = {
      counter: `; Counter - counts from 0 to 15
  LDX #$00      ; Start at 0
loop:
  INX           ; Increment X
  STX $0200     ; Store at $0200
  CPX #$10      ; Compare with 16
  BNE loop      ; Loop if not equal
  BRK           ; Done`,

      fibonacci: `; Fibonacci sequence
  LDA #$01      ; First number
  STA $00       ; Store at $00
  LDA #$01      ; Second number
  STA $01       ; Store at $01
  LDX #$02      ; Counter
fib:
  LDA $00       ; Get n-2
  CLC
  ADC $01       ; Add n-1
  STA $00,X     ; Store result
  LDA $01       ; Shift numbers
  STA $00
  LDA $00,X
  STA $01
  INX
  CPX #$10      ; Generate 16 numbers
  BNE fib
  BRK`,

      multiply: `; Multiply A * X
  LDA #$07      ; Multiplicand
  LDX #$05      ; Multiplier
  LDY #$00      ; Result
mult:
  CPX #$00
  BEQ done
  CLC
  TYA
  ADC #$07      ; Add multiplicand
  TAY
  DEX
  JMP mult
done:
  STY $0200     ; Store result
  BRK`,

      flags: `; Flag demonstration
  CLC           ; Clear carry
  LDA #$7F      ; Load 127
  ADC #$01      ; Add 1 (sets N, V)
  SEC           ; Set carry
  SBC #$80      ; Subtract 128
  LDA #$00      ; Load 0 (sets Z)
  BRK`
    };

    document.getElementById('exampleSelect').addEventListener('change', (e) => {
      if (examples[e.target.value]) {
        codeEditor.value = examples[e.target.value];
        e.target.value = '';
      }
    });

    // Initialize
    updateDisplay();
  </script>
  </div><!-- end crt-wrapper -->
<script src="/sloppy-header/sloppy-bar.js"></script>
</body>
</html>
