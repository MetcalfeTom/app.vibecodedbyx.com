<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Crypto Tools - Web Security Encoder/Decoder</title>
    <link rel="icon" href="https://emojicdn.elk.sh/üîê">

    <meta property="og:title" content="Crypto Tools - Web Security Encoder/Decoder">
    <meta property="og:description" content="Encode, decode, hash, and encrypt with Base64, Base58, SHA, AES, and more">
    <meta property="og:url" content="https://app.sloppy.live/crypto-tools">
    <meta property="og:image" content="https://image.pollinations.ai/prompt/cryptography%20security%20encryption%20digital%20locks%20code?width=1200&height=630&nologo=true&referrer=sloppy.live">

    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #1e3c72 0%, #2a5298 100%);
            min-height: 100vh;
            padding: 20px;
            color: #333;
        }

        .header {
            text-align: center;
            color: white;
            margin-bottom: 30px;
        }

        .header h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
        }

        .header p {
            font-size: 1.1em;
            opacity: 0.9;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
        }

        .tools-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(350px, 1fr));
            gap: 25px;
            margin-bottom: 40px;
        }

        .tool-card {
            background: white;
            border-radius: 15px;
            padding: 25px;
            box-shadow: 0 8px 25px rgba(0,0,0,0.2);
        }

        .tool-header {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 20px;
            padding-bottom: 15px;
            border-bottom: 2px solid #e0e0e0;
        }

        .tool-icon {
            font-size: 2em;
        }

        .tool-title {
            font-size: 1.3em;
            font-weight: bold;
            color: #1e3c72;
        }

        .tool-description {
            font-size: 0.9em;
            color: #666;
            margin-bottom: 15px;
        }

        textarea {
            width: 100%;
            min-height: 100px;
            padding: 12px;
            border: 2px solid #ddd;
            border-radius: 8px;
            font-family: 'Courier New', monospace;
            font-size: 0.9em;
            resize: vertical;
            margin-bottom: 10px;
        }

        textarea:focus {
            outline: none;
            border-color: #1e3c72;
        }

        input[type="text"],
        input[type="password"] {
            width: 100%;
            padding: 10px;
            border: 2px solid #ddd;
            border-radius: 8px;
            font-family: 'Courier New', monospace;
            font-size: 0.9em;
            margin-bottom: 10px;
        }

        input:focus {
            outline: none;
            border-color: #1e3c72;
        }

        .button-group {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
        }

        button {
            flex: 1;
            min-width: 100px;
            padding: 12px 20px;
            background: #1e3c72;
            color: white;
            border: none;
            border-radius: 8px;
            font-size: 0.95em;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        button:hover {
            background: #2a5298;
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(30, 60, 114, 0.3);
        }

        button:active {
            transform: translateY(0);
        }

        .label {
            font-size: 0.85em;
            font-weight: bold;
            color: #555;
            margin-bottom: 5px;
            margin-top: 10px;
            display: block;
        }

        .error {
            color: #d32f2f;
            font-size: 0.85em;
            margin-top: 5px;
            display: none;
        }

        .success {
            color: #2e7d32;
            font-size: 0.85em;
            margin-top: 5px;
            display: none;
        }

        .footer {
            text-align: center;
            margin-top: 40px;
            padding: 20px;
        }

        .footer a {
            color: white;
            text-decoration: none;
            font-size: 1.1em;
            opacity: 0.9;
        }

        .footer a:hover {
            opacity: 1;
            text-decoration: underline;
        }

        .info-box {
            background: #f5f5f5;
            padding: 10px;
            border-radius: 8px;
            font-size: 0.85em;
            color: #666;
            margin-top: 10px;
        }

        @media (max-width: 768px) {
            .header h1 {
                font-size: 1.8em;
            }

            .tools-grid {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>üîê Crypto Tools</h1>
        <p>Professional encoding, decoding, hashing, and encryption tools</p>
    </div>

    <div class="container">
        <div class="tools-grid">
            <!-- Base64 -->
            <div class="tool-card">
                <div class="tool-header">
                    <span class="tool-icon">üî§</span>
                    <span class="tool-title">Base64</span>
                </div>
                <div class="tool-description">Standard encoding for binary data in text format (RFC 4648)</div>
                <label class="label">Input:</label>
                <textarea id="base64Input" placeholder="Enter text to encode or Base64 to decode..."></textarea>
                <div class="button-group">
                    <button onclick="encodeBase64()">Encode</button>
                    <button onclick="decodeBase64()">Decode</button>
                </div>
                <label class="label">Output:</label>
                <textarea id="base64Output" readonly></textarea>
                <div class="error" id="base64Error"></div>
            </div>

            <!-- Base58 -->
            <div class="tool-card">
                <div class="tool-header">
                    <span class="tool-icon">‚Çø</span>
                    <span class="tool-title">Base58</span>
                </div>
                <div class="tool-description">Bitcoin-style encoding without ambiguous characters (0, O, I, l)</div>
                <label class="label">Input:</label>
                <textarea id="base58Input" placeholder="Enter text to encode or Base58 to decode..."></textarea>
                <div class="button-group">
                    <button onclick="encodeBase58()">Encode</button>
                    <button onclick="decodeBase58()">Decode</button>
                </div>
                <label class="label">Output:</label>
                <textarea id="base58Output" readonly></textarea>
                <div class="error" id="base58Error"></div>
            </div>

            <!-- Hex -->
            <div class="tool-card">
                <div class="tool-header">
                    <span class="tool-icon">üî¢</span>
                    <span class="tool-title">Hexadecimal</span>
                </div>
                <div class="tool-description">Convert text to hex and back (base16 encoding)</div>
                <label class="label">Input:</label>
                <textarea id="hexInput" placeholder="Enter text or hex..."></textarea>
                <div class="button-group">
                    <button onclick="encodeHex()">To Hex</button>
                    <button onclick="decodeHex()">From Hex</button>
                </div>
                <label class="label">Output:</label>
                <textarea id="hexOutput" readonly></textarea>
                <div class="error" id="hexError"></div>
            </div>

            <!-- URL Encoding -->
            <div class="tool-card">
                <div class="tool-header">
                    <span class="tool-icon">üåê</span>
                    <span class="tool-title">URL Encoding</span>
                </div>
                <div class="tool-description">Percent-encoding for URLs (RFC 3986)</div>
                <label class="label">Input:</label>
                <textarea id="urlInput" placeholder="Enter text or URL-encoded string..."></textarea>
                <div class="button-group">
                    <button onclick="encodeUrl()">Encode</button>
                    <button onclick="decodeUrl()">Decode</button>
                </div>
                <label class="label">Output:</label>
                <textarea id="urlOutput" readonly></textarea>
                <div class="error" id="urlError"></div>
            </div>

            <!-- SHA-256 -->
            <div class="tool-card">
                <div class="tool-header">
                    <span class="tool-icon">üîí</span>
                    <span class="tool-title">SHA-256 Hash</span>
                </div>
                <div class="tool-description">Secure Hash Algorithm - 256 bit (one-way)</div>
                <label class="label">Input:</label>
                <textarea id="sha256Input" placeholder="Enter text to hash..."></textarea>
                <button onclick="hashSHA256()">Generate Hash</button>
                <label class="label">SHA-256 Hash:</label>
                <textarea id="sha256Output" readonly></textarea>
                <div class="info-box">‚ö†Ô∏è Hashing is one-way - cannot be reversed</div>
            </div>

            <!-- SHA-512 -->
            <div class="tool-card">
                <div class="tool-header">
                    <span class="tool-icon">üîê</span>
                    <span class="tool-title">SHA-512 Hash</span>
                </div>
                <div class="tool-description">Secure Hash Algorithm - 512 bit (one-way)</div>
                <label class="label">Input:</label>
                <textarea id="sha512Input" placeholder="Enter text to hash..."></textarea>
                <button onclick="hashSHA512()">Generate Hash</button>
                <label class="label">SHA-512 Hash:</label>
                <textarea id="sha512Output" readonly></textarea>
                <div class="info-box">‚ö†Ô∏è Hashing is one-way - cannot be reversed</div>
            </div>

            <!-- MD5 -->
            <div class="tool-card">
                <div class="tool-header">
                    <span class="tool-icon">üîì</span>
                    <span class="tool-title">MD5 Hash</span>
                </div>
                <div class="tool-description">Legacy hash function (deprecated for security)</div>
                <label class="label">Input:</label>
                <textarea id="md5Input" placeholder="Enter text to hash..."></textarea>
                <button onclick="hashMD5()">Generate Hash</button>
                <label class="label">MD5 Hash:</label>
                <textarea id="md5Output" readonly></textarea>
                <div class="info-box">‚ö†Ô∏è MD5 is cryptographically broken - use SHA-256+ for security</div>
            </div>

            <!-- AES Encryption -->
            <div class="tool-card">
                <div class="tool-header">
                    <span class="tool-icon">üõ°Ô∏è</span>
                    <span class="tool-title">AES Encryption</span>
                </div>
                <div class="tool-description">Advanced Encryption Standard (symmetric)</div>
                <label class="label">Text:</label>
                <textarea id="aesInput" placeholder="Enter text to encrypt/decrypt..."></textarea>
                <label class="label">Password:</label>
                <input type="password" id="aesPassword" placeholder="Enter encryption password...">
                <div class="button-group">
                    <button onclick="encryptAES()">Encrypt</button>
                    <button onclick="decryptAES()">Decrypt</button>
                </div>
                <label class="label">Output:</label>
                <textarea id="aesOutput" readonly></textarea>
                <div class="error" id="aesError"></div>
            </div>

            <!-- JWT Decoder -->
            <div class="tool-card">
                <div class="tool-header">
                    <span class="tool-icon">üé´</span>
                    <span class="tool-title">JWT Decoder</span>
                </div>
                <div class="tool-description">Decode JSON Web Tokens (does not verify signature)</div>
                <label class="label">JWT Token:</label>
                <textarea id="jwtInput" placeholder="Paste JWT token here..."></textarea>
                <button onclick="decodeJWT()">Decode</button>
                <label class="label">Decoded Payload:</label>
                <textarea id="jwtOutput" readonly></textarea>
                <div class="error" id="jwtError"></div>
                <div class="info-box">‚ö†Ô∏è This only decodes the token - does not verify signature</div>
            </div>

            <!-- HTML Entities -->
            <div class="tool-card">
                <div class="tool-header">
                    <span class="tool-icon">üìù</span>
                    <span class="tool-title">HTML Entities</span>
                </div>
                <div class="tool-description">Escape/unescape HTML special characters</div>
                <label class="label">Input:</label>
                <textarea id="htmlInput" placeholder="Enter text or HTML entities..."></textarea>
                <div class="button-group">
                    <button onclick="encodeHTML()">Encode</button>
                    <button onclick="decodeHTML()">Decode</button>
                </div>
                <label class="label">Output:</label>
                <textarea id="htmlOutput" readonly></textarea>
            </div>

            <!-- Bcrypt -->
            <div class="tool-card">
                <div class="tool-header">
                    <span class="tool-icon">üîë</span>
                    <span class="tool-title">Bcrypt</span>
                </div>
                <div class="tool-description">Password hashing with salt (adaptive, slow by design)</div>
                <label class="label">Password:</label>
                <input type="text" id="bcryptInput" placeholder="Enter password to hash...">
                <label class="label">Rounds (cost factor):</label>
                <input type="number" id="bcryptRounds" value="10" min="4" max="15" placeholder="10">
                <button onclick="hashBcrypt()">Generate Hash</button>
                <label class="label">Bcrypt Hash:</label>
                <textarea id="bcryptOutput" readonly></textarea>
                <div class="info-box">‚ö†Ô∏è Higher rounds = slower but more secure. 10-12 recommended.</div>
                <div class="error" id="bcryptError"></div>
            </div>

            <!-- PBKDF2 -->
            <div class="tool-card">
                <div class="tool-header">
                    <span class="tool-icon">üîê</span>
                    <span class="tool-title">PBKDF2</span>
                </div>
                <div class="tool-description">Password-Based Key Derivation Function 2</div>
                <label class="label">Password:</label>
                <input type="text" id="pbkdf2Password" placeholder="Enter password...">
                <label class="label">Salt:</label>
                <input type="text" id="pbkdf2Salt" placeholder="Enter salt...">
                <label class="label">Iterations:</label>
                <input type="number" id="pbkdf2Iterations" value="10000" min="1000" placeholder="10000">
                <button onclick="hashPBKDF2()">Generate Key</button>
                <label class="label">Derived Key:</label>
                <textarea id="pbkdf2Output" readonly></textarea>
                <div class="error" id="pbkdf2Error"></div>
            </div>

            <!-- HMAC -->
            <div class="tool-card">
                <div class="tool-header">
                    <span class="tool-icon">üîè</span>
                    <span class="tool-title">HMAC</span>
                </div>
                <div class="tool-description">Hash-based Message Authentication Code</div>
                <label class="label">Message:</label>
                <textarea id="hmacMessage" placeholder="Enter message..."></textarea>
                <label class="label">Secret Key:</label>
                <input type="text" id="hmacKey" placeholder="Enter secret key...">
                <label class="label">Algorithm:</label>
                <select id="hmacAlgo" style="width: 100%; padding: 10px; margin-bottom: 10px; border: 2px solid #ddd; border-radius: 8px;">
                    <option value="SHA256">SHA-256</option>
                    <option value="SHA512">SHA-512</option>
                    <option value="SHA1">SHA-1</option>
                </select>
                <button onclick="generateHMAC()">Generate HMAC</button>
                <label class="label">HMAC:</label>
                <textarea id="hmacOutput" readonly></textarea>
                <div class="error" id="hmacError"></div>
            </div>

            <!-- SHA-1 -->
            <div class="tool-card">
                <div class="tool-header">
                    <span class="tool-icon">üîì</span>
                    <span class="tool-title">SHA-1 Hash</span>
                </div>
                <div class="tool-description">Legacy hash function (deprecated for security)</div>
                <label class="label">Input:</label>
                <textarea id="sha1Input" placeholder="Enter text to hash..."></textarea>
                <button onclick="hashSHA1()">Generate Hash</button>
                <label class="label">SHA-1 Hash:</label>
                <textarea id="sha1Output" readonly></textarea>
                <div class="info-box">‚ö†Ô∏è SHA-1 is cryptographically broken - use SHA-256+ for security</div>
            </div>

            <!-- Base32 -->
            <div class="tool-card">
                <div class="tool-header">
                    <span class="tool-icon">üî†</span>
                    <span class="tool-title">Base32</span>
                </div>
                <div class="tool-description">Base32 encoding (RFC 4648) - human-readable</div>
                <label class="label">Input:</label>
                <textarea id="base32Input" placeholder="Enter text to encode or Base32 to decode..."></textarea>
                <div class="button-group">
                    <button onclick="encodeBase32()">Encode</button>
                    <button onclick="decodeBase32()">Decode</button>
                </div>
                <label class="label">Output:</label>
                <textarea id="base32Output" readonly></textarea>
                <div class="error" id="base32Error"></div>
            </div>
        </div>
    </div>

    <div class="footer">
        <a href="https://sloppy.live" target="_blank">‚Üê Back to VibeCodedByX</a>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/crypto-js/4.2.0/crypto-js.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/bcryptjs/2.4.3/bcrypt.min.js"></script>
    <script>
        // Base64
        function encodeBase64() {
            try {
                const input = document.getElementById('base64Input').value;
                const encoded = btoa(unescape(encodeURIComponent(input)));
                document.getElementById('base64Output').value = encoded;
                hideError('base64Error');
            } catch (e) {
                showError('base64Error', 'Encoding failed: ' + e.message);
            }
        }

        function decodeBase64() {
            try {
                const input = document.getElementById('base64Input').value;
                const decoded = decodeURIComponent(escape(atob(input)));
                document.getElementById('base64Output').value = decoded;
                hideError('base64Error');
            } catch (e) {
                showError('base64Error', 'Decoding failed: Invalid Base64');
            }
        }

        // Base58
        const BASE58_ALPHABET = '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz';

        function encodeBase58() {
            try {
                const input = document.getElementById('base58Input').value;
                const bytes = new TextEncoder().encode(input);
                let num = BigInt(0);

                for (let i = 0; i < bytes.length; i++) {
                    num = num * BigInt(256) + BigInt(bytes[i]);
                }

                let encoded = '';
                while (num > 0) {
                    const remainder = num % BigInt(58);
                    num = num / BigInt(58);
                    encoded = BASE58_ALPHABET[Number(remainder)] + encoded;
                }

                // Handle leading zeros
                for (let i = 0; i < bytes.length && bytes[i] === 0; i++) {
                    encoded = '1' + encoded;
                }

                document.getElementById('base58Output').value = encoded || '1';
                hideError('base58Error');
            } catch (e) {
                showError('base58Error', 'Encoding failed: ' + e.message);
            }
        }

        function decodeBase58() {
            try {
                const input = document.getElementById('base58Input').value.trim();
                let num = BigInt(0);

                for (let i = 0; i < input.length; i++) {
                    const char = input[i];
                    const index = BASE58_ALPHABET.indexOf(char);
                    if (index === -1) {
                        throw new Error('Invalid Base58 character: ' + char);
                    }
                    num = num * BigInt(58) + BigInt(index);
                }

                const bytes = [];
                while (num > 0) {
                    bytes.unshift(Number(num % BigInt(256)));
                    num = num / BigInt(256);
                }

                // Handle leading 1s (zeros)
                for (let i = 0; i < input.length && input[i] === '1'; i++) {
                    bytes.unshift(0);
                }

                const decoded = new TextDecoder().decode(new Uint8Array(bytes));
                document.getElementById('base58Output').value = decoded;
                hideError('base58Error');
            } catch (e) {
                showError('base58Error', 'Decoding failed: ' + e.message);
            }
        }

        // Hex
        function encodeHex() {
            try {
                const input = document.getElementById('hexInput').value;
                const hex = Array.from(new TextEncoder().encode(input))
                    .map(b => b.toString(16).padStart(2, '0'))
                    .join('');
                document.getElementById('hexOutput').value = hex;
                hideError('hexError');
            } catch (e) {
                showError('hexError', 'Encoding failed: ' + e.message);
            }
        }

        function decodeHex() {
            try {
                const input = document.getElementById('hexInput').value.replace(/\s/g, '');
                if (!/^[0-9a-fA-F]*$/.test(input)) {
                    throw new Error('Invalid hex string');
                }
                const bytes = [];
                for (let i = 0; i < input.length; i += 2) {
                    bytes.push(parseInt(input.substr(i, 2), 16));
                }
                const decoded = new TextDecoder().decode(new Uint8Array(bytes));
                document.getElementById('hexOutput').value = decoded;
                hideError('hexError');
            } catch (e) {
                showError('hexError', 'Decoding failed: ' + e.message);
            }
        }

        // URL
        function encodeUrl() {
            try {
                const input = document.getElementById('urlInput').value;
                const encoded = encodeURIComponent(input);
                document.getElementById('urlOutput').value = encoded;
                hideError('urlError');
            } catch (e) {
                showError('urlError', 'Encoding failed: ' + e.message);
            }
        }

        function decodeUrl() {
            try {
                const input = document.getElementById('urlInput').value;
                const decoded = decodeURIComponent(input);
                document.getElementById('urlOutput').value = decoded;
                hideError('urlError');
            } catch (e) {
                showError('urlError', 'Decoding failed: ' + e.message);
            }
        }

        // SHA-256
        function hashSHA256() {
            const input = document.getElementById('sha256Input').value;
            const hash = CryptoJS.SHA256(input).toString();
            document.getElementById('sha256Output').value = hash;
        }

        // SHA-512
        function hashSHA512() {
            const input = document.getElementById('sha512Input').value;
            const hash = CryptoJS.SHA512(input).toString();
            document.getElementById('sha512Output').value = hash;
        }

        // MD5
        function hashMD5() {
            const input = document.getElementById('md5Input').value;
            const hash = CryptoJS.MD5(input).toString();
            document.getElementById('md5Output').value = hash;
        }

        // AES
        function encryptAES() {
            try {
                const text = document.getElementById('aesInput').value;
                const password = document.getElementById('aesPassword').value;

                if (!password) {
                    showError('aesError', 'Password is required');
                    return;
                }

                const encrypted = CryptoJS.AES.encrypt(text, password).toString();
                document.getElementById('aesOutput').value = encrypted;
                hideError('aesError');
            } catch (e) {
                showError('aesError', 'Encryption failed: ' + e.message);
            }
        }

        function decryptAES() {
            try {
                const encrypted = document.getElementById('aesInput').value;
                const password = document.getElementById('aesPassword').value;

                if (!password) {
                    showError('aesError', 'Password is required');
                    return;
                }

                const decrypted = CryptoJS.AES.decrypt(encrypted, password);
                const text = decrypted.toString(CryptoJS.enc.Utf8);

                if (!text) {
                    throw new Error('Invalid password or corrupted data');
                }

                document.getElementById('aesOutput').value = text;
                hideError('aesError');
            } catch (e) {
                showError('aesError', 'Decryption failed: ' + e.message);
            }
        }

        // JWT
        function decodeJWT() {
            try {
                const token = document.getElementById('jwtInput').value.trim();
                const parts = token.split('.');

                if (parts.length !== 3) {
                    throw new Error('Invalid JWT format');
                }

                const header = JSON.parse(atob(parts[0]));
                const payload = JSON.parse(atob(parts[1]));

                const output = {
                    header: header,
                    payload: payload,
                    signature: parts[2]
                };

                document.getElementById('jwtOutput').value = JSON.stringify(output, null, 2);
                hideError('jwtError');
            } catch (e) {
                showError('jwtError', 'Decoding failed: Invalid JWT token');
            }
        }

        // HTML Entities
        function encodeHTML() {
            const input = document.getElementById('htmlInput').value;
            const textarea = document.createElement('textarea');
            textarea.textContent = input;
            document.getElementById('htmlOutput').value = textarea.innerHTML;
        }

        function decodeHTML() {
            const input = document.getElementById('htmlInput').value;
            const textarea = document.createElement('textarea');
            textarea.innerHTML = input;
            document.getElementById('htmlOutput').value = textarea.textContent;
        }

        // Bcrypt
        async function hashBcrypt() {
            try {
                const password = document.getElementById('bcryptInput').value;
                const rounds = parseInt(document.getElementById('bcryptRounds').value) || 10;

                if (!password) {
                    showError('bcryptError', 'Password is required');
                    return;
                }

                if (rounds < 4 || rounds > 15) {
                    showError('bcryptError', 'Rounds must be between 4 and 15');
                    return;
                }

                document.getElementById('bcryptOutput').value = 'Hashing... (this may take a few seconds)';

                // Use setTimeout to allow UI to update
                setTimeout(async () => {
                    try {
                        const salt = await dcodeIO.bcrypt.genSalt(rounds);
                        const hash = await dcodeIO.bcrypt.hash(password, salt);
                        document.getElementById('bcryptOutput').value = hash;
                        hideError('bcryptError');
                    } catch (e) {
                        showError('bcryptError', 'Hashing failed: ' + e.message);
                        document.getElementById('bcryptOutput').value = '';
                    }
                }, 100);
            } catch (e) {
                showError('bcryptError', 'Hashing failed: ' + e.message);
            }
        }

        // PBKDF2
        function hashPBKDF2() {
            try {
                const password = document.getElementById('pbkdf2Password').value;
                const salt = document.getElementById('pbkdf2Salt').value;
                const iterations = parseInt(document.getElementById('pbkdf2Iterations').value) || 10000;

                if (!password) {
                    showError('pbkdf2Error', 'Password is required');
                    return;
                }
                if (!salt) {
                    showError('pbkdf2Error', 'Salt is required');
                    return;
                }

                const key = CryptoJS.PBKDF2(password, salt, {
                    keySize: 256/32,
                    iterations: iterations
                });

                document.getElementById('pbkdf2Output').value = key.toString();
                hideError('pbkdf2Error');
            } catch (e) {
                showError('pbkdf2Error', 'Key derivation failed: ' + e.message);
            }
        }

        // HMAC
        function generateHMAC() {
            try {
                const message = document.getElementById('hmacMessage').value;
                const key = document.getElementById('hmacKey').value;
                const algo = document.getElementById('hmacAlgo').value;

                if (!message) {
                    showError('hmacError', 'Message is required');
                    return;
                }
                if (!key) {
                    showError('hmacError', 'Secret key is required');
                    return;
                }

                let hmac;
                switch(algo) {
                    case 'SHA256':
                        hmac = CryptoJS.HmacSHA256(message, key);
                        break;
                    case 'SHA512':
                        hmac = CryptoJS.HmacSHA512(message, key);
                        break;
                    case 'SHA1':
                        hmac = CryptoJS.HmacSHA1(message, key);
                        break;
                }

                document.getElementById('hmacOutput').value = hmac.toString();
                hideError('hmacError');
            } catch (e) {
                showError('hmacError', 'HMAC generation failed: ' + e.message);
            }
        }

        // SHA-1
        function hashSHA1() {
            const input = document.getElementById('sha1Input').value;
            const hash = CryptoJS.SHA1(input).toString();
            document.getElementById('sha1Output').value = hash;
        }

        // Base32
        const BASE32_ALPHABET = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ234567';

        function encodeBase32() {
            try {
                const input = document.getElementById('base32Input').value;
                const bytes = new TextEncoder().encode(input);
                let bits = '';

                // Convert to binary
                for (let i = 0; i < bytes.length; i++) {
                    bits += bytes[i].toString(2).padStart(8, '0');
                }

                // Pad to multiple of 5
                while (bits.length % 5 !== 0) {
                    bits += '0';
                }

                // Convert to base32
                let encoded = '';
                for (let i = 0; i < bits.length; i += 5) {
                    const chunk = bits.substr(i, 5);
                    encoded += BASE32_ALPHABET[parseInt(chunk, 2)];
                }

                // Add padding
                while (encoded.length % 8 !== 0) {
                    encoded += '=';
                }

                document.getElementById('base32Output').value = encoded;
                hideError('base32Error');
            } catch (e) {
                showError('base32Error', 'Encoding failed: ' + e.message);
            }
        }

        function decodeBase32() {
            try {
                let input = document.getElementById('base32Input').value.trim().toUpperCase();

                // Remove padding
                input = input.replace(/=/g, '');

                let bits = '';

                // Convert to binary
                for (let i = 0; i < input.length; i++) {
                    const index = BASE32_ALPHABET.indexOf(input[i]);
                    if (index === -1) {
                        throw new Error('Invalid Base32 character: ' + input[i]);
                    }
                    bits += index.toString(2).padStart(5, '0');
                }

                // Convert to bytes
                const bytes = [];
                for (let i = 0; i + 8 <= bits.length; i += 8) {
                    bytes.push(parseInt(bits.substr(i, 8), 2));
                }

                const decoded = new TextDecoder().decode(new Uint8Array(bytes));
                document.getElementById('base32Output').value = decoded;
                hideError('base32Error');
            } catch (e) {
                showError('base32Error', 'Decoding failed: ' + e.message);
            }
        }

        // Error handling
        function showError(id, message) {
            const el = document.getElementById(id);
            el.textContent = message;
            el.style.display = 'block';
        }

        function hideError(id) {
            document.getElementById(id).style.display = 'none';
        }
    </script>
<script src="/sloppy-header/sloppy-bar.js"></script>
<script src="/vibelib-extended.js"></script>
<script>
  // Compatibility Patch for Legacy Apps
  window.addEventListener("load", () => {
    if (window.SloppyKarma && window.VibeLib.Economy) {
      // Redirect old calls to new engine
      window.SloppyKarma.track = window.VibeLib.Economy.track;
    }
  });
</script>
</body>
</html>
