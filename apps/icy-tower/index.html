<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Icy Tower Online</title>
  <link rel="icon" href="https://emojicdn.elk.sh/üßä">

  <meta property="og:title" content="Icy Tower Online">
  <meta property="og:description" content="Climb endless icy floors. Jump fast, don‚Äôt fall!">
  <meta property="og:url" content="https://app.vibecodedbyx.com/icy-tower">
  <meta property="og:image" content="https://app.vibecodedbyx.com/icy-tower/og.png">

  <style>
    :root {
      --bg1: #0a1828;
      --bg2: #1a2f47;
      --ice: #aee6ff;
      --ice-dark: #6cc3ec;
      --accent: #e8f7ff;
      --good: #8ef59a;
      --bad: #ff6b6b;
      --gold: #ffd166;
      --snow: #f0f8ff;
    }

    * { box-sizing: border-box; }
    html, body { height: 100%; }
    body {
      margin: 0;
      font-family: Inter, ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji", "Segoe UI Emoji";
      background: radial-gradient(100% 120% at 50% 0%, var(--bg2) 0%, var(--bg1) 60%);
      color: white;
      overflow: hidden;
      position: relative;
    }

    /* Falling snow effect */
    body::before {
      content: '';
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background-image:
        radial-gradient(2px 2px at 20% 30%, white, transparent),
        radial-gradient(2px 2px at 60% 70%, white, transparent),
        radial-gradient(1px 1px at 50% 50%, white, transparent),
        radial-gradient(1px 1px at 80% 10%, white, transparent),
        radial-gradient(2px 2px at 90% 60%, white, transparent),
        radial-gradient(1px 1px at 33% 80%, white, transparent),
        radial-gradient(2px 2px at 75% 25%, white, transparent);
      background-size: 200% 200%;
      background-position: 0% 0%;
      opacity: 0.5;
      animation: snowfall 15s linear infinite;
      pointer-events: none;
      z-index: 1;
    }

    @keyframes snowfall {
      0% { background-position: 0% 0%; }
      100% { background-position: 0% 200%; }
    }

    .wrap {
      position: relative;
      z-index: 2;
      display: grid;
      grid-template-columns: 1fr min(420px, 45vw);
      gap: 16px;
      height: 100%;
      padding: 12px;
    }

    @media (max-width: 900px) {
      .wrap { grid-template-columns: 1fr; padding-bottom: 90px; }
    }

    .panel {
      background: rgba(255,255,255,0.06);
      border: 1px solid rgba(255,255,255,0.1);
      border-radius: 14px;
      backdrop-filter: blur(6px);
      box-shadow: 0 20px 60px rgba(0,0,0,0.35) inset;
    }

    .hud { padding: 10px 12px; display: flex; align-items: center; justify-content: space-between; gap: 8px; }
    .hud .stat { font-weight: 700; letter-spacing: 0.3px; }
    .hud .stat.good { color: var(--good); }
    .hud .stat.bad { color: var(--bad); }

    .canvas-wrap { position: relative; }
    canvas { width: 100%; height: calc(100vh - 24px); display: block; }
    @media (max-width: 900px) {
      canvas { height: calc(100vh - 110px); }
    }

    .sidebar { padding: 14px; display: grid; grid-auto-rows: min-content; gap: 12px; overflow-y: auto; max-height: calc(100vh - 24px); }
    .title { font-size: 22px; font-weight: 800; letter-spacing: 0.2px; }
    .desc { color: #cfe9ff; opacity: 0.9; }

    .btn { cursor: pointer; border: 0; border-radius: 10px; padding: 10px 14px; font-weight: 700; }
    .btn.primary { background: linear-gradient(180deg, var(--ice) 0%, var(--ice-dark) 90%); color: #062033; }
    .btn.ghost { background: transparent; color: #cfe9ff; border: 1px solid rgba(255,255,255,0.18); }
    .btn:disabled { opacity: 0.6; cursor: not-allowed; }

    .row { display: flex; gap: 10px; align-items: center; justify-content: space-between; flex-wrap: wrap; }

    .board { border-radius: 10px; overflow: hidden; border: 1px solid rgba(255,255,255,0.15); }
    table { width: 100%; border-collapse: collapse; font-size: 14px; }
    th, td { padding: 8px 10px; border-bottom: 1px solid rgba(255,255,255,0.08); }
    th { text-align: left; color: #e0f3ff; background: rgba(255,255,255,0.05); }
    td.score { font-weight: 800; color: var(--gold); }

    .error { background: rgba(255,107,107,0.12); border: 1px solid rgba(255,107,107,0.4); color: #ffdede; padding: 8px 10px; border-radius: 10px; }
    .muted { opacity: 0.75; }

    .backlink { text-align: center; margin-top: 6px; }
    .backlink a { color: var(--ice); text-decoration: none; }

    /* Mobile controls */
    .touchpad { position: fixed; left: 0; right: 0; bottom: 0; height: 78px; padding: 8px 12px; display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 8px; background: linear-gradient(180deg, transparent, rgba(0,0,0,0.45)); }
    .touchpad .padbtn { height: 62px; border-radius: 10px; border: 1px solid rgba(255,255,255,0.18); background: rgba(255,255,255,0.06); color: #e4f6ff; font-weight: 800; letter-spacing: 0.3px; }
    @media (min-width: 901px) { .touchpad { display:none; } }

    /* Overlays */
    .overlay { position: absolute; inset: 0; display: none; align-items: center; justify-content: center; }
    .overlay.show { display: flex; }
    .card { background: rgba(1,12,24,0.8); border: 1px solid rgba(255,255,255,0.16); padding: 18px; border-radius: 12px; max-width: 440px; width: min(90%, 440px); }
    .card h2 { margin: 0 0 8px; }
    .card p { margin: 0 0 10px; color: #cfe9ff; }
    .field { display: grid; gap: 6px; margin: 8px 0; }
    .field input { padding: 10px 12px; border-radius: 8px; border: 1px solid rgba(255,255,255,0.2); background: rgba(255,255,255,0.06); color: white; }

    /* Power chips */
    .chips { display:flex; gap:6px; align-items:center; flex-wrap:wrap; }
    .chip { display:flex; gap:6px; align-items:center; padding:4px 8px; background:rgba(255,255,255,0.08); border:1px solid rgba(255,255,255,0.18); border-radius:999px; font-size:12px; }
    .chip .dot { width:10px; height:10px; border-radius:50%; display:inline-block; }

    /* Toast */
    .toast { position:absolute; left:50%; top:72px; transform:translateX(-50%); background:rgba(5,20,36,0.9); border:1px solid rgba(255,255,255,0.18); padding:10px 14px; border-radius:10px; display:none; box-shadow:0 8px 30px rgba(0,0,0,0.4); }
    .toast.show { display:block; animation: pop .2s ease-out; }
    @keyframes pop { from { transform: translateX(-50%) scale(.95); opacity:.6 } to { transform: translateX(-50%) scale(1); opacity:1 } }

    /* Achievements */
    .ach { border:1px solid rgba(255,255,255,0.15); border-radius:10px; overflow:hidden; }
    .ach table { width:100%; border-collapse:collapse; font-size:14px }
    .ach th, .ach td { padding:8px 10px; border-bottom:1px solid rgba(255,255,255,0.08) }
    .ach th { text-align:left; background:rgba(255,255,255,0.05); color:#e0f3ff }
    .badge { display:inline-flex; align-items:center; gap:6px; }
    .badge .mark { width:14px; height:14px; border-radius:50%; display:inline-block; border:1px solid rgba(255,255,255,0.2); background:rgba(255,255,255,0.06) }
    .badge.unlocked .mark { background:linear-gradient(180deg,#8ef59a,#46d46a); border-color:#2ab34e }
  </style>
</head>
<body>
  <div class="wrap">
    <div class="panel canvas-wrap">
      <div class="hud">
        <div class="stat">Floor: <span id="floor">0</span></div>
        <div class="stat">Best: <span id="best">0</span></div>
        <div class="stat good">Combo: <span id="combo">x1</span></div>
        <div class="row">
          <button id="startBtn" class="btn primary">Start (Space)</button>
          <button id="pauseBtn" class="btn ghost">Pause (P)</button>
          <button id="restartBtn" class="btn ghost">Restart (R)</button>
        </div>
        <div id="powerChips" class="chips"></div>
      </div>
      <canvas id="game"></canvas>
      <div id="toast" class="toast"></div>

      <!-- Overlays -->
      <div id="startOverlay" class="overlay show">
        <div class="card">
          <h2>üßä Icy Tower</h2>
          <p>Climb as high as you can. Don‚Äôt fall off-screen.</p>
          <p class="muted">Controls: A/D or ‚Üê/‚Üí to move, Space to jump. P to pause.</p>
          <div class="row">
            <button id="playNow" class="btn primary" autofocus>Play Now</button>
            <button id="muteBtn" class="btn ghost">üîä Sound</button>
          </div>
        </div>
      </div>

      <div id="gameOverOverlay" class="overlay">
        <div class="card">
          <h2>Game Over</h2>
          <p>You reached floor <b id="finalFloor">0</b>.</p>
          <div id="saveBlock" class="field">
            <label for="playerName">Name (for leaderboard)</label>
            <input id="playerName" placeholder="e.g. IceWizard" maxlength="20" />
            <div class="row">
              <button id="saveScoreBtn" class="btn primary">Save Score</button>
              <button id="skipSaveBtn" class="btn ghost">Skip</button>
            </div>
            <div id="saveError" class="error" style="display:none"></div>
          </div>
          <div class="row">
            <button id="playAgain" class="btn primary">Play Again</button>
            <button id="shareBtn" class="btn ghost">Share</button>
          </div>
        </div>
      </div>
    </div>

    <div class="panel sidebar">
      <div class="title">üèÜ Leaderboard</div>
      <div id="errBox" class="error" style="display:none"></div>
      <div class="board">
        <table>
          <thead>
            <tr><th>#</th><th>Name</th><th>Floor</th><th>Date</th></tr>
          </thead>
          <tbody id="boardBody">
            <tr><td></td><td class="muted" colspan="3">Loading‚Ä¶</td></tr>
          </tbody>
        </table>
      </div>
      <div class="row">
        <button id="refreshBtn" class="btn ghost">Refresh</button>
        <button id="toggleFxBtn" class="btn ghost">FX: On</button>
      </div>
      <div class="title">üéØ Achievements</div>
      <div class="ach">
        <table>
          <thead><tr><th>Badge</th><th>Status</th></tr></thead>
          <tbody id="achBody"><tr><td class="muted" colspan="2">Play to unlock achievements‚Ä¶</td></tr></tbody>
        </table>
      </div>
      <div class="backlink"><a href="https://www.vibecodedbyx.com" target="_blank" rel="noopener">‚Üê Back to VibeCodedByX livestream</a></div>
      <div id="premium-content" style="display:none"></div>
      <button id="upgrade-button" style="display:none"></button>
    </div>
  </div>

  <div class="touchpad">
    <button id="leftPad" class="padbtn">‚üµ</button>
    <button id="jumpPad" class="padbtn">‚§¥</button>
    <button id="rightPad" class="padbtn">‚ü∂</button>
  </div>

  <script type="module">
    import supabase, { supabaseSession, isUserPremium } from './supabase-config.js';

    // ===== Canvas + Game State =====
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');
    let W = 0, H = 0, dpr = Math.max(1, window.devicePixelRatio || 1);
    function resize() {
      W = canvas.clientWidth | 0; H = canvas.clientHeight | 0;
      canvas.width = W * dpr; canvas.height = H * dpr; ctx.setTransform(dpr,0,0,dpr,0,0);
    }
    addEventListener('resize', resize, { passive: true });
    resize();

    const state = {
      running: false,
      paused: false,
      floor: 0,
      best: Number(localStorage.getItem('icy-best')||0),
      combo: 1,
      fx: true,
      cameraY: 0,
      gravity: 0.9,
      jumpVel: -16,
      moveSpeed: 6.2,
      scrollSpeed: 2.2,
      lastFrame: 0,
      player: { x: 160, y: 0, vx: 0, vy: 0, w: 28, h: 34, onGround: false, jumpsLeft: 1 },
      floors: [],
      powerups: [],
      effects: { double: 0, slow: 0, boost: 0 },
      input: { left: false, right: false, jump: false, jumpPressed: false },
      sounds: {},
    };

    // Sound (small synth tones via WebAudio)
    let audioCtx;
    function beep(freq=440, dur=0.08, type='sine') {
      if (muted) return; if (!audioCtx) { try { audioCtx = new (window.AudioContext||window.webkitAudioContext)(); } catch(e){} }
      if (!audioCtx) return; const o = audioCtx.createOscillator(); const g = audioCtx.createGain();
      o.type = type; o.frequency.value = freq; o.connect(g); g.connect(audioCtx.destination);
      const t = audioCtx.currentTime; g.gain.setValueAtTime(0.12, t); g.gain.exponentialRampToValueAtTime(0.0001, t + dur);
      o.start(t); o.stop(t + dur);
    }
    let muted = false;

    // Floor generation
    function resetWorld() {
      state.floor = 0; state.combo = 1; state.cameraY = 0; state.player.x = W/2-14; state.player.y = H-80; state.player.vx=0; state.player.vy=0; state.player.onGround=false; state.player.jumpsLeft = 1;
      state.floors.length = 0; state.powerups.length = 0; state.effects.double = 0; state.effects.slow = 0; state.effects.boost = 0;
      // base floor
      state.floors.push({ x: 0, y: H-40, w: W, h: 24 });
      // generate upwards
      let y = H-100;
      for (let i=0;i<40;i++) {
        const s = addPlatformAt(y); maybeSpawnPowerup(s); y -= rand(52, 88);
      }
    }

    function addPlatformAt(y) {
      const minW = Math.max(90, W * 0.28);
      const maxW = Math.max(140, W * 0.44);
      const w = rand(minW, maxW);
      const x = rand(0, Math.max(0, W - w));
      const s = { x, y, w, h: 16 };
      state.floors.push(s);
      return s;
    }

    function rand(a,b){ return a + Math.random()*(b-a) }

    function maybeSpawnPowerup(s){
      if (s.y > H - 80) return;
      if (Math.random() > 0.08) return;
      const pick = Math.random();
      const type = pick < 0.4 ? 'double' : (pick < 0.75 ? 'slow' : 'boost');
      const r = 9; const x = s.x + rand(10, Math.max(12, s.w - 12)); const y = s.y - r - 2;
      state.powerups.push({ x, y, r, type });
    }

    function update(dt) {
      // input ‚Üí velocity
      const p = state.player;
      if (state.input.left) p.vx = -state.moveSpeed; else if (state.input.right) p.vx = state.moveSpeed; else p.vx *= 0.8;
      // auto jump when holding space
      if (state.input.jump && p.onGround) {
        state.input.jumpPressed = true;
      }
      // queued jump (ground or double)
      if (state.input.jumpPressed) {
        const jv = state.jumpVel * (state.effects.boost > 0 ? 1.3 : 1);
        if (p.onGround) { p.vy = jv; p.onGround = false; p.jumpsLeft = (state.effects.double > 0 ? 1 : 0); beep(880, 0.07, 'triangle'); }
        else if (state.effects.double > 0 && p.jumpsLeft > 0) { p.vy = jv; p.jumpsLeft -= 1; beep(980, 0.06, 'triangle'); }
        state.input.jumpPressed = false;
      }

      // physics
      const g = state.gravity * (state.effects.slow > 0 ? 0.7 : 1);
      p.vy += g; p.x += p.vx; p.y += p.vy;
      // wrap horizontally
      if (p.x < -p.w) p.x = W; if (p.x > W) p.x = -p.w;

      // collisions with platforms (only falling)
      let groundedThisFrame = false;
      for (const s of state.floors) {
        if (p.vy >= 0 && p.x + p.w > s.x && p.x < s.x + s.w) {
          const dy = (s.y - p.h) - p.y;
          if (dy >= -10 && dy <= p.vy) {
            // land
            p.y = s.y - p.h; p.vy = 0; p.onGround = true; p.jumpsLeft = (state.effects.double > 0 ? 2 : 1); groundedThisFrame = true;
            // scoring when landing on new floors above camera
            if (s.y < H - 60 - state.floor * 24) {
              state.floor += 1; state.combo = Math.min(10, state.combo + 1);
              beep(300 + state.combo*50, 0.06, 'sine');
              checkAchievements();
            }
          }
        }
      }
      if (!groundedThisFrame) p.onGround = false;

      // camera follows upward when player above center
      const targetCam = Math.min(state.cameraY, p.y - H*0.45);
      state.cameraY += (targetCam - state.cameraY) * 0.12;
      // slow auto-scroll
      const scroll = state.scrollSpeed * (state.effects.slow > 0 ? 0.6 : 1);
      state.cameraY -= scroll * 0.06 * dt;

      // recycle platforms below viewport and add new above
      const cutoff = state.cameraY + H + 40;
      state.floors = state.floors.filter(s => s.y < cutoff);
      state.powerups = state.powerups.filter(u => u.y < cutoff);
      while (state.floors.length < 42) {
        const topY = Math.min(...state.floors.map(s=>s.y));
        const s = addPlatformAt(topY - rand(56, 90)); maybeSpawnPowerup(s);
      }

      // powerup pickups
      for (let i = state.powerups.length - 1; i >= 0; i--) {
        const u = state.powerups[i];
        if (rectCircleOverlap(p.x, p.y, p.w, p.h, u.x, u.y, u.r)) {
          applyPowerup(u.type);
          state.powerups.splice(i, 1);
        }
      }

      // decay effects
      const dms = dt;
      for (const k of Object.keys(state.effects)) state.effects[k] = Math.max(0, state.effects[k] - dms);
      renderChips();

      // death: fall below screen
      if (p.y - state.cameraY > H + 40) {
        endGame();
      }
    }

    function rectCircleOverlap(rx, ry, rw, rh, cx, cy, cr){
      const closestX = Math.max(rx, Math.min(cx, rx + rw));
      const closestY = Math.max(ry, Math.min(cy, ry + rh));
      const dx = cx - closestX, dy = cy - closestY; return dx*dx + dy*dy <= cr*cr;
    }

    function applyPowerup(type){
      const DUR = 8000; // ms
      if (type==='double') { state.effects.double = DUR; showToast('Double Jump!'); }
      if (type==='slow') { state.effects.slow = DUR; showToast('Time Slow!'); }
      if (type==='boost') { state.effects.boost = DUR; showToast('Super Jump!'); }
      unlock('firstPower');
      beep(520, 0.08, 'sine');
    }

    function draw() {
      // bg
      ctx.clearRect(0,0,W,H);
    // subtle stars
      if (state.fx) {
        ctx.globalAlpha = 0.25; ctx.fillStyle = '#99cfff';
        for (let i=0;i<20;i++) ctx.fillRect(((i*73)%W), ((i*137)%H), 2, 2);
        ctx.globalAlpha = 1;
      }

      const cam = state.cameraY;
      // platforms
      for (const s of state.floors) {
        const y = s.y - cam;
        if (y < -30 || y > H+30) continue;
        const grd = ctx.createLinearGradient(s.x, y, s.x, y + s.h);
        grd.addColorStop(0, 'rgba(255,255,255,0.95)');
        grd.addColorStop(0.5, 'rgba(200,240,255,0.85)');
        grd.addColorStop(1, 'rgba(174,230,255,0.7)');
        ctx.fillStyle = grd;
        ctx.fillRect(s.x, y, s.w, s.h);
        // frost bevel
        ctx.fillStyle = 'rgba(12,55,88,0.4)';
        ctx.fillRect(s.x, y + s.h - 3, s.w, 3);
        // icicles hanging from bottom
        if (state.fx && s.h > 10) {
          ctx.fillStyle = 'rgba(200,240,255,0.6)';
          const icicleCount = Math.floor(s.w / 30);
          for (let i = 0; i < icicleCount; i++) {
            const ix = s.x + (i + 0.5) * (s.w / icicleCount);
            const ih = 4 + Math.random() * 6;
            ctx.beginPath();
            ctx.moveTo(ix - 2, y + s.h);
            ctx.lineTo(ix, y + s.h + ih);
            ctx.lineTo(ix + 2, y + s.h);
            ctx.closePath();
            ctx.fill();
          }
        }
        // frost sparkles on top
        if (state.fx) {
          ctx.fillStyle = 'rgba(255,255,255,0.8)';
          for (let i = 0; i < 3; i++) {
            const sx = s.x + (i + 0.5) * (s.w / 3);
            ctx.fillRect(sx, y + 2, 2, 2);
          }
        }
      }

      // powerups
      for (const u of state.powerups) {
        const y = u.y - cam; if (y < -20 || y > H+30) continue;
        let color = '#8ef59a'; let label = '2x';
        if (u.type==='slow'){ color = '#ffd166'; label='‚è≥'; }
        if (u.type==='boost'){ color = '#66e'; label='‚¨Ü'; }
        ctx.fillStyle = color; ctx.beginPath(); ctx.arc(u.x, y, u.r, 0, Math.PI*2); ctx.fill();
        ctx.fillStyle = '#04233a'; ctx.font = 'bold 10px sans-serif'; ctx.textAlign='center'; ctx.textBaseline='middle'; ctx.fillText(label, u.x, y+0.5);
      }

      // player
      const p = state.player;
      const py = p.y - cam;
      ctx.save();
      ctx.translate(p.x + p.w/2, py + p.h/2);
      const tilt = Math.max(-0.25, Math.min(0.25, p.vx * 0.05));
      ctx.rotate(tilt);
      // body
      ctx.fillStyle = '#e8f7ff';
      roundRect(ctx, -p.w/2, -p.h/2, p.w, p.h, 6, true, false);
      // scarf
      ctx.fillStyle = '#66e'; ctx.fillRect(-p.w/2, -p.h/2 + 6, p.w, 6);
      // face
      ctx.fillStyle = '#113b5c'; ctx.fillRect(-6, -6, 3, 3); ctx.fillRect(3, -6, 3, 3);
      if (state.fx) {
        ctx.globalAlpha = 0.15; ctx.fillStyle = '#aee6ff'; roundRect(ctx, -p.w/2-3, -p.h/2-2, p.w+6, p.h+4, 8, true, false); ctx.globalAlpha = 1;
      }
      ctx.restore();

      // UI numbers
      document.getElementById('floor').textContent = state.floor;
      document.getElementById('best').textContent = state.best;
      document.getElementById('combo').textContent = 'x' + state.combo;
    }

    function roundRect(ctx, x, y, w, h, r, fill, stroke) {
      if (w < 2*r) r = w/2; if (h < 2*r) r = h/2; ctx.beginPath(); ctx.moveTo(x+r, y); ctx.arcTo(x+w, y, x+w, y+h, r); ctx.arcTo(x+w, y+h, x, y+h, r); ctx.arcTo(x, y+h, x, y, r); ctx.arcTo(x, y, x+w, y, r); ctx.closePath(); if (fill) ctx.fill(); if (stroke) ctx.stroke();
    }

    function loop(ts) {
      const dt = Math.min(33, ts - state.lastFrame || 16.6); state.lastFrame = ts;
      if (state.running && !state.paused) update(dt);
      draw();
      requestAnimationFrame(loop);
    }
    requestAnimationFrame(loop);

    // ===== Controls =====
    addEventListener('keydown', (e) => {
      if (e.repeat) return;
      if (e.code === 'ArrowLeft' || e.code === 'KeyA') state.input.left = true;
      if (e.code === 'ArrowRight' || e.code === 'KeyD') state.input.right = true;
      if (e.code === 'Space') { state.input.jump = true; state.input.jumpPressed = true; if (!state.running) startGame(); }
      if (e.code === 'KeyP') togglePause();
      if (e.code === 'KeyR') restart();
    });
    addEventListener('keyup', (e) => {
      if (e.code === 'ArrowLeft' || e.code === 'KeyA') state.input.left = false;
      if (e.code === 'ArrowRight' || e.code === 'KeyD') state.input.right = false;
      if (e.code === 'Space') state.input.jump = false;
    });

    // Mobile pads
    const leftPad = document.getElementById('leftPad');
    const rightPad = document.getElementById('rightPad');
    const jumpPad = document.getElementById('jumpPad');
    const bindPad = (el, on, off) => {
      const down = (e)=>{ e.preventDefault(); on(); };
      const up = (e)=>{ e.preventDefault(); off(); };
      el.addEventListener('touchstart', down, { passive: false });
      el.addEventListener('touchend', up, { passive: false });
      el.addEventListener('mousedown', down);
      el.addEventListener('mouseup', up);
      el.addEventListener('mouseleave', up);
    };
    bindPad(leftPad, ()=>state.input.left=true, ()=>state.input.left=false);
    bindPad(rightPad, ()=>state.input.right=true, ()=>state.input.right=false);
    bindPad(jumpPad, ()=>{ state.input.jump=true; state.input.jumpPressed=true; if (!state.running) startGame(); setTimeout(()=>state.input.jump=false, 120); }, ()=>state.input.jump=false);

    // ===== UI actions =====
    const startOverlay = document.getElementById('startOverlay');
    const gameOverOverlay = document.getElementById('gameOverOverlay');
    const startBtn = document.getElementById('startBtn');
    const pauseBtn = document.getElementById('pauseBtn');
    const restartBtn = document.getElementById('restartBtn');
    const muteBtn = document.getElementById('muteBtn');
    const playNow = document.getElementById('playNow');
    const playAgain = document.getElementById('playAgain');
    const shareBtn = document.getElementById('shareBtn');
    const toggleFxBtn = document.getElementById('toggleFxBtn');
    startBtn.onclick = ()=>startGame();
    playNow.onclick = ()=>startGame();
    playAgain.onclick = ()=>{ gameOverOverlay.classList.remove('show'); restart(); startGame(); };
    restartBtn.onclick = ()=>restart();
    pauseBtn.onclick = ()=>togglePause();
    muteBtn.onclick = ()=>{ muted = !muted; muteBtn.textContent = muted ? 'üîá Muted' : 'üîä Sound'; };
    toggleFxBtn.onclick = ()=>{ state.fx=!state.fx; toggleFxBtn.textContent = 'FX: ' + (state.fx?'On':'Off'); };
    shareBtn.onclick = ()=>{
      const url = encodeURIComponent('https://app.vibecodedbyx.com/icy-tower');
      const text = encodeURIComponent(`I reached floor ${state.floor} in Icy Tower Online! üßä`);
      window.open(`https://twitter.com/intent/tweet?text=${text}&url=${url}`, '_blank');
    };

    function startGame() {
      if (state.running) return; startOverlay.classList.remove('show'); gameOverOverlay.classList.remove('show');
      state.running = true; state.paused = false; resetWorld();
    }
    function togglePause() { if (!state.running) return; state.paused = !state.paused; }
    function restart() { state.running = false; resetWorld(); draw(); }
    function endGame() {
      state.running = false; state.best = Math.max(state.best, state.floor); localStorage.setItem('icy-best', state.best);
      document.getElementById('finalFloor').textContent = state.floor;
      gameOverOverlay.classList.add('show');
      if (state.floor >= state.best) unlock('newPB');
    }

    // ===== Leaderboard (Supabase) =====
    let currentUser = null; let premium = false;
    const errBox = document.getElementById('errBox');
    const boardBody = document.getElementById('boardBody');
    const refreshBtn = document.getElementById('refreshBtn');
    refreshBtn.onclick = loadBoard;

    const saveScoreBtn = document.getElementById('saveScoreBtn');
    const skipSaveBtn = document.getElementById('skipSaveBtn');
    const playerNameEl = document.getElementById('playerName');
    const saveError = document.getElementById('saveError');

    skipSaveBtn.onclick = ()=>{ document.getElementById('saveBlock').style.display='none'; };
    saveScoreBtn.onclick = async ()=>{
      saveError.style.display='none';
      try {
        const name = (playerNameEl.value || 'Anonymous').slice(0,20);
        const payload = { score: state.floor, display_name: name, user_id: currentUser?.id };
        const { error } = await supabase.from('icy_tower_scores').insert([payload]);
        if (error) throw error;
        loadBoard(); unlock('savedScore');
        document.getElementById('saveBlock').style.display='none';
      } catch (e) {
        saveError.textContent = 'Failed to save score: ' + e.message;
        saveError.style.display='block';
      }
    };

    async function initAuth() {
      try {
        const { user } = await supabaseSession(); currentUser = user; premium = await isUserPremium();
      } catch (e) {
        showErr('Auth failed: ' + e.message);
      }
      loadBoard();
    }

    async function loadBoard() {
      try {
        showErr('');
        boardBody.innerHTML = '<tr><td></td><td class="muted" colspan="3">Loading‚Ä¶</td></tr>';
        const { data, error } = await supabase
          .from('icy_tower_scores')
          .select('score, display_name, created_at')
          .order('score', { ascending: false })
          .limit(10);
        if (error) throw error;
        if (!data || data.length === 0) {
          boardBody.innerHTML = '<tr><td></td><td class="muted" colspan="3">No scores yet. Be the first!</td></tr>';
          return;
        }
        boardBody.innerHTML = data.map((row, i)=>{
          const when = new Date(row.created_at).toLocaleDateString();
          const name = escapeHtml(row.display_name || 'Anonymous');
          return `<tr><td>${i+1}</td><td>${name}</td><td class="score">${row.score}</td><td>${when}</td></tr>`;
        }).join('');
      } catch (e) { showErr('Failed to load leaderboard: ' + e.message); }
    }

    function showErr(msg){ if (!msg) { errBox.style.display='none'; errBox.textContent=''; } else { errBox.style.display='block'; errBox.textContent = msg; } }
    function escapeHtml(s){ const d=document.createElement('div'); d.textContent=s; return d.innerHTML; }

    // kick off
    resetWorld(); draw(); initAuth();

    // ===== Power chips + Toast =====
    const chipsEl = document.getElementById('powerChips');
    const toastEl = document.getElementById('toast');
    let toastTimer = null;
    function renderChips(){
      if (!chipsEl) return;
      const items = [];
      if (state.effects.double>0) items.push({label:'Double Jump', color:'#8ef59a', secs:Math.ceil(state.effects.double/1000)});
      if (state.effects.slow>0) items.push({label:'Time Slow', color:'#ffd166', secs:Math.ceil(state.effects.slow/1000)});
      if (state.effects.boost>0) items.push({label:'Super Jump', color:'#66e', secs:Math.ceil(state.effects.boost/1000)});
      if (items.length===0) { chipsEl.innerHTML=''; return; }
      chipsEl.innerHTML = items.map(i=>`<div class="chip"><span class="dot" style="background:${i.color}"></span>${i.label} ¬∑ ${i.secs}s</div>`).join('');
    }
    function showToast(msg){ clearTimeout(toastTimer); toastEl.textContent = msg; toastEl.classList.add('show'); toastTimer = setTimeout(()=>toastEl.classList.remove('show'), 1400); }

    // ===== Achievements =====
    const achBody = document.getElementById('achBody');
    const ACHS = [
      { key:'floor20', name:'Getting Started', cond:()=> state.floor>=20 },
      { key:'floor50', name:'Climber', cond:()=> state.floor>=50 },
      { key:'floor100', name:'Icy Pro', cond:()=> state.floor>=100 },
      { key:'combo7', name:'Combo Starter', cond:()=> state.combo>=7 },
      { key:'combo10', name:'Combo Master', cond:()=> state.combo>=10 },
      { key:'firstPower', name:'Powered Up', cond:()=> false },
      { key:'savedScore', name:'On The Board', cond:()=> false },
      { key:'newPB', name:'New PB', cond:()=> false },
    ];
    let achUnlocked = {}; try{ achUnlocked = JSON.parse(localStorage.getItem('icy-achievements')||'{}')||{} }catch{}
    function saveAch(){ try{ localStorage.setItem('icy-achievements', JSON.stringify(achUnlocked)); }catch{} }
    function unlock(k){ if (achUnlocked[k]) return; achUnlocked[k]=true; saveAch(); renderAchievements(); showToast('Achievement: '+ (ACHS.find(a=>a.key===k)?.name||k)); }
    function checkAchievements(){ for (const a of ACHS){ if (!achUnlocked[a.key] && a.cond()) unlock(a.key); } }
    function renderAchievements(){
      const rows = ACHS.map(a=>{
        const ok = !!achUnlocked[a.key];
        return `<tr><td><span class=\"badge ${ok?'unlocked':''}\"><span class=\"mark\"></span>${a.name}</span></td><td>${ok? 'Unlocked ‚úÖ' : '<span class=\"muted\">Locked</span>'}</td></tr>`;
      }).join('');
      achBody.innerHTML = rows;
    }
    renderAchievements();
  </script>
</body>
</html>
