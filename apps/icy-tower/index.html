<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
  <title>Icy Tower Online</title>
  <link rel="icon" href="https://emojicdn.elk.sh/üßä">

  <meta property="og:title" content="Icy Tower Online">
  <meta property="og:description" content="Climb endless icy floors. Jump fast, don't fall!">
  <meta property="og:url" content="https://sloppy.live/icy-tower">
  <meta property="og:image" content="https://sloppy.live/icy-tower/og.png">

  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link href="https://fonts.googleapis.com/css2?family=Outfit:wght@400;600;800&display=swap" rel="stylesheet">

  <style>
    :root {
      --bg-deep: #0a0e1a;
      --bg-mid: #121b2e;
      --aurora1: #00d4aa;
      --aurora2: #00a8ff;
      --aurora3: #8b5cf6;
      --ice: #7dd3fc;
      --ice-glow: #38bdf8;
      --snow: #f0f9ff;
      --gold: #fbbf24;
      --danger: #f87171;
      --success: #4ade80;
    }

    * { box-sizing: border-box; margin: 0; padding: 0; }
    html, body { height: 100%; overflow: hidden; }

    body {
      font-family: 'Outfit', system-ui, sans-serif;
      background: var(--bg-deep);
      color: white;
    }

    .game-container {
      display: grid;
      grid-template-columns: 1fr 320px;
      height: 100vh;
      gap: 0;
    }

    @media (max-width: 900px) {
      .game-container { grid-template-columns: 1fr; }
      .sidebar { display: none; }
    }

    .canvas-area {
      position: relative;
      background: linear-gradient(180deg, #0f172a 0%, #1e293b 50%, #0f172a 100%);
      overflow: hidden;
    }

    canvas {
      display: block;
      width: 100%;
      height: 100%;
    }

    /* HUD */
    .hud {
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      padding: 16px 20px;
      display: flex;
      align-items: center;
      gap: 24px;
      background: linear-gradient(180deg, rgba(0,0,0,0.6) 0%, transparent 100%);
      z-index: 10;
    }

    .stat {
      display: flex;
      flex-direction: column;
      gap: 2px;
    }

    .stat-label {
      font-size: 11px;
      text-transform: uppercase;
      letter-spacing: 1px;
      opacity: 0.6;
    }

    .stat-value {
      font-size: 28px;
      font-weight: 800;
      background: linear-gradient(135deg, var(--ice) 0%, var(--aurora1) 100%);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
    }

    .stat-value.combo {
      background: linear-gradient(135deg, var(--gold) 0%, #f59e0b 100%);
      -webkit-background-clip: text;
      background-clip: text;
    }

    .hud-controls {
      margin-left: auto;
      display: flex;
      gap: 8px;
    }

    .btn {
      padding: 10px 18px;
      border: none;
      border-radius: 8px;
      font-family: inherit;
      font-weight: 600;
      font-size: 14px;
      cursor: pointer;
      transition: all 0.2s ease;
    }

    .btn-primary {
      background: linear-gradient(135deg, var(--aurora1) 0%, var(--aurora2) 100%);
      color: #0a0e1a;
      box-shadow: 0 4px 20px rgba(0, 212, 170, 0.3);
    }

    .btn-primary:hover {
      transform: translateY(-2px);
      box-shadow: 0 6px 30px rgba(0, 212, 170, 0.4);
    }

    .btn-ghost {
      background: rgba(255,255,255,0.1);
      color: white;
      border: 1px solid rgba(255,255,255,0.2);
    }

    .btn-ghost:hover {
      background: rgba(255,255,255,0.15);
    }

    /* Power-up chips */
    .powerups {
      position: absolute;
      top: 80px;
      left: 20px;
      display: flex;
      flex-direction: column;
      gap: 8px;
      z-index: 10;
    }

    .power-chip {
      display: flex;
      align-items: center;
      gap: 8px;
      padding: 8px 14px;
      background: rgba(0,0,0,0.6);
      backdrop-filter: blur(10px);
      border-radius: 20px;
      border: 1px solid rgba(255,255,255,0.1);
      font-size: 13px;
      font-weight: 600;
      animation: chipIn 0.3s ease-out;
    }

    @keyframes chipIn {
      from { opacity: 0; transform: translateX(-20px); }
      to { opacity: 1; transform: translateX(0); }
    }

    .power-chip .icon {
      width: 24px;
      height: 24px;
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 12px;
    }

    .power-chip.double .icon { background: linear-gradient(135deg, #4ade80, #22c55e); }
    .power-chip.slow .icon { background: linear-gradient(135deg, #fbbf24, #f59e0b); }
    .power-chip.boost .icon { background: linear-gradient(135deg, #8b5cf6, #7c3aed); }

    /* Overlays */
    .overlay {
      position: absolute;
      inset: 0;
      display: none;
      align-items: center;
      justify-content: center;
      background: rgba(10, 14, 26, 0.85);
      backdrop-filter: blur(8px);
      z-index: 100;
    }

    .overlay.show { display: flex; }

    .modal {
      background: linear-gradient(180deg, rgba(30,41,59,0.95) 0%, rgba(15,23,42,0.98) 100%);
      border: 1px solid rgba(255,255,255,0.1);
      border-radius: 20px;
      padding: 32px;
      max-width: 420px;
      width: 90%;
      text-align: center;
      box-shadow: 0 25px 80px rgba(0,0,0,0.5);
    }

    .modal-icon {
      font-size: 64px;
      margin-bottom: 16px;
      animation: float 3s ease-in-out infinite;
    }

    @keyframes float {
      0%, 100% { transform: translateY(0); }
      50% { transform: translateY(-10px); }
    }

    .modal h2 {
      font-size: 28px;
      font-weight: 800;
      margin-bottom: 12px;
      background: linear-gradient(135deg, var(--ice) 0%, var(--aurora1) 100%);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
    }

    .modal p {
      color: rgba(255,255,255,0.7);
      margin-bottom: 8px;
      line-height: 1.6;
    }

    .modal-controls {
      font-size: 13px;
      color: rgba(255,255,255,0.5);
      margin: 16px 0;
      padding: 12px;
      background: rgba(0,0,0,0.3);
      border-radius: 10px;
    }

    .modal-controls kbd {
      background: rgba(255,255,255,0.1);
      padding: 4px 8px;
      border-radius: 4px;
      font-family: inherit;
      margin: 0 2px;
    }

    .modal-buttons {
      display: flex;
      gap: 12px;
      justify-content: center;
      margin-top: 20px;
    }

    .score-display {
      font-size: 48px;
      font-weight: 800;
      background: linear-gradient(135deg, var(--gold) 0%, #f59e0b 100%);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
      margin: 16px 0;
    }

    .input-field {
      width: 100%;
      padding: 14px 18px;
      background: rgba(0,0,0,0.4);
      border: 1px solid rgba(255,255,255,0.1);
      border-radius: 10px;
      color: white;
      font-family: inherit;
      font-size: 16px;
      margin: 12px 0;
      transition: border-color 0.2s;
    }

    .input-field:focus {
      outline: none;
      border-color: var(--aurora1);
    }

    .error-msg {
      color: var(--danger);
      font-size: 13px;
      margin-top: 8px;
    }

    /* Sidebar */
    .sidebar {
      background: linear-gradient(180deg, #1e293b 0%, #0f172a 100%);
      border-left: 1px solid rgba(255,255,255,0.08);
      padding: 20px;
      overflow-y: auto;
      display: flex;
      flex-direction: column;
      gap: 20px;
    }

    .section-title {
      font-size: 14px;
      font-weight: 600;
      text-transform: uppercase;
      letter-spacing: 1px;
      color: rgba(255,255,255,0.5);
      margin-bottom: 12px;
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .leaderboard {
      background: rgba(0,0,0,0.3);
      border-radius: 12px;
      overflow: hidden;
    }

    .lb-row {
      display: grid;
      grid-template-columns: 32px 1fr 60px;
      padding: 12px 14px;
      border-bottom: 1px solid rgba(255,255,255,0.05);
      align-items: center;
      gap: 10px;
    }

    .lb-row:last-child { border-bottom: none; }
    .lb-row.header { background: rgba(255,255,255,0.05); font-weight: 600; font-size: 12px; color: rgba(255,255,255,0.6); }

    .lb-rank {
      font-weight: 800;
      color: var(--aurora1);
    }

    .lb-rank.gold { color: #fbbf24; }
    .lb-rank.silver { color: #94a3b8; }
    .lb-rank.bronze { color: #cd7f32; }

    .lb-name {
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
    }

    .lb-score {
      font-weight: 800;
      text-align: right;
      color: var(--ice);
    }

    .achievements {
      display: flex;
      flex-direction: column;
      gap: 8px;
    }

    .ach-item {
      display: flex;
      align-items: center;
      gap: 10px;
      padding: 10px 12px;
      background: rgba(0,0,0,0.2);
      border-radius: 8px;
      border: 1px solid rgba(255,255,255,0.05);
    }

    .ach-item.unlocked {
      border-color: rgba(74, 222, 128, 0.3);
      background: rgba(74, 222, 128, 0.1);
    }

    .ach-icon {
      width: 28px;
      height: 28px;
      border-radius: 50%;
      background: rgba(255,255,255,0.1);
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 14px;
    }

    .ach-item.unlocked .ach-icon {
      background: linear-gradient(135deg, #4ade80, #22c55e);
    }

    .ach-name {
      flex: 1;
      font-size: 13px;
    }

    .ach-status {
      font-size: 11px;
      color: rgba(255,255,255,0.4);
    }

    .ach-item.unlocked .ach-status {
      color: var(--success);
    }

    .backlink {
      margin-top: auto;
      padding-top: 16px;
      border-top: 1px solid rgba(255,255,255,0.1);
      text-align: center;
      font-size: 12px;
    }

    .backlink a {
      color: var(--ice);
      text-decoration: none;
    }

    /* Toast */
    .toast {
      position: absolute;
      left: 50%;
      top: 120px;
      transform: translateX(-50%) scale(0.9);
      background: rgba(0,0,0,0.8);
      backdrop-filter: blur(10px);
      padding: 12px 24px;
      border-radius: 30px;
      border: 1px solid rgba(255,255,255,0.1);
      font-weight: 600;
      opacity: 0;
      pointer-events: none;
      transition: all 0.3s ease;
      z-index: 50;
    }

    .toast.show {
      opacity: 1;
      transform: translateX(-50%) scale(1);
    }

    /* Mobile controls */
    .touch-controls {
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      padding: 16px;
      display: none;
      grid-template-columns: 1fr 1fr 1fr;
      gap: 12px;
      background: linear-gradient(180deg, transparent, rgba(0,0,0,0.8));
      z-index: 20;
    }

    @media (max-width: 900px) {
      .touch-controls { display: grid; }
      .hud-controls { display: none; }
    }

    .touch-btn {
      height: 70px;
      border-radius: 16px;
      border: 2px solid rgba(255,255,255,0.2);
      background: rgba(255,255,255,0.1);
      color: white;
      font-size: 28px;
      font-weight: 800;
      cursor: pointer;
      transition: all 0.1s;
      -webkit-tap-highlight-color: transparent;
    }

    .touch-btn:active {
      background: rgba(255,255,255,0.25);
      transform: scale(0.95);
    }

    .touch-btn.jump {
      background: linear-gradient(135deg, rgba(0,212,170,0.3), rgba(0,168,255,0.3));
      border-color: var(--aurora1);
    }
  </style>
</head>
<body>
  <div class="game-container">
    <div class="canvas-area">
      <canvas id="game"></canvas>

      <div class="hud">
        <div class="stat">
          <span class="stat-label">Floor</span>
          <span class="stat-value" id="floor">0</span>
        </div>
        <div class="stat">
          <span class="stat-label">Best</span>
          <span class="stat-value" id="best">0</span>
        </div>
        <div class="stat">
          <span class="stat-label">Combo</span>
          <span class="stat-value combo" id="combo">x1</span>
        </div>
        <div class="hud-controls">
          <button class="btn btn-ghost" id="pauseBtn">Pause</button>
          <button class="btn btn-ghost" id="muteBtn">üîä</button>
        </div>
      </div>

      <div class="powerups" id="powerChips"></div>

      <div class="toast" id="toast"></div>

      <!-- Start overlay -->
      <div class="overlay show" id="startOverlay">
        <div class="modal">
          <div class="modal-icon">üßä</div>
          <h2>Icy Tower</h2>
          <p>Climb as high as you can before the rising void catches you!</p>
          <div class="modal-controls">
            <kbd>A</kbd> <kbd>D</kbd> or <kbd>‚Üê</kbd> <kbd>‚Üí</kbd> to move<br>
            <kbd>Space</kbd> to jump ¬∑ <kbd>P</kbd> to pause
          </div>
          <div class="modal-buttons">
            <button class="btn btn-primary" id="playBtn">Play Now</button>
            <button class="btn btn-ghost" id="startMuteBtn">üîä Sound</button>
          </div>
        </div>
      </div>

      <!-- Game over overlay -->
      <div class="overlay" id="gameOverOverlay">
        <div class="modal">
          <div class="modal-icon">‚ùÑÔ∏è</div>
          <h2>Game Over</h2>
          <p>You reached floor</p>
          <div class="score-display" id="finalFloor">0</div>
          <div id="saveBlock">
            <input class="input-field" id="playerName" placeholder="Enter your name" maxlength="20">
            <div id="saveError" class="error-msg" style="display:none"></div>
            <div class="modal-buttons">
              <button class="btn btn-primary" id="saveScoreBtn">Save Score</button>
              <button class="btn btn-ghost" id="skipSaveBtn">Skip</button>
            </div>
          </div>
          <div class="modal-buttons" style="margin-top: 16px;">
            <button class="btn btn-primary" id="playAgainBtn">Play Again</button>
            <button class="btn btn-ghost" id="shareBtn">Share</button>
          </div>
        </div>
      </div>

      <!-- Touch controls -->
      <div class="touch-controls">
        <button class="touch-btn" id="leftPad">‚Üê</button>
        <button class="touch-btn jump" id="jumpPad">‚Üë</button>
        <button class="touch-btn" id="rightPad">‚Üí</button>
      </div>
    </div>

    <div class="sidebar">
      <div>
        <div class="section-title">üèÜ Leaderboard</div>
        <div class="leaderboard" id="leaderboard">
          <div class="lb-row header">
            <span>#</span>
            <span>Player</span>
            <span>Floor</span>
          </div>
          <div class="lb-row">
            <span></span>
            <span style="color:rgba(255,255,255,0.5)">Loading...</span>
            <span></span>
          </div>
        </div>
        <button class="btn btn-ghost" style="width:100%;margin-top:12px" id="refreshBtn">Refresh</button>
      </div>

      <div>
        <div class="section-title">üéØ Achievements</div>
        <div class="achievements" id="achievements"></div>
      </div>

      <div class="backlink">
        <a href="https://sloppy.live" target="_blank">‚Üê sloppy.live</a> ¬∑
        <a href="/overview">All Apps</a>
      </div>
    </div>
  </div>

  <script type="module">
    import supabase, { supabaseSession, isUserPremium } from './supabase-config.js';

    // ===== Canvas Setup =====
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');
    let W = 0, H = 0, dpr = Math.min(2, window.devicePixelRatio || 1);

    function resize() {
      W = canvas.clientWidth;
      H = canvas.clientHeight;
      canvas.width = W * dpr;
      canvas.height = H * dpr;
      ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
    }

    window.addEventListener('resize', resize);
    resize();

    // ===== Game State =====
    const game = {
      running: false,
      paused: false,
      muted: false,
      floor: 0,
      lastFloor: 0,
      best: parseInt(localStorage.getItem('icy-best') || '0'),
      combo: 1,
      comboTimer: 0,
      cameraY: 0,
      cameraTargetY: 0,
      deathLine: 0,
      lastTime: 0,
      particles: [],
      platforms: [],
      powerups: [],
      effects: { double: 0, slow: 0, boost: 0 },
      screenShake: 0,
    };

    // Player
    const player = {
      x: 0,
      y: 0,
      vx: 0,
      vy: 0,
      width: 30,
      height: 40,
      grounded: false,
      jumpsLeft: 1,
      facingRight: true,
      animFrame: 0,
      trail: [],
    };

    // Physics constants
    const PHYSICS = {
      gravity: 0.55,
      jumpForce: -14.5,
      moveAccel: 1.2,
      moveDecel: 0.85,
      maxSpeed: 7,
      airControl: 0.7,
      cameraSmooth: 0.08,
      deathSpeed: 0.8,
    };

    // Audio
    let audioCtx;
    function playSound(freq, duration = 0.1, type = 'sine', vol = 0.15) {
      if (game.muted) return;
      if (!audioCtx) {
        try { audioCtx = new (window.AudioContext || window.webkitAudioContext)(); } catch(e) { return; }
      }
      if (audioCtx.state === 'suspended') audioCtx.resume();

      const osc = audioCtx.createOscillator();
      const gain = audioCtx.createGain();
      osc.type = type;
      osc.frequency.value = freq;
      osc.connect(gain);
      gain.connect(audioCtx.destination);
      gain.gain.setValueAtTime(vol, audioCtx.currentTime);
      gain.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + duration);
      osc.start();
      osc.stop(audioCtx.currentTime + duration);
    }

    function playJumpSound() {
      playSound(440, 0.1, 'triangle', 0.12);
      setTimeout(() => playSound(660, 0.08, 'sine', 0.08), 30);
    }

    function playLandSound() {
      playSound(200, 0.05, 'square', 0.05);
    }

    function playPowerupSound() {
      playSound(523, 0.1, 'sine', 0.12);
      setTimeout(() => playSound(659, 0.1, 'sine', 0.1), 80);
      setTimeout(() => playSound(784, 0.15, 'sine', 0.08), 160);
    }

    // ===== Particles =====
    function spawnParticle(x, y, vx, vy, color, life = 1, size = 4) {
      game.particles.push({ x, y, vx, vy, color, life, maxLife: life, size });
    }

    function spawnJumpParticles(x, y) {
      for (let i = 0; i < 8; i++) {
        const angle = Math.PI + (Math.random() - 0.5) * 1.2;
        const speed = 2 + Math.random() * 3;
        spawnParticle(
          x + (Math.random() - 0.5) * 20,
          y,
          Math.cos(angle) * speed,
          Math.sin(angle) * speed,
          `hsla(${190 + Math.random() * 30}, 80%, 70%, 0.8)`,
          0.5 + Math.random() * 0.3,
          3 + Math.random() * 3
        );
      }
    }

    function spawnLandParticles(x, y) {
      for (let i = 0; i < 6; i++) {
        const angle = -Math.PI / 2 + (Math.random() - 0.5) * 2;
        const speed = 1 + Math.random() * 2;
        spawnParticle(
          x + (Math.random() - 0.5) * 30,
          y,
          Math.cos(angle) * speed,
          Math.sin(angle) * speed - 1,
          'rgba(200, 230, 255, 0.6)',
          0.4,
          2 + Math.random() * 2
        );
      }
    }

    function spawnPowerupParticles(x, y, color) {
      for (let i = 0; i < 12; i++) {
        const angle = (i / 12) * Math.PI * 2;
        const speed = 3 + Math.random() * 2;
        spawnParticle(x, y, Math.cos(angle) * speed, Math.sin(angle) * speed, color, 0.6, 4);
      }
    }

    function updateParticles(dt) {
      for (let i = game.particles.length - 1; i >= 0; i--) {
        const p = game.particles[i];
        p.x += p.vx * dt;
        p.y += p.vy * dt;
        p.vy += 0.1 * dt;
        p.life -= dt / 60;
        if (p.life <= 0) game.particles.splice(i, 1);
      }
    }

    // ===== Platforms =====
    function createPlatform(y) {
      const minW = Math.max(80, W * 0.2);
      const maxW = Math.max(150, W * 0.35);
      const w = minW + Math.random() * (maxW - minW);
      const x = Math.random() * (W - w);
      const type = Math.random() < 0.15 ? 'special' : 'normal';
      return { x, y, w, h: 14, type };
    }

    function resetWorld() {
      game.floor = 0;
      game.combo = 1;
      game.comboTimer = 0;
      game.cameraY = 0;
      game.cameraTargetY = 0;
      game.deathLine = H + 100;
      game.particles = [];
      game.platforms = [];
      game.powerups = [];
      game.effects = { double: 0, slow: 0, boost: 0 };
      game.screenShake = 0;

      player.x = W / 2 - player.width / 2;
      player.y = H * 0.6;
      player.vx = 0;
      player.vy = 0;
      player.grounded = false;
      player.jumpsLeft = 1;
      player.trail = [];

      // Ground platform
      game.platforms.push({ x: 0, y: H * 0.75, w: W, h: 20, type: 'ground' });

      // Generate initial platforms
      let y = H * 0.6;
      for (let i = 0; i < 40; i++) {
        y -= 55 + Math.random() * 40;
        const plat = createPlatform(y);
        game.platforms.push(plat);
        maybeSpawnPowerup(plat);
      }
    }

    function maybeSpawnPowerup(plat) {
      if (plat.y > H - 100) return;
      if (Math.random() > 0.1) return;

      const types = ['double', 'slow', 'boost'];
      const type = types[Math.floor(Math.random() * types.length)];
      game.powerups.push({
        x: plat.x + plat.w / 2,
        y: plat.y - 15,
        type,
        bob: Math.random() * Math.PI * 2,
      });
    }

    // ===== Input =====
    const input = { left: false, right: false, jump: false, jumpPressed: false };

    window.addEventListener('keydown', (e) => {
      if (e.repeat) return;
      if (e.code === 'ArrowLeft' || e.code === 'KeyA') input.left = true;
      if (e.code === 'ArrowRight' || e.code === 'KeyD') input.right = true;
      if (e.code === 'Space' || e.code === 'ArrowUp' || e.code === 'KeyW') {
        input.jump = true;
        input.jumpPressed = true;
        if (!game.running) startGame();
      }
      if (e.code === 'KeyP') togglePause();
      if (e.code === 'KeyR' && !game.running) { resetWorld(); }
    });

    window.addEventListener('keyup', (e) => {
      if (e.code === 'ArrowLeft' || e.code === 'KeyA') input.left = false;
      if (e.code === 'ArrowRight' || e.code === 'KeyD') input.right = false;
      if (e.code === 'Space' || e.code === 'ArrowUp' || e.code === 'KeyW') input.jump = false;
    });

    // Touch controls
    function bindTouch(el, onStart, onEnd) {
      const start = (e) => { e.preventDefault(); onStart(); };
      const end = (e) => { e.preventDefault(); onEnd(); };
      el.addEventListener('touchstart', start, { passive: false });
      el.addEventListener('touchend', end, { passive: false });
      el.addEventListener('mousedown', start);
      el.addEventListener('mouseup', end);
      el.addEventListener('mouseleave', end);
    }

    bindTouch(document.getElementById('leftPad'), () => input.left = true, () => input.left = false);
    bindTouch(document.getElementById('rightPad'), () => input.right = true, () => input.right = false);
    bindTouch(document.getElementById('jumpPad'), () => {
      input.jump = true;
      input.jumpPressed = true;
      if (!game.running) startGame();
    }, () => input.jump = false);

    // ===== Physics Update =====
    function update(dt) {
      const dtNorm = dt / 16.67; // Normalize to 60fps

      // Combo decay
      if (game.comboTimer > 0) {
        game.comboTimer -= dt;
        if (game.comboTimer <= 0) {
          game.combo = Math.max(1, game.combo - 1);
          game.comboTimer = game.combo > 1 ? 2000 : 0;
        }
      }

      // Effects decay
      for (const key of Object.keys(game.effects)) {
        game.effects[key] = Math.max(0, game.effects[key] - dt);
      }
      renderPowerChips();

      // Screen shake decay
      game.screenShake *= 0.9;

      // Player movement
      const accel = PHYSICS.moveAccel * (player.grounded ? 1 : PHYSICS.airControl);

      if (input.left) {
        player.vx -= accel * dtNorm;
        player.facingRight = false;
      } else if (input.right) {
        player.vx += accel * dtNorm;
        player.facingRight = true;
      } else {
        player.vx *= Math.pow(PHYSICS.moveDecel, dtNorm);
      }

      // Clamp speed
      const maxSpd = PHYSICS.maxSpeed * (game.effects.boost > 0 ? 1.2 : 1);
      player.vx = Math.max(-maxSpd, Math.min(maxSpd, player.vx));

      // Jump
      if (input.jumpPressed) {
        const jumpMod = game.effects.boost > 0 ? 1.25 : 1;

        if (player.grounded) {
          player.vy = PHYSICS.jumpForce * jumpMod;
          player.grounded = false;
          player.jumpsLeft = game.effects.double > 0 ? 1 : 0;
          playJumpSound();
          spawnJumpParticles(player.x + player.width / 2, player.y + player.height);
        } else if (game.effects.double > 0 && player.jumpsLeft > 0) {
          player.vy = PHYSICS.jumpForce * jumpMod * 0.9;
          player.jumpsLeft--;
          playJumpSound();
          spawnJumpParticles(player.x + player.width / 2, player.y + player.height / 2);
        }
        input.jumpPressed = false;
      }

      // Gravity
      const gravMod = game.effects.slow > 0 ? 0.7 : 1;
      player.vy += PHYSICS.gravity * gravMod * dtNorm;

      // Apply velocity
      player.x += player.vx * dtNorm;
      player.y += player.vy * dtNorm;

      // Wrap horizontally
      if (player.x < -player.width) player.x = W;
      if (player.x > W) player.x = -player.width;

      // Trail
      if (Math.abs(player.vy) > 2 || Math.abs(player.vx) > 3) {
        player.trail.push({ x: player.x + player.width / 2, y: player.y + player.height / 2, alpha: 0.5 });
        if (player.trail.length > 15) player.trail.shift();
      }
      for (const t of player.trail) t.alpha *= 0.92;
      player.trail = player.trail.filter(t => t.alpha > 0.05);

      // Platform collisions
      let landed = false;
      for (const plat of game.platforms) {
        if (player.vy >= 0 &&
            player.x + player.width > plat.x &&
            player.x < plat.x + plat.w &&
            player.y + player.height >= plat.y &&
            player.y + player.height <= plat.y + plat.h + player.vy * dtNorm + 5) {

          player.y = plat.y - player.height;
          player.vy = 0;
          player.grounded = true;
          player.jumpsLeft = game.effects.double > 0 ? 2 : 1;
          landed = true;

          // Score
          const screenY = plat.y - game.cameraY;
          if (screenY < H * 0.6 && plat.type !== 'ground') {
            game.floor++;
            game.combo = Math.min(10, game.combo + 1);
            game.comboTimer = 2500;
            playLandSound();
            spawnLandParticles(player.x + player.width / 2, player.y + player.height);
            checkAchievements();
          }
          break;
        }
      }

      if (!landed && player.grounded) player.grounded = false;

      // Powerup collection
      for (let i = game.powerups.length - 1; i >= 0; i--) {
        const pu = game.powerups[i];
        const dx = (player.x + player.width / 2) - pu.x;
        const dy = (player.y + player.height / 2) - pu.y;
        if (Math.sqrt(dx * dx + dy * dy) < 30) {
          applyPowerup(pu.type, pu.x, pu.y);
          game.powerups.splice(i, 1);
        }
      }

      // Camera follow
      game.cameraTargetY = Math.min(game.cameraTargetY, player.y - H * 0.45);
      game.cameraY += (game.cameraTargetY - game.cameraY) * PHYSICS.cameraSmooth * dtNorm;

      // Death line rises
      const scrollSpeed = PHYSICS.deathSpeed * (game.effects.slow > 0 ? 0.5 : 1);
      game.deathLine -= scrollSpeed * dtNorm;

      // Recycle platforms
      const cutoff = game.cameraY + H + 100;
      game.platforms = game.platforms.filter(p => p.y < cutoff);
      game.powerups = game.powerups.filter(p => p.y < cutoff);

      // Generate new platforms
      while (game.platforms.length < 45) {
        const topY = Math.min(...game.platforms.map(p => p.y));
        const newY = topY - (55 + Math.random() * 40);
        const plat = createPlatform(newY);
        game.platforms.push(plat);
        maybeSpawnPowerup(plat);
      }

      // Death check
      if (player.y - game.cameraY > H + 50) {
        endGame();
      }

      // Update particles
      updateParticles(dtNorm);
    }

    function applyPowerup(type, x, y) {
      const dur = 8000;
      game.effects[type] = dur;

      let color = '#4ade80';
      let msg = 'Double Jump!';
      if (type === 'slow') { color = '#fbbf24'; msg = 'Time Slow!'; }
      if (type === 'boost') { color = '#8b5cf6'; msg = 'Super Jump!'; }

      playPowerupSound();
      spawnPowerupParticles(x, y - game.cameraY, color);
      showToast(msg);
      unlock('firstPower');
    }

    // ===== Rendering =====
    function draw() {
      ctx.clearRect(0, 0, W, H);

      // Background gradient
      const bgGrad = ctx.createLinearGradient(0, 0, 0, H);
      bgGrad.addColorStop(0, '#0f172a');
      bgGrad.addColorStop(0.5, '#1e293b');
      bgGrad.addColorStop(1, '#0f172a');
      ctx.fillStyle = bgGrad;
      ctx.fillRect(0, 0, W, H);

      // Aurora effect
      ctx.globalAlpha = 0.15;
      const auroraGrad = ctx.createLinearGradient(0, 0, W, H * 0.5);
      auroraGrad.addColorStop(0, '#00d4aa');
      auroraGrad.addColorStop(0.5, '#00a8ff');
      auroraGrad.addColorStop(1, '#8b5cf6');
      ctx.fillStyle = auroraGrad;
      ctx.fillRect(0, 0, W, H * 0.4);
      ctx.globalAlpha = 1;

      // Stars
      ctx.fillStyle = 'rgba(255, 255, 255, 0.4)';
      for (let i = 0; i < 30; i++) {
        const sx = (i * 137) % W;
        const sy = ((i * 73 + game.cameraY * 0.1) % H + H) % H;
        ctx.fillRect(sx, sy, 2, 2);
      }

      // Screen shake
      if (game.screenShake > 0.1) {
        ctx.save();
        ctx.translate(
          (Math.random() - 0.5) * game.screenShake,
          (Math.random() - 0.5) * game.screenShake
        );
      }

      const cam = game.cameraY;

      // Platforms
      for (const plat of game.platforms) {
        const py = plat.y - cam;
        if (py < -30 || py > H + 30) continue;

        // Platform glow
        ctx.shadowColor = plat.type === 'special' ? '#fbbf24' : '#38bdf8';
        ctx.shadowBlur = plat.type === 'special' ? 15 : 8;

        // Platform body
        const grad = ctx.createLinearGradient(plat.x, py, plat.x, py + plat.h);
        if (plat.type === 'special') {
          grad.addColorStop(0, 'rgba(251, 191, 36, 0.9)');
          grad.addColorStop(1, 'rgba(217, 119, 6, 0.8)');
        } else if (plat.type === 'ground') {
          grad.addColorStop(0, 'rgba(148, 163, 184, 0.9)');
          grad.addColorStop(1, 'rgba(100, 116, 139, 0.8)');
        } else {
          grad.addColorStop(0, 'rgba(186, 230, 253, 0.95)');
          grad.addColorStop(0.4, 'rgba(125, 211, 252, 0.9)');
          grad.addColorStop(1, 'rgba(56, 189, 248, 0.8)');
        }

        ctx.fillStyle = grad;
        roundRect(plat.x, py, plat.w, plat.h, 4);
        ctx.fill();

        // Frost highlight
        ctx.fillStyle = 'rgba(255, 255, 255, 0.5)';
        ctx.fillRect(plat.x + 4, py + 2, plat.w - 8, 2);

        ctx.shadowBlur = 0;
      }

      // Powerups
      for (const pu of game.powerups) {
        const py = pu.y - cam;
        if (py < -30 || py > H + 30) continue;

        pu.bob += 0.05;
        const bobY = py + Math.sin(pu.bob) * 4;

        let color1, color2, icon;
        if (pu.type === 'double') {
          color1 = '#4ade80'; color2 = '#22c55e'; icon = '2√ó';
        } else if (pu.type === 'slow') {
          color1 = '#fbbf24'; color2 = '#f59e0b'; icon = '‚è±';
        } else {
          color1 = '#8b5cf6'; color2 = '#7c3aed'; icon = '‚Üë';
        }

        // Glow
        ctx.shadowColor = color1;
        ctx.shadowBlur = 15;

        // Circle
        const puGrad = ctx.createRadialGradient(pu.x, bobY, 0, pu.x, bobY, 14);
        puGrad.addColorStop(0, color1);
        puGrad.addColorStop(1, color2);
        ctx.fillStyle = puGrad;
        ctx.beginPath();
        ctx.arc(pu.x, bobY, 12, 0, Math.PI * 2);
        ctx.fill();

        // Icon
        ctx.shadowBlur = 0;
        ctx.fillStyle = '#fff';
        ctx.font = 'bold 10px Outfit';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText(icon, pu.x, bobY);
      }

      // Particles
      for (const p of game.particles) {
        const alpha = p.life / p.maxLife;
        ctx.globalAlpha = alpha;
        ctx.fillStyle = p.color;
        ctx.beginPath();
        ctx.arc(p.x, p.y - cam, p.size * alpha, 0, Math.PI * 2);
        ctx.fill();
      }
      ctx.globalAlpha = 1;

      // Player trail
      for (const t of player.trail) {
        ctx.globalAlpha = t.alpha * 0.5;
        ctx.fillStyle = '#7dd3fc';
        ctx.beginPath();
        ctx.arc(t.x, t.y - cam, 8, 0, Math.PI * 2);
        ctx.fill();
      }
      ctx.globalAlpha = 1;

      // Player
      const px = player.x;
      const py = player.y - cam;

      ctx.save();
      ctx.translate(px + player.width / 2, py + player.height / 2);

      // Tilt based on velocity
      const tilt = Math.max(-0.2, Math.min(0.2, player.vx * 0.03));
      ctx.rotate(tilt);

      // Glow
      ctx.shadowColor = '#38bdf8';
      ctx.shadowBlur = 12;

      // Body
      const bodyGrad = ctx.createLinearGradient(-15, -20, 15, 20);
      bodyGrad.addColorStop(0, '#e0f2fe');
      bodyGrad.addColorStop(0.5, '#bae6fd');
      bodyGrad.addColorStop(1, '#7dd3fc');
      ctx.fillStyle = bodyGrad;
      roundRect(-player.width / 2, -player.height / 2, player.width, player.height, 8);
      ctx.fill();

      ctx.shadowBlur = 0;

      // Scarf
      ctx.fillStyle = '#f43f5e';
      ctx.fillRect(-player.width / 2, -player.height / 2 + 8, player.width, 6);

      // Face
      ctx.fillStyle = '#0f172a';
      const eyeOffset = player.facingRight ? 2 : -2;
      ctx.fillRect(-6 + eyeOffset, -4, 4, 4);
      ctx.fillRect(4 + eyeOffset, -4, 4, 4);

      // Smile
      ctx.fillRect(-4 + eyeOffset, 6, 10, 2);

      ctx.restore();

      // Death line indicator (subtle)
      const deathY = game.deathLine - cam;
      if (deathY < H + 50 && deathY > -50) {
        ctx.fillStyle = `rgba(248, 113, 113, ${0.3 + Math.sin(Date.now() / 200) * 0.1})`;
        ctx.fillRect(0, deathY, W, 4);
      }

      if (game.screenShake > 0.1) {
        ctx.restore();
      }

      // Update HUD
      document.getElementById('floor').textContent = game.floor;
      document.getElementById('best').textContent = game.best;
      document.getElementById('combo').textContent = 'x' + game.combo;
    }

    function roundRect(x, y, w, h, r) {
      ctx.beginPath();
      ctx.moveTo(x + r, y);
      ctx.arcTo(x + w, y, x + w, y + h, r);
      ctx.arcTo(x + w, y + h, x, y + h, r);
      ctx.arcTo(x, y + h, x, y, r);
      ctx.arcTo(x, y, x + w, y, r);
      ctx.closePath();
    }

    // ===== Game Loop =====
    function gameLoop(timestamp) {
      const dt = Math.min(32, timestamp - game.lastTime || 16);
      game.lastTime = timestamp;

      if (game.running && !game.paused) {
        update(dt);
      }
      draw();
      requestAnimationFrame(gameLoop);
    }

    requestAnimationFrame(gameLoop);

    // ===== UI =====
    const startOverlay = document.getElementById('startOverlay');
    const gameOverOverlay = document.getElementById('gameOverOverlay');

    document.getElementById('playBtn').onclick = startGame;
    document.getElementById('playAgainBtn').onclick = () => {
      gameOverOverlay.classList.remove('show');
      startGame();
    };

    document.getElementById('pauseBtn').onclick = togglePause;

    const muteBtn = document.getElementById('muteBtn');
    const startMuteBtn = document.getElementById('startMuteBtn');
    function updateMuteUI() {
      muteBtn.textContent = game.muted ? 'üîá' : 'üîä';
      startMuteBtn.textContent = game.muted ? 'üîá Muted' : 'üîä Sound';
    }
    muteBtn.onclick = startMuteBtn.onclick = () => {
      game.muted = !game.muted;
      updateMuteUI();
    };

    document.getElementById('shareBtn').onclick = () => {
      const text = encodeURIComponent(`I reached floor ${game.lastFloor} in Icy Tower! üßä`);
      const url = encodeURIComponent('https://sloppy.live/icy-tower');
      window.open(`https://twitter.com/intent/tweet?text=${text}&url=${url}`, '_blank');
    };

    function startGame() {
      if (game.running) return;
      startOverlay.classList.remove('show');
      gameOverOverlay.classList.remove('show');
      resetWorld();
      game.running = true;
      game.paused = false;
    }

    function togglePause() {
      if (!game.running) return;
      game.paused = !game.paused;
      document.getElementById('pauseBtn').textContent = game.paused ? 'Resume' : 'Pause';
    }

    function endGame() {
      game.running = false;
      game.lastFloor = game.floor;
      game.best = Math.max(game.best, game.floor);
      localStorage.setItem('icy-best', game.best);
      document.getElementById('finalFloor').textContent = game.floor;
      gameOverOverlay.classList.add('show');
      if (game.floor >= game.best && game.floor > 0) unlock('newPB');
    }

    // ===== Powerup Chips =====
    const chipsEl = document.getElementById('powerChips');
    function renderPowerChips() {
      const chips = [];
      if (game.effects.double > 0) chips.push({ type: 'double', label: 'Double Jump', time: Math.ceil(game.effects.double / 1000) });
      if (game.effects.slow > 0) chips.push({ type: 'slow', label: 'Time Slow', time: Math.ceil(game.effects.slow / 1000) });
      if (game.effects.boost > 0) chips.push({ type: 'boost', label: 'Super Jump', time: Math.ceil(game.effects.boost / 1000) });

      chipsEl.innerHTML = chips.map(c => `
        <div class="power-chip ${c.type}">
          <div class="icon">${c.type === 'double' ? '2√ó' : c.type === 'slow' ? '‚è±' : '‚Üë'}</div>
          <span>${c.label}</span>
          <span style="opacity:0.6">${c.time}s</span>
        </div>
      `).join('');
    }

    // ===== Toast =====
    const toastEl = document.getElementById('toast');
    let toastTimer = null;
    function showToast(msg) {
      clearTimeout(toastTimer);
      toastEl.textContent = msg;
      toastEl.classList.add('show');
      toastTimer = setTimeout(() => toastEl.classList.remove('show'), 1500);
    }

    // ===== Achievements =====
    const ACHIEVEMENTS = [
      { key: 'floor20', name: 'Getting Started', desc: 'Reach floor 20', check: () => game.floor >= 20 },
      { key: 'floor50', name: 'Climber', desc: 'Reach floor 50', check: () => game.floor >= 50 },
      { key: 'floor100', name: 'Icy Pro', desc: 'Reach floor 100', check: () => game.floor >= 100 },
      { key: 'combo7', name: 'Combo Starter', desc: 'Get a x7 combo', check: () => game.combo >= 7 },
      { key: 'combo10', name: 'Combo Master', desc: 'Get a x10 combo', check: () => game.combo >= 10 },
      { key: 'firstPower', name: 'Powered Up', desc: 'Collect a power-up', check: () => false },
      { key: 'savedScore', name: 'On The Board', desc: 'Save a score', check: () => false },
      { key: 'newPB', name: 'New Record', desc: 'Beat your best', check: () => false },
    ];

    let unlocked = {};
    try { unlocked = JSON.parse(localStorage.getItem('icy-achievements') || '{}'); } catch {}

    function saveAchievements() {
      localStorage.setItem('icy-achievements', JSON.stringify(unlocked));
    }

    function unlock(key) {
      if (unlocked[key]) return;
      unlocked[key] = true;
      saveAchievements();
      renderAchievements();
      const ach = ACHIEVEMENTS.find(a => a.key === key);
      if (ach) showToast(`üéØ ${ach.name}`);
    }

    function checkAchievements() {
      for (const a of ACHIEVEMENTS) {
        if (!unlocked[a.key] && a.check()) unlock(a.key);
      }
    }

    function renderAchievements() {
      const achEl = document.getElementById('achievements');
      achEl.innerHTML = ACHIEVEMENTS.map(a => `
        <div class="ach-item ${unlocked[a.key] ? 'unlocked' : ''}">
          <div class="ach-icon">${unlocked[a.key] ? '‚úì' : '?'}</div>
          <span class="ach-name">${a.name}</span>
          <span class="ach-status">${unlocked[a.key] ? 'Unlocked' : 'Locked'}</span>
        </div>
      `).join('');
    }

    renderAchievements();

    // ===== Leaderboard =====
    let currentUser = null;
    const leaderboardEl = document.getElementById('leaderboard');

    async function initAuth() {
      try {
        const { user } = await supabaseSession();
        currentUser = user;
      } catch (e) {
        console.error('Auth error:', e);
      }
      loadLeaderboard();
    }

    async function loadLeaderboard() {
      try {
        const { data, error } = await supabase
          .from('icy_tower_scores')
          .select('score, display_name, created_at')
          .order('score', { ascending: false })
          .limit(10);

        if (error) throw error;

        const header = '<div class="lb-row header"><span>#</span><span>Player</span><span>Floor</span></div>';

        if (!data || data.length === 0) {
          leaderboardEl.innerHTML = header + '<div class="lb-row"><span></span><span style="color:rgba(255,255,255,0.5)">No scores yet</span><span></span></div>';
          return;
        }

        leaderboardEl.innerHTML = header + data.map((row, i) => {
          const rankClass = i === 0 ? 'gold' : i === 1 ? 'silver' : i === 2 ? 'bronze' : '';
          return `<div class="lb-row">
            <span class="lb-rank ${rankClass}">${i + 1}</span>
            <span class="lb-name">${escapeHtml(row.display_name || 'Anonymous')}</span>
            <span class="lb-score">${row.score}</span>
          </div>`;
        }).join('');
      } catch (e) {
        console.error('Leaderboard error:', e);
      }
    }

    document.getElementById('refreshBtn').onclick = loadLeaderboard;

    // Save score
    const saveScoreBtn = document.getElementById('saveScoreBtn');
    const skipSaveBtn = document.getElementById('skipSaveBtn');
    const saveError = document.getElementById('saveError');
    const playerNameInput = document.getElementById('playerName');
    const saveBlock = document.getElementById('saveBlock');

    skipSaveBtn.onclick = () => saveBlock.style.display = 'none';

    saveScoreBtn.onclick = async () => {
      saveError.style.display = 'none';
      try {
        const name = (playerNameInput.value || 'Anonymous').slice(0, 20);
        const { error } = await supabase.from('icy_tower_scores').insert([{
          score: game.lastFloor,
          display_name: name,
          user_id: currentUser?.id
        }]);
        if (error) throw error;
        saveBlock.style.display = 'none';
        unlock('savedScore');
        loadLeaderboard();
      } catch (e) {
        saveError.textContent = 'Failed to save: ' + e.message;
        saveError.style.display = 'block';
      }
    };

    function escapeHtml(s) {
      const div = document.createElement('div');
      div.textContent = s;
      return div.innerHTML;
    }

    // Init
    resetWorld();
    draw();
    initAuth();
  </script>
</body>
</html>
