<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
  <title>Icy Tower</title>
  <link rel="icon" href="https://emojicdn.elk.sh/üßä">

  <meta property="og:title" content="Icy Tower Online">
  <meta property="og:description" content="Climb endless icy floors with neon style!">
  <meta property="og:url" content="https://sloppy.live/icy-tower">
  <meta property="og:image" content="https://sloppy.live/icy-tower/og.png">

  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&display=swap" rel="stylesheet">

  <style>
    * { box-sizing: border-box; margin: 0; padding: 0; }
    html, body { height: 100%; overflow: hidden; }

    body {
      font-family: 'Orbitron', sans-serif;
      background: #030712;
      color: #fff;
    }

    .game-wrap {
      width: 100vw;
      height: 100vh;
      display: flex;
      position: relative;
      overflow: hidden;
    }

    /* Animated background */
    .bg-layer {
      position: absolute;
      inset: 0;
      background:
        radial-gradient(ellipse at 20% 0%, rgba(0, 255, 255, 0.08) 0%, transparent 50%),
        radial-gradient(ellipse at 80% 100%, rgba(0, 150, 255, 0.08) 0%, transparent 50%),
        linear-gradient(180deg, #030712 0%, #0a1628 50%, #030712 100%);
      z-index: 0;
    }

    .canvas-container {
      flex: 1;
      position: relative;
      z-index: 1;
    }

    canvas {
      display: block;
      width: 100%;
      height: 100%;
    }

    /* HUD */
    .hud {
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      padding: 20px 24px;
      display: flex;
      align-items: flex-start;
      gap: 32px;
      background: linear-gradient(180deg, rgba(0,0,0,0.7) 0%, transparent 100%);
      z-index: 10;
    }

    .stat {
      text-align: center;
    }

    .stat-label {
      font-size: 10px;
      letter-spacing: 2px;
      color: rgba(0, 255, 255, 0.6);
      text-transform: uppercase;
    }

    .stat-value {
      font-size: 32px;
      font-weight: 900;
      color: #22c55e;
      text-shadow: 0 0 20px #22c55e, 0 0 40px #22c55e;
    }

    .stat-value.combo {
      color: #ef4444;
      text-shadow: 0 0 20px #ef4444, 0 0 40px #ef4444;
    }

    .hud-right {
      margin-left: auto;
      display: flex;
      gap: 12px;
    }

    .btn {
      background: transparent;
      border: 1px solid rgba(34, 197, 94, 0.4);
      color: #22c55e;
      padding: 10px 20px;
      font-family: inherit;
      font-size: 12px;
      letter-spacing: 1px;
      cursor: pointer;
      transition: all 0.2s;
      text-transform: uppercase;
    }

    .btn:hover {
      background: rgba(34, 197, 94, 0.15);
      border-color: #22c55e;
      box-shadow: 0 0 20px rgba(34, 197, 94, 0.4);
    }

    /* Power chips */
    .power-chips {
      position: absolute;
      top: 90px;
      left: 24px;
      display: flex;
      flex-direction: column;
      gap: 8px;
      z-index: 10;
    }

    .power-chip {
      display: flex;
      align-items: center;
      gap: 10px;
      padding: 8px 16px;
      background: rgba(0, 0, 0, 0.6);
      border: 1px solid;
      border-radius: 4px;
      font-size: 12px;
      letter-spacing: 1px;
      animation: chipGlow 1s ease-in-out infinite alternate;
    }

    .power-chip.double { border-color: #0f0; color: #0f0; }
    .power-chip.slow { border-color: #ff0; color: #ff0; }
    .power-chip.boost { border-color: #f0f; color: #f0f; }

    @keyframes chipGlow {
      from { box-shadow: 0 0 5px currentColor; }
      to { box-shadow: 0 0 15px currentColor; }
    }

    /* Overlays */
    .overlay {
      position: absolute;
      inset: 0;
      display: none;
      align-items: center;
      justify-content: center;
      background: rgba(3, 7, 18, 0.9);
      backdrop-filter: blur(10px);
      z-index: 100;
    }

    .overlay.show { display: flex; }

    .modal {
      text-align: center;
      padding: 48px;
      max-width: 420px;
    }

    .modal-icon {
      font-size: 80px;
      margin-bottom: 24px;
      animation: iconFloat 3s ease-in-out infinite;
      filter: drop-shadow(0 0 30px rgba(0, 255, 255, 0.5));
    }

    @keyframes iconFloat {
      0%, 100% { transform: translateY(0) rotate(-5deg); }
      50% { transform: translateY(-15px) rotate(5deg); }
    }

    .modal h1 {
      font-size: 48px;
      font-weight: 900;
      letter-spacing: 4px;
      margin-bottom: 16px;
      background: linear-gradient(135deg, #0ff 0%, #00f 50%, #f0f 100%);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
      text-shadow: none;
    }

    .modal p {
      color: rgba(255, 255, 255, 0.6);
      font-size: 14px;
      line-height: 1.6;
      margin-bottom: 8px;
    }

    .modal-controls {
      margin: 24px 0;
      padding: 16px;
      background: rgba(0, 255, 255, 0.05);
      border: 1px solid rgba(0, 255, 255, 0.2);
      border-radius: 8px;
      font-size: 12px;
      color: rgba(255, 255, 255, 0.5);
    }

    .modal-controls kbd {
      background: rgba(0, 255, 255, 0.15);
      border: 1px solid rgba(0, 255, 255, 0.3);
      padding: 4px 10px;
      border-radius: 4px;
      margin: 0 4px;
      color: #0ff;
    }

    .modal-buttons {
      display: flex;
      gap: 16px;
      justify-content: center;
      margin-top: 32px;
    }

    .btn-primary {
      background: linear-gradient(135deg, #ef4444 0%, #991b1b 100%);
      border: none;
      color: #fff;
      font-weight: 700;
      padding: 14px 32px;
      box-shadow: 0 0 30px rgba(239, 68, 68, 0.4);
    }

    .btn-primary:hover {
      box-shadow: 0 0 50px rgba(239, 68, 68, 0.6);
      transform: scale(1.05);
    }

    .score-display {
      font-size: 72px;
      font-weight: 900;
      color: #ffd700;
      text-shadow: 0 0 40px #ffd700, 0 0 80px #ffd700;
      margin: 24px 0;
    }

    .input-wrap {
      margin: 24px 0;
    }

    .input-wrap label {
      display: block;
      font-size: 11px;
      letter-spacing: 1px;
      color: rgba(255, 255, 255, 0.5);
      margin-bottom: 8px;
      text-transform: uppercase;
    }

    .neon-input {
      width: 100%;
      padding: 14px 18px;
      background: rgba(0, 0, 0, 0.5);
      border: 1px solid rgba(34, 197, 94, 0.3);
      border-radius: 4px;
      color: #fff;
      font-family: inherit;
      font-size: 16px;
      text-align: center;
      transition: all 0.2s;
    }

    .neon-input:focus {
      outline: none;
      border-color: #22c55e;
      box-shadow: 0 0 20px rgba(34, 197, 94, 0.3);
    }

    .error-text {
      color: #f66;
      font-size: 12px;
      margin-top: 8px;
    }

    /* Toast */
    .toast {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%) scale(0.8);
      background: rgba(0, 0, 0, 0.8);
      border: 1px solid #ffd700;
      padding: 16px 32px;
      font-size: 18px;
      font-weight: 700;
      color: #ffd700;
      text-shadow: 0 0 10px #ffd700;
      box-shadow: 0 0 30px rgba(255, 215, 0, 0.3);
      opacity: 0;
      pointer-events: none;
      transition: all 0.3s;
      z-index: 50;
    }

    .toast.show {
      opacity: 1;
      transform: translate(-50%, -50%) scale(1);
    }

    /* Mobile controls */
    .touch-controls {
      display: none;
      position: absolute;
      bottom: 20px;
      left: 20px;
      right: 20px;
      grid-template-columns: 1fr 1fr 1fr;
      gap: 12px;
      z-index: 20;
    }

    @media (max-width: 768px) {
      .touch-controls { display: grid; }
      .hud-right { display: none; }
    }

    .touch-btn {
      height: 80px;
      background: rgba(239, 68, 68, 0.15);
      border: 2px solid rgba(239, 68, 68, 0.5);
      border-radius: 12px;
      color: #ef4444;
      font-size: 32px;
      cursor: pointer;
      transition: all 0.1s;
      -webkit-tap-highlight-color: transparent;
    }

    .touch-btn:active {
      background: rgba(239, 68, 68, 0.4);
      box-shadow: 0 0 30px rgba(239, 68, 68, 0.5);
      transform: scale(0.95);
    }

    /* Sidebar */
    .sidebar {
      width: 280px;
      background: rgba(0, 0, 0, 0.5);
      border-left: 1px solid rgba(0, 255, 255, 0.1);
      padding: 24px;
      display: flex;
      flex-direction: column;
      gap: 24px;
      z-index: 1;
    }

    @media (max-width: 900px) {
      .sidebar { display: none; }
    }

    .section-title {
      font-size: 11px;
      letter-spacing: 2px;
      color: rgba(0, 255, 255, 0.5);
      text-transform: uppercase;
      margin-bottom: 12px;
    }

    .leaderboard {
      background: rgba(0, 0, 0, 0.3);
      border: 1px solid rgba(0, 255, 255, 0.1);
      border-radius: 8px;
      overflow: hidden;
    }

    .lb-row {
      display: grid;
      grid-template-columns: 32px 1fr 50px;
      padding: 10px 12px;
      border-bottom: 1px solid rgba(0, 255, 255, 0.05);
      font-size: 12px;
    }

    .lb-row:last-child { border-bottom: none; }
    .lb-row.header { background: rgba(0, 255, 255, 0.05); color: rgba(255,255,255,0.4); }

    .lb-rank { color: #0ff; font-weight: 700; }
    .lb-rank.gold { color: #ffd700; text-shadow: 0 0 10px #ffd700; }
    .lb-rank.silver { color: #c0c0c0; }
    .lb-rank.bronze { color: #cd7f32; }

    .lb-score { text-align: right; color: #0ff; font-weight: 700; }

    .backlink {
      margin-top: auto;
      text-align: center;
      font-size: 11px;
    }

    .backlink a {
      color: rgba(0, 255, 255, 0.5);
      text-decoration: none;
      transition: color 0.2s;
    }

    .backlink a:hover { color: #0ff; }
  </style>
</head>
<body>
  <div class="game-wrap">
    <div class="bg-layer"></div>

    <div class="canvas-container">
      <canvas id="game"></canvas>

      <div class="hud">
        <div class="stat">
          <div class="stat-label">Floor</div>
          <div class="stat-value" id="floor">0</div>
        </div>
        <div class="stat">
          <div class="stat-label">Best</div>
          <div class="stat-value" id="best">0</div>
        </div>
        <div class="stat">
          <div class="stat-label">Combo</div>
          <div class="stat-value combo" id="combo">x1</div>
        </div>
        <div class="hud-right">
          <button class="btn" id="pauseBtn">Pause</button>
          <button class="btn" id="muteBtn">Sound On</button>
        </div>
      </div>

      <div class="power-chips" id="powerChips"></div>
      <div class="toast" id="toast"></div>

      <!-- Start -->
      <div class="overlay show" id="startOverlay">
        <div class="modal">
          <div class="modal-icon">üßä</div>
          <h1>ICY TOWER</h1>
          <p>Climb the frozen tower before it crumbles beneath you.</p>
          <div class="modal-controls">
            <kbd>A</kbd> <kbd>D</kbd> Move ¬∑ <kbd>Space</kbd> Jump ¬∑ <kbd>P</kbd> Pause
          </div>
          <div class="modal-buttons">
            <button class="btn btn-primary" id="playBtn">ENTER THE TOWER</button>
          </div>
        </div>
      </div>

      <!-- Game Over -->
      <div class="overlay" id="gameOverOverlay">
        <div class="modal">
          <div class="modal-icon">‚ùÑÔ∏è</div>
          <h1>FROZEN</h1>
          <p>You reached floor</p>
          <div class="score-display" id="finalFloor">0</div>
          <div class="input-wrap" id="saveBlock">
            <label>Enter your name</label>
            <input class="neon-input" id="playerName" maxlength="20" placeholder="PLAYER">
            <div id="saveError" class="error-text" style="display:none"></div>
            <div class="modal-buttons">
              <button class="btn btn-primary" id="saveScoreBtn">Save Score</button>
              <button class="btn" id="skipSaveBtn">Skip</button>
            </div>
          </div>
          <div class="modal-buttons">
            <button class="btn btn-primary" id="playAgainBtn">Try Again</button>
            <button class="btn" id="shareBtn">Share</button>
          </div>
        </div>
      </div>

      <!-- Touch -->
      <div class="touch-controls">
        <button class="touch-btn" id="leftPad">‚óÄ</button>
        <button class="touch-btn" id="jumpPad">‚ñ≤</button>
        <button class="touch-btn" id="rightPad">‚ñ∂</button>
      </div>
    </div>

    <div class="sidebar">
      <div>
        <div class="section-title">Leaderboard</div>
        <div class="leaderboard" id="leaderboard">
          <div class="lb-row header">
            <span>#</span><span>Player</span><span>Floor</span>
          </div>
          <div class="lb-row">
            <span></span><span style="opacity:0.4">Loading...</span><span></span>
          </div>
        </div>
        <button class="btn" style="width:100%;margin-top:12px" id="refreshBtn">Refresh</button>
      </div>

      <div class="backlink">
        <a href="https://sloppy.live">sloppy.live</a> ¬∑ <a href="/overview">All Apps</a>
      </div>
    </div>
  </div>

  <script type="module">
    import supabase, { supabaseSession } from './supabase-config.js';

    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');
    let W = 0, H = 0, dpr = Math.min(2, window.devicePixelRatio || 1);

    function resize() {
      W = canvas.clientWidth;
      H = canvas.clientHeight;
      canvas.width = W * dpr;
      canvas.height = H * dpr;
      ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
    }
    window.addEventListener('resize', resize);
    resize();

    // Game state
    const game = {
      running: false,
      paused: false,
      muted: false,
      floor: 0,
      lastFloor: 0,
      best: parseInt(localStorage.getItem('icy-best') || '0'),
      combo: 1,
      comboTimer: 0,
      cameraY: 0,
      cameraTargetY: 0,
      lastTime: 0,
      particles: [],
      snowflakes: [],
      platforms: [],
      powerups: [],
      effects: { double: 0, slow: 0, boost: 0 },
    };

    const player = {
      x: 0, y: 0, vx: 0, vy: 0,
      width: 28, height: 38,
      grounded: false, jumpsLeft: 1,
      facingRight: true,
      trail: [],
      glowIntensity: 0,
    };

    const PHYSICS = {
      gravity: 0.52,
      jumpForce: -14,
      moveAccel: 1.1,
      moveDecel: 0.88,
      maxSpeed: 7,
      airControl: 0.7,
      cameraSmooth: 0.08,
    };

    // Audio
    let audioCtx;
    function playSound(freq, dur = 0.1, type = 'sine', vol = 0.12) {
      if (game.muted) return;
      if (!audioCtx) {
        try { audioCtx = new (window.AudioContext || window.webkitAudioContext)(); } catch(e) { return; }
      }
      if (audioCtx.state === 'suspended') audioCtx.resume();
      const osc = audioCtx.createOscillator();
      const gain = audioCtx.createGain();
      osc.type = type;
      osc.frequency.value = freq;
      osc.connect(gain);
      gain.connect(audioCtx.destination);
      gain.gain.setValueAtTime(vol, audioCtx.currentTime);
      gain.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + dur);
      osc.start();
      osc.stop(audioCtx.currentTime + dur);
    }

    // Initialize snowflakes
    function initSnowflakes() {
      game.snowflakes = [];
      for (let i = 0; i < 50; i++) {
        game.snowflakes.push({
          x: Math.random() * W,
          y: Math.random() * H,
          size: 1 + Math.random() * 3,
          speed: 0.3 + Math.random() * 0.5,
          drift: (Math.random() - 0.5) * 0.5,
        });
      }
    }

    // Particles
    function spawnParticle(x, y, vx, vy, color, life = 0.8, size = 4, glow = true) {
      game.particles.push({ x, y, vx, vy, color, life, maxLife: life, size, glow });
    }

    function spawnJumpBurst(x, y) {
      for (let i = 0; i < 12; i++) {
        const angle = (i / 12) * Math.PI * 2;
        const speed = 3 + Math.random() * 4;
        spawnParticle(x, y, Math.cos(angle) * speed, Math.sin(angle) * speed - 2, '#0ff', 0.6, 3 + Math.random() * 3);
      }
    }

    function spawnLandingParticles(x, y) {
      for (let i = 0; i < 8; i++) {
        const angle = Math.PI + (Math.random() - 0.5) * 1.5;
        const speed = 2 + Math.random() * 3;
        spawnParticle(x + (Math.random() - 0.5) * 30, y, Math.cos(angle) * speed, Math.sin(angle) * speed, 'rgba(0, 255, 255, 0.8)', 0.4, 2 + Math.random() * 2);
      }
    }

    function spawnPowerupBurst(x, y, color) {
      for (let i = 0; i < 16; i++) {
        const angle = (i / 16) * Math.PI * 2;
        const speed = 4 + Math.random() * 3;
        spawnParticle(x, y, Math.cos(angle) * speed, Math.sin(angle) * speed, color, 0.8, 4);
      }
    }

    // Platforms - progressive difficulty
    function getDifficulty(y) {
      // Calculate difficulty based on height (more negative y = higher = harder)
      // Start easy, get harder as player climbs
      const height = Math.max(0, H * 0.6 - y); // Distance climbed from start
      const difficulty = Math.min(1, height / 8000); // Max difficulty at ~8000 pixels up
      return difficulty;
    }

    function createPlatform(y) {
      const difficulty = getDifficulty(y);

      // Platform width: starts wide (15-30% of screen), shrinks to (8-15% of screen)
      const minWStart = W * 0.15, maxWStart = W * 0.30;
      const minWEnd = W * 0.08, maxWEnd = W * 0.15;
      const minW = Math.max(50, minWStart - (minWStart - minWEnd) * difficulty);
      const maxW = Math.max(70, maxWStart - (maxWStart - maxWEnd) * difficulty);

      const w = minW + Math.random() * (maxW - minW);
      const x = Math.random() * (W - w);
      const type = Math.random() < 0.12 ? 'special' : 'normal';
      const hue = 180 + Math.random() * 40; // Cyan-blue range
      return { x, y, w, h: 12, type, hue, glow: 0 };
    }

    function getPlatformGap(y) {
      const difficulty = getDifficulty(y);
      // Gap starts at 50-90, increases to 70-130 at max difficulty
      const baseGap = 50 + difficulty * 20;
      const gapVariance = 40 + difficulty * 20;
      return baseGap + Math.random() * gapVariance;
    }

    function resetWorld() {
      game.floor = 0;
      game.combo = 1;
      game.comboTimer = 0;
      game.cameraY = 0;
      game.cameraTargetY = 0;
      game.particles = [];
      game.platforms = [];
      game.powerups = [];
      game.effects = { double: 0, slow: 0, boost: 0 };

      player.x = W / 2 - player.width / 2;
      player.y = H * 0.6;
      player.vx = 0;
      player.vy = 0;
      player.grounded = false;
      player.jumpsLeft = 1;
      player.trail = [];
      player.glowIntensity = 0;

      game.platforms.push({ x: 0, y: H * 0.75, w: W, h: 16, type: 'ground', hue: 200, glow: 0 });

      let y = H * 0.6;
      for (let i = 0; i < 40; i++) {
        y -= getPlatformGap(y);
        const plat = createPlatform(y);
        game.platforms.push(plat);
        if (Math.random() < 0.1 && y < H - 100) {
          const types = ['double', 'slow', 'boost'];
          game.powerups.push({
            x: plat.x + plat.w / 2,
            y: plat.y - 15,
            type: types[Math.floor(Math.random() * 3)],
            bob: Math.random() * Math.PI * 2,
            pulse: 0,
          });
        }
      }

      initSnowflakes();
      updateUI();
    }

    // Input
    const input = { left: false, right: false, jump: false, jumpPressed: false };

    window.addEventListener('keydown', (e) => {
      if (e.repeat) return;
      if (e.code === 'ArrowLeft' || e.code === 'KeyA') input.left = true;
      if (e.code === 'ArrowRight' || e.code === 'KeyD') input.right = true;
      if (e.code === 'Space' || e.code === 'ArrowUp' || e.code === 'KeyW') {
        input.jump = true;
        input.jumpPressed = true;
        if (!game.running) startGame();
      }
      if (e.code === 'KeyP') togglePause();
    });

    window.addEventListener('keyup', (e) => {
      if (e.code === 'ArrowLeft' || e.code === 'KeyA') input.left = false;
      if (e.code === 'ArrowRight' || e.code === 'KeyD') input.right = false;
      if (e.code === 'Space' || e.code === 'ArrowUp' || e.code === 'KeyW') input.jump = false;
    });

    // Touch
    function bindTouch(el, onStart, onEnd) {
      const start = (e) => { e.preventDefault(); onStart(); };
      const end = (e) => { e.preventDefault(); onEnd(); };
      el.addEventListener('touchstart', start, { passive: false });
      el.addEventListener('touchend', end, { passive: false });
      el.addEventListener('mousedown', start);
      el.addEventListener('mouseup', end);
      el.addEventListener('mouseleave', end);
    }
    bindTouch(document.getElementById('leftPad'), () => input.left = true, () => input.left = false);
    bindTouch(document.getElementById('rightPad'), () => input.right = true, () => input.right = false);
    bindTouch(document.getElementById('jumpPad'), () => {
      input.jump = true;
      input.jumpPressed = true;
      if (!game.running) startGame();
    }, () => input.jump = false);

    // Update
    function update(dt) {
      const dtNorm = dt / 16.67;

      // Combo decay
      if (game.comboTimer > 0) {
        game.comboTimer -= dt;
        if (game.comboTimer <= 0) {
          game.combo = Math.max(1, game.combo - 1);
          game.comboTimer = game.combo > 1 ? 2000 : 0;
        }
      }

      // Effects decay
      for (const key of Object.keys(game.effects)) {
        game.effects[key] = Math.max(0, game.effects[key] - dt);
      }
      renderPowerChips();

      // Player movement
      const accel = PHYSICS.moveAccel * (player.grounded ? 1 : PHYSICS.airControl);
      if (input.left) { player.vx -= accel * dtNorm; player.facingRight = false; }
      else if (input.right) { player.vx += accel * dtNorm; player.facingRight = true; }
      else { player.vx *= Math.pow(PHYSICS.moveDecel, dtNorm); }

      const maxSpd = PHYSICS.maxSpeed * (game.effects.boost > 0 ? 1.25 : 1);
      player.vx = Math.max(-maxSpd, Math.min(maxSpd, player.vx));

      // Jump
      if (input.jumpPressed) {
        const jumpMod = game.effects.boost > 0 ? 1.25 : 1;
        if (player.grounded) {
          player.vy = PHYSICS.jumpForce * jumpMod;
          player.grounded = false;
          player.jumpsLeft = game.effects.double > 0 ? 1 : 0;
          player.glowIntensity = 1;
          playSound(440, 0.12, 'sine');
          playSound(660, 0.08, 'triangle');
          spawnJumpBurst(player.x + player.width / 2, player.y + player.height);
        } else if (game.effects.double > 0 && player.jumpsLeft > 0) {
          player.vy = PHYSICS.jumpForce * jumpMod * 0.9;
          player.jumpsLeft--;
          player.glowIntensity = 1;
          playSound(550, 0.1, 'sine');
          spawnJumpBurst(player.x + player.width / 2, player.y + player.height / 2);
        }
        input.jumpPressed = false;
      }

      // Gravity
      const gravMod = game.effects.slow > 0 ? 0.65 : 1;
      player.vy += PHYSICS.gravity * gravMod * dtNorm;
      player.x += player.vx * dtNorm;
      player.y += player.vy * dtNorm;

      // Wrap
      if (player.x < -player.width) player.x = W;
      if (player.x > W) player.x = -player.width;

      // Trail
      if (Math.abs(player.vy) > 3 || Math.abs(player.vx) > 4) {
        player.trail.push({
          x: player.x + player.width / 2,
          y: player.y + player.height / 2,
          alpha: 0.6,
          size: player.width * 0.4,
        });
        if (player.trail.length > 12) player.trail.shift();
      }
      for (const t of player.trail) t.alpha *= 0.9;
      player.trail = player.trail.filter(t => t.alpha > 0.05);

      // Glow decay
      player.glowIntensity *= 0.95;

      // Platform collision
      let landed = false;
      for (const plat of game.platforms) {
        if (player.vy >= 0 &&
            player.x + player.width > plat.x && player.x < plat.x + plat.w &&
            player.y + player.height >= plat.y && player.y + player.height <= plat.y + plat.h + player.vy * dtNorm + 5) {
          player.y = plat.y - player.height;
          player.vy = 0;
          player.grounded = true;
          player.jumpsLeft = game.effects.double > 0 ? 2 : 1;
          landed = true;
          plat.glow = 1;

          const screenY = plat.y - game.cameraY;
          if (screenY < H * 0.55 && plat.type !== 'ground') {
            game.floor++;
            game.combo = Math.min(10, game.combo + 1);
            game.comboTimer = 2500;
            playSound(300 + game.combo * 50, 0.06, 'sine');
            spawnLandingParticles(player.x + player.width / 2, player.y + player.height);
            checkAchievements();
          }
          break;
        }
      }
      if (!landed && player.grounded) player.grounded = false;

      // Platform glow decay
      for (const plat of game.platforms) {
        plat.glow *= 0.92;
      }

      // Powerup collection
      for (let i = game.powerups.length - 1; i >= 0; i--) {
        const pu = game.powerups[i];
        const dx = (player.x + player.width / 2) - pu.x;
        const dy = (player.y + player.height / 2) - pu.y;
        if (Math.sqrt(dx * dx + dy * dy) < 28) {
          applyPowerup(pu.type, pu.x, pu.y);
          game.powerups.splice(i, 1);
        }
      }

      // Camera
      game.cameraTargetY = Math.min(game.cameraTargetY, player.y - H * 0.45);
      game.cameraY += (game.cameraTargetY - game.cameraY) * PHYSICS.cameraSmooth * dtNorm;

      // Recycle
      const cutoff = game.cameraY + H + 100;
      game.platforms = game.platforms.filter(p => p.y < cutoff);
      game.powerups = game.powerups.filter(p => p.y < cutoff);

      while (game.platforms.length < 45) {
        const topY = Math.min(...game.platforms.map(p => p.y));
        const newY = topY - getPlatformGap(topY);
        const plat = createPlatform(newY);
        game.platforms.push(plat);
        if (Math.random() < 0.1) {
          const types = ['double', 'slow', 'boost'];
          game.powerups.push({
            x: plat.x + plat.w / 2,
            y: plat.y - 15,
            type: types[Math.floor(Math.random() * 3)],
            bob: Math.random() * Math.PI * 2,
            pulse: 0,
          });
        }
      }

      // Death
      if (player.y - game.cameraY > H + 50) endGame();

      // Update particles
      for (let i = game.particles.length - 1; i >= 0; i--) {
        const p = game.particles[i];
        p.x += p.vx * dtNorm;
        p.y += p.vy * dtNorm;
        p.vy += 0.15 * dtNorm;
        p.life -= dt / 1000;
        if (p.life <= 0) game.particles.splice(i, 1);
      }

      // Update snowflakes
      for (const s of game.snowflakes) {
        s.y += s.speed * dtNorm;
        s.x += s.drift * dtNorm;
        if (s.y > H) { s.y = 0; s.x = Math.random() * W; }
        if (s.x < 0) s.x = W;
        if (s.x > W) s.x = 0;
      }
    }

    function applyPowerup(type, x, y) {
      game.effects[type] = 8000;
      const colors = { double: '#0f0', slow: '#ff0', boost: '#f0f' };
      const msgs = { double: 'DOUBLE JUMP', slow: 'TIME WARP', boost: 'HYPER BOOST' };
      playSound(523, 0.1, 'sine');
      playSound(784, 0.15, 'sine');
      spawnPowerupBurst(x, y - game.cameraY, colors[type]);
      showToast(msgs[type]);
      unlock('firstPower');
    }

    // Draw
    function draw() {
      // Christmas night sky
      ctx.fillStyle = '#0a1929';
      ctx.fillRect(0, 0, W, H);

      // Background gradient with festive colors
      const bgGrad = ctx.createLinearGradient(0, 0, 0, H);
      bgGrad.addColorStop(0, 'rgba(20, 60, 40, 0.4)');
      bgGrad.addColorStop(0.5, 'rgba(40, 20, 30, 0.3)');
      bgGrad.addColorStop(1, 'rgba(20, 60, 40, 0.4)');
      ctx.fillStyle = bgGrad;
      ctx.fillRect(0, 0, W, H);

      // Snowflakes
      ctx.fillStyle = 'rgba(255, 255, 255, 0.6)';
      for (const s of game.snowflakes) {
        ctx.beginPath();
        ctx.arc(s.x, s.y, s.size, 0, Math.PI * 2);
        ctx.fill();
      }

      const cam = game.cameraY;

      // Christmas platforms with snow
      for (const plat of game.platforms) {
        const py = plat.y - cam;
        if (py < -30 || py > H + 30) continue;

        const glowAmount = 6 + plat.glow * 15;

        // Glow - alternating red and green
        const isRed = plat.hue % 2 === 0;
        ctx.shadowColor = plat.type === 'special' ? '#ffd700' : (isRed ? '#ff4444' : '#44ff44');
        ctx.shadowBlur = glowAmount;

        // Platform body - wood/brick style
        const grad = ctx.createLinearGradient(plat.x, py, plat.x, py + plat.h);
        if (plat.type === 'special') {
          grad.addColorStop(0, '#ffd700');
          grad.addColorStop(1, '#b8860b');
        } else if (plat.type === 'ground') {
          grad.addColorStop(0, '#8b4513');
          grad.addColorStop(1, '#654321');
        } else {
          if (isRed) {
            grad.addColorStop(0, '#dc2626');
            grad.addColorStop(1, '#991b1b');
          } else {
            grad.addColorStop(0, '#16a34a');
            grad.addColorStop(1, '#166534');
          }
        }

        ctx.fillStyle = grad;
        ctx.beginPath();
        ctx.roundRect(plat.x, py, plat.w, plat.h, 3);
        ctx.fill();

        // Snow on top of platform
        ctx.shadowBlur = 0;
        ctx.fillStyle = '#fff';
        ctx.beginPath();
        ctx.ellipse(plat.x + plat.w / 2, py, plat.w / 2 + 4, 5, 0, Math.PI, 0);
        ctx.fill();

        // Snow bumps
        for (let i = 0; i < 3; i++) {
          const bx = plat.x + (plat.w / 4) * (i + 0.5);
          ctx.beginPath();
          ctx.arc(bx, py - 2, 4 + Math.random() * 2, 0, Math.PI * 2);
          ctx.fill();
        }
      }

      // Powerups as Christmas ornaments/gifts
      for (const pu of game.powerups) {
        const py = pu.y - cam;
        if (py < -30 || py > H + 30) continue;

        pu.bob += 0.06;
        pu.pulse += 0.1;
        const bobY = py + Math.sin(pu.bob) * 5;
        const pulseScale = 1 + Math.sin(pu.pulse) * 0.1;

        let color1, color2, icon;
        if (pu.type === 'double') { color1 = '#22c55e'; color2 = '#166534'; icon = 'üéÅ'; }
        else if (pu.type === 'slow') { color1 = '#fbbf24'; color2 = '#b45309'; icon = '‚≠ê'; }
        else { color1 = '#ef4444'; color2 = '#991b1b'; icon = 'üéÑ'; }

        ctx.shadowColor = color1;
        ctx.shadowBlur = 15 + Math.sin(pu.pulse) * 5;

        const puGrad = ctx.createRadialGradient(pu.x, bobY, 0, pu.x, bobY, 14 * pulseScale);
        puGrad.addColorStop(0, color1);
        puGrad.addColorStop(1, color2);
        ctx.fillStyle = puGrad;
        ctx.beginPath();
        ctx.arc(pu.x, bobY, 12 * pulseScale, 0, Math.PI * 2);
        ctx.fill();

        ctx.shadowBlur = 0;
        ctx.font = '14px serif';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText(icon, pu.x, bobY);
      }

      // Particles - festive red/green/white
      for (const p of game.particles) {
        const alpha = p.life / p.maxLife;
        if (p.glow) {
          ctx.shadowColor = p.color;
          ctx.shadowBlur = 10;
        }
        ctx.globalAlpha = alpha;
        ctx.fillStyle = p.color;
        ctx.beginPath();
        ctx.arc(p.x, p.y - cam, p.size * alpha, 0, Math.PI * 2);
        ctx.fill();
        ctx.shadowBlur = 0;
      }
      ctx.globalAlpha = 1;

      // Player trail - red/green alternating
      for (let i = 0; i < player.trail.length; i++) {
        const t = player.trail[i];
        ctx.globalAlpha = t.alpha * 0.5;
        ctx.shadowColor = i % 2 === 0 ? '#ff4444' : '#44ff44';
        ctx.shadowBlur = 15;
        ctx.fillStyle = i % 2 === 0 ? '#ff4444' : '#44ff44';
        ctx.beginPath();
        ctx.arc(t.x, t.y - cam, t.size, 0, Math.PI * 2);
        ctx.fill();
      }
      ctx.globalAlpha = 1;
      ctx.shadowBlur = 0;

      // Player (Santa's helper!)
      const px = player.x;
      const py = player.y - cam;

      ctx.save();
      ctx.translate(px + player.width / 2, py + player.height / 2);
      const tilt = Math.max(-0.15, Math.min(0.15, player.vx * 0.025));
      ctx.rotate(tilt);

      // Glow
      const glowSize = 15 + player.glowIntensity * 25;
      ctx.shadowColor = '#ff4444';
      ctx.shadowBlur = glowSize;

      // Body - red Christmas outfit
      const bodyGrad = ctx.createLinearGradient(-14, -19, 14, 19);
      bodyGrad.addColorStop(0, '#ef4444');
      bodyGrad.addColorStop(0.5, '#dc2626');
      bodyGrad.addColorStop(1, '#b91c1c');
      ctx.fillStyle = bodyGrad;
      ctx.beginPath();
      ctx.roundRect(-player.width / 2, -player.height / 2, player.width, player.height, 6);
      ctx.fill();

      ctx.shadowBlur = 0;

      // White fur trim on outfit
      ctx.fillStyle = '#fff';
      ctx.fillRect(-player.width / 2, -player.height / 2 + player.height - 10, player.width, 6);
      ctx.fillRect(-player.width / 2, player.height / 2 - 20, player.width, 4);

      // Belt
      ctx.fillStyle = '#000';
      ctx.fillRect(-player.width / 2, 2, player.width, 5);
      ctx.fillStyle = '#ffd700';
      ctx.fillRect(-4, 1, 8, 7);

      // Face area
      ctx.fillStyle = '#fcd9b6';
      ctx.beginPath();
      ctx.roundRect(-player.width / 2 + 3, -player.height / 2 + 6, player.width - 6, 12, 3);
      ctx.fill();

      // Eyes
      ctx.fillStyle = '#000';
      const eyeOff = player.facingRight ? 2 : -2;
      ctx.fillRect(-5 + eyeOff, -player.height / 2 + 9, 3, 4);
      ctx.fillRect(3 + eyeOff, -player.height / 2 + 9, 3, 4);

      // Rosy cheeks
      ctx.fillStyle = 'rgba(255, 150, 150, 0.5)';
      ctx.beginPath();
      ctx.arc(-8, -player.height / 2 + 14, 3, 0, Math.PI * 2);
      ctx.arc(8, -player.height / 2 + 14, 3, 0, Math.PI * 2);
      ctx.fill();

      // Santa Hat
      ctx.fillStyle = '#dc2626';
      ctx.beginPath();
      ctx.moveTo(-player.width / 2 - 2, -player.height / 2 + 4);
      ctx.lineTo(player.width / 2 + 2, -player.height / 2 + 4);
      ctx.lineTo(player.width / 2 + 8, -player.height / 2 - 20);
      ctx.lineTo(-player.width / 2 + 5, -player.height / 2 - 8);
      ctx.closePath();
      ctx.fill();

      // Hat fur trim
      ctx.fillStyle = '#fff';
      ctx.fillRect(-player.width / 2 - 3, -player.height / 2 + 2, player.width + 6, 5);

      // Hat pompom
      ctx.beginPath();
      ctx.arc(player.width / 2 + 10, -player.height / 2 - 22, 6, 0, Math.PI * 2);
      ctx.fill();

      // Boots
      ctx.fillStyle = '#1a1a1a';
      ctx.fillRect(-player.width / 2 + 2, player.height / 2 - 8, 8, 8);
      ctx.fillRect(player.width / 2 - 10, player.height / 2 - 8, 8, 8);

      ctx.restore();

      // HUD
      document.getElementById('floor').textContent = game.floor;
      document.getElementById('best').textContent = game.best;
      document.getElementById('combo').textContent = 'x' + game.combo;
    }

    // Loop
    function gameLoop(ts) {
      const dt = Math.min(32, ts - game.lastTime || 16);
      game.lastTime = ts;
      if (game.running && !game.paused) update(dt);
      draw();
      requestAnimationFrame(gameLoop);
    }
    requestAnimationFrame(gameLoop);

    // UI
    const startOverlay = document.getElementById('startOverlay');
    const gameOverOverlay = document.getElementById('gameOverOverlay');

    document.getElementById('playBtn').onclick = startGame;
    document.getElementById('playAgainBtn').onclick = () => { gameOverOverlay.classList.remove('show'); startGame(); };
    document.getElementById('pauseBtn').onclick = togglePause;

    const muteBtn = document.getElementById('muteBtn');
    muteBtn.onclick = () => { game.muted = !game.muted; muteBtn.textContent = game.muted ? 'Sound Off' : 'Sound On'; };

    document.getElementById('shareBtn').onclick = () => {
      const text = encodeURIComponent(`I reached floor ${game.lastFloor} in Icy Tower! üßä‚ùÑÔ∏è`);
      const url = encodeURIComponent('https://sloppy.live/icy-tower');
      window.open(`https://twitter.com/intent/tweet?text=${text}&url=${url}`, '_blank');
    };

    function startGame() {
      if (game.running) return;
      startOverlay.classList.remove('show');
      gameOverOverlay.classList.remove('show');
      resetWorld();
      game.running = true;
      game.paused = false;
    }

    function togglePause() {
      if (!game.running) return;
      game.paused = !game.paused;
      document.getElementById('pauseBtn').textContent = game.paused ? 'Resume' : 'Pause';
    }

    function endGame() {
      game.running = false;
      game.lastFloor = game.floor;
      game.best = Math.max(game.best, game.floor);
      localStorage.setItem('icy-best', game.best);
      document.getElementById('finalFloor').textContent = game.floor;
      gameOverOverlay.classList.add('show');
      document.getElementById('saveBlock').style.display = 'block';
      if (game.floor >= game.best && game.floor > 0) unlock('newPB');
    }

    function updateUI() {
      document.getElementById('floor').textContent = game.floor;
      document.getElementById('best').textContent = game.best;
      document.getElementById('combo').textContent = 'x' + game.combo;
    }

    // Power chips
    const chipsEl = document.getElementById('powerChips');
    function renderPowerChips() {
      const chips = [];
      if (game.effects.double > 0) chips.push({ type: 'double', label: 'DOUBLE JUMP', time: Math.ceil(game.effects.double / 1000) });
      if (game.effects.slow > 0) chips.push({ type: 'slow', label: 'TIME WARP', time: Math.ceil(game.effects.slow / 1000) });
      if (game.effects.boost > 0) chips.push({ type: 'boost', label: 'HYPER BOOST', time: Math.ceil(game.effects.boost / 1000) });
      chipsEl.innerHTML = chips.map(c => `<div class="power-chip ${c.type}">${c.label} ¬∑ ${c.time}s</div>`).join('');
    }

    // Toast
    const toastEl = document.getElementById('toast');
    let toastTimer = null;
    function showToast(msg) {
      clearTimeout(toastTimer);
      toastEl.textContent = msg;
      toastEl.classList.add('show');
      toastTimer = setTimeout(() => toastEl.classList.remove('show'), 1500);
    }

    // Achievements
    const ACHIEVEMENTS = [
      { key: 'floor20', name: 'First Steps', check: () => game.floor >= 20 },
      { key: 'floor50', name: 'Climber', check: () => game.floor >= 50 },
      { key: 'floor100', name: 'Ice Master', check: () => game.floor >= 100 },
      { key: 'combo7', name: 'Combo x7', check: () => game.combo >= 7 },
      { key: 'combo10', name: 'Combo x10', check: () => game.combo >= 10 },
      { key: 'firstPower', name: 'Powered', check: () => false },
      { key: 'savedScore', name: 'Ranked', check: () => false },
      { key: 'newPB', name: 'New Record', check: () => false },
    ];
    let unlocked = {};
    try { unlocked = JSON.parse(localStorage.getItem('icy-achievements') || '{}'); } catch {}
    function saveAch() { localStorage.setItem('icy-achievements', JSON.stringify(unlocked)); }
    function unlock(key) {
      if (unlocked[key]) return;
      unlocked[key] = true;
      saveAch();
      const a = ACHIEVEMENTS.find(x => x.key === key);
      if (a) showToast('üèÜ ' + a.name);
    }
    function checkAchievements() { for (const a of ACHIEVEMENTS) if (!unlocked[a.key] && a.check()) unlock(a.key); }

    // Leaderboard
    let currentUser = null;
    const leaderboardEl = document.getElementById('leaderboard');

    async function initAuth() {
      try { const { user } = await supabaseSession(); currentUser = user; } catch (e) {}
      loadLeaderboard();
    }

    async function loadLeaderboard() {
      try {
        const { data, error } = await supabase.from('icy_tower_scores').select('score, display_name').order('score', { ascending: false }).limit(8);
        if (error) throw error;
        const header = '<div class="lb-row header"><span>#</span><span>Player</span><span>Floor</span></div>';
        if (!data || data.length === 0) {
          leaderboardEl.innerHTML = header + '<div class="lb-row"><span></span><span style="opacity:0.4">No scores yet</span><span></span></div>';
          return;
        }
        leaderboardEl.innerHTML = header + data.map((r, i) => {
          const rankClass = i === 0 ? 'gold' : i === 1 ? 'silver' : i === 2 ? 'bronze' : '';
          return `<div class="lb-row"><span class="lb-rank ${rankClass}">${i + 1}</span><span>${escapeHtml(r.display_name || 'Anon')}</span><span class="lb-score">${r.score}</span></div>`;
        }).join('');
      } catch (e) {}
    }

    document.getElementById('refreshBtn').onclick = loadLeaderboard;

    const saveScoreBtn = document.getElementById('saveScoreBtn');
    const skipSaveBtn = document.getElementById('skipSaveBtn');
    const saveError = document.getElementById('saveError');
    const playerNameInput = document.getElementById('playerName');
    const saveBlock = document.getElementById('saveBlock');

    skipSaveBtn.onclick = () => saveBlock.style.display = 'none';
    saveScoreBtn.onclick = async () => {
      saveError.style.display = 'none';
      try {
        const name = (playerNameInput.value || 'Player').slice(0, 20);
        const { error } = await supabase.from('icy_tower_scores').insert([{ score: game.lastFloor, display_name: name, user_id: currentUser?.id }]);
        if (error) throw error;
        saveBlock.style.display = 'none';
        unlock('savedScore');
        loadLeaderboard();
      } catch (e) {
        saveError.textContent = 'Error: ' + e.message;
        saveError.style.display = 'block';
      }
    };

    function escapeHtml(s) { const d = document.createElement('div'); d.textContent = s; return d.innerHTML; }

    resetWorld();
    draw();
    initAuth();
  </script>
</body>
</html>
