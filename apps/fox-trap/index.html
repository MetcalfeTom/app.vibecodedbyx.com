<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
  <title>Neon Fox Trap</title>
  <link rel="icon" href="https://emojicdn.elk.sh/ü¶ä">
  <meta name="description" content="Catch glowing digital pests with your neon fox traps">
  <meta property="og:title" content="Neon Fox Trap">
  <meta property="og:description" content="Catch glowing digital pests with your neon fox traps">
  <meta property="og:image" content="https://emojicdn.elk.sh/ü¶ä?style=google">
  <meta property="og:url" content="https://app.sloppy.live/fox-trap">
  <style>
    @import url('https://fonts.googleapis.com/css2?family=Russo+One&display=swap');
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      background: #0a0a12;
      min-height: 100vh;
      display: flex;
      flex-direction: column;
      align-items: center;
      font-family: 'Russo One', sans-serif;
      overflow: hidden;
      cursor: crosshair;
    }
    #gameCanvas {
      position: fixed;
      top: 0; left: 0;
      width: 100vw;
      height: 100vh;
    }
    .ui {
      position: fixed;
      top: 20px;
      display: flex;
      gap: 30px;
      z-index: 100;
      pointer-events: none;
    }
    .stat {
      color: #ff6622;
      font-size: 1.2rem;
      text-shadow: 0 0 10px #ff6622, 0 0 20px #ff4400;
    }
    .stat span { color: #ffaa00; }
    h1 {
      position: fixed;
      bottom: 20px;
      color: #ff8844;
      font-size: 1.5rem;
      text-shadow: 0 0 15px #ff6622, 0 0 30px #ff4400;
      letter-spacing: 3px;
      z-index: 100;
      pointer-events: none;
    }
    .back-link {
      position: fixed;
      top: 20px; left: 20px;
      color: #ff6622;
      text-decoration: none;
      font-size: 0.8rem;
      opacity: 0.7;
      z-index: 101;
    }
    .combo {
      position: fixed;
      font-size: 2rem;
      color: #ffcc00;
      text-shadow: 0 0 20px #ffaa00;
      pointer-events: none;
      z-index: 100;
      animation: comboFade 0.8s ease-out forwards;
    }
    @keyframes comboFade {
      0% { transform: scale(0.5); opacity: 1; }
      50% { transform: scale(1.2); }
      100% { transform: scale(1); opacity: 0; transform: translateY(-30px); }
    }
  </style>
</head>
<body>
  <a href="https://sloppy.live" class="back-link">‚Üê sloppy.live</a>
  <div class="ui">
    <div class="stat">CAUGHT: <span id="score">0</span></div>
    <div class="stat">ESCAPED: <span id="escaped">0</span></div>
    <div class="stat">COMBO: <span id="combo">x1</span></div>
  </div>
  <canvas id="gameCanvas"></canvas>
  <h1>ü¶ä NEON FOX TRAP ü¶ä</h1>

  <script>
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    
    let width, height;
    function resize() {
      width = canvas.width = window.innerWidth;
      height = canvas.height = window.innerHeight;
    }
    resize();
    window.addEventListener('resize', resize);

    const scoreEl = document.getElementById('score');
    const escapedEl = document.getElementById('escaped');
    const comboEl = document.getElementById('combo');

    let score = 0;
    let escaped = 0;
    let combo = 1;
    let comboTimer = 0;
    const pests = [];
    const traps = [];
    const particles = [];
    const foxX = width / 2;
    const foxY = height / 2;

    // Audio context
    let audioCtx;
    function initAudio() {
      if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    }

    function playTrapSound() {
      if (!audioCtx) return;
      const osc = audioCtx.createOscillator();
      const gain = audioCtx.createGain();
      osc.connect(gain);
      gain.connect(audioCtx.destination);
      osc.frequency.setValueAtTime(800, audioCtx.currentTime);
      osc.frequency.exponentialRampToValueAtTime(200, audioCtx.currentTime + 0.15);
      gain.gain.setValueAtTime(0.3, audioCtx.currentTime);
      gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.15);
      osc.start();
      osc.stop(audioCtx.currentTime + 0.15);
    }

    function playCatchSound() {
      if (!audioCtx) return;
      const osc = audioCtx.createOscillator();
      const gain = audioCtx.createGain();
      osc.connect(gain);
      gain.connect(audioCtx.destination);
      osc.type = 'square';
      osc.frequency.setValueAtTime(400 + combo * 50, audioCtx.currentTime);
      osc.frequency.exponentialRampToValueAtTime(800 + combo * 100, audioCtx.currentTime + 0.1);
      gain.gain.setValueAtTime(0.2, audioCtx.currentTime);
      gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.1);
      osc.start();
      osc.stop(audioCtx.currentTime + 0.1);
    }

    function playEscapeSound() {
      if (!audioCtx) return;
      const osc = audioCtx.createOscillator();
      const gain = audioCtx.createGain();
      osc.connect(gain);
      gain.connect(audioCtx.destination);
      osc.type = 'sawtooth';
      osc.frequency.setValueAtTime(300, audioCtx.currentTime);
      osc.frequency.exponentialRampToValueAtTime(100, audioCtx.currentTime + 0.3);
      gain.gain.setValueAtTime(0.15, audioCtx.currentTime);
      gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.3);
      osc.start();
      osc.stop(audioCtx.currentTime + 0.3);
    }

    // Pest types
    const pestTypes = [
      { name: 'glitch', color: '#00ffaa', size: 15, speed: 2, points: 10 },
      { name: 'pixel', color: '#ff00ff', size: 10, speed: 3, points: 15 },
      { name: 'bug', color: '#ffff00', size: 20, speed: 1.5, points: 20 },
      { name: 'virus', color: '#ff3366', size: 12, speed: 4, points: 25 },
      { name: 'worm', color: '#00ffff', size: 8, speed: 5, points: 30 },
    ];

    class Pest {
      constructor() {
        const type = pestTypes[Math.floor(Math.random() * pestTypes.length)];
        Object.assign(this, type);
        // Spawn from edges
        const side = Math.floor(Math.random() * 4);
        if (side === 0) { this.x = Math.random() * width; this.y = -this.size; }
        else if (side === 1) { this.x = width + this.size; this.y = Math.random() * height; }
        else if (side === 2) { this.x = Math.random() * width; this.y = height + this.size; }
        else { this.x = -this.size; this.y = Math.random() * height; }
        
        this.targetX = Math.random() * width;
        this.targetY = Math.random() * height;
        this.angle = Math.atan2(this.targetY - this.y, this.targetX - this.x);
        this.wobble = Math.random() * Math.PI * 2;
        this.lifetime = 0;
        this.maxLife = 300 + Math.random() * 200;
        this.caught = false;
        this.glitchOffset = 0;
      }

      update() {
        this.lifetime++;
        this.wobble += 0.1;
        
        // Move toward target with wobble
        const wobbleX = Math.sin(this.wobble) * 2;
        const wobbleY = Math.cos(this.wobble * 0.7) * 2;
        this.x += Math.cos(this.angle) * this.speed + wobbleX * 0.3;
        this.y += Math.sin(this.angle) * this.speed + wobbleY * 0.3;
        
        // Occasionally change direction
        if (Math.random() < 0.02) {
          this.targetX = Math.random() * width;
          this.targetY = Math.random() * height;
          this.angle = Math.atan2(this.targetY - this.y, this.targetX - this.x);
        }
        
        // Glitch effect
        this.glitchOffset = Math.random() < 0.1 ? (Math.random() - 0.5) * 10 : 0;
        
        // Check if escaped
        if (this.lifetime > this.maxLife) {
          return 'escaped';
        }
        
        // Check if out of bounds for too long
        if (this.x < -100 || this.x > width + 100 || this.y < -100 || this.y > height + 100) {
          return 'escaped';
        }
        
        return 'alive';
      }

      draw() {
        ctx.save();
        ctx.translate(this.x + this.glitchOffset, this.y);
        
        // Glow
        ctx.shadowColor = this.color;
        ctx.shadowBlur = 20;
        
        if (this.name === 'glitch') {
          // Glitchy square pattern
          ctx.fillStyle = this.color;
          for (let i = 0; i < 3; i++) {
            const offset = (Math.random() - 0.5) * 5;
            ctx.fillRect(-this.size/2 + offset, -this.size/2, this.size, this.size * 0.3);
            ctx.fillRect(-this.size/2, -this.size/2 + i * this.size/3, this.size, this.size * 0.2);
          }
        } else if (this.name === 'pixel') {
          // Pixel cluster
          ctx.fillStyle = this.color;
          const ps = this.size / 3;
          for (let px = -1; px <= 1; px++) {
            for (let py = -1; py <= 1; py++) {
              if (Math.random() > 0.3) {
                ctx.fillRect(px * ps - ps/2, py * ps - ps/2, ps * 0.8, ps * 0.8);
              }
            }
          }
        } else if (this.name === 'bug') {
          // Digital bug with legs
          ctx.fillStyle = this.color;
          ctx.beginPath();
          ctx.ellipse(0, 0, this.size/2, this.size/3, 0, 0, Math.PI * 2);
          ctx.fill();
          // Legs
          ctx.strokeStyle = this.color;
          ctx.lineWidth = 2;
          for (let i = -1; i <= 1; i++) {
            const legAngle = Math.sin(this.wobble + i) * 0.3;
            ctx.beginPath();
            ctx.moveTo(i * 5, 0);
            ctx.lineTo(i * 5 - 8, -10 + legAngle * 5);
            ctx.moveTo(i * 5, 0);
            ctx.lineTo(i * 5 - 8, 10 - legAngle * 5);
            ctx.stroke();
          }
          // Antennae
          ctx.beginPath();
          ctx.moveTo(this.size/3, -2);
          ctx.lineTo(this.size/2 + 5, -8);
          ctx.moveTo(this.size/3, 2);
          ctx.lineTo(this.size/2 + 5, 8);
          ctx.stroke();
        } else if (this.name === 'virus') {
          // Spiky virus
          ctx.fillStyle = this.color;
          ctx.beginPath();
          for (let i = 0; i < 8; i++) {
            const a = (i / 8) * Math.PI * 2;
            const r = i % 2 === 0 ? this.size : this.size * 0.5;
            if (i === 0) ctx.moveTo(Math.cos(a) * r, Math.sin(a) * r);
            else ctx.lineTo(Math.cos(a) * r, Math.sin(a) * r);
          }
          ctx.closePath();
          ctx.fill();
          // Core
          ctx.fillStyle = '#000';
          ctx.beginPath();
          ctx.arc(0, 0, this.size * 0.3, 0, Math.PI * 2);
          ctx.fill();
        } else if (this.name === 'worm') {
          // Segmented worm
          ctx.fillStyle = this.color;
          for (let i = 0; i < 5; i++) {
            const segX = -i * 4 + Math.sin(this.wobble + i * 0.5) * 3;
            const segY = Math.cos(this.wobble + i * 0.5) * 2;
            ctx.beginPath();
            ctx.arc(segX, segY, this.size * (1 - i * 0.15), 0, Math.PI * 2);
            ctx.fill();
          }
        }
        
        ctx.restore();
      }
    }

    class Trap {
      constructor(x, y) {
        this.x = x;
        this.y = y;
        this.radius = 50;
        this.maxRadius = 80;
        this.life = 60;
        this.maxLife = 60;
        this.triggered = false;
        this.catchRadius = 60;
      }

      update() {
        this.life--;
        if (!this.triggered) {
          this.radius = 50 + Math.sin(this.life * 0.3) * 5;
        } else {
          this.radius += 5;
          if (this.radius > this.maxRadius) this.radius = this.maxRadius;
        }
        return this.life > 0;
      }

      draw() {
        const alpha = this.life / this.maxLife;
        
        // Trap circle
        ctx.strokeStyle = this.triggered 
          ? `rgba(255, 200, 50, ${alpha})` 
          : `rgba(255, 100, 50, ${alpha})`;
        ctx.lineWidth = 3;
        ctx.shadowColor = this.triggered ? '#ffcc00' : '#ff6622';
        ctx.shadowBlur = 15;
        
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
        ctx.stroke();
        
        // Inner pattern
        ctx.beginPath();
        for (let i = 0; i < 6; i++) {
          const angle = (i / 6) * Math.PI * 2 + this.life * 0.05;
          const x1 = this.x + Math.cos(angle) * this.radius * 0.3;
          const y1 = this.y + Math.sin(angle) * this.radius * 0.3;
          const x2 = this.x + Math.cos(angle) * this.radius * 0.9;
          const y2 = this.y + Math.sin(angle) * this.radius * 0.9;
          ctx.moveTo(x1, y1);
          ctx.lineTo(x2, y2);
        }
        ctx.stroke();
        
        // Fox paw print in center
        if (!this.triggered) {
          ctx.fillStyle = `rgba(255, 136, 68, ${alpha * 0.8})`;
          // Main pad
          ctx.beginPath();
          ctx.ellipse(this.x, this.y + 5, 8, 10, 0, 0, Math.PI * 2);
          ctx.fill();
          // Toes
          const toePositions = [[-8, -8], [0, -12], [8, -8]];
          toePositions.forEach(([tx, ty]) => {
            ctx.beginPath();
            ctx.arc(this.x + tx, this.y + ty, 5, 0, Math.PI * 2);
            ctx.fill();
          });
        }
        
        ctx.shadowBlur = 0;
      }

      checkCatch(pest) {
        const dx = pest.x - this.x;
        const dy = pest.y - this.y;
        const dist = Math.sqrt(dx * dx + dy * dy);
        return dist < this.catchRadius;
      }
    }

    class Particle {
      constructor(x, y, color) {
        this.x = x;
        this.y = y;
        this.color = color;
        this.vx = (Math.random() - 0.5) * 8;
        this.vy = (Math.random() - 0.5) * 8;
        this.life = 30;
        this.size = 3 + Math.random() * 4;
      }

      update() {
        this.x += this.vx;
        this.y += this.vy;
        this.vx *= 0.95;
        this.vy *= 0.95;
        this.life--;
        return this.life > 0;
      }

      draw() {
        const alpha = this.life / 30;
        ctx.fillStyle = this.color.replace(')', `, ${alpha})`).replace('rgb', 'rgba');
        ctx.shadowColor = this.color;
        ctx.shadowBlur = 10;
        ctx.fillRect(this.x - this.size/2, this.y - this.size/2, this.size, this.size);
        ctx.shadowBlur = 0;
      }
    }

    function spawnParticles(x, y, color, count = 10) {
      for (let i = 0; i < count; i++) {
        particles.push(new Particle(x, y, color));
      }
    }

    function showCombo(x, y, text) {
      const div = document.createElement('div');
      div.className = 'combo';
      div.textContent = text;
      div.style.left = x + 'px';
      div.style.top = y + 'px';
      document.body.appendChild(div);
      setTimeout(() => div.remove(), 800);
    }

    // Spawn pests periodically
    let spawnTimer = 0;
    function spawnPest() {
      if (pests.length < 15) {
        pests.push(new Pest());
      }
    }

    // Place trap on click
    canvas.addEventListener('click', (e) => {
      initAudio();
      const rect = canvas.getBoundingClientRect();
      const x = e.clientX - rect.left;
      const y = e.clientY - rect.top;
      traps.push(new Trap(x, y));
      playTrapSound();
    });

    canvas.addEventListener('touchstart', (e) => {
      e.preventDefault();
      initAudio();
      const touch = e.touches[0];
      traps.push(new Trap(touch.clientX, touch.clientY));
      playTrapSound();
    });

    // Draw neon fox
    function drawFox(x, y, size) {
      ctx.save();
      ctx.translate(x, y);
      
      ctx.shadowColor = '#ff6622';
      ctx.shadowBlur = 20;
      
      // Body
      ctx.fillStyle = '#ff6622';
      ctx.beginPath();
      ctx.ellipse(0, 20, size * 0.6, size * 0.4, 0, 0, Math.PI * 2);
      ctx.fill();
      
      // Head
      ctx.beginPath();
      ctx.arc(0, -10, size * 0.5, 0, Math.PI * 2);
      ctx.fill();
      
      // Ears
      ctx.beginPath();
      ctx.moveTo(-size * 0.4, -size * 0.3);
      ctx.lineTo(-size * 0.2, -size * 0.8);
      ctx.lineTo(0, -size * 0.3);
      ctx.fill();
      ctx.beginPath();
      ctx.moveTo(size * 0.4, -size * 0.3);
      ctx.lineTo(size * 0.2, -size * 0.8);
      ctx.lineTo(0, -size * 0.3);
      ctx.fill();
      
      // Inner ears
      ctx.fillStyle = '#ffaa44';
      ctx.beginPath();
      ctx.moveTo(-size * 0.3, -size * 0.35);
      ctx.lineTo(-size * 0.2, -size * 0.6);
      ctx.lineTo(-size * 0.1, -size * 0.35);
      ctx.fill();
      ctx.beginPath();
      ctx.moveTo(size * 0.3, -size * 0.35);
      ctx.lineTo(size * 0.2, -size * 0.6);
      ctx.lineTo(size * 0.1, -size * 0.35);
      ctx.fill();
      
      // Snout
      ctx.fillStyle = '#ffcc88';
      ctx.beginPath();
      ctx.ellipse(0, 0, size * 0.25, size * 0.2, 0, 0, Math.PI * 2);
      ctx.fill();
      
      // Nose
      ctx.fillStyle = '#222';
      ctx.beginPath();
      ctx.arc(0, -5, 5, 0, Math.PI * 2);
      ctx.fill();
      
      // Eyes
      ctx.fillStyle = '#00ffaa';
      ctx.shadowColor = '#00ffaa';
      ctx.beginPath();
      ctx.ellipse(-12, -15, 6, 8, 0, 0, Math.PI * 2);
      ctx.fill();
      ctx.beginPath();
      ctx.ellipse(12, -15, 6, 8, 0, 0, Math.PI * 2);
      ctx.fill();
      
      // Pupils
      ctx.fillStyle = '#000';
      ctx.beginPath();
      ctx.arc(-12, -15, 3, 0, Math.PI * 2);
      ctx.fill();
      ctx.beginPath();
      ctx.arc(12, -15, 3, 0, Math.PI * 2);
      ctx.fill();
      
      // Tail
      ctx.fillStyle = '#ff6622';
      ctx.shadowColor = '#ff6622';
      const tailWag = Math.sin(Date.now() * 0.01) * 0.3;
      ctx.save();
      ctx.translate(-size * 0.3, size * 0.3);
      ctx.rotate(-0.5 + tailWag);
      ctx.beginPath();
      ctx.ellipse(0, 0, size * 0.2, size * 0.5, 0, 0, Math.PI * 2);
      ctx.fill();
      // White tail tip
      ctx.fillStyle = '#ffeecc';
      ctx.beginPath();
      ctx.ellipse(0, -size * 0.35, size * 0.15, size * 0.15, 0, 0, Math.PI * 2);
      ctx.fill();
      ctx.restore();
      
      ctx.restore();
    }

    // Draw background grid
    function drawBackground() {
      ctx.fillStyle = '#0a0a12';
      ctx.fillRect(0, 0, width, height);
      
      // Grid
      ctx.strokeStyle = 'rgba(255, 100, 50, 0.1)';
      ctx.lineWidth = 1;
      const gridSize = 50;
      for (let x = 0; x < width; x += gridSize) {
        ctx.beginPath();
        ctx.moveTo(x, 0);
        ctx.lineTo(x, height);
        ctx.stroke();
      }
      for (let y = 0; y < height; y += gridSize) {
        ctx.beginPath();
        ctx.moveTo(0, y);
        ctx.lineTo(width, y);
        ctx.stroke();
      }
    }

    function update() {
      spawnTimer++;
      if (spawnTimer > 60) {
        spawnPest();
        spawnTimer = 0;
      }
      
      // Combo decay
      if (comboTimer > 0) {
        comboTimer--;
      } else if (combo > 1) {
        combo = 1;
        comboEl.textContent = 'x1';
      }
      
      // Update pests
      for (let i = pests.length - 1; i >= 0; i--) {
        const result = pests[i].update();
        if (result === 'escaped') {
          escaped++;
          escapedEl.textContent = escaped;
          combo = 1;
          comboEl.textContent = 'x1';
          playEscapeSound();
          pests.splice(i, 1);
        }
      }
      
      // Update traps and check catches
      for (let i = traps.length - 1; i >= 0; i--) {
        const trap = traps[i];
        
        // Check if trap catches any pest
        for (let j = pests.length - 1; j >= 0; j--) {
          if (trap.checkCatch(pests[j]) && !pests[j].caught) {
            const pest = pests[j];
            pest.caught = true;
            trap.triggered = true;
            
            // Score with combo
            const points = pest.points * combo;
            score += points;
            scoreEl.textContent = score;
            
            // Increase combo
            combo = Math.min(combo + 1, 10);
            comboTimer = 120;
            comboEl.textContent = 'x' + combo;
            
            // Effects
            spawnParticles(pest.x, pest.y, pest.color, 15);
            showCombo(pest.x, pest.y - 30, '+' + points);
            playCatchSound();
            
            pests.splice(j, 1);
          }
        }
        
        if (!trap.update()) {
          traps.splice(i, 1);
        }
      }
      
      // Update particles
      for (let i = particles.length - 1; i >= 0; i--) {
        if (!particles[i].update()) {
          particles.splice(i, 1);
        }
      }
    }

    function draw() {
      drawBackground();
      
      // Draw fox mascot in corner
      drawFox(80, height - 100, 40);
      
      // Draw traps
      traps.forEach(trap => trap.draw());
      
      // Draw pests
      pests.forEach(pest => pest.draw());
      
      // Draw particles
      particles.forEach(p => p.draw());
    }

    function gameLoop() {
      update();
      draw();
      requestAnimationFrame(gameLoop);
    }

    gameLoop();
  </script>
<script src="/sloppy-header/sloppy-bar.js"></script>
<script src="/vibelib-extended.js"></script>
<script>
  // Compatibility Patch for Legacy Apps
  window.addEventListener("load", () => {
    if (window.SloppyKarma && window.VibeLib.Economy) {
      // Redirect old calls to new engine
      window.SloppyKarma.track = window.VibeLib.Economy.track;
    }
  });
</script>
</body>
</html>
