<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Void Fishing</title>
  <meta name="description" content="Cast your line into the static and catch digital ghosts">
  <meta property="og:title" content="Void Fishing">
  <meta property="og:description" content="Fish for digital ghosts in a sea of static">
  <meta property="og:url" content="https://sloppy.live/void-fishing/">
  <meta property="og:image" content="https://sloppy.live/void-fishing/og-image.png">
  <link rel="icon" href="https://emojicdn.elk.sh/üëª">
  <link href="https://fonts.googleapis.com/css2?family=VT323&family=Creepster&display=swap" rel="stylesheet">
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      background: #000;
      min-height: 100vh;
      overflow: hidden;
      font-family: 'VT323', monospace;
      color: #0ff;
      cursor: crosshair;
    }

    #staticCanvas {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      opacity: 0.15;
    }

    #gameCanvas {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
    }

    .ui-overlay {
      position: fixed;
      z-index: 100;
      pointer-events: none;
    }

    .header {
      top: 1.5rem;
      left: 50%;
      transform: translateX(-50%);
      text-align: center;
    }

    .header h1 {
      font-family: 'Creepster', cursive;
      font-size: 2.5rem;
      color: #0ff;
      text-shadow:
        0 0 10px #0ff,
        0 0 20px #0ff,
        0 0 40px #088,
        2px 2px 0 #f0f;
      letter-spacing: 0.1em;
      animation: glitchText 3s infinite;
    }

    @keyframes glitchText {
      0%, 90%, 100% { transform: translateX(-50%) skewX(0); }
      92% { transform: translateX(-52%) skewX(-2deg); }
      94% { transform: translateX(-48%) skewX(2deg); }
    }

    .stats-panel {
      top: 1rem;
      left: 1rem;
      background: rgba(0, 0, 0, 0.8);
      border: 2px solid #0ff;
      padding: 1rem;
      font-size: 1.2rem;
      box-shadow: 0 0 20px rgba(0, 255, 255, 0.3);
    }

    .stat {
      margin: 0.3rem 0;
    }

    .stat-label {
      color: #088;
    }

    .stat-value {
      color: #0ff;
      text-shadow: 0 0 10px #0ff;
    }

    .collection-panel {
      top: 1rem;
      right: 1rem;
      background: rgba(0, 0, 0, 0.8);
      border: 2px solid #f0f;
      padding: 1rem;
      max-width: 200px;
      box-shadow: 0 0 20px rgba(255, 0, 255, 0.3);
    }

    .collection-title {
      font-size: 1.2rem;
      color: #f0f;
      margin-bottom: 0.5rem;
      text-shadow: 0 0 10px #f0f;
    }

    .ghost-collection {
      display: flex;
      flex-wrap: wrap;
      gap: 0.3rem;
      min-height: 30px;
    }

    .collected-ghost {
      font-size: 1.5rem;
      filter: drop-shadow(0 0 5px currentColor);
      animation: floatGhost 2s ease-in-out infinite;
    }

    @keyframes floatGhost {
      0%, 100% { transform: translateY(0); }
      50% { transform: translateY(-3px); }
    }

    .instructions {
      bottom: 1.5rem;
      left: 50%;
      transform: translateX(-50%);
      text-align: center;
      font-size: 1.1rem;
      color: #088;
      transition: opacity 0.5s;
    }

    .instructions.hidden {
      opacity: 0;
    }

    .message {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      font-family: 'Creepster', cursive;
      font-size: 2rem;
      color: #f0f;
      text-shadow: 0 0 20px #f0f;
      opacity: 0;
      pointer-events: none;
      z-index: 200;
      transition: opacity 0.3s;
    }

    .message.visible {
      opacity: 1;
      animation: messageGlitch 0.5s infinite;
    }

    @keyframes messageGlitch {
      0%, 100% { transform: translate(-50%, -50%); }
      25% { transform: translate(-52%, -48%); }
      50% { transform: translate(-48%, -52%); }
      75% { transform: translate(-51%, -49%); }
    }

    .depth-meter {
      position: fixed;
      left: 1rem;
      top: 50%;
      transform: translateY(-50%);
      width: 20px;
      height: 200px;
      background: rgba(0, 0, 0, 0.8);
      border: 2px solid #0ff;
      z-index: 100;
    }

    .depth-fill {
      position: absolute;
      bottom: 0;
      width: 100%;
      background: linear-gradient(to top, #f0f, #0ff);
      transition: height 0.3s;
      box-shadow: 0 0 10px #0ff;
    }

    .depth-label {
      position: absolute;
      left: 30px;
      top: 50%;
      transform: translateY(-50%);
      font-size: 0.9rem;
      color: #088;
      white-space: nowrap;
    }

    .backlink {
      position: fixed;
      bottom: 0.5rem;
      right: 0.5rem;
      font-size: 0.8rem;
      z-index: 100;
      opacity: 0.5;
    }

    .backlink a {
      color: #0ff;
      text-decoration: none;
    }

    .catch-flash {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: #f0f;
      opacity: 0;
      pointer-events: none;
      z-index: 150;
      animation: catchFlash 0.3s ease-out;
    }

    @keyframes catchFlash {
      0% { opacity: 0.5; }
      100% { opacity: 0; }
    }

    @media (max-width: 600px) {
      .header h1 {
        font-size: 1.8rem;
      }

      .stats-panel, .collection-panel {
        font-size: 1rem;
        padding: 0.7rem;
      }

      .collection-panel {
        max-width: 150px;
      }

      .depth-meter {
        height: 150px;
      }
    }
  </style>
</head>
<body>
  <canvas id="staticCanvas"></canvas>
  <canvas id="gameCanvas"></canvas>

  <div class="ui-overlay header">
    <h1>VOID FISHING</h1>
  </div>

  <div class="ui-overlay stats-panel">
    <div class="stat">
      <span class="stat-label">CAUGHT:</span>
      <span class="stat-value" id="caught">0</span>
    </div>
    <div class="stat">
      <span class="stat-label">DEPTH:</span>
      <span class="stat-value" id="depth">0m</span>
    </div>
    <div class="stat">
      <span class="stat-label">STATUS:</span>
      <span class="stat-value" id="status">READY</span>
    </div>
  </div>

  <div class="ui-overlay collection-panel">
    <div class="collection-title">COLLECTION</div>
    <div class="ghost-collection" id="collection">-</div>
  </div>

  <div class="depth-meter">
    <div class="depth-fill" id="depthFill" style="height: 0%"></div>
    <div class="depth-label">VOID DEPTH</div>
  </div>

  <div class="ui-overlay instructions" id="instructions">
    CLICK TO CAST ‚Ä¢ WAIT FOR BITE ‚Ä¢ CLICK TO REEL
  </div>

  <div class="message" id="message"></div>

  <div class="backlink"><a href="https://sloppy.live">sloppy.live</a></div>

  <script>
    // Canvases
    const staticCanvas = document.getElementById('staticCanvas');
    const staticCtx = staticCanvas.getContext('2d');
    const gameCanvas = document.getElementById('gameCanvas');
    const ctx = gameCanvas.getContext('2d');

    function resize() {
      staticCanvas.width = gameCanvas.width = window.innerWidth;
      staticCanvas.height = gameCanvas.height = window.innerHeight;
    }
    resize();
    window.addEventListener('resize', resize);

    // Audio
    let audioCtx = null;

    function initAudio() {
      if (!audioCtx) {
        audioCtx = new (window.AudioContext || window.webkitAudioContext)();
      }
    }

    function playSound(type) {
      if (!audioCtx) return;

      const osc = audioCtx.createOscillator();
      const gain = audioCtx.createGain();

      if (type === 'cast') {
        osc.type = 'sine';
        osc.frequency.value = 200;
        osc.frequency.exponentialRampToValueAtTime(50, audioCtx.currentTime + 0.5);
        gain.gain.value = 0.1;
        gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.5);
        osc.connect(gain);
        gain.connect(audioCtx.destination);
        osc.start();
        osc.stop(audioCtx.currentTime + 0.5);
      } else if (type === 'bite') {
        osc.type = 'square';
        osc.frequency.value = 400;
        gain.gain.value = 0.15;
        gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.1);
        osc.connect(gain);
        gain.connect(audioCtx.destination);
        osc.start();
        osc.stop(audioCtx.currentTime + 0.1);
      } else if (type === 'catch') {
        osc.type = 'sawtooth';
        osc.frequency.value = 150;
        osc.frequency.exponentialRampToValueAtTime(600, audioCtx.currentTime + 0.3);
        gain.gain.value = 0.2;
        gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.4);
        osc.connect(gain);
        gain.connect(audioCtx.destination);
        osc.start();
        osc.stop(audioCtx.currentTime + 0.4);
      }
    }

    // Game state
    let state = 'ready'; // ready, casting, waiting, bite, reeling
    let caughtCount = 0;
    let collection = [];
    let currentDepth = 0;
    let targetDepth = 0;
    let bobberX = 0;
    let bobberY = 0;
    let lineStartX = 0;
    let lineStartY = 0;
    let biteTimer = 0;
    let reelProgress = 0;
    let currentGhost = null;

    // Ghost types
    const ghostTypes = [
      { emoji: 'üëª', name: 'Common Spirit', rarity: 'common', depth: [0, 30], color: '#ffffff' },
      { emoji: 'üíÄ', name: 'Skull Specter', rarity: 'common', depth: [10, 50], color: '#f0f0f0' },
      { emoji: 'üëÅÔ∏è', name: 'Void Watcher', rarity: 'uncommon', depth: [20, 60], color: '#ff00ff' },
      { emoji: 'ü¶¥', name: 'Bone Wraith', rarity: 'uncommon', depth: [30, 70], color: '#dddddd' },
      { emoji: 'üåÄ', name: 'Data Vortex', rarity: 'rare', depth: [40, 80], color: '#00ffff' },
      { emoji: 'üë§', name: 'Shadow Entity', rarity: 'rare', depth: [50, 90], color: '#333366' },
      { emoji: 'üîÆ', name: 'Orb of Forgotten', rarity: 'epic', depth: [60, 95], color: '#ff00ff' },
      { emoji: 'üëÅÔ∏è‚Äçüó®Ô∏è', name: 'All-Seeing Glitch', rarity: 'epic', depth: [70, 100], color: '#00ff88' },
      { emoji: 'üï≥Ô∏è', name: 'Void Itself', rarity: 'legendary', depth: [85, 100], color: '#000000' },
      { emoji: '‚ö°', name: 'Static Lord', rarity: 'legendary', depth: [90, 100], color: '#ffff00' }
    ];

    // Ambient ghosts floating in the void
    let ambientGhosts = [];

    class AmbientGhost {
      constructor() {
        this.reset();
      }

      reset() {
        this.x = Math.random() * gameCanvas.width;
        this.y = gameCanvas.height * 0.4 + Math.random() * gameCanvas.height * 0.5;
        this.type = ghostTypes[Math.floor(Math.random() * ghostTypes.length)];
        this.size = 20 + Math.random() * 30;
        this.speedX = (Math.random() - 0.5) * 0.5;
        this.speedY = (Math.random() - 0.5) * 0.3;
        this.wobble = Math.random() * Math.PI * 2;
        this.opacity = 0.1 + Math.random() * 0.3;
        this.glitchTimer = 0;
      }

      update() {
        this.wobble += 0.02;
        this.x += this.speedX + Math.sin(this.wobble) * 0.3;
        this.y += this.speedY + Math.cos(this.wobble * 0.7) * 0.2;

        // Random glitch
        if (Math.random() < 0.005) {
          this.glitchTimer = 10;
        }
        if (this.glitchTimer > 0) this.glitchTimer--;

        // Wrap around
        if (this.x < -50) this.x = gameCanvas.width + 50;
        if (this.x > gameCanvas.width + 50) this.x = -50;
        if (this.y < gameCanvas.height * 0.3) this.y = gameCanvas.height * 0.9;
        if (this.y > gameCanvas.height + 50) this.y = gameCanvas.height * 0.4;
      }

      draw() {
        ctx.save();
        ctx.globalAlpha = this.opacity;

        let drawX = this.x;
        let drawY = this.y;

        if (this.glitchTimer > 0) {
          drawX += (Math.random() - 0.5) * 20;
          drawY += (Math.random() - 0.5) * 10;
        }

        ctx.font = `${this.size}px Arial`;
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.shadowColor = this.type.color;
        ctx.shadowBlur = 15;
        ctx.fillText(this.type.emoji, drawX, drawY);

        ctx.restore();
      }
    }

    // Initialize ambient ghosts
    for (let i = 0; i < 15; i++) {
      ambientGhosts.push(new AmbientGhost());
    }

    // Draw static
    function drawStatic() {
      const imageData = staticCtx.createImageData(staticCanvas.width, staticCanvas.height);
      const data = imageData.data;

      for (let i = 0; i < data.length; i += 4) {
        const val = Math.random() * 255;
        data[i] = val;     // R
        data[i + 1] = val; // G
        data[i + 2] = val; // B
        data[i + 3] = 255; // A
      }

      staticCtx.putImageData(imageData, 0, 0);
    }

    // Draw fishing line and bobber
    function drawFishing() {
      if (state === 'ready') return;

      ctx.save();

      // Line from shore to bobber
      ctx.strokeStyle = '#0ff';
      ctx.lineWidth = 2;
      ctx.shadowColor = '#0ff';
      ctx.shadowBlur = 5;

      ctx.beginPath();
      ctx.moveTo(lineStartX, lineStartY);

      // Curved line
      const midX = (lineStartX + bobberX) / 2;
      const midY = Math.min(lineStartY, bobberY) - 50;
      ctx.quadraticCurveTo(midX, midY, bobberX, bobberY);
      ctx.stroke();

      // Bobber
      const bobberOffset = state === 'bite' ? Math.sin(Date.now() * 0.05) * 5 : 0;

      ctx.fillStyle = state === 'bite' ? '#f0f' : '#0ff';
      ctx.shadowColor = state === 'bite' ? '#f0f' : '#0ff';
      ctx.shadowBlur = 20;
      ctx.beginPath();
      ctx.arc(bobberX, bobberY + bobberOffset, 8, 0, Math.PI * 2);
      ctx.fill();

      // Line going down into void
      if (state !== 'casting') {
        ctx.strokeStyle = 'rgba(0, 255, 255, 0.5)';
        ctx.setLineDash([5, 5]);
        ctx.beginPath();
        ctx.moveTo(bobberX, bobberY);
        ctx.lineTo(bobberX, bobberY + currentDepth * 2);
        ctx.stroke();
        ctx.setLineDash([]);
      }

      // Ghost on line when reeling
      if (state === 'reeling' && currentGhost) {
        const ghostY = bobberY + (1 - reelProgress) * currentDepth * 2;
        ctx.font = '40px Arial';
        ctx.textAlign = 'center';
        ctx.shadowColor = currentGhost.color;
        ctx.shadowBlur = 30;
        ctx.fillText(currentGhost.emoji, bobberX + (Math.random() - 0.5) * 10, ghostY);
      }

      ctx.restore();
    }

    // Draw void surface
    function drawVoidSurface() {
      const surfaceY = gameCanvas.height * 0.35;

      ctx.save();

      // Gradient from surface into void
      const gradient = ctx.createLinearGradient(0, surfaceY - 50, 0, surfaceY + 100);
      gradient.addColorStop(0, 'rgba(0, 0, 0, 0)');
      gradient.addColorStop(0.5, 'rgba(0, 50, 50, 0.3)');
      gradient.addColorStop(1, 'rgba(0, 20, 40, 0.5)');

      ctx.fillStyle = gradient;
      ctx.fillRect(0, surfaceY - 50, gameCanvas.width, gameCanvas.height);

      // Wavy surface line
      ctx.strokeStyle = '#0ff';
      ctx.lineWidth = 2;
      ctx.shadowColor = '#0ff';
      ctx.shadowBlur = 10;

      ctx.beginPath();
      for (let x = 0; x <= gameCanvas.width; x += 5) {
        const y = surfaceY + Math.sin(x * 0.02 + Date.now() * 0.001) * 5;
        if (x === 0) ctx.moveTo(x, y);
        else ctx.lineTo(x, y);
      }
      ctx.stroke();

      ctx.restore();
    }

    // Cast the line
    function castLine(targetX) {
      if (state !== 'ready') return;

      initAudio();
      playSound('cast');

      state = 'casting';
      lineStartX = gameCanvas.width * 0.1;
      lineStartY = gameCanvas.height * 0.3;
      bobberX = lineStartX;
      bobberY = lineStartY;

      targetDepth = 20 + Math.random() * 80;

      // Animate cast
      const targetBobberX = Math.min(Math.max(targetX, gameCanvas.width * 0.2), gameCanvas.width * 0.9);
      const targetBobberY = gameCanvas.height * 0.35 + 20;

      const castDuration = 1000;
      const startTime = Date.now();

      function animateCast() {
        const elapsed = Date.now() - startTime;
        const progress = Math.min(elapsed / castDuration, 1);
        const eased = 1 - Math.pow(1 - progress, 3);

        bobberX = lineStartX + (targetBobberX - lineStartX) * eased;
        bobberY = lineStartY + (targetBobberY - lineStartY) * eased - Math.sin(progress * Math.PI) * 100;

        if (progress < 1) {
          requestAnimationFrame(animateCast);
        } else {
          state = 'waiting';
          biteTimer = 2000 + Math.random() * 5000;
          updateStatus('WAITING...');
        }
      }

      animateCast();
      updateStatus('CASTING...');
    }

    // Sink the line
    function sinkLine() {
      if (currentDepth < targetDepth) {
        currentDepth += 0.5;
        document.getElementById('depth').textContent = Math.floor(currentDepth) + 'm';
        document.getElementById('depthFill').style.height = currentDepth + '%';
      }
    }

    // Check for bite
    function checkBite(dt) {
      if (state !== 'waiting') return;

      sinkLine();

      biteTimer -= dt;
      if (biteTimer <= 0) {
        // Something bit!
        state = 'bite';
        playSound('bite');

        // Select ghost based on depth
        const possibleGhosts = ghostTypes.filter(g =>
          currentDepth >= g.depth[0] && currentDepth <= g.depth[1]
        );
        currentGhost = possibleGhosts[Math.floor(Math.random() * possibleGhosts.length)];

        showMessage('SOMETHING BITES!');
        updateStatus('BITE!');

        // Auto-escape if not reeled in time
        setTimeout(() => {
          if (state === 'bite') {
            showMessage('IT ESCAPED...');
            resetFishing();
          }
        }, 3000);
      }
    }

    // Reel in
    function reelIn() {
      if (state !== 'bite') return;

      state = 'reeling';
      reelProgress = 0;
      updateStatus('REELING...');

      function animateReel() {
        reelProgress += 0.02;
        currentDepth = targetDepth * (1 - reelProgress);
        document.getElementById('depth').textContent = Math.floor(currentDepth) + 'm';
        document.getElementById('depthFill').style.height = currentDepth + '%';

        if (reelProgress >= 1) {
          catchGhost();
        } else if (state === 'reeling') {
          requestAnimationFrame(animateReel);
        }
      }

      animateReel();
    }

    // Catch the ghost
    function catchGhost() {
      if (!currentGhost) return;

      playSound('catch');

      // Flash effect
      const flash = document.createElement('div');
      flash.className = 'catch-flash';
      document.body.appendChild(flash);
      setTimeout(() => flash.remove(), 300);

      caughtCount++;
      collection.push(currentGhost);

      document.getElementById('caught').textContent = caughtCount;
      updateCollection();

      const rarityColors = {
        common: '#aaa',
        uncommon: '#0f0',
        rare: '#00f',
        epic: '#f0f',
        legendary: '#ff0'
      };

      showMessage(`CAUGHT: ${currentGhost.name}!`, rarityColors[currentGhost.rarity]);

      resetFishing();
    }

    // Reset fishing state
    function resetFishing() {
      state = 'ready';
      currentDepth = 0;
      targetDepth = 0;
      currentGhost = null;
      document.getElementById('depth').textContent = '0m';
      document.getElementById('depthFill').style.height = '0%';
      updateStatus('READY');
    }

    // Update status display
    function updateStatus(text) {
      document.getElementById('status').textContent = text;
    }

    // Update collection display
    function updateCollection() {
      const container = document.getElementById('collection');
      if (collection.length === 0) {
        container.innerHTML = '-';
        return;
      }

      // Show unique ghosts
      const unique = [...new Set(collection.map(g => g.emoji))];
      container.innerHTML = unique.map(e =>
        `<span class="collected-ghost">${e}</span>`
      ).join('');
    }

    // Show message
    function showMessage(text, color = '#f0f') {
      const msg = document.getElementById('message');
      msg.textContent = text;
      msg.style.color = color;
      msg.style.textShadow = `0 0 20px ${color}`;
      msg.classList.add('visible');

      setTimeout(() => {
        msg.classList.remove('visible');
      }, 2000);
    }

    // Main game loop
    let lastTime = Date.now();

    function gameLoop() {
      const now = Date.now();
      const dt = now - lastTime;
      lastTime = now;

      // Draw static (every few frames for performance)
      if (Math.random() < 0.3) {
        drawStatic();
      }

      // Clear game canvas
      ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
      ctx.fillRect(0, 0, gameCanvas.width, gameCanvas.height);

      // Draw void surface
      drawVoidSurface();

      // Update and draw ambient ghosts
      ambientGhosts.forEach(g => {
        g.update();
        g.draw();
      });

      // Draw fishing
      drawFishing();

      // Check for bite
      checkBite(dt);

      requestAnimationFrame(gameLoop);
    }

    // Click handler
    gameCanvas.addEventListener('click', (e) => {
      if (state === 'ready') {
        castLine(e.clientX);
        document.getElementById('instructions').classList.add('hidden');
      } else if (state === 'bite') {
        reelIn();
      }
    });

    // Touch support
    gameCanvas.addEventListener('touchstart', (e) => {
      e.preventDefault();
      const touch = e.touches[0];
      gameCanvas.dispatchEvent(new MouseEvent('click', {
        clientX: touch.clientX,
        clientY: touch.clientY
      }));
    });

    // Start
    gameLoop();
  </script>
</body>
</html>
