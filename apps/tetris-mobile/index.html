<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<title>Tetris Mobile - Classic Block Puzzle</title>
<link rel="icon" href="https://emojicdn.elk.sh/üü¶">
<meta property="og:title" content="Tetris Mobile - Block Puzzle Game">
<meta property="og:description" content="Classic Tetris optimized for mobile with swipe controls">
<meta property="og:url" content="https://app.sloppy.live/tetris-mobile">
<meta property="og:image" content="https://image.pollinations.ai/prompt/colorful%20tetris%20blocks%20mobile%20game%20neon%20glow?width=1200&height=630&referrer=sloppy.live">
<style>
*{margin:0;padding:0;box-sizing:border-box;-webkit-tap-highlight-color:transparent}
body{font-family:-apple-system,BlinkMacSystemFont,'Segoe UI',Roboto,sans-serif;background:linear-gradient(135deg,#1a1a2e 0%,#16213e 50%,#0f3460 100%);color:#fff;overflow:hidden;height:100vh;touch-action:none}
.game-wrapper{display:flex;flex-direction:column;height:100vh;max-width:600px;margin:0 auto;padding:10px}
.header{text-align:center;padding:10px 0}
h1{font-size:28px;margin-bottom:5px;background:linear-gradient(45deg,#ff6b6b,#4ecdc4,#45b7d1);-webkit-background-clip:text;-webkit-text-fill-color:transparent;background-clip:text}
.stats-container{display:grid;grid-template-columns:repeat(3,1fr);gap:10px;margin-bottom:15px}
.stat-box{background:rgba(255,255,255,.1);backdrop-filter:blur(10px);border:2px solid rgba(255,255,255,.2);border-radius:12px;padding:10px;text-align:center}
.stat-label{font-size:11px;opacity:.7;text-transform:uppercase;letter-spacing:1px}
.stat-value{font-size:24px;font-weight:bold;margin-top:5px}
.game-area{display:flex;gap:10px;flex:1;min-height:0;align-items:center;justify-content:center}
.side-panel{display:flex;flex-direction:column;gap:10px;width:90px;flex-shrink:0}
.preview-box{background:rgba(255,255,255,.1);backdrop-filter:blur(10px);border:2px solid rgba(255,255,255,.2);border-radius:12px;padding:10px}
.preview-label{font-size:11px;opacity:.7;text-transform:uppercase;text-align:center;margin-bottom:8px}
.preview-canvas{width:100%;height:80px;display:block}
.main-game{flex:1;display:flex;flex-direction:column;position:relative;max-width:400px}
#gameCanvas{width:100%;height:auto;max-height:100%;background:rgba(0,0,0,.4);border:3px solid rgba(255,255,255,.3);border-radius:12px;box-shadow:0 0 30px rgba(0,0,0,.5);display:block;object-fit:contain}
.controls{display:grid;grid-template-columns:repeat(4,1fr);gap:8px;margin-top:10px}
.control-btn{background:rgba(255,255,255,.15);border:2px solid rgba(255,255,255,.3);border-radius:12px;color:#fff;font-size:24px;height:60px;display:flex;align-items:center;justify-content:center;cursor:pointer;user-select:none;transition:all .1s;backdrop-filter:blur(10px)}
.control-btn:active{background:rgba(255,255,255,.3);transform:scale(.95)}
.control-btn.wide{grid-column:span 2}
.game-over-screen{position:fixed;top:0;left:0;right:0;bottom:0;background:rgba(0,0,0,.95);display:none;align-items:center;justify-content:center;z-index:1000}
.game-over-screen.show{display:flex}
.game-over-content{background:rgba(255,255,255,.1);backdrop-filter:blur(20px);border:3px solid rgba(255,255,255,.3);border-radius:20px;padding:30px;text-align:center;max-width:400px;width:90%}
.game-over-content h2{font-size:48px;margin-bottom:20px;background:linear-gradient(45deg,#ff6b6b,#ffd93d);-webkit-background-clip:text;-webkit-text-fill-color:transparent;background-clip:text}
.final-stats{margin:20px 0;display:flex;flex-direction:column;gap:10px}
.final-stat-row{display:flex;justify-content:space-between;font-size:18px;padding:10px;background:rgba(255,255,255,.05);border-radius:8px}
.play-again-btn{background:linear-gradient(45deg,#4ecdc4,#45b7d1);border:none;border-radius:12px;color:#fff;font-size:20px;font-weight:bold;padding:15px 40px;cursor:pointer;margin-top:20px;transition:transform .2s}
.play-again-btn:active{transform:scale(.95)}
.pause-overlay{position:absolute;top:0;left:0;right:0;bottom:0;background:rgba(0,0,0,.8);display:none;align-items:center;justify-content:center;border-radius:12px;z-index:10}
.pause-overlay.show{display:flex}
.pause-text{font-size:48px;font-weight:bold;animation:pulse 1.5s infinite}
@keyframes pulse{0%,100%{opacity:1}50%{opacity:.5}}
.swipe-hint{position:fixed;bottom:90px;left:50%;transform:translateX(-50%);background:rgba(0,0,0,.8);padding:10px 20px;border-radius:20px;font-size:12px;text-align:center;opacity:0;pointer-events:none;transition:opacity .3s}
.swipe-hint.show{opacity:1}
@media (max-width:400px){
h1{font-size:24px}
.stat-value{font-size:20px}
.control-btn{height:50px;font-size:20px}
.side-panel{width:70px}
.main-game{max-width:250px}
}
@media (min-width:401px) and (max-width:600px){
.main-game{max-width:300px}
}
@media (min-height:700px){
.control-btn{height:70px}
}
</style>
</head>
<body>
<div class="game-wrapper">
<div class="header">
<h1>üü¶ TETRIS üü¶</h1>
</div>
<div class="stats-container">
<div class="stat-box">
<div class="stat-label">Score</div>
<div class="stat-value" id="score">0</div>
</div>
<div class="stat-box">
<div class="stat-label">Lines</div>
<div class="stat-value" id="lines">0</div>
</div>
<div class="stat-box">
<div class="stat-label">Level</div>
<div class="stat-value" id="level">1</div>
</div>
</div>
<div class="game-area">
<div class="side-panel">
<div class="preview-box">
<div class="preview-label">Next</div>
<canvas id="nextCanvas" class="preview-canvas" width="80" height="80"></canvas>
</div>
<div class="preview-box">
<div class="preview-label">Hold</div>
<canvas id="holdCanvas" class="preview-canvas" width="80" height="80"></canvas>
</div>
</div>
<div class="main-game">
<canvas id="gameCanvas" width="300" height="600"></canvas>
<div class="pause-overlay" id="pauseOverlay">
<div class="pause-text">PAUSED</div>
</div>
</div>
</div>
<div class="controls">
<button class="control-btn" id="btnLeft">‚Üê</button>
<button class="control-btn" id="btnRotate">‚Üª</button>
<button class="control-btn" id="btnRight">‚Üí</button>
<button class="control-btn" id="btnHold">üíæ</button>
<button class="control-btn wide" id="btnDrop">‚¨á DROP</button>
<button class="control-btn wide" id="btnPause">‚è∏ PAUSE</button>
</div>
</div>
<div class="swipe-hint" id="swipeHint">Swipe ‚Üê‚Üí to move | Swipe ‚Üì for drop | Tap to rotate</div>
<div class="game-over-screen" id="gameOverScreen">
<div class="game-over-content">
<h2>GAME OVER</h2>
<div class="final-stats">
<div class="final-stat-row"><span>Final Score:</span><span id="finalScore">0</span></div>
<div class="final-stat-row"><span>Lines Cleared:</span><span id="finalLines">0</span></div>
<div class="final-stat-row"><span>Level Reached:</span><span id="finalLevel">1</span></div>
</div>
<button class="play-again-btn" onclick="startGame()">PLAY AGAIN</button>
<div style="margin-top:20px;font-size:12px;opacity:.7">
<a href="https://sloppy.live" style="color:#4ecdc4;text-decoration:none">‚Üê Back to VibeCodedByX</a> | <a href="https://app.sloppy.live/overview" style="color:#4ecdc4;text-decoration:none">üé® View All Apps</a>
</div>
</div>
</div>
<script>
const c=document.getElementById('gameCanvas'),ctx=c.getContext('2d'),nc=document.getElementById('nextCanvas'),nctx=nc.getContext('2d'),hc=document.getElementById('holdCanvas'),hctx=hc.getContext('2d');
const COLS=10,ROWS=20,BS=c.width/COLS;
const SHAPES={I:[[1,1,1,1]],O:[[1,1],[1,1]],T:[[0,1,0],[1,1,1]],S:[[0,1,1],[1,1,0]],Z:[[1,1,0],[0,1,1]],J:[[1,0,0],[1,1,1]],L:[[0,0,1],[1,1,1]]};
const COLORS={I:'#00f0f0',O:'#f0f000',T:'#a000f0',S:'#00f000',Z:'#f00000',J:'#0000f0',L:'#f0a000'};
let board=[],currentPiece=null,nextPiece=null,holdPiece=null,canHold=true,score=0,lines=0,level=1,gameRunning=false,paused=false,dropCounter=0,dropInterval=1e3,lastTime=0,particles=[];
let touchStartX=0,touchStartY=0,touchStartTime=0;
class Glitter{
constructor(x,y,color){this.x=x;this.y=y;this.size=Math.random()*3+1;this.speedX=(Math.random()-.5)*4;this.speedY=(Math.random()-.5)*4-2;this.life=1;this.decay=Math.random()*.02+.01;this.color=color;this.rotation=Math.random()*Math.PI*2;this.rotationSpeed=(Math.random()-.5)*.2}
update(){this.x+=this.speedX;this.y+=this.speedY;this.speedY+=.15;this.life-=this.decay;this.rotation+=this.rotationSpeed}
draw(){
ctx.save();
ctx.globalAlpha=this.life;
ctx.translate(this.x,this.y);
ctx.rotate(this.rotation);
ctx.fillStyle=this.color;
ctx.beginPath();
for(let i=0;i<4;i++){
const angle=(i/4)*Math.PI*2,radius=i%2===0?this.size:this.size/2,px=Math.cos(angle)*radius,py=Math.sin(angle)*radius;
if(i===0)ctx.moveTo(px,py);else ctx.lineTo(px,py)
}
ctx.closePath();
ctx.fill();
ctx.shadowBlur=5;
ctx.shadowColor=this.color;
ctx.fill();
ctx.restore()
}
isDead(){return this.life<=0}
}
class Piece{
constructor(type){this.type=type;this.shape=SHAPES[type];this.color=COLORS[type];this.x=Math.floor(COLS/2)-Math.floor(this.shape[0].length/2);this.y=0}
rotate(){
const newShape=this.shape[0].map((_,i)=>this.shape.map(row=>row[i]).reverse());
if(this.canMove(this.x,this.y,newShape))this.shape=newShape
}
canMove(newX,newY,shape=this.shape){
for(let y=0;y<shape.length;y++){
for(let x=0;x<shape[y].length;x++){
if(shape[y][x]){
const bx=newX+x,by=newY+y;
if(bx<0||bx>=COLS||by>=ROWS)return false;
if(by>=0&&board[by][bx])return false
}
}
}
return true
}
move(dx,dy){
if(this.canMove(this.x+dx,this.y+dy)){this.x+=dx;this.y+=dy;return true}
return false
}
draw(context,offsetX=0,offsetY=0,blockSize=BS){
this.shape.forEach((row,y)=>{
row.forEach((value,x)=>{
if(value){
const px=(this.x+x)*blockSize+offsetX,py=(this.y+y)*blockSize+offsetY;
context.fillStyle=this.color;
context.fillRect(px,py,blockSize-1,blockSize-1);
context.fillStyle='rgba(255,255,255,0.3)';
context.fillRect(px,py,blockSize-1,blockSize/3)
}
})
})
}
hardDrop(){while(this.move(0,1)){}this.lock()}
lock(){
this.shape.forEach((row,y)=>{
row.forEach((value,x)=>{
if(value){
const by=this.y+y,bx=this.x+x;
if(by>=0){
board[by][bx]=this.color;
const cx=bx*BS+BS/2,cy=by*BS+BS/2;
for(let i=0;i<3;i++)particles.push(new Glitter(cx,cy,this.color))
}
}
})
});
clearLines();
spawnPiece();
canHold=true
}
}
const initBoard=()=>board=Array(ROWS).fill().map(()=>Array(COLS).fill(0));
const drawBoard=()=>{
ctx.fillStyle='#000';
ctx.fillRect(0,0,c.width,c.height);
board.forEach((row,y)=>{
row.forEach((value,x)=>{
if(value){
ctx.fillStyle=value;
ctx.fillRect(x*BS,y*BS,BS-1,BS-1);
ctx.fillStyle='rgba(255,255,255,0.3)';
ctx.fillRect(x*BS,y*BS,BS-1,BS/3)
}
})
});
if(currentPiece){
let gy=currentPiece.y;
while(currentPiece.canMove(currentPiece.x,gy+1))gy++;
ctx.globalAlpha=.3;
currentPiece.shape.forEach((row,y)=>{
row.forEach((value,x)=>{
if(value){
ctx.fillStyle=currentPiece.color;
ctx.fillRect((currentPiece.x+x)*BS,(gy+y)*BS,BS-1,BS-1)
}
})
});
ctx.globalAlpha=1
}
};
const drawPiecePreview=(piece,context,canvasEl)=>{
context.clearRect(0,0,canvasEl.width,canvasEl.height);
if(!piece)return;
const shape=SHAPES[piece],previewSize=15,offsetX=(canvasEl.width-shape[0].length*previewSize)/2,offsetY=(canvasEl.height-shape.length*previewSize)/2;
shape.forEach((row,y)=>{
row.forEach((value,x)=>{
if(value){
context.fillStyle=COLORS[piece];
context.fillRect(offsetX+x*previewSize,offsetY+y*previewSize,previewSize-1,previewSize-1)
}
})
})
};
const spawnPiece=()=>{
if(!nextPiece)nextPiece=randomPieceType();
currentPiece=new Piece(nextPiece);
nextPiece=randomPieceType();
drawPiecePreview(nextPiece,nctx,nc);
if(!currentPiece.canMove(currentPiece.x,currentPiece.y))gameOver()
};
const randomPieceType=()=>{const types=Object.keys(SHAPES);return types[Math.floor(Math.random()*types.length)]};
const clearLines=()=>{
let linesCleared=0;
for(let y=ROWS-1;y>=0;y--){
if(board[y].every(cell=>cell!==0)){
for(let x=0;x<COLS;x++){
const color=board[y][x],cx=x*BS+BS/2,cy=y*BS+BS/2;
for(let i=0;i<8;i++)particles.push(new Glitter(cx,cy,color))
}
board.splice(y,1);
board.unshift(Array(COLS).fill(0));
linesCleared++;
y++
}
}
if(linesCleared>0){
lines+=linesCleared;
score+=[0,100,300,500,800][linesCleared]*level;
level=Math.floor(lines/10)+1;
dropInterval=Math.max(100,1e3-(level-1)*50);
updateUI()
}
};
const holdCurrentPiece=()=>{
if(!canHold)return;
canHold=false;
if(!holdPiece){holdPiece=currentPiece.type;spawnPiece()}
else{const temp=holdPiece;holdPiece=currentPiece.type;currentPiece=new Piece(temp)}
drawPiecePreview(holdPiece,hctx,hc)
};
const update=(time=0)=>{
if(!gameRunning||paused){requestAnimationFrame(update);return}
const deltaTime=time-lastTime;
lastTime=time;
dropCounter+=deltaTime;
if(dropCounter>dropInterval){if(!currentPiece.move(0,1))currentPiece.lock();dropCounter=0}
particles=particles.filter(p=>{p.update();return!p.isDead()});
drawBoard();
if(currentPiece)currentPiece.draw(ctx);
particles.forEach(p=>p.draw());
requestAnimationFrame(update)
};
const updateUI=()=>{
document.getElementById('score').textContent=score;
document.getElementById('lines').textContent=lines;
document.getElementById('level').textContent=level
};
const startGame=()=>{
gameRunning=true;
paused=false;
score=0;
lines=0;
level=1;
dropInterval=1e3;
dropCounter=0;
holdPiece=null;
canHold=true;
particles=[];
initBoard();
nextPiece=randomPieceType();
spawnPiece();
hctx.clearRect(0,0,hc.width,hc.height);
document.getElementById('gameOverScreen').classList.remove('show');
document.getElementById('pauseOverlay').classList.remove('show');
updateUI();
lastTime=0;
requestAnimationFrame(update);
const hint=document.getElementById('swipeHint');
hint.classList.add('show');
setTimeout(()=>hint.classList.remove('show'),3e3)
};
const togglePause=()=>{
if(!gameRunning)return;
paused=!paused;
document.getElementById('pauseOverlay').classList.toggle('show',paused)
};
const gameOver=()=>{
gameRunning=false;
document.getElementById('finalScore').textContent=score;
document.getElementById('finalLines').textContent=lines;
document.getElementById('finalLevel').textContent=level;
document.getElementById('gameOverScreen').classList.add('show')
};
document.getElementById('btnLeft').addEventListener('touchstart',e=>{e.preventDefault();if(currentPiece)currentPiece.move(-1,0)});
document.getElementById('btnRight').addEventListener('touchstart',e=>{e.preventDefault();if(currentPiece)currentPiece.move(1,0)});
document.getElementById('btnRotate').addEventListener('touchstart',e=>{e.preventDefault();if(currentPiece)currentPiece.rotate()});
document.getElementById('btnDrop').addEventListener('touchstart',e=>{e.preventDefault();if(currentPiece)currentPiece.hardDrop()});
document.getElementById('btnHold').addEventListener('touchstart',e=>{e.preventDefault();holdCurrentPiece()});
document.getElementById('btnPause').addEventListener('touchstart',e=>{e.preventDefault();togglePause()});
c.addEventListener('touchstart',e=>{
e.preventDefault();
const touch=e.touches[0];
touchStartX=touch.clientX;
touchStartY=touch.clientY;
touchStartTime=Date.now()
});
c.addEventListener('touchmove',e=>e.preventDefault());
c.addEventListener('touchend',e=>{
e.preventDefault();
if(!currentPiece||paused)return;
const touch=e.changedTouches[0],dx=touch.clientX-touchStartX,dy=touch.clientY-touchStartY,dt=Date.now()-touchStartTime;
if(Math.abs(dx)<10&&Math.abs(dy)<10&&dt<200){currentPiece.rotate();return}
if(Math.abs(dx)>Math.abs(dy)){if(Math.abs(dx)>30){if(dx>0)currentPiece.move(1,0);else currentPiece.move(-1,0)}}
else{if(dy>50)currentPiece.hardDrop();else if(dy<-50)holdCurrentPiece()}
});
document.addEventListener('keydown',e=>{
if(!currentPiece||!gameRunning||paused)return;
switch(e.key){
case 'ArrowLeft':e.preventDefault();currentPiece.move(-1,0);break;
case 'ArrowRight':e.preventDefault();currentPiece.move(1,0);break;
case 'ArrowDown':e.preventDefault();currentPiece.move(0,1);break;
case 'ArrowUp':case ' ':e.preventDefault();currentPiece.rotate();break;
case 'c':case 'C':e.preventDefault();holdCurrentPiece();break;
case 'p':case 'P':e.preventDefault();togglePause();break;
}
});
startGame()
</script>
<script src="/sloppy-header/sloppy-bar.js"></script>
<script src="/vibelib-extended.js"></script>
<script>
  // Compatibility Patch for Legacy Apps
  window.addEventListener("load", () => {
    if (window.SloppyKarma && window.VibeLib.Economy) {
      // Redirect old calls to new engine
      window.SloppyKarma.track = window.VibeLib.Economy.track;
    }
  });
</script>
</body>
</html>
