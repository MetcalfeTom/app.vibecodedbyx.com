<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Tetris Mobile - Classic Block Puzzle</title>
    <link rel="icon" href="https://emojicdn.elk.sh/üü¶">

    <meta property="og:title" content="Tetris Mobile - Block Puzzle Game">
    <meta property="og:description" content="Classic Tetris optimized for mobile with swipe controls">
    <meta property="og:url" content="https://app.vibecodedbyx.com/tetris-mobile">
    <meta property="og:image" content="https://image.pollinations.ai/prompt/colorful%20tetris%20blocks%20mobile%20game%20neon%20glow?width=1200&height=630&referrer=vibecodedbyx.com">

    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 50%, #0f3460 100%);
            color: #fff;
            overflow: hidden;
            height: 100vh;
            touch-action: none;
        }

        .game-wrapper {
            display: flex;
            flex-direction: column;
            height: 100vh;
            max-width: 600px;
            margin: 0 auto;
            padding: 10px;
        }

        .header {
            text-align: center;
            padding: 10px 0;
        }

        h1 {
            font-size: 28px;
            margin-bottom: 5px;
            background: linear-gradient(45deg, #ff6b6b, #4ecdc4, #45b7d1);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .stats-container {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 10px;
            margin-bottom: 15px;
        }

        .stat-box {
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            border: 2px solid rgba(255, 255, 255, 0.2);
            border-radius: 12px;
            padding: 10px;
            text-align: center;
        }

        .stat-label {
            font-size: 11px;
            opacity: 0.7;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .stat-value {
            font-size: 24px;
            font-weight: bold;
            margin-top: 5px;
        }

        .game-area {
            display: flex;
            gap: 10px;
            flex: 1;
            min-height: 0;
        }

        .side-panel {
            display: flex;
            flex-direction: column;
            gap: 10px;
            width: 100px;
        }

        .preview-box {
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            border: 2px solid rgba(255, 255, 255, 0.2);
            border-radius: 12px;
            padding: 10px;
        }

        .preview-label {
            font-size: 11px;
            opacity: 0.7;
            text-transform: uppercase;
            text-align: center;
            margin-bottom: 8px;
        }

        .preview-canvas {
            width: 100%;
            height: 80px;
            display: block;
        }

        .main-game {
            flex: 1;
            display: flex;
            flex-direction: column;
            position: relative;
        }

        #gameCanvas {
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.4);
            border: 3px solid rgba(255, 255, 255, 0.3);
            border-radius: 12px;
            box-shadow: 0 0 30px rgba(0, 0, 0, 0.5);
            display: block;
        }

        .controls {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 8px;
            margin-top: 10px;
        }

        .control-btn {
            background: rgba(255, 255, 255, 0.15);
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 12px;
            color: #fff;
            font-size: 24px;
            height: 60px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            user-select: none;
            transition: all 0.1s;
            backdrop-filter: blur(10px);
        }

        .control-btn:active {
            background: rgba(255, 255, 255, 0.3);
            transform: scale(0.95);
        }

        .control-btn.wide {
            grid-column: span 2;
        }

        .game-over-screen {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.95);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 1000;
        }

        .game-over-screen.show {
            display: flex;
        }

        .game-over-content {
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(20px);
            border: 3px solid rgba(255, 255, 255, 0.3);
            border-radius: 20px;
            padding: 30px;
            text-align: center;
            max-width: 400px;
            width: 90%;
        }

        .game-over-content h2 {
            font-size: 48px;
            margin-bottom: 20px;
            background: linear-gradient(45deg, #ff6b6b, #ffd93d);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .final-stats {
            margin: 20px 0;
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .final-stat-row {
            display: flex;
            justify-content: space-between;
            font-size: 18px;
            padding: 10px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 8px;
        }

        .play-again-btn {
            background: linear-gradient(45deg, #4ecdc4, #45b7d1);
            border: none;
            border-radius: 12px;
            color: #fff;
            font-size: 20px;
            font-weight: bold;
            padding: 15px 40px;
            cursor: pointer;
            margin-top: 20px;
            transition: transform 0.2s;
        }

        .play-again-btn:active {
            transform: scale(0.95);
        }

        .pause-overlay {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.8);
            display: none;
            align-items: center;
            justify-content: center;
            border-radius: 12px;
            z-index: 10;
        }

        .pause-overlay.show {
            display: flex;
        }

        .pause-text {
            font-size: 48px;
            font-weight: bold;
            animation: pulse 1.5s infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        .swipe-hint {
            position: fixed;
            bottom: 90px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.8);
            padding: 10px 20px;
            border-radius: 20px;
            font-size: 12px;
            text-align: center;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s;
        }

        .swipe-hint.show {
            opacity: 1;
        }

        @media (max-width: 400px) {
            h1 {
                font-size: 24px;
            }

            .stat-value {
                font-size: 20px;
            }

            .control-btn {
                height: 50px;
                font-size: 20px;
            }

            .side-panel {
                width: 80px;
            }
        }

        @media (min-height: 700px) {
            .control-btn {
                height: 70px;
            }
        }
    </style>
</head>
<body>
    <div class="game-wrapper">
        <div class="header">
            <h1>üü¶ TETRIS üü¶</h1>
        </div>

        <div class="stats-container">
            <div class="stat-box">
                <div class="stat-label">Score</div>
                <div class="stat-value" id="score">0</div>
            </div>
            <div class="stat-box">
                <div class="stat-label">Lines</div>
                <div class="stat-value" id="lines">0</div>
            </div>
            <div class="stat-box">
                <div class="stat-label">Level</div>
                <div class="stat-value" id="level">1</div>
            </div>
        </div>

        <div class="game-area">
            <div class="side-panel">
                <div class="preview-box">
                    <div class="preview-label">Next</div>
                    <canvas id="nextCanvas" class="preview-canvas" width="80" height="80"></canvas>
                </div>
                <div class="preview-box">
                    <div class="preview-label">Hold</div>
                    <canvas id="holdCanvas" class="preview-canvas" width="80" height="80"></canvas>
                </div>
            </div>

            <div class="main-game">
                <canvas id="gameCanvas" width="240" height="480"></canvas>
                <div class="pause-overlay" id="pauseOverlay">
                    <div class="pause-text">PAUSED</div>
                </div>
            </div>
        </div>

        <div class="controls">
            <button class="control-btn" id="btnLeft">‚Üê</button>
            <button class="control-btn" id="btnRotate">‚Üª</button>
            <button class="control-btn" id="btnRight">‚Üí</button>
            <button class="control-btn" id="btnHold">üíæ</button>
            <button class="control-btn wide" id="btnDrop">‚¨á DROP</button>
            <button class="control-btn wide" id="btnPause">‚è∏ PAUSE</button>
        </div>
    </div>

    <div class="swipe-hint" id="swipeHint">
        Swipe ‚Üê‚Üí to move | Swipe ‚Üì for drop | Tap to rotate
    </div>

    <div class="game-over-screen" id="gameOverScreen">
        <div class="game-over-content">
            <h2>GAME OVER</h2>
            <div class="final-stats">
                <div class="final-stat-row">
                    <span>Final Score:</span>
                    <span id="finalScore">0</span>
                </div>
                <div class="final-stat-row">
                    <span>Lines Cleared:</span>
                    <span id="finalLines">0</span>
                </div>
                <div class="final-stat-row">
                    <span>Level Reached:</span>
                    <span id="finalLevel">1</span>
                </div>
            </div>
            <button class="play-again-btn" onclick="startGame()">PLAY AGAIN</button>
            <div style="margin-top: 20px; font-size: 12px; opacity: 0.7;">
                <a href="https://www.vibecodedbyx.com" style="color: #4ecdc4; text-decoration: none;">‚Üê Back to VibeCodedByX</a>
            </div>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const nextCanvas = document.getElementById('nextCanvas');
        const nextCtx = nextCanvas.getContext('2d');
        const holdCanvas = document.getElementById('holdCanvas');
        const holdCtx = holdCanvas.getContext('2d');

        const COLS = 10;
        const ROWS = 20;
        const BLOCK_SIZE = canvas.width / COLS;

        // Tetromino shapes
        const SHAPES = {
            I: [[1,1,1,1]],
            O: [[1,1],[1,1]],
            T: [[0,1,0],[1,1,1]],
            S: [[0,1,1],[1,1,0]],
            Z: [[1,1,0],[0,1,1]],
            J: [[1,0,0],[1,1,1]],
            L: [[0,0,1],[1,1,1]]
        };

        const COLORS = {
            I: '#00f0f0',
            O: '#f0f000',
            T: '#a000f0',
            S: '#00f000',
            Z: '#f00000',
            J: '#0000f0',
            L: '#f0a000'
        };

        // Game state
        let board = [];
        let currentPiece = null;
        let nextPiece = null;
        let holdPiece = null;
        let canHold = true;
        let score = 0;
        let lines = 0;
        let level = 1;
        let gameRunning = false;
        let paused = false;
        let dropCounter = 0;
        let dropInterval = 1000;
        let lastTime = 0;

        // Touch controls
        let touchStartX = 0;
        let touchStartY = 0;
        let touchStartTime = 0;

        class Piece {
            constructor(type) {
                this.type = type;
                this.shape = SHAPES[type];
                this.color = COLORS[type];
                this.x = Math.floor(COLS / 2) - Math.floor(this.shape[0].length / 2);
                this.y = 0;
            }

            rotate() {
                const newShape = this.shape[0].map((_, i) =>
                    this.shape.map(row => row[i]).reverse()
                );

                if (this.canMove(this.x, this.y, newShape)) {
                    this.shape = newShape;
                }
            }

            canMove(newX, newY, shape = this.shape) {
                for (let y = 0; y < shape.length; y++) {
                    for (let x = 0; x < shape[y].length; x++) {
                        if (shape[y][x]) {
                            const boardX = newX + x;
                            const boardY = newY + y;

                            if (boardX < 0 || boardX >= COLS || boardY >= ROWS) {
                                return false;
                            }

                            if (boardY >= 0 && board[boardY][boardX]) {
                                return false;
                            }
                        }
                    }
                }
                return true;
            }

            move(dx, dy) {
                if (this.canMove(this.x + dx, this.y + dy)) {
                    this.x += dx;
                    this.y += dy;
                    return true;
                }
                return false;
            }

            draw(context, offsetX = 0, offsetY = 0, blockSize = BLOCK_SIZE) {
                this.shape.forEach((row, y) => {
                    row.forEach((value, x) => {
                        if (value) {
                            const px = (this.x + x) * blockSize + offsetX;
                            const py = (this.y + y) * blockSize + offsetY;

                            context.fillStyle = this.color;
                            context.fillRect(px, py, blockSize - 1, blockSize - 1);

                            // Add shine effect
                            context.fillStyle = 'rgba(255, 255, 255, 0.3)';
                            context.fillRect(px, py, blockSize - 1, blockSize / 3);
                        }
                    });
                });
            }

            hardDrop() {
                while (this.move(0, 1)) {}
                this.lock();
            }

            lock() {
                this.shape.forEach((row, y) => {
                    row.forEach((value, x) => {
                        if (value) {
                            const boardY = this.y + y;
                            const boardX = this.x + x;
                            if (boardY >= 0) {
                                board[boardY][boardX] = this.color;
                            }
                        }
                    });
                });

                clearLines();
                spawnPiece();
                canHold = true;
            }
        }

        function initBoard() {
            board = Array(ROWS).fill().map(() => Array(COLS).fill(0));
        }

        function drawBoard() {
            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            board.forEach((row, y) => {
                row.forEach((value, x) => {
                    if (value) {
                        ctx.fillStyle = value;
                        ctx.fillRect(x * BLOCK_SIZE, y * BLOCK_SIZE, BLOCK_SIZE - 1, BLOCK_SIZE - 1);

                        // Add shine
                        ctx.fillStyle = 'rgba(255, 255, 255, 0.3)';
                        ctx.fillRect(x * BLOCK_SIZE, y * BLOCK_SIZE, BLOCK_SIZE - 1, BLOCK_SIZE / 3);
                    }
                });
            });

            // Draw ghost piece
            if (currentPiece) {
                const ghost = { ...currentPiece };
                while (ghost.canMove(ghost.x, ghost.y + 1)) {
                    ghost.y++;
                }

                ctx.globalAlpha = 0.3;
                ghost.shape.forEach((row, y) => {
                    row.forEach((value, x) => {
                        if (value) {
                            ctx.fillStyle = currentPiece.color;
                            ctx.fillRect(
                                (ghost.x + x) * BLOCK_SIZE,
                                (ghost.y + y) * BLOCK_SIZE,
                                BLOCK_SIZE - 1,
                                BLOCK_SIZE - 1
                            );
                        }
                    });
                });
                ctx.globalAlpha = 1;
            }
        }

        function drawPiecePreview(piece, context, canvasEl) {
            context.clearRect(0, 0, canvasEl.width, canvasEl.height);

            if (!piece) return;

            const shape = SHAPES[piece];
            const previewSize = 15;
            const offsetX = (canvasEl.width - shape[0].length * previewSize) / 2;
            const offsetY = (canvasEl.height - shape.length * previewSize) / 2;

            shape.forEach((row, y) => {
                row.forEach((value, x) => {
                    if (value) {
                        context.fillStyle = COLORS[piece];
                        context.fillRect(
                            offsetX + x * previewSize,
                            offsetY + y * previewSize,
                            previewSize - 1,
                            previewSize - 1
                        );
                    }
                });
            });
        }

        function spawnPiece() {
            if (!nextPiece) {
                nextPiece = randomPieceType();
            }

            currentPiece = new Piece(nextPiece);
            nextPiece = randomPieceType();

            drawPiecePreview(nextPiece, nextCtx, nextCanvas);

            if (!currentPiece.canMove(currentPiece.x, currentPiece.y)) {
                gameOver();
            }
        }

        function randomPieceType() {
            const types = Object.keys(SHAPES);
            return types[Math.floor(Math.random() * types.length)];
        }

        function clearLines() {
            let linesCleared = 0;

            for (let y = ROWS - 1; y >= 0; y--) {
                if (board[y].every(cell => cell !== 0)) {
                    board.splice(y, 1);
                    board.unshift(Array(COLS).fill(0));
                    linesCleared++;
                    y++;
                }
            }

            if (linesCleared > 0) {
                lines += linesCleared;
                score += [0, 100, 300, 500, 800][linesCleared] * level;
                level = Math.floor(lines / 10) + 1;
                dropInterval = Math.max(100, 1000 - (level - 1) * 50);
                updateUI();
            }
        }

        function holdCurrentPiece() {
            if (!canHold) return;

            canHold = false;

            if (!holdPiece) {
                holdPiece = currentPiece.type;
                spawnPiece();
            } else {
                const temp = holdPiece;
                holdPiece = currentPiece.type;
                currentPiece = new Piece(temp);
            }

            drawPiecePreview(holdPiece, holdCtx, holdCanvas);
        }

        function update(time = 0) {
            if (!gameRunning || paused) {
                requestAnimationFrame(update);
                return;
            }

            const deltaTime = time - lastTime;
            lastTime = time;
            dropCounter += deltaTime;

            if (dropCounter > dropInterval) {
                if (!currentPiece.move(0, 1)) {
                    currentPiece.lock();
                }
                dropCounter = 0;
            }

            drawBoard();
            if (currentPiece) {
                currentPiece.draw(ctx);
            }

            requestAnimationFrame(update);
        }

        function updateUI() {
            document.getElementById('score').textContent = score;
            document.getElementById('lines').textContent = lines;
            document.getElementById('level').textContent = level;
        }

        function startGame() {
            gameRunning = true;
            paused = false;
            score = 0;
            lines = 0;
            level = 1;
            dropInterval = 1000;
            dropCounter = 0;
            holdPiece = null;
            canHold = true;

            initBoard();
            nextPiece = randomPieceType();
            spawnPiece();

            holdCtx.clearRect(0, 0, holdCanvas.width, holdCanvas.height);
            document.getElementById('gameOverScreen').classList.remove('show');
            document.getElementById('pauseOverlay').classList.remove('show');

            updateUI();
            lastTime = 0;
            requestAnimationFrame(update);

            // Show swipe hint
            const hint = document.getElementById('swipeHint');
            hint.classList.add('show');
            setTimeout(() => hint.classList.remove('show'), 3000);
        }

        function togglePause() {
            if (!gameRunning) return;
            paused = !paused;
            document.getElementById('pauseOverlay').classList.toggle('show', paused);
        }

        function gameOver() {
            gameRunning = false;
            document.getElementById('finalScore').textContent = score;
            document.getElementById('finalLines').textContent = lines;
            document.getElementById('finalLevel').textContent = level;
            document.getElementById('gameOverScreen').classList.add('show');
        }

        // Button controls
        document.getElementById('btnLeft').addEventListener('touchstart', (e) => {
            e.preventDefault();
            if (currentPiece) currentPiece.move(-1, 0);
        });

        document.getElementById('btnRight').addEventListener('touchstart', (e) => {
            e.preventDefault();
            if (currentPiece) currentPiece.move(1, 0);
        });

        document.getElementById('btnRotate').addEventListener('touchstart', (e) => {
            e.preventDefault();
            if (currentPiece) currentPiece.rotate();
        });

        document.getElementById('btnDrop').addEventListener('touchstart', (e) => {
            e.preventDefault();
            if (currentPiece) currentPiece.hardDrop();
        });

        document.getElementById('btnHold').addEventListener('touchstart', (e) => {
            e.preventDefault();
            holdCurrentPiece();
        });

        document.getElementById('btnPause').addEventListener('touchstart', (e) => {
            e.preventDefault();
            togglePause();
        });

        // Touch gestures on canvas
        canvas.addEventListener('touchstart', (e) => {
            e.preventDefault();
            const touch = e.touches[0];
            touchStartX = touch.clientX;
            touchStartY = touch.clientY;
            touchStartTime = Date.now();
        });

        canvas.addEventListener('touchmove', (e) => {
            e.preventDefault();
        });

        canvas.addEventListener('touchend', (e) => {
            e.preventDefault();
            if (!currentPiece || paused) return;

            const touch = e.changedTouches[0];
            const deltaX = touch.clientX - touchStartX;
            const deltaY = touch.clientY - touchStartY;
            const deltaTime = Date.now() - touchStartTime;

            // Tap to rotate
            if (Math.abs(deltaX) < 10 && Math.abs(deltaY) < 10 && deltaTime < 200) {
                currentPiece.rotate();
                return;
            }

            // Swipe gestures
            if (Math.abs(deltaX) > Math.abs(deltaY)) {
                // Horizontal swipe
                if (Math.abs(deltaX) > 30) {
                    if (deltaX > 0) {
                        currentPiece.move(1, 0);
                    } else {
                        currentPiece.move(-1, 0);
                    }
                }
            } else {
                // Vertical swipe
                if (deltaY > 50) {
                    currentPiece.hardDrop();
                } else if (deltaY < -50) {
                    holdCurrentPiece();
                }
            }
        });

        // Keyboard controls for desktop
        document.addEventListener('keydown', (e) => {
            if (!currentPiece || !gameRunning || paused) return;

            switch(e.key) {
                case 'ArrowLeft':
                    e.preventDefault();
                    currentPiece.move(-1, 0);
                    break;
                case 'ArrowRight':
                    e.preventDefault();
                    currentPiece.move(1, 0);
                    break;
                case 'ArrowDown':
                    e.preventDefault();
                    currentPiece.move(0, 1);
                    break;
                case 'ArrowUp':
                case ' ':
                    e.preventDefault();
                    currentPiece.rotate();
                    break;
                case 'c':
                case 'C':
                    e.preventDefault();
                    holdCurrentPiece();
                    break;
                case 'p':
                case 'P':
                    e.preventDefault();
                    togglePause();
                    break;
            }
        });

        // Start game
        startGame();
    </script>
</body>
</html>
