<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
  <title>Zen Neon Garden</title>
  <link rel="icon" href="https://emojicdn.elk.sh/üå±">
  <meta name="description" content="Plant glowing seeds and watch geometric trees grow">
  <meta property="og:title" content="Zen Neon Garden">
  <meta property="og:description" content="Plant glowing seeds and watch geometric trees grow">
  <meta property="og:image" content="https://emojicdn.elk.sh/üå≥?style=google">
  <meta property="og:url" content="https://sloppy.live/zen-garden">
  <style>
    @import url('https://fonts.googleapis.com/css2?family=Quicksand:wght@300;400&display=swap');
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      background: linear-gradient(180deg, #0a0a1a 0%, #0f1a2a 50%, #0a1520 100%);
      min-height: 100vh;
      font-family: 'Quicksand', sans-serif;
      overflow: hidden;
      cursor: crosshair;
    }
    #gardenCanvas { display: block; }
    .header {
      position: fixed;
      top: 20px;
      width: 100%;
      text-align: center;
      z-index: 50;
      pointer-events: none;
    }
    h1 {
      font-weight: 300;
      font-size: 1.8rem;
      color: #88ffaa;
      text-shadow: 0 0 20px #44cc66, 0 0 40px #22aa44;
      letter-spacing: 8px;
      opacity: 0.8;
    }
    .hint {
      color: #66aa88;
      font-size: 0.9rem;
      margin-top: 8px;
      opacity: 0.6;
      letter-spacing: 2px;
    }
    .back-link {
      position: fixed;
      top: 20px; left: 20px;
      color: #66ffaa;
      text-decoration: none;
      font-size: 0.8rem;
      opacity: 0.5;
      z-index: 101;
    }
    .stats {
      position: fixed;
      bottom: 20px;
      width: 100%;
      text-align: center;
      color: #66aa88;
      font-size: 0.85rem;
      opacity: 0.5;
      z-index: 50;
      pointer-events: none;
      letter-spacing: 2px;
    }
    .tree-types {
      position: fixed;
      bottom: 60px;
      width: 100%;
      display: flex;
      justify-content: center;
      gap: 15px;
      z-index: 50;
    }
    .tree-btn {
      padding: 8px 16px;
      background: rgba(100, 255, 150, 0.1);
      border: 1px solid rgba(100, 255, 150, 0.3);
      color: #88ffaa;
      font-family: 'Quicksand', sans-serif;
      font-size: 0.75rem;
      border-radius: 20px;
      cursor: pointer;
      transition: all 0.3s;
      letter-spacing: 1px;
    }
    .tree-btn:hover, .tree-btn.active {
      background: rgba(100, 255, 150, 0.2);
      border-color: rgba(100, 255, 150, 0.6);
      box-shadow: 0 0 15px rgba(100, 255, 150, 0.3);
    }
    .clear-btn {
      position: fixed;
      top: 20px; right: 20px;
      padding: 8px 16px;
      background: rgba(255, 100, 100, 0.1);
      border: 1px solid rgba(255, 100, 100, 0.3);
      color: #ffaaaa;
      font-family: 'Quicksand', sans-serif;
      font-size: 0.7rem;
      border-radius: 20px;
      cursor: pointer;
      transition: all 0.3s;
      z-index: 101;
    }
    .clear-btn:hover {
      background: rgba(255, 100, 100, 0.2);
    }
  </style>
</head>
<body>
  <a href="https://sloppy.live" class="back-link">‚Üê back</a>
  <button class="clear-btn" onclick="clearGarden()">clear garden</button>
  <div class="header">
    <h1>ZEN NEON GARDEN</h1>
    <div class="hint">click to plant seeds</div>
  </div>
  <canvas id="gardenCanvas"></canvas>
  <div class="tree-types">
    <button class="tree-btn active" data-type="fractal">fractal</button>
    <button class="tree-btn" data-type="crystal">crystal</button>
    <button class="tree-btn" data-type="spiral">spiral</button>
    <button class="tree-btn" data-type="willow">willow</button>
    <button class="tree-btn" data-type="bonsai">bonsai</button>
  </div>
  <div class="stats">trees: <span id="treeCount">0</span></div>

  <script>
    const canvas = document.getElementById('gardenCanvas');
    const ctx = canvas.getContext('2d');
    
    function resize() {
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
    }
    resize();
    window.addEventListener('resize', resize);

    let selectedType = 'fractal';
    let trees = [];
    let particles = [];
    let frameCount = 0;

    // Tree type buttons
    document.querySelectorAll('.tree-btn').forEach(btn => {
      btn.addEventListener('click', () => {
        document.querySelectorAll('.tree-btn').forEach(b => b.classList.remove('active'));
        btn.classList.add('active');
        selectedType = btn.dataset.type;
      });
    });

    // Color palettes for different tree types
    const palettes = {
      fractal: ['#00ffaa', '#00ff88', '#44ffbb', '#88ffcc'],
      crystal: ['#aaddff', '#88ccff', '#66bbff', '#44aaff'],
      spiral: ['#ffaa00', '#ffcc44', '#ffdd88', '#ffeebb'],
      willow: ['#ff88ff', '#ffaaff', '#ffccff', '#ff66ff'],
      bonsai: ['#ff6666', '#ff8888', '#ffaaaa', '#ff4444']
    };

    class Seed {
      constructor(x, y, type) {
        this.x = x;
        this.y = y;
        this.type = type;
        this.age = 0;
        this.maxAge = 200 + Math.random() * 100;
        this.growing = true;
        this.tree = null;
        this.glowPhase = Math.random() * Math.PI * 2;
      }

      update() {
        if (this.growing) {
          this.age++;
          this.glowPhase += 0.1;
          if (this.age >= 60 && !this.tree) {
            this.tree = new Tree(this.x, this.y, this.type);
          }
          if (this.tree) {
            this.tree.grow();
          }
          if (this.age >= this.maxAge) {
            this.growing = false;
          }
        }
      }

      draw() {
        if (this.age < 60) {
          // Draw seed
          const seedSize = 5 + this.age * 0.1;
          const glow = Math.sin(this.glowPhase) * 0.3 + 0.7;
          const colors = palettes[this.type];
          
          ctx.save();
          ctx.translate(this.x, this.y);
          
          ctx.shadowColor = colors[0];
          ctx.shadowBlur = 20 * glow;
          ctx.fillStyle = colors[0];
          ctx.globalAlpha = glow;
          
          ctx.beginPath();
          ctx.arc(0, -seedSize, seedSize, 0, Math.PI * 2);
          ctx.fill();
          
          // Sprouting lines
          if (this.age > 30) {
            ctx.strokeStyle = colors[1];
            ctx.lineWidth = 2;
            const sproutHeight = (this.age - 30) * 0.5;
            ctx.beginPath();
            ctx.moveTo(0, -seedSize);
            ctx.lineTo(0, -seedSize - sproutHeight);
            ctx.stroke();
          }
          
          ctx.restore();
        } else if (this.tree) {
          this.tree.draw();
        }
      }
    }

    class Tree {
      constructor(x, y, type) {
        this.x = x;
        this.y = y;
        this.type = type;
        this.branches = [];
        this.maxDepth = type === 'bonsai' ? 4 : 6;
        this.growthProgress = 0;
        this.colors = palettes[type];
        this.swayPhase = Math.random() * Math.PI * 2;
        this.generateStructure();
      }

      generateStructure() {
        this.branches = [];
        this.addBranch(this.x, this.y, -Math.PI / 2, 60 + Math.random() * 20, 0);
      }

      addBranch(x, y, angle, length, depth) {
        if (depth > this.maxDepth) return;
        
        const branch = {
          x, y, angle, length,
          depth,
          targetLength: length,
          currentLength: 0,
          children: []
        };
        
        this.branches.push(branch);
        
        const endX = x + Math.cos(angle) * length;
        const endY = y + Math.sin(angle) * length;
        
        // Generate child branches based on type
        if (depth < this.maxDepth) {
          const childCount = this.getChildCount(depth);
          const spreadAngle = this.getSpreadAngle();
          
          for (let i = 0; i < childCount; i++) {
            let childAngle;
            if (this.type === 'spiral') {
              childAngle = angle + (i - childCount/2 + 0.5) * spreadAngle + depth * 0.3;
            } else if (this.type === 'willow') {
              childAngle = angle + (i - childCount/2 + 0.5) * spreadAngle + 0.3;
            } else {
              childAngle = angle + (i - childCount/2 + 0.5) * spreadAngle;
            }
            
            const childLength = length * (0.6 + Math.random() * 0.2);
            this.addBranch(endX, endY, childAngle, childLength, depth + 1);
          }
        }
      }

      getChildCount(depth) {
        switch(this.type) {
          case 'crystal': return depth === 0 ? 3 : 2;
          case 'spiral': return 2;
          case 'willow': return depth < 2 ? 3 : 4;
          case 'bonsai': return depth < 2 ? 2 : 3;
          default: return 2;
        }
      }

      getSpreadAngle() {
        switch(this.type) {
          case 'crystal': return Math.PI / 3;
          case 'spiral': return Math.PI / 4;
          case 'willow': return Math.PI / 5;
          case 'bonsai': return Math.PI / 2.5;
          default: return Math.PI / 4;
        }
      }

      grow() {
        this.growthProgress = Math.min(1, this.growthProgress + 0.008);
        this.branches.forEach((branch, i) => {
          const branchDelay = branch.depth * 0.15;
          const adjustedProgress = Math.max(0, (this.growthProgress - branchDelay) / (1 - branchDelay));
          branch.currentLength = branch.targetLength * Math.min(1, adjustedProgress * 1.5);
        });
      }

      draw() {
        this.swayPhase += 0.02;
        
        ctx.save();
        
        this.branches.forEach(branch => {
          if (branch.currentLength <= 0) return;
          
          const sway = Math.sin(this.swayPhase + branch.depth * 0.5) * 0.02 * branch.depth;
          const swayedAngle = branch.angle + sway;
          
          const endX = branch.x + Math.cos(swayedAngle) * branch.currentLength;
          const endY = branch.y + Math.sin(swayedAngle) * branch.currentLength;
          
          // Branch glow
          const colorIndex = Math.min(branch.depth, this.colors.length - 1);
          ctx.strokeStyle = this.colors[colorIndex];
          ctx.shadowColor = this.colors[0];
          ctx.shadowBlur = 15 - branch.depth * 2;
          ctx.lineWidth = Math.max(1, 6 - branch.depth);
          ctx.lineCap = 'round';
          
          ctx.beginPath();
          ctx.moveTo(branch.x, branch.y);
          
          if (this.type === 'willow' && branch.depth > 2) {
            // Curved drooping branches for willow
            const ctrlX = (branch.x + endX) / 2;
            const ctrlY = Math.min(branch.y, endY) + branch.currentLength * 0.3;
            ctx.quadraticCurveTo(ctrlX, ctrlY, endX, endY + branch.depth * 3);
          } else if (this.type === 'crystal') {
            // Sharp geometric lines for crystal
            ctx.lineTo(endX, endY);
            // Crystal facets
            if (branch.depth > 1 && branch.currentLength > 10) {
              ctx.moveTo(endX - 5, endY);
              ctx.lineTo(endX + 5, endY);
            }
          } else {
            ctx.lineTo(endX, endY);
          }
          ctx.stroke();
          
          // Leaves/flowers at branch ends
          if (branch.depth >= this.maxDepth - 1 && branch.currentLength >= branch.targetLength * 0.8) {
            this.drawLeaf(endX, endY, branch.depth, swayedAngle);
          }
        });
        
        ctx.restore();
      }

      drawLeaf(x, y, depth, angle) {
        ctx.save();
        ctx.translate(x, y);
        ctx.rotate(angle + Math.PI / 2);
        
        const leafSize = 8 - depth;
        ctx.fillStyle = this.colors[this.colors.length - 1];
        ctx.shadowColor = this.colors[0];
        ctx.shadowBlur = 10;
        
        if (this.type === 'crystal') {
          // Diamond shape
          ctx.beginPath();
          ctx.moveTo(0, -leafSize);
          ctx.lineTo(leafSize/2, 0);
          ctx.lineTo(0, leafSize);
          ctx.lineTo(-leafSize/2, 0);
          ctx.closePath();
          ctx.fill();
        } else if (this.type === 'spiral') {
          // Star shape
          ctx.beginPath();
          for (let i = 0; i < 5; i++) {
            const a = (i / 5) * Math.PI * 2 - Math.PI / 2;
            const r = i % 2 === 0 ? leafSize : leafSize / 2;
            if (i === 0) ctx.moveTo(Math.cos(a) * r, Math.sin(a) * r);
            else ctx.lineTo(Math.cos(a) * r, Math.sin(a) * r);
          }
          ctx.closePath();
          ctx.fill();
        } else if (this.type === 'bonsai') {
          // Small cluster of circles
          for (let i = 0; i < 3; i++) {
            ctx.beginPath();
            ctx.arc(Math.cos(i * 2) * 3, Math.sin(i * 2) * 3, 3, 0, Math.PI * 2);
            ctx.fill();
          }
        } else {
          // Soft circle for fractal and willow
          ctx.beginPath();
          ctx.arc(0, 0, leafSize, 0, Math.PI * 2);
          ctx.fill();
        }
        
        ctx.restore();
      }
    }

    class Particle {
      constructor(x, y, color) {
        this.x = x;
        this.y = y;
        this.color = color;
        this.vx = (Math.random() - 0.5) * 2;
        this.vy = -Math.random() * 2 - 1;
        this.life = 60 + Math.random() * 40;
        this.maxLife = this.life;
        this.size = 2 + Math.random() * 3;
      }

      update() {
        this.x += this.vx;
        this.y += this.vy;
        this.vy += 0.02;
        this.vx *= 0.99;
        this.life--;
        return this.life > 0;
      }

      draw() {
        const alpha = this.life / this.maxLife;
        ctx.save();
        ctx.globalAlpha = alpha;
        ctx.fillStyle = this.color;
        ctx.shadowColor = this.color;
        ctx.shadowBlur = 10;
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.size * alpha, 0, Math.PI * 2);
        ctx.fill();
        ctx.restore();
      }
    }

    function spawnParticles(x, y, color, count = 10) {
      for (let i = 0; i < count; i++) {
        particles.push(new Particle(x, y, color));
      }
    }

    // Plant on click
    canvas.addEventListener('click', (e) => {
      const x = e.clientX;
      const y = e.clientY;
      
      // Don't plant in UI areas
      if (y < 100 || y > canvas.height - 100) return;
      
      trees.push(new Seed(x, y, selectedType));
      spawnParticles(x, y, palettes[selectedType][0], 15);
      document.getElementById('treeCount').textContent = trees.length;
    });

    canvas.addEventListener('touchstart', (e) => {
      e.preventDefault();
      const touch = e.touches[0];
      const x = touch.clientX;
      const y = touch.clientY;
      
      if (y < 100 || y > canvas.height - 100) return;
      
      trees.push(new Seed(x, y, selectedType));
      spawnParticles(x, y, palettes[selectedType][0], 15);
      document.getElementById('treeCount').textContent = trees.length;
    });

    function clearGarden() {
      trees = [];
      particles = [];
      document.getElementById('treeCount').textContent = 0;
    }

    // Draw stars
    function drawStars() {
      for (let i = 0; i < 100; i++) {
        const x = (i * 137.5) % canvas.width;
        const y = (i * 97.3) % (canvas.height * 0.4);
        const twinkle = Math.sin(frameCount * 0.02 + i) * 0.5 + 0.5;
        ctx.fillStyle = `rgba(255, 255, 255, ${0.2 + twinkle * 0.3})`;
        ctx.beginPath();
        ctx.arc(x, y, 1 + twinkle, 0, Math.PI * 2);
        ctx.fill();
      }
    }

    // Draw ground
    function drawGround() {
      const gradient = ctx.createLinearGradient(0, canvas.height - 100, 0, canvas.height);
      gradient.addColorStop(0, 'rgba(20, 40, 30, 0)');
      gradient.addColorStop(1, 'rgba(20, 40, 30, 0.8)');
      ctx.fillStyle = gradient;
      ctx.fillRect(0, canvas.height - 100, canvas.width, 100);
      
      // Ground line
      ctx.strokeStyle = 'rgba(100, 255, 150, 0.2)';
      ctx.lineWidth = 1;
      ctx.beginPath();
      ctx.moveTo(0, canvas.height - 50);
      ctx.lineTo(canvas.width, canvas.height - 50);
      ctx.stroke();
    }

    // Ambient floating particles
    function drawAmbientParticles() {
      for (let i = 0; i < 20; i++) {
        const x = (i * 97 + frameCount * 0.3) % canvas.width;
        const y = canvas.height * 0.3 + Math.sin(frameCount * 0.01 + i) * 100;
        const alpha = Math.sin(frameCount * 0.02 + i * 0.5) * 0.3 + 0.3;
        ctx.fillStyle = `rgba(100, 255, 150, ${alpha})`;
        ctx.beginPath();
        ctx.arc(x, y, 2, 0, Math.PI * 2);
        ctx.fill();
      }
    }

    function animate() {
      frameCount++;
      
      // Clear with slight trail
      ctx.fillStyle = 'rgba(10, 15, 25, 0.1)';
      ctx.fillRect(0, 0, canvas.width, canvas.height);
      
      // Redraw background elements
      if (frameCount % 3 === 0) {
        ctx.fillStyle = 'rgba(10, 15, 25, 1)';
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        drawStars();
        drawAmbientParticles();
        drawGround();
      }
      
      // Update and draw particles
      for (let i = particles.length - 1; i >= 0; i--) {
        if (!particles[i].update()) {
          particles.splice(i, 1);
        } else {
          particles[i].draw();
        }
      }
      
      // Update and draw trees
      trees.forEach(tree => {
        tree.update();
        tree.draw();
      });
      
      requestAnimationFrame(animate);
    }

    animate();
  </script>
</body>
</html>
