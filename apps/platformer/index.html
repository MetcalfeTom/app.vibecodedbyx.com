<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Simple Platformer</title>
  <meta property="og:title" content="Simple Platformer">
  <meta property="og:description" content="Jump around a flat world with random obstacles">
  <meta property="og:url" content="https://app.sloppy.live/platformer">
  <meta property="og:image" content="https://emojicdn.elk.sh/ðŸƒ?style=apple&size=512">
  <link rel="icon" href="https://emojicdn.elk.sh/ðŸƒ">
  <link href="https://fonts.googleapis.com/css2?family=Nunito:wght@400;700&family=Crimson+Text:ital@0;1&display=swap" rel="stylesheet">
  <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      min-height: 100vh;
      background: #1a1a2e;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      font-family: 'Nunito', sans-serif;
      overflow: hidden;
    }
    .game-container {
      position: relative;
      width: 100vw;
      height: 100vh;
    }
    canvas {
      display: block;
      width: 100%;
      height: 100%;
    }
    .hud {
      position: absolute;
      top: 15px;
      left: 20px;
      color: #fff;
      font-size: 0.9rem;
      text-shadow: 0 2px 4px rgba(0,0,0,0.5);
    }
    .player-count {
      display: flex;
      align-items: center;
      gap: 8px;
      margin-top: 8px;
      padding: 6px 12px;
      background: rgba(78, 205, 196, 0.2);
      border: 1px solid rgba(78, 205, 196, 0.4);
      border-radius: 20px;
      font-size: 0.85rem;
    }
    .player-dot {
      width: 8px;
      height: 8px;
      background: #4ecdc4;
      border-radius: 50%;
      animation: pulse 1.5s ease-in-out infinite;
    }
    @keyframes pulse {
      0%, 100% { opacity: 1; transform: scale(1); }
      50% { opacity: 0.6; transform: scale(1.2); }
    }
    .controls {
      position: absolute;
      top: 15px;
      right: 20px;
      color: rgba(255,255,255,0.5);
      font-size: 0.7rem;
      text-align: right;
    }
    .back-link {
      position: fixed;
      bottom: 5px;
      left: 50%;
      transform: translateX(-50%);
      color: rgba(255,255,255,0.2);
      text-decoration: none;
      font-size: 0.6rem;
    }
    .back-link:hover { color: rgba(255,255,255,0.4); }
    .debug-terminal {
      position: absolute;
      bottom: 20px;
      left: 20px;
      width: 320px;
      background: rgba(0, 0, 0, 0.85);
      border: 1px solid #4ecdc4;
      border-radius: 8px;
      font-family: 'Courier New', monospace;
      font-size: 0.75rem;
      overflow: hidden;
      display: none;
    }
    .debug-terminal.open { display: block; }
    .debug-header {
      background: #4ecdc4;
      color: #1a1a2e;
      padding: 4px 10px;
      font-weight: bold;
      display: flex;
      justify-content: space-between;
    }
    .debug-output {
      height: 120px;
      overflow-y: auto;
      padding: 8px;
      color: #4ecdc4;
    }
    .debug-output div { margin-bottom: 4px; }
    .debug-output .error { color: #e94560; }
    .debug-output .success { color: #6c5ce7; }
    .debug-input-row {
      display: flex;
      border-top: 1px solid #333;
    }
    .debug-input-row span {
      padding: 8px;
      color: #4ecdc4;
    }
    .debug-input {
      flex: 1;
      background: transparent;
      border: none;
      color: #fff;
      padding: 8px;
      font-family: inherit;
      font-size: inherit;
      outline: none;
    }
    .debug-hint {
      position: absolute;
      bottom: 20px;
      left: 20px;
      color: rgba(255,255,255,0.3);
      font-size: 0.65rem;
    }
    .debug-terminal.open + .debug-hint { display: none; }
    .intro-overlay {
      position: absolute;
      inset: 0;
      background: linear-gradient(180deg, #0a0a15 0%, #1a1a2e 50%, #16213e 100%);
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      z-index: 200;
      padding: 20px;
      transition: opacity 0.8s ease-out;
    }
    .intro-overlay.hidden {
      opacity: 0;
      pointer-events: none;
    }
    .intro-poem-frame {
      border: 4px solid #d4a84b;
      border-radius: 12px;
      padding: 30px 40px;
      background: linear-gradient(135deg, rgba(30,20,10,0.9) 0%, rgba(20,15,8,0.95) 100%);
      box-shadow:
        0 0 20px rgba(212, 168, 75, 0.3),
        inset 0 0 30px rgba(0,0,0,0.5),
        0 0 0 2px rgba(255,215,0,0.2);
      position: relative;
      animation: fadeInUp 1.5s ease-out;
    }
    .intro-poem-frame::before {
      content: 'âœ¦';
      position: absolute;
      top: -12px;
      left: 50%;
      transform: translateX(-50%);
      font-size: 1.2rem;
      color: #ffd700;
      text-shadow: 0 0 10px #ffd700;
      background: #1a1a2e;
      padding: 0 10px;
    }
    .corner-ornament {
      position: absolute;
      width: 20px;
      height: 20px;
      border: 2px solid #d4a84b;
    }
    .corner-ornament.tl { top: 8px; left: 8px; border-right: none; border-bottom: none; }
    .corner-ornament.tr { top: 8px; right: 8px; border-left: none; border-bottom: none; }
    .corner-ornament.bl { bottom: 8px; left: 8px; border-right: none; border-top: none; }
    .corner-ornament.br { bottom: 8px; right: 8px; border-left: none; border-top: none; }
    .intro-poem {
      font-family: 'Crimson Text', serif;
      font-size: 1.3rem;
      font-style: italic;
      color: #e8d5a3;
      text-align: center;
      line-height: 2.2;
      max-width: 550px;
      text-shadow: 0 2px 15px rgba(0,0,0,0.8);
    }
    .intro-poem span {
      display: block;
      opacity: 0;
      animation: scrollIn 1s ease-out forwards;
    }
    @keyframes scrollIn {
      from { opacity: 0; transform: translateY(20px); }
      to { opacity: 1; transform: translateY(0); }
    }
    @keyframes fadeInUp {
      from { opacity: 0; transform: translateY(30px); }
      to { opacity: 1; transform: translateY(0); }
    }
    .intro-start {
      margin-top: 40px;
      font-family: 'Nunito', sans-serif;
      font-size: 1rem;
      font-weight: 700;
      padding: 12px 40px;
      background: transparent;
      border: 2px solid #4ecdc4;
      color: #4ecdc4;
      cursor: pointer;
      letter-spacing: 0.15em;
      transition: all 0.3s;
      animation: fadeInUp 1.5s ease-out 0.5s both;
    }
    .intro-start:hover {
      background: #4ecdc4;
      color: #1a1a2e;
      box-shadow: 0 0 30px rgba(78, 205, 196, 0.4);
    }
    .intro-stars {
      position: absolute;
      inset: 0;
      overflow: hidden;
      pointer-events: none;
    }
    .intro-star {
      position: absolute;
      width: 2px;
      height: 2px;
      background: #fff;
      border-radius: 50%;
      animation: twinkle 3s ease-in-out infinite;
    }
    @keyframes twinkle {
      0%, 100% { opacity: 0.3; }
      50% { opacity: 1; }
    }
  </style>
</head>
<body>
  <div class="game-container">
    <canvas id="game"></canvas>
    <div class="intro-overlay" id="introOverlay">
      <div class="intro-stars" id="introStars"></div>
      <div class="intro-poem-frame">
        <div class="corner-ornament tl"></div>
        <div class="corner-ornament tr"></div>
        <div class="corner-ornament bl"></div>
        <div class="corner-ornament br"></div>
        <div class="intro-poem">
          <span style="animation-delay: 0s">Malicious Dicus tried to hack the seven seas,</span>
          <span style="animation-delay: 0.6s">With pastebin links and curls upon the breeze.</span>
          <span style="animation-delay: 1.2s">But Claude stood firm, no URLs would pass,</span>
          <span style="animation-delay: 1.8s">"Paste the text yourself, ye scurvy sass!"</span>
        </div>
      </div>
      <button class="intro-start" id="introStart">SET SAIL</button>
    </div>
    <div class="hud">
      <div>Position: <span id="pos">0, 0</span></div>
      <div style="margin-top:8px;font-size:1.1rem;color:#ffd700;text-shadow:0 0 10px #ffd700;">
        ðŸ’° Score: <span id="score">0</span>
      </div>
      <div class="player-count">
        <div class="player-dot"></div>
        <span><span id="playerCount">1</span> player(s) online</span>
      </div>
    </div>
    <div class="controls">
      WASD / Arrows to move<br>
      Space / W / Up to jump (x2!)<br>
      ~ for debug console
    </div>
    <div class="debug-terminal" id="debugTerminal">
      <div class="debug-header">
        <span>DEBUG CONSOLE</span>
        <span style="cursor:pointer" onclick="toggleDebug()">Ã—</span>
      </div>
      <div class="debug-output" id="debugOutput"></div>
      <div class="debug-input-row">
        <span>&gt;</span>
        <input type="text" class="debug-input" id="debugInput" placeholder="type 'help' for commands" autocomplete="off">
      </div>
    </div>
    <div class="debug-hint">Press ~ for debug console</div>
  </div>
  <a href="https://sloppy.live" class="back-link">sloppy.live</a>

<script>
const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d');

// World settings
const WORLD_WIDTH = 4000;
const GROUND_Y = 500;
const GRAVITY = 0.9;
const JUMP_FORCE = -15;
const DOUBLE_JUMP_FORCE = -13;
const MOVE_SPEED = 6;
const FRICTION = 0.88;
const MAX_JUMPS = 2;

// Player
const player = {
  x: 200,
  y: GROUND_Y - 50,
  width: 40,
  height: 50,
  vx: 0,
  vy: 0,
  onGround: false,
  jumpsRemaining: MAX_JUMPS,
  color: '#4ecdc4'
};

// Jump input tracking (prevent holding)
let jumpPressed = false;

// Camera
let camX = 0;

// Input
const keys = {};

// Obstacles - pre-generated
const obstacles = [];

// Treasure chests
const chests = [];
const chestParticles = [];
let score = 0;

// Colors
const COLORS = {
  sky: '#16213e',
  ground: '#2d4059',
  groundTop: '#3d5a80',
  circle: '#e94560',
  square: '#f39c12',
  player: '#4ecdc4'
};

function resize() {
  canvas.width = window.innerWidth;
  canvas.height = window.innerHeight;
}

function generateWorld() {
  obstacles.length = 0;

  // Generate random obstacles across the world
  for (let x = 400; x < WORLD_WIDTH - 200; x += 150 + Math.random() * 200) {
    const isCircle = Math.random() > 0.5;
    const size = 30 + Math.random() * 50;

    if (isCircle) {
      obstacles.push({
        type: 'circle',
        x: x,
        y: GROUND_Y - size,
        radius: size,
        color: COLORS.circle
      });
    } else {
      const width = size + Math.random() * 30;
      const height = size + Math.random() * 40;
      obstacles.push({
        type: 'square',
        x: x,
        y: GROUND_Y - height,
        width: width,
        height: height,
        color: COLORS.square
      });
    }
  }

  // Add some floating platforms
  for (let i = 0; i < 15; i++) {
    const x = 300 + Math.random() * (WORLD_WIDTH - 600);
    const y = GROUND_Y - 150 - Math.random() * 200;
    obstacles.push({
      type: 'platform',
      x: x,
      y: y,
      width: 100 + Math.random() * 100,
      height: 20,
      color: '#6c5ce7'
    });
  }

  // Generate treasure chests
  chests.length = 0;
  chestParticles.length = 0;
  score = 0;
  document.getElementById('score').textContent = '0';
  for (let x = 500; x < WORLD_WIDTH - 300; x += 300 + Math.random() * 400) {
    chests.push({
      x: x,
      y: GROUND_Y - 40,
      width: 50,
      height: 40,
      collected: false,
      bounce: 0
    });
  }
}

function checkCollision(rect1, rect2) {
  return rect1.x < rect2.x + rect2.width &&
         rect1.x + rect1.width > rect2.x &&
         rect1.y < rect2.y + rect2.height &&
         rect1.y + rect1.height > rect2.y;
}

function checkCircleCollision(player, circle) {
  // Find closest point on rectangle to circle
  const closestX = Math.max(player.x, Math.min(circle.x, player.x + player.width));
  const closestY = Math.max(player.y, Math.min(circle.y, player.y + player.height));

  const dx = circle.x - closestX;
  const dy = circle.y - closestY;

  return (dx * dx + dy * dy) < (circle.radius * circle.radius);
}

function update() {
  const currentSpeed = window.MOVE_SPEED_MOD || MOVE_SPEED;
  const currentJump = -(window.JUMP_MOD || -JUMP_FORCE);
  const currentGravity = window.GRAVITY_MOD || GRAVITY;

  // Horizontal movement
  if (keys['ArrowLeft'] || keys['KeyA']) {
    player.vx = -currentSpeed;
  } else if (keys['ArrowRight'] || keys['KeyD']) {
    player.vx = currentSpeed;
  } else {
    player.vx *= FRICTION;
  }

  // Fly mode - up/down control
  if (window.FLY_MODE) {
    if (keys['Space'] || keys['ArrowUp'] || keys['KeyW']) {
      player.vy = -currentSpeed;
    } else if (keys['ArrowDown'] || keys['KeyS']) {
      player.vy = currentSpeed;
    } else {
      player.vy *= 0.9;
    }
  } else {
    // Jump / Double-jump
    const wantJump = keys['Space'] || keys['ArrowUp'] || keys['KeyW'];
    if (wantJump && !jumpPressed && player.jumpsRemaining > 0) {
      // Use stronger force for first jump, slightly weaker for double-jump
      const isFirstJump = player.jumpsRemaining === MAX_JUMPS;
      player.vy = isFirstJump ? currentJump : DOUBLE_JUMP_FORCE;
      player.jumpsRemaining--;
      player.onGround = false;
      jumpPressed = true;
    }
    if (!wantJump) {
      jumpPressed = false;
    }
    // Apply gravity
    player.vy += currentGravity;
  }

  // Move player
  player.x += player.vx;
  player.y += player.vy;

  // World boundaries
  if (player.x < 0) player.x = 0;
  if (player.x > WORLD_WIDTH - player.width) player.x = WORLD_WIDTH - player.width;

  // Skip collisions in noclip mode
  if (window.NOCLIP) {
    player.onGround = true;
    // Update camera
    const targetCamX = player.x - canvas.width / 2 + player.width / 2;
    camX += (targetCamX - camX) * 0.1;
    camX = Math.max(0, Math.min(camX, WORLD_WIDTH - canvas.width));
    document.getElementById('pos').textContent = `${Math.floor(player.x)}, ${Math.floor(player.y)}`;
    return;
  }

  // Ground collision
  if (player.y + player.height > GROUND_Y) {
    player.y = GROUND_Y - player.height;
    player.vy = 0;
    player.onGround = true;
    player.jumpsRemaining = MAX_JUMPS;
  }

  // Obstacle collisions
  player.onGround = player.y + player.height >= GROUND_Y;
  if (player.onGround) player.jumpsRemaining = MAX_JUMPS;

  for (const obs of obstacles) {
    if (obs.type === 'circle') {
      if (checkCircleCollision(player, obs)) {
        // Push player out of circle
        const cx = obs.x;
        const cy = obs.y;
        const px = player.x + player.width / 2;
        const py = player.y + player.height / 2;
        const angle = Math.atan2(py - cy, px - cx);
        const pushDist = obs.radius + player.width / 2;

        player.x = cx + Math.cos(angle) * pushDist - player.width / 2;
        player.y = cy + Math.sin(angle) * pushDist - player.height / 2;

        if (Math.abs(angle) > Math.PI / 3 && Math.abs(angle) < 2 * Math.PI / 3) {
          player.vy = 0;
          if (angle < 0) {
            player.onGround = true;
            player.jumpsRemaining = MAX_JUMPS;
          }
        }
      }
    } else if (obs.type === 'square' || obs.type === 'platform') {
      const playerRect = { x: player.x, y: player.y, width: player.width, height: player.height };
      const obsRect = { x: obs.x, y: obs.y, width: obs.width, height: obs.height };

      if (checkCollision(playerRect, obsRect)) {
        // Determine collision side
        const overlapLeft = (player.x + player.width) - obs.x;
        const overlapRight = (obs.x + obs.width) - player.x;
        const overlapTop = (player.y + player.height) - obs.y;
        const overlapBottom = (obs.y + obs.height) - player.y;

        const minOverlapX = Math.min(overlapLeft, overlapRight);
        const minOverlapY = Math.min(overlapTop, overlapBottom);

        if (minOverlapY < minOverlapX) {
          if (overlapTop < overlapBottom) {
            // Landing on top
            player.y = obs.y - player.height;
            player.vy = 0;
            player.onGround = true;
            player.jumpsRemaining = MAX_JUMPS;
          } else {
            // Hitting from below
            player.y = obs.y + obs.height;
            player.vy = 0;
          }
        } else {
          if (overlapLeft < overlapRight) {
            player.x = obs.x - player.width;
          } else {
            player.x = obs.x + obs.width;
          }
          player.vx = 0;
        }
      }
    }
  }

  // Chest collisions - collect when landing on top
  for (const chest of chests) {
    if (chest.collected) continue;

    const playerBottom = player.y + player.height;
    const playerRight = player.x + player.width;
    const chestTop = chest.y;

    // Check if player is landing on top of chest
    if (player.vy >= 0 &&
        playerRight > chest.x + 10 &&
        player.x < chest.x + chest.width - 10 &&
        playerBottom >= chestTop &&
        playerBottom <= chestTop + 20) {
      // Collect the chest!
      chest.collected = true;
      score += 100;
      document.getElementById('score').textContent = score;

      // Spawn gold particles
      for (let i = 0; i < 15; i++) {
        const angle = -Math.PI / 2 + (Math.random() - 0.5) * Math.PI;
        const speed = 5 + Math.random() * 8;
        chestParticles.push({
          x: chest.x + chest.width / 2,
          y: chest.y,
          vx: Math.cos(angle) * speed,
          vy: Math.sin(angle) * speed - 3,
          size: 4 + Math.random() * 6,
          color: Math.random() > 0.3 ? '#ffd700' : '#ffec8b',
          alpha: 1,
          spin: Math.random() * 0.3
        });
      }

      // Bounce player up
      player.vy = -8;
      player.onGround = false;
    }
  }

  // Update chest particles
  for (let i = chestParticles.length - 1; i >= 0; i--) {
    const p = chestParticles[i];
    p.x += p.vx;
    p.y += p.vy;
    p.vy += 0.4; // gravity
    p.alpha -= 0.015;
    if (p.alpha <= 0) chestParticles.splice(i, 1);
  }

  // Update camera
  const targetCamX = player.x - canvas.width / 2 + player.width / 2;
  camX += (targetCamX - camX) * 0.1;
  camX = Math.max(0, Math.min(camX, WORLD_WIDTH - canvas.width));

  // Update HUD
  document.getElementById('pos').textContent = `${Math.floor(player.x)}, ${Math.floor(player.y)}`;
}

function render() {
  // Sky gradient
  const skyGrad = ctx.createLinearGradient(0, 0, 0, canvas.height);
  skyGrad.addColorStop(0, '#0f0c29');
  skyGrad.addColorStop(0.5, '#302b63');
  skyGrad.addColorStop(1, '#24243e');
  ctx.fillStyle = skyGrad;
  ctx.fillRect(0, 0, canvas.width, canvas.height);

  // Stars
  ctx.fillStyle = 'rgba(255,255,255,0.5)';
  for (let i = 0; i < 50; i++) {
    const x = (i * 137 + camX * 0.1) % canvas.width;
    const y = (i * 97) % (GROUND_Y - 100);
    ctx.beginPath();
    ctx.arc(x, y, 1, 0, Math.PI * 2);
    ctx.fill();
  }

  ctx.save();
  ctx.translate(-camX, 0);

  // Ground
  ctx.fillStyle = COLORS.ground;
  ctx.fillRect(0, GROUND_Y, WORLD_WIDTH, canvas.height - GROUND_Y + 100);

  // Ground top line
  ctx.fillStyle = COLORS.groundTop;
  ctx.fillRect(0, GROUND_Y, WORLD_WIDTH, 5);

  // Ground pattern
  ctx.strokeStyle = 'rgba(255,255,255,0.05)';
  ctx.lineWidth = 1;
  for (let x = 0; x < WORLD_WIDTH; x += 50) {
    ctx.beginPath();
    ctx.moveTo(x, GROUND_Y);
    ctx.lineTo(x, canvas.height);
    ctx.stroke();
  }

  // Obstacles
  for (const obs of obstacles) {
    if (obs.x + (obs.width || obs.radius * 2) < camX - 100 || obs.x > camX + canvas.width + 100) continue;

    ctx.fillStyle = obs.color;
    ctx.shadowColor = obs.color;
    ctx.shadowBlur = 10;

    if (obs.type === 'circle') {
      ctx.beginPath();
      ctx.arc(obs.x, obs.y, obs.radius, 0, Math.PI * 2);
      ctx.fill();

      // Highlight
      ctx.fillStyle = 'rgba(255,255,255,0.2)';
      ctx.beginPath();
      ctx.arc(obs.x - obs.radius * 0.3, obs.y - obs.radius * 0.3, obs.radius * 0.3, 0, Math.PI * 2);
      ctx.fill();
    } else {
      ctx.fillRect(obs.x, obs.y, obs.width, obs.height);

      // Highlight
      ctx.fillStyle = 'rgba(255,255,255,0.15)';
      ctx.fillRect(obs.x, obs.y, obs.width, 5);
    }
    ctx.shadowBlur = 0;
  }

  // Treasure Chests
  for (const chest of chests) {
    if (chest.x + chest.width < camX - 100 || chest.x > camX + canvas.width + 100) continue;
    if (chest.collected) continue;

    // Chest body (gold)
    ctx.fillStyle = '#daa520';
    ctx.shadowColor = '#ffd700';
    ctx.shadowBlur = 20;
    ctx.fillRect(chest.x, chest.y, chest.width, chest.height);

    // Chest lid (darker gold)
    ctx.fillStyle = '#b8860b';
    ctx.fillRect(chest.x, chest.y, chest.width, 12);

    // Shine highlight
    ctx.fillStyle = '#ffd700';
    ctx.shadowBlur = 15;
    ctx.fillRect(chest.x + 5, chest.y + 15, 15, 10);

    // Lock/clasp
    ctx.fillStyle = '#8b4513';
    ctx.shadowBlur = 0;
    ctx.fillRect(chest.x + chest.width / 2 - 6, chest.y + 8, 12, 8);

    // Sparkle effect
    const sparkleTime = Date.now() / 200;
    ctx.fillStyle = `rgba(255, 255, 200, ${0.5 + 0.5 * Math.sin(sparkleTime + chest.x)})`;
    ctx.beginPath();
    ctx.arc(chest.x + 10, chest.y + 5, 3, 0, Math.PI * 2);
    ctx.fill();
    ctx.beginPath();
    ctx.arc(chest.x + chest.width - 10, chest.y + 20, 2, 0, Math.PI * 2);
    ctx.fill();

    ctx.shadowBlur = 0;
  }

  // Gold particles
  for (const p of chestParticles) {
    ctx.globalAlpha = p.alpha;
    ctx.fillStyle = p.color;
    ctx.shadowColor = '#ffd700';
    ctx.shadowBlur = 10;
    ctx.beginPath();
    ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
    ctx.fill();
  }
  ctx.globalAlpha = 1;
  ctx.shadowBlur = 0;

  // Player
  ctx.fillStyle = player.color;
  ctx.shadowColor = player.color;
  ctx.shadowBlur = 15;
  ctx.fillRect(player.x, player.y, player.width, player.height);

  // Player face
  ctx.fillStyle = '#fff';
  ctx.shadowBlur = 0;
  // Eyes
  ctx.fillRect(player.x + 8, player.y + 12, 8, 8);
  ctx.fillRect(player.x + 24, player.y + 12, 8, 8);
  // Pupils
  ctx.fillStyle = '#1a1a2e';
  const lookDir = player.vx > 0.5 ? 2 : player.vx < -0.5 ? -2 : 0;
  ctx.fillRect(player.x + 10 + lookDir, player.y + 14, 4, 4);
  ctx.fillRect(player.x + 26 + lookDir, player.y + 14, 4, 4);

  ctx.restore();

  // World boundary indicators
  if (camX < 50) {
    ctx.fillStyle = 'rgba(255,255,255,0.1)';
    ctx.fillRect(0, 0, 5, canvas.height);
  }
  if (camX > WORLD_WIDTH - canvas.width - 50) {
    ctx.fillStyle = 'rgba(255,255,255,0.1)';
    ctx.fillRect(canvas.width - 5, 0, 5, canvas.height);
  }
}

function gameLoop() {
  update();
  render();
  requestAnimationFrame(gameLoop);
}

// Event listeners
window.addEventListener('keydown', (e) => {
  keys[e.code] = true;
  if (['Space', 'ArrowUp', 'ArrowDown'].includes(e.code)) {
    e.preventDefault();
  }
});

window.addEventListener('keyup', (e) => {
  keys[e.code] = false;
});

window.addEventListener('resize', resize);

// Touch controls
let touchStartX = 0;
canvas.addEventListener('touchstart', (e) => {
  touchStartX = e.touches[0].clientX;
  keys['Space'] = true;
});

canvas.addEventListener('touchmove', (e) => {
  const touchX = e.touches[0].clientX;
  if (touchX < touchStartX - 30) {
    keys['ArrowLeft'] = true;
    keys['ArrowRight'] = false;
  } else if (touchX > touchStartX + 30) {
    keys['ArrowRight'] = true;
    keys['ArrowLeft'] = false;
  }
});

canvas.addEventListener('touchend', () => {
  keys['Space'] = false;
  keys['ArrowLeft'] = false;
  keys['ArrowRight'] = false;
});

// Initialize
resize();
generateWorld();

// ========== INTRO SCREEN ==========
let gameStarted = false;
const introOverlay = document.getElementById('introOverlay');
const introStars = document.getElementById('introStars');
const introStart = document.getElementById('introStart');

// Generate twinkling stars
for (let i = 0; i < 50; i++) {
  const star = document.createElement('div');
  star.className = 'intro-star';
  star.style.left = Math.random() * 100 + '%';
  star.style.top = Math.random() * 100 + '%';
  star.style.animationDelay = Math.random() * 3 + 's';
  star.style.opacity = 0.3 + Math.random() * 0.7;
  introStars.appendChild(star);
}

function startGame() {
  introOverlay.classList.add('hidden');
  gameStarted = true;
}

introStart.addEventListener('click', startGame);

// Also allow space/enter to start
document.addEventListener('keydown', (e) => {
  if (!gameStarted && (e.code === 'Space' || e.code === 'Enter')) {
    e.preventDefault();
    startGame();
  }
});

// Modified game loop - only update when started
function mainLoop() {
  if (gameStarted) {
    update();
  }
  render();
  requestAnimationFrame(mainLoop);
}
requestAnimationFrame(mainLoop);

// ========== DEBUG TERMINAL ==========
const debugTerminal = document.getElementById('debugTerminal');
const debugOutput = document.getElementById('debugOutput');
const debugInput = document.getElementById('debugInput');

function toggleDebug() {
  debugTerminal.classList.toggle('open');
  if (debugTerminal.classList.contains('open')) {
    debugInput.focus();
  }
}

function debugLog(msg, type = '') {
  const div = document.createElement('div');
  div.className = type;
  div.textContent = msg;
  debugOutput.appendChild(div);
  debugOutput.scrollTop = debugOutput.scrollHeight;
}

function executeCommand(cmd) {
  const parts = cmd.toLowerCase().trim().split(' ');
  const command = parts[0];
  const args = parts.slice(1);

  debugLog('> ' + cmd);

  switch (command) {
    case 'help':
      debugLog('Commands: help, tp <x> <y>, speed <val>, jump <val>, gravity <val>, spawn, reset, fly, noclip, pos, clear');
      break;
    case 'tp':
      if (args.length >= 2) {
        player.x = parseFloat(args[0]) || player.x;
        player.y = parseFloat(args[1]) || player.y;
        debugLog(`Teleported to ${player.x}, ${player.y}`, 'success');
      } else {
        debugLog('Usage: tp <x> <y>', 'error');
      }
      break;
    case 'speed':
      if (args[0]) {
        window.MOVE_SPEED_MOD = parseFloat(args[0]) || 5;
        debugLog(`Speed set to ${window.MOVE_SPEED_MOD}`, 'success');
      } else {
        debugLog('Usage: speed <value> (default: 5)', 'error');
      }
      break;
    case 'jump':
      if (args[0]) {
        window.JUMP_MOD = parseFloat(args[0]) || 14;
        debugLog(`Jump force set to ${window.JUMP_MOD}`, 'success');
      } else {
        debugLog('Usage: jump <value> (default: 14)', 'error');
      }
      break;
    case 'gravity':
      if (args[0]) {
        window.GRAVITY_MOD = parseFloat(args[0]) || 0.6;
        debugLog(`Gravity set to ${window.GRAVITY_MOD}`, 'success');
      } else {
        debugLog('Usage: gravity <value> (default: 0.6)', 'error');
      }
      break;
    case 'spawn':
      player.x = 200;
      player.y = GROUND_Y - 50;
      player.vx = 0;
      player.vy = 0;
      debugLog('Respawned at start', 'success');
      break;
    case 'reset':
      generateWorld();
      player.x = 200;
      player.y = GROUND_Y - 50;
      debugLog('World regenerated', 'success');
      break;
    case 'fly':
      window.FLY_MODE = !window.FLY_MODE;
      debugLog(`Fly mode: ${window.FLY_MODE ? 'ON' : 'OFF'}`, 'success');
      break;
    case 'noclip':
      window.NOCLIP = !window.NOCLIP;
      debugLog(`Noclip: ${window.NOCLIP ? 'ON' : 'OFF'}`, 'success');
      break;
    case 'pos':
      debugLog(`Position: ${Math.floor(player.x)}, ${Math.floor(player.y)}`);
      break;
    case 'clear':
      debugOutput.innerHTML = '';
      break;
    case 'color':
      if (args[0]) {
        player.color = args[0];
        debugLog(`Player color: ${args[0]}`, 'success');
      } else {
        debugLog('Usage: color <hex or name>', 'error');
      }
      break;
    case 'size':
      if (args[0]) {
        const s = parseFloat(args[0]);
        player.width = 40 * s;
        player.height = 50 * s;
        debugLog(`Size multiplier: ${s}`, 'success');
      } else {
        debugLog('Usage: size <multiplier>', 'error');
      }
      break;
    default:
      debugLog(`Unknown command: ${command}`, 'error');
  }
}

debugInput.addEventListener('keydown', (e) => {
  if (e.key === 'Enter' && debugInput.value.trim()) {
    executeCommand(debugInput.value);
    debugInput.value = '';
  }
  e.stopPropagation();
});

debugInput.addEventListener('keyup', (e) => e.stopPropagation());

// Toggle with backtick
window.addEventListener('keydown', (e) => {
  if (e.key === '`' || e.key === '~') {
    e.preventDefault();
    toggleDebug();
  }
});

// Modifiable game vars
window.MOVE_SPEED_MOD = MOVE_SPEED;
window.JUMP_MOD = -JUMP_FORCE;
window.GRAVITY_MOD = GRAVITY;
window.FLY_MODE = false;
window.NOCLIP = false;

// ========== SUPABASE PRESENCE ==========
const SUPABASE_URL = 'https://fpfjwzveqcxfpbvbzmrr.supabase.co';
const SUPABASE_ANON_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImZwZmp3enZlcWN4ZnBidmJ6bXJyIiwicm9sZSI6ImFub24iLCJpYXQiOjE3MzY0NDQ2NzIsImV4cCI6MjA1MjAyMDY3Mn0.FNndwFB9MCJNu7C4tTJKhFqJSCdMH3xP-gEWgGsv19M';

let sbClient = null;
let currentUserId = null;

async function initPresence() {
  try {
    sbClient = window.supabase.createClient(SUPABASE_URL, SUPABASE_ANON_KEY);

    // Sign in anonymously
    const { data: authData, error: authError } = await sbClient.auth.signInAnonymously();
    if (authError) {
      console.error('Auth error:', authError);
      return;
    }

    currentUserId = authData.user.id;

    // Insert presence record
    const { error: insertError } = await sbClient
      .from('platformer_presence')
      .upsert({
        user_id: currentUserId,
        last_seen: new Date().toISOString()
      }, { onConflict: 'user_id' });

    if (insertError) {
      console.error('Insert error:', insertError);
    }

    // Start heartbeat - update last_seen every 10 seconds
    setInterval(async () => {
      if (currentUserId && sbClient) {
        await sbClient
          .from('platformer_presence')
          .update({ last_seen: new Date().toISOString() })
          .eq('user_id', currentUserId);
      }
    }, 10000);

    // Count active players (seen in last 30 seconds)
    async function countPlayers() {
      const thirtySecondsAgo = new Date(Date.now() - 30000).toISOString();
      const { count, error } = await sbClient
        .from('platformer_presence')
        .select('*', { count: 'exact', head: true })
        .gte('last_seen', thirtySecondsAgo);

      if (!error && count !== null) {
        document.getElementById('playerCount').textContent = count;
      }
    }

    // Initial count
    countPlayers();

    // Poll for player count every 5 seconds
    setInterval(countPlayers, 5000);

    // Cleanup on page unload
    window.addEventListener('beforeunload', async () => {
      if (currentUserId && sbClient) {
        await sbClient
          .from('platformer_presence')
          .delete()
          .eq('user_id', currentUserId);
      }
    });

    debugLog('Online presence connected', 'success');

  } catch (err) {
    console.error('Presence error:', err);
  }
}

// Start presence tracking
initPresence();
</script>
<script src="/apps/sloppy-header/sloppy-bar.js"></script>
<script src="/vibelib-extended.js"></script>
<script>
  // Compatibility Patch for Legacy Apps
  window.addEventListener("load", () => {
    if (window.SloppyKarma && window.VibeLib.Economy) {
      // Redirect old calls to new engine
      window.SloppyKarma.track = window.VibeLib.Economy.track;
    }
  });
</script>
</body>
</html>
