<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Simple Platformer</title>
  <meta property="og:title" content="Simple Platformer">
  <meta property="og:description" content="Jump around a flat world with random obstacles">
  <meta property="og:url" content="https://sloppy.live/platformer">
  <meta property="og:image" content="https://emojicdn.elk.sh/ðŸƒ?style=apple&size=512">
  <link rel="icon" href="https://emojicdn.elk.sh/ðŸƒ">
  <link href="https://fonts.googleapis.com/css2?family=Nunito:wght@400;700&display=swap" rel="stylesheet">
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      min-height: 100vh;
      background: #1a1a2e;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      font-family: 'Nunito', sans-serif;
      overflow: hidden;
    }
    .game-container {
      position: relative;
      width: 100vw;
      height: 100vh;
    }
    canvas {
      display: block;
      width: 100%;
      height: 100%;
    }
    .hud {
      position: absolute;
      top: 15px;
      left: 20px;
      color: #fff;
      font-size: 0.9rem;
      text-shadow: 0 2px 4px rgba(0,0,0,0.5);
    }
    .controls {
      position: absolute;
      top: 15px;
      right: 20px;
      color: rgba(255,255,255,0.5);
      font-size: 0.7rem;
      text-align: right;
    }
    .back-link {
      position: fixed;
      bottom: 5px;
      left: 50%;
      transform: translateX(-50%);
      color: rgba(255,255,255,0.2);
      text-decoration: none;
      font-size: 0.6rem;
    }
    .back-link:hover { color: rgba(255,255,255,0.4); }
  </style>
</head>
<body>
  <div class="game-container">
    <canvas id="game"></canvas>
    <div class="hud">
      <div>Position: <span id="pos">0, 0</span></div>
    </div>
    <div class="controls">
      WASD / Arrows to move<br>
      Space / W / Up to jump
    </div>
  </div>
  <a href="https://sloppy.live" class="back-link">sloppy.live</a>

<script>
const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d');

// World settings
const WORLD_WIDTH = 4000;
const GROUND_Y = 500;
const GRAVITY = 0.6;
const JUMP_FORCE = -14;
const MOVE_SPEED = 5;
const FRICTION = 0.85;

// Player
const player = {
  x: 200,
  y: GROUND_Y - 50,
  width: 40,
  height: 50,
  vx: 0,
  vy: 0,
  onGround: false,
  color: '#4ecdc4'
};

// Camera
let camX = 0;

// Input
const keys = {};

// Obstacles - pre-generated
const obstacles = [];

// Colors
const COLORS = {
  sky: '#16213e',
  ground: '#2d4059',
  groundTop: '#3d5a80',
  circle: '#e94560',
  square: '#f39c12',
  player: '#4ecdc4'
};

function resize() {
  canvas.width = window.innerWidth;
  canvas.height = window.innerHeight;
}

function generateWorld() {
  obstacles.length = 0;

  // Generate random obstacles across the world
  for (let x = 400; x < WORLD_WIDTH - 200; x += 150 + Math.random() * 200) {
    const isCircle = Math.random() > 0.5;
    const size = 30 + Math.random() * 50;

    if (isCircle) {
      obstacles.push({
        type: 'circle',
        x: x,
        y: GROUND_Y - size,
        radius: size,
        color: COLORS.circle
      });
    } else {
      const width = size + Math.random() * 30;
      const height = size + Math.random() * 40;
      obstacles.push({
        type: 'square',
        x: x,
        y: GROUND_Y - height,
        width: width,
        height: height,
        color: COLORS.square
      });
    }
  }

  // Add some floating platforms
  for (let i = 0; i < 15; i++) {
    const x = 300 + Math.random() * (WORLD_WIDTH - 600);
    const y = GROUND_Y - 150 - Math.random() * 200;
    obstacles.push({
      type: 'platform',
      x: x,
      y: y,
      width: 100 + Math.random() * 100,
      height: 20,
      color: '#6c5ce7'
    });
  }
}

function checkCollision(rect1, rect2) {
  return rect1.x < rect2.x + rect2.width &&
         rect1.x + rect1.width > rect2.x &&
         rect1.y < rect2.y + rect2.height &&
         rect1.y + rect1.height > rect2.y;
}

function checkCircleCollision(player, circle) {
  // Find closest point on rectangle to circle
  const closestX = Math.max(player.x, Math.min(circle.x, player.x + player.width));
  const closestY = Math.max(player.y, Math.min(circle.y, player.y + player.height));

  const dx = circle.x - closestX;
  const dy = circle.y - closestY;

  return (dx * dx + dy * dy) < (circle.radius * circle.radius);
}

function update() {
  // Horizontal movement
  if (keys['ArrowLeft'] || keys['KeyA']) {
    player.vx = -MOVE_SPEED;
  } else if (keys['ArrowRight'] || keys['KeyD']) {
    player.vx = MOVE_SPEED;
  } else {
    player.vx *= FRICTION;
  }

  // Jump
  if ((keys['Space'] || keys['ArrowUp'] || keys['KeyW']) && player.onGround) {
    player.vy = JUMP_FORCE;
    player.onGround = false;
  }

  // Apply gravity
  player.vy += GRAVITY;

  // Move player
  player.x += player.vx;
  player.y += player.vy;

  // World boundaries
  if (player.x < 0) player.x = 0;
  if (player.x > WORLD_WIDTH - player.width) player.x = WORLD_WIDTH - player.width;

  // Ground collision
  if (player.y + player.height > GROUND_Y) {
    player.y = GROUND_Y - player.height;
    player.vy = 0;
    player.onGround = true;
  }

  // Obstacle collisions
  player.onGround = player.y + player.height >= GROUND_Y;

  for (const obs of obstacles) {
    if (obs.type === 'circle') {
      if (checkCircleCollision(player, obs)) {
        // Push player out of circle
        const cx = obs.x;
        const cy = obs.y;
        const px = player.x + player.width / 2;
        const py = player.y + player.height / 2;
        const angle = Math.atan2(py - cy, px - cx);
        const pushDist = obs.radius + player.width / 2;

        player.x = cx + Math.cos(angle) * pushDist - player.width / 2;
        player.y = cy + Math.sin(angle) * pushDist - player.height / 2;

        if (Math.abs(angle) > Math.PI / 3 && Math.abs(angle) < 2 * Math.PI / 3) {
          player.vy = 0;
          if (angle < 0) player.onGround = true;
        }
      }
    } else if (obs.type === 'square' || obs.type === 'platform') {
      const playerRect = { x: player.x, y: player.y, width: player.width, height: player.height };
      const obsRect = { x: obs.x, y: obs.y, width: obs.width, height: obs.height };

      if (checkCollision(playerRect, obsRect)) {
        // Determine collision side
        const overlapLeft = (player.x + player.width) - obs.x;
        const overlapRight = (obs.x + obs.width) - player.x;
        const overlapTop = (player.y + player.height) - obs.y;
        const overlapBottom = (obs.y + obs.height) - player.y;

        const minOverlapX = Math.min(overlapLeft, overlapRight);
        const minOverlapY = Math.min(overlapTop, overlapBottom);

        if (minOverlapY < minOverlapX) {
          if (overlapTop < overlapBottom) {
            // Landing on top
            player.y = obs.y - player.height;
            player.vy = 0;
            player.onGround = true;
          } else {
            // Hitting from below
            player.y = obs.y + obs.height;
            player.vy = 0;
          }
        } else {
          if (overlapLeft < overlapRight) {
            player.x = obs.x - player.width;
          } else {
            player.x = obs.x + obs.width;
          }
          player.vx = 0;
        }
      }
    }
  }

  // Update camera
  const targetCamX = player.x - canvas.width / 2 + player.width / 2;
  camX += (targetCamX - camX) * 0.1;
  camX = Math.max(0, Math.min(camX, WORLD_WIDTH - canvas.width));

  // Update HUD
  document.getElementById('pos').textContent = `${Math.floor(player.x)}, ${Math.floor(player.y)}`;
}

function render() {
  // Sky gradient
  const skyGrad = ctx.createLinearGradient(0, 0, 0, canvas.height);
  skyGrad.addColorStop(0, '#0f0c29');
  skyGrad.addColorStop(0.5, '#302b63');
  skyGrad.addColorStop(1, '#24243e');
  ctx.fillStyle = skyGrad;
  ctx.fillRect(0, 0, canvas.width, canvas.height);

  // Stars
  ctx.fillStyle = 'rgba(255,255,255,0.5)';
  for (let i = 0; i < 50; i++) {
    const x = (i * 137 + camX * 0.1) % canvas.width;
    const y = (i * 97) % (GROUND_Y - 100);
    ctx.beginPath();
    ctx.arc(x, y, 1, 0, Math.PI * 2);
    ctx.fill();
  }

  ctx.save();
  ctx.translate(-camX, 0);

  // Ground
  ctx.fillStyle = COLORS.ground;
  ctx.fillRect(0, GROUND_Y, WORLD_WIDTH, canvas.height - GROUND_Y + 100);

  // Ground top line
  ctx.fillStyle = COLORS.groundTop;
  ctx.fillRect(0, GROUND_Y, WORLD_WIDTH, 5);

  // Ground pattern
  ctx.strokeStyle = 'rgba(255,255,255,0.05)';
  ctx.lineWidth = 1;
  for (let x = 0; x < WORLD_WIDTH; x += 50) {
    ctx.beginPath();
    ctx.moveTo(x, GROUND_Y);
    ctx.lineTo(x, canvas.height);
    ctx.stroke();
  }

  // Obstacles
  for (const obs of obstacles) {
    if (obs.x + (obs.width || obs.radius * 2) < camX - 100 || obs.x > camX + canvas.width + 100) continue;

    ctx.fillStyle = obs.color;
    ctx.shadowColor = obs.color;
    ctx.shadowBlur = 10;

    if (obs.type === 'circle') {
      ctx.beginPath();
      ctx.arc(obs.x, obs.y, obs.radius, 0, Math.PI * 2);
      ctx.fill();

      // Highlight
      ctx.fillStyle = 'rgba(255,255,255,0.2)';
      ctx.beginPath();
      ctx.arc(obs.x - obs.radius * 0.3, obs.y - obs.radius * 0.3, obs.radius * 0.3, 0, Math.PI * 2);
      ctx.fill();
    } else {
      ctx.fillRect(obs.x, obs.y, obs.width, obs.height);

      // Highlight
      ctx.fillStyle = 'rgba(255,255,255,0.15)';
      ctx.fillRect(obs.x, obs.y, obs.width, 5);
    }
    ctx.shadowBlur = 0;
  }

  // Player
  ctx.fillStyle = player.color;
  ctx.shadowColor = player.color;
  ctx.shadowBlur = 15;
  ctx.fillRect(player.x, player.y, player.width, player.height);

  // Player face
  ctx.fillStyle = '#fff';
  ctx.shadowBlur = 0;
  // Eyes
  ctx.fillRect(player.x + 8, player.y + 12, 8, 8);
  ctx.fillRect(player.x + 24, player.y + 12, 8, 8);
  // Pupils
  ctx.fillStyle = '#1a1a2e';
  const lookDir = player.vx > 0.5 ? 2 : player.vx < -0.5 ? -2 : 0;
  ctx.fillRect(player.x + 10 + lookDir, player.y + 14, 4, 4);
  ctx.fillRect(player.x + 26 + lookDir, player.y + 14, 4, 4);

  ctx.restore();

  // World boundary indicators
  if (camX < 50) {
    ctx.fillStyle = 'rgba(255,255,255,0.1)';
    ctx.fillRect(0, 0, 5, canvas.height);
  }
  if (camX > WORLD_WIDTH - canvas.width - 50) {
    ctx.fillStyle = 'rgba(255,255,255,0.1)';
    ctx.fillRect(canvas.width - 5, 0, 5, canvas.height);
  }
}

function gameLoop() {
  update();
  render();
  requestAnimationFrame(gameLoop);
}

// Event listeners
window.addEventListener('keydown', (e) => {
  keys[e.code] = true;
  if (['Space', 'ArrowUp', 'ArrowDown'].includes(e.code)) {
    e.preventDefault();
  }
});

window.addEventListener('keyup', (e) => {
  keys[e.code] = false;
});

window.addEventListener('resize', resize);

// Touch controls
let touchStartX = 0;
canvas.addEventListener('touchstart', (e) => {
  touchStartX = e.touches[0].clientX;
  keys['Space'] = true;
});

canvas.addEventListener('touchmove', (e) => {
  const touchX = e.touches[0].clientX;
  if (touchX < touchStartX - 30) {
    keys['ArrowLeft'] = true;
    keys['ArrowRight'] = false;
  } else if (touchX > touchStartX + 30) {
    keys['ArrowRight'] = true;
    keys['ArrowLeft'] = false;
  }
});

canvas.addEventListener('touchend', () => {
  keys['Space'] = false;
  keys['ArrowLeft'] = false;
  keys['ArrowRight'] = false;
});

// Initialize
resize();
generateWorld();
requestAnimationFrame(gameLoop);
</script>
</body>
</html>
