<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
  <title>Tickle Defense - Dodge the Feathers!</title>
  <link rel="icon" href="https://emojicdn.elk.sh/ðŸª¶">
  <meta property="og:title" content="Tickle Defense - Dodge the Feathers!">
  <meta property="og:description" content="Chaotic feather dodging madness! How long can you survive?">
  <meta property="og:url" content="https://sloppy.live/tickle-defense">
  <meta property="og:image" content="https://emojicdn.elk.sh/ðŸª¶?style=apple&size=512">
  <link href="https://fonts.googleapis.com/css2?family=Fredoka+One&family=Nunito:wght@400;700&display=swap" rel="stylesheet">
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      min-height: 100vh;
      background: linear-gradient(135deg, #ff9a9e 0%, #fecfef 50%, #ffecd2 100%);
      font-family: 'Nunito', sans-serif;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      overflow: hidden;
      touch-action: none;
    }
    .game-container {
      position: relative;
      width: 100vw;
      height: 100vh;
      max-width: 800px;
      max-height: 600px;
    }
    canvas {
      display: block;
      width: 100%;
      height: 100%;
      border-radius: 20px;
      box-shadow: 0 10px 40px rgba(255, 100, 150, 0.3);
    }
    .hud {
      position: absolute;
      top: 15px;
      left: 20px;
      right: 20px;
      display: flex;
      justify-content: space-between;
      pointer-events: none;
      z-index: 10;
    }
    .score {
      font-family: 'Fredoka One', cursive;
      font-size: 1.8rem;
      color: #ff6b9d;
      text-shadow: 2px 2px 0 #fff, 4px 4px 0 rgba(255,107,157,0.3);
    }
    .lives {
      font-size: 1.5rem;
    }
    .overlay {
      position: absolute;
      inset: 0;
      background: rgba(255, 220, 230, 0.95);
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      z-index: 100;
      border-radius: 20px;
      transition: opacity 0.3s;
    }
    .overlay.hidden {
      opacity: 0;
      pointer-events: none;
    }
    .title {
      font-family: 'Fredoka One', cursive;
      font-size: 2.5rem;
      color: #ff6b9d;
      text-shadow: 3px 3px 0 #fff;
      margin-bottom: 10px;
      text-align: center;
    }
    .subtitle {
      font-size: 1rem;
      color: #c77dff;
      margin-bottom: 30px;
    }
    .btn {
      font-family: 'Fredoka One', cursive;
      font-size: 1.2rem;
      padding: 15px 40px;
      background: linear-gradient(135deg, #ff6b9d, #c77dff);
      border: none;
      color: white;
      cursor: pointer;
      border-radius: 50px;
      box-shadow: 0 6px 0 #d44a7a, 0 10px 20px rgba(255,107,157,0.3);
      transition: all 0.1s;
    }
    .btn:hover {
      transform: translateY(-2px);
      box-shadow: 0 8px 0 #d44a7a, 0 14px 25px rgba(255,107,157,0.4);
    }
    .btn:active {
      transform: translateY(4px);
      box-shadow: 0 2px 0 #d44a7a;
    }
    .instructions {
      margin-top: 20px;
      font-size: 0.85rem;
      color: #999;
      text-align: center;
    }
    .game-over-score {
      font-family: 'Fredoka One', cursive;
      font-size: 3rem;
      color: #c77dff;
      margin: 10px 0 20px;
    }
    .tickle-meter {
      position: absolute;
      bottom: 15px;
      left: 50%;
      transform: translateX(-50%);
      width: 200px;
      height: 20px;
      background: rgba(255,255,255,0.5);
      border-radius: 10px;
      overflow: hidden;
      border: 3px solid #ff6b9d;
    }
    .tickle-fill {
      height: 100%;
      background: linear-gradient(90deg, #ffeb3b, #ff9800, #f44336);
      transition: width 0.1s;
      border-radius: 7px;
    }
    .back-link {
      position: fixed;
      bottom: 5px;
      right: 10px;
      color: #c77dff;
      text-decoration: none;
      font-size: 0.7rem;
      opacity: 0.6;
    }
    @media (max-width: 600px) {
      .title { font-size: 1.8rem; }
      .score { font-size: 1.3rem; }
    }
  </style>
</head>
<body>
  <div class="game-container" id="container">
    <canvas id="game"></canvas>
    <div class="hud">
      <div class="score" id="score">0</div>
      <div class="lives" id="lives"></div>
    </div>
    <div class="tickle-meter">
      <div class="tickle-fill" id="tickleFill" style="width: 0%"></div>
    </div>
    <div class="overlay" id="startOverlay">
      <div class="title">ðŸª¶ TICKLE DEFENSE ðŸª¶</div>
      <div class="subtitle">Dodge the chaotic feathers!</div>
      <button class="btn" id="startBtn">PLAY!</button>
      <div class="instructions">Move: Arrow keys / WASD / Touch drag</div>
    </div>
    <div class="overlay hidden" id="gameOverOverlay">
      <div class="title">TOO TICKLISH! ðŸ˜‚</div>
      <div class="game-over-score" id="finalScore">0</div>
      <button class="btn" id="restartBtn">TRY AGAIN</button>
    </div>
  </div>
  <a href="https://sloppy.live" class="back-link">sloppy.live</a>

<script>
const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d');
const container = document.getElementById('container');

let gameRunning = false;
let score = 0;
let tickleLevel = 0;
let shakeIntensity = 0;
let frameCount = 0;
let feathers = [];
let particles = [];
let giggles = [];

const player = {
  x: 0, y: 0, size: 40,
  vx: 0, vy: 0, wiggle: 0
};

const keys = {};
let touchStart = null;
let touchCurrent = null;

const FEATHER_TYPES = [
  { color: '#ff6b9d', speed: 2, size: 30, wiggle: 0.1 },
  { color: '#c77dff', speed: 3, size: 25, wiggle: 0.15 },
  { color: '#64b5f6', speed: 4, size: 20, wiggle: 0.2 },
  { color: '#ffeb3b', speed: 5, size: 35, wiggle: 0.08, golden: true }
];

function resize() {
  canvas.width = container.clientWidth;
  canvas.height = container.clientHeight;
  if (!gameRunning) {
    player.x = canvas.width / 2;
    player.y = canvas.height / 2;
  }
}

function spawnFeather() {
  const type = FEATHER_TYPES[Math.floor(Math.random() * FEATHER_TYPES.length)];
  const side = Math.floor(Math.random() * 4);
  let x, y, vx, vy;

  switch(side) {
    case 0: x = Math.random() * canvas.width; y = -30; vx = (Math.random() - 0.5) * 2; vy = type.speed; break;
    case 1: x = canvas.width + 30; y = Math.random() * canvas.height; vx = -type.speed; vy = (Math.random() - 0.5) * 2; break;
    case 2: x = Math.random() * canvas.width; y = canvas.height + 30; vx = (Math.random() - 0.5) * 2; vy = -type.speed; break;
    case 3: x = -30; y = Math.random() * canvas.height; vx = type.speed; vy = (Math.random() - 0.5) * 2; break;
  }

  feathers.push({
    x, y, vx, vy,
    rotation: Math.random() * Math.PI * 2,
    rotationSpeed: (Math.random() - 0.5) * 0.2,
    type,
    phase: Math.random() * Math.PI * 2
  });
}

function spawnTickleParticle(x, y) {
  for (let i = 0; i < 5; i++) {
    particles.push({
      x, y,
      vx: (Math.random() - 0.5) * 8,
      vy: (Math.random() - 0.5) * 8,
      size: 5 + Math.random() * 10,
      color: ['#ff6b9d', '#c77dff', '#ffeb3b', '#64b5f6'][Math.floor(Math.random() * 4)],
      alpha: 1,
      rotation: Math.random() * Math.PI * 2
    });
  }
  giggles.push({
    x, y,
    text: ['hehe!', 'teehee!', 'ahahaha!', 'stop!', 'nooo!'][Math.floor(Math.random() * 5)],
    alpha: 1, vy: -2, scale: 1
  });
}

function updatePlayer() {
  let dx = 0, dy = 0;
  if (keys['ArrowLeft'] || keys['KeyA']) dx -= 1;
  if (keys['ArrowRight'] || keys['KeyD']) dx += 1;
  if (keys['ArrowUp'] || keys['KeyW']) dy -= 1;
  if (keys['ArrowDown'] || keys['KeyS']) dy += 1;

  const speed = 6;
  if (dx !== 0 || dy !== 0) {
    const len = Math.sqrt(dx * dx + dy * dy);
    player.vx += (dx / len) * speed * 0.3;
    player.vy += (dy / len) * speed * 0.3;
  }

  if (touchCurrent && touchStart) {
    const tdx = touchCurrent.x - touchStart.x;
    const tdy = touchCurrent.y - touchStart.y;
    const dist = Math.sqrt(tdx * tdx + tdy * tdy);
    if (dist > 10) {
      player.vx += (tdx / dist) * speed * 0.4;
      player.vy += (tdy / dist) * speed * 0.4;
    }
  }

  player.vx *= 0.9;
  player.vy *= 0.9;
  player.x += player.vx;
  player.y += player.vy;

  if (tickleLevel > 0) {
    player.wiggle += 0.5;
    player.x += Math.sin(player.wiggle) * tickleLevel * 0.5;
    player.y += Math.cos(player.wiggle * 1.3) * tickleLevel * 0.3;
  }

  player.x = Math.max(player.size, Math.min(canvas.width - player.size, player.x));
  player.y = Math.max(player.size, Math.min(canvas.height - player.size, player.y));
}

function updateFeathers() {
  for (let i = feathers.length - 1; i >= 0; i--) {
    const f = feathers[i];
    f.phase += f.type.wiggle;
    f.x += f.vx + Math.sin(f.phase) * 2;
    f.y += f.vy + Math.cos(f.phase * 0.7) * 1.5;
    f.rotation += f.rotationSpeed;

    const dx = f.x - player.x;
    const dy = f.y - player.y;
    const dist = Math.sqrt(dx * dx + dy * dy);

    if (dist < player.size + f.type.size * 0.4) {
      if (f.type.golden) {
        tickleLevel += 15;
        shakeIntensity = 20;
      } else {
        tickleLevel += 8;
        shakeIntensity = 10;
      }
      spawnTickleParticle(f.x, f.y);
      feathers.splice(i, 1);
      continue;
    }

    if (f.x < -50 || f.x > canvas.width + 50 || f.y < -50 || f.y > canvas.height + 50) {
      feathers.splice(i, 1);
      score += f.type.golden ? 5 : 1;
    }
  }
}

function updateParticles() {
  for (let i = particles.length - 1; i >= 0; i--) {
    const p = particles[i];
    p.x += p.vx; p.y += p.vy;
    p.vx *= 0.95; p.vy *= 0.95;
    p.alpha -= 0.02; p.rotation += 0.1;
    if (p.alpha <= 0) particles.splice(i, 1);
  }
  for (let i = giggles.length - 1; i >= 0; i--) {
    const g = giggles[i];
    g.y += g.vy; g.alpha -= 0.02; g.scale += 0.02;
    if (g.alpha <= 0) giggles.splice(i, 1);
  }
}

function update() {
  if (!gameRunning) return;
  frameCount++;

  const spawnRate = Math.max(10, 40 - Math.floor(score / 20));
  if (frameCount % spawnRate === 0) {
    spawnFeather();
    if (score > 50 && Math.random() < 0.3) spawnFeather();
    if (score > 100 && Math.random() < 0.3) spawnFeather();
  }

  updatePlayer();
  updateFeathers();
  updateParticles();

  tickleLevel = Math.max(0, tickleLevel - 0.3);
  shakeIntensity *= 0.9;

  document.getElementById('score').textContent = score;
  document.getElementById('tickleFill').style.width = Math.min(100, tickleLevel) + '%';

  if (tickleLevel >= 100) gameOver();
}

function drawFeather(x, y, rotation, type) {
  ctx.save();
  ctx.translate(x, y);
  ctx.rotate(rotation);

  ctx.beginPath();
  ctx.moveTo(0, -type.size);
  ctx.quadraticCurveTo(type.size * 0.4, -type.size * 0.3, type.size * 0.3, type.size * 0.5);
  ctx.quadraticCurveTo(0, type.size * 0.8, -type.size * 0.3, type.size * 0.5);
  ctx.quadraticCurveTo(-type.size * 0.4, -type.size * 0.3, 0, -type.size);
  ctx.fillStyle = type.color;
  ctx.fill();

  ctx.beginPath();
  ctx.moveTo(0, -type.size);
  ctx.lineTo(0, type.size * 0.7);
  ctx.strokeStyle = type.golden ? '#ffd700' : '#fff';
  ctx.lineWidth = 2;
  ctx.stroke();

  if (type.golden) {
    ctx.shadowColor = '#ffeb3b';
    ctx.shadowBlur = 20;
  }
  ctx.restore();
}

function drawPlayer() {
  ctx.save();
  ctx.translate(player.x, player.y);

  const wobble = tickleLevel > 0 ? Math.sin(frameCount * 0.5) * tickleLevel * 0.05 : 0;
  ctx.rotate(wobble);

  ctx.beginPath();
  ctx.arc(0, 0, player.size, 0, Math.PI * 2);
  const gradient = ctx.createRadialGradient(0, -10, 5, 0, 0, player.size);
  gradient.addColorStop(0, '#ffe4ec');
  gradient.addColorStop(1, '#ffb6c1');
  ctx.fillStyle = gradient;
  ctx.fill();
  ctx.strokeStyle = '#ff6b9d';
  ctx.lineWidth = 3;
  ctx.stroke();

  const eyeOffset = 12, eyeY = -5;
  const blinkPhase = Math.sin(frameCount * 0.1);
  const eyeHeight = tickleLevel > 30 ? 2 : (blinkPhase > 0.95 ? 2 : 8);

  ctx.fillStyle = '#333';
  ctx.beginPath();
  ctx.ellipse(-eyeOffset, eyeY, 6, eyeHeight, 0, 0, Math.PI * 2);
  ctx.ellipse(eyeOffset, eyeY, 6, eyeHeight, 0, 0, Math.PI * 2);
  ctx.fill();

  ctx.fillStyle = '#fff';
  ctx.beginPath();
  ctx.arc(-eyeOffset - 2, eyeY - 2, 2, 0, Math.PI * 2);
  ctx.arc(eyeOffset - 2, eyeY - 2, 2, 0, Math.PI * 2);
  ctx.fill();

  ctx.beginPath();
  if (tickleLevel > 20) {
    ctx.arc(0, 12, 12, 0, Math.PI);
    ctx.fillStyle = '#ff6b9d';
    ctx.fill();
  } else {
    ctx.arc(0, 8, 8, 0.1 * Math.PI, 0.9 * Math.PI);
    ctx.strokeStyle = '#ff6b9d';
    ctx.lineWidth = 2;
    ctx.stroke();
  }

  if (tickleLevel > 10) {
    ctx.fillStyle = 'rgba(255, 100, 150, ' + Math.min(0.5, tickleLevel / 100) + ')';
    ctx.beginPath();
    ctx.ellipse(-25, 5, 10, 6, 0, 0, Math.PI * 2);
    ctx.ellipse(25, 5, 10, 6, 0, 0, Math.PI * 2);
    ctx.fill();
  }
  ctx.restore();
}

function render() {
  ctx.save();
  if (shakeIntensity > 0.5) {
    ctx.translate((Math.random() - 0.5) * shakeIntensity, (Math.random() - 0.5) * shakeIntensity);
  }

  const bgGrad = ctx.createLinearGradient(0, 0, canvas.width, canvas.height);
  bgGrad.addColorStop(0, '#fff5f7');
  bgGrad.addColorStop(0.5, '#ffe4ec');
  bgGrad.addColorStop(1, '#f0e6ff');
  ctx.fillStyle = bgGrad;
  ctx.fillRect(0, 0, canvas.width, canvas.height);

  ctx.globalAlpha = 0.1;
  for (let x = 0; x < canvas.width; x += 50) {
    for (let y = 0; y < canvas.height; y += 50) {
      ctx.fillStyle = (x + y) % 100 === 0 ? '#ff6b9d' : '#c77dff';
      ctx.beginPath();
      ctx.arc(x + Math.sin(frameCount * 0.02 + x) * 5, y + Math.cos(frameCount * 0.02 + y) * 5, 3, 0, Math.PI * 2);
      ctx.fill();
    }
  }
  ctx.globalAlpha = 1;

  for (const p of particles) {
    ctx.save();
    ctx.globalAlpha = p.alpha;
    ctx.translate(p.x, p.y);
    ctx.rotate(p.rotation);
    ctx.fillStyle = p.color;
    ctx.fillRect(-p.size/2, -p.size/2, p.size, p.size);
    ctx.restore();
  }

  ctx.font = 'bold 20px Fredoka One';
  for (const g of giggles) {
    ctx.save();
    ctx.globalAlpha = g.alpha;
    ctx.fillStyle = '#ff6b9d';
    ctx.textAlign = 'center';
    ctx.translate(g.x, g.y);
    ctx.scale(g.scale, g.scale);
    ctx.fillText(g.text, 0, 0);
    ctx.restore();
  }

  for (const f of feathers) {
    drawFeather(f.x, f.y, f.rotation, f.type);
  }

  drawPlayer();
  ctx.restore();
}

function gameLoop() {
  update();
  render();
  requestAnimationFrame(gameLoop);
}

function startGame() {
  document.getElementById('startOverlay').classList.add('hidden');
  document.getElementById('gameOverOverlay').classList.add('hidden');
  score = 0; tickleLevel = 0; frameCount = 0;
  feathers = []; particles = []; giggles = [];
  shakeIntensity = 0;
  player.x = canvas.width / 2;
  player.y = canvas.height / 2;
  player.vx = 0; player.vy = 0;
  gameRunning = true;
}

function gameOver() {
  gameRunning = false;
  document.getElementById('finalScore').textContent = score;
  document.getElementById('gameOverOverlay').classList.remove('hidden');
}

document.getElementById('startBtn').addEventListener('click', startGame);
document.getElementById('restartBtn').addEventListener('click', startGame);

document.addEventListener('keydown', e => {
  keys[e.code] = true;
  if (['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight', 'Space'].includes(e.code)) e.preventDefault();
  if (e.code === 'Space' && !gameRunning) startGame();
});
document.addEventListener('keyup', e => { keys[e.code] = false; });

canvas.addEventListener('touchstart', e => {
  e.preventDefault();
  const touch = e.touches[0];
  const rect = canvas.getBoundingClientRect();
  touchStart = { x: touch.clientX - rect.left, y: touch.clientY - rect.top };
  touchCurrent = { ...touchStart };
});
canvas.addEventListener('touchmove', e => {
  e.preventDefault();
  const touch = e.touches[0];
  const rect = canvas.getBoundingClientRect();
  touchCurrent = { x: touch.clientX - rect.left, y: touch.clientY - rect.top };
});
canvas.addEventListener('touchend', () => { touchStart = null; touchCurrent = null; });

window.addEventListener('resize', resize);
resize();
gameLoop();
</script>
</body>
</html>
