<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
  <title>Tickle Defense - Protect the Grumpy Robot</title>
  <link rel="icon" href="https://emojicdn.elk.sh/ü§ñ">
  <meta name="description" content="Shoot neon lasers to blast away tickling hands!">
  <meta property="og:title" content="Tickle Defense">
  <meta property="og:description" content="Shoot neon lasers to blast away tickling hands!">
  <meta property="og:url" content="https://app.sloppy.live/tickle-defense">
  <meta property="og:image" content="https://app.sloppy.live/tickle-defense/og-image.png">
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link href="https://fonts.googleapis.com/css2?family=Bangers&family=Roboto+Mono:wght@700&display=swap" rel="stylesheet">
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; user-select: none; -webkit-user-select: none; }
    :root {
      --robot-gray: #5a6a7a;
      --robot-dark: #3a4a5a;
      --robot-light: #8a9aaa;
      --danger-red: #ff3344;
      --safe-green: #44ff66;
      --warning-yellow: #ffcc00;
      --bg-dark: #1a1a2e;
    }
    body {
      font-family: 'Bangers', cursive;
      background: var(--bg-dark);
      min-height: 100vh;
      overflow: hidden;
      touch-action: manipulation;
    }
    .game-container {
      position: relative;
      width: 100vw;
      height: 100vh;
      background: radial-gradient(ellipse at center, #2a2a4e 0%, #1a1a2e 70%);
    }
    .game-header {
      position: absolute;
      top: 0; left: 0; right: 0;
      padding: 15px 20px;
      display: flex;
      justify-content: space-between;
      align-items: center;
      z-index: 100;
      background: linear-gradient(to bottom, rgba(0,0,0,0.5), transparent);
    }
    .score {
      font-size: 2rem;
      color: #fff;
      text-shadow: 2px 2px 0 #000, 0 0 10px var(--warning-yellow);
      letter-spacing: 2px;
    }
    .grump-meter { display: flex; align-items: center; gap: 10px; }
    .grump-label { font-size: 1rem; color: #fff; text-shadow: 1px 1px 0 #000; }
    .grump-bar {
      width: 150px; height: 25px;
      background: #222;
      border: 3px solid #444;
      border-radius: 5px;
      overflow: hidden;
    }
    .grump-fill {
      height: 100%;
      background: linear-gradient(90deg, var(--danger-red), var(--warning-yellow), var(--safe-green));
      transition: width 0.3s;
      box-shadow: 0 0 10px currentColor;
    }
    .robot {
      position: absolute;
      left: 50%; top: 50%;
      transform: translate(-50%, -50%);
      width: 180px; height: 220px;
      z-index: 50;
    }
    .robot-head {
      width: 120px; height: 100px;
      background: linear-gradient(135deg, var(--robot-light), var(--robot-gray), var(--robot-dark));
      border-radius: 20px 20px 10px 10px;
      margin: 0 auto;
      position: relative;
      box-shadow: inset 0 -10px 20px rgba(0,0,0,0.3), 0 5px 15px rgba(0,0,0,0.5);
      border: 3px solid var(--robot-dark);
    }
    .robot-eyes { display: flex; justify-content: space-around; padding-top: 25px; }
    .robot-eye {
      width: 35px; height: 25px;
      background: #111;
      border-radius: 5px;
      position: relative;
      overflow: hidden;
      border: 2px solid #333;
    }
    .robot-eye::after {
      content: '';
      position: absolute;
      width: 15px; height: 15px;
      background: #ff0000;
      border-radius: 50%;
      top: 50%; left: 50%;
      transform: translate(-50%, -50%);
      box-shadow: 0 0 10px #ff0000, 0 0 20px #ff0000;
      transition: all 0.1s;
    }
    .robot.tickled .robot-eye::after {
      background: #00ffff;
      animation: eyePanic 0.1s infinite;
    }
    @keyframes eyePanic {
      0%, 100% { transform: translate(-50%, -50%); }
      50% { transform: translate(-30%, -50%); }
    }
    .robot-mouth {
      width: 50px; height: 15px;
      background: #111;
      margin: 15px auto 0;
      border-radius: 3px;
      position: relative;
      border: 2px solid #333;
    }
    .robot.grumpy .robot-mouth { border-radius: 0 0 10px 10px; height: 8px; }
    .robot.tickled .robot-mouth {
      width: 40px; height: 30px;
      border-radius: 50%;
      animation: laughMouth 0.15s infinite;
    }
    @keyframes laughMouth {
      0%, 100% { transform: scaleY(1); }
      50% { transform: scaleY(0.7); }
    }
    .robot-antenna {
      width: 8px; height: 30px;
      background: var(--robot-gray);
      margin: 0 auto;
      position: relative;
      top: -3px;
    }
    .robot-antenna::after {
      content: '';
      position: absolute;
      top: -12px; left: 50%;
      transform: translateX(-50%);
      width: 16px; height: 16px;
      background: var(--danger-red);
      border-radius: 50%;
      box-shadow: 0 0 10px var(--danger-red);
      animation: antennaBlink 1s infinite;
    }
    @keyframes antennaBlink { 0%, 100% { opacity: 1; } 50% { opacity: 0.5; } }
    .robot-body {
      width: 100px; height: 80px;
      background: linear-gradient(135deg, var(--robot-light), var(--robot-gray), var(--robot-dark));
      margin: 5px auto 0;
      border-radius: 10px;
      position: relative;
      box-shadow: inset 0 -10px 20px rgba(0,0,0,0.3), 0 5px 15px rgba(0,0,0,0.5);
      border: 3px solid var(--robot-dark);
    }
    .robot-chest { display: flex; justify-content: center; gap: 8px; padding-top: 15px; }
    .robot-light {
      width: 12px; height: 12px;
      border-radius: 50%;
      background: var(--safe-green);
      box-shadow: 0 0 10px var(--safe-green);
    }
    .robot.tickled .robot-light { animation: panicLights 0.2s infinite; }
    @keyframes panicLights {
      0% { background: var(--danger-red); box-shadow: 0 0 10px var(--danger-red); }
      33% { background: var(--warning-yellow); box-shadow: 0 0 10px var(--warning-yellow); }
      66% { background: var(--safe-green); box-shadow: 0 0 10px var(--safe-green); }
    }
    .robot-arms {
      position: absolute;
      width: 140%; left: -20%; top: 20px;
      display: flex;
      justify-content: space-between;
    }
    .robot-arm {
      width: 20px; height: 50px;
      background: var(--robot-gray);
      border-radius: 10px;
      box-shadow: 0 3px 10px rgba(0,0,0,0.3);
    }
    .robot.tickled { animation: robotShake 0.1s infinite; }
    @keyframes robotShake {
      0%, 100% { transform: translate(-50%, -50%) rotate(-2deg); }
      50% { transform: translate(-50%, -50%) rotate(2deg); }
    }
    .tickle-text {
      position: absolute;
      font-size: 1.5rem;
      color: var(--warning-yellow);
      text-shadow: 2px 2px 0 #000;
      pointer-events: none;
      animation: tickleFloat 0.5s forwards;
      z-index: 200;
    }
    @keyframes tickleFloat {
      0% { opacity: 1; transform: translateY(0) scale(1); }
      100% { opacity: 0; transform: translateY(-50px) scale(1.5); }
    }
    .tickle-hand {
      position: absolute;
      width: 120px; height: 150px;
      z-index: 80;
      filter: drop-shadow(0 5px 15px rgba(0,0,0,0.5));
      pointer-events: none;
    }
    .hand-svg { width: 100%; height: 100%; }
    .tickle-hand.wiggle { animation: handWiggle 0.3s infinite; }
    @keyframes handWiggle {
      0%, 100% { transform: rotate(-5deg); }
      50% { transform: rotate(5deg); }
    }
    /* Laser Blaster */
    .robot-blaster {
      position: absolute;
      bottom: 10px;
      left: 50%;
      transform: translateX(-50%);
      width: 60px;
      height: 25px;
      background: linear-gradient(90deg, #333, #555, #333);
      border: 2px solid #00ffff;
      border-radius: 5px 15px 15px 5px;
      box-shadow: 0 0 15px #00ffff, inset 0 0 10px rgba(0,255,255,0.3);
      z-index: 60;
    }
    .robot-blaster::before {
      content: '';
      position: absolute;
      right: -8px;
      top: 50%;
      transform: translateY(-50%);
      width: 12px;
      height: 12px;
      background: #00ffff;
      border-radius: 50%;
      box-shadow: 0 0 10px #00ffff, 0 0 20px #00ffff;
      animation: blasterGlow 0.5s infinite alternate;
    }
    @keyframes blasterGlow {
      0% { box-shadow: 0 0 10px #00ffff, 0 0 20px #00ffff; }
      100% { box-shadow: 0 0 15px #00ffff, 0 0 30px #00ffff, 0 0 40px #00ffff; }
    }
    .robot-blaster::after {
      content: 'ZAP';
      position: absolute;
      left: 5px;
      top: 50%;
      transform: translateY(-50%);
      font-family: 'Bangers', cursive;
      font-size: 0.5rem;
      color: #00ffff;
      text-shadow: 0 0 5px #00ffff;
    }
    /* Projectiles */
    .laser-projectile {
      position: absolute;
      width: 20px;
      height: 8px;
      background: linear-gradient(90deg, transparent, #00ffff, #ffffff, #00ffff, transparent);
      border-radius: 4px;
      box-shadow: 0 0 10px #00ffff, 0 0 20px #00ffff, 0 0 30px #0088ff;
      pointer-events: none;
      z-index: 200;
    }
    .laser-projectile::before {
      content: '';
      position: absolute;
      top: -2px;
      left: 0;
      right: 0;
      bottom: -2px;
      background: rgba(0, 255, 255, 0.3);
      border-radius: 6px;
      filter: blur(3px);
    }
    /* Zap effect replaces swat */
    .zap-effect {
      position: absolute;
      width: 100px; height: 100px;
      pointer-events: none;
      z-index: 300;
    }
    .zap-effect::after {
      content: 'ZAP!';
      position: absolute;
      font-family: 'Bangers', cursive;
      font-size: 2rem;
      color: #00ffff;
      text-shadow: 2px 2px 0 #000, 0 0 10px #00ffff, 0 0 20px #00ffff;
      animation: zapPop 0.4s forwards;
    }
    @keyframes zapPop {
      0% { opacity: 1; transform: scale(0.5) rotate(-10deg); }
      50% { transform: scale(1.3) rotate(10deg); }
      100% { opacity: 0; transform: scale(1) rotate(0deg) translateY(-30px); }
    }
    /* Muzzle flash */
    .muzzle-flash {
      position: absolute;
      width: 30px;
      height: 30px;
      background: radial-gradient(circle, #ffffff 0%, #00ffff 30%, transparent 70%);
      border-radius: 50%;
      pointer-events: none;
      animation: flashFade 0.15s forwards;
      z-index: 250;
    }
    @keyframes flashFade {
      0% { opacity: 1; transform: scale(1); }
      100% { opacity: 0; transform: scale(2); }
    }
    /* Crosshair cursor during game */
    .game-container.playing { cursor: crosshair; }
    .start-screen {
      position: absolute;
      top: 0; left: 0; right: 0; bottom: 0;
      background: rgba(0,0,0,0.85);
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      z-index: 500;
    }
    .start-screen h1 {
      font-size: 3rem;
      color: var(--warning-yellow);
      text-shadow: 3px 3px 0 var(--danger-red), 0 0 30px var(--warning-yellow);
      margin-bottom: 20px;
      animation: titlePulse 1s infinite;
    }
    @keyframes titlePulse { 0%, 100% { transform: scale(1); } 50% { transform: scale(1.05); } }
    .start-screen p {
      font-family: 'Roboto Mono', monospace;
      font-size: 1rem;
      color: #aaa;
      margin-bottom: 30px;
      text-align: center;
      padding: 0 20px;
    }
    .start-btn {
      font-family: 'Bangers', cursive;
      font-size: 2rem;
      padding: 15px 50px;
      background: var(--safe-green);
      color: #000;
      border: none;
      border-radius: 10px;
      cursor: pointer;
      box-shadow: 0 5px 0 #22aa44, 0 10px 20px rgba(0,0,0,0.5);
      transition: all 0.1s;
      letter-spacing: 2px;
    }
    .start-btn:hover { transform: translateY(-3px); box-shadow: 0 8px 0 #22aa44, 0 15px 25px rgba(0,0,0,0.5); }
    .start-btn:active { transform: translateY(3px); box-shadow: 0 2px 0 #22aa44, 0 5px 10px rgba(0,0,0,0.5); }
    .game-over {
      position: absolute;
      top: 0; left: 0; right: 0; bottom: 0;
      background: rgba(0,0,0,0.9);
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      z-index: 500;
    }
    .game-over h2 {
      font-size: 2.5rem;
      color: var(--danger-red);
      text-shadow: 3px 3px 0 #000, 0 0 20px var(--danger-red);
      margin-bottom: 10px;
    }
    .game-over .final-score { font-size: 1.5rem; color: var(--warning-yellow); margin-bottom: 10px; }
    .game-over p { font-family: 'Roboto Mono', monospace; font-size: 0.9rem; color: #888; margin-bottom: 30px; }
    .hidden { display: none !important; }
    footer {
      position: absolute;
      bottom: 10px; left: 0; right: 0;
      text-align: center;
      font-family: 'Roboto Mono', monospace;
      font-size: 0.7rem;
      color: #555;
      z-index: 10;
    }
    footer a { color: var(--warning-yellow); text-decoration: none; }
    .laugh-bubble {
      position: absolute;
      font-size: 1.2rem;
      pointer-events: none;
      animation: laughFloat 1s forwards;
      z-index: 150;
    }
    @keyframes laughFloat {
      0% { opacity: 1; transform: translateY(0) scale(1); }
      100% { opacity: 0; transform: translateY(-80px) scale(0.5); }
    }
    @media (max-width: 600px) {
      .start-screen h1 { font-size: 2rem; }
      .score { font-size: 1.5rem; }
      .grump-bar { width: 100px; }
      .robot { transform: translate(-50%, -50%) scale(0.8); }
      .tickle-hand { width: 90px; height: 110px; }
      .tickle-hand.mega-mitt { width: 180px; height: 220px; }
    }
    /* MEGA MITT BOSS */
    .tickle-hand.mega-mitt {
      width: 240px; height: 300px;
      z-index: 90;
      filter: drop-shadow(0 0 30px #ff00ff) drop-shadow(0 10px 30px rgba(0,0,0,0.7));
    }
    .tickle-hand.mega-mitt.wiggle {
      animation: megaWiggle 0.4s infinite;
    }
    @keyframes megaWiggle {
      0%, 100% { transform: rotate(-8deg) scale(1); }
      50% { transform: rotate(8deg) scale(1.05); }
    }
    .mega-mitt-hp {
      position: absolute;
      bottom: -35px;
      left: 50%;
      transform: translateX(-50%);
      width: 180px;
      text-align: center;
    }
    .mega-mitt-label {
      font-family: 'Bangers', cursive;
      font-size: 1rem;
      color: #ff00ff;
      text-shadow: 2px 2px 0 #000, 0 0 10px #ff00ff;
      margin-bottom: 5px;
    }
    .mega-mitt-bar {
      width: 100%;
      height: 16px;
      background: #222;
      border: 3px solid #ff00ff;
      border-radius: 8px;
      overflow: hidden;
      box-shadow: 0 0 15px rgba(255, 0, 255, 0.5);
    }
    .mega-mitt-fill {
      height: 100%;
      background: linear-gradient(90deg, #ff0066, #ff00ff, #ff66ff);
      transition: width 0.2s;
      box-shadow: inset 0 0 10px rgba(255,255,255,0.3);
    }
    .mega-mitt-warning {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      font-family: 'Bangers', cursive;
      font-size: 3rem;
      color: #ff00ff;
      text-shadow: 3px 3px 0 #000, 0 0 30px #ff00ff, 0 0 60px #ff00ff;
      animation: warningPulse 0.5s ease-out forwards;
      pointer-events: none;
      z-index: 400;
    }
    @keyframes warningPulse {
      0% { opacity: 0; transform: translate(-50%, -50%) scale(0.5); }
      50% { opacity: 1; transform: translate(-50%, -50%) scale(1.2); }
      100% { opacity: 0; transform: translate(-50%, -50%) scale(1.5); }
    }
    .mega-defeated {
      position: absolute;
      font-family: 'Bangers', cursive;
      font-size: 2.5rem;
      color: #ffff00;
      text-shadow: 3px 3px 0 #000, 0 0 20px #ffff00;
      animation: defeatBurst 1s forwards;
      pointer-events: none;
      z-index: 350;
    }
    @keyframes defeatBurst {
      0% { opacity: 1; transform: scale(1) rotate(0deg); }
      50% { transform: scale(1.5) rotate(10deg); }
      100% { opacity: 0; transform: scale(2) rotate(-5deg) translateY(-50px); }
    }
  </style>
</head>
<body>
  <div class="game-container" id="gameContainer">
    <div class="game-header">
      <div class="score">SCORE: <span id="scoreValue">0</span></div>
      <div class="grump-meter">
        <span class="grump-label">GRUMP</span>
        <div class="grump-bar">
          <div class="grump-fill" id="grumpFill" style="width: 100%"></div>
        </div>
      </div>
    </div>
    <div class="robot grumpy" id="robot">
      <div class="robot-antenna"></div>
      <div class="robot-head">
        <div class="robot-eyes">
          <div class="robot-eye"></div>
          <div class="robot-eye"></div>
        </div>
        <div class="robot-mouth"></div>
      </div>
      <div class="robot-body">
        <div class="robot-chest">
          <div class="robot-light"></div>
          <div class="robot-light"></div>
          <div class="robot-light"></div>
        </div>
        <div class="robot-arms">
          <div class="robot-arm"></div>
          <div class="robot-arm"></div>
        </div>
      </div>
      <div class="robot-blaster" id="robotBlaster"></div>
    </div>
    <div class="start-screen" id="startScreen">
      <h1>TICKLE DEFENSE</h1>
      <p>Protect the grumpy robot from tickling hands!<br>Click/tap anywhere to shoot neon lasers!</p>
      <button class="start-btn" id="startBtn">START!</button>
    </div>
    <div class="game-over hidden" id="gameOver">
      <h2>ROBOT BROKE DOWN!</h2>
      <div class="final-score">SCORE: <span id="finalScore">0</span></div>
      <p>Too much tickling overloaded the circuits!</p>
      <button class="start-btn" id="restartBtn">TRY AGAIN</button>
    </div>
    <footer><a href="https://sloppy.live">‚Üê back to sloppy.live</a></footer>
  </div>
  <script>
    let score = 0, grumpLevel = 100, gameActive = false, hands = [], projectiles = [];
    let spawnInterval = null, tickleInterval = null, difficultyInterval = null, megaMittInterval = null, difficulty = 1;
    let megaMittActive = false;
    const gameContainer = document.getElementById('gameContainer');
    const robot = document.getElementById('robot');
    const robotBlaster = document.getElementById('robotBlaster');
    const scoreValue = document.getElementById('scoreValue');
    const grumpFill = document.getElementById('grumpFill');
    const startScreen = document.getElementById('startScreen');
    const gameOver = document.getElementById('gameOver');
    const finalScore = document.getElementById('finalScore');
    let robotRect = null;
    let blasterRect = null;
    function updateRobotRect() {
      robotRect = robot.getBoundingClientRect();
      blasterRect = robotBlaster.getBoundingClientRect();
    }
    function createHandSVG(flipped = false) {
      const skinTones = ['#ffdbac', '#f1c27d', '#e0ac69', '#c68642', '#8d5524'];
      const skinTone = skinTones[Math.floor(Math.random() * skinTones.length)];
      const darkerTone = shadeColor(skinTone, -20);
      return '<svg class="hand-svg" viewBox="0 0 100 130" style="transform: scaleX('+(flipped ? -1 : 1)+')">'+
        '<ellipse cx="50" cy="80" rx="35" ry="40" fill="'+skinTone+'" stroke="'+darkerTone+'" stroke-width="2"/>'+
        '<ellipse cx="20" cy="60" rx="12" ry="20" fill="'+skinTone+'" stroke="'+darkerTone+'" stroke-width="1.5" transform="rotate(-30 20 60)"/>'+
        '<rect x="25" y="5" width="14" height="55" rx="7" fill="'+skinTone+'" stroke="'+darkerTone+'" stroke-width="1.5"><animate attributeName="y" values="5;3;5" dur="0.3s" repeatCount="indefinite"/></rect>'+
        '<rect x="43" y="0" width="14" height="60" rx="7" fill="'+skinTone+'" stroke="'+darkerTone+'" stroke-width="1.5"><animate attributeName="y" values="0;-2;0" dur="0.25s" repeatCount="indefinite"/></rect>'+
        '<rect x="61" y="5" width="13" height="52" rx="6.5" fill="'+skinTone+'" stroke="'+darkerTone+'" stroke-width="1.5"><animate attributeName="y" values="5;3;5" dur="0.35s" repeatCount="indefinite"/></rect>'+
        '<rect x="77" y="15" width="11" height="42" rx="5.5" fill="'+skinTone+'" stroke="'+darkerTone+'" stroke-width="1.5"><animate attributeName="y" values="15;13;15" dur="0.28s" repeatCount="indefinite"/></rect>'+
        '<line x1="28" y1="35" x2="36" y2="35" stroke="'+darkerTone+'" stroke-width="1" opacity="0.5"/>'+
        '<line x1="46" y1="33" x2="54" y2="33" stroke="'+darkerTone+'" stroke-width="1" opacity="0.5"/>'+
        '<line x1="63" y1="35" x2="71" y2="35" stroke="'+darkerTone+'" stroke-width="1" opacity="0.5"/>'+
        '<line x1="79" y1="38" x2="86" y2="38" stroke="'+darkerTone+'" stroke-width="1" opacity="0.5"/>'+
        '<path d="M 30 70 Q 50 60 70 70" stroke="'+darkerTone+'" stroke-width="1" fill="none" opacity="0.4"/>'+
        '<path d="M 25 85 Q 50 75 75 85" stroke="'+darkerTone+'" stroke-width="1" fill="none" opacity="0.4"/>'+
        '<rect x="35" y="115" width="30" height="20" rx="5" fill="'+skinTone+'" stroke="'+darkerTone+'" stroke-width="2"/></svg>';
    }
    function shadeColor(color, percent) {
      const num = parseInt(color.replace('#', ''), 16);
      const amt = Math.round(2.55 * percent);
      const R = Math.min(255, Math.max(0, (num >> 16) + amt));
      const G = Math.min(255, Math.max(0, (num >> 8 & 0x00FF) + amt));
      const B = Math.min(255, Math.max(0, (num & 0x0000FF) + amt));
      return '#'+(0x1000000 + R * 0x10000 + G * 0x100 + B).toString(16).slice(1);
    }
    function spawnHand() {
      if (!gameActive) return;
      updateRobotRect();
      const hand = document.createElement('div');
      hand.className = 'tickle-hand wiggle';
      hand.innerHTML = createHandSVG(Math.random() > 0.5);
      const side = Math.floor(Math.random() * 4);
      const containerRect = gameContainer.getBoundingClientRect();
      let startX, startY;
      const robotCenterX = robotRect.left + robotRect.width / 2;
      const robotCenterY = robotRect.top + robotRect.height / 2;
      switch (side) {
        case 0: startX = Math.random() * containerRect.width; startY = -150; break;
        case 1: startX = containerRect.width + 50; startY = Math.random() * containerRect.height; break;
        case 2: startX = Math.random() * containerRect.width; startY = containerRect.height + 50; break;
        case 3: startX = -150; startY = Math.random() * containerRect.height; break;
      }
      hand.style.left = startX + 'px';
      hand.style.top = startY + 'px';
      const dx = robotCenterX - startX + (Math.random() - 0.5) * 100;
      const dy = robotCenterY - startY + (Math.random() - 0.5) * 100;
      const dist = Math.sqrt(dx * dx + dy * dy);
      const speed = 1.5 + difficulty * 0.3;
      const vx = (dx / dist) * speed;
      const vy = (dy / dist) * speed;
      const handData = { element: hand, x: startX, y: startY, vx: vx, vy: vy, tickling: false, width: 120, height: 150 };
      gameContainer.appendChild(hand);
      hands.push(handData);
    }
    function spawnMegaMitt() {
      if (!gameActive || megaMittActive) return;
      megaMittActive = true;
      updateRobotRect();
      // Show warning
      const warning = document.createElement('div');
      warning.className = 'mega-mitt-warning';
      warning.textContent = '‚ö†Ô∏è MEGA MITT INCOMING! ‚ö†Ô∏è';
      gameContainer.appendChild(warning);
      setTimeout(() => warning.remove(), 1500);
      setTimeout(() => {
        if (!gameActive) return;
        const hand = document.createElement('div');
        hand.className = 'tickle-hand mega-mitt wiggle';
        hand.innerHTML = createMegaMittSVG();
        // Add health bar
        const hpContainer = document.createElement('div');
        hpContainer.className = 'mega-mitt-hp';
        hpContainer.innerHTML = '<div class="mega-mitt-label">MEGA MITT</div><div class="mega-mitt-bar"><div class="mega-mitt-fill" style="width:100%"></div></div>';
        hand.appendChild(hpContainer);
        const side = Math.floor(Math.random() * 4);
        const containerRect = gameContainer.getBoundingClientRect();
        let startX, startY;
        const robotCenterX = robotRect.left + robotRect.width / 2;
        const robotCenterY = robotRect.top + robotRect.height / 2;
        switch (side) {
          case 0: startX = Math.random() * containerRect.width; startY = -300; break;
          case 1: startX = containerRect.width + 100; startY = Math.random() * containerRect.height; break;
          case 2: startX = Math.random() * containerRect.width; startY = containerRect.height + 100; break;
          case 3: startX = -300; startY = Math.random() * containerRect.height; break;
        }
        hand.style.left = startX + 'px';
        hand.style.top = startY + 'px';
        const dx = robotCenterX - startX;
        const dy = robotCenterY - startY;
        const dist = Math.sqrt(dx * dx + dy * dy);
        const speed = 0.8;
        const handData = {
          element: hand,
          x: startX, y: startY,
          vx: (dx / dist) * speed,
          vy: (dy / dist) * speed,
          tickling: false,
          isMegaMitt: true,
          hp: 10,
          maxHp: 10,
          width: 240,
          height: 300,
          hpBar: hpContainer.querySelector('.mega-mitt-fill')
        };
        gameContainer.appendChild(hand);
        hands.push(handData);
      }, 1000);
    }
    function createMegaMittSVG() {
      const skinTone = '#ff99cc';
      const darkerTone = '#cc6699';
      return '<svg class="hand-svg" viewBox="0 0 100 130">'+
        '<ellipse cx="50" cy="80" rx="35" ry="40" fill="'+skinTone+'" stroke="'+darkerTone+'" stroke-width="3"/>'+
        '<ellipse cx="20" cy="60" rx="12" ry="20" fill="'+skinTone+'" stroke="'+darkerTone+'" stroke-width="2" transform="rotate(-30 20 60)"/>'+
        '<rect x="25" y="5" width="14" height="55" rx="7" fill="'+skinTone+'" stroke="'+darkerTone+'" stroke-width="2"><animate attributeName="y" values="5;1;5" dur="0.2s" repeatCount="indefinite"/></rect>'+
        '<rect x="43" y="0" width="14" height="60" rx="7" fill="'+skinTone+'" stroke="'+darkerTone+'" stroke-width="2"><animate attributeName="y" values="0;-4;0" dur="0.15s" repeatCount="indefinite"/></rect>'+
        '<rect x="61" y="5" width="13" height="52" rx="6.5" fill="'+skinTone+'" stroke="'+darkerTone+'" stroke-width="2"><animate attributeName="y" values="5;1;5" dur="0.25s" repeatCount="indefinite"/></rect>'+
        '<rect x="77" y="15" width="11" height="42" rx="5.5" fill="'+skinTone+'" stroke="'+darkerTone+'" stroke-width="2"><animate attributeName="y" values="15;11;15" dur="0.18s" repeatCount="indefinite"/></rect>'+
        '<path d="M 30 70 Q 50 60 70 70" stroke="'+darkerTone+'" stroke-width="2" fill="none" opacity="0.6"/>'+
        '<path d="M 25 85 Q 50 75 75 85" stroke="'+darkerTone+'" stroke-width="2" fill="none" opacity="0.6"/>'+
        '<rect x="35" y="115" width="30" height="20" rx="5" fill="'+skinTone+'" stroke="'+darkerTone+'" stroke-width="3"/>'+
        '<text x="50" y="95" text-anchor="middle" fill="#ff00ff" font-size="12" font-family="Bangers" style="text-shadow:0 0 5px #fff">BOSS</text>'+
        '</svg>';
    }
    function hitHand(handData) {
      if (!gameActive) return;
      // Handle Mega Mitt boss
      if (handData.isMegaMitt) {
        handData.hp--;
        const hpPercent = (handData.hp / handData.maxHp) * 100;
        handData.hpBar.style.width = hpPercent + '%';
        showFloatingText('-1', handData.x + 100, handData.y + 50, '#ff00ff');
        // Shake effect
        handData.element.style.transform = 'scale(0.95)';
        setTimeout(() => { if (handData.element) handData.element.style.transform = ''; }, 100);
        if (handData.hp <= 0) {
          // Defeated!
          const defeated = document.createElement('div');
          defeated.className = 'mega-defeated';
          defeated.textContent = 'MEGA MITT DEFEATED! +500';
          defeated.style.left = handData.x + 'px';
          defeated.style.top = handData.y + 'px';
          gameContainer.appendChild(defeated);
          setTimeout(() => defeated.remove(), 1000);
          handData.element.remove();
          const index = hands.indexOf(handData);
          if (index > -1) hands.splice(index, 1);
          score += 500;
          scoreValue.textContent = score;
          megaMittActive = false;
          if (handData.tickling) checkTickleState();
        }
        return false; // Don't destroy projectile on Mega Mitt (need multiple hits)
      }
      // Regular hand - ZAP effect
      const zap = document.createElement('div');
      zap.className = 'zap-effect';
      zap.style.left = handData.x + 'px';
      zap.style.top = handData.y + 'px';
      gameContainer.appendChild(zap);
      setTimeout(() => zap.remove(), 400);
      handData.element.remove();
      const index = hands.indexOf(handData);
      if (index > -1) hands.splice(index, 1);
      const points = handData.tickling ? 50 : 10;
      score += points;
      scoreValue.textContent = score;
      showFloatingText('+'+points, handData.x + 40, handData.y, '#00ffff');
      if (handData.tickling) checkTickleState();
      return true; // Destroy projectile after hitting regular hand
    }
    // Shoot laser projectile
    function shootLaser(targetX, targetY) {
      if (!gameActive) return;
      updateRobotRect();
      // Start from blaster position
      const startX = blasterRect.left + blasterRect.width / 2;
      const startY = blasterRect.top + blasterRect.height / 2;
      // Direction toward click
      const dx = targetX - startX;
      const dy = targetY - startY;
      const dist = Math.sqrt(dx * dx + dy * dy);
      if (dist < 10) return; // Too close
      const speed = 15;
      const vx = (dx / dist) * speed;
      const vy = (dy / dist) * speed;
      // Create projectile
      const proj = document.createElement('div');
      proj.className = 'laser-projectile';
      proj.style.left = startX + 'px';
      proj.style.top = startY + 'px';
      // Rotate to face direction
      const angle = Math.atan2(dy, dx) * (180 / Math.PI);
      proj.style.transform = 'translate(-50%, -50%) rotate(' + angle + 'deg)';
      gameContainer.appendChild(proj);
      projectiles.push({ element: proj, x: startX, y: startY, vx: vx, vy: vy, angle: angle });
      // Muzzle flash
      const flash = document.createElement('div');
      flash.className = 'muzzle-flash';
      flash.style.left = (startX - 15) + 'px';
      flash.style.top = (startY - 15) + 'px';
      gameContainer.appendChild(flash);
      setTimeout(() => flash.remove(), 150);
    }
    // Check projectile-hand collision
    function checkProjectileCollisions() {
      for (let i = projectiles.length - 1; i >= 0; i--) {
        const proj = projectiles[i];
        let hit = false;
        for (let j = hands.length - 1; j >= 0; j--) {
          const hand = hands[j];
          // Simple box collision
          const hCenterX = hand.x + hand.width / 2;
          const hCenterY = hand.y + hand.height / 2;
          const collisionRadius = hand.isMegaMitt ? 100 : 60;
          const dx = proj.x - hCenterX;
          const dy = proj.y - hCenterY;
          const dist = Math.sqrt(dx * dx + dy * dy);
          if (dist < collisionRadius) {
            const shouldDestroy = hitHand(hand);
            if (shouldDestroy !== false) {
              hit = true;
              break;
            }
          }
        }
        // Remove projectile if hit or off screen
        if (hit || proj.x < -50 || proj.x > window.innerWidth + 50 || proj.y < -50 || proj.y > window.innerHeight + 50) {
          proj.element.remove();
          projectiles.splice(i, 1);
        }
      }
    }
    function showFloatingText(text, x, y, color) {
      const el = document.createElement('div');
      el.className = 'tickle-text';
      el.textContent = text;
      el.style.left = x + 'px';
      el.style.top = y + 'px';
      el.style.color = color || '#ffcc00';
      gameContainer.appendChild(el);
      setTimeout(() => el.remove(), 500);
    }
    function showLaughBubble() {
      const laughs = ['AHAHA!', 'HEE HEE!', 'STOP!', 'NO!', '*bzzt*', 'ERROR!', 'HELP!', 'TEE HEE!', 'GAHAHA!', '*BEEP*'];
      const el = document.createElement('div');
      el.className = 'laugh-bubble';
      el.textContent = laughs[Math.floor(Math.random() * laughs.length)];
      el.style.left = (robotRect.left + Math.random() * robotRect.width) + 'px';
      el.style.top = (robotRect.top - 20) + 'px';
      el.style.color = ['#ff0', '#f0f', '#0ff', '#f00'][Math.floor(Math.random() * 4)];
      gameContainer.appendChild(el);
      setTimeout(() => el.remove(), 1000);
    }
    function updateGame() {
      if (!gameActive) return;
      updateRobotRect();
      const robotCenterX = robotRect.left + robotRect.width / 2;
      const robotCenterY = robotRect.top + robotRect.height / 2;
      const tickleRadius = 80;
      let anyTickling = false;
      // Update hands
      hands.forEach(hand => {
        hand.x += hand.vx;
        hand.y += hand.vy;
        hand.element.style.left = hand.x + 'px';
        hand.element.style.top = hand.y + 'px';
        const hx = hand.x + (hand.width || 120) / 2;
        const hy = hand.y + (hand.height || 150) / 2;
        const dist = Math.sqrt((hx - robotCenterX) ** 2 + (hy - robotCenterY) ** 2);
        if (dist < tickleRadius) {
          hand.tickling = true;
          hand.vx *= 0.5;
          hand.vy *= 0.5;
          anyTickling = true;
        }
        if (hand.x < -300 || hand.x > window.innerWidth + 300 || hand.y < -300 || hand.y > window.innerHeight + 300) {
          hand.element.remove();
          const index = hands.indexOf(hand);
          if (index > -1) hands.splice(index, 1);
        }
      });
      // Update projectiles
      projectiles.forEach(proj => {
        proj.x += proj.vx;
        proj.y += proj.vy;
        proj.element.style.left = proj.x + 'px';
        proj.element.style.top = proj.y + 'px';
      });
      // Check collisions
      checkProjectileCollisions();
      if (anyTickling) { robot.classList.add('tickled'); robot.classList.remove('grumpy'); }
      else { robot.classList.remove('tickled'); robot.classList.add('grumpy'); }
    }
    function checkTickleState() {
      const anyTickling = hands.some(h => h.tickling);
      if (!anyTickling) { robot.classList.remove('tickled'); robot.classList.add('grumpy'); }
    }
    function tickleDamage() {
      if (!gameActive) return;
      const ticklingHands = hands.filter(h => h.tickling);
      if (ticklingHands.length > 0) {
        let damage = 0;
        ticklingHands.forEach(h => {
          damage += h.isMegaMitt ? 5 : 2; // Mega Mitt does 5 damage per tick!
        });
        grumpLevel -= damage;
        grumpFill.style.width = Math.max(0, grumpLevel) + '%';
        if (Math.random() > 0.5) showLaughBubble();
        if (grumpLevel <= 0) endGame();
      } else {
        grumpLevel = Math.min(100, grumpLevel + 0.5);
        grumpFill.style.width = grumpLevel + '%';
      }
    }
    function increaseDifficulty() {
      if (!gameActive) return;
      difficulty += 0.1;
      clearInterval(spawnInterval);
      const newRate = Math.max(500, 2000 - difficulty * 100);
      spawnInterval = setInterval(spawnHand, newRate);
    }
    function startGame() {
      score = 0; grumpLevel = 100; difficulty = 1;
      megaMittActive = false;
      hands.forEach(h => h.element.remove());
      hands = [];
      projectiles.forEach(p => p.element.remove());
      projectiles = [];
      gameActive = true;
      scoreValue.textContent = '0';
      grumpFill.style.width = '100%';
      startScreen.classList.add('hidden');
      gameOver.classList.add('hidden');
      robot.classList.remove('tickled');
      robot.classList.add('grumpy');
      gameContainer.classList.add('playing');
      clearInterval(spawnInterval);
      clearInterval(tickleInterval);
      clearInterval(difficultyInterval);
      clearInterval(megaMittInterval);
      spawnInterval = setInterval(spawnHand, 2000);
      tickleInterval = setInterval(tickleDamage, 100);
      difficultyInterval = setInterval(increaseDifficulty, 5000);
      // Mega Mitt spawns rarely - every 15-25 seconds with 50% chance
      megaMittInterval = setInterval(() => {
        if (Math.random() > 0.5) spawnMegaMitt();
      }, 15000 + Math.random() * 10000);
      function loop() { if (gameActive) { updateGame(); requestAnimationFrame(loop); } }
      loop();
      setTimeout(spawnHand, 500);
    }
    function endGame() {
      gameActive = false;
      clearInterval(spawnInterval);
      clearInterval(tickleInterval);
      clearInterval(difficultyInterval);
      clearInterval(megaMittInterval);
      megaMittActive = false;
      gameContainer.classList.remove('playing');
      finalScore.textContent = score;
      gameOver.classList.remove('hidden');
      robot.classList.add('tickled');
    }
    document.getElementById('startBtn').onclick = startGame;
    document.getElementById('restartBtn').onclick = startGame;
    // Shooting handlers
    gameContainer.addEventListener('click', (e) => {
      if (!gameActive) return;
      // Don't shoot if clicking buttons
      if (e.target.closest('.start-screen') || e.target.closest('.game-over')) return;
      shootLaser(e.clientX, e.clientY);
    });
    gameContainer.addEventListener('touchstart', (e) => {
      if (!gameActive) return;
      if (e.target.closest('.start-screen') || e.target.closest('.game-over')) return;
      e.preventDefault();
      const touch = e.touches[0];
      shootLaser(touch.clientX, touch.clientY);
    }, { passive: false });
    let lastTouchEnd = 0;
    document.addEventListener('touchend', (e) => {
      const now = Date.now();
      if (now - lastTouchEnd <= 300) e.preventDefault();
      lastTouchEnd = now;
    }, { passive: false });
    setTimeout(updateRobotRect, 100);
    window.addEventListener('resize', updateRobotRect);
  </script>
<script src="/sloppy-header/sloppy-bar.js"></script>
<script src="/vibelib-extended.js"></script>
<script>
  // Compatibility Patch for Legacy Apps
  window.addEventListener("load", () => {
    if (window.SloppyKarma && window.VibeLib.Economy) {
      // Redirect old calls to new engine
      window.SloppyKarma.track = window.VibeLib.Economy.track;
    }
  });
</script>
</body>
</html>
