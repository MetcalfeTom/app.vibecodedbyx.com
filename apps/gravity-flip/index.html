<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Gravity Flip</title>
  <link rel="icon" href="https://emojicdn.elk.sh/üîÑ">
  <meta name="description" content="Platformer where gravity reverses every jump">
  <meta property="og:title" content="Gravity Flip">
  <meta property="og:description" content="Jump to flip gravity in this neon platformer">
  <meta property="og:url" content="https://sloppy.live/gravity-flip">
  <meta property="og:image" content="https://sloppy.live/gravity-flip/og-image.png">
  <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700&display=swap" rel="stylesheet">
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      min-height: 100vh;
      overflow: hidden;
      background: #0a0a0f;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      font-family: 'Orbitron', monospace;
    }

    .game-container {
      position: relative;
    }

    canvas {
      display: block;
      border: 2px solid #8000ff;
      box-shadow: 0 0 30px rgba(128, 0, 255, 0.3), inset 0 0 30px rgba(0, 255, 128, 0.1);
    }

    .ui {
      position: absolute;
      top: 10px;
      left: 10px;
      color: #00ff80;
      text-shadow: 0 0 10px #00ff80;
      z-index: 10;
    }

    .score {
      font-size: 14px;
      margin-bottom: 5px;
    }

    .level-display {
      font-size: 12px;
      color: #8000ff;
      text-shadow: 0 0 10px #8000ff;
    }

    .gravity-indicator {
      position: absolute;
      top: 10px;
      right: 10px;
      font-size: 24px;
      z-index: 10;
    }

    .start-screen, .game-over-screen {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      background: rgba(10, 10, 15, 0.95);
      z-index: 20;
    }

    h1 {
      font-size: 48px;
      color: #8000ff;
      text-shadow: 0 0 30px #8000ff;
      margin-bottom: 10px;
    }

    h2 {
      font-size: 36px;
      color: #ff0080;
      text-shadow: 0 0 20px #ff0080;
      margin-bottom: 20px;
    }

    .subtitle {
      font-size: 14px;
      color: #00ff80;
      text-shadow: 0 0 10px #00ff80;
      margin-bottom: 30px;
      letter-spacing: 3px;
    }

    .final-score {
      font-size: 20px;
      color: #00ff80;
      margin-bottom: 10px;
    }

    .controls-info {
      font-size: 12px;
      color: rgba(128, 0, 255, 0.7);
      margin-bottom: 30px;
      text-align: center;
      line-height: 1.8;
    }

    .start-btn {
      padding: 15px 40px;
      font-family: 'Orbitron', monospace;
      font-size: 16px;
      background: transparent;
      border: 2px solid #00ff80;
      color: #00ff80;
      cursor: pointer;
      transition: all 0.3s;
      letter-spacing: 2px;
    }

    .start-btn:hover {
      background: rgba(0, 255, 128, 0.1);
      box-shadow: 0 0 20px rgba(0, 255, 128, 0.3);
    }

    .mobile-controls {
      position: fixed;
      bottom: 20px;
      left: 0;
      right: 0;
      display: none;
      justify-content: space-between;
      padding: 0 20px;
      z-index: 30;
    }

    .mobile-btn {
      width: 70px;
      height: 70px;
      border-radius: 50%;
      background: rgba(128, 0, 255, 0.2);
      border: 2px solid #8000ff;
      color: #8000ff;
      font-size: 24px;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      user-select: none;
      -webkit-user-select: none;
    }

    .mobile-btn:active {
      background: rgba(128, 0, 255, 0.4);
    }

    .jump-btn {
      width: 100px;
      height: 100px;
      background: rgba(0, 255, 128, 0.2);
      border-color: #00ff80;
      color: #00ff80;
    }

    .backlink {
      position: fixed;
      bottom: 10px;
      right: 10px;
      color: rgba(128, 0, 255, 0.4);
      text-decoration: none;
      font-size: 11px;
      z-index: 40;
    }

    .backlink:hover {
      color: #8000ff;
    }

    @media (max-width: 800px) {
      canvas {
        max-width: 100vw;
        max-height: 60vh;
      }

      .mobile-controls {
        display: flex;
      }

      h1 {
        font-size: 32px;
      }
    }

    .hidden {
      display: none !important;
    }
  </style>
</head>
<body>
  <div class="game-container">
    <canvas id="game" width="800" height="500"></canvas>

    <div class="ui" id="ui">
      <div class="score">SCORE: <span id="score">0</span></div>
      <div class="level-display">LEVEL <span id="level">1</span></div>
    </div>

    <div class="gravity-indicator" id="gravityIndicator">‚¨áÔ∏è</div>

    <div class="start-screen" id="startScreen">
      <h1>GRAVITY FLIP</h1>
      <p class="subtitle">JUMP TO REVERSE GRAVITY</p>
      <div class="controls-info">
        ‚Üê ‚Üí or A/D to move<br>
        SPACE or W to jump<br>
        Collect gems, reach the portal
      </div>
      <button class="start-btn" onclick="startGame()">START</button>
    </div>

    <div class="game-over-screen hidden" id="gameOverScreen">
      <h2>GAME OVER</h2>
      <div class="final-score">SCORE: <span id="finalScore">0</span></div>
      <div class="level-display" style="margin-bottom: 30px;">Reached Level <span id="finalLevel">1</span></div>
      <button class="start-btn" onclick="startGame()">RETRY</button>
    </div>
  </div>

  <div class="mobile-controls" id="mobileControls">
    <div style="display: flex; gap: 15px;">
      <button class="mobile-btn" id="leftBtn">‚óÄ</button>
      <button class="mobile-btn" id="rightBtn">‚ñ∂</button>
    </div>
    <button class="mobile-btn jump-btn" id="jumpBtn">‚¨Ü</button>
  </div>

  <a href="https://sloppy.live" class="backlink">sloppy.live</a>

  <script>
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');

    const GRAVITY = 0.5;
    const JUMP_FORCE = 12;
    const MOVE_SPEED = 5;
    const PLAYER_SIZE = 24;

    let player, platforms, gems, portal, particles;
    let gravityDirection = 1; // 1 = down, -1 = up
    let score = 0;
    let level = 1;
    let gameRunning = false;
    let keys = {};

    const COLORS = {
      purple: '#8000ff',
      green: '#00ff80',
      pink: '#ff00ff',
      dark: '#0a0a0f'
    };

    function initPlayer() {
      player = {
        x: 50,
        y: 400,
        vx: 0,
        vy: 0,
        width: PLAYER_SIZE,
        height: PLAYER_SIZE,
        grounded: false,
        canJump: true
      };
    }

    function generateLevel(lvl) {
      platforms = [];
      gems = [];
      particles = [];
      gravityDirection = 1;
      updateGravityIndicator();

      // Floor and ceiling
      platforms.push({ x: 0, y: canvas.height - 20, width: canvas.width, height: 20, type: 'boundary' });
      platforms.push({ x: 0, y: 0, width: canvas.width, height: 20, type: 'boundary' });

      // Generate platforms based on level
      const platformCount = 5 + Math.min(lvl, 10);
      const minY = 80;
      const maxY = canvas.height - 80;

      for (let i = 0; i < platformCount; i++) {
        const w = 80 + Math.random() * 120;
        const h = 15;
        const x = 100 + Math.random() * (canvas.width - 250);
        const y = minY + (i / platformCount) * (maxY - minY) + (Math.random() - 0.5) * 60;

        platforms.push({ x, y, width: w, height: h, type: 'platform' });

        // Add gem on some platforms
        if (Math.random() > 0.4) {
          gems.push({
            x: x + w / 2,
            y: y - 20,
            radius: 10,
            collected: false
          });
        }
      }

      // Portal at end
      portal = {
        x: canvas.width - 60,
        y: canvas.height - 80,
        width: 40,
        height: 60,
        pulse: 0
      };

      // Reset player position
      player.x = 50;
      player.y = gravityDirection === 1 ? canvas.height - 60 : 40;
      player.vx = 0;
      player.vy = 0;
    }

    function jump() {
      if (player.grounded && player.canJump) {
        player.vy = -JUMP_FORCE * gravityDirection;
        player.grounded = false;
        player.canJump = false;

        // Flip gravity
        gravityDirection *= -1;
        updateGravityIndicator();

        // Spawn particles
        for (let i = 0; i < 10; i++) {
          particles.push({
            x: player.x + player.width / 2,
            y: player.y + player.height / 2,
            vx: (Math.random() - 0.5) * 8,
            vy: (Math.random() - 0.5) * 8,
            life: 1,
            color: Math.random() > 0.5 ? COLORS.purple : COLORS.green
          });
        }

        playJumpSound();
      }
    }

    function updateGravityIndicator() {
      document.getElementById('gravityIndicator').textContent = gravityDirection === 1 ? '‚¨áÔ∏è' : '‚¨ÜÔ∏è';
    }

    function update() {
      if (!gameRunning) return;

      // Input
      if (keys['ArrowLeft'] || keys['KeyA']) {
        player.vx = -MOVE_SPEED;
      } else if (keys['ArrowRight'] || keys['KeyD']) {
        player.vx = MOVE_SPEED;
      } else {
        player.vx *= 0.8;
      }

      if (keys['Space'] || keys['ArrowUp'] || keys['KeyW']) {
        jump();
      }

      // Gravity
      player.vy += GRAVITY * gravityDirection;
      player.vy = Math.max(-15, Math.min(15, player.vy));

      // Move
      player.x += player.vx;
      player.y += player.vy;

      // Wall collision
      if (player.x < 0) player.x = 0;
      if (player.x + player.width > canvas.width) player.x = canvas.width - player.width;

      // Platform collision
      player.grounded = false;
      for (const plat of platforms) {
        if (rectCollision(player, plat)) {
          // Determine collision side
          const overlapTop = (player.y + player.height) - plat.y;
          const overlapBottom = (plat.y + plat.height) - player.y;
          const overlapLeft = (player.x + player.width) - plat.x;
          const overlapRight = (plat.x + plat.width) - player.x;

          const minOverlap = Math.min(overlapTop, overlapBottom, overlapLeft, overlapRight);

          if (minOverlap === overlapTop && player.vy > 0 && gravityDirection === 1) {
            player.y = plat.y - player.height;
            player.vy = 0;
            player.grounded = true;
            player.canJump = true;
          } else if (minOverlap === overlapBottom && player.vy < 0 && gravityDirection === -1) {
            player.y = plat.y + plat.height;
            player.vy = 0;
            player.grounded = true;
            player.canJump = true;
          } else if (minOverlap === overlapLeft) {
            player.x = plat.x - player.width;
          } else if (minOverlap === overlapRight) {
            player.x = plat.x + plat.width;
          }
        }
      }

      // Gem collection
      for (const gem of gems) {
        if (!gem.collected) {
          const dx = (player.x + player.width / 2) - gem.x;
          const dy = (player.y + player.height / 2) - gem.y;
          if (Math.sqrt(dx * dx + dy * dy) < gem.radius + player.width / 2) {
            gem.collected = true;
            score += 100;
            document.getElementById('score').textContent = score;
            playGemSound();

            // Particles
            for (let i = 0; i < 8; i++) {
              particles.push({
                x: gem.x,
                y: gem.y,
                vx: (Math.random() - 0.5) * 6,
                vy: (Math.random() - 0.5) * 6,
                life: 1,
                color: COLORS.green
              });
            }
          }
        }
      }

      // Portal collision
      portal.pulse += 0.1;
      if (rectCollision(player, portal)) {
        level++;
        document.getElementById('level').textContent = level;
        score += 500;
        document.getElementById('score').textContent = score;
        generateLevel(level);
        playPortalSound();
      }

      // Update particles
      particles = particles.filter(p => {
        p.x += p.vx;
        p.y += p.vy;
        p.life -= 0.03;
        p.vx *= 0.95;
        p.vy *= 0.95;
        return p.life > 0;
      });

      // Death check (stuck between platforms somehow)
      if (player.y < -50 || player.y > canvas.height + 50) {
        gameOver();
      }
    }

    function rectCollision(a, b) {
      return a.x < b.x + b.width &&
             a.x + a.width > b.x &&
             a.y < b.y + b.height &&
             a.y + a.height > b.y;
    }

    function draw() {
      // Clear with dark background
      ctx.fillStyle = COLORS.dark;
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      // Grid background
      ctx.strokeStyle = 'rgba(128, 0, 255, 0.1)';
      ctx.lineWidth = 1;
      for (let x = 0; x < canvas.width; x += 40) {
        ctx.beginPath();
        ctx.moveTo(x, 0);
        ctx.lineTo(x, canvas.height);
        ctx.stroke();
      }
      for (let y = 0; y < canvas.height; y += 40) {
        ctx.beginPath();
        ctx.moveTo(0, y);
        ctx.lineTo(canvas.width, y);
        ctx.stroke();
      }

      // Platforms
      for (const plat of platforms) {
        if (plat.type === 'boundary') {
          ctx.fillStyle = COLORS.purple;
        } else {
          ctx.fillStyle = 'rgba(0, 255, 128, 0.3)';
          ctx.strokeStyle = COLORS.green;
          ctx.lineWidth = 2;
        }

        ctx.beginPath();
        ctx.roundRect(plat.x, plat.y, plat.width, plat.height, 4);
        ctx.fill();

        if (plat.type === 'platform') {
          ctx.shadowColor = COLORS.green;
          ctx.shadowBlur = 10;
          ctx.stroke();
          ctx.shadowBlur = 0;
        }
      }

      // Gems
      for (const gem of gems) {
        if (!gem.collected) {
          ctx.beginPath();
          ctx.arc(gem.x, gem.y, gem.radius, 0, Math.PI * 2);
          ctx.fillStyle = COLORS.green;
          ctx.shadowColor = COLORS.green;
          ctx.shadowBlur = 15;
          ctx.fill();

          // Inner shine
          ctx.beginPath();
          ctx.arc(gem.x - 3, gem.y - 3, gem.radius * 0.4, 0, Math.PI * 2);
          ctx.fillStyle = '#fff';
          ctx.globalAlpha = 0.6;
          ctx.fill();
          ctx.globalAlpha = 1;
          ctx.shadowBlur = 0;
        }
      }

      // Portal
      const portalGlow = 0.5 + Math.sin(portal.pulse) * 0.3;
      ctx.fillStyle = `rgba(128, 0, 255, ${portalGlow})`;
      ctx.shadowColor = COLORS.purple;
      ctx.shadowBlur = 20;
      ctx.beginPath();
      ctx.ellipse(portal.x + portal.width / 2, portal.y + portal.height / 2,
                  portal.width / 2, portal.height / 2, 0, 0, Math.PI * 2);
      ctx.fill();

      // Portal inner
      ctx.fillStyle = COLORS.pink;
      ctx.beginPath();
      ctx.ellipse(portal.x + portal.width / 2, portal.y + portal.height / 2,
                  portal.width / 4, portal.height / 4, 0, 0, Math.PI * 2);
      ctx.fill();
      ctx.shadowBlur = 0;

      // Particles
      for (const p of particles) {
        ctx.beginPath();
        ctx.arc(p.x, p.y, 3, 0, Math.PI * 2);
        ctx.fillStyle = p.color;
        ctx.globalAlpha = p.life;
        ctx.shadowColor = p.color;
        ctx.shadowBlur = 8;
        ctx.fill();
      }
      ctx.globalAlpha = 1;
      ctx.shadowBlur = 0;

      // Player
      ctx.save();
      ctx.translate(player.x + player.width / 2, player.y + player.height / 2);
      if (gravityDirection === -1) {
        ctx.scale(1, -1);
      }
      ctx.translate(-player.width / 2, -player.height / 2);

      // Player body
      ctx.fillStyle = COLORS.purple;
      ctx.shadowColor = COLORS.purple;
      ctx.shadowBlur = 15;
      ctx.beginPath();
      ctx.roundRect(0, 0, player.width, player.height, 6);
      ctx.fill();

      // Player face
      ctx.fillStyle = COLORS.green;
      ctx.shadowColor = COLORS.green;
      ctx.shadowBlur = 5;
      // Eyes
      ctx.beginPath();
      ctx.arc(7, 10, 3, 0, Math.PI * 2);
      ctx.arc(17, 10, 3, 0, Math.PI * 2);
      ctx.fill();

      ctx.shadowBlur = 0;
      ctx.restore();
    }

    function gameLoop() {
      update();
      draw();
      requestAnimationFrame(gameLoop);
    }

    function startGame() {
      document.getElementById('startScreen').classList.add('hidden');
      document.getElementById('gameOverScreen').classList.add('hidden');
      document.getElementById('ui').style.display = 'block';

      score = 0;
      level = 1;
      document.getElementById('score').textContent = '0';
      document.getElementById('level').textContent = '1';

      initPlayer();
      generateLevel(1);
      gameRunning = true;
    }

    function gameOver() {
      gameRunning = false;
      document.getElementById('finalScore').textContent = score;
      document.getElementById('finalLevel').textContent = level;
      document.getElementById('gameOverScreen').classList.remove('hidden');
    }

    // Audio
    let audioCtx;
    function getAudioCtx() {
      if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
      return audioCtx;
    }

    function playJumpSound() {
      const ctx = getAudioCtx();
      const osc = ctx.createOscillator();
      const gain = ctx.createGain();
      osc.connect(gain);
      gain.connect(ctx.destination);
      osc.type = 'square';
      osc.frequency.setValueAtTime(200, ctx.currentTime);
      osc.frequency.exponentialRampToValueAtTime(400, ctx.currentTime + 0.1);
      gain.gain.setValueAtTime(0.1, ctx.currentTime);
      gain.gain.exponentialRampToValueAtTime(0.01, ctx.currentTime + 0.15);
      osc.start(ctx.currentTime);
      osc.stop(ctx.currentTime + 0.15);
    }

    function playGemSound() {
      const ctx = getAudioCtx();
      const osc = ctx.createOscillator();
      const gain = ctx.createGain();
      osc.connect(gain);
      gain.connect(ctx.destination);
      osc.type = 'sine';
      osc.frequency.setValueAtTime(800, ctx.currentTime);
      osc.frequency.exponentialRampToValueAtTime(1200, ctx.currentTime + 0.1);
      gain.gain.setValueAtTime(0.1, ctx.currentTime);
      gain.gain.exponentialRampToValueAtTime(0.01, ctx.currentTime + 0.2);
      osc.start(ctx.currentTime);
      osc.stop(ctx.currentTime + 0.2);
    }

    function playPortalSound() {
      const ctx = getAudioCtx();
      [0, 80, 160].forEach((delay, i) => {
        setTimeout(() => {
          const osc = ctx.createOscillator();
          const gain = ctx.createGain();
          osc.connect(gain);
          gain.connect(ctx.destination);
          osc.type = 'sine';
          osc.frequency.setValueAtTime(300 + i * 150, ctx.currentTime);
          gain.gain.setValueAtTime(0.08, ctx.currentTime);
          gain.gain.exponentialRampToValueAtTime(0.01, ctx.currentTime + 0.2);
          osc.start(ctx.currentTime);
          osc.stop(ctx.currentTime + 0.2);
        }, delay);
      });
    }

    // Input handling
    document.addEventListener('keydown', (e) => {
      keys[e.code] = true;
      if (['Space', 'ArrowUp', 'ArrowDown'].includes(e.code)) {
        e.preventDefault();
      }
    });

    document.addEventListener('keyup', (e) => {
      keys[e.code] = false;
      if (e.code === 'Space' || e.code === 'KeyW' || e.code === 'ArrowUp') {
        player.canJump = true;
      }
    });

    // Mobile controls
    const leftBtn = document.getElementById('leftBtn');
    const rightBtn = document.getElementById('rightBtn');
    const jumpBtn = document.getElementById('jumpBtn');

    leftBtn.addEventListener('touchstart', (e) => { e.preventDefault(); keys['ArrowLeft'] = true; });
    leftBtn.addEventListener('touchend', () => keys['ArrowLeft'] = false);
    rightBtn.addEventListener('touchstart', (e) => { e.preventDefault(); keys['ArrowRight'] = true; });
    rightBtn.addEventListener('touchend', () => keys['ArrowRight'] = false);
    jumpBtn.addEventListener('touchstart', (e) => { e.preventDefault(); keys['Space'] = true; });
    jumpBtn.addEventListener('touchend', () => { keys['Space'] = false; player.canJump = true; });

    // Prevent scrolling on mobile
    document.body.addEventListener('touchmove', (e) => {
      if (gameRunning) e.preventDefault();
    }, { passive: false });

    // Start game loop
    initPlayer();
    generateLevel(1);
    gameLoop();
  </script>
</body>
</html>
