<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
  <title>Lint Roller Defense</title>
  <link rel="icon" href="https://emojicdn.elk.sh/ðŸ¦Š">
  <meta property="og:title" content="Lint Roller Defense">
  <meta property="og:description" content="Defend your server from fluffy fox tails with a lint roller. It's official.">
  <meta property="og:url" content="https://sloppy.live/lint-defense">
  <meta property="og:image" content="https://emojicdn.elk.sh/ðŸ¦Š?style=google">
  <link href="https://fonts.googleapis.com/css2?family=Chakra+Petch:wght@400;600;700&family=IBM+Plex+Mono:wght@400;600&display=swap" rel="stylesheet">
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    :root {
      --bg: #0d1117;
      --green: #00ff88;
      --orange: #ff8844;
      --pink: #ff6b9d;
      --cyan: #22d3ee;
      --red: #ff3355;
      --panel: rgba(13,17,23,0.92);
      --dim: rgba(255,255,255,0.35);
    }
    body {
      background: var(--bg);
      color: #e0e0e0;
      font-family: 'IBM Plex Mono', monospace;
      overflow: hidden;
      height: 100dvh;
      width: 100vw;
      cursor: none;
      touch-action: none;
    }
    canvas { display: block; }

    .screen {
      position: absolute;
      inset: 0;
      display: none;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      z-index: 10;
      background: rgba(13,17,23,0.94);
    }
    .screen.active { display: flex; }

    h1 {
      font-family: 'Chakra Petch', sans-serif;
      font-weight: 700;
      font-size: clamp(22px, 6vw, 44px);
      text-align: center;
      line-height: 1.15;
    }
    .title-main {
      color: var(--green);
      text-shadow: 0 0 12px var(--green), 0 0 40px rgba(0,255,136,0.25);
    }
    .title-sub {
      font-family: 'Chakra Petch', sans-serif;
      font-weight: 400;
      font-size: clamp(13px, 3vw, 18px);
      color: var(--orange);
      text-shadow: 0 0 8px rgba(255,136,68,0.3);
      margin-top: 4px;
      margin-bottom: 24px;
    }
    .btn {
      font-family: 'Chakra Petch', sans-serif;
      font-weight: 700;
      font-size: clamp(12px, 2.8vw, 16px);
      padding: 12px 32px;
      margin: 6px;
      border: 2px solid var(--green);
      background: transparent;
      color: var(--green);
      cursor: pointer;
      text-transform: uppercase;
      letter-spacing: 2px;
      transition: all 0.15s;
    }
    .btn:hover {
      background: var(--green);
      color: var(--bg);
      box-shadow: 0 0 20px rgba(0,255,136,0.3);
    }
    .btn-row { display: flex; flex-wrap: wrap; justify-content: center; gap: 4px; margin-top: 12px; }

    .score-big {
      font-family: 'Chakra Petch', sans-serif;
      font-weight: 700;
      font-size: clamp(40px, 10vw, 72px);
      color: var(--orange);
      text-shadow: 0 0 20px rgba(255,136,68,0.4);
      margin: 8px 0;
    }
    .stat-line {
      font-size: clamp(13px, 2.5vw, 16px);
      color: var(--dim);
      margin: 2px 0;
    }
    .stat-line span { color: var(--cyan); }

    .lb-list { width: 90%; max-width: 380px; margin: 12px 0; }
    .lb-row {
      display: flex;
      justify-content: space-between;
      padding: 6px 10px;
      border-bottom: 1px solid rgba(0,255,136,0.1);
      font-size: clamp(13px, 2.5vw, 16px);
    }
    .lb-rank { width: 36px; color: var(--green); font-weight: 600; }
    .lb-rank.g { color: #ffd700; }
    .lb-rank.s { color: #c0c0c0; }
    .lb-rank.b { color: #cd7f32; }
    .lb-name { flex: 1; color: var(--dim); }
    .lb-pts { font-weight: 600; color: var(--orange); }

    .controls-hint {
      font-size: clamp(11px, 2vw, 13px);
      color: rgba(255,255,255,0.25);
      text-align: center;
      margin-top: 20px;
      line-height: 1.6;
    }

    .backlink {
      position: fixed;
      bottom: 6px; left: 50%;
      transform: translateX(-50%);
      font-size: 12px;
      color: rgba(0,255,136,0.2);
      text-decoration: none;
      z-index: 100;
    }
    .backlink:hover { color: rgba(0,255,136,0.5); }
  </style>
</head>
<body>
  <canvas id="game"></canvas>

  <!-- Title -->
  <div id="title-screen" class="screen active">
    <h1 class="title-main">LINT ROLLER<br>DEFENSE</h1>
    <div class="title-sub">ðŸ¦Š Defend your server from fluffy fox tails ðŸ§¹</div>
    <div class="btn-row">
      <button class="btn" onclick="startGame()">Deploy</button>
      <button class="btn" onclick="showLB()">Scores</button>
    </div>
    <div class="controls-hint">Mouse / touch to move roller<br>Space / tap to peel (reset fluff)</div>
  </div>

  <!-- Game Over -->
  <div id="gameover-screen" class="screen">
    <h1 class="title-main">SERVER DOWN</h1>
    <div class="title-sub">ðŸ¦Š The fluff was too powerful ðŸ¦Š</div>
    <div class="score-big" id="go-score">0</div>
    <div class="stat-line">Wave <span id="go-wave">1</span> &middot; Tails collected: <span id="go-tails">0</span></div>
    <div id="go-best" class="stat-line" style="display:none;color:var(--pink)">New personal best!</div>
    <div class="btn-row">
      <button class="btn" onclick="startGame()">Retry</button>
      <button class="btn" onclick="showLB()">Scores</button>
      <button class="btn" onclick="showTitle()">Menu</button>
    </div>
  </div>

  <!-- Leaderboard -->
  <div id="lb-screen" class="screen">
    <h1 class="title-main" style="font-size:clamp(18px,5vw,32px)">LEADERBOARD</h1>
    <div class="lb-list" id="lb-list"></div>
    <div class="btn-row">
      <button class="btn" onclick="showTitle()">Back</button>
    </div>
  </div>

  <a class="backlink" href="https://sloppy.live" target="_blank">sloppy.live</a>

  <script type="module">
    import supabase, { supabaseSession } from './supabase-config.js';

    // â”€â”€â”€ Auth â”€â”€â”€
    let userId = null, username = 'Anon', bestScore = 0;
    async function initAuth() {
      try {
        const s = await supabaseSession();
        userId = s.user.id;
        try {
          const stored = localStorage.getItem('sloppy-profile');
          if (stored) { const p = JSON.parse(stored); if (p.username) username = p.username; }
        } catch(_) {}
        if (username === 'Anon') {
          try {
            const { data } = await supabase.from('sloppygram_profiles').select('username').eq('user_id', userId).limit(1);
            if (data?.[0]?.username) username = data[0].username;
          } catch(_) {}
        }
        const { data: best } = await supabase.from('lint_defense_scores').select('score').eq('user_id', userId).order('score', { ascending: false }).limit(1);
        if (best?.[0]) bestScore = best[0].score;
      } catch(e) { console.error('Auth:', e); }
    }

    async function submitScore(score, wave) {
      if (!userId || score <= 0) return;
      if (score > bestScore) {
        bestScore = score;
        await supabase.from('lint_defense_scores').insert({ user_id: userId, username, score, wave });
        return true;
      }
      return false;
    }

    async function fetchLB() {
      const { data } = await supabase.from('lint_defense_scores').select('username, score, wave').order('score', { ascending: false }).limit(10);
      return data || [];
    }

    // â”€â”€â”€ Canvas â”€â”€â”€
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');
    let W = 0, H = 0;

    function resize() {
      W = window.innerWidth;
      H = window.innerHeight;
      canvas.width = W;
      canvas.height = H;
    }
    resize();
    window.addEventListener('resize', resize);

    // â”€â”€â”€ Game State â”€â”€â”€
    let state = 'title';
    let score = 0, wave = 1, tailsCaught = 0;
    let serverHP = 100, serverMaxHP = 100;
    let roller = { x: W / 2, y: H / 2, r: 22, fluff: 0, maxFluff: 15, peeling: 0 };
    let tails = [];
    let particles = [];
    let serverX, serverY, serverW, serverH;
    let spawnTimer = 0, spawnInterval = 2.0;
    let waveTimer = 0, waveDuration = 20;
    let tailSpeed = 50;
    let lastTime = 0;
    let shakeAmount = 0;
    let mouseX = W / 2, mouseY = H / 2;

    // Server position (center)
    function recalcServer() {
      serverW = Math.min(80, W * 0.12);
      serverH = Math.min(120, H * 0.2);
      serverX = W / 2 - serverW / 2;
      serverY = H / 2 - serverH / 2;
    }
    recalcServer();
    window.addEventListener('resize', recalcServer);

    // â”€â”€â”€ Tail types â”€â”€â”€
    const TAIL_TYPES = [
      { name: 'Fluffy', color: '#ff8844', size: 14, hp: 1, points: 10, speed: 1.0 },
      { name: 'Bushy', color: '#ffaa55', size: 18, hp: 1, points: 15, speed: 0.8 },
      { name: 'Wispy', color: '#ffcc88', size: 10, hp: 1, points: 8, speed: 1.4 },
      { name: 'Mega Floof', color: '#ff6b3d', size: 24, hp: 2, points: 30, speed: 0.6 },
      { name: 'Golden Tail', color: '#ffd700', size: 16, hp: 1, points: 50, speed: 1.2, glow: true },
      { name: 'Shadow Tail', color: '#bb77ff', size: 13, hp: 1, points: 20, speed: 1.5 },
    ];

    function pickTailType() {
      const w = wave;
      // More variety in later waves
      const pool = TAIL_TYPES.slice(0, Math.min(TAIL_TYPES.length, 2 + Math.floor(w / 2)));
      // Golden tails rare
      if (Math.random() < 0.05 + w * 0.005) return TAIL_TYPES[4];
      return pool[Math.floor(Math.random() * pool.length)];
    }

    function spawnTail() {
      const type = pickTailType();
      // Spawn from edges, aimed at server center
      const edge = Math.floor(Math.random() * 4);
      let x, y;
      const margin = 30;
      if (edge === 0) { x = -margin; y = Math.random() * H; }
      else if (edge === 1) { x = W + margin; y = Math.random() * H; }
      else if (edge === 2) { x = Math.random() * W; y = -margin; }
      else { x = Math.random() * W; y = H + margin; }

      // Direction toward server center with some spread
      const targetX = W / 2 + (Math.random() - 0.5) * serverW * 2;
      const targetY = H / 2 + (Math.random() - 0.5) * serverH * 2;
      const angle = Math.atan2(targetY - y, targetX - x);
      const speed = tailSpeed * type.speed;

      tails.push({
        x, y,
        vx: Math.cos(angle) * speed,
        vy: Math.sin(angle) * speed,
        type,
        hp: type.hp,
        wobble: Math.random() * Math.PI * 2,
        alpha: 1,
      });
    }

    // â”€â”€â”€ Particles â”€â”€â”€
    function emitFluff(x, y, color, count) {
      for (let i = 0; i < count; i++) {
        const angle = Math.random() * Math.PI * 2;
        const speed = 30 + Math.random() * 60;
        particles.push({
          x, y,
          vx: Math.cos(angle) * speed,
          vy: Math.sin(angle) * speed,
          r: 2 + Math.random() * 4,
          color,
          life: 0.5 + Math.random() * 0.5,
          maxLife: 1,
        });
      }
    }

    function emitPeelParticles() {
      for (let i = 0; i < 12; i++) {
        const angle = Math.random() * Math.PI * 2;
        const speed = 40 + Math.random() * 80;
        particles.push({
          x: roller.x, y: roller.y,
          vx: Math.cos(angle) * speed,
          vy: Math.sin(angle) * speed,
          r: 3 + Math.random() * 5,
          color: '#ffaa55',
          life: 0.6 + Math.random() * 0.4,
          maxLife: 1,
        });
      }
    }

    // â”€â”€â”€ Input â”€â”€â”€
    window.addEventListener('mousemove', e => {
      mouseX = e.clientX;
      mouseY = e.clientY;
    });
    window.addEventListener('touchmove', e => {
      e.preventDefault();
      mouseX = e.touches[0].clientX;
      mouseY = e.touches[0].clientY;
    }, { passive: false });
    window.addEventListener('touchstart', e => {
      if (state !== 'playing') return;
      // Double touch = peel
      if (e.touches.length >= 2) { peelRoller(); return; }
      mouseX = e.touches[0].clientX;
      mouseY = e.touches[0].clientY;
    }, { passive: false });

    window.addEventListener('keydown', e => {
      if (e.key === ' ' && state === 'playing') { e.preventDefault(); peelRoller(); }
    });

    // Tap center area on mobile = peel
    canvas.addEventListener('touchend', e => {
      if (state !== 'playing') return;
      // Single quick tap in lower area = peel
    });

    function peelRoller() {
      if (roller.peeling > 0 || roller.fluff === 0) return;
      roller.peeling = 0.4; // seconds of peel animation
      emitPeelParticles();
    }

    // â”€â”€â”€ Screens â”€â”€â”€
    function hideAll() {
      document.querySelectorAll('.screen').forEach(s => s.classList.remove('active'));
    }

    window.showTitle = function() {
      hideAll();
      document.getElementById('title-screen').classList.add('active');
      state = 'title';
    };

    window.startGame = function() {
      hideAll();
      state = 'playing';
      score = 0; wave = 1; tailsCaught = 0;
      serverHP = 100; serverMaxHP = 100;
      roller.fluff = 0; roller.peeling = 0;
      roller.x = mouseX; roller.y = mouseY;
      tails = []; particles = [];
      spawnTimer = 0; spawnInterval = 2.0;
      waveTimer = 0; tailSpeed = 50;
      shakeAmount = 0;
    };

    window.showLB = async function() {
      hideAll();
      document.getElementById('lb-screen').classList.add('active');
      state = 'leaderboard';
      const data = await fetchLB();
      const el = document.getElementById('lb-list');
      if (!data.length) {
        el.innerHTML = '<div style="text-align:center;color:var(--dim);padding:20px">No scores yet!</div>';
        return;
      }
      el.innerHTML = data.map((r, i) => {
        const rc = i === 0 ? 'g' : i === 1 ? 's' : i === 2 ? 'b' : '';
        const medal = i < 3 ? ['ðŸ¥‡','ðŸ¥ˆ','ðŸ¥‰'][i] : `${i+1}`;
        return `<div class="lb-row"><span class="lb-rank ${rc}">${medal}</span><span class="lb-name">${esc(r.username || 'Anon')}</span><span class="lb-pts">${r.score} (W${r.wave})</span></div>`;
      }).join('');
    };

    function esc(s) { const d = document.createElement('div'); d.textContent = s; return d.innerHTML; }

    async function gameOver() {
      hideAll();
      state = 'gameover';
      document.getElementById('go-score').textContent = score;
      document.getElementById('go-wave').textContent = wave;
      document.getElementById('go-tails').textContent = tailsCaught;
      const isNew = await submitScore(score, wave);
      document.getElementById('go-best').style.display = isNew ? 'block' : 'none';
      document.getElementById('gameover-screen').classList.add('active');
    }

    // â”€â”€â”€ Update â”€â”€â”€
    function update(dt) {
      if (state !== 'playing') return;

      // Roller follows mouse with slight smoothing
      const lerpSpeed = roller.peeling > 0 ? 3 : 12;
      roller.x += (mouseX - roller.x) * lerpSpeed * dt;
      roller.y += (mouseY - roller.y) * lerpSpeed * dt;

      // Peel timer
      if (roller.peeling > 0) {
        roller.peeling -= dt;
        if (roller.peeling <= 0) {
          roller.fluff = 0;
          roller.peeling = 0;
        }
      }

      // Wave timer
      waveTimer += dt;
      if (waveTimer >= waveDuration) {
        waveTimer = 0;
        wave++;
        spawnInterval = Math.max(0.3, spawnInterval * 0.85);
        tailSpeed = Math.min(160, tailSpeed + 8);
        waveDuration = Math.min(30, waveDuration + 1);
      }

      // Spawn tails
      spawnTimer += dt;
      const tailsPerSpawn = wave >= 5 ? 2 : 1;
      if (spawnTimer >= spawnInterval) {
        spawnTimer = 0;
        for (let i = 0; i < tailsPerSpawn; i++) spawnTail();
      }

      // Shake decay
      if (shakeAmount > 0) shakeAmount *= Math.pow(0.05, dt);

      // Roller hitbox (grows with fluff)
      const rollerR = roller.r + roller.fluff * 1.5;
      const rollerSlow = 1 + roller.fluff * 0.04; // higher fluff = slower tracking

      // Update tails
      for (let i = tails.length - 1; i >= 0; i--) {
        const t = tails[i];
        t.x += t.vx * dt;
        t.y += t.vy * dt;
        t.wobble += dt * 4;

        // Wobble perpendicular to movement direction
        const angle = Math.atan2(t.vy, t.vx);
        const wobX = Math.sin(t.wobble) * 8 * Math.cos(angle + Math.PI / 2);
        const wobY = Math.sin(t.wobble) * 8 * Math.sin(angle + Math.PI / 2);
        const drawX = t.x + wobX;
        const drawY = t.y + wobY;

        // Check roller collision (only if not peeling)
        if (roller.peeling <= 0) {
          const dx = drawX - roller.x;
          const dy = drawY - roller.y;
          const dist = Math.sqrt(dx * dx + dy * dy);
          if (dist < rollerR + t.type.size) {
            t.hp--;
            if (t.hp <= 0) {
              score += t.type.points;
              tailsCaught++;
              roller.fluff = Math.min(roller.maxFluff, roller.fluff + 1);
              emitFluff(drawX, drawY, t.type.color, 6);
              tails.splice(i, 1);
              continue;
            }
          }
        }

        // Check server collision
        const sx = W / 2, sy = H / 2;
        const sdx = drawX - sx, sdy = drawY - sy;
        if (Math.abs(sdx) < serverW / 2 + t.type.size && Math.abs(sdy) < serverH / 2 + t.type.size) {
          const dmg = t.type.size > 20 ? 12 : t.type.size > 15 ? 8 : 5;
          serverHP -= dmg;
          shakeAmount = Math.min(8, shakeAmount + 3);
          emitFluff(drawX, drawY, '#ff3355', 4);
          tails.splice(i, 1);
          if (serverHP <= 0) {
            serverHP = 0;
            gameOver();
            return;
          }
          continue;
        }

        // Remove if way off screen
        if (t.x < -200 || t.x > W + 200 || t.y < -200 || t.y > H + 200) {
          tails.splice(i, 1);
        }
      }

      // Particles
      for (let i = particles.length - 1; i >= 0; i--) {
        const p = particles[i];
        p.x += p.vx * dt;
        p.y += p.vy * dt;
        p.vx *= 0.95;
        p.vy *= 0.95;
        p.life -= dt;
        if (p.life <= 0) particles.splice(i, 1);
      }
    }

    // â”€â”€â”€ Render â”€â”€â”€
    function render() {
      ctx.save();

      // Screen shake
      if (shakeAmount > 0.5) {
        ctx.translate(
          (Math.random() - 0.5) * shakeAmount * 2,
          (Math.random() - 0.5) * shakeAmount * 2
        );
      }

      // Background
      ctx.fillStyle = '#0d1117';
      ctx.fillRect(-10, -10, W + 20, H + 20);

      // Subtle grid
      ctx.strokeStyle = 'rgba(0,255,136,0.04)';
      ctx.lineWidth = 1;
      for (let x = 0; x < W; x += 50) { ctx.beginPath(); ctx.moveTo(x, 0); ctx.lineTo(x, H); ctx.stroke(); }
      for (let y = 0; y < H; y += 50) { ctx.beginPath(); ctx.moveTo(0, y); ctx.lineTo(W, y); ctx.stroke(); }

      // Server
      drawServer();

      // Tails
      for (const t of tails) drawTail(t);

      // Particles
      for (const p of particles) {
        ctx.globalAlpha = Math.max(0, p.life / p.maxLife);
        ctx.fillStyle = p.color;
        ctx.beginPath();
        ctx.arc(p.x, p.y, p.r, 0, Math.PI * 2);
        ctx.fill();
      }
      ctx.globalAlpha = 1;

      // Roller
      drawRoller();

      // HUD
      if (state === 'playing') drawHUD();

      ctx.restore();
    }

    function drawServer() {
      const sx = serverX, sy = serverY;

      // Server glow (health-based)
      const hpPct = serverHP / serverMaxHP;
      const glowColor = hpPct > 0.5 ? `rgba(0,255,136,${0.08 + hpPct * 0.05})` : `rgba(255,51,85,${0.1 + (1 - hpPct) * 0.08})`;
      ctx.shadowColor = hpPct > 0.5 ? '#00ff88' : '#ff3355';
      ctx.shadowBlur = 20 + (1 - hpPct) * 15;

      // Rack body
      ctx.fillStyle = '#1a2030';
      ctx.fillRect(sx, sy, serverW, serverH);
      ctx.strokeStyle = hpPct > 0.5 ? 'rgba(0,255,136,0.4)' : 'rgba(255,51,85,0.5)';
      ctx.lineWidth = 2;
      ctx.strokeRect(sx, sy, serverW, serverH);

      ctx.shadowBlur = 0;

      // Drive bays
      const bayH = 10, bayGap = 4, bayStart = sy + 10;
      for (let i = 0; i < 5; i++) {
        const by = bayStart + i * (bayH + bayGap);
        ctx.fillStyle = '#0d1520';
        ctx.fillRect(sx + 6, by, serverW - 12, bayH);
        // LED
        const ledColor = serverHP > 20 ? '#00ff88' : (Math.sin(Date.now() * 0.01) > 0 ? '#ff3355' : '#550011');
        ctx.fillStyle = ledColor;
        ctx.fillRect(sx + serverW - 14, by + 3, 4, 4);
      }

      // Label
      ctx.font = '600 9px "IBM Plex Mono"';
      ctx.fillStyle = 'rgba(0,255,136,0.5)';
      ctx.textAlign = 'center';
      ctx.fillText('SERVER', sx + serverW / 2, sy + serverH - 6);
    }

    function drawTail(t) {
      const wobX = Math.sin(t.wobble) * 8;
      const wobY = Math.cos(t.wobble) * 5;
      const dx = t.x + wobX;
      const dy = t.y + wobY;
      const s = t.type.size;

      // Glow for golden tails
      if (t.type.glow) {
        ctx.shadowColor = '#ffd700';
        ctx.shadowBlur = 10 + Math.sin(t.wobble) * 4;
      }

      // Tail shape â€” fluffy oval with wispy tip
      ctx.fillStyle = t.type.color;
      ctx.beginPath();
      ctx.ellipse(dx, dy, s, s * 0.65, Math.atan2(t.vy, t.vx) + Math.PI, 0, Math.PI * 2);
      ctx.fill();

      // Inner fluff highlight
      ctx.fillStyle = 'rgba(255,255,255,0.2)';
      ctx.beginPath();
      ctx.ellipse(dx - s * 0.2, dy - s * 0.15, s * 0.4, s * 0.25, 0, 0, Math.PI * 2);
      ctx.fill();

      // Fur lines
      ctx.strokeStyle = `rgba(255,255,255,0.15)`;
      ctx.lineWidth = 1;
      const angle = Math.atan2(t.vy, t.vx);
      for (let i = 0; i < 4; i++) {
        const a = angle + Math.PI + (i - 1.5) * 0.35;
        ctx.beginPath();
        ctx.moveTo(dx, dy);
        ctx.lineTo(dx + Math.cos(a) * s * 1.2, dy + Math.sin(a) * s * 1.2);
        ctx.stroke();
      }

      ctx.shadowBlur = 0;
    }

    function drawRoller() {
      const r = roller.r + roller.fluff * 1.5;
      const x = roller.x, y = roller.y;

      // Handle
      ctx.strokeStyle = '#667788';
      ctx.lineWidth = 4;
      ctx.beginPath();
      ctx.moveTo(x, y + r);
      ctx.lineTo(x, y + r + 24);
      ctx.stroke();
      // Handle grip
      ctx.strokeStyle = '#4a5568';
      ctx.lineWidth = 6;
      ctx.beginPath();
      ctx.moveTo(x, y + r + 18);
      ctx.lineTo(x, y + r + 28);
      ctx.stroke();

      // Roller body
      ctx.fillStyle = roller.peeling > 0 ? 'rgba(255,200,100,0.5)' : '#e8e8e8';
      ctx.beginPath();
      ctx.arc(x, y, r, 0, Math.PI * 2);
      ctx.fill();

      // Fluff accumulation on roller
      if (roller.fluff > 0 && roller.peeling <= 0) {
        const fluffOpacity = Math.min(0.8, roller.fluff * 0.05);
        ctx.fillStyle = `rgba(255,136,68,${fluffOpacity})`;
        ctx.beginPath();
        ctx.arc(x, y, r - 2, 0, Math.PI * 2);
        ctx.fill();
        // Fluff tufts
        for (let i = 0; i < roller.fluff; i++) {
          const a = (i / roller.maxFluff) * Math.PI * 2;
          const fx = x + Math.cos(a) * (r - 4);
          const fy = y + Math.sin(a) * (r - 4);
          ctx.fillStyle = 'rgba(255,170,85,0.6)';
          ctx.beginPath();
          ctx.arc(fx, fy, 2 + Math.random(), 0, Math.PI * 2);
          ctx.fill();
        }
      }

      // Peel animation
      if (roller.peeling > 0) {
        ctx.strokeStyle = 'rgba(255,200,100,0.7)';
        ctx.lineWidth = 2;
        ctx.setLineDash([4, 4]);
        ctx.beginPath();
        ctx.arc(x, y, r + 4, 0, Math.PI * 2);
        ctx.stroke();
        ctx.setLineDash([]);
      }

      // Roller outline
      ctx.strokeStyle = roller.peeling > 0 ? 'rgba(255,200,100,0.6)' : 'rgba(255,255,255,0.3)';
      ctx.lineWidth = 1.5;
      ctx.beginPath();
      ctx.arc(x, y, r, 0, Math.PI * 2);
      ctx.stroke();

      // Fluff warning indicator
      if (roller.fluff >= roller.maxFluff - 2 && roller.peeling <= 0) {
        ctx.font = '600 10px "Chakra Petch"';
        ctx.textAlign = 'center';
        ctx.fillStyle = roller.fluff >= roller.maxFluff ? '#ff3355' : '#ffaa00';
        ctx.fillText(roller.fluff >= roller.maxFluff ? 'FULL! PEEL!' : 'PEEL SOON', x, y - r - 8);
      }
    }

    function drawHUD() {
      // HP bar
      const hpW = Math.min(200, W * 0.35);
      const hpH = 14;
      const hpX = W / 2 - hpW / 2;
      const hpY = 14;
      const hpPct = serverHP / serverMaxHP;

      ctx.fillStyle = 'rgba(0,0,0,0.5)';
      ctx.fillRect(hpX - 2, hpY - 2, hpW + 4, hpH + 4);
      ctx.fillStyle = hpPct > 0.5 ? '#00ff88' : hpPct > 0.25 ? '#ffaa00' : '#ff3355';
      ctx.fillRect(hpX, hpY, hpW * hpPct, hpH);
      ctx.strokeStyle = 'rgba(255,255,255,0.2)';
      ctx.lineWidth = 1;
      ctx.strokeRect(hpX, hpY, hpW, hpH);

      ctx.font = '600 10px "IBM Plex Mono"';
      ctx.textAlign = 'center';
      ctx.fillStyle = '#fff';
      ctx.fillText(`SERVER HP: ${Math.ceil(serverHP)}%`, W / 2, hpY + 11);

      // Score
      ctx.font = '700 16px "Chakra Petch"';
      ctx.textAlign = 'left';
      ctx.fillStyle = '#00ff88';
      ctx.fillText(`${score}`, 14, 26);

      // Wave
      ctx.textAlign = 'right';
      ctx.fillStyle = '#22d3ee';
      ctx.fillText(`WAVE ${wave}`, W - 14, 26);

      // Fluff meter
      const fmW = 80, fmH = 6;
      const fmX = 14, fmY = 34;
      ctx.fillStyle = 'rgba(0,0,0,0.4)';
      ctx.fillRect(fmX, fmY, fmW, fmH);
      const fluffPct = roller.fluff / roller.maxFluff;
      ctx.fillStyle = fluffPct > 0.8 ? '#ff3355' : '#ff8844';
      ctx.fillRect(fmX, fmY, fmW * fluffPct, fmH);
      ctx.font = '400 9px "IBM Plex Mono"';
      ctx.textAlign = 'left';
      ctx.fillStyle = 'rgba(255,255,255,0.4)';
      ctx.fillText('FLUFF', fmX, fmY + fmH + 10);
    }

    // â”€â”€â”€ Loop â”€â”€â”€
    function loop(ts) {
      const dt = lastTime ? Math.min((ts - lastTime) / 1000, 0.05) : 0.016;
      lastTime = ts;
      update(dt);
      render();
      requestAnimationFrame(loop);
    }

    initAuth();
    requestAnimationFrame(loop);
  </script>
</body>
</html>
