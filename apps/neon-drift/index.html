<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
  <title>Pirate Drift - High Seas Racing</title>
  <link rel="icon" href="https://emojicdn.elk.sh/ðŸ´â€â˜ ï¸">
  <meta property="og:title" content="Pirate Drift">
  <meta property="og:description" content="High-speed pirate ship drifting on the seven seas">
  <meta property="og:url" content="https://sloppy.live/neon-drift">
  <meta property="og:image" content="https://sloppy.live/neon-drift/og-image.png">
  <link href="https://fonts.googleapis.com/css2?family=Pirate+One&family=IM+Fell+English+SC&display=swap" rel="stylesheet">
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      background: #0d2137;
      overflow: hidden;
      font-family: 'IM Fell English SC', serif;
      touch-action: none;
    }
    canvas {
      display: block;
    }
    #ui {
      position: fixed;
      top: 20px;
      left: 20px;
      color: #d4a84b;
      text-shadow: 2px 2px 0 #1a0f0a, 0 0 15px rgba(212, 168, 75, 0.5);
      z-index: 10;
    }
    #speed {
      font-family: 'Pirate One', cursive;
      font-size: 48px;
    }
    #speed-unit {
      font-size: 16px;
      opacity: 0.7;
    }
    #drift-score {
      font-family: 'Pirate One', cursive;
      font-size: 24px;
      color: #c0392b;
      text-shadow: 2px 2px 0 #1a0f0a, 0 0 15px rgba(192, 57, 43, 0.5);
      margin-top: 10px;
    }
    #drift-multiplier {
      font-family: 'Pirate One', cursive;
      font-size: 18px;
      color: #27ae60;
      text-shadow: 0 0 10px rgba(39, 174, 96, 0.5);
      opacity: 0;
      transition: opacity 0.2s;
    }
    #controls-hint {
      position: fixed;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      color: #8b7355;
      opacity: 0.7;
      font-size: 12px;
      text-align: center;
    }
    #backlink {
      position: fixed;
      bottom: 20px;
      right: 20px;
      color: #8b7355;
      text-decoration: none;
      font-size: 12px;
      opacity: 0.6;
    }
    #backlink:hover { opacity: 1; color: #d4a84b; }
    #mobile-controls {
      display: none;
      position: fixed;
      bottom: 0;
      left: 0;
      right: 0;
      height: 150px;
      z-index: 20;
    }
    .mobile-btn {
      position: absolute;
      width: 70px;
      height: 70px;
      border: 2px solid #d4a84b;
      border-radius: 50%;
      background: rgba(139, 90, 43, 0.2);
      color: #d4a84b;
      font-size: 24px;
      display: flex;
      align-items: center;
      justify-content: center;
      user-select: none;
    }
    .mobile-btn:active {
      background: rgba(212, 168, 75, 0.4);
    }
    #btn-left { left: 20px; bottom: 40px; }
    #btn-right { left: 110px; bottom: 40px; }
    #btn-gas { right: 20px; bottom: 40px; }
    #btn-brake { right: 110px; bottom: 40px; }
    @media (max-width: 768px) {
      #mobile-controls { display: block; }
      #controls-hint { display: none; }
      #speed { font-size: 32px; }
      #drift-score { font-size: 18px; }
    }
  </style>
</head>
<body>
  <canvas id="game"></canvas>

  <div id="ui">
    <div id="speed">0</div>
    <div id="speed-unit">KNOTS</div>
    <div id="drift-score">PLUNDER: 0</div>
    <div id="drift-multiplier">x1</div>
  </div>

  <div id="controls-hint">
    WASD or Arrow Keys to sail â€¢ Hold SPACE or SHIFT to drift
  </div>

  <div id="mobile-controls">
    <div class="mobile-btn" id="btn-left">â—€</div>
    <div class="mobile-btn" id="btn-right">â–¶</div>
    <div class="mobile-btn" id="btn-brake">â–¼</div>
    <div class="mobile-btn" id="btn-gas">â–²</div>
  </div>

  <a id="backlink" href="https://sloppy.live">sloppy.live</a>

  <script>
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');

    let W, H;
    function resize() {
      W = canvas.width = window.innerWidth;
      H = canvas.height = window.innerHeight;
    }
    resize();
    window.addEventListener('resize', resize);

    const ship = {
      x: 0,
      y: 0,
      vx: 0,
      vy: 0,
      angle: -Math.PI / 2,
      angularVel: 0,
      drifting: false,
      driftAngle: 0
    };

    const trails = [];
    const MAX_TRAILS = 400;

    let driftScore = 0;
    let currentDrift = 0;
    let driftMultiplier = 1;
    let driftTime = 0;

    // Islands
    const islands = [];
    for (let i = 0; i < 12; i++) {
      islands.push({
        x: Math.random() * 4000 - 2000,
        y: Math.random() * 4000 - 2000,
        radius: 60 + Math.random() * 80,
        palmCount: Math.floor(Math.random() * 3) + 1
      });
    }

    // Floating barrels/treasure
    const flotsam = [];
    for (let i = 0; i < 20; i++) {
      flotsam.push({
        x: Math.random() * 3000 - 1500,
        y: Math.random() * 3000 - 1500,
        type: Math.random() > 0.5 ? 'barrel' : 'chest',
        bob: Math.random() * Math.PI * 2
      });
    }

    const keys = {};
    const mobileKeys = { left: false, right: false, up: false, down: false };

    window.addEventListener('keydown', e => {
      keys[e.code] = true;
      if (['Space', 'ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight'].includes(e.code)) {
        e.preventDefault();
      }
    });
    window.addEventListener('keyup', e => keys[e.code] = false);

    function setupMobileBtn(id, key) {
      const btn = document.getElementById(id);
      btn.addEventListener('touchstart', e => { e.preventDefault(); mobileKeys[key] = true; });
      btn.addEventListener('touchend', e => { e.preventDefault(); mobileKeys[key] = false; });
    }
    setupMobileBtn('btn-left', 'left');
    setupMobileBtn('btn-right', 'right');
    setupMobileBtn('btn-gas', 'up');
    setupMobileBtn('btn-brake', 'down');

    function isPressed(action) {
      switch(action) {
        case 'left': return keys['ArrowLeft'] || keys['KeyA'] || mobileKeys.left;
        case 'right': return keys['ArrowRight'] || keys['KeyD'] || mobileKeys.right;
        case 'up': return keys['ArrowUp'] || keys['KeyW'] || mobileKeys.up;
        case 'down': return keys['ArrowDown'] || keys['KeyS'] || mobileKeys.down;
        case 'drift': return keys['Space'] || keys['ShiftLeft'] || keys['ShiftRight'];
      }
      return false;
    }

    const ACCEL = 0.12;
    const MAX_SPEED = 20;
    const TURN_SPEED = 0.035;
    const DRIFT_TURN = 0.07;
    const FRICTION = 0.992;
    const DRIFT_FRICTION = 0.98;

    function update() {
      if (isPressed('up')) {
        ship.vx += Math.cos(ship.angle) * ACCEL;
        ship.vy += Math.sin(ship.angle) * ACCEL;
      }
      if (isPressed('down')) {
        ship.vx -= Math.cos(ship.angle) * ACCEL * 0.4;
        ship.vy -= Math.sin(ship.angle) * ACCEL * 0.4;
      }

      const wasDrifting = ship.drifting;
      ship.drifting = isPressed('drift') && (Math.abs(ship.vx) > 1.5 || Math.abs(ship.vy) > 1.5);

      if (ship.drifting && !wasDrifting) {
        ship.driftAngle = Math.atan2(ship.vy, ship.vx);
      }

      const turnSpeed = ship.drifting ? DRIFT_TURN : TURN_SPEED;
      if (isPressed('left')) ship.angle -= turnSpeed;
      if (isPressed('right')) ship.angle += turnSpeed;

      const friction = ship.drifting ? DRIFT_FRICTION : FRICTION;
      ship.vx *= friction;
      ship.vy *= friction;

      const speed = Math.sqrt(ship.vx * ship.vx + ship.vy * ship.vy);
      if (speed > MAX_SPEED) {
        ship.vx = (ship.vx / speed) * MAX_SPEED;
        ship.vy = (ship.vy / speed) * MAX_SPEED;
      }

      ship.x += ship.vx;
      ship.y += ship.vy;

      if (ship.drifting && speed > 4) {
        const moveAngle = Math.atan2(ship.vy, ship.vx);
        let angleDiff = Math.abs(ship.angle - moveAngle);
        if (angleDiff > Math.PI) angleDiff = Math.PI * 2 - angleDiff;

        if (angleDiff > 0.25) {
          driftTime += 1/60;
          currentDrift += angleDiff * speed * 0.6;
          driftMultiplier = Math.min(5, 1 + Math.floor(driftTime / 2));
        }
      } else if (wasDrifting && currentDrift > 0) {
        driftScore += Math.floor(currentDrift * driftMultiplier);
        currentDrift = 0;
        driftTime = 0;
        driftMultiplier = 1;
      }

      // Wake trails
      if (speed > 0.8) {
        const wakeColor = ship.drifting ?
          `rgba(212, 168, 75, ${0.4 + Math.random() * 0.2})` :
          `rgba(255, 255, 255, ${0.3 + Math.random() * 0.2})`;

        const leftX = ship.x + Math.cos(ship.angle + Math.PI * 0.8) * 20;
        const leftY = ship.y + Math.sin(ship.angle + Math.PI * 0.8) * 20;
        trails.push({
          x: leftX,
          y: leftY,
          vx: -ship.vx * 0.05,
          vy: -ship.vy * 0.05,
          life: 1,
          color: wakeColor,
          size: ship.drifting ? 10 : 6
        });

        const rightX = ship.x + Math.cos(ship.angle - Math.PI * 0.8) * 20;
        const rightY = ship.y + Math.sin(ship.angle - Math.PI * 0.8) * 20;
        trails.push({
          x: rightX,
          y: rightY,
          vx: -ship.vx * 0.05,
          vy: -ship.vy * 0.05,
          life: 1,
          color: wakeColor,
          size: ship.drifting ? 10 : 6
        });
      }

      for (let i = trails.length - 1; i >= 0; i--) {
        const t = trails[i];
        t.x += t.vx;
        t.y += t.vy;
        t.life -= 0.012;
        t.size *= 1.01;
        if (t.life <= 0) trails.splice(i, 1);
      }

      while (trails.length > MAX_TRAILS) trails.shift();

      flotsam.forEach(f => { f.bob += 0.03; });

      const displaySpeed = Math.floor(speed * 3);
      document.getElementById('speed').textContent = displaySpeed;
      document.getElementById('drift-score').textContent = `PLUNDER: ${Math.floor(driftScore + currentDrift * driftMultiplier)}`;

      const multEl = document.getElementById('drift-multiplier');
      if (ship.drifting && driftMultiplier > 1) {
        multEl.textContent = `x${driftMultiplier}`;
        multEl.style.opacity = '1';
      } else {
        multEl.style.opacity = '0';
      }
    }

    function draw() {
      // Ocean gradient
      const oceanGrad = ctx.createLinearGradient(0, 0, 0, H);
      oceanGrad.addColorStop(0, '#0d2137');
      oceanGrad.addColorStop(1, '#1a3a5c');
      ctx.fillStyle = oceanGrad;
      ctx.fillRect(0, 0, W, H);

      ctx.save();
      ctx.translate(W/2 - ship.x, H/2 - ship.y);

      // Ocean waves
      const time = Date.now() * 0.001;
      ctx.strokeStyle = 'rgba(46, 134, 171, 0.15)';
      ctx.lineWidth = 2;
      for (let y = -2000; y < 2000; y += 60) {
        ctx.beginPath();
        for (let x = -2000; x < 2000; x += 10) {
          const wave = Math.sin((x + time * 50) * 0.02 + y * 0.01) * 8;
          if (x === -2000) ctx.moveTo(x, y + wave);
          else ctx.lineTo(x, y + wave);
        }
        ctx.stroke();
      }

      // Draw islands
      islands.forEach(island => {
        // Sand
        ctx.fillStyle = '#c2a366';
        ctx.shadowColor = '#8b7355';
        ctx.shadowBlur = 20;
        ctx.beginPath();
        ctx.ellipse(island.x, island.y, island.radius, island.radius * 0.7, 0, 0, Math.PI * 2);
        ctx.fill();
        ctx.shadowBlur = 0;

        // Palm trees
        for (let p = 0; p < island.palmCount; p++) {
          const px = island.x + (p - island.palmCount/2) * 25;
          const py = island.y - 10;

          // Trunk
          ctx.strokeStyle = '#5c3a1e';
          ctx.lineWidth = 6;
          ctx.beginPath();
          ctx.moveTo(px, py);
          ctx.quadraticCurveTo(px + 5, py - 20, px, py - 35);
          ctx.stroke();

          // Leaves
          ctx.fillStyle = '#2d5a27';
          for (let l = 0; l < 5; l++) {
            const angle = (l / 5) * Math.PI * 2;
            ctx.beginPath();
            ctx.ellipse(px + Math.cos(angle) * 15, py - 35 + Math.sin(angle) * 8, 18, 6, angle, 0, Math.PI * 2);
            ctx.fill();
          }
        }
      });

      // Draw flotsam
      flotsam.forEach(f => {
        const bobY = Math.sin(f.bob) * 3;
        ctx.save();
        ctx.translate(f.x, f.y + bobY);

        if (f.type === 'barrel') {
          ctx.fillStyle = '#8b5a2b';
          ctx.beginPath();
          ctx.ellipse(0, 0, 12, 8, 0, 0, Math.PI * 2);
          ctx.fill();
          ctx.strokeStyle = '#5c3a1e';
          ctx.lineWidth = 2;
          ctx.stroke();
        } else {
          ctx.fillStyle = '#d4a84b';
          ctx.shadowColor = '#d4a84b';
          ctx.shadowBlur = 10;
          ctx.fillRect(-10, -6, 20, 12);
          ctx.strokeStyle = '#8b5a2b';
          ctx.lineWidth = 2;
          ctx.strokeRect(-10, -6, 20, 12);
        }
        ctx.restore();
      });

      // Draw wake trails
      trails.forEach(t => {
        ctx.globalAlpha = t.life * 0.6;
        ctx.fillStyle = t.color;
        ctx.beginPath();
        ctx.arc(t.x, t.y, t.size * t.life, 0, Math.PI * 2);
        ctx.fill();
      });
      ctx.globalAlpha = 1;

      // Draw ship
      ctx.save();
      ctx.translate(ship.x, ship.y);
      ctx.rotate(ship.angle);

      // Hull shadow
      ctx.shadowColor = 'rgba(0, 0, 0, 0.5)';
      ctx.shadowBlur = 15;
      ctx.shadowOffsetY = 5;

      // Hull
      ctx.fillStyle = ship.drifting ? '#c0392b' : '#5c3a1e';
      ctx.beginPath();
      ctx.moveTo(30, 0);
      ctx.quadraticCurveTo(20, -12, -20, -10);
      ctx.lineTo(-25, 0);
      ctx.lineTo(-20, 10);
      ctx.quadraticCurveTo(20, 12, 30, 0);
      ctx.closePath();
      ctx.fill();

      ctx.shadowBlur = 0;
      ctx.shadowOffsetY = 0;

      // Deck
      ctx.fillStyle = '#8b5a2b';
      ctx.beginPath();
      ctx.ellipse(0, 0, 18, 7, 0, 0, Math.PI * 2);
      ctx.fill();

      // Mast
      ctx.strokeStyle = '#3d2817';
      ctx.lineWidth = 4;
      ctx.beginPath();
      ctx.moveTo(0, 0);
      ctx.lineTo(0, -35);
      ctx.stroke();

      // Sail
      const sailPuff = isPressed('up') ? 8 : 4;
      ctx.fillStyle = ship.drifting ? '#c0392b' : '#e8d4a8';
      ctx.beginPath();
      ctx.moveTo(0, -35);
      ctx.quadraticCurveTo(sailPuff + Math.sin(Date.now() * 0.005) * 2, -20, 0, -5);
      ctx.quadraticCurveTo(-sailPuff, -20, 0, -35);
      ctx.fill();

      // Jolly Roger
      ctx.fillStyle = '#1a0f0a';
      ctx.beginPath();
      ctx.moveTo(0, -35);
      ctx.lineTo(12, -32);
      ctx.lineTo(0, -28);
      ctx.fill();
      ctx.fillStyle = '#fff';
      ctx.font = '6px serif';
      ctx.fillText('â˜ ', 3, -30);

      // Cannon fire effect when drifting
      if (ship.drifting && Math.random() > 0.7) {
        ctx.fillStyle = '#f80';
        ctx.shadowColor = '#f80';
        ctx.shadowBlur = 15;
        const side = Math.random() > 0.5 ? 1 : -1;
        ctx.beginPath();
        ctx.arc(0, side * 12, 4, 0, Math.PI * 2);
        ctx.fill();
      }

      ctx.restore();

      // Drift spray
      if (ship.drifting) {
        const speed = Math.sqrt(ship.vx * ship.vx + ship.vy * ship.vy);
        if (speed > 4) {
          ctx.save();
          ctx.translate(ship.x, ship.y);

          for (let i = 0; i < 4; i++) {
            const sparkAngle = ship.angle + Math.PI + (Math.random() - 0.5) * 0.8;
            const sparkDist = 25 + Math.random() * 20;
            ctx.fillStyle = `rgba(255, 255, 255, ${Math.random() * 0.6})`;
            ctx.beginPath();
            ctx.arc(
              Math.cos(sparkAngle) * sparkDist,
              Math.sin(sparkAngle) * sparkDist,
              2 + Math.random() * 2, 0, Math.PI * 2
            );
            ctx.fill();
          }

          ctx.restore();
        }
      }

      ctx.restore();

      // Vignette
      const vignette = ctx.createRadialGradient(W/2, H/2, H * 0.3, W/2, H/2, H * 0.9);
      vignette.addColorStop(0, 'transparent');
      vignette.addColorStop(1, 'rgba(0, 0, 0, 0.4)');
      ctx.fillStyle = vignette;
      ctx.fillRect(0, 0, W, H);
    }

    function gameLoop() {
      update();
      draw();
      requestAnimationFrame(gameLoop);
    }

    gameLoop();
  </script>
</body>
</html>
