<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
  <title>Neon Drift - Zero Gravity Racing</title>
  <link rel="icon" href="https://emojicdn.elk.sh/ðŸŽï¸">
  <meta property="og:title" content="Neon Drift">
  <meta property="og:description" content="High-speed zero gravity drifting with neon trails">
  <meta property="og:url" content="https://sloppy.live/neon-drift">
  <meta property="og:image" content="https://sloppy.live/neon-drift/og-image.png">
  <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&display=swap" rel="stylesheet">
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      background: #0a0a12;
      overflow: hidden;
      font-family: 'Orbitron', sans-serif;
      touch-action: none;
    }
    canvas {
      display: block;
    }
    #ui {
      position: fixed;
      top: 20px;
      left: 20px;
      color: #0ff;
      text-shadow: 0 0 10px #0ff, 0 0 20px #0ff;
      z-index: 10;
    }
    #speed {
      font-size: 48px;
      font-weight: 900;
    }
    #speed-unit {
      font-size: 16px;
      opacity: 0.7;
    }
    #drift-score {
      font-size: 24px;
      color: #f0f;
      text-shadow: 0 0 10px #f0f, 0 0 20px #f0f;
      margin-top: 10px;
    }
    #drift-multiplier {
      font-size: 18px;
      color: #ff0;
      text-shadow: 0 0 10px #ff0;
      opacity: 0;
      transition: opacity 0.2s;
    }
    #controls-hint {
      position: fixed;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      color: #fff;
      opacity: 0.5;
      font-size: 12px;
      text-align: center;
    }
    #backlink {
      position: fixed;
      bottom: 20px;
      right: 20px;
      color: #0ff;
      text-decoration: none;
      font-size: 12px;
      opacity: 0.6;
    }
    #backlink:hover { opacity: 1; }
    #mobile-controls {
      display: none;
      position: fixed;
      bottom: 0;
      left: 0;
      right: 0;
      height: 150px;
      z-index: 20;
    }
    .mobile-btn {
      position: absolute;
      width: 70px;
      height: 70px;
      border: 2px solid #0ff;
      border-radius: 50%;
      background: rgba(0, 255, 255, 0.1);
      color: #0ff;
      font-size: 24px;
      display: flex;
      align-items: center;
      justify-content: center;
      user-select: none;
    }
    .mobile-btn:active {
      background: rgba(0, 255, 255, 0.3);
    }
    #btn-left { left: 20px; bottom: 40px; }
    #btn-right { left: 110px; bottom: 40px; }
    #btn-gas { right: 20px; bottom: 40px; }
    #btn-brake { right: 110px; bottom: 40px; }
    @media (max-width: 768px) {
      #mobile-controls { display: block; }
      #controls-hint { display: none; }
      #speed { font-size: 32px; }
      #drift-score { font-size: 18px; }
    }
  </style>
</head>
<body>
  <canvas id="game"></canvas>

  <div id="ui">
    <div id="speed">0</div>
    <div id="speed-unit">KM/H</div>
    <div id="drift-score">DRIFT: 0</div>
    <div id="drift-multiplier">x1</div>
  </div>

  <div id="controls-hint">
    WASD or Arrow Keys to drive â€¢ Hold SPACE or SHIFT to drift
  </div>

  <div id="mobile-controls">
    <div class="mobile-btn" id="btn-left">â—€</div>
    <div class="mobile-btn" id="btn-right">â–¶</div>
    <div class="mobile-btn" id="btn-brake">â–¼</div>
    <div class="mobile-btn" id="btn-gas">â–²</div>
  </div>

  <a id="backlink" href="https://sloppy.live">sloppy.live</a>

  <script>
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');

    let W, H;
    function resize() {
      W = canvas.width = window.innerWidth;
      H = canvas.height = window.innerHeight;
    }
    resize();
    window.addEventListener('resize', resize);

    // Ship state
    const ship = {
      x: 0,
      y: 0,
      vx: 0,
      vy: 0,
      angle: -Math.PI / 2,
      angularVel: 0,
      drifting: false,
      driftAngle: 0
    };

    // Trail system
    const trails = [];
    const MAX_TRAILS = 500;

    // Drift scoring
    let driftScore = 0;
    let currentDrift = 0;
    let driftMultiplier = 1;
    let driftTime = 0;

    // Stars background
    const stars = [];
    for (let i = 0; i < 200; i++) {
      stars.push({
        x: Math.random() * 4000 - 2000,
        y: Math.random() * 4000 - 2000,
        size: Math.random() * 2 + 0.5,
        brightness: Math.random()
      });
    }

    // Floating obstacles/rings
    const rings = [];
    for (let i = 0; i < 15; i++) {
      rings.push({
        x: Math.random() * 3000 - 1500,
        y: Math.random() * 3000 - 1500,
        radius: 80 + Math.random() * 60,
        rotation: Math.random() * Math.PI * 2,
        rotSpeed: (Math.random() - 0.5) * 0.02,
        hue: Math.random() * 60 + 160 // cyan to purple range
      });
    }

    // Input
    const keys = {};
    const mobileKeys = { left: false, right: false, up: false, down: false };

    window.addEventListener('keydown', e => {
      keys[e.code] = true;
      if (['Space', 'ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight'].includes(e.code)) {
        e.preventDefault();
      }
    });
    window.addEventListener('keyup', e => keys[e.code] = false);

    // Mobile controls
    function setupMobileBtn(id, key) {
      const btn = document.getElementById(id);
      btn.addEventListener('touchstart', e => { e.preventDefault(); mobileKeys[key] = true; });
      btn.addEventListener('touchend', e => { e.preventDefault(); mobileKeys[key] = false; });
    }
    setupMobileBtn('btn-left', 'left');
    setupMobileBtn('btn-right', 'right');
    setupMobileBtn('btn-gas', 'up');
    setupMobileBtn('btn-brake', 'down');

    function isPressed(action) {
      switch(action) {
        case 'left': return keys['ArrowLeft'] || keys['KeyA'] || mobileKeys.left;
        case 'right': return keys['ArrowRight'] || keys['KeyD'] || mobileKeys.right;
        case 'up': return keys['ArrowUp'] || keys['KeyW'] || mobileKeys.up;
        case 'down': return keys['ArrowDown'] || keys['KeyS'] || mobileKeys.down;
        case 'drift': return keys['Space'] || keys['ShiftLeft'] || keys['ShiftRight'];
      }
      return false;
    }

    // Physics constants
    const ACCEL = 0.15;
    const MAX_SPEED = 25;
    const TURN_SPEED = 0.04;
    const DRIFT_TURN = 0.08;
    const FRICTION = 0.995;
    const DRIFT_FRICTION = 0.985;

    function update() {
      // Acceleration
      if (isPressed('up')) {
        ship.vx += Math.cos(ship.angle) * ACCEL;
        ship.vy += Math.sin(ship.angle) * ACCEL;
      }
      if (isPressed('down')) {
        ship.vx -= Math.cos(ship.angle) * ACCEL * 0.5;
        ship.vy -= Math.sin(ship.angle) * ACCEL * 0.5;
      }

      // Drifting
      const wasDrifting = ship.drifting;
      ship.drifting = isPressed('drift') && (Math.abs(ship.vx) > 2 || Math.abs(ship.vy) > 2);

      if (ship.drifting && !wasDrifting) {
        ship.driftAngle = Math.atan2(ship.vy, ship.vx);
      }

      // Turning
      const turnSpeed = ship.drifting ? DRIFT_TURN : TURN_SPEED;
      if (isPressed('left')) {
        ship.angle -= turnSpeed;
      }
      if (isPressed('right')) {
        ship.angle += turnSpeed;
      }

      // Apply friction
      const friction = ship.drifting ? DRIFT_FRICTION : FRICTION;
      ship.vx *= friction;
      ship.vy *= friction;

      // Speed limit
      const speed = Math.sqrt(ship.vx * ship.vx + ship.vy * ship.vy);
      if (speed > MAX_SPEED) {
        ship.vx = (ship.vx / speed) * MAX_SPEED;
        ship.vy = (ship.vy / speed) * MAX_SPEED;
      }

      // Update position
      ship.x += ship.vx;
      ship.y += ship.vy;

      // Calculate drift angle difference for scoring
      if (ship.drifting && speed > 5) {
        const moveAngle = Math.atan2(ship.vy, ship.vx);
        let angleDiff = Math.abs(ship.angle - moveAngle);
        if (angleDiff > Math.PI) angleDiff = Math.PI * 2 - angleDiff;

        if (angleDiff > 0.3) {
          driftTime += 1/60;
          currentDrift += angleDiff * speed * 0.5;
          driftMultiplier = Math.min(5, 1 + Math.floor(driftTime / 2));
        }
      } else if (wasDrifting && currentDrift > 0) {
        // End drift, add to score
        driftScore += Math.floor(currentDrift * driftMultiplier);
        currentDrift = 0;
        driftTime = 0;
        driftMultiplier = 1;
      }

      // Add trail points
      if (speed > 1) {
        const trailColor = ship.drifting ?
          `hsl(${300 + Math.sin(Date.now() * 0.01) * 30}, 100%, 60%)` :
          `hsl(${180 + Math.sin(Date.now() * 0.005) * 20}, 100%, 60%)`;

        // Left trail
        const leftX = ship.x + Math.cos(ship.angle + Math.PI * 0.7) * 15;
        const leftY = ship.y + Math.sin(ship.angle + Math.PI * 0.7) * 15;
        trails.push({
          x: leftX,
          y: leftY,
          vx: -ship.vx * 0.1 + (Math.random() - 0.5) * 0.5,
          vy: -ship.vy * 0.1 + (Math.random() - 0.5) * 0.5,
          life: 1,
          color: trailColor,
          size: ship.drifting ? 8 : 5
        });

        // Right trail
        const rightX = ship.x + Math.cos(ship.angle - Math.PI * 0.7) * 15;
        const rightY = ship.y + Math.sin(ship.angle - Math.PI * 0.7) * 15;
        trails.push({
          x: rightX,
          y: rightY,
          vx: -ship.vx * 0.1 + (Math.random() - 0.5) * 0.5,
          vy: -ship.vy * 0.1 + (Math.random() - 0.5) * 0.5,
          life: 1,
          color: trailColor,
          size: ship.drifting ? 8 : 5
        });
      }

      // Update trails (zero gravity - they float)
      for (let i = trails.length - 1; i >= 0; i--) {
        const t = trails[i];
        t.x += t.vx;
        t.y += t.vy;
        t.vx *= 0.98;
        t.vy *= 0.98;
        t.life -= 0.008;
        if (t.life <= 0) {
          trails.splice(i, 1);
        }
      }

      // Limit trails
      while (trails.length > MAX_TRAILS) {
        trails.shift();
      }

      // Rotate rings
      rings.forEach(r => {
        r.rotation += r.rotSpeed;
      });

      // Update UI
      const displaySpeed = Math.floor(speed * 40);
      document.getElementById('speed').textContent = displaySpeed;
      document.getElementById('drift-score').textContent = `DRIFT: ${Math.floor(driftScore + currentDrift * driftMultiplier)}`;

      const multEl = document.getElementById('drift-multiplier');
      if (ship.drifting && driftMultiplier > 1) {
        multEl.textContent = `x${driftMultiplier}`;
        multEl.style.opacity = '1';
      } else {
        multEl.style.opacity = '0';
      }
    }

    function draw() {
      ctx.fillStyle = '#0a0a12';
      ctx.fillRect(0, 0, W, H);

      // Camera follows ship
      ctx.save();
      ctx.translate(W/2 - ship.x, H/2 - ship.y);

      // Draw stars
      stars.forEach(star => {
        const pulse = 0.5 + Math.sin(Date.now() * 0.003 + star.brightness * 10) * 0.5;
        ctx.fillStyle = `rgba(255, 255, 255, ${star.brightness * pulse})`;
        ctx.beginPath();
        ctx.arc(star.x, star.y, star.size, 0, Math.PI * 2);
        ctx.fill();
      });

      // Draw grid
      ctx.strokeStyle = 'rgba(0, 255, 255, 0.1)';
      ctx.lineWidth = 1;
      const gridSize = 100;
      const gridRange = 2000;
      for (let x = -gridRange; x <= gridRange; x += gridSize) {
        ctx.beginPath();
        ctx.moveTo(x, -gridRange);
        ctx.lineTo(x, gridRange);
        ctx.stroke();
      }
      for (let y = -gridRange; y <= gridRange; y += gridSize) {
        ctx.beginPath();
        ctx.moveTo(-gridRange, y);
        ctx.lineTo(gridRange, y);
        ctx.stroke();
      }

      // Draw rings
      rings.forEach(ring => {
        ctx.save();
        ctx.translate(ring.x, ring.y);
        ctx.rotate(ring.rotation);

        const gradient = ctx.createRadialGradient(0, 0, ring.radius - 10, 0, 0, ring.radius + 10);
        gradient.addColorStop(0, 'transparent');
        gradient.addColorStop(0.4, `hsla(${ring.hue}, 100%, 50%, 0.3)`);
        gradient.addColorStop(0.5, `hsla(${ring.hue}, 100%, 70%, 0.8)`);
        gradient.addColorStop(0.6, `hsla(${ring.hue}, 100%, 50%, 0.3)`);
        gradient.addColorStop(1, 'transparent');

        ctx.strokeStyle = `hsla(${ring.hue}, 100%, 60%, 0.8)`;
        ctx.lineWidth = 4;
        ctx.shadowColor = `hsl(${ring.hue}, 100%, 60%)`;
        ctx.shadowBlur = 20;

        ctx.beginPath();
        ctx.ellipse(0, 0, ring.radius, ring.radius * 0.3, 0, 0, Math.PI * 2);
        ctx.stroke();

        ctx.restore();
      });

      // Draw trails
      trails.forEach(t => {
        ctx.globalAlpha = t.life;
        ctx.fillStyle = t.color;
        ctx.shadowColor = t.color;
        ctx.shadowBlur = 15;
        ctx.beginPath();
        ctx.arc(t.x, t.y, t.size * t.life, 0, Math.PI * 2);
        ctx.fill();
      });
      ctx.globalAlpha = 1;
      ctx.shadowBlur = 0;

      // Draw ship
      ctx.save();
      ctx.translate(ship.x, ship.y);
      ctx.rotate(ship.angle);

      // Ship glow
      const shipGlow = ship.drifting ? '#f0f' : '#0ff';
      ctx.shadowColor = shipGlow;
      ctx.shadowBlur = 30;

      // Ship body
      ctx.fillStyle = ship.drifting ? '#f0f' : '#0ff';
      ctx.beginPath();
      ctx.moveTo(25, 0);
      ctx.lineTo(-15, -12);
      ctx.lineTo(-10, 0);
      ctx.lineTo(-15, 12);
      ctx.closePath();
      ctx.fill();

      // Cockpit
      ctx.fillStyle = '#fff';
      ctx.shadowBlur = 10;
      ctx.beginPath();
      ctx.ellipse(5, 0, 6, 4, 0, 0, Math.PI * 2);
      ctx.fill();

      // Engine glow
      if (isPressed('up')) {
        const flameGrad = ctx.createLinearGradient(-10, 0, -30, 0);
        flameGrad.addColorStop(0, '#fff');
        flameGrad.addColorStop(0.3, ship.drifting ? '#f0f' : '#0ff');
        flameGrad.addColorStop(1, 'transparent');

        ctx.fillStyle = flameGrad;
        ctx.shadowColor = ship.drifting ? '#f0f' : '#0ff';
        ctx.shadowBlur = 25;
        ctx.beginPath();
        ctx.moveTo(-10, -6);
        ctx.lineTo(-25 - Math.random() * 10, 0);
        ctx.lineTo(-10, 6);
        ctx.closePath();
        ctx.fill();
      }

      ctx.restore();

      // Drift indicator
      if (ship.drifting) {
        const speed = Math.sqrt(ship.vx * ship.vx + ship.vy * ship.vy);
        if (speed > 5) {
          ctx.save();
          ctx.translate(ship.x, ship.y);

          // Drift sparks
          for (let i = 0; i < 3; i++) {
            const sparkAngle = ship.angle + Math.PI + (Math.random() - 0.5) * 0.5;
            const sparkDist = 20 + Math.random() * 15;
            ctx.fillStyle = `hsla(${50 + Math.random() * 30}, 100%, 70%, ${Math.random()})`;
            ctx.shadowColor = '#ff0';
            ctx.shadowBlur = 10;
            ctx.beginPath();
            ctx.arc(
              Math.cos(sparkAngle) * sparkDist,
              Math.sin(sparkAngle) * sparkDist,
              2, 0, Math.PI * 2
            );
            ctx.fill();
          }

          ctx.restore();
        }
      }

      ctx.restore();

      // Vignette
      const vignette = ctx.createRadialGradient(W/2, H/2, H * 0.3, W/2, H/2, H * 0.8);
      vignette.addColorStop(0, 'transparent');
      vignette.addColorStop(1, 'rgba(0, 0, 0, 0.5)');
      ctx.fillStyle = vignette;
      ctx.fillRect(0, 0, W, H);
    }

    function gameLoop() {
      update();
      draw();
      requestAnimationFrame(gameLoop);
    }

    gameLoop();
  </script>
</body>
</html>
