<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
  <title>GALLEON DRIFT - Heavy Seas Racing</title>
  <link rel="icon" href="https://emojicdn.elk.sh/‚öì">
  <meta property="og:title" content="GALLEON DRIFT - Heavy Seas Racing">
  <meta property="og:description" content="Skid yer heavy galleon around jagged rocks on treacherous seas!">
  <meta property="og:url" content="https://app.sloppy.live/neon-drift">
  <meta property="og:image" content="https://emojicdn.elk.sh/üè¥‚Äç‚ò†Ô∏è?style=apple&size=512">
  <link href="https://fonts.googleapis.com/css2?family=Pirata+One&family=IM+Fell+English+SC&display=swap" rel="stylesheet">
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      background: #0d1a2a;
      overflow: hidden;
      font-family: 'IM Fell English SC', serif;
      touch-action: none;
    }
    canvas { display: block; }
    #ui {
      position: fixed;
      top: 20px;
      left: 20px;
      color: #d4a84b;
      text-shadow: 2px 2px 0 #1a0f0a, 0 0 15px rgba(212, 168, 75, 0.5);
      z-index: 10;
    }
    #speed {
      font-family: 'Pirata One', cursive;
      font-size: 48px;
    }
    #speed-unit {
      font-size: 16px;
      opacity: 0.7;
    }
    #drift-score {
      font-family: 'Pirata One', cursive;
      font-size: 24px;
      color: #ffd700;
      text-shadow: 2px 2px 0 #5c3a1e, 0 0 15px rgba(255, 215, 0, 0.5);
      margin-top: 10px;
    }
    #drift-multiplier {
      font-family: 'Pirata One', cursive;
      font-size: 20px;
      color: #ff6b35;
      text-shadow: 0 0 10px rgba(255, 107, 53, 0.7);
      opacity: 0;
      transition: opacity 0.2s;
    }
    #drift-label {
      font-family: 'Pirata One', cursive;
      font-size: 14px;
      color: #8b4513;
      opacity: 0;
      transition: opacity 0.2s;
      margin-top: 5px;
    }
    #controls-hint {
      position: fixed;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      color: #5c3a1e;
      opacity: 0.7;
      font-size: 12px;
      text-align: center;
    }
    #backlink {
      position: fixed;
      bottom: 5px;
      right: 10px;
      color: #5c3a1e55;
      text-decoration: none;
      font-size: 11px;
    }
    #backlink:hover { color: #d4a84b; }
    #mobile-controls {
      display: none;
      position: fixed;
      bottom: 0;
      left: 0;
      right: 0;
      height: 150px;
      z-index: 20;
    }
    .mobile-btn {
      position: absolute;
      width: 70px;
      height: 70px;
      border: 2px solid #d4a84b;
      border-radius: 50%;
      background: rgba(92, 58, 30, 0.3);
      color: #d4a84b;
      font-size: 24px;
      display: flex;
      align-items: center;
      justify-content: center;
      user-select: none;
    }
    .mobile-btn:active {
      background: rgba(212, 168, 75, 0.4);
    }
    #btn-left { left: 20px; bottom: 40px; }
    #btn-right { left: 110px; bottom: 40px; }
    #btn-gas { right: 20px; bottom: 40px; }
    #btn-drift { right: 110px; bottom: 40px; font-size: 14px; }
    @media (max-width: 768px) {
      #mobile-controls { display: block; }
      #controls-hint { display: none; }
      #speed { font-size: 32px; }
      #drift-score { font-size: 18px; }
    }
  </style>
</head>
<body>
  <canvas id="game"></canvas>

  <div id="ui">
    <div id="speed">0</div>
    <div id="speed-unit">KNOTS</div>
    <div id="drift-score">PLUNDER: 0</div>
    <div id="drift-multiplier">x1</div>
    <div id="drift-label">‚öì DRIFTING!</div>
  </div>

  <div id="controls-hint">
    WASD or Arrows to sail ‚Ä¢ Hold SPACE to DRIFT around rocks!
  </div>

  <div id="mobile-controls">
    <div class="mobile-btn" id="btn-left">‚óÄ</div>
    <div class="mobile-btn" id="btn-right">‚ñ∂</div>
    <div class="mobile-btn" id="btn-drift">DRIFT</div>
    <div class="mobile-btn" id="btn-gas">‚õµ</div>
  </div>

  <a id="backlink" href="https://sloppy.live">‚Üê sloppy.live</a>

  <script>
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');

    let W, H;
    function resize() {
      W = canvas.width = window.innerWidth;
      H = canvas.height = window.innerHeight;
    }
    resize();
    window.addEventListener('resize', resize);

    const ship = {
      x: 0,
      y: 0,
      vx: 0,
      vy: 0,
      angle: -Math.PI / 2,
      angularVel: 0,
      drifting: false,
      driftAngle: 0,
      creakTime: 0
    };

    const trails = [];
    const MAX_TRAILS = 500;
    const splashes = [];

    let driftScore = 0;
    let currentDrift = 0;
    let driftMultiplier = 1;
    let driftTime = 0;

    // Jagged rocks
    const rocks = [];
    for (let i = 0; i < 25; i++) {
      const baseX = Math.random() * 5000 - 2500;
      const baseY = Math.random() * 5000 - 2500;
      // Don't spawn too close to start
      if (Math.abs(baseX) < 200 && Math.abs(baseY) < 200) continue;

      const points = [];
      const numPoints = 5 + Math.floor(Math.random() * 4);
      const baseRadius = 40 + Math.random() * 60;
      for (let j = 0; j < numPoints; j++) {
        const angle = (j / numPoints) * Math.PI * 2;
        const r = baseRadius * (0.6 + Math.random() * 0.6);
        points.push({
          x: Math.cos(angle) * r,
          y: Math.sin(angle) * r
        });
      }
      rocks.push({
        x: baseX,
        y: baseY,
        points: points,
        radius: baseRadius,
        color: `rgb(${30 + Math.random() * 20}, ${25 + Math.random() * 15}, ${20 + Math.random() * 15})`
      });
    }

    // Floating debris
    const debris = [];
    for (let i = 0; i < 15; i++) {
      debris.push({
        x: Math.random() * 4000 - 2000,
        y: Math.random() * 4000 - 2000,
        type: ['barrel', 'crate', 'plank'][Math.floor(Math.random() * 3)],
        bob: Math.random() * Math.PI * 2,
        rot: Math.random() * Math.PI * 2
      });
    }

    const keys = {};
    const mobileKeys = { left: false, right: false, up: false, drift: false };

    window.addEventListener('keydown', e => {
      keys[e.code] = true;
      if (['Space', 'ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight'].includes(e.code)) {
        e.preventDefault();
      }
    });
    window.addEventListener('keyup', e => keys[e.code] = false);

    function setupMobileBtn(id, key) {
      const btn = document.getElementById(id);
      btn.addEventListener('touchstart', e => { e.preventDefault(); mobileKeys[key] = true; });
      btn.addEventListener('touchend', e => { e.preventDefault(); mobileKeys[key] = false; });
    }
    setupMobileBtn('btn-left', 'left');
    setupMobileBtn('btn-right', 'right');
    setupMobileBtn('btn-gas', 'up');
    setupMobileBtn('btn-drift', 'drift');

    function isPressed(action) {
      switch(action) {
        case 'left': return keys['ArrowLeft'] || keys['KeyA'] || mobileKeys.left;
        case 'right': return keys['ArrowRight'] || keys['KeyD'] || mobileKeys.right;
        case 'up': return keys['ArrowUp'] || keys['KeyW'] || mobileKeys.up;
        case 'drift': return keys['Space'] || keys['ShiftLeft'] || keys['ShiftRight'] || mobileKeys.drift;
      }
      return false;
    }

    // Heavy galleon physics - slower but more momentum
    const ACCEL = 0.08;
    const MAX_SPEED = 14;
    const TURN_SPEED = 0.025;
    const DRIFT_TURN = 0.055;
    const FRICTION = 0.994;
    const DRIFT_FRICTION = 0.985;

    function spawnSplash(x, y, intensity) {
      for (let i = 0; i < intensity; i++) {
        splashes.push({
          x: x + (Math.random() - 0.5) * 20,
          y: y + (Math.random() - 0.5) * 20,
          vx: (Math.random() - 0.5) * 4,
          vy: (Math.random() - 0.5) * 4 - 2,
          life: 1,
          size: 3 + Math.random() * 4
        });
      }
    }

    function checkRockCollision() {
      for (const rock of rocks) {
        const dx = ship.x - rock.x;
        const dy = ship.y - rock.y;
        const dist = Math.sqrt(dx * dx + dy * dy);

        if (dist < rock.radius + 25) {
          // Push away from rock
          const pushX = dx / dist;
          const pushY = dy / dist;
          const overlap = rock.radius + 25 - dist;

          ship.x += pushX * overlap * 0.5;
          ship.y += pushY * overlap * 0.5;

          // Bounce velocity
          ship.vx = pushX * Math.abs(ship.vx) * 0.3;
          ship.vy = pushY * Math.abs(ship.vy) * 0.3;

          spawnSplash(ship.x - pushX * 30, ship.y - pushY * 30, 8);

          // Lose some drift score on collision
          if (currentDrift > 50) {
            currentDrift *= 0.7;
          }
        }
      }
    }

    function update() {
      if (isPressed('up')) {
        ship.vx += Math.cos(ship.angle) * ACCEL;
        ship.vy += Math.sin(ship.angle) * ACCEL;
      }

      const wasDrifting = ship.drifting;
      const speed = Math.sqrt(ship.vx * ship.vx + ship.vy * ship.vy);
      ship.drifting = isPressed('drift') && speed > 2;

      if (ship.drifting && !wasDrifting) {
        ship.driftAngle = Math.atan2(ship.vy, ship.vx);
      }

      const turnSpeed = ship.drifting ? DRIFT_TURN : TURN_SPEED;
      if (isPressed('left')) ship.angle -= turnSpeed;
      if (isPressed('right')) ship.angle += turnSpeed;

      const friction = ship.drifting ? DRIFT_FRICTION : FRICTION;
      ship.vx *= friction;
      ship.vy *= friction;

      if (speed > MAX_SPEED) {
        ship.vx = (ship.vx / speed) * MAX_SPEED;
        ship.vy = (ship.vy / speed) * MAX_SPEED;
      }

      ship.x += ship.vx;
      ship.y += ship.vy;

      checkRockCollision();

      // Drift scoring
      if (ship.drifting && speed > 3) {
        const moveAngle = Math.atan2(ship.vy, ship.vx);
        let angleDiff = Math.abs(ship.angle - moveAngle);
        if (angleDiff > Math.PI) angleDiff = Math.PI * 2 - angleDiff;

        if (angleDiff > 0.3) {
          driftTime += 1/60;
          currentDrift += angleDiff * speed * 0.8;
          driftMultiplier = Math.min(5, 1 + Math.floor(driftTime / 1.5));
          ship.creakTime += 0.1;
        }
      } else if (wasDrifting && currentDrift > 0) {
        driftScore += Math.floor(currentDrift * driftMultiplier);
        currentDrift = 0;
        driftTime = 0;
        driftMultiplier = 1;
      }

      // Heavy wake trails
      if (speed > 0.5) {
        const wakeAlpha = ship.drifting ? 0.5 : 0.3;
        const wakeColor = ship.drifting ?
          `rgba(255, 255, 255, ${wakeAlpha + Math.random() * 0.2})` :
          `rgba(200, 220, 255, ${wakeAlpha * 0.7})`;

        // Wider wake for galleon
        for (let side = -1; side <= 1; side += 2) {
          const wakeX = ship.x + Math.cos(ship.angle + Math.PI * 0.85 * side) * 28;
          const wakeY = ship.y + Math.sin(ship.angle + Math.PI * 0.85 * side) * 28;
          trails.push({
            x: wakeX,
            y: wakeY,
            vx: -ship.vx * 0.03 + (Math.random() - 0.5) * 0.5,
            vy: -ship.vy * 0.03 + (Math.random() - 0.5) * 0.5,
            life: 1,
            color: wakeColor,
            size: ship.drifting ? 14 : 8
          });
        }

        // Center wake
        if (speed > 2) {
          trails.push({
            x: ship.x + Math.cos(ship.angle + Math.PI) * 35,
            y: ship.y + Math.sin(ship.angle + Math.PI) * 35,
            vx: -ship.vx * 0.02,
            vy: -ship.vy * 0.02,
            life: 1,
            color: `rgba(180, 200, 220, 0.4)`,
            size: 10
          });
        }
      }

      // Update trails
      for (let i = trails.length - 1; i >= 0; i--) {
        const t = trails[i];
        t.x += t.vx;
        t.y += t.vy;
        t.life -= 0.01;
        t.size *= 1.008;
        if (t.life <= 0) trails.splice(i, 1);
      }
      while (trails.length > MAX_TRAILS) trails.shift();

      // Update splashes
      for (let i = splashes.length - 1; i >= 0; i--) {
        const s = splashes[i];
        s.x += s.vx;
        s.y += s.vy;
        s.vy += 0.15;
        s.life -= 0.03;
        if (s.life <= 0) splashes.splice(i, 1);
      }

      // Bob debris
      debris.forEach(d => {
        d.bob += 0.02;
        d.rot += 0.005;
      });

      // UI updates
      document.getElementById('speed').textContent = Math.floor(speed * 2.5);
      document.getElementById('drift-score').textContent = `PLUNDER: ${Math.floor(driftScore + currentDrift * driftMultiplier)}`;

      const multEl = document.getElementById('drift-multiplier');
      const labelEl = document.getElementById('drift-label');
      if (ship.drifting && speed > 3) {
        multEl.textContent = `x${driftMultiplier}`;
        multEl.style.opacity = '1';
        labelEl.style.opacity = '1';
      } else {
        multEl.style.opacity = '0';
        labelEl.style.opacity = '0';
      }
    }

    function drawRock(rock) {
      ctx.fillStyle = rock.color;
      ctx.strokeStyle = '#1a1512';
      ctx.lineWidth = 3;

      ctx.beginPath();
      ctx.moveTo(rock.x + rock.points[0].x, rock.y + rock.points[0].y);
      for (let i = 1; i < rock.points.length; i++) {
        ctx.lineTo(rock.x + rock.points[i].x, rock.y + rock.points[i].y);
      }
      ctx.closePath();
      ctx.fill();
      ctx.stroke();

      // Highlight
      ctx.fillStyle = 'rgba(80, 70, 60, 0.5)';
      ctx.beginPath();
      ctx.moveTo(rock.x + rock.points[0].x * 0.6, rock.y + rock.points[0].y * 0.6 - 5);
      for (let i = 1; i < Math.floor(rock.points.length / 2); i++) {
        ctx.lineTo(rock.x + rock.points[i].x * 0.6, rock.y + rock.points[i].y * 0.6 - 5);
      }
      ctx.closePath();
      ctx.fill();
    }

    function drawGalleon() {
      ctx.save();
      ctx.translate(ship.x, ship.y);
      ctx.rotate(ship.angle);

      const rocking = Math.sin(Date.now() * 0.003) * 0.03;
      ctx.rotate(rocking);

      // Hull shadow
      ctx.shadowColor = 'rgba(0, 0, 0, 0.6)';
      ctx.shadowBlur = 20;
      ctx.shadowOffsetY = 8;

      // Main hull - dark wood
      const hullGrad = ctx.createLinearGradient(-40, -20, -40, 20);
      hullGrad.addColorStop(0, ship.drifting ? '#8b2500' : '#3d2817');
      hullGrad.addColorStop(0.5, ship.drifting ? '#a52a2a' : '#5c3a1e');
      hullGrad.addColorStop(1, ship.drifting ? '#6b1c00' : '#2a1810');
      ctx.fillStyle = hullGrad;

      ctx.beginPath();
      ctx.moveTo(45, 0);
      // Bow (front)
      ctx.quadraticCurveTo(50, -8, 40, -14);
      ctx.lineTo(-30, -16);
      // Stern castle
      ctx.lineTo(-40, -18);
      ctx.lineTo(-45, -10);
      ctx.lineTo(-45, 10);
      ctx.lineTo(-40, 18);
      ctx.lineTo(-30, 16);
      ctx.lineTo(40, 14);
      ctx.quadraticCurveTo(50, 8, 45, 0);
      ctx.closePath();
      ctx.fill();

      ctx.shadowBlur = 0;
      ctx.shadowOffsetY = 0;

      // Hull stripes
      ctx.strokeStyle = '#d4a84b';
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(40, -12);
      ctx.lineTo(-35, -14);
      ctx.stroke();
      ctx.beginPath();
      ctx.moveTo(40, 12);
      ctx.lineTo(-35, 14);
      ctx.stroke();

      // Deck
      ctx.fillStyle = '#6b4423';
      ctx.beginPath();
      ctx.ellipse(5, 0, 30, 10, 0, 0, Math.PI * 2);
      ctx.fill();

      // Deck planks
      ctx.strokeStyle = '#4a2c0f';
      ctx.lineWidth = 1;
      for (let i = -25; i < 35; i += 8) {
        ctx.beginPath();
        ctx.moveTo(i, -8);
        ctx.lineTo(i, 8);
        ctx.stroke();
      }

      // Main mast
      ctx.fillStyle = '#3d2817';
      ctx.fillRect(-3, -55, 6, 55);

      // Crow's nest
      ctx.fillStyle = '#5c3a1e';
      ctx.fillRect(-8, -58, 16, 6);

      // Main sail
      const sailPuff = isPressed('up') ? 12 : 6;
      const sailWave = Math.sin(Date.now() * 0.004) * 3;
      ctx.fillStyle = ship.drifting ? '#8b0000' : '#e8dcc8';
      ctx.beginPath();
      ctx.moveTo(-2, -52);
      ctx.quadraticCurveTo(sailPuff + sailWave, -35, sailPuff + sailWave * 0.5, -15);
      ctx.lineTo(2, -15);
      ctx.quadraticCurveTo(-sailPuff * 0.3, -35, 2, -52);
      ctx.closePath();
      ctx.fill();

      // Sail lines
      ctx.strokeStyle = ship.drifting ? '#5c0000' : '#8b7355';
      ctx.lineWidth = 1;
      ctx.beginPath();
      ctx.moveTo(0, -52);
      ctx.lineTo(sailPuff + sailWave * 0.5, -35);
      ctx.moveTo(0, -52);
      ctx.lineTo(sailPuff + sailWave * 0.5, -20);
      ctx.stroke();

      // Front mast (smaller)
      ctx.fillStyle = '#3d2817';
      ctx.fillRect(22, -35, 4, 35);

      // Front sail
      ctx.fillStyle = ship.drifting ? '#a52a2a' : '#f5f5dc';
      ctx.beginPath();
      ctx.moveTo(22, -32);
      ctx.quadraticCurveTo(30 + sailWave * 0.5, -20, 28 + sailWave * 0.3, -5);
      ctx.lineTo(26, -5);
      ctx.quadraticCurveTo(20, -20, 26, -32);
      ctx.closePath();
      ctx.fill();

      // Stern castle structure
      ctx.fillStyle = '#4a2c0f';
      ctx.fillRect(-42, -15, 15, 30);

      // Windows
      ctx.fillStyle = '#ffd700';
      ctx.globalAlpha = 0.6;
      ctx.fillRect(-40, -10, 4, 4);
      ctx.fillRect(-40, 6, 4, 4);
      ctx.globalAlpha = 1;

      // Jolly Roger flag
      ctx.fillStyle = '#0a0a0a';
      ctx.beginPath();
      ctx.moveTo(0, -55);
      ctx.lineTo(18, -50);
      ctx.lineTo(18, -40);
      ctx.lineTo(0, -45);
      ctx.closePath();
      ctx.fill();

      // Skull on flag
      ctx.fillStyle = '#fff';
      ctx.font = '10px serif';
      ctx.fillText('‚ò†', 5, -45);

      // Cannons poking out (visible when drifting)
      if (ship.drifting) {
        ctx.fillStyle = '#2a2a2a';
        ctx.fillRect(-15, -18, 8, 4);
        ctx.fillRect(-15, 14, 8, 4);
        ctx.fillRect(5, -18, 8, 4);
        ctx.fillRect(5, 14, 8, 4);

        // Cannon fire!
        if (Math.random() > 0.85) {
          ctx.fillStyle = '#ff6600';
          ctx.shadowColor = '#ff6600';
          ctx.shadowBlur = 15;
          const side = Math.random() > 0.5 ? -20 : 20;
          const cannonX = Math.random() > 0.5 ? -12 : 8;
          ctx.beginPath();
          ctx.arc(cannonX, side, 6, 0, Math.PI * 2);
          ctx.fill();
          ctx.shadowBlur = 0;
        }
      }

      // Bow figurehead
      ctx.fillStyle = '#d4a84b';
      ctx.beginPath();
      ctx.moveTo(45, 0);
      ctx.lineTo(52, -2);
      ctx.lineTo(52, 2);
      ctx.closePath();
      ctx.fill();

      ctx.restore();
    }

    function draw() {
      // Ocean gradient
      const oceanGrad = ctx.createLinearGradient(0, 0, 0, H);
      oceanGrad.addColorStop(0, '#0d1a2a');
      oceanGrad.addColorStop(0.5, '#1a2d4a');
      oceanGrad.addColorStop(1, '#0a1520');
      ctx.fillStyle = oceanGrad;
      ctx.fillRect(0, 0, W, H);

      ctx.save();
      ctx.translate(W/2 - ship.x, H/2 - ship.y);

      // Ocean waves
      const time = Date.now() * 0.001;
      ctx.strokeStyle = 'rgba(100, 150, 180, 0.12)';
      ctx.lineWidth = 2;
      for (let y = -3000; y < 3000; y += 50) {
        ctx.beginPath();
        for (let x = -3000; x < 3000; x += 15) {
          const wave = Math.sin((x + time * 30) * 0.015 + y * 0.008) * 10;
          if (x === -3000) ctx.moveTo(x, y + wave);
          else ctx.lineTo(x, y + wave);
        }
        ctx.stroke();
      }

      // Draw rocks
      rocks.forEach(drawRock);

      // Draw debris
      debris.forEach(d => {
        const bobY = Math.sin(d.bob) * 4;
        ctx.save();
        ctx.translate(d.x, d.y + bobY);
        ctx.rotate(d.rot);

        if (d.type === 'barrel') {
          ctx.fillStyle = '#6b4423';
          ctx.beginPath();
          ctx.ellipse(0, 0, 10, 14, 0, 0, Math.PI * 2);
          ctx.fill();
          ctx.strokeStyle = '#3d2817';
          ctx.lineWidth = 2;
          ctx.beginPath();
          ctx.ellipse(0, -6, 8, 3, 0, 0, Math.PI * 2);
          ctx.stroke();
          ctx.beginPath();
          ctx.ellipse(0, 6, 8, 3, 0, 0, Math.PI * 2);
          ctx.stroke();
        } else if (d.type === 'crate') {
          ctx.fillStyle = '#5c3a1e';
          ctx.fillRect(-12, -10, 24, 20);
          ctx.strokeStyle = '#3d2817';
          ctx.lineWidth = 2;
          ctx.strokeRect(-12, -10, 24, 20);
          ctx.beginPath();
          ctx.moveTo(-12, 0);
          ctx.lineTo(12, 0);
          ctx.moveTo(0, -10);
          ctx.lineTo(0, 10);
          ctx.stroke();
        } else {
          ctx.fillStyle = '#6b4423';
          ctx.fillRect(-20, -3, 40, 6);
        }
        ctx.restore();
      });

      // Draw wake trails
      trails.forEach(t => {
        ctx.globalAlpha = t.life * 0.5;
        ctx.fillStyle = t.color;
        ctx.beginPath();
        ctx.arc(t.x, t.y, t.size * t.life, 0, Math.PI * 2);
        ctx.fill();
      });
      ctx.globalAlpha = 1;

      // Draw splashes
      splashes.forEach(s => {
        ctx.globalAlpha = s.life;
        ctx.fillStyle = '#fff';
        ctx.beginPath();
        ctx.arc(s.x, s.y, s.size * s.life, 0, Math.PI * 2);
        ctx.fill();
      });
      ctx.globalAlpha = 1;

      // Draw galleon
      drawGalleon();

      // Drift spray
      if (ship.drifting) {
        const speed = Math.sqrt(ship.vx * ship.vx + ship.vy * ship.vy);
        if (speed > 3) {
          for (let i = 0; i < 6; i++) {
            const sprayAngle = ship.angle + Math.PI + (Math.random() - 0.5) * 1;
            const sprayDist = 35 + Math.random() * 25;
            ctx.fillStyle = `rgba(255, 255, 255, ${Math.random() * 0.7})`;
            ctx.beginPath();
            ctx.arc(
              ship.x + Math.cos(sprayAngle) * sprayDist,
              ship.y + Math.sin(sprayAngle) * sprayDist,
              2 + Math.random() * 3, 0, Math.PI * 2
            );
            ctx.fill();
          }
        }
      }

      ctx.restore();

      // Vignette
      const vignette = ctx.createRadialGradient(W/2, H/2, H * 0.25, W/2, H/2, H * 0.85);
      vignette.addColorStop(0, 'transparent');
      vignette.addColorStop(1, 'rgba(0, 0, 0, 0.5)');
      ctx.fillStyle = vignette;
      ctx.fillRect(0, 0, W, H);
    }

    function gameLoop() {
      update();
      draw();
      requestAnimationFrame(gameLoop);
    }

    gameLoop();
  </script>
<script src="/apps/sloppy-header/sloppy-bar.js"></script>
<script src="/vibelib-extended.js"></script>
<script>
  // Compatibility Patch for Legacy Apps
  window.addEventListener("load", () => {
    if (window.SloppyKarma && window.VibeLib.Economy) {
      // Redirect old calls to new engine
      window.SloppyKarma.track = window.VibeLib.Economy.track;
    }
  });
</script>
</body>
</html>
