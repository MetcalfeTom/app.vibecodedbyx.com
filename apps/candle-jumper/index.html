<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Candle Jumper - Crypto Platformer</title>
  <link rel="icon" href="https://emojicdn.elk.sh/üìà">
  <meta property="og:title" content="Candle Jumper - Crypto Platformer">
  <meta property="og:description" content="Jump on green candles, dodge the red! A crypto trading platformer.">
  <meta property="og:url" content="https://app.sloppy.live/candle-jumper">
  <meta property="og:image" content="https://app.sloppy.live/candle-jumper/og-image.png">
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&family=Share+Tech+Mono&display=swap" rel="stylesheet">
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: 'Share Tech Mono', monospace;
      background: #0a0a12;
      min-height: 100vh;
      overflow: hidden;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
    }

    #game-container {
      position: relative;
      border: 3px solid #00ff88;
      box-shadow: 0 0 30px rgba(0, 255, 136, 0.3), inset 0 0 50px rgba(0, 255, 136, 0.05);
      background: linear-gradient(180deg, #0a0a12 0%, #0f1a15 100%);
    }

    #canvas {
      display: block;
    }

    #ui {
      position: absolute;
      top: 10px;
      left: 10px;
      right: 10px;
      display: flex;
      justify-content: space-between;
      pointer-events: none;
      z-index: 10;
    }

    .stat {
      background: rgba(0, 0, 0, 0.7);
      border: 1px solid #00ff88;
      padding: 8px 15px;
      color: #00ff88;
      font-size: 1rem;
      text-shadow: 0 0 10px #00ff88;
    }

    .stat-value {
      color: #fff;
      font-weight: bold;
    }

    #start-screen, #game-over {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(10, 10, 18, 0.95);
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      z-index: 20;
    }

    #game-over {
      display: none;
    }

    h1 {
      font-family: 'Orbitron', sans-serif;
      font-size: 2.5rem;
      color: #00ff88;
      text-shadow: 0 0 20px #00ff88;
      margin-bottom: 10px;
      text-align: center;
    }

    .subtitle {
      color: #0a8;
      font-size: 1rem;
      margin-bottom: 30px;
    }

    .instructions {
      color: #888;
      font-size: 0.9rem;
      margin-bottom: 20px;
      text-align: center;
      line-height: 1.8;
    }

    .instructions span {
      color: #00ff88;
    }

    .btn {
      background: linear-gradient(180deg, #00ff88, #00aa55);
      border: none;
      padding: 15px 40px;
      font-family: 'Orbitron', sans-serif;
      font-size: 1.2rem;
      color: #000;
      cursor: pointer;
      border-radius: 5px;
      transition: all 0.2s;
      box-shadow: 0 0 20px rgba(0, 255, 136, 0.4);
    }

    .btn:hover {
      transform: scale(1.05);
      box-shadow: 0 0 30px rgba(0, 255, 136, 0.6);
    }

    .final-score {
      font-family: 'Orbitron', sans-serif;
      font-size: 3rem;
      color: #fff;
      margin: 20px 0;
    }

    .high-score {
      color: #ff0;
      margin-bottom: 20px;
    }

    #mobile-controls {
      display: none;
      position: absolute;
      bottom: 10px;
      left: 10px;
      right: 10px;
      justify-content: space-between;
      z-index: 15;
    }

    .mobile-btn {
      width: 70px;
      height: 70px;
      background: rgba(0, 255, 136, 0.2);
      border: 2px solid #00ff88;
      border-radius: 10px;
      color: #00ff88;
      font-size: 1.5rem;
      cursor: pointer;
      user-select: none;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .mobile-btn:active {
      background: rgba(0, 255, 136, 0.4);
    }

    .jump-btn {
      width: 100px;
    }

    #back-link {
      position: fixed;
      bottom: 10px;
      color: #333;
      font-size: 0.75rem;
      text-decoration: none;
    }

    #back-link:hover {
      color: #00ff88;
    }

    @media (max-width: 800px) {
      #mobile-controls {
        display: flex;
      }
      h1 { font-size: 1.8rem; }
      .stat { font-size: 0.8rem; padding: 5px 10px; }
    }

    @media (max-height: 600px) {
      h1 { font-size: 1.5rem; }
      .instructions { font-size: 0.8rem; margin-bottom: 15px; }
      .btn { padding: 10px 30px; font-size: 1rem; }
    }
  </style>
</head>
<body>
  <div id="game-container">
    <canvas id="canvas"></canvas>

    <div id="ui">
      <div class="stat">SCORE: <span class="stat-value" id="score">0</span></div>
      <div class="stat">HIGH: <span class="stat-value" id="high-score">0</span></div>
    </div>

    <div id="start-screen">
      <h1>üìà CANDLE JUMPER</h1>
      <div class="subtitle">CRYPTO PLATFORMER</div>
      <div class="instructions">
        <span>‚Üê ‚Üí</span> or <span>A D</span> to move<br>
        <span>SPACE</span> or <span>W</span> to jump<br><br>
        üü¢ Jump on <span style="color:#00ff88">GREEN</span> candles<br>
        üî¥ Dodge <span style="color:#ff4444">RED</span> candles<br>
        üí∞ Collect coins for bonus points!
      </div>
      <button class="btn" onclick="startGame()">START TRADING</button>
    </div>

    <div id="game-over">
      <h1>üìâ LIQUIDATED!</h1>
      <div class="final-score" id="final-score">0</div>
      <div class="high-score">HIGH SCORE: <span id="final-high">0</span></div>
      <button class="btn" onclick="startGame()">TRADE AGAIN</button>
    </div>

    <div id="mobile-controls">
      <div style="display: flex; gap: 10px;">
        <button class="mobile-btn" id="left-btn">‚óÄ</button>
        <button class="mobile-btn" id="right-btn">‚ñ∂</button>
      </div>
      <button class="mobile-btn jump-btn" id="jump-btn">JUMP</button>
    </div>
  </div>

  <a id="back-link" href="https://sloppy.live">sloppy.live</a>

  <script>
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');

    // Responsive canvas sizing
    function resizeCanvas() {
      const maxWidth = Math.min(800, window.innerWidth - 20);
      const maxHeight = Math.min(600, window.innerHeight - 100);
      canvas.width = maxWidth;
      canvas.height = maxHeight;
      document.getElementById('game-container').style.width = maxWidth + 'px';
      document.getElementById('game-container').style.height = maxHeight + 'px';
    }
    resizeCanvas();
    window.addEventListener('resize', resizeCanvas);

    // Game state
    let gameRunning = false;
    let score = 0;
    let highScore = parseInt(localStorage.getItem('candleJumperHigh') || '0');
    document.getElementById('high-score').textContent = highScore;

    // Player
    const player = {
      x: 100,
      y: 0,
      width: 30,
      height: 40,
      vx: 0,
      vy: 0,
      onGround: false,
      speed: 5,
      jumpForce: -15,
      gravity: 0.6
    };

    // Game objects
    let greenCandles = [];
    let redCandles = [];
    let coins = [];
    let particles = [];

    // Input
    const keys = {};

    // Audio context
    let audioCtx;
    function initAudio() {
      if (!audioCtx) {
        audioCtx = new (window.AudioContext || window.webkitAudioContext)();
      }
    }

    function playJump() {
      if (!audioCtx) return;
      const osc = audioCtx.createOscillator();
      const gain = audioCtx.createGain();
      osc.connect(gain);
      gain.connect(audioCtx.destination);
      osc.frequency.setValueAtTime(400, audioCtx.currentTime);
      osc.frequency.exponentialRampToValueAtTime(800, audioCtx.currentTime + 0.1);
      gain.gain.setValueAtTime(0.1, audioCtx.currentTime);
      gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.1);
      osc.start();
      osc.stop(audioCtx.currentTime + 0.1);
    }

    function playCoin() {
      if (!audioCtx) return;
      const osc = audioCtx.createOscillator();
      const gain = audioCtx.createGain();
      osc.connect(gain);
      gain.connect(audioCtx.destination);
      osc.frequency.setValueAtTime(800, audioCtx.currentTime);
      osc.frequency.setValueAtTime(1000, audioCtx.currentTime + 0.05);
      osc.frequency.setValueAtTime(1200, audioCtx.currentTime + 0.1);
      gain.gain.setValueAtTime(0.1, audioCtx.currentTime);
      gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.15);
      osc.start();
      osc.stop(audioCtx.currentTime + 0.15);
    }

    function playHit() {
      if (!audioCtx) return;
      const osc = audioCtx.createOscillator();
      const gain = audioCtx.createGain();
      osc.type = 'sawtooth';
      osc.connect(gain);
      gain.connect(audioCtx.destination);
      osc.frequency.setValueAtTime(200, audioCtx.currentTime);
      osc.frequency.exponentialRampToValueAtTime(50, audioCtx.currentTime + 0.3);
      gain.gain.setValueAtTime(0.2, audioCtx.currentTime);
      gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.3);
      osc.start();
      osc.stop(audioCtx.currentTime + 0.3);
    }

    // Initialize game
    function initGame() {
      player.x = 100;
      player.y = canvas.height - 150;
      player.vx = 0;
      player.vy = 0;
      player.onGround = false;
      score = 0;
      greenCandles = [];
      redCandles = [];
      coins = [];
      particles = [];

      // Create initial green candles
      for (let i = 0; i < 8; i++) {
        spawnGreenCandle(i * 120 + 50);
      }
    }

    // Spawn green candle platform
    function spawnGreenCandle(x = canvas.width + 50) {
      const height = 60 + Math.random() * 80;
      greenCandles.push({
        x: x,
        y: canvas.height - height,
        width: 40,
        height: height,
        wickHeight: 15 + Math.random() * 20
      });
    }

    // Spawn red candle (falling)
    function spawnRedCandle() {
      const width = 30 + Math.random() * 20;
      redCandles.push({
        x: Math.random() * (canvas.width - width),
        y: -100,
        width: width,
        height: 50 + Math.random() * 50,
        vy: 3 + Math.random() * 2 + score / 500,
        wickHeight: 10 + Math.random() * 15,
        rotation: 0,
        rotationSpeed: (Math.random() - 0.5) * 0.1
      });
    }

    // Spawn coin
    function spawnCoin() {
      coins.push({
        x: Math.random() * (canvas.width - 30),
        y: -30,
        radius: 15,
        vy: 2 + Math.random() * 2,
        rotation: 0,
        rotationSpeed: 0.1
      });
    }

    // Create particles
    function createParticles(x, y, color, count = 10) {
      for (let i = 0; i < count; i++) {
        particles.push({
          x: x,
          y: y,
          vx: (Math.random() - 0.5) * 8,
          vy: (Math.random() - 0.5) * 8 - 3,
          size: 3 + Math.random() * 5,
          color: color,
          life: 1
        });
      }
    }

    // Draw candle
    function drawCandle(candle, isGreen) {
      const color = isGreen ? '#00ff88' : '#ff4444';
      const darkColor = isGreen ? '#00aa55' : '#aa2222';

      ctx.save();

      if (!isGreen && candle.rotation) {
        ctx.translate(candle.x + candle.width / 2, candle.y + candle.height / 2);
        ctx.rotate(candle.rotation);
        ctx.translate(-(candle.x + candle.width / 2), -(candle.y + candle.height / 2));
      }

      // Wick
      ctx.fillStyle = '#888';
      ctx.fillRect(
        candle.x + candle.width / 2 - 2,
        candle.y - candle.wickHeight,
        4,
        candle.wickHeight
      );

      // Body shadow
      ctx.fillStyle = darkColor;
      ctx.fillRect(candle.x + 3, candle.y + 3, candle.width, candle.height);

      // Body
      const gradient = ctx.createLinearGradient(candle.x, 0, candle.x + candle.width, 0);
      gradient.addColorStop(0, color);
      gradient.addColorStop(0.5, isGreen ? '#44ffaa' : '#ff6666');
      gradient.addColorStop(1, darkColor);
      ctx.fillStyle = gradient;
      ctx.fillRect(candle.x, candle.y, candle.width, candle.height);

      // Highlight
      ctx.fillStyle = isGreen ? 'rgba(255,255,255,0.3)' : 'rgba(255,255,255,0.2)';
      ctx.fillRect(candle.x + 5, candle.y + 5, 8, candle.height - 10);

      // Glow
      ctx.shadowColor = color;
      ctx.shadowBlur = 15;
      ctx.strokeStyle = color;
      ctx.lineWidth = 2;
      ctx.strokeRect(candle.x, candle.y, candle.width, candle.height);
      ctx.shadowBlur = 0;

      ctx.restore();
    }

    // Draw coin
    function drawCoin(coin) {
      ctx.save();
      ctx.translate(coin.x + coin.radius, coin.y + coin.radius);
      ctx.rotate(coin.rotation);

      // Coin body
      const gradient = ctx.createRadialGradient(0, 0, 0, 0, 0, coin.radius);
      gradient.addColorStop(0, '#ffdd00');
      gradient.addColorStop(0.7, '#ffaa00');
      gradient.addColorStop(1, '#cc8800');
      ctx.fillStyle = gradient;
      ctx.beginPath();
      ctx.arc(0, 0, coin.radius, 0, Math.PI * 2);
      ctx.fill();

      // Dollar sign
      ctx.fillStyle = '#886600';
      ctx.font = 'bold 16px Arial';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillText('$', 0, 0);

      // Glow
      ctx.shadowColor = '#ffdd00';
      ctx.shadowBlur = 10;
      ctx.strokeStyle = '#ffdd00';
      ctx.lineWidth = 2;
      ctx.stroke();

      ctx.restore();
    }

    // Draw player
    function drawPlayer() {
      ctx.save();
      ctx.translate(player.x + player.width / 2, player.y + player.height / 2);

      // Body (trader)
      const gradient = ctx.createLinearGradient(-15, -20, 15, 20);
      gradient.addColorStop(0, '#4488ff');
      gradient.addColorStop(1, '#2255aa');
      ctx.fillStyle = gradient;
      ctx.fillRect(-15, -10, 30, 35);

      // Head
      ctx.fillStyle = '#ffcc99';
      ctx.beginPath();
      ctx.arc(0, -18, 12, 0, Math.PI * 2);
      ctx.fill();

      // Eyes
      ctx.fillStyle = '#000';
      ctx.beginPath();
      ctx.arc(-4, -20, 2, 0, Math.PI * 2);
      ctx.arc(4, -20, 2, 0, Math.PI * 2);
      ctx.fill();

      // Smile/Frown based on velocity
      ctx.strokeStyle = '#000';
      ctx.lineWidth = 2;
      ctx.beginPath();
      if (player.vy < 0) {
        ctx.arc(0, -14, 5, 0.2, Math.PI - 0.2);
      } else {
        ctx.arc(0, -12, 5, Math.PI + 0.2, -0.2);
      }
      ctx.stroke();

      // Tie
      ctx.fillStyle = '#ff4444';
      ctx.beginPath();
      ctx.moveTo(0, -5);
      ctx.lineTo(-5, 5);
      ctx.lineTo(0, 20);
      ctx.lineTo(5, 5);
      ctx.closePath();
      ctx.fill();

      ctx.restore();
    }

    // Draw particles
    function drawParticles() {
      particles.forEach(p => {
        ctx.globalAlpha = p.life;
        ctx.fillStyle = p.color;
        ctx.fillRect(p.x - p.size / 2, p.y - p.size / 2, p.size, p.size);
      });
      ctx.globalAlpha = 1;
    }

    // Draw background
    function drawBackground() {
      // Grid lines
      ctx.strokeStyle = 'rgba(0, 255, 136, 0.1)';
      ctx.lineWidth = 1;

      for (let x = 0; x < canvas.width; x += 50) {
        ctx.beginPath();
        ctx.moveTo(x, 0);
        ctx.lineTo(x, canvas.height);
        ctx.stroke();
      }

      for (let y = 0; y < canvas.height; y += 50) {
        ctx.beginPath();
        ctx.moveTo(0, y);
        ctx.lineTo(canvas.width, y);
        ctx.stroke();
      }

      // Price line (decorative)
      ctx.strokeStyle = 'rgba(0, 255, 136, 0.3)';
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(0, canvas.height * 0.3);
      for (let x = 0; x < canvas.width; x += 20) {
        const y = canvas.height * 0.3 + Math.sin(x * 0.02 + Date.now() * 0.001) * 30;
        ctx.lineTo(x, y);
      }
      ctx.stroke();
    }

    // Update game
    function update() {
      if (!gameRunning) return;

      // Player input
      if (keys['ArrowLeft'] || keys['KeyA']) {
        player.vx = -player.speed;
      } else if (keys['ArrowRight'] || keys['KeyD']) {
        player.vx = player.speed;
      } else {
        player.vx *= 0.8;
      }

      if ((keys['Space'] || keys['KeyW'] || keys['ArrowUp']) && player.onGround) {
        player.vy = player.jumpForce;
        player.onGround = false;
        playJump();
      }

      // Apply physics
      player.vy += player.gravity;
      player.x += player.vx;
      player.y += player.vy;

      // Screen bounds
      if (player.x < 0) player.x = 0;
      if (player.x + player.width > canvas.width) player.x = canvas.width - player.width;

      // Ground collision
      player.onGround = false;

      // Green candle collision
      greenCandles.forEach(candle => {
        if (
          player.x + player.width > candle.x &&
          player.x < candle.x + candle.width &&
          player.y + player.height > candle.y &&
          player.y + player.height < candle.y + 20 &&
          player.vy > 0
        ) {
          player.y = candle.y - player.height;
          player.vy = 0;
          player.onGround = true;
        }
      });

      // Floor
      if (player.y + player.height > canvas.height - 10) {
        player.y = canvas.height - 10 - player.height;
        player.vy = 0;
        player.onGround = true;
      }

      // Update green candles (scroll)
      const scrollSpeed = 2 + score / 300;
      greenCandles.forEach(candle => {
        candle.x -= scrollSpeed;
      });
      greenCandles = greenCandles.filter(c => c.x + c.width > -50);

      // Spawn new green candles
      if (greenCandles.length < 8) {
        const lastCandle = greenCandles[greenCandles.length - 1];
        const gap = 80 + Math.random() * 60;
        spawnGreenCandle(lastCandle ? lastCandle.x + lastCandle.width + gap : canvas.width);
      }

      // Update red candles
      redCandles.forEach(candle => {
        candle.y += candle.vy;
        candle.rotation += candle.rotationSpeed;

        // Check collision with player
        if (
          player.x + player.width > candle.x + 5 &&
          player.x < candle.x + candle.width - 5 &&
          player.y + player.height > candle.y + 5 &&
          player.y < candle.y + candle.height - 5
        ) {
          gameOver();
        }
      });
      redCandles = redCandles.filter(c => c.y < canvas.height + 100);

      // Spawn red candles
      if (Math.random() < 0.02 + score / 5000) {
        spawnRedCandle();
      }

      // Update coins
      coins.forEach(coin => {
        coin.y += coin.vy;
        coin.rotation += coin.rotationSpeed;

        // Check collision with player
        const dx = (player.x + player.width / 2) - (coin.x + coin.radius);
        const dy = (player.y + player.height / 2) - (coin.y + coin.radius);
        if (Math.sqrt(dx * dx + dy * dy) < coin.radius + 20) {
          score += 50;
          createParticles(coin.x + coin.radius, coin.y + coin.radius, '#ffdd00', 15);
          playCoin();
          coin.collected = true;
        }
      });
      coins = coins.filter(c => !c.collected && c.y < canvas.height + 50);

      // Spawn coins
      if (Math.random() < 0.01) {
        spawnCoin();
      }

      // Update particles
      particles.forEach(p => {
        p.x += p.vx;
        p.y += p.vy;
        p.vy += 0.2;
        p.life -= 0.02;
      });
      particles = particles.filter(p => p.life > 0);

      // Update score
      score++;
      document.getElementById('score').textContent = score;

      // Fall off screen
      if (player.y > canvas.height + 100) {
        gameOver();
      }
    }

    // Draw game
    function draw() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);

      drawBackground();

      // Draw green candles
      greenCandles.forEach(c => drawCandle(c, true));

      // Draw red candles
      redCandles.forEach(c => drawCandle(c, false));

      // Draw coins
      coins.forEach(drawCoin);

      // Draw player
      if (gameRunning) {
        drawPlayer();
      }

      // Draw particles
      drawParticles();

      // Floor
      ctx.fillStyle = '#1a2a20';
      ctx.fillRect(0, canvas.height - 10, canvas.width, 10);
      ctx.strokeStyle = '#00ff88';
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(0, canvas.height - 10);
      ctx.lineTo(canvas.width, canvas.height - 10);
      ctx.stroke();
    }

    // Game loop
    function gameLoop() {
      update();
      draw();
      requestAnimationFrame(gameLoop);
    }

    // Start game
    function startGame() {
      initAudio();
      document.getElementById('start-screen').style.display = 'none';
      document.getElementById('game-over').style.display = 'none';
      initGame();
      gameRunning = true;
    }

    // Game over
    function gameOver() {
      gameRunning = false;
      playHit();
      createParticles(player.x + player.width / 2, player.y + player.height / 2, '#ff4444', 30);

      if (score > highScore) {
        highScore = score;
        localStorage.setItem('candleJumperHigh', highScore.toString());
        document.getElementById('high-score').textContent = highScore;
      }

      document.getElementById('final-score').textContent = score;
      document.getElementById('final-high').textContent = highScore;
      document.getElementById('game-over').style.display = 'flex';
    }

    // Input handlers
    document.addEventListener('keydown', (e) => {
      keys[e.code] = true;
      if (['Space', 'ArrowUp', 'ArrowDown'].includes(e.code)) {
        e.preventDefault();
      }
    });

    document.addEventListener('keyup', (e) => {
      keys[e.code] = false;
    });

    // Mobile controls
    const leftBtn = document.getElementById('left-btn');
    const rightBtn = document.getElementById('right-btn');
    const jumpBtn = document.getElementById('jump-btn');

    function addMobileControl(btn, key) {
      btn.addEventListener('touchstart', (e) => {
        e.preventDefault();
        initAudio();
        keys[key] = true;
      });
      btn.addEventListener('touchend', (e) => {
        e.preventDefault();
        keys[key] = false;
      });
      btn.addEventListener('mousedown', () => { keys[key] = true; });
      btn.addEventListener('mouseup', () => { keys[key] = false; });
      btn.addEventListener('mouseleave', () => { keys[key] = false; });
    }

    addMobileControl(leftBtn, 'ArrowLeft');
    addMobileControl(rightBtn, 'ArrowRight');
    addMobileControl(jumpBtn, 'Space');

    // Start loop
    gameLoop();
  </script>
<script src="/apps/sloppy-header/sloppy-bar.js"></script>
<script src="/vibelib-extended.js"></script>
<script>
  // Compatibility Patch for Legacy Apps
  window.addEventListener("load", () => {
    if (window.SloppyKarma && window.VibeLib.Economy) {
      // Redirect old calls to new engine
      window.SloppyKarma.track = window.VibeLib.Economy.track;
    }
  });
</script>
</body>
</html>
