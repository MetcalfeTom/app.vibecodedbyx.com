<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
  <title>Butter Physics - Sliding Cubes</title>
  <link rel="icon" href="https://emojicdn.elk.sh/ðŸ§ˆ">
  <meta name="description" content="Satisfying butter physics simulation with slippery sliding cubes!">
  <meta property="og:title" content="Butter Physics - Sliding Cubes">
  <meta property="og:description" content="Satisfying butter physics simulation with slippery sliding cubes!">
  <meta property="og:url" content="https://app.sloppy.live/butter-physics">
  <meta property="og:image" content="https://emojicdn.elk.sh/ðŸ§ˆ?style=twitter">
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link href="https://fonts.googleapis.com/css2?family=Nunito:wght@400;700;900&display=swap" rel="stylesheet">
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      background: linear-gradient(180deg, #1a1a2e 0%, #16213e 100%);
      min-height: 100vh;
      display: flex;
      flex-direction: column;
      align-items: center;
      font-family: 'Nunito', sans-serif;
      overflow: hidden;
      touch-action: none;
    }

    .header {
      padding: 15px;
      text-align: center;
      z-index: 10;
    }

    h1 {
      font-size: 32px;
      font-weight: 900;
      color: #ffd700;
      text-shadow:
        0 0 10px #ffd700,
        0 0 20px #ffaa00,
        0 0 40px #ff880044;
      letter-spacing: 2px;
    }

    .subtitle {
      color: #ffeeaa;
      font-size: 14px;
      opacity: 0.8;
      margin-top: 5px;
    }

    #canvas {
      display: block;
      cursor: crosshair;
      border-radius: 10px;
      box-shadow:
        0 0 30px rgba(255, 215, 0, 0.2),
        inset 0 0 100px rgba(255, 215, 0, 0.05);
    }

    .controls {
      position: fixed;
      bottom: 20px;
      display: flex;
      gap: 10px;
      flex-wrap: wrap;
      justify-content: center;
      padding: 0 20px;
    }

    .btn {
      padding: 10px 20px;
      font-family: 'Nunito', sans-serif;
      font-size: 14px;
      font-weight: 700;
      background: rgba(255, 215, 0, 0.1);
      border: 2px solid #ffd700;
      color: #ffd700;
      border-radius: 25px;
      cursor: pointer;
      transition: all 0.2s;
    }

    .btn:hover {
      background: #ffd700;
      color: #1a1a2e;
      box-shadow: 0 0 20px #ffd700;
    }

    .btn.active {
      background: #ffd700;
      color: #1a1a2e;
    }

    .stats {
      position: fixed;
      top: 80px;
      right: 20px;
      color: #ffeeaa;
      font-size: 12px;
      text-align: right;
      opacity: 0.7;
    }

    .friction-slider {
      position: fixed;
      top: 80px;
      left: 20px;
      color: #ffeeaa;
      font-size: 12px;
    }

    .friction-slider input {
      width: 100px;
      margin-top: 5px;
      accent-color: #ffd700;
    }

    .hint {
      position: fixed;
      bottom: 70px;
      color: #ffeeaa;
      font-size: 12px;
      opacity: 0.6;
      text-align: center;
    }

    .backlink {
      position: fixed;
      bottom: 5px;
      color: #444;
      font-size: 10px;
      text-decoration: none;
    }

    .backlink:hover { color: #ffd700; }

    @media (max-width: 600px) {
      h1 { font-size: 24px; }
      .stats, .friction-slider { font-size: 10px; }
      .btn { padding: 8px 15px; font-size: 12px; }
    }
  </style>
</head>
<body>
  <div class="header">
    <h1>ðŸ§ˆ BUTTER PHYSICS ðŸ§ˆ</h1>
    <div class="subtitle">Click to spawn â€¢ Drag to fling â€¢ Watch them slide!</div>
  </div>

  <canvas id="canvas"></canvas>

  <div class="friction-slider">
    <label>BUTTERINESS</label><br>
    <input type="range" id="frictionSlider" min="0" max="100" value="95">
    <span id="frictionLabel">95%</span>
  </div>

  <div class="stats">
    <div>Cubes: <span id="cubeCount">0</span></div>
    <div>Collisions: <span id="collisionCount">0</span></div>
  </div>

  <div class="hint">Tilt your device or use arrow keys!</div>

  <div class="controls">
    <button class="btn" id="spawnBtn">+ SPAWN</button>
    <button class="btn" id="shakeBtn">ðŸŒŠ SHAKE</button>
    <button class="btn" id="clearBtn">âœ• CLEAR</button>
    <button class="btn" id="gravityBtn">ðŸ”„ GRAVITY</button>
  </div>

  <a href="https://sloppy.live" class="backlink">sloppy.live</a>

  <script>
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');

    // Resize canvas
    function resize() {
      canvas.width = Math.min(window.innerWidth - 20, 800);
      canvas.height = Math.min(window.innerHeight - 200, 600);
    }
    resize();
    window.addEventListener('resize', resize);

    // Physics settings
    let friction = 0.95; // Buttery smooth!
    let gravity = { x: 0, y: 0.3 };
    let gravityMode = 'down';
    let collisionCount = 0;

    // Cubes
    const cubes = [];
    const butterColors = [
      '#ffd700', '#ffcc00', '#ffaa00', '#fff176',
      '#ffe082', '#ffca28', '#ffc107', '#ffb300'
    ];

    class Cube {
      constructor(x, y, size = null) {
        this.x = x;
        this.y = y;
        this.size = size || 30 + Math.random() * 30;
        this.vx = (Math.random() - 0.5) * 5;
        this.vy = (Math.random() - 0.5) * 5;
        this.rotation = Math.random() * Math.PI * 2;
        this.angularVel = (Math.random() - 0.5) * 0.1;
        this.color = butterColors[Math.floor(Math.random() * butterColors.length)];
        this.mass = this.size * this.size;
        this.trail = [];
      }

      update() {
        // Apply gravity
        this.vx += gravity.x;
        this.vy += gravity.y;

        // Apply friction (butter slide!)
        this.vx *= friction;
        this.vy *= friction;
        this.angularVel *= friction;

        // Update position
        this.x += this.vx;
        this.y += this.vy;
        this.rotation += this.angularVel;

        // Trail
        if (Math.abs(this.vx) > 0.5 || Math.abs(this.vy) > 0.5) {
          this.trail.push({ x: this.x, y: this.y, alpha: 0.5 });
          if (this.trail.length > 10) this.trail.shift();
        }
        this.trail.forEach(t => t.alpha *= 0.9);
        this.trail = this.trail.filter(t => t.alpha > 0.05);

        // Bounce off walls
        const halfSize = this.size / 2;
        const bounceFactor = 0.6;

        if (this.x - halfSize < 0) {
          this.x = halfSize;
          this.vx = -this.vx * bounceFactor;
          this.angularVel += this.vy * 0.01;
        }
        if (this.x + halfSize > canvas.width) {
          this.x = canvas.width - halfSize;
          this.vx = -this.vx * bounceFactor;
          this.angularVel -= this.vy * 0.01;
        }
        if (this.y - halfSize < 0) {
          this.y = halfSize;
          this.vy = -this.vy * bounceFactor;
          this.angularVel += this.vx * 0.01;
        }
        if (this.y + halfSize > canvas.height) {
          this.y = canvas.height - halfSize;
          this.vy = -this.vy * bounceFactor;
          this.angularVel -= this.vx * 0.01;

          // Extra slide on ground
          this.vx *= 0.99;
        }
      }

      draw() {
        // Draw trail
        this.trail.forEach(t => {
          ctx.fillStyle = `rgba(255, 215, 0, ${t.alpha * 0.3})`;
          ctx.beginPath();
          ctx.arc(t.x, t.y, this.size / 4, 0, Math.PI * 2);
          ctx.fill();
        });

        ctx.save();
        ctx.translate(this.x, this.y);
        ctx.rotate(this.rotation);

        // Shadow
        ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
        ctx.fillRect(-this.size/2 + 5, -this.size/2 + 5, this.size, this.size);

        // Main cube
        const gradient = ctx.createLinearGradient(
          -this.size/2, -this.size/2,
          this.size/2, this.size/2
        );
        gradient.addColorStop(0, this.color);
        gradient.addColorStop(0.5, '#fffde7');
        gradient.addColorStop(1, this.color);

        ctx.fillStyle = gradient;
        ctx.fillRect(-this.size/2, -this.size/2, this.size, this.size);

        // Butter shine
        ctx.fillStyle = 'rgba(255, 255, 255, 0.4)';
        ctx.fillRect(-this.size/2 + 3, -this.size/2 + 3, this.size/3, this.size/3);

        // Border
        ctx.strokeStyle = 'rgba(255, 170, 0, 0.8)';
        ctx.lineWidth = 2;
        ctx.strokeRect(-this.size/2, -this.size/2, this.size, this.size);

        ctx.restore();
      }

      collidesWith(other) {
        const dx = other.x - this.x;
        const dy = other.y - this.y;
        const minDist = (this.size + other.size) / 2;
        return Math.abs(dx) < minDist && Math.abs(dy) < minDist;
      }

      resolveCollision(other) {
        const dx = other.x - this.x;
        const dy = other.y - this.y;

        // Overlap resolution
        const overlapX = (this.size + other.size) / 2 - Math.abs(dx);
        const overlapY = (this.size + other.size) / 2 - Math.abs(dy);

        if (overlapX > 0 && overlapY > 0) {
          if (overlapX < overlapY) {
            const push = overlapX / 2;
            if (dx > 0) {
              this.x -= push;
              other.x += push;
            } else {
              this.x += push;
              other.x -= push;
            }
          } else {
            const push = overlapY / 2;
            if (dy > 0) {
              this.y -= push;
              other.y += push;
            } else {
              this.y += push;
              other.y -= push;
            }
          }

          // Velocity exchange (elastic-ish)
          const totalMass = this.mass + other.mass;
          const dvx = this.vx - other.vx;
          const dvy = this.vy - other.vy;

          const newVx1 = this.vx - (2 * other.mass / totalMass) * dvx * 0.8;
          const newVy1 = this.vy - (2 * other.mass / totalMass) * dvy * 0.8;
          const newVx2 = other.vx + (2 * this.mass / totalMass) * dvx * 0.8;
          const newVy2 = other.vy + (2 * this.mass / totalMass) * dvy * 0.8;

          this.vx = newVx1;
          this.vy = newVy1;
          other.vx = newVx2;
          other.vy = newVy2;

          // Angular momentum transfer
          this.angularVel += (Math.random() - 0.5) * 0.2;
          other.angularVel += (Math.random() - 0.5) * 0.2;

          collisionCount++;
        }
      }
    }

    // Spawn initial cubes
    for (let i = 0; i < 5; i++) {
      cubes.push(new Cube(
        100 + Math.random() * (canvas.width - 200),
        100 + Math.random() * (canvas.height - 200)
      ));
    }

    // Mouse/touch interaction
    let isDragging = false;
    let dragStart = { x: 0, y: 0 };
    let dragEnd = { x: 0, y: 0 };

    function getEventPos(e) {
      const rect = canvas.getBoundingClientRect();
      const clientX = e.touches ? e.touches[0].clientX : e.clientX;
      const clientY = e.touches ? e.touches[0].clientY : e.clientY;
      return {
        x: (clientX - rect.left) * (canvas.width / rect.width),
        y: (clientY - rect.top) * (canvas.height / rect.height)
      };
    }

    canvas.addEventListener('mousedown', startDrag);
    canvas.addEventListener('touchstart', startDrag);

    function startDrag(e) {
      e.preventDefault();
      isDragging = true;
      const pos = getEventPos(e);
      dragStart = pos;
      dragEnd = pos;
    }

    canvas.addEventListener('mousemove', moveDrag);
    canvas.addEventListener('touchmove', moveDrag);

    function moveDrag(e) {
      if (!isDragging) return;
      e.preventDefault();
      dragEnd = getEventPos(e);
    }

    canvas.addEventListener('mouseup', endDrag);
    canvas.addEventListener('touchend', endDrag);

    function endDrag(e) {
      if (!isDragging) return;
      isDragging = false;

      const dx = dragEnd.x - dragStart.x;
      const dy = dragEnd.y - dragStart.y;
      const dist = Math.sqrt(dx * dx + dy * dy);

      if (dist < 10) {
        // Click - spawn cube
        const cube = new Cube(dragStart.x, dragStart.y);
        cubes.push(cube);
      } else {
        // Drag - fling cube
        const cube = new Cube(dragStart.x, dragStart.y);
        cube.vx = dx * 0.15;
        cube.vy = dy * 0.15;
        cubes.push(cube);
      }
    }

    // Keyboard controls
    document.addEventListener('keydown', (e) => {
      const force = 2;
      if (e.key === 'ArrowLeft') cubes.forEach(c => c.vx -= force);
      if (e.key === 'ArrowRight') cubes.forEach(c => c.vx += force);
      if (e.key === 'ArrowUp') cubes.forEach(c => c.vy -= force);
      if (e.key === 'ArrowDown') cubes.forEach(c => c.vy += force);
    });

    // Device tilt
    if (window.DeviceOrientationEvent) {
      window.addEventListener('deviceorientation', (e) => {
        if (e.gamma !== null && e.beta !== null) {
          gravity.x = e.gamma / 30;
          gravity.y = e.beta / 30;
        }
      });
    }

    // Controls
    document.getElementById('spawnBtn').addEventListener('click', () => {
      for (let i = 0; i < 5; i++) {
        cubes.push(new Cube(
          Math.random() * canvas.width,
          Math.random() * canvas.height * 0.3
        ));
      }
    });

    document.getElementById('shakeBtn').addEventListener('click', () => {
      cubes.forEach(c => {
        c.vx += (Math.random() - 0.5) * 20;
        c.vy += (Math.random() - 0.5) * 20;
        c.angularVel += (Math.random() - 0.5) * 0.5;
      });
    });

    document.getElementById('clearBtn').addEventListener('click', () => {
      cubes.length = 0;
      collisionCount = 0;
    });

    document.getElementById('gravityBtn').addEventListener('click', () => {
      const modes = ['down', 'up', 'left', 'right', 'none'];
      const currentIndex = modes.indexOf(gravityMode);
      gravityMode = modes[(currentIndex + 1) % modes.length];

      switch (gravityMode) {
        case 'down': gravity = { x: 0, y: 0.3 }; break;
        case 'up': gravity = { x: 0, y: -0.3 }; break;
        case 'left': gravity = { x: -0.3, y: 0 }; break;
        case 'right': gravity = { x: 0.3, y: 0 }; break;
        case 'none': gravity = { x: 0, y: 0 }; break;
      }
    });

    // Friction slider
    const frictionSlider = document.getElementById('frictionSlider');
    const frictionLabel = document.getElementById('frictionLabel');

    frictionSlider.addEventListener('input', () => {
      const value = parseInt(frictionSlider.value);
      friction = 0.9 + (value / 1000); // 0.9 to 1.0
      frictionLabel.textContent = value + '%';
    });

    // Animation loop
    function animate() {
      // Clear with slight trail
      ctx.fillStyle = 'rgba(26, 26, 46, 0.3)';
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      // Draw buttery floor shine
      const floorGradient = ctx.createLinearGradient(0, canvas.height - 50, 0, canvas.height);
      floorGradient.addColorStop(0, 'transparent');
      floorGradient.addColorStop(1, 'rgba(255, 215, 0, 0.1)');
      ctx.fillStyle = floorGradient;
      ctx.fillRect(0, canvas.height - 50, canvas.width, 50);

      // Update and check collisions
      for (let i = 0; i < cubes.length; i++) {
        cubes[i].update();

        for (let j = i + 1; j < cubes.length; j++) {
          if (cubes[i].collidesWith(cubes[j])) {
            cubes[i].resolveCollision(cubes[j]);
          }
        }
      }

      // Draw cubes (sorted by y for pseudo-3D)
      cubes.sort((a, b) => a.y - b.y);
      cubes.forEach(cube => cube.draw());

      // Draw drag line
      if (isDragging) {
        ctx.strokeStyle = '#ffd700';
        ctx.lineWidth = 3;
        ctx.setLineDash([10, 5]);
        ctx.beginPath();
        ctx.moveTo(dragStart.x, dragStart.y);
        ctx.lineTo(dragEnd.x, dragEnd.y);
        ctx.stroke();
        ctx.setLineDash([]);

        // Arrow head
        const angle = Math.atan2(dragEnd.y - dragStart.y, dragEnd.x - dragStart.x);
        ctx.beginPath();
        ctx.moveTo(dragEnd.x, dragEnd.y);
        ctx.lineTo(
          dragEnd.x - 15 * Math.cos(angle - 0.3),
          dragEnd.y - 15 * Math.sin(angle - 0.3)
        );
        ctx.lineTo(
          dragEnd.x - 15 * Math.cos(angle + 0.3),
          dragEnd.y - 15 * Math.sin(angle + 0.3)
        );
        ctx.closePath();
        ctx.fillStyle = '#ffd700';
        ctx.fill();
      }

      // Update stats
      document.getElementById('cubeCount').textContent = cubes.length;
      document.getElementById('collisionCount').textContent = collisionCount;

      // Limit cubes
      if (cubes.length > 50) {
        cubes.shift();
      }

      requestAnimationFrame(animate);
    }

    animate();
  </script>
<script src="/apps/sloppy-header/sloppy-bar.js"></script>
<script src="/vibelib-extended.js"></script>
<script>
  // Compatibility Patch for Legacy Apps
  window.addEventListener("load", () => {
    if (window.SloppyKarma && window.VibeLib.Economy) {
      // Redirect old calls to new engine
      window.SloppyKarma.track = window.VibeLib.Economy.track;
    }
  });
</script>
</body>
</html>
