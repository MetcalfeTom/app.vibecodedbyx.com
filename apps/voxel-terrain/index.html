<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Voxel Terrain</title>
  <link rel="icon" href="https://emojicdn.elk.sh/üèîÔ∏è">
  <meta property="og:title" content="Voxel Terrain">
  <meta property="og:description" content="Explore procedural voxel hills in first-person">
  <meta property="og:url" content="https://sloppy.live/voxel-terrain">
  <meta property="og:image" content="https://emojicdn.elk.sh/üèîÔ∏è?style=apple&size=512">
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      overflow: hidden;
      background: #1a1a2e;
      font-family: 'Segoe UI', system-ui, sans-serif;
    }

    canvas {
      display: block;
    }

    #blocker {
      position: fixed;
      inset: 0;
      background: rgba(0, 0, 0, 0.85);
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      z-index: 100;
      cursor: pointer;
    }

    #blocker.hidden {
      display: none;
    }

    #blocker h1 {
      color: #4ade80;
      font-size: 2.5rem;
      margin-bottom: 1rem;
      text-shadow: 0 0 20px rgba(74, 222, 128, 0.5);
    }

    #blocker p {
      color: #a1a1aa;
      font-size: 1rem;
      margin-bottom: 0.5rem;
    }

    #blocker .controls {
      margin-top: 2rem;
      color: #71717a;
      font-size: 0.85rem;
      text-align: center;
      line-height: 1.8;
    }

    #blocker .key {
      display: inline-block;
      background: #27272a;
      border: 1px solid #3f3f46;
      padding: 0.2rem 0.5rem;
      border-radius: 4px;
      color: #4ade80;
      margin: 0 0.2rem;
    }

    #hud {
      position: fixed;
      top: 1rem;
      left: 1rem;
      color: #4ade80;
      font-size: 0.8rem;
      font-family: monospace;
      z-index: 50;
      text-shadow: 0 0 5px rgba(0, 0, 0, 0.8);
      pointer-events: none;
    }

    #crosshair {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      width: 20px;
      height: 20px;
      z-index: 50;
      pointer-events: none;
    }

    #crosshair::before,
    #crosshair::after {
      content: '';
      position: absolute;
      background: rgba(255, 255, 255, 0.7);
    }

    #crosshair::before {
      width: 2px;
      height: 100%;
      left: 50%;
      transform: translateX(-50%);
    }

    #crosshair::after {
      width: 100%;
      height: 2px;
      top: 50%;
      transform: translateY(-50%);
    }

    .link {
      position: fixed;
      bottom: 0.5rem;
      left: 50%;
      transform: translateX(-50%);
      color: #555;
      font-size: 0.7rem;
      z-index: 50;
      pointer-events: none;
    }
  </style>
</head>
<body>
  <div id="blocker">
    <h1>üèîÔ∏è Voxel Terrain</h1>
    <p>Click to explore the procedural world</p>
    <div class="controls">
      <span class="key">W</span><span class="key">A</span><span class="key">S</span><span class="key">D</span> Move<br>
      <span class="key">SPACE</span> Jump &nbsp; <span class="key">SHIFT</span> Run<br>
      <span class="key">MOUSE</span> Look around &nbsp; <span class="key">ESC</span> Pause
    </div>
  </div>

  <div id="hud">
    <div>Pos: <span id="posX">0</span>, <span id="posY">0</span>, <span id="posZ">0</span></div>
    <div>Voxels: <span id="voxelCount">0</span></div>
  </div>

  <div id="crosshair"></div>

  <div class="link">sloppy.live</div>

  <script type="importmap">
    {
      "imports": {
        "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
        "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
      }
    }
  </script>

  <script type="module">
    import * as THREE from 'three';
    import { PointerLockControls } from 'three/addons/controls/PointerLockControls.js';

    // Scene setup
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x87ceeb);
    scene.fog = new THREE.Fog(0x87ceeb, 120, 350);  // Extended fog for 192x192 world

    // Camera - extended far plane for bigger world
    const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.set(96, 50, 96);  // Start in center of 192x192 world

    // Renderer
    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    renderer.shadowMap.enabled = true;
    renderer.shadowMap.type = THREE.PCFSoftShadowMap;
    document.body.appendChild(renderer.domElement);

    // Lighting
    const ambientLight = new THREE.AmbientLight(0x6688aa, 0.5);
    scene.add(ambientLight);

    const sunLight = new THREE.DirectionalLight(0xffffee, 1.2);
    sunLight.position.set(150, 200, 100);
    sunLight.castShadow = true;
    sunLight.shadow.mapSize.width = 2048;
    sunLight.shadow.mapSize.height = 2048;
    sunLight.shadow.camera.near = 10;
    sunLight.shadow.camera.far = 600;
    sunLight.shadow.camera.left = -200;
    sunLight.shadow.camera.right = 200;
    sunLight.shadow.camera.top = 200;
    sunLight.shadow.camera.bottom = -200;
    scene.add(sunLight);

    // Improved noise function for more varied terrain
    function noise2D(x, z) {
      // Multiple octaves for interesting terrain
      let value = 0;
      let amplitude = 1;
      let frequency = 0.015;  // Lower frequency = bigger features
      let maxValue = 0;

      // Add seed offsets for variety
      const seed1 = 12.9898;
      const seed2 = 78.233;

      for (let i = 0; i < 5; i++) {
        // Better pseudo-random noise using multiple sine waves
        const nx = x * frequency;
        const nz = z * frequency;

        value += amplitude * (
          Math.sin(nx * seed1 + nz * seed2 + i * 43.5453) * 0.5 +
          Math.sin(nx * 1.7 + i * 2.1) * Math.cos(nz * 1.3 + i * 1.7) * 0.3 +
          Math.sin((nx + nz) * 0.8 + i * 5.7) * 0.2
        );
        maxValue += amplitude;
        amplitude *= 0.5;
        frequency *= 2.2;
      }

      // Normalize to 0-1 range
      const normalized = (value / maxValue + 1) / 2;

      // Add some variation with secondary wave
      const variation = Math.sin(x * 0.05) * Math.cos(z * 0.05) * 0.15;

      return Math.max(0.05, Math.min(1, normalized + variation));
    }

    // Voxel colors for realistic soil stratification
    const colors = {
      // Surface biomes
      water: new THREE.Color(0x3b82f6),
      sand: new THREE.Color(0xfcd34d),
      grass: new THREE.Color(0x4ade80),
      snow: new THREE.Color(0xf4f4f5),
      // Subsurface layers
      dirt: new THREE.Color(0x8b5a2b),       // Rich brown dirt
      dirtDark: new THREE.Color(0x5c3d1e),   // Darker dirt layer
      clay: new THREE.Color(0xa0522d),        // Clay/subsoil
      gravel: new THREE.Color(0x808080),      // Gravel transition
      stone: new THREE.Color(0x696969),       // Standard stone
      stoneDark: new THREE.Color(0x505050),   // Deeper stone
      bedrock: new THREE.Color(0x2d2d2d)      // Bedrock at bottom
    };

    // Get surface biome color based on elevation
    function getSurfaceBiome(surfaceHeight, maxHeight) {
      const ratio = surfaceHeight / maxHeight;
      if (ratio < 0.15) return colors.water;
      if (ratio < 0.22) return colors.sand;
      if (ratio < 0.75) return colors.grass;
      return colors.snow;
    }

    // Realistic soil stratification based on depth from surface
    function getVoxelColor(y, surfaceHeight, maxHeight) {
      const depthFromSurface = surfaceHeight - y - 1;
      const absoluteY = y;

      // Bedrock layer at very bottom (y = 0-2)
      if (absoluteY <= 2) {
        return colors.bedrock;
      }

      // Surface layer (top block)
      if (depthFromSurface === 0) {
        return getSurfaceBiome(surfaceHeight, maxHeight);
      }

      // Topsoil - rich dirt (1-2 blocks deep)
      if (depthFromSurface <= 2) {
        return colors.dirt;
      }

      // Subsoil - darker dirt (3-4 blocks deep)
      if (depthFromSurface <= 4) {
        return colors.dirtDark;
      }

      // Clay/transition layer (5-6 blocks deep)
      if (depthFromSurface <= 6) {
        return colors.clay;
      }

      // Gravel transition (7-8 blocks deep)
      if (depthFromSurface <= 8) {
        return colors.gravel;
      }

      // Upper stone layer
      if (absoluteY > 8) {
        return colors.stone;
      }

      // Deep stone layer (darker)
      if (absoluteY > 3) {
        return colors.stoneDark;
      }

      // Bedrock transition
      return colors.bedrock;
    }

    // Generate terrain - EVEN BIGGER WORLD!
    const WORLD_SIZE = 192;  // 3x original size
    const MAX_HEIGHT = 40;   // Taller mountains
    const VOXEL_SIZE = 1;

    let voxelCount = 0;
    const terrainGroup = new THREE.Group();

    // Use instanced mesh for performance
    const voxelGeometry = new THREE.BoxGeometry(VOXEL_SIZE, VOXEL_SIZE, VOXEL_SIZE);
    const voxelMaterial = new THREE.MeshLambertMaterial({ vertexColors: true });

    // Pre-calculate terrain heights - ensure no empty chunks
    const heightMap = [];
    for (let x = 0; x < WORLD_SIZE; x++) {
      heightMap[x] = [];
      for (let z = 0; z < WORLD_SIZE; z++) {
        const n = noise2D(x, z);
        // Minimum height of 3 to avoid flat/empty areas
        heightMap[x][z] = Math.max(3, Math.floor(n * MAX_HEIGHT) + 1);
      }
    }

    console.log('Terrain generated:', WORLD_SIZE, 'x', WORLD_SIZE, 'max height:', MAX_HEIGHT);

    // Create merged geometry for better performance
    function generateTerrain() {
      const positions = [];
      const normals = [];
      const colorsArray = [];
      const indices = [];

      let vertexOffset = 0;

      for (let x = 0; x < WORLD_SIZE; x++) {
        for (let z = 0; z < WORLD_SIZE; z++) {
          const height = heightMap[x][z];

          // Only render visible voxel faces - WATERTIGHT mesh generation
          for (let y = 0; y < height; y++) {
            // Realistic soil stratification - each layer gets proper color
            const color = getVoxelColor(y, height, MAX_HEIGHT);

            // Helper: check if a neighboring cell at (nx, y, nz) is solid
            // Returns true if solid, false if air (out of bounds = air for edges)
            const isSolid = (nx, ny, nz) => {
              if (nx < 0 || nx >= WORLD_SIZE || nz < 0 || nz >= WORLD_SIZE) return false;
              if (ny < 0) return false;
              return ny < heightMap[nx][nz];
            };

            // A face is visible if the adjacent cell is NOT solid (is air)
            const showTop = !isSolid(x, y + 1, z);      // Above this voxel
            const showBottom = !isSolid(x, y - 1, z);   // Below this voxel
            const showFront = !isSolid(x, y, z + 1);    // +Z direction
            const showBack = !isSolid(x, y, z - 1);     // -Z direction
            const showRight = !isSolid(x + 1, y, z);    // +X direction
            const showLeft = !isSolid(x - 1, y, z);     // -X direction

            // Skip if completely enclosed (no visible faces)
            if (!showTop && !showBottom && !showFront && !showBack && !showRight && !showLeft) continue;

            // Add visible faces
            const faces = [];
            if (showTop) faces.push({ dir: [0, 1, 0], corners: [[0,1,0],[1,1,0],[1,1,1],[0,1,1]] });
            if (showBottom) faces.push({ dir: [0,-1,0], corners: [[0,0,1],[1,0,1],[1,0,0],[0,0,0]] });
            if (showFront) faces.push({ dir: [0,0,1], corners: [[0,0,1],[0,1,1],[1,1,1],[1,0,1]] });
            if (showBack) faces.push({ dir: [0,0,-1], corners: [[1,0,0],[1,1,0],[0,1,0],[0,0,0]] });
            if (showRight) faces.push({ dir: [1,0,0], corners: [[1,0,1],[1,1,1],[1,1,0],[1,0,0]] });
            if (showLeft) faces.push({ dir: [-1,0,0], corners: [[0,0,0],[0,1,0],[0,1,1],[0,0,1]] });

            for (const face of faces) {
              const ndx = vertexOffset;

              for (const corner of face.corners) {
                positions.push(
                  (x + corner[0]) * VOXEL_SIZE,
                  (y + corner[1]) * VOXEL_SIZE,
                  (z + corner[2]) * VOXEL_SIZE
                );
                normals.push(...face.dir);
                colorsArray.push(color.r, color.g, color.b);
              }

              indices.push(ndx, ndx + 1, ndx + 2, ndx, ndx + 2, ndx + 3);
              vertexOffset += 4;
            }

            voxelCount++;
          }
        }
      }

      const geometry = new THREE.BufferGeometry();
      geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
      geometry.setAttribute('normal', new THREE.Float32BufferAttribute(normals, 3));
      geometry.setAttribute('color', new THREE.Float32BufferAttribute(colorsArray, 3));
      geometry.setIndex(indices);

      const mesh = new THREE.Mesh(geometry, voxelMaterial);
      mesh.castShadow = true;
      mesh.receiveShadow = true;
      terrainGroup.add(mesh);
    }

    generateTerrain();
    scene.add(terrainGroup);

    document.getElementById('voxelCount').textContent = voxelCount.toLocaleString();

    // Player controls
    const controls = new PointerLockControls(camera, document.body);

    const blocker = document.getElementById('blocker');

    blocker.addEventListener('click', () => {
      controls.lock();
    });

    controls.addEventListener('lock', () => {
      blocker.classList.add('hidden');
    });

    controls.addEventListener('unlock', () => {
      blocker.classList.remove('hidden');
    });

    // Movement
    const velocity = new THREE.Vector3();
    const direction = new THREE.Vector3();

    let moveForward = false;
    let moveBackward = false;
    let moveLeft = false;
    let moveRight = false;
    let canJump = false;
    let isRunning = false;

    const WALK_SPEED = 50;
    const RUN_SPEED = 100;
    const JUMP_FORCE = 15;
    const GRAVITY = 40;
    const PLAYER_HEIGHT = 2;

    document.addEventListener('keydown', (e) => {
      switch (e.code) {
        case 'KeyW': moveForward = true; break;
        case 'KeyS': moveBackward = true; break;
        case 'KeyA': moveLeft = true; break;
        case 'KeyD': moveRight = true; break;
        case 'Space':
          if (canJump) {
            velocity.y = JUMP_FORCE;
            canJump = false;
          }
          break;
        case 'ShiftLeft': isRunning = true; break;
      }
    });

    document.addEventListener('keyup', (e) => {
      switch (e.code) {
        case 'KeyW': moveForward = false; break;
        case 'KeyS': moveBackward = false; break;
        case 'KeyA': moveLeft = false; break;
        case 'KeyD': moveRight = false; break;
        case 'ShiftLeft': isRunning = false; break;
      }
    });

    // Get terrain height at position
    function getTerrainHeight(x, z) {
      const vx = Math.floor(x / VOXEL_SIZE);
      const vz = Math.floor(z / VOXEL_SIZE);

      if (vx >= 0 && vx < WORLD_SIZE && vz >= 0 && vz < WORLD_SIZE) {
        return heightMap[vx][vz] * VOXEL_SIZE;
      }
      return 0;
    }

    // HUD elements
    const posX = document.getElementById('posX');
    const posY = document.getElementById('posY');
    const posZ = document.getElementById('posZ');

    // Animation loop
    let prevTime = performance.now();

    function animate() {
      requestAnimationFrame(animate);

      const time = performance.now();
      const delta = (time - prevTime) / 1000;
      prevTime = time;

      if (controls.isLocked) {
        // Apply gravity
        velocity.y -= GRAVITY * delta;

        // Movement direction
        direction.z = Number(moveForward) - Number(moveBackward);
        direction.x = Number(moveRight) - Number(moveLeft);
        direction.normalize();

        const speed = isRunning ? RUN_SPEED : WALK_SPEED;

        if (moveForward || moveBackward) velocity.z = direction.z * speed * delta;
        else velocity.z = 0;

        if (moveLeft || moveRight) velocity.x = direction.x * speed * delta;
        else velocity.x = 0;

        controls.moveRight(velocity.x);
        controls.moveForward(velocity.z);

        // Apply vertical velocity
        camera.position.y += velocity.y * delta;

        // Ground collision
        const groundHeight = getTerrainHeight(camera.position.x, camera.position.z) + PLAYER_HEIGHT;

        if (camera.position.y < groundHeight) {
          camera.position.y = groundHeight;
          velocity.y = 0;
          canJump = true;
        }

        // Keep in bounds
        camera.position.x = Math.max(1, Math.min(WORLD_SIZE - 1, camera.position.x));
        camera.position.z = Math.max(1, Math.min(WORLD_SIZE - 1, camera.position.z));

        // Update HUD
        posX.textContent = Math.floor(camera.position.x);
        posY.textContent = Math.floor(camera.position.y);
        posZ.textContent = Math.floor(camera.position.z);
      }

      renderer.render(scene, camera);
    }

    // Handle resize
    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });

    animate();
  </script>
<script src="/sloppy-header/sloppy-bar.js"></script>
</body>
</html>
