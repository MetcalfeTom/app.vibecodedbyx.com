<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
  <title>NEON FOX PLAYGROUND</title>
  <link rel="icon" href="https://emojicdn.elk.sh/ðŸ¦Š">
  <meta property="og:title" content="NEON FOX PLAYGROUND">
  <meta property="og:description" content="Play as a glowing fox with yarn balls and floating platforms!">
  <meta property="og:url" content="https://sloppy.live/fox-playground">
  <meta property="og:image" content="https://emojicdn.elk.sh/ðŸ§¶?style=apple&size=512">
  <link href="https://fonts.googleapis.com/css2?family=Fredoka:wght@400;600&display=swap" rel="stylesheet">
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      min-height: 100vh;
      background: #0a0a18;
      font-family: 'Fredoka', sans-serif;
      overflow: hidden;
    }
    .game-container {
      position: relative;
      width: 100vw;
      height: 100vh;
    }
    canvas { display: block; width: 100%; height: 100%; }
    .hud {
      position: absolute;
      top: 15px;
      left: 20px;
      right: 20px;
      display: flex;
      justify-content: space-between;
      pointer-events: none;
      z-index: 10;
    }
    .title {
      font-size: 1.3rem;
      color: #ff6b35;
      text-shadow: 0 0 20px #ff6b35, 0 0 40px #ff4500;
      letter-spacing: 0.05em;
    }
    .stats {
      font-size: 1rem;
      color: #f0f;
      text-shadow: 0 0 15px #f0f;
    }
    .controls-hint {
      position: absolute;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      font-size: 0.75rem;
      color: #666;
      text-align: center;
      pointer-events: none;
    }
    .back-link {
      position: fixed;
      bottom: 5px;
      right: 10px;
      color: #ff6b35;
      text-decoration: none;
      font-size: 0.6rem;
      opacity: 0.4;
    }
  </style>
</head>
<body>
  <div class="game-container">
    <canvas id="canvas"></canvas>
    <div class="hud">
      <div class="title">ðŸ¦Š NEON FOX PLAYGROUND</div>
      <div class="stats">ðŸ§¶ <span id="yarnCount">0</span></div>
    </div>
    <div class="controls-hint">Arrow Keys / WASD to move â€¢ Space to jump â€¢ Click yarn to bat it!</div>
  </div>
  <a href="https://sloppy.live" class="back-link">sloppy.live</a>

<script>
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');

let frameCount = 0;
let yarnCollected = 0;

const fox = {
  x: 200,
  y: 300,
  vx: 0,
  vy: 0,
  width: 50,
  height: 40,
  onGround: false,
  facing: 1,
  walkFrame: 0,
  tailWag: 0
};

const platforms = [];
const yarnBalls = [];
const particles = [];
const sparkles = [];

const keys = {};
const GRAVITY = 0.5;
const JUMP_FORCE = -12;
const MOVE_SPEED = 5;
const FRICTION = 0.85;

const COLORS = ['#ff6b35', '#f0f', '#0ff', '#ff0', '#0f0', '#f55'];

function resize() {
  canvas.width = window.innerWidth;
  canvas.height = window.innerHeight;
  initLevel();
}

function initLevel() {
  platforms.length = 0;
  yarnBalls.length = 0;

  // Ground
  platforms.push({
    x: 0, y: canvas.height - 40,
    width: canvas.width, height: 40,
    color: '#2a1a35',
    glowColor: '#f0f'
  });

  // Floating platforms
  const platCount = Math.floor(canvas.width / 200);
  for (let i = 0; i < platCount + 3; i++) {
    platforms.push({
      x: 100 + (i % platCount) * 200 + Math.random() * 80,
      y: 150 + Math.random() * (canvas.height - 300),
      width: 100 + Math.random() * 80,
      height: 20,
      color: '#1a2a35',
      glowColor: COLORS[Math.floor(Math.random() * COLORS.length)],
      floatOffset: Math.random() * Math.PI * 2,
      floatSpeed: 0.02 + Math.random() * 0.02,
      floatAmount: 10 + Math.random() * 15
    });
  }

  // Yarn balls
  for (let i = 0; i < 5; i++) {
    spawnYarn();
  }

  // Position fox
  fox.x = 100;
  fox.y = canvas.height - 100;
}

function spawnYarn() {
  const plat = platforms[1 + Math.floor(Math.random() * (platforms.length - 1))];
  yarnBalls.push({
    x: plat ? plat.x + plat.width / 2 : 200 + Math.random() * (canvas.width - 400),
    y: plat ? plat.y - 50 : 200 + Math.random() * 200,
    vx: 0,
    vy: 0,
    radius: 20 + Math.random() * 15,
    color: COLORS[Math.floor(Math.random() * COLORS.length)],
    rotation: Math.random() * Math.PI * 2,
    collected: false
  });
}

function spawnParticle(x, y, color) {
  for (let i = 0; i < 6; i++) {
    const angle = Math.random() * Math.PI * 2;
    particles.push({
      x, y,
      vx: Math.cos(angle) * (2 + Math.random() * 3),
      vy: Math.sin(angle) * (2 + Math.random() * 3),
      radius: 3 + Math.random() * 4,
      color,
      alpha: 1
    });
  }
}

function spawnSparkle(x, y, color) {
  sparkles.push({
    x, y,
    size: 10 + Math.random() * 10,
    color,
    alpha: 1,
    rotation: Math.random() * Math.PI
  });
}

function update() {
  frameCount++;
  fox.tailWag += 0.15;

  // Fox movement
  if (keys['ArrowLeft'] || keys['KeyA']) {
    fox.vx -= 0.8;
    fox.facing = -1;
    fox.walkFrame += 0.2;
  }
  if (keys['ArrowRight'] || keys['KeyD']) {
    fox.vx += 0.8;
    fox.facing = 1;
    fox.walkFrame += 0.2;
  }
  if ((keys['Space'] || keys['ArrowUp'] || keys['KeyW']) && fox.onGround) {
    fox.vy = JUMP_FORCE;
    fox.onGround = false;
    spawnParticle(fox.x, fox.y + fox.height / 2, '#ff6b35');
  }

  fox.vx *= FRICTION;
  fox.vx = Math.max(-MOVE_SPEED, Math.min(MOVE_SPEED, fox.vx));
  fox.vy += GRAVITY;

  fox.x += fox.vx;
  fox.y += fox.vy;

  // Platform collision
  fox.onGround = false;
  for (const plat of platforms) {
    // Floating animation
    if (plat.floatOffset !== undefined) {
      plat.currentY = plat.y + Math.sin(frameCount * plat.floatSpeed + plat.floatOffset) * plat.floatAmount;
    } else {
      plat.currentY = plat.y;
    }

    // Collision
    if (fox.vy >= 0 &&
        fox.x + fox.width / 2 > plat.x &&
        fox.x - fox.width / 2 < plat.x + plat.width &&
        fox.y + fox.height / 2 > plat.currentY &&
        fox.y + fox.height / 2 < plat.currentY + plat.height + fox.vy) {
      fox.y = plat.currentY - fox.height / 2;
      fox.vy = 0;
      fox.onGround = true;
    }
  }

  // Screen wrap
  if (fox.x < -fox.width) fox.x = canvas.width;
  if (fox.x > canvas.width + fox.width) fox.x = 0;
  if (fox.y > canvas.height + 100) {
    fox.y = 0;
    fox.vy = 0;
  }

  // Yarn physics
  for (const yarn of yarnBalls) {
    if (yarn.collected) continue;

    yarn.vy += GRAVITY * 0.5;
    yarn.vx *= 0.98;
    yarn.vy *= 0.98;

    yarn.x += yarn.vx;
    yarn.y += yarn.vy;
    yarn.rotation += yarn.vx * 0.05;

    // Yarn platform collision
    for (const plat of platforms) {
      const platY = plat.currentY || plat.y;
      if (yarn.y + yarn.radius > platY &&
          yarn.y - yarn.radius < platY + plat.height &&
          yarn.x > plat.x && yarn.x < plat.x + plat.width) {
        yarn.y = platY - yarn.radius;
        yarn.vy *= -0.6;
        yarn.vx *= 0.9;
      }
    }

    // Screen wrap for yarn
    if (yarn.x < -yarn.radius) yarn.x = canvas.width + yarn.radius;
    if (yarn.x > canvas.width + yarn.radius) yarn.x = -yarn.radius;

    // Fox collects yarn
    const dx = fox.x - yarn.x;
    const dy = fox.y - yarn.y;
    const dist = Math.sqrt(dx * dx + dy * dy);
    if (dist < fox.width / 2 + yarn.radius) {
      yarn.collected = true;
      yarnCollected++;
      document.getElementById('yarnCount').textContent = yarnCollected;
      spawnParticle(yarn.x, yarn.y, yarn.color);
      for (let i = 0; i < 5; i++) {
        spawnSparkle(yarn.x + (Math.random() - 0.5) * 40, yarn.y + (Math.random() - 0.5) * 40, yarn.color);
      }
      setTimeout(spawnYarn, 2000);
    }
  }

  // Update particles
  for (let i = particles.length - 1; i >= 0; i--) {
    const p = particles[i];
    p.x += p.vx;
    p.y += p.vy;
    p.vy += 0.1;
    p.alpha -= 0.03;
    if (p.alpha <= 0) particles.splice(i, 1);
  }

  // Update sparkles
  for (let i = sparkles.length - 1; i >= 0; i--) {
    const s = sparkles[i];
    s.alpha -= 0.03;
    s.size += 0.5;
    s.rotation += 0.1;
    if (s.alpha <= 0) sparkles.splice(i, 1);
  }
}

function drawFox() {
  ctx.save();
  ctx.translate(fox.x, fox.y);
  ctx.scale(fox.facing, 1);

  const bounce = fox.onGround ? Math.sin(fox.walkFrame) * 3 : 0;

  // Glow
  ctx.shadowColor = '#ff6b35';
  ctx.shadowBlur = 30;

  // Tail
  const tailWag = Math.sin(fox.tailWag) * 0.3;
  ctx.save();
  ctx.translate(-20, 5);
  ctx.rotate(tailWag - 0.5);
  ctx.fillStyle = '#ff6b35';
  ctx.beginPath();
  ctx.ellipse(0, 0, 25, 10, 0, 0, Math.PI * 2);
  ctx.fill();
  // Tail tip
  ctx.fillStyle = '#fff';
  ctx.beginPath();
  ctx.ellipse(-20, 0, 8, 6, 0, 0, Math.PI * 2);
  ctx.fill();
  ctx.restore();

  // Body
  ctx.fillStyle = '#ff6b35';
  ctx.beginPath();
  ctx.ellipse(0, bounce, 25, 18, 0, 0, Math.PI * 2);
  ctx.fill();

  // Head
  ctx.beginPath();
  ctx.ellipse(18, -8 + bounce, 18, 15, 0.3, 0, Math.PI * 2);
  ctx.fill();

  // Ears
  ctx.beginPath();
  ctx.moveTo(22, -22 + bounce);
  ctx.lineTo(15, -8 + bounce);
  ctx.lineTo(28, -10 + bounce);
  ctx.closePath();
  ctx.fill();
  ctx.beginPath();
  ctx.moveTo(32, -20 + bounce);
  ctx.lineTo(25, -8 + bounce);
  ctx.lineTo(38, -8 + bounce);
  ctx.closePath();
  ctx.fill();

  // Inner ears
  ctx.fillStyle = '#ffaa88';
  ctx.beginPath();
  ctx.moveTo(23, -18 + bounce);
  ctx.lineTo(18, -10 + bounce);
  ctx.lineTo(26, -11 + bounce);
  ctx.closePath();
  ctx.fill();

  // Snout
  ctx.fillStyle = '#fff';
  ctx.beginPath();
  ctx.ellipse(30, 0 + bounce, 10, 8, 0.2, 0, Math.PI * 2);
  ctx.fill();

  // Eyes
  ctx.fillStyle = '#000';
  ctx.beginPath();
  ctx.arc(22, -8 + bounce, 4, 0, Math.PI * 2);
  ctx.fill();
  ctx.fillStyle = '#fff';
  ctx.beginPath();
  ctx.arc(21, -9 + bounce, 1.5, 0, Math.PI * 2);
  ctx.fill();

  // Nose
  ctx.fillStyle = '#222';
  ctx.beginPath();
  ctx.ellipse(38, -2 + bounce, 4, 3, 0, 0, Math.PI * 2);
  ctx.fill();

  // Legs
  ctx.fillStyle = '#ff6b35';
  const legOffset = Math.sin(fox.walkFrame) * 5;
  ctx.fillRect(-10, 12 + bounce, 8, 15 + (fox.onGround ? legOffset : 0));
  ctx.fillRect(5, 12 + bounce, 8, 15 - (fox.onGround ? legOffset : 0));

  // Paws
  ctx.fillStyle = '#222';
  ctx.beginPath();
  ctx.ellipse(-6, 28 + bounce + (fox.onGround ? legOffset : 0), 6, 4, 0, 0, Math.PI * 2);
  ctx.ellipse(9, 28 + bounce - (fox.onGround ? legOffset : 0), 6, 4, 0, 0, Math.PI * 2);
  ctx.fill();

  ctx.restore();
}

function drawYarn(yarn) {
  if (yarn.collected) return;

  ctx.save();
  ctx.translate(yarn.x, yarn.y);
  ctx.rotate(yarn.rotation);

  // Glow
  ctx.shadowColor = yarn.color;
  ctx.shadowBlur = 20;

  // Yarn ball
  const grad = ctx.createRadialGradient(0, 0, 0, 0, 0, yarn.radius);
  grad.addColorStop(0, yarn.color);
  grad.addColorStop(1, yarn.color + '88');
  ctx.fillStyle = grad;
  ctx.beginPath();
  ctx.arc(0, 0, yarn.radius, 0, Math.PI * 2);
  ctx.fill();

  // Yarn threads
  ctx.strokeStyle = '#fff';
  ctx.lineWidth = 2;
  ctx.globalAlpha = 0.5;
  for (let i = 0; i < 5; i++) {
    const angle = (i / 5) * Math.PI * 2;
    ctx.beginPath();
    ctx.arc(0, 0, yarn.radius * 0.7, angle, angle + 1);
    ctx.stroke();
  }
  ctx.globalAlpha = 1;

  // Shine
  ctx.fillStyle = 'rgba(255,255,255,0.4)';
  ctx.beginPath();
  ctx.arc(-yarn.radius * 0.3, -yarn.radius * 0.3, yarn.radius * 0.3, 0, Math.PI * 2);
  ctx.fill();

  ctx.restore();
}

function drawPlatform(plat) {
  const y = plat.currentY || plat.y;

  // Glow
  ctx.shadowColor = plat.glowColor;
  ctx.shadowBlur = 15;

  // Platform body
  ctx.fillStyle = plat.color;
  ctx.fillRect(plat.x, y, plat.width, plat.height);

  // Neon edge
  ctx.strokeStyle = plat.glowColor;
  ctx.lineWidth = 3;
  ctx.strokeRect(plat.x, y, plat.width, plat.height);

  // Top highlight
  ctx.strokeStyle = '#fff';
  ctx.lineWidth = 1;
  ctx.globalAlpha = 0.3;
  ctx.beginPath();
  ctx.moveTo(plat.x + 2, y + 2);
  ctx.lineTo(plat.x + plat.width - 2, y + 2);
  ctx.stroke();
  ctx.globalAlpha = 1;

  ctx.shadowBlur = 0;
}

function drawParticles() {
  for (const p of particles) {
    ctx.globalAlpha = p.alpha;
    ctx.fillStyle = p.color;
    ctx.shadowColor = p.color;
    ctx.shadowBlur = 10;
    ctx.beginPath();
    ctx.arc(p.x, p.y, p.radius, 0, Math.PI * 2);
    ctx.fill();
  }
  ctx.globalAlpha = 1;
  ctx.shadowBlur = 0;
}

function drawSparkles() {
  for (const s of sparkles) {
    ctx.save();
    ctx.translate(s.x, s.y);
    ctx.rotate(s.rotation);
    ctx.globalAlpha = s.alpha;
    ctx.strokeStyle = s.color;
    ctx.lineWidth = 2;
    ctx.shadowColor = s.color;
    ctx.shadowBlur = 10;

    // Star shape
    ctx.beginPath();
    ctx.moveTo(0, -s.size);
    ctx.lineTo(0, s.size);
    ctx.moveTo(-s.size, 0);
    ctx.lineTo(s.size, 0);
    ctx.moveTo(-s.size * 0.7, -s.size * 0.7);
    ctx.lineTo(s.size * 0.7, s.size * 0.7);
    ctx.moveTo(s.size * 0.7, -s.size * 0.7);
    ctx.lineTo(-s.size * 0.7, s.size * 0.7);
    ctx.stroke();

    ctx.restore();
  }
  ctx.globalAlpha = 1;
}

function render() {
  // Background gradient
  const bg = ctx.createLinearGradient(0, 0, 0, canvas.height);
  bg.addColorStop(0, '#0a0a18');
  bg.addColorStop(0.5, '#12102a');
  bg.addColorStop(1, '#1a1535');
  ctx.fillStyle = bg;
  ctx.fillRect(0, 0, canvas.width, canvas.height);

  // Stars
  ctx.fillStyle = '#fff';
  for (let i = 0; i < 60; i++) {
    const x = (i * 137) % canvas.width;
    const y = (i * 89) % canvas.height;
    const twinkle = 0.2 + Math.sin(frameCount * 0.03 + i) * 0.2;
    ctx.globalAlpha = twinkle;
    ctx.beginPath();
    ctx.arc(x, y, 1.5, 0, Math.PI * 2);
    ctx.fill();
  }
  ctx.globalAlpha = 1;

  // Platforms
  for (const plat of platforms) {
    drawPlatform(plat);
  }

  // Yarn balls
  for (const yarn of yarnBalls) {
    drawYarn(yarn);
  }

  // Fox
  drawFox();

  // Effects
  drawParticles();
  drawSparkles();

  // Vignette
  const vignette = ctx.createRadialGradient(
    canvas.width / 2, canvas.height / 2, canvas.height * 0.4,
    canvas.width / 2, canvas.height / 2, canvas.height
  );
  vignette.addColorStop(0, 'transparent');
  vignette.addColorStop(1, 'rgba(0, 0, 0, 0.4)');
  ctx.fillStyle = vignette;
  ctx.fillRect(0, 0, canvas.width, canvas.height);
}

function gameLoop() {
  update();
  render();
  requestAnimationFrame(gameLoop);
}

// Click to bat yarn
canvas.addEventListener('click', e => {
  const clickX = e.clientX;
  const clickY = e.clientY;

  for (const yarn of yarnBalls) {
    if (yarn.collected) continue;
    const dx = clickX - yarn.x;
    const dy = clickY - yarn.y;
    const dist = Math.sqrt(dx * dx + dy * dy);

    if (dist < yarn.radius + 30) {
      // Bat the yarn away from click
      yarn.vx += (yarn.x - clickX) * 0.15;
      yarn.vy += (yarn.y - clickY) * 0.15 - 5;
      spawnParticle(yarn.x, yarn.y, yarn.color);
    }
  }
});

// Keyboard
window.addEventListener('keydown', e => {
  keys[e.code] = true;
  if (['Space', 'ArrowUp', 'ArrowDown'].includes(e.code)) {
    e.preventDefault();
  }
});

window.addEventListener('keyup', e => {
  keys[e.code] = false;
});

// Touch controls
let touchStartX = 0;
canvas.addEventListener('touchstart', e => {
  touchStartX = e.touches[0].clientX;
  const touchY = e.touches[0].clientY;

  // Jump if touch is in upper half
  if (touchY < canvas.height / 2) {
    keys['Space'] = true;
    setTimeout(() => keys['Space'] = false, 100);
  }

  // Bat yarn
  for (const yarn of yarnBalls) {
    if (yarn.collected) continue;
    const dx = touchStartX - yarn.x;
    const dy = touchY - yarn.y;
    const dist = Math.sqrt(dx * dx + dy * dy);
    if (dist < yarn.radius + 50) {
      yarn.vx += (yarn.x - touchStartX) * 0.15;
      yarn.vy += (yarn.y - touchY) * 0.15 - 5;
      spawnParticle(yarn.x, yarn.y, yarn.color);
    }
  }
});

canvas.addEventListener('touchmove', e => {
  e.preventDefault();
  const touchX = e.touches[0].clientX;
  const diff = touchX - touchStartX;

  keys['ArrowLeft'] = diff < -20;
  keys['ArrowRight'] = diff > 20;
});

canvas.addEventListener('touchend', () => {
  keys['ArrowLeft'] = false;
  keys['ArrowRight'] = false;
});

window.addEventListener('resize', resize);

resize();
gameLoop();
</script>
</body>
</html>
