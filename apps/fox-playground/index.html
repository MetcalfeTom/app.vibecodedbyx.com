<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
  <title>Pirate Parrot</title>
  <link rel="icon" href="https://emojicdn.elk.sh/ðŸ¦œ">
  <meta property="og:title" content="Pirate Parrot">
  <meta property="og:description" content="Fly as a ship's parrot collecting gold doubloons on floating barrels!">
  <meta property="og:url" content="https://sloppy.live/fox-playground">
  <meta property="og:image" content="https://emojicdn.elk.sh/ðŸ¦œ?style=apple&size=512">
  <link href="https://fonts.googleapis.com/css2?family=Pirata+One&family=IM+Fell+English+SC&display=swap" rel="stylesheet">
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      min-height: 100vh;
      background: #0d1a2a;
      font-family: 'IM Fell English SC', serif;
      overflow: hidden;
    }
    .game-container {
      position: relative;
      width: 100vw;
      height: 100vh;
    }
    canvas { display: block; width: 100%; height: 100%; }
    .hud {
      position: absolute;
      top: 15px;
      left: 20px;
      right: 20px;
      display: flex;
      justify-content: space-between;
      pointer-events: none;
      z-index: 10;
    }
    .title {
      font-family: 'Pirata One', cursive;
      font-size: 1.5rem;
      color: #d4a84b;
      text-shadow: 0 0 20px #d4a84b, 2px 2px 4px #1a0f0a;
      letter-spacing: 0.05em;
    }
    .stats {
      font-family: 'Pirata One', cursive;
      font-size: 1.2rem;
      color: #ffd700;
      text-shadow: 0 0 15px #ffd700;
    }
    .controls-hint {
      position: absolute;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      font-size: 0.75rem;
      color: #5c4a2a;
      text-align: center;
      pointer-events: none;
    }
    .back-link {
      position: fixed;
      bottom: 5px;
      right: 10px;
      color: #d4a84b;
      text-decoration: none;
      font-size: 0.6rem;
      opacity: 0.4;
    }
  </style>
</head>
<body>
  <div class="game-container">
    <canvas id="canvas"></canvas>
    <div class="hud">
      <div class="title">ðŸ¦œ Pirate Parrot</div>
      <div class="stats">ðŸª™ <span id="coinCount">0</span></div>
    </div>
    <div class="controls-hint">Arrow Keys / WASD to fly â€¢ Space to flap â€¢ Click coins to knock them!</div>
  </div>
  <a href="https://sloppy.live" class="back-link">sloppy.live</a>

<script>
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');

let frameCount = 0;
let coinsCollected = 0;

const parrot = {
  x: 200,
  y: 300,
  vx: 0,
  vy: 0,
  width: 50,
  height: 40,
  onGround: false,
  facing: 1,
  wingFrame: 0,
  bobFrame: 0
};

const platforms = [];
const coins = [];
const particles = [];
const sparkles = [];

const keys = {};
const GRAVITY = 0.4;
const FLAP_FORCE = -10;
const MOVE_SPEED = 5;
const FRICTION = 0.88;

const COLORS = ['#ffd700', '#d4a84b', '#c0c0c0', '#cd7f32', '#b8860b'];

function resize() {
  canvas.width = window.innerWidth;
  canvas.height = window.innerHeight;
  initLevel();
}

function initLevel() {
  platforms.length = 0;
  coins.length = 0;

  // Ship deck (ground)
  platforms.push({
    x: 0, y: canvas.height - 40,
    width: canvas.width, height: 40,
    type: 'deck',
    color: '#5c3a1e'
  });

  // Floating barrels and planks
  const platCount = Math.floor(canvas.width / 180);
  for (let i = 0; i < platCount + 4; i++) {
    const isBarrel = Math.random() > 0.5;
    platforms.push({
      x: 80 + (i % platCount) * 180 + Math.random() * 60,
      y: 120 + Math.random() * (canvas.height - 280),
      width: isBarrel ? 60 : 100 + Math.random() * 60,
      height: isBarrel ? 50 : 18,
      type: isBarrel ? 'barrel' : 'plank',
      color: isBarrel ? '#6b4423' : '#8b6914',
      floatOffset: Math.random() * Math.PI * 2,
      floatSpeed: 0.015 + Math.random() * 0.015,
      floatAmount: 8 + Math.random() * 12
    });
  }

  // Gold coins
  for (let i = 0; i < 6; i++) {
    spawnCoin();
  }

  // Position parrot
  parrot.x = 100;
  parrot.y = canvas.height - 100;
}

function spawnCoin() {
  const plat = platforms[1 + Math.floor(Math.random() * (platforms.length - 1))];
  coins.push({
    x: plat ? plat.x + plat.width / 2 : 200 + Math.random() * (canvas.width - 400),
    y: plat ? plat.y - 40 : 200 + Math.random() * 200,
    vx: 0,
    vy: 0,
    radius: 18 + Math.random() * 8,
    color: COLORS[Math.floor(Math.random() * COLORS.length)],
    rotation: Math.random() * Math.PI * 2,
    collected: false,
    shine: Math.random() * Math.PI * 2
  });
}

function spawnParticle(x, y, color) {
  for (let i = 0; i < 6; i++) {
    const angle = Math.random() * Math.PI * 2;
    particles.push({
      x, y,
      vx: Math.cos(angle) * (2 + Math.random() * 3),
      vy: Math.sin(angle) * (2 + Math.random() * 3),
      radius: 3 + Math.random() * 4,
      color,
      alpha: 1
    });
  }
}

function spawnSparkle(x, y, color) {
  sparkles.push({
    x, y,
    size: 10 + Math.random() * 10,
    color,
    alpha: 1,
    rotation: Math.random() * Math.PI
  });
}

function update() {
  frameCount++;
  parrot.bobFrame += 0.1;
  parrot.wingFrame += 0.2;

  // Parrot movement
  if (keys['ArrowLeft'] || keys['KeyA']) {
    parrot.vx -= 0.7;
    parrot.facing = -1;
  }
  if (keys['ArrowRight'] || keys['KeyD']) {
    parrot.vx += 0.7;
    parrot.facing = 1;
  }
  if (keys['Space'] || keys['ArrowUp'] || keys['KeyW']) {
    if (parrot.onGround || parrot.vy > -3) {
      parrot.vy = FLAP_FORCE;
      parrot.onGround = false;
      parrot.wingFrame = 0;
      spawnParticle(parrot.x, parrot.y + 10, '#4a9');
    }
  }

  parrot.vx *= FRICTION;
  parrot.vx = Math.max(-MOVE_SPEED, Math.min(MOVE_SPEED, parrot.vx));
  parrot.vy += GRAVITY;

  parrot.x += parrot.vx;
  parrot.y += parrot.vy;

  // Platform collision
  parrot.onGround = false;
  for (const plat of platforms) {
    // Floating animation
    if (plat.floatOffset !== undefined) {
      plat.currentY = plat.y + Math.sin(frameCount * plat.floatSpeed + plat.floatOffset) * plat.floatAmount;
    } else {
      plat.currentY = plat.y;
    }

    // Collision
    if (parrot.vy >= 0 &&
        parrot.x + parrot.width / 2 > plat.x &&
        parrot.x - parrot.width / 2 < plat.x + plat.width &&
        parrot.y + parrot.height / 2 > plat.currentY &&
        parrot.y + parrot.height / 2 < plat.currentY + plat.height + parrot.vy) {
      parrot.y = plat.currentY - parrot.height / 2;
      parrot.vy = 0;
      parrot.onGround = true;
    }
  }

  // Screen wrap
  if (parrot.x < -parrot.width) parrot.x = canvas.width;
  if (parrot.x > canvas.width + parrot.width) parrot.x = 0;
  if (parrot.y > canvas.height + 100) {
    parrot.y = 0;
    parrot.vy = 0;
  }

  // Coin physics
  for (const coin of coins) {
    if (coin.collected) continue;

    coin.vy += GRAVITY * 0.4;
    coin.vx *= 0.98;
    coin.vy *= 0.98;

    coin.x += coin.vx;
    coin.y += coin.vy;
    coin.rotation += coin.vx * 0.05;
    coin.shine += 0.05;

    // Coin platform collision
    for (const plat of platforms) {
      const platY = plat.currentY || plat.y;
      if (coin.y + coin.radius > platY &&
          coin.y - coin.radius < platY + plat.height &&
          coin.x > plat.x && coin.x < plat.x + plat.width) {
        coin.y = platY - coin.radius;
        coin.vy *= -0.5;
        coin.vx *= 0.85;
      }
    }

    // Screen wrap for coins
    if (coin.x < -coin.radius) coin.x = canvas.width + coin.radius;
    if (coin.x > canvas.width + coin.radius) coin.x = -coin.radius;

    // Parrot collects coin
    const dx = parrot.x - coin.x;
    const dy = parrot.y - coin.y;
    const dist = Math.sqrt(dx * dx + dy * dy);
    if (dist < parrot.width / 2 + coin.radius) {
      coin.collected = true;
      coinsCollected++;
      document.getElementById('coinCount').textContent = coinsCollected;
      spawnParticle(coin.x, coin.y, coin.color);
      for (let i = 0; i < 5; i++) {
        spawnSparkle(coin.x + (Math.random() - 0.5) * 40, coin.y + (Math.random() - 0.5) * 40, '#ffd700');
      }
      setTimeout(spawnCoin, 2000);
    }
  }

  // Update particles
  for (let i = particles.length - 1; i >= 0; i--) {
    const p = particles[i];
    p.x += p.vx;
    p.y += p.vy;
    p.vy += 0.1;
    p.alpha -= 0.03;
    if (p.alpha <= 0) particles.splice(i, 1);
  }

  // Update sparkles
  for (let i = sparkles.length - 1; i >= 0; i--) {
    const s = sparkles[i];
    s.alpha -= 0.03;
    s.size += 0.5;
    s.rotation += 0.1;
    if (s.alpha <= 0) sparkles.splice(i, 1);
  }
}

function drawParrot() {
  ctx.save();
  ctx.translate(parrot.x, parrot.y);
  ctx.scale(parrot.facing, 1);

  const bounce = parrot.onGround ? Math.sin(parrot.bobFrame * 2) * 2 : 0;
  const wingFlap = Math.sin(parrot.wingFrame * 3) * (parrot.onGround ? 0.1 : 0.5);

  // Wing (back)
  ctx.save();
  ctx.translate(-5, -5 + bounce);
  ctx.rotate(wingFlap - 0.2);
  ctx.fillStyle = '#1e90ff';
  ctx.beginPath();
  ctx.ellipse(-15, 5, 20, 8, -0.5, 0, Math.PI * 2);
  ctx.fill();
  ctx.fillStyle = '#ffd700';
  ctx.beginPath();
  ctx.ellipse(-22, 8, 10, 5, -0.5, 0, Math.PI * 2);
  ctx.fill();
  ctx.restore();

  // Body
  ctx.fillStyle = '#e63946';
  ctx.beginPath();
  ctx.ellipse(0, bounce, 22, 18, 0, 0, Math.PI * 2);
  ctx.fill();

  // Chest
  ctx.fillStyle = '#f4a261';
  ctx.beginPath();
  ctx.ellipse(8, 5 + bounce, 12, 10, 0.3, 0, Math.PI * 2);
  ctx.fill();

  // Wing (front)
  ctx.save();
  ctx.translate(0, -5 + bounce);
  ctx.rotate(-wingFlap + 0.1);
  ctx.fillStyle = '#1e90ff';
  ctx.beginPath();
  ctx.ellipse(-12, 5, 18, 7, -0.3, 0, Math.PI * 2);
  ctx.fill();
  ctx.fillStyle = '#2a9d8f';
  ctx.beginPath();
  ctx.ellipse(-18, 7, 10, 5, -0.3, 0, Math.PI * 2);
  ctx.fill();
  ctx.restore();

  // Head
  ctx.fillStyle = '#e63946';
  ctx.beginPath();
  ctx.ellipse(18, -12 + bounce, 15, 13, 0, 0, Math.PI * 2);
  ctx.fill();

  // Eye ring (white)
  ctx.fillStyle = '#fff';
  ctx.beginPath();
  ctx.arc(22, -14 + bounce, 7, 0, Math.PI * 2);
  ctx.fill();

  // Eye
  ctx.fillStyle = '#1a1a1a';
  ctx.beginPath();
  ctx.arc(23, -14 + bounce, 4, 0, Math.PI * 2);
  ctx.fill();
  ctx.fillStyle = '#fff';
  ctx.beginPath();
  ctx.arc(24, -15 + bounce, 1.5, 0, Math.PI * 2);
  ctx.fill();

  // Beak
  ctx.fillStyle = '#1a1a1a';
  ctx.beginPath();
  ctx.moveTo(30, -12 + bounce);
  ctx.quadraticCurveTo(45, -8 + bounce, 38, -2 + bounce);
  ctx.quadraticCurveTo(30, -6 + bounce, 30, -12 + bounce);
  ctx.fill();

  // Beak highlight
  ctx.fillStyle = '#333';
  ctx.beginPath();
  ctx.moveTo(31, -11 + bounce);
  ctx.quadraticCurveTo(40, -9 + bounce, 36, -5 + bounce);
  ctx.quadraticCurveTo(31, -7 + bounce, 31, -11 + bounce);
  ctx.fill();

  // Head feathers
  ctx.fillStyle = '#e63946';
  ctx.beginPath();
  ctx.moveTo(10, -22 + bounce);
  ctx.quadraticCurveTo(5, -35 + bounce, 15, -28 + bounce);
  ctx.quadraticCurveTo(12, -35 + bounce, 22, -25 + bounce);
  ctx.closePath();
  ctx.fill();

  // Tail feathers
  ctx.fillStyle = '#e63946';
  ctx.beginPath();
  ctx.moveTo(-20, 10 + bounce);
  ctx.quadraticCurveTo(-40, 25 + bounce, -35, 15 + bounce);
  ctx.quadraticCurveTo(-45, 20 + bounce, -38, 8 + bounce);
  ctx.quadraticCurveTo(-35, 5 + bounce, -20, 5 + bounce);
  ctx.fill();

  ctx.fillStyle = '#1e90ff';
  ctx.beginPath();
  ctx.moveTo(-22, 8 + bounce);
  ctx.quadraticCurveTo(-38, 18 + bounce, -32, 10 + bounce);
  ctx.closePath();
  ctx.fill();

  // Feet
  ctx.fillStyle = '#555';
  ctx.fillRect(5, 15 + bounce, 4, 12);
  ctx.fillRect(-5, 15 + bounce, 4, 12);

  // Claws
  ctx.strokeStyle = '#555';
  ctx.lineWidth = 2;
  ctx.beginPath();
  ctx.moveTo(3, 27 + bounce);
  ctx.lineTo(0, 30 + bounce);
  ctx.moveTo(7, 27 + bounce);
  ctx.lineTo(7, 31 + bounce);
  ctx.moveTo(9, 27 + bounce);
  ctx.lineTo(12, 30 + bounce);
  ctx.moveTo(-7, 27 + bounce);
  ctx.lineTo(-10, 30 + bounce);
  ctx.moveTo(-3, 27 + bounce);
  ctx.lineTo(-3, 31 + bounce);
  ctx.moveTo(-1, 27 + bounce);
  ctx.lineTo(2, 30 + bounce);
  ctx.stroke();

  ctx.restore();
}

function drawCoin(coin) {
  if (coin.collected) return;

  ctx.save();
  ctx.translate(coin.x, coin.y);
  ctx.rotate(coin.rotation);

  // Glow
  ctx.shadowColor = '#ffd700';
  ctx.shadowBlur = 15;

  // Coin body
  const grad = ctx.createRadialGradient(-5, -5, 0, 0, 0, coin.radius);
  grad.addColorStop(0, '#fff8dc');
  grad.addColorStop(0.3, coin.color);
  grad.addColorStop(1, '#8b6914');
  ctx.fillStyle = grad;
  ctx.beginPath();
  ctx.arc(0, 0, coin.radius, 0, Math.PI * 2);
  ctx.fill();

  // Coin edge
  ctx.strokeStyle = '#5c4a1e';
  ctx.lineWidth = 2;
  ctx.stroke();

  // Skull emblem
  ctx.fillStyle = '#5c3a1e';
  ctx.font = `${coin.radius}px serif`;
  ctx.textAlign = 'center';
  ctx.textBaseline = 'middle';
  ctx.fillText('â˜ ', 0, 1);

  // Shine
  ctx.globalAlpha = 0.3 + Math.sin(coin.shine) * 0.2;
  ctx.fillStyle = '#fff';
  ctx.beginPath();
  ctx.arc(-coin.radius * 0.3, -coin.radius * 0.3, coin.radius * 0.25, 0, Math.PI * 2);
  ctx.fill();
  ctx.globalAlpha = 1;

  ctx.restore();
}

function drawPlatform(plat) {
  const y = plat.currentY || plat.y;

  ctx.shadowColor = '#d4a84b';
  ctx.shadowBlur = 8;

  if (plat.type === 'barrel') {
    // Barrel
    ctx.fillStyle = plat.color;
    ctx.beginPath();
    ctx.ellipse(plat.x + plat.width / 2, y + plat.height / 2, plat.width / 2, plat.height / 2, 0, 0, Math.PI * 2);
    ctx.fill();

    // Barrel bands
    ctx.strokeStyle = '#3a2a1a';
    ctx.lineWidth = 3;
    ctx.beginPath();
    ctx.ellipse(plat.x + plat.width / 2, y + 8, plat.width / 2 - 3, 6, 0, 0, Math.PI * 2);
    ctx.stroke();
    ctx.beginPath();
    ctx.ellipse(plat.x + plat.width / 2, y + plat.height - 8, plat.width / 2 - 3, 6, 0, 0, Math.PI * 2);
    ctx.stroke();

    // Barrel highlight
    ctx.fillStyle = 'rgba(255,255,255,0.1)';
    ctx.beginPath();
    ctx.ellipse(plat.x + plat.width / 3, y + plat.height / 3, plat.width / 6, plat.height / 4, -0.5, 0, Math.PI * 2);
    ctx.fill();
  } else if (plat.type === 'deck') {
    // Ship deck
    ctx.fillStyle = '#5c3a1e';
    ctx.fillRect(plat.x, y, plat.width, plat.height);

    // Planks
    ctx.strokeStyle = '#3a2a1a';
    ctx.lineWidth = 2;
    for (let px = 0; px < plat.width; px += 60) {
      ctx.beginPath();
      ctx.moveTo(plat.x + px, y);
      ctx.lineTo(plat.x + px, y + plat.height);
      ctx.stroke();
    }

    // Top edge
    ctx.strokeStyle = '#8b6914';
    ctx.lineWidth = 3;
    ctx.beginPath();
    ctx.moveTo(plat.x, y);
    ctx.lineTo(plat.x + plat.width, y);
    ctx.stroke();
  } else {
    // Wooden plank
    ctx.fillStyle = plat.color;
    ctx.fillRect(plat.x, y, plat.width, plat.height);

    // Wood grain
    ctx.strokeStyle = '#5c3a1e';
    ctx.lineWidth = 1;
    for (let i = 0; i < 3; i++) {
      ctx.beginPath();
      ctx.moveTo(plat.x, y + 5 + i * 5);
      ctx.lineTo(plat.x + plat.width, y + 5 + i * 5);
      ctx.stroke();
    }

    // Nails
    ctx.fillStyle = '#555';
    ctx.beginPath();
    ctx.arc(plat.x + 8, y + plat.height / 2, 3, 0, Math.PI * 2);
    ctx.arc(plat.x + plat.width - 8, y + plat.height / 2, 3, 0, Math.PI * 2);
    ctx.fill();
  }

  ctx.shadowBlur = 0;
}

function drawParticles() {
  for (const p of particles) {
    ctx.globalAlpha = p.alpha;
    ctx.fillStyle = p.color;
    ctx.shadowColor = p.color;
    ctx.shadowBlur = 10;
    ctx.beginPath();
    ctx.arc(p.x, p.y, p.radius, 0, Math.PI * 2);
    ctx.fill();
  }
  ctx.globalAlpha = 1;
  ctx.shadowBlur = 0;
}

function drawSparkles() {
  for (const s of sparkles) {
    ctx.save();
    ctx.translate(s.x, s.y);
    ctx.rotate(s.rotation);
    ctx.globalAlpha = s.alpha;
    ctx.strokeStyle = s.color;
    ctx.lineWidth = 2;
    ctx.shadowColor = s.color;
    ctx.shadowBlur = 10;

    // Star shape
    ctx.beginPath();
    ctx.moveTo(0, -s.size);
    ctx.lineTo(0, s.size);
    ctx.moveTo(-s.size, 0);
    ctx.lineTo(s.size, 0);
    ctx.moveTo(-s.size * 0.7, -s.size * 0.7);
    ctx.lineTo(s.size * 0.7, s.size * 0.7);
    ctx.moveTo(s.size * 0.7, -s.size * 0.7);
    ctx.lineTo(-s.size * 0.7, s.size * 0.7);
    ctx.stroke();

    ctx.restore();
  }
  ctx.globalAlpha = 1;
}

function render() {
  // Ocean night background
  const bg = ctx.createLinearGradient(0, 0, 0, canvas.height);
  bg.addColorStop(0, '#0d1a2a');
  bg.addColorStop(0.4, '#1a2d4a');
  bg.addColorStop(0.7, '#0d2a3a');
  bg.addColorStop(1, '#051520');
  ctx.fillStyle = bg;
  ctx.fillRect(0, 0, canvas.width, canvas.height);

  // Moon
  ctx.fillStyle = '#f5f5dc';
  ctx.shadowColor = '#f5f5dc';
  ctx.shadowBlur = 40;
  ctx.beginPath();
  ctx.arc(canvas.width - 100, 80, 40, 0, Math.PI * 2);
  ctx.fill();
  ctx.shadowBlur = 0;

  // Stars
  ctx.fillStyle = '#fff';
  for (let i = 0; i < 50; i++) {
    const x = (i * 137) % canvas.width;
    const y = (i * 89) % (canvas.height * 0.5);
    const twinkle = 0.3 + Math.sin(frameCount * 0.03 + i) * 0.2;
    ctx.globalAlpha = twinkle;
    ctx.beginPath();
    ctx.arc(x, y, 1.5, 0, Math.PI * 2);
    ctx.fill();
  }
  ctx.globalAlpha = 1;

  // Ocean waves (background)
  ctx.fillStyle = '#0a3a4a';
  ctx.globalAlpha = 0.3;
  for (let w = 0; w < 3; w++) {
    ctx.beginPath();
    ctx.moveTo(0, canvas.height - 80 + w * 15);
    for (let x = 0; x <= canvas.width; x += 50) {
      const y = canvas.height - 80 + w * 15 + Math.sin((x + frameCount * 2 + w * 100) * 0.02) * 8;
      ctx.lineTo(x, y);
    }
    ctx.lineTo(canvas.width, canvas.height);
    ctx.lineTo(0, canvas.height);
    ctx.fill();
  }
  ctx.globalAlpha = 1;

  // Platforms
  for (const plat of platforms) {
    drawPlatform(plat);
  }

  // Coins
  for (const coin of coins) {
    drawCoin(coin);
  }

  // Parrot
  drawParrot();

  // Effects
  drawParticles();
  drawSparkles();

  // Vignette
  const vignette = ctx.createRadialGradient(
    canvas.width / 2, canvas.height / 2, canvas.height * 0.4,
    canvas.width / 2, canvas.height / 2, canvas.height
  );
  vignette.addColorStop(0, 'transparent');
  vignette.addColorStop(1, 'rgba(0, 0, 0, 0.5)');
  ctx.fillStyle = vignette;
  ctx.fillRect(0, 0, canvas.width, canvas.height);
}

function gameLoop() {
  update();
  render();
  requestAnimationFrame(gameLoop);
}

// Click to knock coins
canvas.addEventListener('click', e => {
  const clickX = e.clientX;
  const clickY = e.clientY;

  for (const coin of coins) {
    if (coin.collected) continue;
    const dx = clickX - coin.x;
    const dy = clickY - coin.y;
    const dist = Math.sqrt(dx * dx + dy * dy);

    if (dist < coin.radius + 30) {
      coin.vx += (coin.x - clickX) * 0.15;
      coin.vy += (coin.y - clickY) * 0.15 - 5;
      spawnParticle(coin.x, coin.y, coin.color);
    }
  }
});

// Keyboard
window.addEventListener('keydown', e => {
  keys[e.code] = true;
  if (['Space', 'ArrowUp', 'ArrowDown'].includes(e.code)) {
    e.preventDefault();
  }
});

window.addEventListener('keyup', e => {
  keys[e.code] = false;
});

// Touch controls
let touchStartX = 0;
canvas.addEventListener('touchstart', e => {
  touchStartX = e.touches[0].clientX;
  const touchY = e.touches[0].clientY;

  // Flap if touch is in upper half
  if (touchY < canvas.height / 2) {
    keys['Space'] = true;
    setTimeout(() => keys['Space'] = false, 100);
  }

  // Knock coins
  for (const coin of coins) {
    if (coin.collected) continue;
    const dx = touchStartX - coin.x;
    const dy = touchY - coin.y;
    const dist = Math.sqrt(dx * dx + dy * dy);
    if (dist < coin.radius + 50) {
      coin.vx += (coin.x - touchStartX) * 0.15;
      coin.vy += (coin.y - touchY) * 0.15 - 5;
      spawnParticle(coin.x, coin.y, coin.color);
    }
  }
});

canvas.addEventListener('touchmove', e => {
  e.preventDefault();
  const touchX = e.touches[0].clientX;
  const diff = touchX - touchStartX;

  keys['ArrowLeft'] = diff < -20;
  keys['ArrowRight'] = diff > 20;
});

canvas.addEventListener('touchend', () => {
  keys['ArrowLeft'] = false;
  keys['ArrowRight'] = false;
});

window.addEventListener('resize', resize);

resize();
gameLoop();
</script>
</body>
</html>
