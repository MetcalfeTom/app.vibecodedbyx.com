<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
  <title>Graffiti Wall - Draw Together</title>
  <link rel="icon" href="https://emojicdn.elk.sh/üé®">
  <meta property="og:title" content="Graffiti Wall - Draw Together">
  <meta property="og:description" content="Collaborative graffiti wall - spray paint with everyone in realtime!">
  <meta property="og:url" content="https://sloppy.live/graffiti-wall">
  <meta property="og:image" content="https://emojicdn.elk.sh/üé®?style=apple&size=512">
  <link href="https://fonts.googleapis.com/css2?family=Permanent+Marker&family=Bebas+Neue&display=swap" rel="stylesheet">
  <script src="https://unpkg.com/@supabase/supabase-js@2"></script>
  <script src="/supabase-config.js"></script>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }

    body {
      font-family: 'Bebas Neue', sans-serif;
      background: #0a0a0a;
      min-height: 100vh;
      overflow: hidden;
      user-select: none;
      -webkit-user-select: none;
    }

    .wall-container {
      position: relative;
      width: 100vw;
      height: 100vh;
    }

    #wallCanvas {
      display: block;
      width: 100%;
      height: 100%;
      cursor: crosshair;
    }

    /* Brick wall pattern overlay */
    .brick-overlay {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
      opacity: 0.15;
      background-image:
        linear-gradient(to right, #333 1px, transparent 1px),
        linear-gradient(to bottom, #333 1px, transparent 1px),
        linear-gradient(to right, #222 1px, transparent 1px);
      background-size: 60px 30px, 60px 30px, 30px 30px;
      background-position: 0 0, 30px 15px, 0 0;
    }

    .toolbar {
      position: fixed;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      display: flex;
      gap: 10px;
      align-items: center;
      background: rgba(0, 0, 0, 0.8);
      padding: 12px 20px;
      border-radius: 50px;
      border: 2px solid #333;
      box-shadow: 0 0 30px rgba(0, 0, 0, 0.5);
      z-index: 100;
    }

    .color-btn {
      width: 36px;
      height: 36px;
      border-radius: 50%;
      border: 3px solid #222;
      cursor: pointer;
      transition: all 0.2s;
      position: relative;
    }

    .color-btn:hover {
      transform: scale(1.2);
    }

    .color-btn.active {
      border-color: #fff;
      box-shadow: 0 0 15px currentColor;
    }

    .color-btn::after {
      content: '';
      position: absolute;
      inset: 2px;
      border-radius: 50%;
      background: inherit;
      filter: blur(4px);
      opacity: 0.6;
    }

    .divider {
      width: 2px;
      height: 30px;
      background: #333;
      margin: 0 5px;
    }

    .size-btn {
      width: 40px;
      height: 40px;
      border-radius: 50%;
      background: #1a1a1a;
      border: 2px solid #333;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      transition: all 0.2s;
    }

    .size-btn:hover {
      border-color: #666;
    }

    .size-btn.active {
      border-color: #fff;
      background: #333;
    }

    .size-dot {
      background: #fff;
      border-radius: 50%;
    }

    .tool-btn {
      width: 40px;
      height: 40px;
      border-radius: 50%;
      background: #1a1a1a;
      border: 2px solid #333;
      color: #888;
      font-size: 1.2rem;
      cursor: pointer;
      transition: all 0.2s;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .tool-btn:hover {
      border-color: #666;
      color: #fff;
    }

    .header {
      position: fixed;
      top: 20px;
      left: 50%;
      transform: translateX(-50%);
      text-align: center;
      z-index: 100;
      pointer-events: none;
      opacity: 0.8;
      transition: opacity 0.5s;
    }

    .header.hidden {
      opacity: 0;
    }

    .title {
      font-family: 'Permanent Marker', cursive;
      font-size: 2.5rem;
      background: linear-gradient(90deg, #ff00ff, #00ffff, #ffff00, #ff00ff);
      background-size: 300% 100%;
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
      animation: gradientShift 3s ease infinite;
      filter: drop-shadow(0 0 10px rgba(255, 0, 255, 0.5));
    }

    @keyframes gradientShift {
      0%, 100% { background-position: 0% 50%; }
      50% { background-position: 100% 50%; }
    }

    .subtitle {
      font-size: 0.9rem;
      color: #666;
      letter-spacing: 3px;
    }

    .spray-cursor {
      position: fixed;
      pointer-events: none;
      z-index: 1000;
      transform: translate(-50%, -50%);
    }

    .spray-ring {
      border: 2px dashed rgba(255, 255, 255, 0.5);
      border-radius: 50%;
      animation: pulse 1s ease-in-out infinite;
    }

    @keyframes pulse {
      0%, 100% { opacity: 0.5; }
      50% { opacity: 1; }
    }

    .back-link {
      position: fixed;
      top: 15px;
      right: 15px;
      color: #444;
      text-decoration: none;
      font-size: 0.8rem;
      z-index: 100;
      letter-spacing: 2px;
    }

    .back-link:hover { color: #0ff; }

    /* Spray effect when painting */
    .spraying .spray-ring {
      animation: spray 0.1s ease-in-out infinite;
    }

    @keyframes spray {
      0%, 100% { transform: scale(1); }
      50% { transform: scale(1.1); }
    }

    /* Other artists' cursors */
    .other-cursor {
      position: fixed;
      pointer-events: none;
      z-index: 999;
      transform: translate(-50%, -50%);
      transition: left 0.05s, top 0.05s;
    }

    .other-cursor-ring {
      border: 2px solid;
      border-radius: 50%;
      opacity: 0.7;
    }

    .other-cursor-name {
      position: absolute;
      top: 100%;
      left: 50%;
      transform: translateX(-50%);
      font-size: 0.7rem;
      color: #fff;
      background: rgba(0,0,0,0.6);
      padding: 2px 6px;
      border-radius: 3px;
      white-space: nowrap;
      margin-top: 5px;
    }

    .artists-online {
      position: fixed;
      top: 15px;
      left: 15px;
      color: #0ff;
      font-size: 0.8rem;
      z-index: 100;
      letter-spacing: 2px;
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .pulse-dot {
      width: 8px;
      height: 8px;
      background: #0f0;
      border-radius: 50%;
      animation: pulseDot 1.5s ease-in-out infinite;
    }

    @keyframes pulseDot {
      0%, 100% { opacity: 1; box-shadow: 0 0 5px #0f0; }
      50% { opacity: 0.5; box-shadow: 0 0 15px #0f0; }
    }

    @media (max-width: 600px) {
      .title { font-size: 1.5rem; }
      .toolbar {
        padding: 8px 12px;
        gap: 6px;
        bottom: 10px;
      }
      .color-btn { width: 28px; height: 28px; }
      .size-btn, .tool-btn { width: 32px; height: 32px; }
      .header { top: 10px; }
    }
  </style>
</head>
<body>
  <div class="wall-container">
    <canvas id="wallCanvas"></canvas>
    <div class="brick-overlay"></div>
  </div>

  <div class="header" id="header">
    <h1 class="title">GRAFFITI WALL</h1>
    <p class="subtitle">DRAW TOGETHER</p>
  </div>

  <div class="artists-online" id="artistsOnline">
    <div class="pulse-dot"></div>
    <span id="artistCount">1 artist</span>
  </div>

  <div class="toolbar">
    <button class="color-btn active" data-color="#ff00ff" style="background: #ff00ff;" title="Magenta"></button>
    <button class="color-btn" data-color="#00ffff" style="background: #00ffff;" title="Cyan"></button>
    <button class="color-btn" data-color="#ffff00" style="background: #ffff00;" title="Yellow"></button>
    <button class="color-btn" data-color="#ff3300" style="background: #ff3300;" title="Red"></button>
    <button class="color-btn" data-color="#00ff66" style="background: #00ff66;" title="Green"></button>
    <button class="color-btn" data-color="#ff66cc" style="background: #ff66cc;" title="Pink"></button>
    <button class="color-btn" data-color="#ffffff" style="background: #ffffff;" title="White"></button>

    <div class="divider"></div>

    <button class="size-btn" data-size="15" title="Small">
      <div class="size-dot" style="width: 6px; height: 6px;"></div>
    </button>
    <button class="size-btn active" data-size="30" title="Medium">
      <div class="size-dot" style="width: 12px; height: 12px;"></div>
    </button>
    <button class="size-btn" data-size="50" title="Large">
      <div class="size-dot" style="width: 18px; height: 18px;"></div>
    </button>

    <div class="divider"></div>

    <button class="tool-btn" id="clearBtn" title="Clear Wall">üóëÔ∏è</button>
    <button class="tool-btn" id="saveBtn" title="Save Art">üíæ</button>
  </div>

  <div class="spray-cursor" id="sprayCursor">
    <div class="spray-ring" id="sprayRing"></div>
  </div>

  <a href="https://sloppy.live" class="back-link">‚Üê sloppy.live</a>

  <script>
    const canvas = document.getElementById('wallCanvas');
    const ctx = canvas.getContext('2d');
    const sprayCursor = document.getElementById('sprayCursor');
    const sprayRing = document.getElementById('sprayRing');
    const header = document.getElementById('header');
    const artistCountEl = document.getElementById('artistCount');

    let currentColor = '#ff00ff';
    let brushSize = 30;
    let isDrawing = false;
    let lastX = 0;
    let lastY = 0;
    let hasDrawn = false;

    // Supabase & collaboration state
    var supabase = null;
    var channel = null;
    var myArtistId = 'artist_' + Math.random().toString(36).substr(2, 9);
    var myArtistName = generateArtistName();
    var otherArtists = {};
    var otherCursors = {};

    function generateArtistName() {
      var adjectives = ['Neon', 'Cyber', 'Rad', 'Funky', 'Wild', 'Cosmic', 'Electric', 'Mystic', 'Urban', 'Shadow'];
      var nouns = ['Painter', 'Bomber', 'Artist', 'Sprayer', 'Writer', 'Creator', 'Vandal', 'Master', 'Wizard', 'Ghost'];
      return adjectives[Math.floor(Math.random() * adjectives.length)] + nouns[Math.floor(Math.random() * nouns.length)];
    }

    // Set canvas size
    function resizeCanvas() {
      const tempCanvas = document.createElement('canvas');
      const tempCtx = tempCanvas.getContext('2d');
      tempCanvas.width = canvas.width;
      tempCanvas.height = canvas.height;
      tempCtx.drawImage(canvas, 0, 0);

      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;

      // Restore content
      ctx.drawImage(tempCanvas, 0, 0);

      // Draw initial wall if empty
      if (!hasDrawn) {
        drawWallBackground();
      }
    }

    function drawWallBackground() {
      // Dark gradient background
      const gradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
      gradient.addColorStop(0, '#1a1a2e');
      gradient.addColorStop(1, '#0a0a12');
      ctx.fillStyle = gradient;
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      // Add some texture/noise
      for (let i = 0; i < 5000; i++) {
        const x = Math.random() * canvas.width;
        const y = Math.random() * canvas.height;
        const alpha = Math.random() * 0.03;
        ctx.fillStyle = `rgba(255, 255, 255, ${alpha})`;
        ctx.fillRect(x, y, 1, 1);
      }
    }

    // Spray paint effect
    function spray(x, y, broadcast) {
      const density = brushSize * 2;

      for (let i = 0; i < density; i++) {
        // Random point within circle using gaussian-like distribution
        const angle = Math.random() * Math.PI * 2;
        const radius = Math.random() * brushSize * 0.5 + Math.random() * brushSize * 0.5;

        const px = x + Math.cos(angle) * radius;
        const py = y + Math.sin(angle) * radius;

        // Particle size varies
        const size = Math.random() * 3 + 1;

        // Alpha based on distance from center
        const dist = Math.sqrt((px - x) ** 2 + (py - y) ** 2);
        const alpha = Math.max(0, 1 - dist / brushSize) * 0.3;

        ctx.beginPath();
        ctx.arc(px, py, size, 0, Math.PI * 2);
        ctx.fillStyle = hexToRgba(currentColor, alpha);
        ctx.fill();
      }

      // Add glow effect at center
      const glowGradient = ctx.createRadialGradient(x, y, 0, x, y, brushSize * 0.3);
      glowGradient.addColorStop(0, hexToRgba(currentColor, 0.1));
      glowGradient.addColorStop(1, hexToRgba(currentColor, 0));
      ctx.fillStyle = glowGradient;
      ctx.beginPath();
      ctx.arc(x, y, brushSize * 0.3, 0, Math.PI * 2);
      ctx.fill();

      // Broadcast and save if this is a local spray
      if (broadcast !== false) {
        broadcastSpray(x, y);
        saveStroke(x, y, currentColor, brushSize);
      }
    }

    function hexToRgba(hex, alpha) {
      const r = parseInt(hex.slice(1, 3), 16);
      const g = parseInt(hex.slice(3, 5), 16);
      const b = parseInt(hex.slice(5, 7), 16);
      return `rgba(${r}, ${g}, ${b}, ${alpha})`;
    }

    // Interpolate spray between points for smooth lines
    // Only the last point broadcasts/saves to reduce overhead
    function sprayLine(x1, y1, x2, y2) {
      const dist = Math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2);
      const steps = Math.max(1, Math.floor(dist / 5));

      for (let i = 0; i <= steps; i++) {
        const t = i / steps;
        const x = x1 + (x2 - x1) * t;
        const y = y1 + (y2 - y1) * t;
        // Only broadcast/save final point of line segment
        spray(x, y, i === steps);
      }
    }

    // Update cursor
    function updateCursor(x, y) {
      sprayCursor.style.left = x + 'px';
      sprayCursor.style.top = y + 'px';
      sprayRing.style.width = brushSize + 'px';
      sprayRing.style.height = brushSize + 'px';
      sprayRing.style.borderColor = currentColor;

      // Throttled cursor broadcast
      var now = Date.now();
      if (now - lastCursorBroadcast > cursorBroadcastInterval) {
        broadcastCursor(x, y);
        lastCursorBroadcast = now;
      }
    }

    // Event handlers
    function startDrawing(x, y) {
      isDrawing = true;
      hasDrawn = true;
      lastX = x;
      lastY = y;
      spray(x, y);
      sprayCursor.classList.add('spraying');
      header.classList.add('hidden');
    }

    function draw(x, y) {
      if (!isDrawing) return;
      sprayLine(lastX, lastY, x, y);
      lastX = x;
      lastY = y;
    }

    function stopDrawing() {
      isDrawing = false;
      sprayCursor.classList.remove('spraying');
    }

    // Mouse events
    canvas.addEventListener('mousedown', (e) => {
      startDrawing(e.clientX, e.clientY);
    });

    canvas.addEventListener('mousemove', (e) => {
      updateCursor(e.clientX, e.clientY);
      draw(e.clientX, e.clientY);
    });

    canvas.addEventListener('mouseup', stopDrawing);
    canvas.addEventListener('mouseleave', stopDrawing);

    // Touch events
    canvas.addEventListener('touchstart', (e) => {
      e.preventDefault();
      const touch = e.touches[0];
      updateCursor(touch.clientX, touch.clientY);
      startDrawing(touch.clientX, touch.clientY);
    });

    canvas.addEventListener('touchmove', (e) => {
      e.preventDefault();
      const touch = e.touches[0];
      updateCursor(touch.clientX, touch.clientY);
      draw(touch.clientX, touch.clientY);
    });

    canvas.addEventListener('touchend', stopDrawing);

    // Color buttons
    document.querySelectorAll('.color-btn').forEach(btn => {
      btn.addEventListener('click', () => {
        document.querySelectorAll('.color-btn').forEach(b => b.classList.remove('active'));
        btn.classList.add('active');
        currentColor = btn.dataset.color;
        sprayRing.style.borderColor = currentColor;
      });
    });

    // Size buttons
    document.querySelectorAll('.size-btn').forEach(btn => {
      btn.addEventListener('click', () => {
        document.querySelectorAll('.size-btn').forEach(b => b.classList.remove('active'));
        btn.classList.add('active');
        brushSize = parseInt(btn.dataset.size);
        sprayRing.style.width = brushSize + 'px';
        sprayRing.style.height = brushSize + 'px';
      });
    });

    // Clear button
    document.getElementById('clearBtn').addEventListener('click', () => {
      if (confirm('Clear the entire wall?')) {
        hasDrawn = false;
        drawWallBackground();
        header.classList.remove('hidden');
      }
    });

    // Save button
    document.getElementById('saveBtn').addEventListener('click', () => {
      const link = document.createElement('a');
      link.download = 'graffiti-collab-' + Date.now() + '.png';
      link.href = canvas.toDataURL('image/png');
      link.click();
    });

    // ========== REALTIME COLLABORATION ==========

    function initSupabase() {
      if (typeof window.SUPABASE_URL === 'undefined') {
        console.log('Supabase config not found, running in local mode');
        return;
      }

      supabase = window.supabase.createClient(window.SUPABASE_URL, window.SUPABASE_ANON_KEY);

      // Set up realtime channel
      channel = supabase.channel('graffiti-wall', {
        config: { presence: { key: myArtistId } }
      });

      // Handle presence (who's online)
      channel.on('presence', { event: 'sync' }, function() {
        var state = channel.presenceState();
        var count = Object.keys(state).length;
        artistCountEl.textContent = count + (count === 1 ? ' artist' : ' artists');

        // Update tracked artists
        var currentIds = {};
        Object.keys(state).forEach(function(key) {
          var presences = state[key];
          if (presences && presences.length > 0) {
            var artist = presences[0];
            currentIds[artist.id] = true;
            if (artist.id !== myArtistId) {
              otherArtists[artist.id] = artist;
            }
          }
        });

        // Remove cursors for artists who left
        Object.keys(otherCursors).forEach(function(id) {
          if (!currentIds[id]) {
            if (otherCursors[id]) {
              otherCursors[id].remove();
              delete otherCursors[id];
            }
            delete otherArtists[id];
          }
        });
      });

      // Handle broadcast messages (spray strokes and cursor moves)
      channel.on('broadcast', { event: 'spray' }, function(payload) {
        var data = payload.payload;
        if (data.artistId !== myArtistId) {
          sprayRemote(data.x, data.y, data.color, data.size);
        }
      });

      channel.on('broadcast', { event: 'cursor' }, function(payload) {
        var data = payload.payload;
        if (data.artistId !== myArtistId) {
          updateOtherCursor(data.artistId, data.name, data.x, data.y, data.color, data.size);
        }
      });

      // Subscribe to channel
      channel.subscribe(function(status) {
        if (status === 'SUBSCRIBED') {
          channel.track({
            id: myArtistId,
            name: myArtistName,
            color: currentColor
          });
        }
      });

      // Load existing strokes from database
      loadExistingStrokes();
    }

    function loadExistingStrokes() {
      if (!supabase) return;

      supabase
        .from('graffiti_strokes')
        .select('*')
        .order('created_at', { ascending: true })
        .then(function(response) {
          if (response.error) {
            console.log('Error loading strokes:', response.error);
            return;
          }
          if (response.data && response.data.length > 0) {
            hasDrawn = true;
            header.classList.add('hidden');
            response.data.forEach(function(stroke) {
              sprayRemote(stroke.x, stroke.y, stroke.color, stroke.size);
            });
          }
        });
    }

    function saveStroke(x, y, color, size) {
      if (!supabase) return;

      supabase
        .from('graffiti_strokes')
        .insert({
          x: Math.round(x),
          y: Math.round(y),
          color: color,
          size: size,
          artist_name: myArtistName
        })
        .then(function(response) {
          if (response.error) {
            console.log('Error saving stroke:', response.error);
          }
        });
    }

    function broadcastSpray(x, y) {
      if (!channel) return;

      channel.send({
        type: 'broadcast',
        event: 'spray',
        payload: {
          artistId: myArtistId,
          x: x,
          y: y,
          color: currentColor,
          size: brushSize
        }
      });
    }

    function broadcastCursor(x, y) {
      if (!channel) return;

      channel.send({
        type: 'broadcast',
        event: 'cursor',
        payload: {
          artistId: myArtistId,
          name: myArtistName,
          x: x,
          y: y,
          color: currentColor,
          size: brushSize
        }
      });
    }

    function sprayRemote(x, y, color, size) {
      // Spray effect for remote artists
      var density = size * 1.5;

      for (var i = 0; i < density; i++) {
        var angle = Math.random() * Math.PI * 2;
        var radius = Math.random() * size * 0.5 + Math.random() * size * 0.5;

        var px = x + Math.cos(angle) * radius;
        var py = y + Math.sin(angle) * radius;

        var particleSize = Math.random() * 3 + 1;

        var dist = Math.sqrt((px - x) * (px - x) + (py - y) * (py - y));
        var alpha = Math.max(0, 1 - dist / size) * 0.3;

        ctx.beginPath();
        ctx.arc(px, py, particleSize, 0, Math.PI * 2);
        ctx.fillStyle = hexToRgba(color, alpha);
        ctx.fill();
      }

      // Glow effect
      var glowGradient = ctx.createRadialGradient(x, y, 0, x, y, size * 0.3);
      glowGradient.addColorStop(0, hexToRgba(color, 0.1));
      glowGradient.addColorStop(1, hexToRgba(color, 0));
      ctx.fillStyle = glowGradient;
      ctx.beginPath();
      ctx.arc(x, y, size * 0.3, 0, Math.PI * 2);
      ctx.fill();
    }

    function updateOtherCursor(artistId, name, x, y, color, size) {
      var cursor = otherCursors[artistId];

      if (!cursor) {
        // Create new cursor element
        cursor = document.createElement('div');
        cursor.className = 'other-cursor';
        cursor.innerHTML = '<div class="other-cursor-ring"></div><div class="other-cursor-name">' + name + '</div>';
        document.body.appendChild(cursor);
        otherCursors[artistId] = cursor;
      }

      cursor.style.left = x + 'px';
      cursor.style.top = y + 'px';

      var ring = cursor.querySelector('.other-cursor-ring');
      ring.style.width = size + 'px';
      ring.style.height = size + 'px';
      ring.style.borderColor = color;
    }

    // Throttle cursor broadcasts
    var lastCursorBroadcast = 0;
    var cursorBroadcastInterval = 50; // ms

    // ========== END REALTIME ==========

    // Initialize
    window.addEventListener('resize', resizeCanvas);
    resizeCanvas();
    initSupabase();

    // Hide cursor when outside window
    document.addEventListener('mouseleave', () => {
      sprayCursor.style.display = 'none';
    });

    document.addEventListener('mouseenter', () => {
      sprayCursor.style.display = 'block';
    });

    // Initial cursor setup
    sprayRing.style.borderColor = currentColor;
    sprayRing.style.width = brushSize + 'px';
    sprayRing.style.height = brushSize + 'px';
  </script>
  <script src="/sloppy-header/sloppy-bar.js"></script>
</body>
</html>
