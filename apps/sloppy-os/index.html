<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>SloppyOS</title>
  <link rel="icon" href="https://emojicdn.elk.sh/üíæ">
  <meta property="og:title" content="SloppyOS">
  <meta property="og:description" content="Explore the neon mansion hallway - each door leads to a new world">
  <meta property="og:url" content="https://sloppy.live/sloppy-os">
  <meta property="og:image" content="https://emojicdn.elk.sh/üíæ?style=apple&size=512">
  <link href="https://fonts.googleapis.com/css2?family=Share+Tech+Mono&family=Orbitron:wght@400;700;900&display=swap" rel="stylesheet">
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body { background: #000; overflow: hidden; font-family: 'Share Tech Mono', monospace; }
    #canvas-container { position: fixed; top: 0; left: 0; width: 100%; height: 100%; }
    canvas { display: block; }

    .boot-screen {
      position: fixed; top: 0; left: 0; width: 100%; height: 100%;
      background: #000; display: flex; flex-direction: column;
      align-items: center; justify-content: center; z-index: 10000;
      transition: opacity 0.5s, visibility 0.5s;
    }
    .boot-screen.hidden { opacity: 0; visibility: hidden; pointer-events: none; }
    .boot-logo {
      font-family: 'Orbitron', sans-serif; font-size: 2.5rem; font-weight: 900;
      color: #00ffff; text-shadow: 0 0 20px #00ffff, 0 0 40px #ff00ff;
      animation: pulse 1s ease-in-out infinite;
    }
    @keyframes pulse { 0%, 100% { opacity: 1; } 50% { opacity: 0.7; } }
    .boot-text { margin-top: 30px; color: #00ff88; font-size: 0.9rem; }
    .boot-progress { width: 300px; height: 4px; background: rgba(0,255,255,0.2); margin-top: 20px; border-radius: 2px; overflow: hidden; }
    .boot-progress-fill { height: 100%; width: 0%; background: linear-gradient(90deg, #00ffff, #ff00ff); transition: width 0.1s; }

    .hud { position: fixed; top: 0; left: 0; width: 100%; pointer-events: none; z-index: 100; }
    .hud-top { position: absolute; top: 15px; left: 20px; right: 20px; display: flex; justify-content: space-between; }
    .os-logo { font-family: 'Orbitron'; font-weight: 700; font-size: 1rem; color: #00ffff; text-shadow: 0 0 10px #00ffff; }
    .clock { color: #ffff00; font-family: 'Orbitron'; font-weight: 700; text-shadow: 0 0 10px #ffff00; }

    .crosshair {
      position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%);
      width: 20px; height: 20px; border: 2px solid #00ffff; border-radius: 50%;
      opacity: 0.7; box-shadow: 0 0 10px #00ffff; z-index: 100; pointer-events: none;
    }
    .crosshair::before, .crosshair::after { content: ''; position: absolute; background: #00ffff; box-shadow: 0 0 5px #00ffff; }
    .crosshair::before { width: 2px; height: 6px; top: 50%; left: 50%; transform: translate(-50%, -50%); }
    .crosshair::after { width: 6px; height: 2px; top: 50%; left: 50%; transform: translate(-50%, -50%); }

    .app-info {
      position: fixed; bottom: 100px; left: 50%; transform: translateX(-50%);
      background: rgba(10,10,25,0.95); border: 2px solid #00ffff; border-radius: 10px;
      padding: 15px 30px; text-align: center; z-index: 100; opacity: 0;
      transition: opacity 0.2s; pointer-events: none;
    }
    .app-info.visible { opacity: 1; }
    .app-info h3 { font-family: 'Orbitron'; color: #00ffff; font-size: 1.2rem; text-shadow: 0 0 10px #00ffff; margin-bottom: 5px; }
    .app-info p { color: #aaa; font-size: 0.85rem; }

    .stream-link-btn {
      position: fixed; top: 15px; right: 20px; display: flex; align-items: center; gap: 8px;
      padding: 10px 18px; background: linear-gradient(135deg, #9146ff, #772ce8);
      border: 2px solid #9146ff; border-radius: 25px; color: #fff; text-decoration: none;
      font-family: 'Orbitron'; font-size: 0.8rem; font-weight: 700; z-index: 200;
      pointer-events: auto; transition: all 0.3s; box-shadow: 0 0 20px rgba(145,70,255,0.4);
    }
    .stream-link-btn:hover { transform: scale(1.05); box-shadow: 0 0 35px rgba(145,70,255,0.7); }
    .stream-pulse { position: absolute; top: -3px; right: -3px; width: 10px; height: 10px; background: #ff0044; border-radius: 50%; animation: live-pulse 1.5s ease-in-out infinite; }
    @keyframes live-pulse { 0%, 100% { transform: scale(1); opacity: 1; } 50% { transform: scale(1.3); opacity: 0.7; } }

    .snapshot-btn {
      position: fixed; top: 15px; right: 140px; display: flex; align-items: center; gap: 8px;
      padding: 10px 18px; background: linear-gradient(135deg, #00ffff, #0088aa);
      border: 2px solid #00ffff; border-radius: 25px; color: #000; text-decoration: none;
      font-family: 'Orbitron'; font-size: 0.8rem; font-weight: 700; z-index: 200;
      pointer-events: auto; transition: all 0.3s; box-shadow: 0 0 20px rgba(0,255,255,0.4);
      cursor: pointer;
    }
    .snapshot-btn:hover { transform: scale(1.05); box-shadow: 0 0 35px rgba(0,255,255,0.7); background: #00ffff; }
    .snapshot-btn:active { transform: scale(0.95); }

    .flash-overlay {
      position: fixed; top: 0; left: 0; width: 100%; height: 100%;
      background: #fff; opacity: 0; pointer-events: none; z-index: 9998;
      transition: opacity 0.1s;
    }
    .flash-overlay.flash { opacity: 1; animation: flashAnim 0.4s ease-out forwards; }
    @keyframes flashAnim { 0% { opacity: 1; } 100% { opacity: 0; } }

    .snapshot-preview {
      position: fixed; bottom: 100px; right: 20px; background: rgba(10,10,25,0.95);
      border: 3px solid #00ffff; border-radius: 15px; padding: 15px; z-index: 300;
      display: none; box-shadow: 0 0 30px rgba(0,255,255,0.5);
      animation: slideIn 0.3s ease-out;
    }
    @keyframes slideIn { from { transform: translateX(100px); opacity: 0; } to { transform: translateX(0); opacity: 1; } }
    .snapshot-preview.visible { display: block; }
    .snapshot-preview img { max-width: 200px; border-radius: 8px; border: 2px solid #333; }
    .snapshot-preview h4 { font-family: 'Orbitron'; color: #00ffff; font-size: 0.8rem; margin-bottom: 10px; text-align: center; }
    .snapshot-actions { display: flex; gap: 8px; margin-top: 10px; justify-content: center; }
    .snapshot-action-btn {
      padding: 6px 12px; border: none; border-radius: 15px; font-family: 'Orbitron';
      font-size: 0.7rem; cursor: pointer; transition: all 0.2s;
    }
    .snapshot-action-btn.save { background: linear-gradient(135deg, #00ff88, #00aa55); color: #000; }
    .snapshot-action-btn.close { background: #333; color: #fff; border: 1px solid #666; }
    .snapshot-action-btn:hover { transform: scale(1.05); }

    .pet-container { position: fixed; bottom: 20px; right: 20px; z-index: 200; pointer-events: auto; }
    .pet-btn { width: 60px; height: 60px; background: rgba(10,10,25,0.9); border: 2px solid #ff00ff; border-radius: 50%; display: flex; align-items: center; justify-content: center; font-size: 2rem; cursor: pointer; transition: all 0.3s; box-shadow: 0 0 20px rgba(255,0,255,0.4); animation: pet-float 3s ease-in-out infinite; }
    @keyframes pet-float { 0%, 100% { transform: translateY(0); } 50% { transform: translateY(-5px); } }
    .pet-btn:hover { transform: scale(1.1); box-shadow: 0 0 30px rgba(255,0,255,0.6); }
    .pet-popup { position: absolute; bottom: 70px; right: 0; background: rgba(10,10,25,0.98); border: 2px solid #ff00ff; border-radius: 15px; padding: 20px; min-width: 180px; text-align: center; display: none; box-shadow: 0 0 30px rgba(255,0,255,0.4); }
    .pet-popup.open { display: block; }
    .pet-popup h3 { font-family: 'Orbitron'; color: #ff00ff; font-size: 0.9rem; margin-bottom: 10px; }
    .pet-display { font-size: 2.5rem; margin: 10px 0; }
    .pet-status { font-size: 0.75rem; color: #00ffff; }
    .pet-actions { display: flex; gap: 8px; justify-content: center; margin-top: 12px; }
    .pet-action-btn { padding: 6px 12px; background: linear-gradient(135deg, #00ffff, #ff00ff); border: none; border-radius: 15px; color: #000; font-size: 0.7rem; cursor: pointer; transition: all 0.2s; }
    .pet-action-btn:hover { transform: scale(1.1); }

    .instructions { position: fixed; bottom: 20px; left: 20px; color: #666; font-size: 0.75rem; z-index: 100; pointer-events: none; }
    .instructions span { color: #00ffff; }

    .click-to-start { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.8); display: flex; flex-direction: column; align-items: center; justify-content: center; z-index: 500; cursor: pointer; }
    .click-to-start.hidden { display: none; }
    .click-to-start h2 { font-family: 'Orbitron'; color: #00ffff; font-size: 2rem; text-shadow: 0 0 20px #00ffff; animation: pulse 1s ease-in-out infinite; }
    .click-to-start p { color: #888; margin-top: 15px; }

    .mobile-controls { display: none; position: fixed; bottom: 20px; left: 20px; z-index: 200; pointer-events: auto; gap: 10px; }
    @media (max-width: 768px) { .mobile-controls { display: flex; } .instructions { display: none; } }
    .mobile-btn { width: 50px; height: 50px; background: rgba(0,255,255,0.2); border: 2px solid #00ffff; border-radius: 10px; color: #00ffff; font-size: 1.5rem; display: flex; align-items: center; justify-content: center; }

    .scanlines { position: fixed; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 9999; background: repeating-linear-gradient(0deg, rgba(0,0,0,0.05) 0px, rgba(0,0,0,0.05) 1px, transparent 1px, transparent 2px); }
  </style>
</head>
<body>
  <div class="boot-screen" id="boot-screen">
    <div class="boot-logo">SloppyOS Mansion</div>
    <div class="boot-text" id="boot-text">Initializing hallway...</div>
    <div class="boot-progress"><div class="boot-progress-fill" id="boot-progress"></div></div>
  </div>

  <div class="click-to-start hidden" id="click-to-start">
    <h2>ENTER THE MANSION</h2>
    <p>WASD to walk, Mouse to look, Click doors to enter</p>
  </div>

  <div id="canvas-container"></div>
  <div class="scanlines"></div>

  <div class="hud">
    <div class="hud-top">
      <div class="os-logo">üíæ SloppyOS Mansion</div>
      <div class="clock" id="clock">00:00:00</div>
    </div>
  </div>

  <div class="crosshair"></div>

  <div class="app-info" id="app-info">
    <h3 id="app-name">App Name</h3>
    <p>Click to enter</p>
  </div>

  <button class="snapshot-btn" id="snapshot-btn">
    <span>üì∏</span><span>SNAP</span>
  </button>

  <a href="https://twitch.tv/sloppy_ai" target="_blank" class="stream-link-btn">
    <span class="stream-pulse"></span><span>üì°</span><span>LIVE</span>
  </a>

  <div class="flash-overlay" id="flash-overlay"></div>

  <div class="snapshot-preview" id="snapshot-preview">
    <h4>üì∏ SNAPSHOT</h4>
    <img id="snapshot-img" src="" alt="Snapshot">
    <div class="snapshot-actions">
      <button class="snapshot-action-btn save" id="snapshot-save">üíæ Save</button>
      <button class="snapshot-action-btn close" id="snapshot-close">‚úï</button>
    </div>
  </div>

  <div class="pet-container">
    <div class="pet-btn" id="pet-btn">ü•ö</div>
    <div class="pet-popup" id="pet-popup">
      <h3>Virtual Pet</h3>
      <div class="pet-display" id="pet-display">ü•ö</div>
      <div class="pet-status" id="pet-status">Click to hatch!</div>
      <div class="pet-actions">
        <button class="pet-action-btn" id="pet-interact">ü§ö Pet</button>
        <button class="pet-action-btn" id="pet-feed">üçï Feed</button>
      </div>
    </div>
  </div>

  <div class="instructions"><span>WASD</span> Walk | <span>Mouse</span> Look | <span>Click</span> Enter Door</div>

  <div class="mobile-controls">
    <div class="mobile-btn" id="mobile-forward">‚Üë</div>
    <div class="mobile-btn" id="mobile-left">‚Üê</div>
    <div class="mobile-btn" id="mobile-right">‚Üí</div>
  </div>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/GLTFLoader.js"></script>
  <script>
    // Apps for left and right doors
    const leftDoors = [
      { name: 'Space Flight', icon: 'üöÄ', url: '/space-flight', color: 0x00ffff },
      { name: 'Moon Explorer', icon: 'üåô', url: '/moon-explorer', color: 0xaaaaff },
      { name: 'Minecraft', icon: '‚õèÔ∏è', url: '/minecraft', color: 0x00ff00 },
      { name: 'Doom 3D', icon: 'üëπ', url: '/doom-3d', color: 0xff0044 },
      { name: 'Motorbike Racing', icon: 'üèçÔ∏è', url: '/motorbike-racing', color: 0xff6600 },
      { name: 'Neon Bowling', icon: 'üé≥', url: '/neon-bowling', color: 0xff00ff }
    ];

    const rightDoors = [
      { name: 'Voxel World', icon: 'üß±', url: '/voxel-world', color: 0x00ff88 },
      { name: 'Disco Ball', icon: 'ü™©', url: '/disco-ball', color: 0xffff00 },
      { name: 'Space Chess', icon: '‚ôüÔ∏è', url: '/space-chess', color: 0x4488ff },
      { name: 'Bikini Brawl', icon: 'ü•ä', url: '/bikini-bottom-brawl', color: 0xffaa00 },
      { name: 'Eggcraft', icon: 'ü•ö', url: '/eggcraft', color: 0xffddaa },
      { name: 'Sneaker Room', icon: 'üëü', url: null, color: 0xff00ff, special: 'sneakers' }
    ];

    let scene, camera, renderer, raycaster;
    let doors = [];
    let moveForward = false, moveBackward = false, moveLeft = false, moveRight = false;
    let velocity = new THREE.Vector3();
    let direction = new THREE.Vector3();
    let isLocked = false;
    let euler = new THREE.Euler(0, Math.PI, 0, 'YXZ'); // Face toward hallway (180 degrees)
    const PI_2 = Math.PI / 2;

    // Room state
    let currentRoom = 'hallway';
    let hallwayObjects = [];
    let sneakerRoomObjects = [];
    let sneakers = [];
    let exitPortal = null;

    const hallwayLength = 80;
    const hallwayWidth = 8;
    const hallwayHeight = 6;
    const doorSpacing = 12;

    function init() {
      scene = new THREE.Scene();
      scene.background = new THREE.Color(0x050510);
      scene.fog = new THREE.FogExp2(0x050510, 0.015);

      camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
      camera.position.set(0, 1.7, -40); // Spawn in foyer
      camera.quaternion.setFromEuler(euler); // Face toward hallway

      renderer = new THREE.WebGLRenderer({ antialias: true, preserveDrawingBuffer: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
      document.getElementById('canvas-container').appendChild(renderer.domElement);

      raycaster = new THREE.Raycaster();

      createHallway();
      createGrandFoyer();
      createDoors();
      createChandeliers();
      loadDuckModel();
      createSneakerRoom();
      createAmbientLights();

      window.addEventListener('resize', onResize);
      document.addEventListener('keydown', onKeyDown);
      document.addEventListener('keyup', onKeyUp);
      document.addEventListener('click', onClick);
      document.addEventListener('mousemove', onMouseMove);
      document.addEventListener('pointerlockchange', onPointerLockChange);
      setupMobileControls();

      animate();
    }

    // Poly Haven dark weathered stone texture (CC0)
    const stoneTextureUrl = 'https://dl.polyhaven.org/file/ph-assets/Textures/jpg/2k/rock_wall_16/rock_wall_16_diff_2k.jpg';
    let stoneTexture = null;

    function createHallway() {
      const group = new THREE.Group();
      const textureLoader = new THREE.TextureLoader();

      // Load stone texture
      stoneTexture = textureLoader.load(stoneTextureUrl, (tex) => {
        tex.wrapS = THREE.RepeatWrapping;
        tex.wrapT = THREE.RepeatWrapping;
        console.log('Stone texture loaded from Poly Haven');
      });

      // Floor with stone texture
      const floorGeo = new THREE.PlaneGeometry(hallwayWidth, hallwayLength);
      const floorTex = stoneTexture.clone();
      floorTex.wrapS = THREE.RepeatWrapping;
      floorTex.wrapT = THREE.RepeatWrapping;
      floorTex.repeat.set(4, 40); // Tile across floor
      const floorMat = new THREE.MeshBasicMaterial({ map: floorTex });
      const floor = new THREE.Mesh(floorGeo, floorMat);
      floor.rotation.x = -Math.PI / 2;
      group.add(floor);

      // Subtle floor grid overlay (dimmer now with texture)
      const gridMat = new THREE.LineBasicMaterial({ color: 0x00ffff, transparent: true, opacity: 0.1 });
      const gridGeo = new THREE.BufferGeometry();
      const pts = [];
      for (let x = -hallwayWidth/2; x <= hallwayWidth/2; x += 2) {
        pts.push(x, 0.01, -hallwayLength/2, x, 0.01, hallwayLength/2);
      }
      for (let z = -hallwayLength/2; z <= hallwayLength/2; z += 2) {
        pts.push(-hallwayWidth/2, 0.01, z, hallwayWidth/2, 0.01, z);
      }
      gridGeo.setAttribute('position', new THREE.Float32BufferAttribute(pts, 3));
      group.add(new THREE.LineSegments(gridGeo, gridMat));

      // Ceiling with darker stone
      const ceilGeo = new THREE.PlaneGeometry(hallwayWidth, hallwayLength);
      const ceilTex = stoneTexture.clone();
      ceilTex.wrapS = THREE.RepeatWrapping;
      ceilTex.wrapT = THREE.RepeatWrapping;
      ceilTex.repeat.set(4, 40);
      const ceilMat = new THREE.MeshBasicMaterial({ map: ceilTex, side: THREE.DoubleSide, color: 0x666666 });
      const ceiling = new THREE.Mesh(ceilGeo, ceilMat);
      ceiling.rotation.x = Math.PI / 2;
      ceiling.position.y = hallwayHeight;
      group.add(ceiling);

      // Walls with stone texture
      const wallTex = stoneTexture.clone();
      wallTex.wrapS = THREE.RepeatWrapping;
      wallTex.wrapT = THREE.RepeatWrapping;
      wallTex.repeat.set(20, 3);
      const wallMat = new THREE.MeshBasicMaterial({ map: wallTex, side: THREE.DoubleSide });

      const leftWall = new THREE.Mesh(new THREE.PlaneGeometry(hallwayLength, hallwayHeight), wallMat);
      leftWall.rotation.y = Math.PI / 2;
      leftWall.position.set(-hallwayWidth/2, hallwayHeight/2, 0);
      group.add(leftWall);

      const rightWall = new THREE.Mesh(new THREE.PlaneGeometry(hallwayLength, hallwayHeight), wallMat.clone());
      rightWall.rotation.y = -Math.PI / 2;
      rightWall.position.set(hallwayWidth/2, hallwayHeight/2, 0);
      group.add(rightWall);

      // End walls with stone texture
      const endWallTex = stoneTexture.clone();
      endWallTex.wrapS = THREE.RepeatWrapping;
      endWallTex.wrapT = THREE.RepeatWrapping;
      endWallTex.repeat.set(4, 3);
      const endWallMat = new THREE.MeshBasicMaterial({ map: endWallTex, side: THREE.DoubleSide });

      // Far end opens into grand foyer - add archway frame instead of solid wall
      const archFrameMat = new THREE.MeshBasicMaterial({ map: endWallTex, side: THREE.DoubleSide });
      // Left pillar of arch
      const archLeft = new THREE.Mesh(new THREE.BoxGeometry(1, hallwayHeight, 0.5), archFrameMat);
      archLeft.position.set(-hallwayWidth/2 + 0.5, hallwayHeight/2, -hallwayLength/2);
      group.add(archLeft);
      // Right pillar of arch
      const archRight = new THREE.Mesh(new THREE.BoxGeometry(1, hallwayHeight, 0.5), archFrameMat.clone());
      archRight.position.set(hallwayWidth/2 - 0.5, hallwayHeight/2, -hallwayLength/2);
      group.add(archRight);
      // Arch top
      const archTop = new THREE.Mesh(new THREE.BoxGeometry(hallwayWidth, 1, 0.5), archFrameMat.clone());
      archTop.position.set(0, hallwayHeight - 0.5, -hallwayLength/2);
      group.add(archTop);

      const endWall2 = new THREE.Mesh(new THREE.PlaneGeometry(hallwayWidth, hallwayHeight), endWallMat.clone());
      endWall2.rotation.y = Math.PI;
      endWall2.position.set(0, hallwayHeight/2, hallwayLength/2);
      group.add(endWall2);

      // Neon strips along ceiling
      const stripColors = [0x00ffff, 0xff00ff];
      stripColors.forEach((color, i) => {
        const stripGeo = new THREE.BoxGeometry(0.1, 0.1, hallwayLength);
        const stripMat = new THREE.MeshBasicMaterial({ color });
        const strip = new THREE.Mesh(stripGeo, stripMat);
        strip.position.set((i === 0 ? -1 : 1) * (hallwayWidth/2 - 0.5), hallwayHeight - 0.1, 0);
        group.add(strip);
      });

      // Center ceiling strip
      const centerStrip = new THREE.Mesh(
        new THREE.BoxGeometry(0.15, 0.1, hallwayLength),
        new THREE.MeshBasicMaterial({ color: 0x00ff88 })
      );
      centerStrip.position.set(0, hallwayHeight - 0.1, 0);
      group.add(centerStrip);

      scene.add(group);
      hallwayObjects.push(group);
    }

    function createGrandFoyer() {
      const foyerGroup = new THREE.Group();
      const foyerDepth = 25;
      const foyerWidth = 20;
      const foyerHeight = 10;
      const foyerZ = -hallwayLength/2 - foyerDepth/2;

      // Marble floor - checkerboard pattern
      const marbleWhite = new THREE.MeshBasicMaterial({ color: 0xf5f5f5 });
      const marbleBlack = new THREE.MeshBasicMaterial({ color: 0x2a2a3a });
      const tileSize = 2;

      for (let x = -foyerWidth/2; x < foyerWidth/2; x += tileSize) {
        for (let z = -foyerDepth/2; z < foyerDepth/2; z += tileSize) {
          const isWhite = ((x + foyerWidth/2) / tileSize + (z + foyerDepth/2) / tileSize) % 2 < 1;
          const tile = new THREE.Mesh(
            new THREE.PlaneGeometry(tileSize, tileSize),
            isWhite ? marbleWhite.clone() : marbleBlack.clone()
          );
          tile.rotation.x = -Math.PI / 2;
          tile.position.set(x + tileSize/2, 0.01, foyerZ + z + tileSize/2);
          foyerGroup.add(tile);
        }
      }

      // Foyer walls
      const foyerWallMat = new THREE.MeshBasicMaterial({ color: 0x1a1a2e, side: THREE.DoubleSide });

      // Back wall
      const backWall = new THREE.Mesh(new THREE.PlaneGeometry(foyerWidth, foyerHeight), foyerWallMat);
      backWall.position.set(0, foyerHeight/2, foyerZ - foyerDepth/2);
      foyerGroup.add(backWall);

      // Side walls
      const leftFoyerWall = new THREE.Mesh(new THREE.PlaneGeometry(foyerDepth, foyerHeight), foyerWallMat.clone());
      leftFoyerWall.rotation.y = Math.PI / 2;
      leftFoyerWall.position.set(-foyerWidth/2, foyerHeight/2, foyerZ);
      foyerGroup.add(leftFoyerWall);

      const rightFoyerWall = new THREE.Mesh(new THREE.PlaneGeometry(foyerDepth, foyerHeight), foyerWallMat.clone());
      rightFoyerWall.rotation.y = -Math.PI / 2;
      rightFoyerWall.position.set(foyerWidth/2, foyerHeight/2, foyerZ);
      foyerGroup.add(rightFoyerWall);

      // Transition walls connecting hallway to foyer
      const transitionWidth = (foyerWidth - hallwayWidth) / 2;
      const transLeft = new THREE.Mesh(new THREE.PlaneGeometry(transitionWidth, foyerHeight), foyerWallMat.clone());
      transLeft.rotation.y = Math.PI / 2;
      transLeft.position.set(-hallwayWidth/2 - transitionWidth/2, foyerHeight/2, -hallwayLength/2 - 0.25);
      foyerGroup.add(transLeft);

      const transRight = new THREE.Mesh(new THREE.PlaneGeometry(transitionWidth, foyerHeight), foyerWallMat.clone());
      transRight.rotation.y = -Math.PI / 2;
      transRight.position.set(hallwayWidth/2 + transitionWidth/2, foyerHeight/2, -hallwayLength/2 - 0.25);
      foyerGroup.add(transRight);

      // High ceiling
      const ceilingMat = new THREE.MeshBasicMaterial({ color: 0x0a0a15, side: THREE.DoubleSide });
      const foyerCeiling = new THREE.Mesh(new THREE.PlaneGeometry(foyerWidth, foyerDepth), ceilingMat);
      foyerCeiling.rotation.x = Math.PI / 2;
      foyerCeiling.position.set(0, foyerHeight, foyerZ);
      foyerGroup.add(foyerCeiling);

      // === GRAND MAHOGANY DOUBLE DOORS ===
      const mahoganyColor = 0x4a1c1c; // Rich dark mahogany
      const brassColor = 0xb8860b; // Brass/gold trim
      const doorFrameMat = new THREE.MeshBasicMaterial({ color: 0x2a0f0f });
      const mahoganyMat = new THREE.MeshBasicMaterial({ color: mahoganyColor });
      const brassMat = new THREE.MeshBasicMaterial({ color: brassColor });

      // Door frame
      const doorFrameWidth = 8;
      const doorFrameHeight = 7;
      const doorFrame = new THREE.Mesh(
        new THREE.BoxGeometry(doorFrameWidth + 1, doorFrameHeight + 0.5, 0.5),
        doorFrameMat
      );
      doorFrame.position.set(0, doorFrameHeight/2, foyerZ - foyerDepth/2 + 0.3);
      foyerGroup.add(doorFrame);

      // Left door panel
      const doorPanelWidth = 3.5;
      const leftDoor = new THREE.Mesh(
        new THREE.BoxGeometry(doorPanelWidth, doorFrameHeight - 0.5, 0.3),
        mahoganyMat
      );
      leftDoor.position.set(-doorPanelWidth/2 - 0.2, doorFrameHeight/2, foyerZ - foyerDepth/2 + 0.5);
      foyerGroup.add(leftDoor);

      // Right door panel
      const rightDoor = new THREE.Mesh(
        new THREE.BoxGeometry(doorPanelWidth, doorFrameHeight - 0.5, 0.3),
        mahoganyMat.clone()
      );
      rightDoor.position.set(doorPanelWidth/2 + 0.2, doorFrameHeight/2, foyerZ - foyerDepth/2 + 0.5);
      foyerGroup.add(rightDoor);

      // Door panels decorative insets
      [-1, 1].forEach(side => {
        const xBase = side * (doorPanelWidth/2 + 0.2);
        // Upper panel
        const upperPanel = new THREE.Mesh(
          new THREE.BoxGeometry(2.5, 2.5, 0.1),
          new THREE.MeshBasicMaterial({ color: 0x3a1515 })
        );
        upperPanel.position.set(xBase, doorFrameHeight/2 + 1.5, foyerZ - foyerDepth/2 + 0.7);
        foyerGroup.add(upperPanel);
        // Lower panel
        const lowerPanel = new THREE.Mesh(
          new THREE.BoxGeometry(2.5, 2, 0.1),
          new THREE.MeshBasicMaterial({ color: 0x3a1515 })
        );
        lowerPanel.position.set(xBase, doorFrameHeight/2 - 1.5, foyerZ - foyerDepth/2 + 0.7);
        foyerGroup.add(lowerPanel);
        // Brass door handle
        const handle = new THREE.Mesh(
          new THREE.SphereGeometry(0.2, 16, 16),
          brassMat.clone()
        );
        handle.position.set(xBase + side * 1.2, doorFrameHeight/2, foyerZ - foyerDepth/2 + 0.8);
        foyerGroup.add(handle);
      });

      // Brass door arch trim
      const archTrim = new THREE.Mesh(
        new THREE.BoxGeometry(doorFrameWidth + 0.5, 0.4, 0.4),
        brassMat.clone()
      );
      archTrim.position.set(0, doorFrameHeight + 0.1, foyerZ - foyerDepth/2 + 0.5);
      foyerGroup.add(archTrim);

      // Decorative pillars
      const pillarMat = new THREE.MeshBasicMaterial({ color: 0xe8e8e8 });
      const pillarPositions = [
        [-foyerWidth/2 + 2, foyerZ + foyerDepth/4],
        [foyerWidth/2 - 2, foyerZ + foyerDepth/4],
        [-foyerWidth/2 + 2, foyerZ - foyerDepth/4],
        [foyerWidth/2 - 2, foyerZ - foyerDepth/4]
      ];

      pillarPositions.forEach(([px, pz]) => {
        // Pillar column
        const pillar = new THREE.Mesh(
          new THREE.CylinderGeometry(0.4, 0.5, foyerHeight - 1, 16),
          pillarMat
        );
        pillar.position.set(px, foyerHeight/2 - 0.5, pz);
        foyerGroup.add(pillar);

        // Pillar base
        const base = new THREE.Mesh(
          new THREE.BoxGeometry(1.2, 0.5, 1.2),
          pillarMat.clone()
        );
        base.position.set(px, 0.25, pz);
        foyerGroup.add(base);

        // Pillar capital
        const capital = new THREE.Mesh(
          new THREE.BoxGeometry(1, 0.4, 1),
          pillarMat.clone()
        );
        capital.position.set(px, foyerHeight - 0.7, pz);
        foyerGroup.add(capital);
      });

      // Grand chandelier in foyer
      const foyerChandelier = createChandelier();
      foyerChandelier.scale.set(1.5, 1.5, 1.5);
      foyerChandelier.position.set(0, foyerHeight - 1, foyerZ + 3);
      foyerGroup.add(foyerChandelier);

      // Neon accent lighting
      const accentLight1 = new THREE.PointLight(0x00ffff, 1, 20);
      accentLight1.position.set(-foyerWidth/3, 3, foyerZ);
      foyerGroup.add(accentLight1);

      const accentLight2 = new THREE.PointLight(0xff00ff, 1, 20);
      accentLight2.position.set(foyerWidth/3, 3, foyerZ);
      foyerGroup.add(accentLight2);

      // Floor edge neon strips
      const neonEdgeMat = new THREE.MeshBasicMaterial({ color: 0x00ffaa });
      const edgeStrips = [
        { pos: [-foyerWidth/2 + 0.1, 0.05, foyerZ], size: [0.1, 0.1, foyerDepth] },
        { pos: [foyerWidth/2 - 0.1, 0.05, foyerZ], size: [0.1, 0.1, foyerDepth] },
        { pos: [0, 0.05, foyerZ - foyerDepth/2 + 0.1], size: [foyerWidth, 0.1, 0.1] }
      ];

      edgeStrips.forEach(({ pos, size }) => {
        const strip = new THREE.Mesh(
          new THREE.BoxGeometry(...size),
          neonEdgeMat.clone()
        );
        strip.position.set(...pos);
        foyerGroup.add(strip);
      });

      scene.add(foyerGroup);
      hallwayObjects.push(foyerGroup);
    }

    function createDoors() {
      const doorWidth = 2.5;
      const doorHeight = 4;

      // Left side doors
      leftDoors.forEach((app, i) => {
        const z = hallwayLength/2 - 10 - i * doorSpacing;
        createDoor(app, -hallwayWidth/2 + 0.1, z, Math.PI/2, doorWidth, doorHeight);
      });

      // Right side doors
      rightDoors.forEach((app, i) => {
        const z = hallwayLength/2 - 10 - i * doorSpacing;
        createDoor(app, hallwayWidth/2 - 0.1, z, -Math.PI/2, doorWidth, doorHeight);
      });
    }

    function createDoor(app, x, z, rotY, width, height) {
      const group = new THREE.Group();
      group.position.set(x, 0, z);
      group.rotation.y = rotY;

      // Door frame
      const frameGeo = new THREE.BoxGeometry(width + 0.4, height + 0.3, 0.2);
      const frameMat = new THREE.MeshBasicMaterial({ color: 0x1a1a2e });
      const frame = new THREE.Mesh(frameGeo, frameMat);
      frame.position.y = height/2 + 0.1;
      group.add(frame);

      // Door surface
      const doorGeo = new THREE.PlaneGeometry(width, height);
      const doorMat = new THREE.MeshBasicMaterial({
        color: app.color,
        transparent: true,
        opacity: 0.4,
        side: THREE.DoubleSide
      });
      const door = new THREE.Mesh(doorGeo, doorMat);
      door.position.set(0, height/2 + 0.1, 0.15);
      door.userData = { app };
      group.add(door);
      doors.push(door);

      // Door edges glow
      const edgeGeo = new THREE.EdgesGeometry(new THREE.BoxGeometry(width, height, 0.05));
      const edgeMat = new THREE.LineBasicMaterial({ color: app.color });
      const edges = new THREE.LineSegments(edgeGeo, edgeMat);
      edges.position.set(0, height/2 + 0.1, 0.15);
      group.add(edges);

      // Icon
      const iconCanvas = document.createElement('canvas');
      iconCanvas.width = 128;
      iconCanvas.height = 128;
      const ctx = iconCanvas.getContext('2d');
      ctx.font = '80px Arial';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillText(app.icon, 64, 64);
      const iconTex = new THREE.CanvasTexture(iconCanvas);
      const iconSprite = new THREE.Sprite(new THREE.SpriteMaterial({ map: iconTex }));
      iconSprite.scale.set(1.5, 1.5, 1);
      iconSprite.position.set(0, height/2 + 0.5, 0.3);
      group.add(iconSprite);

      // Name label
      const labelCanvas = document.createElement('canvas');
      labelCanvas.width = 256;
      labelCanvas.height = 64;
      const lctx = labelCanvas.getContext('2d');
      lctx.fillStyle = '#' + app.color.toString(16).padStart(6, '0');
      lctx.font = 'bold 22px Orbitron, sans-serif';
      lctx.textAlign = 'center';
      lctx.fillText(app.name, 128, 40);
      const labelTex = new THREE.CanvasTexture(labelCanvas);
      const labelSprite = new THREE.Sprite(new THREE.SpriteMaterial({ map: labelTex }));
      labelSprite.scale.set(3, 0.75, 1);
      labelSprite.position.set(0, height + 0.8, 0.2);
      group.add(labelSprite);

      // Floor glow
      const glowGeo = new THREE.PlaneGeometry(width + 1, 1.5);
      const glowMat = new THREE.MeshBasicMaterial({ color: app.color, transparent: true, opacity: 0.2 });
      const glow = new THREE.Mesh(glowGeo, glowMat);
      glow.rotation.x = -Math.PI/2;
      glow.position.set(0, 0.02, 0.8);
      group.add(glow);

      scene.add(group);
      hallwayObjects.push(group);
    }

    function createSneakerRoom() {
      const roomGroup = new THREE.Group();
      roomGroup.visible = false;

      const roomWidth = 20;
      const roomDepth = 25;
      const roomHeight = 8;

      // Floor
      const floor = new THREE.Mesh(
        new THREE.PlaneGeometry(roomWidth, roomDepth),
        new THREE.MeshBasicMaterial({ color: 0x0a0a15 })
      );
      floor.rotation.x = -Math.PI/2;
      roomGroup.add(floor);

      // Grid
      const gridMat = new THREE.LineBasicMaterial({ color: 0xff00ff, transparent: true, opacity: 0.3 });
      const gridGeo = new THREE.BufferGeometry();
      const pts = [];
      for (let i = -roomWidth/2; i <= roomWidth/2; i += 2) pts.push(i, 0.01, -roomDepth/2, i, 0.01, roomDepth/2);
      for (let i = -roomDepth/2; i <= roomDepth/2; i += 2) pts.push(-roomWidth/2, 0.01, i, roomWidth/2, 0.01, i);
      gridGeo.setAttribute('position', new THREE.Float32BufferAttribute(pts, 3));
      roomGroup.add(new THREE.LineSegments(gridGeo, gridMat));

      // Walls
      const wallMat = new THREE.MeshBasicMaterial({ color: 0x1a0a2e, side: THREE.DoubleSide });
      const walls = [
        { pos: [0, roomHeight/2, -roomDepth/2], rot: [0, 0, 0], size: [roomWidth, roomHeight] },
        { pos: [-roomWidth/2, roomHeight/2, 0], rot: [0, Math.PI/2, 0], size: [roomDepth, roomHeight] },
        { pos: [roomWidth/2, roomHeight/2, 0], rot: [0, -Math.PI/2, 0], size: [roomDepth, roomHeight] },
        { pos: [0, roomHeight, 0], rot: [Math.PI/2, 0, 0], size: [roomWidth, roomDepth] }
      ];
      walls.forEach(w => {
        const wall = new THREE.Mesh(new THREE.PlaneGeometry(w.size[0], w.size[1]), wallMat);
        wall.position.set(...w.pos);
        wall.rotation.set(...w.rot);
        roomGroup.add(wall);
      });

      // Neon strips
      [0xff00ff, 0x00ffff, 0x00ff88].forEach((c, i) => {
        const strip = new THREE.Mesh(
          new THREE.BoxGeometry(roomWidth - 2, 0.1, 0.1),
          new THREE.MeshBasicMaterial({ color: c })
        );
        strip.position.set(0, 2 + i * 2, -roomDepth/2 + 0.1);
        roomGroup.add(strip);
      });

      // Sneakers
      const sneakerData = [
        { name: 'Neon Runner', color: 0x00ffff, accent: 0xff00ff },
        { name: 'Cyber High', color: 0xff00ff, accent: 0x00ff88 },
        { name: 'Grid Walker', color: 0x00ff88, accent: 0xffff00 },
        { name: 'Pixel Kick', color: 0xffff00, accent: 0xff0044 },
        { name: 'Retro Glow', color: 0xff6600, accent: 0x00ffff },
        { name: 'Matrix Step', color: 0x00ff00, accent: 0xff00ff }
      ];

      sneakerData.forEach((data, i) => {
        const x = (i % 3 - 1) * 6;
        const z = Math.floor(i / 3) * 8 - 6;

        // Pedestal
        const ped = new THREE.Mesh(
          new THREE.CylinderGeometry(1, 1.2, 0.8, 32),
          new THREE.MeshBasicMaterial({ color: 0x1a1a2e })
        );
        ped.position.set(x, 0.4, z);
        roomGroup.add(ped);

        // Ring
        const ring = new THREE.Mesh(
          new THREE.TorusGeometry(1.1, 0.08, 8, 32),
          new THREE.MeshBasicMaterial({ color: data.color })
        );
        ring.rotation.x = Math.PI/2;
        ring.position.set(x, 0.82, z);
        roomGroup.add(ring);

        // Sneaker
        const sneaker = createSneaker(data.color, data.accent);
        sneaker.position.set(x, 1.5, z);
        sneaker.userData = { name: data.name, baseY: 1.5 };
        roomGroup.add(sneaker);
        sneakers.push(sneaker);

        // Label
        const lc = document.createElement('canvas');
        lc.width = 256; lc.height = 64;
        const lctx = lc.getContext('2d');
        lctx.fillStyle = '#' + data.color.toString(16).padStart(6, '0');
        lctx.font = 'bold 24px Orbitron';
        lctx.textAlign = 'center';
        lctx.fillText(data.name, 128, 40);
        const label = new THREE.Sprite(new THREE.SpriteMaterial({ map: new THREE.CanvasTexture(lc) }));
        label.scale.set(3, 0.75, 1);
        label.position.set(x, 2.8, z);
        roomGroup.add(label);
      });

      // Exit portal
      const exitGroup = new THREE.Group();
      exitGroup.position.set(0, 0, roomDepth/2 - 0.5);

      const exitDoor = new THREE.Mesh(
        new THREE.PlaneGeometry(3, 5),
        new THREE.MeshBasicMaterial({ color: 0x00ffff, transparent: true, opacity: 0.4, side: THREE.DoubleSide })
      );
      exitDoor.position.y = 2.5;
      exitDoor.userData = { type: 'exit' };
      exitGroup.add(exitDoor);
      exitPortal = exitDoor;

      const exitEdges = new THREE.LineSegments(
        new THREE.EdgesGeometry(new THREE.BoxGeometry(3, 5, 0.1)),
        new THREE.LineBasicMaterial({ color: 0x00ffff })
      );
      exitEdges.position.y = 2.5;
      exitGroup.add(exitEdges);

      const ec = document.createElement('canvas');
      ec.width = 128; ec.height = 64;
      const ectx = ec.getContext('2d');
      ectx.fillStyle = '#00ffff';
      ectx.font = 'bold 24px Orbitron';
      ectx.textAlign = 'center';
      ectx.fillText('‚Üê EXIT', 64, 40);
      const exitLabel = new THREE.Sprite(new THREE.SpriteMaterial({ map: new THREE.CanvasTexture(ec) }));
      exitLabel.scale.set(2.5, 1.25, 1);
      exitLabel.position.y = 5.5;
      exitGroup.add(exitLabel);

      roomGroup.add(exitGroup);
      scene.add(roomGroup);
      sneakerRoomObjects.push(roomGroup);
    }

    function createSneaker(mainColor, accentColor) {
      const g = new THREE.Group();

      // Sole
      const soleShape = new THREE.Shape();
      soleShape.moveTo(-0.8, -0.3);
      soleShape.lineTo(1, -0.3);
      soleShape.quadraticCurveTo(1.2, 0, 1, 0.3);
      soleShape.lineTo(-0.6, 0.3);
      soleShape.quadraticCurveTo(-1, 0, -0.8, -0.3);

      const sole = new THREE.Mesh(
        new THREE.ExtrudeGeometry(soleShape, { depth: 0.2, bevelEnabled: false }),
        new THREE.MeshBasicMaterial({ color: 0x222222 })
      );
      sole.rotation.x = -Math.PI/2;
      sole.position.y = -0.2;
      g.add(sole);

      // Midsole
      const mid = new THREE.Mesh(
        new THREE.ExtrudeGeometry(soleShape, { depth: 0.1, bevelEnabled: false }),
        new THREE.MeshBasicMaterial({ color: accentColor, transparent: true, opacity: 0.9 })
      );
      mid.rotation.x = -Math.PI/2;
      mid.position.y = -0.1;
      mid.scale.set(0.95, 0.95, 1);
      g.add(mid);

      // Upper
      const upper = new THREE.Mesh(
        new THREE.BoxGeometry(1.5, 0.6, 0.7),
        new THREE.MeshBasicMaterial({ color: mainColor })
      );
      upper.position.set(0.1, 0.15, 0);
      g.add(upper);

      // Toe
      const toe = new THREE.Mesh(
        new THREE.SphereGeometry(0.35, 16, 16, 0, Math.PI, 0, Math.PI/2),
        new THREE.MeshBasicMaterial({ color: mainColor })
      );
      toe.rotation.z = -Math.PI/2;
      toe.position.set(0.8, 0.05, 0);
      g.add(toe);

      // Heel
      const heel = new THREE.Mesh(
        new THREE.BoxGeometry(0.3, 0.5, 0.5),
        new THREE.MeshBasicMaterial({ color: accentColor })
      );
      heel.position.set(-0.6, 0.2, 0);
      g.add(heel);

      // Stripe
      const stripe = new THREE.Mesh(
        new THREE.BoxGeometry(0.8, 0.08, 0.04),
        new THREE.MeshBasicMaterial({ color: accentColor })
      );
      stripe.position.set(0.15, 0.2, 0.36);
      stripe.rotation.z = 0.15;
      g.add(stripe);

      // Edges
      const edges = new THREE.LineSegments(
        new THREE.EdgesGeometry(new THREE.BoxGeometry(1.5, 0.6, 0.7)),
        new THREE.LineBasicMaterial({ color: accentColor })
      );
      edges.position.set(0.1, 0.15, 0);
      g.add(edges);

      g.scale.set(0.7, 0.7, 0.7);
      return g;
    }

    // Gothic chandeliers
    let chandeliers = [];

    function createChandeliers() {
      const chandelierCount = 5;
      const spacing = hallwayLength / (chandelierCount + 1);

      for (let i = 0; i < chandelierCount; i++) {
        const z = hallwayLength / 2 - spacing * (i + 1);
        const chandelier = createChandelier();
        chandelier.position.set(0, hallwayHeight - 0.5, z);
        scene.add(chandelier);
        hallwayObjects.push(chandelier);
        chandeliers.push(chandelier);
      }
    }

    function createChandelier() {
      const group = new THREE.Group();

      // Central chain/rod
      const chainGeo = new THREE.CylinderGeometry(0.05, 0.05, 1.2, 8);
      const chainMat = new THREE.MeshBasicMaterial({ color: 0x1a1a2e });
      const chain = new THREE.Mesh(chainGeo, chainMat);
      chain.position.y = 0.1;
      group.add(chain);

      // Main body (gothic spire shape)
      const bodyGeo = new THREE.ConeGeometry(0.4, 0.8, 6);
      const bodyMat = new THREE.MeshBasicMaterial({ color: 0x1a1a3a });
      const body = new THREE.Mesh(bodyGeo, bodyMat);
      body.position.y = -0.6;
      body.rotation.x = Math.PI;
      group.add(body);

      // Ornate ring
      const ringGeo = new THREE.TorusGeometry(0.5, 0.08, 8, 6);
      const ringMat = new THREE.MeshBasicMaterial({ color: 0x2a2a4a });
      const ring = new THREE.Mesh(ringGeo, ringMat);
      ring.rotation.x = Math.PI / 2;
      ring.position.y = -0.4;
      group.add(ring);

      // Arms and candles
      const armCount = 6;
      for (let i = 0; i < armCount; i++) {
        const angle = (i / armCount) * Math.PI * 2;
        const armGroup = new THREE.Group();

        // Curved arm
        const armGeo = new THREE.CylinderGeometry(0.03, 0.03, 0.8, 8);
        const armMat = new THREE.MeshBasicMaterial({ color: 0x2a2a4a });
        const arm = new THREE.Mesh(armGeo, armMat);
        arm.rotation.z = Math.PI / 3;
        arm.position.set(0.35, -0.15, 0);
        armGroup.add(arm);

        // Candle holder
        const holderGeo = new THREE.CylinderGeometry(0.08, 0.06, 0.1, 8);
        const holder = new THREE.Mesh(holderGeo, new THREE.MeshBasicMaterial({ color: 0x2a2a4a }));
        holder.position.set(0.7, -0.5, 0);
        armGroup.add(holder);

        // Candle
        const candleGeo = new THREE.CylinderGeometry(0.04, 0.04, 0.15, 8);
        const candleMat = new THREE.MeshBasicMaterial({ color: 0xffffee });
        const candle = new THREE.Mesh(candleGeo, candleMat);
        candle.position.set(0.7, -0.38, 0);
        armGroup.add(candle);

        // Glowing flame orb
        const flameGeo = new THREE.SphereGeometry(0.08, 8, 8);
        const flameMat = new THREE.MeshBasicMaterial({
          color: 0xff6600,
          transparent: true,
          opacity: 0.9
        });
        const flame = new THREE.Mesh(flameGeo, flameMat);
        flame.position.set(0.7, -0.25, 0);
        flame.userData.isFlame = true;
        armGroup.add(flame);

        // Flame glow
        const glowGeo = new THREE.SphereGeometry(0.15, 8, 8);
        const glowMat = new THREE.MeshBasicMaterial({
          color: 0xff4400,
          transparent: true,
          opacity: 0.3
        });
        const glow = new THREE.Mesh(glowGeo, glowMat);
        glow.position.set(0.7, -0.25, 0);
        glow.userData.isGlow = true;
        armGroup.add(glow);

        armGroup.rotation.y = angle;
        group.add(armGroup);
      }

      // Central haunting orb (bigger glow in center)
      const centerOrbGeo = new THREE.SphereGeometry(0.2, 16, 16);
      const centerOrbMat = new THREE.MeshBasicMaterial({
        color: 0x8800ff,
        transparent: true,
        opacity: 0.7
      });
      const centerOrb = new THREE.Mesh(centerOrbGeo, centerOrbMat);
      centerOrb.position.y = -1.0;
      centerOrb.userData.isCenterOrb = true;
      group.add(centerOrb);

      // Center orb outer glow
      const centerGlowGeo = new THREE.SphereGeometry(0.4, 16, 16);
      const centerGlowMat = new THREE.MeshBasicMaterial({
        color: 0x6600cc,
        transparent: true,
        opacity: 0.2
      });
      const centerGlow = new THREE.Mesh(centerGlowGeo, centerGlowMat);
      centerGlow.position.y = -1.0;
      centerGlow.userData.isCenterGlow = true;
      group.add(centerGlow);

      // Point light for actual illumination
      const light = new THREE.PointLight(0xff6600, 0.4, 12);
      light.position.y = -0.5;
      group.add(light);

      // Purple accent light from center orb
      const purpleLight = new THREE.PointLight(0x8800ff, 0.3, 8);
      purpleLight.position.y = -1.0;
      group.add(purpleLight);

      return group;
    }

    function animateChandeliers(time) {
      chandeliers.forEach((chandelier, idx) => {
        // Gentle sway
        chandelier.rotation.y = Math.sin(time * 0.5 + idx) * 0.05;

        // Animate flames and glows
        chandelier.traverse(child => {
          if (child.userData.isFlame) {
            child.scale.setScalar(1 + Math.sin(time * 10 + idx) * 0.2);
          }
          if (child.userData.isGlow) {
            child.material.opacity = 0.2 + Math.sin(time * 8 + idx) * 0.15;
          }
          if (child.userData.isCenterOrb) {
            child.scale.setScalar(1 + Math.sin(time * 2 + idx) * 0.1);
            child.material.opacity = 0.5 + Math.sin(time * 3 + idx) * 0.2;
          }
          if (child.userData.isCenterGlow) {
            child.scale.setScalar(1 + Math.sin(time * 1.5 + idx) * 0.2);
          }
        });
      });
    }

    // Khronos Duck model
    let duckModel = null;

    function loadDuckModel() {
      const loader = new THREE.GLTFLoader();
      const duckUrl = 'https://raw.githubusercontent.com/KhronosGroup/glTF-Sample-Assets/main/Models/Duck/glTF-Binary/Duck.glb';

      loader.load(
        duckUrl,
        (gltf) => {
          duckModel = gltf.scene;
          duckModel.scale.set(1.0, 1.0, 1.0); // MEGA duck - 10x bigger
          duckModel.position.set(0, 0, 0); // Center of hallway
          duckModel.rotation.y = Math.PI; // Face down the hallway

          // Add a tiny glowing pedestal (shrunk 5x)
          const pedestalGeo = new THREE.CylinderGeometry(0.3, 0.36, 0.08, 16);
          const pedestalMat = new THREE.MeshBasicMaterial({
            color: 0xffff00,
            transparent: true,
            opacity: 0.3
          });
          const pedestal = new THREE.Mesh(pedestalGeo, pedestalMat);
          pedestal.position.set(0, 0.04, 0);

          // Pedestal glow ring (tiny)
          const ringGeo = new THREE.TorusGeometry(0.32, 0.02, 8, 32);
          const ringMat = new THREE.MeshBasicMaterial({ color: 0xffff00 });
          const ring = new THREE.Mesh(ringGeo, ringMat);
          ring.rotation.x = Math.PI / 2;
          ring.position.set(0, 0.08, 0);

          // Duck spotlight (massive for MEGA duck)
          const duckLight = new THREE.PointLight(0xffff00, 1.2, 30);
          duckLight.position.set(0, 8, 0);

          // Group everything
          const duckGroup = new THREE.Group();
          duckGroup.add(duckModel);
          duckGroup.add(pedestal);
          duckGroup.add(ring);
          duckGroup.add(duckLight);
          duckGroup.userData.isDuck = true;

          scene.add(duckGroup);
          hallwayObjects.push(duckGroup);

          console.log('Khronos Duck loaded successfully!');
        },
        (progress) => {
          console.log('Loading duck...', (progress.loaded / progress.total * 100).toFixed(0) + '%');
        },
        (error) => {
          console.error('Error loading duck:', error);
        }
      );
    }

    function animateDuck(time) {
      // Find and animate the duck
      hallwayObjects.forEach(obj => {
        if (obj.userData.isDuck && duckModel) {
          // Gentle bobbing (MEGA duck)
          duckModel.position.y = 0.1 + Math.sin(time * 1.5) * 0.3;
          // Slow majestic rotation
          duckModel.rotation.y += 0.003;
        }
      });
    }

    function createAmbientLights() {
      scene.add(new THREE.AmbientLight(0x111122, 0.3));
      const pl = new THREE.PointLight(0x00ffff, 0.3, 50);
      pl.position.set(0, hallwayHeight - 1, 0);
      scene.add(pl);
    }

    function switchRoom(room) {
      if (room === 'sneakers') {
        hallwayObjects.forEach(o => o.visible = false);
        sneakerRoomObjects.forEach(o => o.visible = true);
        camera.position.set(0, 1.7, 10);
        euler.set(0, Math.PI, 0);
        camera.quaternion.setFromEuler(euler);
        currentRoom = 'sneakers';
      } else {
        sneakerRoomObjects.forEach(o => o.visible = false);
        hallwayObjects.forEach(o => o.visible = true);
        camera.position.set(0, 1.7, hallwayLength/2 - 15);
        euler.set(0, 0, 0);
        camera.quaternion.setFromEuler(euler);
        currentRoom = 'hallway';
      }
    }

    function onResize() {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    }

    function onKeyDown(e) {
      if (e.code === 'KeyW' || e.code === 'ArrowUp') moveForward = true;
      if (e.code === 'KeyS' || e.code === 'ArrowDown') moveBackward = true;
      if (e.code === 'KeyA' || e.code === 'ArrowLeft') moveLeft = true;
      if (e.code === 'KeyD' || e.code === 'ArrowRight') moveRight = true;
    }

    function onKeyUp(e) {
      if (e.code === 'KeyW' || e.code === 'ArrowUp') moveForward = false;
      if (e.code === 'KeyS' || e.code === 'ArrowDown') moveBackward = false;
      if (e.code === 'KeyA' || e.code === 'ArrowLeft') moveLeft = false;
      if (e.code === 'KeyD' || e.code === 'ArrowRight') moveRight = false;
    }

    function onClick(e) {
      if (e.target.closest('.stream-link-btn') || e.target.closest('.pet-container') || e.target.closest('.mobile-controls') || e.target.closest('.snapshot-btn') || e.target.closest('.snapshot-preview')) return;

      if (!isLocked) {
        document.body.requestPointerLock();
        document.getElementById('click-to-start').classList.add('hidden');
        return;
      }

      raycaster.setFromCamera(new THREE.Vector2(0, 0), camera);

      if (currentRoom === 'hallway') {
        const hits = raycaster.intersectObjects(doors);
        if (hits.length > 0 && hits[0].distance < 8) {
          const app = hits[0].object.userData.app;
          if (app.special === 'sneakers') {
            switchRoom('sneakers');
          } else if (app.url) {
            window.location.href = app.url;
          }
        }
      } else if (currentRoom === 'sneakers') {
        const exitHit = raycaster.intersectObject(exitPortal);
        if (exitHit.length > 0 && exitHit[0].distance < 8) {
          switchRoom('hallway');
        }
      }
    }

    function onMouseMove(e) {
      if (!isLocked) return;
      euler.setFromQuaternion(camera.quaternion);
      euler.y -= (e.movementX || 0) * 0.002;
      euler.x -= (e.movementY || 0) * 0.002;
      euler.x = Math.max(-PI_2, Math.min(PI_2, euler.x));
      camera.quaternion.setFromEuler(euler);
    }

    function onPointerLockChange() {
      isLocked = document.pointerLockElement === document.body;
      if (!isLocked) document.getElementById('click-to-start').classList.remove('hidden');
    }

    function setupMobileControls() {
      const fwd = document.getElementById('mobile-forward');
      const left = document.getElementById('mobile-left');
      const right = document.getElementById('mobile-right');
      fwd.addEventListener('touchstart', () => moveForward = true);
      fwd.addEventListener('touchend', () => moveForward = false);
      left.addEventListener('touchstart', () => moveLeft = true);
      left.addEventListener('touchend', () => moveLeft = false);
      right.addEventListener('touchstart', () => moveRight = true);
      right.addEventListener('touchend', () => moveRight = false);
    }

    // Screenshot capture functionality
    let lastSnapshotData = null;

    function takeSnapshot() {
      // Flash effect
      const flash = document.getElementById('flash-overlay');
      flash.classList.add('flash');
      setTimeout(() => flash.classList.remove('flash'), 400);

      // Capture the WebGL canvas
      renderer.render(scene, camera); // Ensure current frame
      const dataUrl = renderer.domElement.toDataURL('image/png');
      lastSnapshotData = dataUrl;

      // Show preview
      const preview = document.getElementById('snapshot-preview');
      const img = document.getElementById('snapshot-img');
      img.src = dataUrl;
      preview.classList.add('visible');

      // Auto-hide after 10 seconds
      setTimeout(() => {
        preview.classList.remove('visible');
      }, 10000);

      console.log('üì∏ Snapshot captured!');
    }

    function saveSnapshot() {
      if (!lastSnapshotData) return;

      const timestamp = new Date().toISOString().replace(/[:.]/g, '-').slice(0, 19);
      const link = document.createElement('a');
      link.download = `sloppyos-snapshot-${timestamp}.png`;
      link.href = lastSnapshotData;
      link.click();

      console.log('üíæ Snapshot saved!');
    }

    function closeSnapshotPreview() {
      document.getElementById('snapshot-preview').classList.remove('visible');
    }

    // Snapshot event listeners
    document.getElementById('snapshot-btn').addEventListener('click', (e) => {
      e.stopPropagation();
      takeSnapshot();
    });

    document.getElementById('snapshot-save').addEventListener('click', (e) => {
      e.stopPropagation();
      saveSnapshot();
    });

    document.getElementById('snapshot-close').addEventListener('click', (e) => {
      e.stopPropagation();
      closeSnapshotPreview();
    });

    // Keyboard shortcut: E for snapshot
    document.addEventListener('keydown', (e) => {
      if (e.key === 'e' || e.key === 'E') {
        takeSnapshot();
      }
    });

    function updateInfo() {
      const info = document.getElementById('app-info');
      const name = document.getElementById('app-name');
      raycaster.setFromCamera(new THREE.Vector2(0, 0), camera);

      if (currentRoom === 'hallway') {
        const hits = raycaster.intersectObjects(doors);
        if (hits.length > 0 && hits[0].distance < 10) {
          const app = hits[0].object.userData.app;
          name.textContent = app.icon + ' ' + app.name;
          info.classList.add('visible');
          return;
        }
      } else if (currentRoom === 'sneakers') {
        const exitHit = raycaster.intersectObject(exitPortal);
        if (exitHit.length > 0 && exitHit[0].distance < 10) {
          name.textContent = '‚Üê Exit to Hallway';
          info.classList.add('visible');
          return;
        }
        const sneakerHits = raycaster.intersectObjects(sneakers, true);
        if (sneakerHits.length > 0 && sneakerHits[0].distance < 8) {
          let p = sneakerHits[0].object;
          while (p.parent && !p.userData.name) p = p.parent;
          if (p.userData.name) {
            name.textContent = 'üëü ' + p.userData.name;
            info.classList.add('visible');
            return;
          }
        }
      }
      info.classList.remove('visible');
    }

    function animate() {
      requestAnimationFrame(animate);
      const time = performance.now() * 0.001;

      // Animate sneakers
      sneakers.forEach((s, i) => {
        if (s.userData.baseY) {
          s.position.y = s.userData.baseY + Math.sin(time * 2 + i) * 0.1;
          s.rotation.y += 0.01;
        }
      });

      // Animate chandeliers and duck
      if (currentRoom === 'hallway') {
        animateChandeliers(time);
        animateDuck(time);
      }

      // Movement with collision
      if (isLocked) {
        velocity.x -= velocity.x * 5 * 0.016;
        velocity.z -= velocity.z * 5 * 0.016;

        direction.z = Number(moveForward) - Number(moveBackward);
        direction.x = Number(moveRight) - Number(moveLeft);
        direction.normalize();

        if (moveForward || moveBackward) velocity.z -= direction.z * 40 * 0.016;
        if (moveLeft || moveRight) velocity.x -= direction.x * 40 * 0.016;

        camera.translateX(-velocity.x * 0.016);
        camera.translateZ(velocity.z * 0.016);

        // Hallway and foyer bounds
        if (currentRoom === 'hallway') {
          // Check if in foyer area (z < -hallwayLength/2)
          const inFoyer = camera.position.z < -hallwayLength/2 + 2;
          if (inFoyer) {
            // Foyer bounds - wider space with staircase limit
            camera.position.x = Math.max(-9.5, Math.min(9.5, camera.position.x));
            camera.position.z = Math.max(-hallwayLength/2 - 24, Math.min(hallwayLength/2 - 1, camera.position.z));
          } else {
            // Normal hallway bounds
            camera.position.x = Math.max(-hallwayWidth/2 + 0.5, Math.min(hallwayWidth/2 - 0.5, camera.position.x));
            camera.position.z = Math.max(-hallwayLength/2 - 24, Math.min(hallwayLength/2 - 1, camera.position.z));
          }
        } else {
          camera.position.x = Math.max(-9, Math.min(9, camera.position.x));
          camera.position.z = Math.max(-11, Math.min(11, camera.position.z));
        }
        camera.position.y = 1.7;
      }

      updateInfo();
      renderer.render(scene, camera);
    }

    // Boot
    const bootScreen = document.getElementById('boot-screen');
    const bootProgress = document.getElementById('boot-progress');
    const bootText = document.getElementById('boot-text');
    const msgs = ['Initializing hallway...', 'Loading doors...', 'Polishing floors...', 'Activating neon...', 'Welcome to the Mansion'];
    let step = 0;
    const bootInt = setInterval(() => {
      step++;
      bootProgress.style.width = (step / msgs.length * 100) + '%';
      if (step < msgs.length) bootText.textContent = msgs[step];
      if (step >= msgs.length) {
        clearInterval(bootInt);
        setTimeout(() => {
          bootScreen.classList.add('hidden');
          document.getElementById('click-to-start').classList.remove('hidden');
          init();
        }, 500);
      }
    }, 400);

    // Clock
    function updateClock() { document.getElementById('clock').textContent = new Date().toLocaleTimeString('en-US', { hour12: false }); }
    updateClock(); setInterval(updateClock, 1000);

    // Pet
    const petBtn = document.getElementById('pet-btn');
    const petPopup = document.getElementById('pet-popup');
    const petDisplay = document.getElementById('pet-display');
    const petStatus = document.getElementById('pet-status');
    const petStages = ['ü•ö', 'üê£', 'üê•', 'üê§', 'üêî'];
    let petStage = parseInt(localStorage.getItem('petStage') || '0');
    let petHappiness = parseInt(localStorage.getItem('petHappiness') || '50');
    let petClicks = parseInt(localStorage.getItem('petClicks') || '0');

    function updatePet() {
      if (petStage === 0) {
        petDisplay.textContent = petBtn.textContent = 'ü•ö';
        petStatus.textContent = petClicks + '/10 clicks to hatch';
      } else {
        const s = Math.min(petStage, petStages.length - 1);
        petDisplay.textContent = petBtn.textContent = petStages[s];
        petStatus.textContent = 'Happiness: ' + petHappiness + '%';
      }
      localStorage.setItem('petStage', petStage);
      localStorage.setItem('petHappiness', petHappiness);
      localStorage.setItem('petClicks', petClicks);
    }

    petBtn.onclick = e => {
      e.stopPropagation();
      petPopup.classList.toggle('open');
      if (petStage === 0) { petClicks++; if (petClicks >= 10) { petStage = 1; petHappiness = 100; } updatePet(); }
    };
    document.getElementById('pet-interact').onclick = () => { if (petStage > 0) { petHappiness = Math.min(100, petHappiness + 10); if (petHappiness >= 100 && petStage < petStages.length - 1) petStage++; updatePet(); } };
    document.getElementById('pet-feed').onclick = () => { if (petStage > 0) { petHappiness = Math.min(100, petHappiness + 15); updatePet(); } };
    setInterval(() => { if (petStage > 0 && petHappiness > 0) { petHappiness--; updatePet(); } }, 30000);
    updatePet();
  </script>
</body>
</html>
