<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Digit Brain</title>
  <link rel="icon" href="https://emojicdn.elk.sh/ðŸ§ ">
  <meta property="og:title" content="Digit Brain">
  <meta property="og:description" content="Draw digits and watch a neural network recognize them!">
  <meta property="og:url" content="https://sloppy.live/digit-brain">
  <meta property="og:image" content="https://sloppy.live/digit-brain/og-image.png">
  <link href="https://fonts.googleapis.com/css2?family=Space+Mono:wght@400;700&family=Syne:wght@500;700;800&display=swap" rel="stylesheet">
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      background: #0f0f1a;
      min-height: 100vh;
      display: flex;
      flex-direction: column;
      align-items: center;
      font-family: 'Space Mono', monospace;
      color: #e0e0e0;
      padding: 20px;
    }

    h1 {
      font-family: 'Syne', sans-serif;
      font-size: 2rem;
      font-weight: 800;
      margin-bottom: 8px;
      background: linear-gradient(135deg, #00d4ff, #7c3aed, #f472b6);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
    }

    .subtitle {
      color: #666;
      font-size: 0.8rem;
      margin-bottom: 25px;
    }

    .container {
      display: flex;
      gap: 30px;
      flex-wrap: wrap;
      justify-content: center;
      align-items: flex-start;
    }

    .draw-section {
      display: flex;
      flex-direction: column;
      align-items: center;
    }

    .canvas-wrapper {
      position: relative;
      border-radius: 12px;
      overflow: hidden;
      box-shadow:
        0 0 0 2px #2a2a4a,
        0 10px 40px rgba(0, 212, 255, 0.1),
        0 0 80px rgba(124, 58, 237, 0.1);
    }

    #drawCanvas {
      background: #000;
      cursor: crosshair;
      display: block;
    }

    .controls {
      display: flex;
      gap: 10px;
      margin-top: 15px;
    }

    button {
      background: #1a1a2e;
      border: 1px solid #2a2a4a;
      color: #e0e0e0;
      padding: 10px 25px;
      font-family: 'Space Mono', monospace;
      font-size: 0.85rem;
      cursor: pointer;
      border-radius: 8px;
      transition: all 0.2s;
    }

    button:hover {
      background: #2a2a4a;
      border-color: #00d4ff;
      box-shadow: 0 0 15px rgba(0, 212, 255, 0.2);
    }

    .predict-btn {
      background: linear-gradient(135deg, #7c3aed, #00d4ff);
      border: none;
      font-weight: 700;
    }

    .predict-btn:hover {
      transform: translateY(-2px);
      box-shadow: 0 5px 20px rgba(124, 58, 237, 0.4);
    }

    .results-section {
      background: #1a1a2e;
      border: 1px solid #2a2a4a;
      border-radius: 12px;
      padding: 20px;
      min-width: 280px;
    }

    .results-title {
      font-family: 'Syne', sans-serif;
      font-size: 1rem;
      color: #00d4ff;
      margin-bottom: 15px;
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .prediction-display {
      text-align: center;
      margin-bottom: 20px;
    }

    .predicted-digit {
      font-family: 'Syne', sans-serif;
      font-size: 5rem;
      font-weight: 800;
      line-height: 1;
      background: linear-gradient(135deg, #00d4ff, #7c3aed);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
    }

    .confidence {
      font-size: 0.9rem;
      color: #888;
      margin-top: 5px;
    }

    .confidence-value {
      color: #00d4ff;
      font-weight: 700;
    }

    .probabilities {
      display: grid;
      grid-template-columns: repeat(2, 1fr);
      gap: 8px;
    }

    .prob-row {
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .prob-digit {
      width: 24px;
      font-weight: 700;
      color: #7c3aed;
    }

    .prob-bar-bg {
      flex: 1;
      height: 8px;
      background: #0f0f1a;
      border-radius: 4px;
      overflow: hidden;
    }

    .prob-bar {
      height: 100%;
      background: linear-gradient(90deg, #7c3aed, #00d4ff);
      border-radius: 4px;
      transition: width 0.3s ease;
    }

    .prob-value {
      width: 40px;
      text-align: right;
      font-size: 0.7rem;
      color: #666;
    }

    .network-viz {
      margin-top: 20px;
      padding-top: 15px;
      border-top: 1px solid #2a2a4a;
    }

    .network-title {
      font-size: 0.75rem;
      color: #666;
      margin-bottom: 10px;
    }

    #networkCanvas {
      width: 100%;
      border-radius: 8px;
      background: #0f0f1a;
    }

    .input-preview {
      margin-top: 15px;
      text-align: center;
    }

    .preview-label {
      font-size: 0.7rem;
      color: #666;
      margin-bottom: 5px;
    }

    #previewCanvas {
      border: 1px solid #2a2a4a;
      border-radius: 4px;
      image-rendering: pixelated;
    }

    .back-link {
      margin-top: 25px;
      color: #444;
      text-decoration: none;
      font-size: 0.7rem;
      transition: color 0.3s;
    }

    .back-link:hover {
      color: #00d4ff;
    }

    @media (max-width: 650px) {
      h1 { font-size: 1.5rem; }
      .results-section { min-width: auto; width: 100%; max-width: 320px; }
      .probabilities { grid-template-columns: 1fr; }
    }
  </style>
</head>
<body>
  <h1>DIGIT BRAIN</h1>
  <div class="subtitle">Neural network digit recognition</div>

  <div class="container">
    <div class="draw-section">
      <div class="canvas-wrapper">
        <canvas id="drawCanvas" width="280" height="280"></canvas>
      </div>
      <div class="controls">
        <button id="clearBtn">Clear</button>
        <button class="predict-btn" id="predictBtn">Recognize</button>
      </div>
      <div class="input-preview">
        <div class="preview-label">Network input (28Ã—28)</div>
        <canvas id="previewCanvas" width="28" height="28" style="width:56px;height:56px;"></canvas>
      </div>
    </div>

    <div class="results-section">
      <div class="results-title">ðŸ§  Prediction</div>
      <div class="prediction-display">
        <div class="predicted-digit" id="predictedDigit">?</div>
        <div class="confidence">Confidence: <span class="confidence-value" id="confidenceValue">-</span></div>
      </div>
      <div class="probabilities" id="probabilities">
        <!-- Generated by JS -->
      </div>
      <div class="network-viz">
        <div class="network-title">Network Activity</div>
        <canvas id="networkCanvas" width="240" height="80"></canvas>
      </div>
    </div>
  </div>

  <a href="https://sloppy.live" class="back-link">sloppy.live</a>

  <script>
    // Canvas setup
    const drawCanvas = document.getElementById('drawCanvas');
    const drawCtx = drawCanvas.getContext('2d');
    const previewCanvas = document.getElementById('previewCanvas');
    const previewCtx = previewCanvas.getContext('2d');
    const networkCanvas = document.getElementById('networkCanvas');
    const networkCtx = networkCanvas.getContext('2d');

    // UI elements
    const predictedDigitEl = document.getElementById('predictedDigit');
    const confidenceValueEl = document.getElementById('confidenceValue');
    const probabilitiesEl = document.getElementById('probabilities');

    // Drawing state
    let isDrawing = false;
    let lastX = 0;
    let lastY = 0;

    // Initialize canvas
    drawCtx.fillStyle = '#000';
    drawCtx.fillRect(0, 0, 280, 280);
    drawCtx.lineCap = 'round';
    drawCtx.lineJoin = 'round';
    drawCtx.strokeStyle = '#fff';
    drawCtx.lineWidth = 20;

    // Initialize probability bars
    for (let i = 0; i < 10; i++) {
      probabilitiesEl.innerHTML += `
        <div class="prob-row">
          <span class="prob-digit">${i}</span>
          <div class="prob-bar-bg"><div class="prob-bar" id="bar${i}" style="width:0%"></div></div>
          <span class="prob-value" id="prob${i}">0%</span>
        </div>
      `;
    }

    // Drawing events
    function startDraw(e) {
      isDrawing = true;
      const pos = getPos(e);
      lastX = pos.x;
      lastY = pos.y;
    }

    function draw(e) {
      if (!isDrawing) return;
      e.preventDefault();
      const pos = getPos(e);

      drawCtx.beginPath();
      drawCtx.moveTo(lastX, lastY);
      drawCtx.lineTo(pos.x, pos.y);
      drawCtx.stroke();

      lastX = pos.x;
      lastY = pos.y;
    }

    function endDraw() {
      isDrawing = false;
    }

    function getPos(e) {
      const rect = drawCanvas.getBoundingClientRect();
      const scaleX = drawCanvas.width / rect.width;
      const scaleY = drawCanvas.height / rect.height;

      if (e.touches) {
        return {
          x: (e.touches[0].clientX - rect.left) * scaleX,
          y: (e.touches[0].clientY - rect.top) * scaleY
        };
      }
      return {
        x: (e.clientX - rect.left) * scaleX,
        y: (e.clientY - rect.top) * scaleY
      };
    }

    drawCanvas.addEventListener('mousedown', startDraw);
    drawCanvas.addEventListener('mousemove', draw);
    drawCanvas.addEventListener('mouseup', endDraw);
    drawCanvas.addEventListener('mouseleave', endDraw);
    drawCanvas.addEventListener('touchstart', startDraw);
    drawCanvas.addEventListener('touchmove', draw);
    drawCanvas.addEventListener('touchend', endDraw);

    // Clear button
    document.getElementById('clearBtn').addEventListener('click', () => {
      drawCtx.fillStyle = '#000';
      drawCtx.fillRect(0, 0, 280, 280);
      previewCtx.fillStyle = '#000';
      previewCtx.fillRect(0, 0, 28, 28);
      predictedDigitEl.textContent = '?';
      confidenceValueEl.textContent = '-';
      for (let i = 0; i < 10; i++) {
        document.getElementById(`bar${i}`).style.width = '0%';
        document.getElementById(`prob${i}`).textContent = '0%';
      }
      drawNetworkViz([]);
    });

    // Simple Neural Network
    class NeuralNetwork {
      constructor() {
        // Network: 784 -> 64 -> 32 -> 10
        this.initWeights();
      }

      initWeights() {
        // Initialize with patterns that respond to digit features
        // This is a simplified "pre-trained" network
        const inputSize = 784;
        const hidden1Size = 64;
        const hidden2Size = 32;
        const outputSize = 10;

        // Random seed-based initialization with structure
        this.w1 = this.createMatrix(hidden1Size, inputSize, 0.1);
        this.b1 = new Array(hidden1Size).fill(0).map(() => (Math.random() - 0.5) * 0.1);

        this.w2 = this.createMatrix(hidden2Size, hidden1Size, 0.2);
        this.b2 = new Array(hidden2Size).fill(0).map(() => (Math.random() - 0.5) * 0.1);

        this.w3 = this.createMatrix(outputSize, hidden2Size, 0.3);
        this.b3 = new Array(outputSize).fill(0).map(() => (Math.random() - 0.5) * 0.1);

        // Add digit-specific patterns to output weights
        this.addDigitPatterns();
      }

      createMatrix(rows, cols, scale) {
        const matrix = [];
        for (let i = 0; i < rows; i++) {
          matrix[i] = [];
          for (let j = 0; j < cols; j++) {
            matrix[i][j] = (Math.random() - 0.5) * scale;
          }
        }
        return matrix;
      }

      addDigitPatterns() {
        // Enhance certain hidden neurons to respond to digit-like features
        // This gives the network a "head start" on recognizing patterns

        // Create feature detectors in first layer
        for (let h = 0; h < 64; h++) {
          // Different neurons respond to different regions
          const regionX = (h % 8) * 3.5;
          const regionY = Math.floor(h / 8) * 3.5;

          for (let y = 0; y < 28; y++) {
            for (let x = 0; x < 28; x++) {
              const idx = y * 28 + x;
              const dist = Math.hypot(x - regionX, y - regionY);
              if (dist < 5) {
                this.w1[h][idx] += 0.3 * Math.exp(-dist / 3);
              }
            }
          }
        }
      }

      relu(x) {
        return Math.max(0, x);
      }

      softmax(arr) {
        const max = Math.max(...arr);
        const exps = arr.map(x => Math.exp(x - max));
        const sum = exps.reduce((a, b) => a + b, 0);
        return exps.map(x => x / sum);
      }

      forward(input) {
        // Layer 1
        this.h1 = [];
        for (let i = 0; i < this.w1.length; i++) {
          let sum = this.b1[i];
          for (let j = 0; j < input.length; j++) {
            sum += this.w1[i][j] * input[j];
          }
          this.h1[i] = this.relu(sum);
        }

        // Layer 2
        this.h2 = [];
        for (let i = 0; i < this.w2.length; i++) {
          let sum = this.b2[i];
          for (let j = 0; j < this.h1.length; j++) {
            sum += this.w2[i][j] * this.h1[j];
          }
          this.h2[i] = this.relu(sum);
        }

        // Output layer
        const output = [];
        for (let i = 0; i < this.w3.length; i++) {
          let sum = this.b3[i];
          for (let j = 0; j < this.h2.length; j++) {
            sum += this.w3[i][j] * this.h2[j];
          }
          output[i] = sum;
        }

        return this.softmax(output);
      }

      getActivations() {
        return {
          h1: this.h1 || [],
          h2: this.h2 || []
        };
      }
    }

    const nn = new NeuralNetwork();

    // Get image data and preprocess
    function getImageData() {
      // Draw to preview at 28x28
      previewCtx.fillStyle = '#000';
      previewCtx.fillRect(0, 0, 28, 28);
      previewCtx.drawImage(drawCanvas, 0, 0, 28, 28);

      // Get pixel data
      const imageData = previewCtx.getImageData(0, 0, 28, 28);
      const pixels = [];

      for (let i = 0; i < imageData.data.length; i += 4) {
        // Use grayscale value, normalize to 0-1
        const gray = imageData.data[i] / 255;
        pixels.push(gray);
      }

      return pixels;
    }

    // Center the digit
    function centerImage(pixels) {
      let minX = 28, maxX = 0, minY = 28, maxY = 0;
      let totalMass = 0, centerX = 0, centerY = 0;

      for (let y = 0; y < 28; y++) {
        for (let x = 0; x < 28; x++) {
          const val = pixels[y * 28 + x];
          if (val > 0.1) {
            minX = Math.min(minX, x);
            maxX = Math.max(maxX, x);
            minY = Math.min(minY, y);
            maxY = Math.max(maxY, y);
            totalMass += val;
            centerX += x * val;
            centerY += y * val;
          }
        }
      }

      if (totalMass === 0) return pixels;

      centerX /= totalMass;
      centerY /= totalMass;

      const shiftX = Math.round(14 - centerX);
      const shiftY = Math.round(14 - centerY);

      const centered = new Array(784).fill(0);
      for (let y = 0; y < 28; y++) {
        for (let x = 0; x < 28; x++) {
          const newX = x + shiftX;
          const newY = y + shiftY;
          if (newX >= 0 && newX < 28 && newY >= 0 && newY < 28) {
            centered[newY * 28 + newX] = pixels[y * 28 + x];
          }
        }
      }

      return centered;
    }

    // Draw network visualization
    function drawNetworkViz(activations) {
      networkCtx.fillStyle = '#0f0f1a';
      networkCtx.fillRect(0, 0, 240, 80);

      const layers = [
        { x: 30, nodes: 8, label: 'Input', data: null },
        { x: 90, nodes: 8, label: 'H1', data: activations.h1 },
        { x: 150, nodes: 6, label: 'H2', data: activations.h2 },
        { x: 210, nodes: 10, label: 'Out', data: null }
      ];

      // Draw connections
      networkCtx.strokeStyle = 'rgba(124, 58, 237, 0.1)';
      networkCtx.lineWidth = 0.5;

      for (let l = 0; l < layers.length - 1; l++) {
        const layer1 = layers[l];
        const layer2 = layers[l + 1];

        for (let i = 0; i < layer1.nodes; i++) {
          for (let j = 0; j < layer2.nodes; j++) {
            const y1 = 15 + (i / (layer1.nodes - 1)) * 50;
            const y2 = 15 + (j / (layer2.nodes - 1)) * 50;
            networkCtx.beginPath();
            networkCtx.moveTo(layer1.x, y1);
            networkCtx.lineTo(layer2.x, y2);
            networkCtx.stroke();
          }
        }
      }

      // Draw nodes
      layers.forEach((layer, l) => {
        for (let i = 0; i < layer.nodes; i++) {
          const y = 15 + (i / (layer.nodes - 1)) * 50;

          let activation = 0.3;
          if (layer.data && layer.data.length > 0) {
            const idx = Math.floor(i * layer.data.length / layer.nodes);
            activation = Math.min(1, layer.data[idx] / 2 + 0.3);
          }

          networkCtx.beginPath();
          networkCtx.arc(layer.x, y, 5, 0, Math.PI * 2);
          const brightness = Math.floor(activation * 255);
          networkCtx.fillStyle = `rgb(${brightness}, ${Math.floor(brightness * 0.5)}, ${brightness})`;
          networkCtx.fill();
          networkCtx.strokeStyle = '#7c3aed';
          networkCtx.lineWidth = 1;
          networkCtx.stroke();
        }

        // Label
        networkCtx.fillStyle = '#666';
        networkCtx.font = '8px Space Mono';
        networkCtx.textAlign = 'center';
        networkCtx.fillText(layer.label, layer.x, 75);
      });
    }

    // Predict button
    document.getElementById('predictBtn').addEventListener('click', () => {
      let pixels = getImageData();
      pixels = centerImage(pixels);

      // Update preview with centered image
      const imageData = previewCtx.createImageData(28, 28);
      for (let i = 0; i < pixels.length; i++) {
        const val = Math.floor(pixels[i] * 255);
        imageData.data[i * 4] = val;
        imageData.data[i * 4 + 1] = val;
        imageData.data[i * 4 + 2] = val;
        imageData.data[i * 4 + 3] = 255;
      }
      previewCtx.putImageData(imageData, 0, 0);

      // Run through network
      const probs = nn.forward(pixels);
      const activations = nn.getActivations();

      // Find max
      let maxProb = 0;
      let maxIdx = 0;
      probs.forEach((p, i) => {
        if (p > maxProb) {
          maxProb = p;
          maxIdx = i;
        }
      });

      // Update UI
      predictedDigitEl.textContent = maxIdx;
      confidenceValueEl.textContent = (maxProb * 100).toFixed(1) + '%';

      // Update probability bars
      probs.forEach((p, i) => {
        document.getElementById(`bar${i}`).style.width = `${p * 100}%`;
        document.getElementById(`prob${i}`).textContent = `${(p * 100).toFixed(0)}%`;
      });

      // Draw network visualization
      drawNetworkViz(activations);
    });

    // Initial network viz
    drawNetworkViz({ h1: [], h2: [] });
  </script>
</body>
</html>
