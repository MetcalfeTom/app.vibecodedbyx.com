<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Digit Brain</title>
  <link rel="icon" href="https://emojicdn.elk.sh/ðŸ§ ">
  <meta property="og:title" content="Digit Brain">
  <meta property="og:description" content="Draw digits and watch a neural network recognize them!">
  <meta property="og:url" content="https://app.sloppy.live/digit-brain">
  <meta property="og:image" content="https://app.sloppy.live/digit-brain/og-image.png">
  <link href="https://fonts.googleapis.com/css2?family=Space+Mono:wght@400;700&family=Syne:wght@500;700;800&display=swap" rel="stylesheet">
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      background: #0f0f1a;
      min-height: 100vh;
      display: flex;
      flex-direction: column;
      align-items: center;
      font-family: 'Space Mono', monospace;
      color: #e0e0e0;
      padding: 20px;
    }

    h1 {
      font-family: 'Syne', sans-serif;
      font-size: 2rem;
      font-weight: 800;
      margin-bottom: 8px;
      background: linear-gradient(135deg, #00d4ff, #7c3aed, #f472b6);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
    }

    .subtitle {
      color: #666;
      font-size: 0.8rem;
      margin-bottom: 25px;
    }

    .container {
      display: flex;
      gap: 30px;
      flex-wrap: wrap;
      justify-content: center;
      align-items: flex-start;
    }

    .draw-section {
      display: flex;
      flex-direction: column;
      align-items: center;
    }

    .canvas-wrapper {
      position: relative;
      border-radius: 12px;
      overflow: hidden;
      box-shadow:
        0 0 0 2px #2a2a4a,
        0 10px 40px rgba(0, 212, 255, 0.1),
        0 0 80px rgba(124, 58, 237, 0.1);
    }

    #drawCanvas {
      background: #000;
      cursor: crosshair;
      display: block;
    }

    .controls {
      display: flex;
      gap: 10px;
      margin-top: 15px;
    }

    button {
      background: #1a1a2e;
      border: 1px solid #2a2a4a;
      color: #e0e0e0;
      padding: 10px 25px;
      font-family: 'Space Mono', monospace;
      font-size: 0.85rem;
      cursor: pointer;
      border-radius: 8px;
      transition: all 0.2s;
    }

    button:hover {
      background: #2a2a4a;
      border-color: #00d4ff;
      box-shadow: 0 0 15px rgba(0, 212, 255, 0.2);
    }

    .predict-btn {
      background: linear-gradient(135deg, #7c3aed, #00d4ff);
      border: none;
      font-weight: 700;
    }

    .predict-btn:hover {
      transform: translateY(-2px);
      box-shadow: 0 5px 20px rgba(124, 58, 237, 0.4);
    }

    .results-section {
      background: #1a1a2e;
      border: 1px solid #2a2a4a;
      border-radius: 12px;
      padding: 20px;
      min-width: 280px;
    }

    .results-title {
      font-family: 'Syne', sans-serif;
      font-size: 1rem;
      color: #00d4ff;
      margin-bottom: 15px;
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .prediction-display {
      text-align: center;
      margin-bottom: 20px;
    }

    .predicted-digit {
      font-family: 'Syne', sans-serif;
      font-size: 5rem;
      font-weight: 800;
      line-height: 1;
      background: linear-gradient(135deg, #00d4ff, #7c3aed);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
    }

    .confidence {
      font-size: 0.9rem;
      color: #888;
      margin-top: 5px;
    }

    .confidence-value {
      color: #00d4ff;
      font-weight: 700;
    }

    .probabilities {
      display: grid;
      grid-template-columns: repeat(2, 1fr);
      gap: 8px;
    }

    .prob-row {
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .prob-digit {
      width: 24px;
      font-weight: 700;
      color: #7c3aed;
    }

    .prob-bar-bg {
      flex: 1;
      height: 8px;
      background: #0f0f1a;
      border-radius: 4px;
      overflow: hidden;
    }

    .prob-bar {
      height: 100%;
      background: linear-gradient(90deg, #7c3aed, #00d4ff);
      border-radius: 4px;
      transition: width 0.3s ease;
    }

    .prob-value {
      width: 40px;
      text-align: right;
      font-size: 0.7rem;
      color: #666;
    }

    .network-viz {
      margin-top: 20px;
      padding-top: 15px;
      border-top: 1px solid #2a2a4a;
    }

    .network-title {
      font-size: 0.75rem;
      color: #666;
      margin-bottom: 10px;
    }

    #networkCanvas {
      width: 100%;
      border-radius: 8px;
      background: #0f0f1a;
    }

    .input-preview {
      margin-top: 15px;
      text-align: center;
    }

    .preview-label {
      font-size: 0.7rem;
      color: #666;
      margin-bottom: 5px;
    }

    #previewCanvas {
      border: 1px solid #2a2a4a;
      border-radius: 4px;
      image-rendering: pixelated;
    }

    .back-link {
      margin-top: 25px;
      color: #444;
      text-decoration: none;
      font-size: 0.7rem;
      transition: color 0.3s;
    }

    .back-link:hover {
      color: #00d4ff;
    }

    @media (max-width: 650px) {
      h1 { font-size: 1.5rem; }
      .results-section { min-width: auto; width: 100%; max-width: 320px; }
      .probabilities { grid-template-columns: 1fr; }
    }
  </style>
</head>
<body>
  <h1>DIGIT BRAIN</h1>
  <div class="subtitle">Neural network digit recognition</div>

  <div class="container">
    <div class="draw-section">
      <div class="canvas-wrapper">
        <canvas id="drawCanvas" width="280" height="280"></canvas>
      </div>
      <div class="controls">
        <button id="clearBtn">Clear</button>
        <button class="predict-btn" id="predictBtn">Recognize</button>
      </div>
      <div class="input-preview">
        <div class="preview-label">Network input (28Ã—28)</div>
        <canvas id="previewCanvas" width="28" height="28" style="width:56px;height:56px;"></canvas>
      </div>
    </div>

    <div class="results-section">
      <div class="results-title">ðŸ§  Prediction</div>
      <div class="prediction-display">
        <div class="predicted-digit" id="predictedDigit">?</div>
        <div class="confidence">Confidence: <span class="confidence-value" id="confidenceValue">-</span></div>
      </div>
      <div class="probabilities" id="probabilities">
        <!-- Generated by JS -->
      </div>
      <div class="network-viz">
        <div class="network-title">Network Activity</div>
        <canvas id="networkCanvas" width="240" height="80"></canvas>
      </div>
    </div>
  </div>

  <a href="https://sloppy.live" class="back-link">sloppy.live</a>

  <script>
    // Canvas setup
    const drawCanvas = document.getElementById('drawCanvas');
    const drawCtx = drawCanvas.getContext('2d');
    const previewCanvas = document.getElementById('previewCanvas');
    const previewCtx = previewCanvas.getContext('2d');
    const networkCanvas = document.getElementById('networkCanvas');
    const networkCtx = networkCanvas.getContext('2d');

    // UI elements
    const predictedDigitEl = document.getElementById('predictedDigit');
    const confidenceValueEl = document.getElementById('confidenceValue');
    const probabilitiesEl = document.getElementById('probabilities');

    // Drawing state
    let isDrawing = false;
    let lastX = 0;
    let lastY = 0;

    // Initialize canvas
    drawCtx.fillStyle = '#000';
    drawCtx.fillRect(0, 0, 280, 280);
    drawCtx.lineCap = 'round';
    drawCtx.lineJoin = 'round';
    drawCtx.strokeStyle = '#fff';
    drawCtx.lineWidth = 20;

    // Initialize probability bars
    for (let i = 0; i < 10; i++) {
      probabilitiesEl.innerHTML += `
        <div class="prob-row">
          <span class="prob-digit">${i}</span>
          <div class="prob-bar-bg"><div class="prob-bar" id="bar${i}" style="width:0%"></div></div>
          <span class="prob-value" id="prob${i}">0%</span>
        </div>
      `;
    }

    // Drawing events
    function startDraw(e) {
      isDrawing = true;
      const pos = getPos(e);
      lastX = pos.x;
      lastY = pos.y;
    }

    function draw(e) {
      if (!isDrawing) return;
      e.preventDefault();
      const pos = getPos(e);

      drawCtx.beginPath();
      drawCtx.moveTo(lastX, lastY);
      drawCtx.lineTo(pos.x, pos.y);
      drawCtx.stroke();

      lastX = pos.x;
      lastY = pos.y;
    }

    function endDraw() {
      isDrawing = false;
    }

    function getPos(e) {
      const rect = drawCanvas.getBoundingClientRect();
      const scaleX = drawCanvas.width / rect.width;
      const scaleY = drawCanvas.height / rect.height;

      if (e.touches) {
        return {
          x: (e.touches[0].clientX - rect.left) * scaleX,
          y: (e.touches[0].clientY - rect.top) * scaleY
        };
      }
      return {
        x: (e.clientX - rect.left) * scaleX,
        y: (e.clientY - rect.top) * scaleY
      };
    }

    drawCanvas.addEventListener('mousedown', startDraw);
    drawCanvas.addEventListener('mousemove', draw);
    drawCanvas.addEventListener('mouseup', endDraw);
    drawCanvas.addEventListener('mouseleave', endDraw);
    drawCanvas.addEventListener('touchstart', startDraw);
    drawCanvas.addEventListener('touchmove', draw);
    drawCanvas.addEventListener('touchend', endDraw);

    // Clear button
    document.getElementById('clearBtn').addEventListener('click', () => {
      drawCtx.fillStyle = '#000';
      drawCtx.fillRect(0, 0, 280, 280);
      previewCtx.fillStyle = '#000';
      previewCtx.fillRect(0, 0, 28, 28);
      predictedDigitEl.textContent = '?';
      confidenceValueEl.textContent = '-';
      for (let i = 0; i < 10; i++) {
        document.getElementById(`bar${i}`).style.width = '0%';
        document.getElementById(`prob${i}`).textContent = '0%';
      }
      drawNetworkViz([]);
    });

    // Template-based digit recognizer with neural network structure
    class NeuralNetwork {
      constructor() {
        this.createDigitTemplates();
      }

      createDigitTemplates() {
        // Create 28x28 templates for each digit
        this.templates = [];

        for (let d = 0; d < 10; d++) {
          this.templates[d] = new Array(784).fill(0);
        }

        const cx = 14, cy = 14; // Center

        // DIGIT 0: Oval/circle shape
        for (let y = 0; y < 28; y++) {
          for (let x = 0; x < 28; x++) {
            const dx = (x - cx) / 8;
            const dy = (y - cy) / 10;
            const dist = Math.sqrt(dx*dx + dy*dy);
            if (dist > 0.6 && dist < 1.2) {
              this.templates[0][y * 28 + x] = Math.exp(-Math.pow(dist - 0.9, 2) * 10);
            }
          }
        }

        // DIGIT 1: Vertical line
        for (let y = 0; y < 28; y++) {
          for (let x = 0; x < 28; x++) {
            const distFromCenter = Math.abs(x - cx);
            if (distFromCenter < 4 && y > 4 && y < 24) {
              this.templates[1][y * 28 + x] = Math.exp(-distFromCenter * 0.5);
            }
            // Small hook at top
            if (y < 8 && y > 4 && x < cx && x > cx - 6) {
              this.templates[1][y * 28 + x] = 0.5;
            }
          }
        }

        // DIGIT 2: Curve top, diagonal, horizontal bottom
        for (let y = 0; y < 28; y++) {
          for (let x = 0; x < 28; x++) {
            // Top curve
            if (y < 12 && y > 4) {
              const curveX = cx + 5 * Math.cos(Math.PI * (1 - (y-4)/8));
              const curveY = 8 + 4 * Math.sin(Math.PI * (1 - (y-4)/8));
              const dist = Math.hypot(x - curveX, y - curveY);
              if (dist < 4) this.templates[2][y * 28 + x] = Math.max(this.templates[2][y * 28 + x], Math.exp(-dist * 0.4));
            }
            // Diagonal middle
            if (y >= 10 && y <= 20) {
              const expectedX = cx + 6 - (y - 10) * 0.8;
              const dist = Math.abs(x - expectedX);
              if (dist < 3) this.templates[2][y * 28 + x] = Math.max(this.templates[2][y * 28 + x], Math.exp(-dist * 0.4));
            }
            // Bottom horizontal
            if (y > 20 && y < 25 && x > 6 && x < 22) {
              this.templates[2][y * 28 + x] = Math.max(this.templates[2][y * 28 + x], 0.8);
            }
          }
        }

        // DIGIT 3: Two curves on right
        for (let y = 0; y < 28; y++) {
          for (let x = 0; x < 28; x++) {
            // Top curve
            const t1 = (y - 8) / 6;
            if (t1 >= -1 && t1 <= 1) {
              const curveX = cx + 5 * Math.sqrt(1 - t1*t1);
              const dist = Math.abs(x - curveX);
              if (dist < 3 && x > cx - 5) this.templates[3][y * 28 + x] = Math.exp(-dist * 0.3);
            }
            // Bottom curve
            const t2 = (y - 20) / 6;
            if (t2 >= -1 && t2 <= 1) {
              const curveX = cx + 5 * Math.sqrt(1 - t2*t2);
              const dist = Math.abs(x - curveX);
              if (dist < 3 && x > cx - 5) this.templates[3][y * 28 + x] = Math.max(this.templates[3][y * 28 + x], Math.exp(-dist * 0.3));
            }
          }
        }

        // DIGIT 4: Vertical with horizontal cross
        for (let y = 0; y < 28; y++) {
          for (let x = 0; x < 28; x++) {
            // Main vertical (right side)
            if (Math.abs(x - (cx + 4)) < 3 && y > 4 && y < 24) {
              this.templates[4][y * 28 + x] = Math.exp(-Math.abs(x - (cx + 4)) * 0.4);
            }
            // Diagonal from top-left
            if (y < 16 && y > 4) {
              const expectedX = cx - 6 + (y - 4) * 0.8;
              if (Math.abs(x - expectedX) < 3) {
                this.templates[4][y * 28 + x] = Math.max(this.templates[4][y * 28 + x], Math.exp(-Math.abs(x - expectedX) * 0.4));
              }
            }
            // Horizontal cross
            if (y > 13 && y < 18 && x > 6 && x < 22) {
              this.templates[4][y * 28 + x] = Math.max(this.templates[4][y * 28 + x], 0.7);
            }
          }
        }

        // DIGIT 5: Top horizontal, vertical, bottom curve
        for (let y = 0; y < 28; y++) {
          for (let x = 0; x < 28; x++) {
            // Top horizontal
            if (y > 4 && y < 9 && x > 8 && x < 20) {
              this.templates[5][y * 28 + x] = 0.8;
            }
            // Left vertical
            if (y > 6 && y < 16 && Math.abs(x - 9) < 3) {
              this.templates[5][y * 28 + x] = Math.max(this.templates[5][y * 28 + x], Math.exp(-Math.abs(x - 9) * 0.4));
            }
            // Bottom curve
            const t = (y - 19) / 5;
            if (t >= -1 && t <= 1 && y > 12) {
              const curveX = cx + 4 * Math.sqrt(1 - t*t);
              const dist = Math.abs(x - curveX);
              if (dist < 4 && x > 6) this.templates[5][y * 28 + x] = Math.max(this.templates[5][y * 28 + x], Math.exp(-dist * 0.3));
            }
          }
        }

        // DIGIT 6: Big curve with loop at bottom
        for (let y = 0; y < 28; y++) {
          for (let x = 0; x < 28; x++) {
            // Main curve from top
            if (y < 18) {
              const expectedX = cx - 4 + Math.sin((y - 4) / 14 * Math.PI) * 6;
              const dist = Math.abs(x - expectedX);
              if (dist < 3 && y > 4) this.templates[6][y * 28 + x] = Math.exp(-dist * 0.4);
            }
            // Bottom loop
            const dx = (x - cx) / 6;
            const dy = (y - 19) / 5;
            const dist = Math.sqrt(dx*dx + dy*dy);
            if (dist > 0.5 && dist < 1.3 && y > 13) {
              this.templates[6][y * 28 + x] = Math.max(this.templates[6][y * 28 + x], Math.exp(-Math.pow(dist - 0.9, 2) * 8));
            }
          }
        }

        // DIGIT 7: Top horizontal + diagonal
        for (let y = 0; y < 28; y++) {
          for (let x = 0; x < 28; x++) {
            // Top horizontal
            if (y > 4 && y < 9 && x > 6 && x < 22) {
              this.templates[7][y * 28 + x] = 0.9;
            }
            // Diagonal
            if (y > 7) {
              const expectedX = cx + 5 - (y - 7) * 0.4;
              const dist = Math.abs(x - expectedX);
              if (dist < 3) this.templates[7][y * 28 + x] = Math.max(this.templates[7][y * 28 + x], Math.exp(-dist * 0.4));
            }
          }
        }

        // DIGIT 8: Two stacked loops
        for (let y = 0; y < 28; y++) {
          for (let x = 0; x < 28; x++) {
            // Top loop
            const dx1 = (x - cx) / 5;
            const dy1 = (y - 9) / 5;
            const dist1 = Math.sqrt(dx1*dx1 + dy1*dy1);
            if (dist1 > 0.5 && dist1 < 1.3) {
              this.templates[8][y * 28 + x] = Math.exp(-Math.pow(dist1 - 0.9, 2) * 8);
            }
            // Bottom loop (slightly larger)
            const dx2 = (x - cx) / 6;
            const dy2 = (y - 19) / 5;
            const dist2 = Math.sqrt(dx2*dx2 + dy2*dy2);
            if (dist2 > 0.5 && dist2 < 1.3) {
              this.templates[8][y * 28 + x] = Math.max(this.templates[8][y * 28 + x], Math.exp(-Math.pow(dist2 - 0.9, 2) * 8));
            }
          }
        }

        // DIGIT 9: Top loop + vertical down
        for (let y = 0; y < 28; y++) {
          for (let x = 0; x < 28; x++) {
            // Top loop
            const dx = (x - cx) / 6;
            const dy = (y - 10) / 5;
            const dist = Math.sqrt(dx*dx + dy*dy);
            if (dist > 0.5 && dist < 1.3 && y < 18) {
              this.templates[9][y * 28 + x] = Math.exp(-Math.pow(dist - 0.9, 2) * 8);
            }
            // Vertical stroke down right side
            if (y > 8 && Math.abs(x - (cx + 5)) < 3) {
              this.templates[9][y * 28 + x] = Math.max(this.templates[9][y * 28 + x], Math.exp(-Math.abs(x - (cx + 5)) * 0.4));
            }
          }
        }

        // Normalize templates
        for (let d = 0; d < 10; d++) {
          const max = Math.max(...this.templates[d]);
          if (max > 0) {
            for (let i = 0; i < 784; i++) {
              this.templates[d][i] /= max;
            }
          }
        }
      }

      relu(x) {
        return Math.max(0, x);
      }

      softmax(arr) {
        const max = Math.max(...arr);
        const exps = arr.map(x => Math.exp((x - max) * 2));
        const sum = exps.reduce((a, b) => a + b, 0);
        return exps.map(x => x / sum);
      }

      forward(input) {
        // Feature extraction layer - compute regional activations
        this.h1 = [];

        // 64 regional feature detectors (8x8 grid)
        for (let ry = 0; ry < 8; ry++) {
          for (let rx = 0; rx < 8; rx++) {
            let activation = 0;
            const startY = ry * 3;
            const startX = rx * 3;
            for (let dy = 0; dy < 5; dy++) {
              for (let dx = 0; dx < 5; dx++) {
                const y = startY + dy;
                const x = startX + dx;
                if (y < 28 && x < 28) {
                  activation += input[y * 28 + x];
                }
              }
            }
            this.h1.push(this.relu(activation / 25 - 0.1));
          }
        }

        // Second layer - combine features
        this.h2 = [];
        // Horizontal line detectors
        for (let row = 0; row < 8; row++) {
          let lineScore = 0;
          for (let col = 0; col < 8; col++) {
            lineScore += this.h1[row * 8 + col];
          }
          this.h2.push(this.relu(lineScore / 8 - 0.2));
        }
        // Vertical line detectors
        for (let col = 0; col < 8; col++) {
          let lineScore = 0;
          for (let row = 0; row < 8; row++) {
            lineScore += this.h1[row * 8 + col];
          }
          this.h2.push(this.relu(lineScore / 8 - 0.2));
        }
        // Diagonal detectors
        let diag1 = 0, diag2 = 0;
        for (let i = 0; i < 8; i++) {
          diag1 += this.h1[i * 8 + i];
          diag2 += this.h1[i * 8 + (7 - i)];
        }
        this.h2.push(this.relu(diag1 / 8 - 0.2));
        this.h2.push(this.relu(diag2 / 8 - 0.2));

        // Quadrant density
        const quads = [[0,0], [0,4], [4,0], [4,4]];
        for (const [qy, qx] of quads) {
          let density = 0;
          for (let dy = 0; dy < 4; dy++) {
            for (let dx = 0; dx < 4; dx++) {
              density += this.h1[(qy + dy) * 8 + qx + dx];
            }
          }
          this.h2.push(this.relu(density / 16 - 0.15));
        }

        // Center density
        let centerDensity = 0;
        for (let dy = 2; dy < 6; dy++) {
          for (let dx = 2; dx < 6; dx++) {
            centerDensity += this.h1[dy * 8 + dx];
          }
        }
        this.h2.push(this.relu(centerDensity / 16 - 0.15));

        // Edge density (perimeter)
        let edgeDensity = 0;
        for (let i = 0; i < 8; i++) {
          edgeDensity += this.h1[i] + this.h1[56 + i] + this.h1[i * 8] + this.h1[i * 8 + 7];
        }
        this.h2.push(this.relu(edgeDensity / 32 - 0.1));

        // Output layer - template matching with learned biases
        const scores = [];
        const biases = [-0.1, 0.15, -0.05, -0.05, 0.0, -0.05, -0.1, 0.1, -0.15, -0.05];

        for (let d = 0; d < 10; d++) {
          let score = biases[d];
          let templateSum = 0;
          let inputSum = 0;
          let matchSum = 0;

          for (let i = 0; i < 784; i++) {
            const t = this.templates[d][i];
            const p = input[i];
            matchSum += t * p;
            templateSum += t * t;
            inputSum += p * p;
          }

          // Normalized correlation
          const denom = Math.sqrt(templateSum * inputSum) + 0.001;
          score += matchSum / denom;

          // Penalize for pixels where input exists but template doesn't
          let mismatchPenalty = 0;
          for (let i = 0; i < 784; i++) {
            if (input[i] > 0.3 && this.templates[d][i] < 0.1) {
              mismatchPenalty += input[i] * 0.3;
            }
          }
          score -= mismatchPenalty / 50;

          scores.push(score);
        }

        return this.softmax(scores);
      }

      getActivations() {
        return {
          h1: this.h1 || [],
          h2: this.h2 || []
        };
      }
    }

    const nn = new NeuralNetwork();

    // Get image data and preprocess
    function getImageData() {
      // Draw to preview at 28x28
      previewCtx.fillStyle = '#000';
      previewCtx.fillRect(0, 0, 28, 28);
      previewCtx.drawImage(drawCanvas, 0, 0, 28, 28);

      // Get pixel data
      const imageData = previewCtx.getImageData(0, 0, 28, 28);
      const pixels = [];

      for (let i = 0; i < imageData.data.length; i += 4) {
        // Use grayscale value, normalize to 0-1
        const gray = imageData.data[i] / 255;
        pixels.push(gray);
      }

      return pixels;
    }

    // Center the digit
    function centerImage(pixels) {
      let minX = 28, maxX = 0, minY = 28, maxY = 0;
      let totalMass = 0, centerX = 0, centerY = 0;

      for (let y = 0; y < 28; y++) {
        for (let x = 0; x < 28; x++) {
          const val = pixels[y * 28 + x];
          if (val > 0.1) {
            minX = Math.min(minX, x);
            maxX = Math.max(maxX, x);
            minY = Math.min(minY, y);
            maxY = Math.max(maxY, y);
            totalMass += val;
            centerX += x * val;
            centerY += y * val;
          }
        }
      }

      if (totalMass === 0) return pixels;

      centerX /= totalMass;
      centerY /= totalMass;

      const shiftX = Math.round(14 - centerX);
      const shiftY = Math.round(14 - centerY);

      const centered = new Array(784).fill(0);
      for (let y = 0; y < 28; y++) {
        for (let x = 0; x < 28; x++) {
          const newX = x + shiftX;
          const newY = y + shiftY;
          if (newX >= 0 && newX < 28 && newY >= 0 && newY < 28) {
            centered[newY * 28 + newX] = pixels[y * 28 + x];
          }
        }
      }

      return centered;
    }

    // Draw network visualization
    function drawNetworkViz(activations) {
      networkCtx.fillStyle = '#0f0f1a';
      networkCtx.fillRect(0, 0, 240, 80);

      const layers = [
        { x: 30, nodes: 8, label: 'Input', data: null },
        { x: 90, nodes: 8, label: 'H1', data: activations.h1 },
        { x: 150, nodes: 6, label: 'H2', data: activations.h2 },
        { x: 210, nodes: 10, label: 'Out', data: null }
      ];

      // Draw connections
      networkCtx.strokeStyle = 'rgba(124, 58, 237, 0.1)';
      networkCtx.lineWidth = 0.5;

      for (let l = 0; l < layers.length - 1; l++) {
        const layer1 = layers[l];
        const layer2 = layers[l + 1];

        for (let i = 0; i < layer1.nodes; i++) {
          for (let j = 0; j < layer2.nodes; j++) {
            const y1 = 15 + (i / (layer1.nodes - 1)) * 50;
            const y2 = 15 + (j / (layer2.nodes - 1)) * 50;
            networkCtx.beginPath();
            networkCtx.moveTo(layer1.x, y1);
            networkCtx.lineTo(layer2.x, y2);
            networkCtx.stroke();
          }
        }
      }

      // Draw nodes
      layers.forEach((layer, l) => {
        for (let i = 0; i < layer.nodes; i++) {
          const y = 15 + (i / (layer.nodes - 1)) * 50;

          let activation = 0.3;
          if (layer.data && layer.data.length > 0) {
            const idx = Math.floor(i * layer.data.length / layer.nodes);
            activation = Math.min(1, layer.data[idx] / 2 + 0.3);
          }

          networkCtx.beginPath();
          networkCtx.arc(layer.x, y, 5, 0, Math.PI * 2);
          const brightness = Math.floor(activation * 255);
          networkCtx.fillStyle = `rgb(${brightness}, ${Math.floor(brightness * 0.5)}, ${brightness})`;
          networkCtx.fill();
          networkCtx.strokeStyle = '#7c3aed';
          networkCtx.lineWidth = 1;
          networkCtx.stroke();
        }

        // Label
        networkCtx.fillStyle = '#666';
        networkCtx.font = '8px Space Mono';
        networkCtx.textAlign = 'center';
        networkCtx.fillText(layer.label, layer.x, 75);
      });
    }

    // Predict button
    document.getElementById('predictBtn').addEventListener('click', () => {
      let pixels = getImageData();
      pixels = centerImage(pixels);

      // Update preview with centered image
      const imageData = previewCtx.createImageData(28, 28);
      for (let i = 0; i < pixels.length; i++) {
        const val = Math.floor(pixels[i] * 255);
        imageData.data[i * 4] = val;
        imageData.data[i * 4 + 1] = val;
        imageData.data[i * 4 + 2] = val;
        imageData.data[i * 4 + 3] = 255;
      }
      previewCtx.putImageData(imageData, 0, 0);

      // Run through network
      const probs = nn.forward(pixels);
      const activations = nn.getActivations();

      // Find max
      let maxProb = 0;
      let maxIdx = 0;
      probs.forEach((p, i) => {
        if (p > maxProb) {
          maxProb = p;
          maxIdx = i;
        }
      });

      // Update UI
      predictedDigitEl.textContent = maxIdx;
      confidenceValueEl.textContent = (maxProb * 100).toFixed(1) + '%';

      // Update probability bars
      probs.forEach((p, i) => {
        document.getElementById(`bar${i}`).style.width = `${p * 100}%`;
        document.getElementById(`prob${i}`).textContent = `${(p * 100).toFixed(0)}%`;
      });

      // Draw network visualization
      drawNetworkViz(activations);
    });

    // Initial network viz
    drawNetworkViz({ h1: [], h2: [] });
  </script>
<script src="/sloppy-header/sloppy-bar.js"></script>
<script src="/vibelib-extended.js"></script>
<script>
  // Compatibility Patch for Legacy Apps
  window.addEventListener("load", () => {
    if (window.SloppyKarma && window.VibeLib.Economy) {
      // Redirect old calls to new engine
      window.SloppyKarma.track = window.VibeLib.Economy.track;
    }
  });
</script>
</body>
</html>
