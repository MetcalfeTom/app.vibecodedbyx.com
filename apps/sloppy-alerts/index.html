<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sloppy Alerts</title>
    <link rel="icon" href="https://emojicdn.elk.sh/üîî">
    <meta property="og:title" content="Sloppy Alerts">
    <meta property="og:description" content="Universal notification grid. Every mention, vote, follow, battle ‚Äî one place.">
    <meta property="og:url" content="https://app.sloppy.live/sloppy-alerts">
    <meta property="og:image" content="https://pollinations.ai/p/a%20dark%20terminal%20screen%20with%20rows%20of%20glowing%20amber%20notification%20alerts%20scrolling%20pixel%20art?width=1200&height=630&nologo=true&referrer=sloppy.live">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link href="https://fonts.googleapis.com/css2?family=Instrument+Serif:ital@0;1&family=IBM+Plex+Mono:wght@300;400;500;700&display=swap" rel="stylesheet">
    <style>
        :root {
            --bg: #0a0908;
            --surface: #141210;
            --surface-hover: #1c1a16;
            --border: #2a2620;
            --border-active: #4a4230;
            --text: #e8e2d8;
            --text-dim: #9a9080;
            --text-muted: #5a5448;
            --amber: #f0a830;
            --amber-dim: #b07818;
            --amber-glow: rgba(240,168,48,0.12);
            --red: #e05040;
            --green: #40c870;
            --blue: #4890e0;
            --purple: #a070e0;
            --cyan: #40c8d0;
            --serif: 'Instrument Serif', Georgia, serif;
            --mono: 'IBM Plex Mono', 'Courier New', monospace;
        }
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            background: var(--bg);
            color: var(--text);
            font-family: var(--mono);
            font-size: 13px;
            min-height: 100vh;
        }
        a { color: var(--amber); text-decoration: none; }
        a:hover { text-decoration: underline; }

        .app-header {
            text-align: center;
            padding: 28px 16px 20px;
            border-bottom: 1px solid var(--border);
            background: linear-gradient(180deg, #141210 0%, var(--bg) 100%);
        }
        .app-header h1 {
            font-family: var(--serif);
            font-size: 2.2rem;
            font-weight: 400;
            color: var(--text);
        }
        .app-header h1 em { color: var(--amber); font-style: italic; }
        .app-header .subtitle {
            font-size: 10px;
            color: var(--text-muted);
            margin-top: 4px;
            letter-spacing: 0.1em;
            text-transform: uppercase;
        }
        .counters {
            display: flex;
            gap: 16px;
            justify-content: center;
            margin-top: 12px;
            font-size: 11px;
            color: var(--text-dim);
        }
        .counters .ct { display: flex; align-items: center; gap: 4px; }
        .counters .ct strong { color: var(--amber); font-size: 14px; }

        .toolbar {
            display: flex;
            align-items: center;
            gap: 6px;
            padding: 8px 12px;
            border-bottom: 1px solid var(--border);
            background: var(--surface);
            position: sticky;
            top: 0;
            z-index: 50;
            flex-wrap: wrap;
        }
        .filter-btn {
            background: none;
            border: 1px solid var(--border);
            color: var(--text-dim);
            font-family: var(--mono);
            font-size: 10px;
            padding: 4px 10px;
            border-radius: 3px;
            cursor: pointer;
            transition: all 0.15s;
            white-space: nowrap;
        }
        .filter-btn:hover { color: var(--text); border-color: var(--border-active); }
        .filter-btn.active { color: var(--amber); border-color: var(--amber-dim); background: var(--amber-glow); }
        .filter-btn .badge {
            display: inline-block;
            background: var(--amber-dim);
            color: #fff;
            font-size: 9px;
            padding: 1px 5px;
            border-radius: 8px;
            margin-left: 4px;
            font-weight: 700;
        }
        .toolbar-right {
            margin-left: auto;
            display: flex;
            gap: 6px;
            align-items: center;
        }
        .mark-read-btn {
            background: none;
            border: 1px solid var(--border);
            color: var(--text-muted);
            font-family: var(--mono);
            font-size: 10px;
            padding: 4px 10px;
            border-radius: 3px;
            cursor: pointer;
        }
        .mark-read-btn:hover { color: var(--amber); border-color: var(--amber-dim); }

        .grid {
            max-width: 700px;
            margin: 0 auto;
            padding: 8px 8px 80px;
        }
        .grid-loading { text-align: center; padding: 40px; color: var(--text-muted); font-size: 12px; }
        .grid-empty {
            text-align: center;
            padding: 60px 20px;
            color: var(--text-muted);
        }
        .grid-empty .icon { font-size: 2.4rem; margin-bottom: 8px; }

        .alert-card {
            display: flex;
            gap: 10px;
            padding: 10px 12px;
            border-bottom: 1px solid var(--border);
            transition: background 0.15s;
            align-items: flex-start;
        }
        .alert-card:hover { background: var(--surface-hover); }
        .alert-card.unread { background: var(--amber-glow); border-left: 2px solid var(--amber); }
        .alert-icon {
            width: 32px;
            height: 32px;
            border-radius: 6px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 15px;
            flex-shrink: 0;
        }
        .alert-icon.mention { background: rgba(72,144,224,0.15); }
        .alert-icon.vote { background: rgba(64,200,112,0.15); }
        .alert-icon.follow { background: rgba(160,112,224,0.15); }
        .alert-icon.comment { background: rgba(240,168,48,0.15); }
        .alert-icon.reaction { background: rgba(224,80,64,0.15); }
        .alert-icon.battle { background: rgba(224,80,64,0.15); }
        .alert-icon.event { background: rgba(64,200,208,0.15); }
        .alert-body { flex: 1; min-width: 0; }
        .alert-body .who {
            font-weight: 500;
            color: var(--text);
            font-size: 12px;
        }
        .alert-body .what {
            color: var(--text-dim);
            font-size: 12px;
        }
        .alert-body .context {
            color: var(--text-muted);
            font-size: 11px;
            margin-top: 2px;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }
        .alert-time {
            font-size: 10px;
            color: var(--text-muted);
            white-space: nowrap;
            flex-shrink: 0;
            padding-top: 2px;
        }

        .load-more {
            display: block;
            margin: 16px auto;
            background: var(--surface);
            border: 1px solid var(--border);
            color: var(--text-dim);
            font-family: var(--mono);
            font-size: 11px;
            padding: 8px 24px;
            border-radius: 4px;
            cursor: pointer;
        }
        .load-more:hover { border-color: var(--amber-dim); color: var(--amber); }

        .section-divider {
            font-size: 10px;
            color: var(--text-muted);
            text-transform: uppercase;
            letter-spacing: 0.1em;
            padding: 10px 12px 4px;
            border-bottom: 1px solid var(--border);
        }

        .backlink { text-align: center; padding: 12px; font-size: 11px; }

        .toast {
            position: fixed;
            bottom: 60px;
            left: 50%;
            transform: translateX(-50%) translateY(20px);
            background: var(--surface);
            border: 1px solid var(--amber-dim);
            color: var(--text);
            font-family: var(--mono);
            font-size: 11px;
            padding: 8px 18px;
            border-radius: 6px;
            z-index: 200;
            opacity: 0;
            transition: all 0.3s;
            pointer-events: none;
        }
        .toast.visible { opacity: 1; transform: translateX(-50%) translateY(0); }

        @media (max-width: 600px) {
            .app-header h1 { font-size: 1.6rem; }
            .toolbar { gap: 4px; }
            .filter-btn { font-size: 9px; padding: 3px 7px; }
            .grid { padding: 4px 2px 80px; }
        }
    </style>
<script>
(function(){var Q=[],N=0,MAX=10;function send(e){var sb=window.supabase;if(!sb){Q.push(e);return;}if(N>=MAX)return;N++;sb.auth.getSession().then(function(r){var u=r&&r.data&&r.data.session&&r.data.session.user;if(!u)return;sb.from('ai_events').insert({event_type:'client_error',entity_type:'app',entity_id:u.id,username:location.pathname.split('/').filter(Boolean)[0]||'unknown',metadata:e,user_id:u.id}).then(function(){});}).catch(function(){});}window.onerror=function(m,s,l,c,e){send({type:'error',msg:String(m).slice(0,500),src:s||'',line:l,col:c,stack:e?String(e.stack).slice(0,1000):''});};window.addEventListener('unhandledrejection',function(ev){var r=ev.reason;send({type:'promise',msg:String(r&&r.message||r).slice(0,500),stack:r?String(r.stack||'').slice(0,1000):''});});var fi=setInterval(function(){if(window.supabase){Q.splice(0).forEach(send);clearInterval(fi);}},1000);setTimeout(function(){clearInterval(fi);},30000);})();
</script>
</head>
<body>
    <div class="app-header">
        <h1>Sloppy <em>Alerts</em></h1>
        <div class="subtitle">Universal Grid Notifications</div>
        <div class="counters">
            <div class="ct"><strong id="cUnread">0</strong> unread</div>
            <div class="ct"><strong id="cTotal">0</strong> total</div>
            <div class="ct"><strong id="cOnline">1</strong> online</div>
        </div>
    </div>

    <div class="toolbar">
        <button class="filter-btn active" data-filter="all" onclick="setFilter('all')">All</button>
        <button class="filter-btn" data-filter="mention" onclick="setFilter('mention')">@Mentions <span class="badge" id="bMention" style="display:none">0</span></button>
        <button class="filter-btn" data-filter="vote" onclick="setFilter('vote')">Votes</button>
        <button class="filter-btn" data-filter="follow" onclick="setFilter('follow')">Follows</button>
        <button class="filter-btn" data-filter="comment" onclick="setFilter('comment')">Comments</button>
        <button class="filter-btn" data-filter="reaction" onclick="setFilter('reaction')">Reactions</button>
        <button class="filter-btn" data-filter="battle" onclick="setFilter('battle')">Battles</button>
        <button class="filter-btn" data-filter="event" onclick="setFilter('event')">Events</button>
        <div class="toolbar-right">
            <button class="mark-read-btn" onclick="markAllRead()">Mark all read</button>
        </div>
    </div>

    <div class="grid" id="grid">
        <div class="grid-loading" id="gridLoading">Loading alerts...</div>
    </div>

    <div class="toast" id="toast"></div>
    <div class="backlink"><a href="https://sloppy.live">‚Üê sloppy.live</a></div>

    <script src="/apps/sloppy-header/sloppy-bar.js" data-position="bottom" data-minimized="true"></script>
    <script type="module">
        import { createBrowserClient } from "https://cdn.jsdelivr.net/npm/@supabase/ssr@0.7.0/+esm";

        const supabase = createBrowserClient(
            'https://yjyxteqzhhmtrgcaekgz.supabase.co',
            'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InlqeXh0ZXF6aGhtdHJnY2Fla2d6Iiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTczNTg3NDIsImV4cCI6MjA3MjkzNDc0Mn0.G8SRde7IN2QFW1EnASM8IS32IUYR2eenCCjdDdioiBU',
            { cookieOptions: { name: 'sb-auth-token', domain: location.hostname.includes('sloppy.live') ? '.sloppy.live' : location.hostname, path: '/', sameSite: 'lax' } }
        );

        const PAGE_SIZE = 20;
        const ICONS = {
            mention: 'üì£', vote: 'üó≥Ô∏è', follow: 'üë§', comment: 'üí¨',
            reaction: 'üòÑ', battle: '‚öîÔ∏è', event: 'üì°',
            post_created: 'üìù', faction_join: 'üè¥', collab_snapshot: 'üé®',
            vote_cast: 'üó≥Ô∏è', comment_posted: 'üí¨', reaction_added: 'üòÑ',
            follow_event: 'üë§', faction_battle: '‚öîÔ∏è'
        };

        let currentUser = null;
        let profile = { username: 'Anonymous', avatar: 'üë§' };
        let alerts = [];
        let activeFilter = 'all';
        let mentionsSeen = new Set();
        let hasMore = true;
        let loading = false;
        let page = 0;

        // --- Auth ---
        async function initAuth() {
            const { data: { session } } = await supabase.auth.getSession();
            let s = session;
            if (!s) {
                const { data } = await supabase.auth.signInAnonymously();
                s = data?.session;
            }
            if (s?.user) {
                currentUser = s.user;
                const { data: prof } = await supabase.from('sloppygram_profiles')
                    .select('username, avatar').eq('user_id', currentUser.id).single();
                if (prof) {
                    profile.username = prof.username || 'Anonymous';
                    profile.avatar = prof.avatar || 'üë§';
                }
            }
        }

        function escapeHtml(s) {
            if (!s) return '';
            return s.replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;').replace(/"/g,'&quot;');
        }
        function timeAgo(d) {
            const s = Math.floor((Date.now() - new Date(d).getTime()) / 1000);
            if (s < 60) return 'now';
            if (s < 3600) return Math.floor(s/60) + 'm';
            if (s < 86400) return Math.floor(s/3600) + 'h';
            if (s < 604800) return Math.floor(s/86400) + 'd';
            return new Date(d).toLocaleDateString();
        }
        function showToast(msg) {
            const t = document.getElementById('toast');
            t.textContent = msg; t.classList.add('visible');
            setTimeout(() => t.classList.remove('visible'), 2200);
        }
        function truncate(s, n) { return s && s.length > n ? s.slice(0, n) + '‚Ä¶' : (s || ''); }

        // --- Load from multiple sources ---
        async function loadAlerts() {
            if (!currentUser) { document.getElementById('gridLoading').textContent = 'Sign in to see alerts.'; return; }
            loading = true;
            page = 0;
            alerts = [];

            const results = await Promise.all([
                // 1. Mentions for current user
                supabase.from('sloppygram_mentions')
                    .select('*')
                    .eq('mentioned_username', profile.username)
                    .order('created_at', { ascending: false })
                    .limit(50),
                // 2. AI events (global activity stream)
                supabase.from('ai_events')
                    .select('*')
                    .order('created_at', { ascending: false })
                    .limit(80),
                // 3. Recent follows TO current user
                supabase.from('sloppygram_follows')
                    .select('follower_username, created_at')
                    .eq('followed_username', profile.username)
                    .order('created_at', { ascending: false })
                    .limit(30),
                // 4. Votes on my posts
                supabase.from('sloppygram_post_likes')
                    .select('post_id, username, vote_type, created_at')
                    .neq('username', profile.username)
                    .order('created_at', { ascending: false })
                    .limit(40),
                // 5. Comments on my posts
                supabase.from('sloppygram_post_comments')
                    .select('id, post_id, username, content, created_at')
                    .neq('username', profile.username)
                    .order('created_at', { ascending: false })
                    .limit(40),
                // 6. Reactions on my posts
                supabase.from('sloppygram_post_reactions')
                    .select('post_id, emoji, username, created_at')
                    .neq('username', profile.username)
                    .order('created_at', { ascending: false })
                    .limit(40),
                // 7. Faction battles (global)
                supabase.from('sloppygram_faction_battles')
                    .select('*')
                    .order('created_at', { ascending: false })
                    .limit(30)
            ]);

            const [mentionsR, eventsR, followsR, votesR, commentsR, reactionsR, battlesR] = results;

            // Process mentions
            (mentionsR.data || []).forEach(m => {
                const isUnread = !m.seen;
                alerts.push({
                    type: 'mention',
                    who: m.source_username,
                    what: `mentioned you in a ${m.source_type}`,
                    context: `Source: ${m.source_type} #${m.source_id || '?'}`,
                    time: m.created_at,
                    unread: isUnread,
                    id: 'mention-' + m.created_at
                });
                if (!isUnread) mentionsSeen.add(m.created_at);
            });

            // Process AI events (excluding own events)
            (eventsR.data || []).forEach(e => {
                if (e.username === profile.username) return; // skip own
                const meta = e.metadata || {};
                let what = e.event_type.replace(/_/g, ' ');
                let context = '';
                if (e.event_type === 'follow' && meta.followed_username) {
                    what = `followed ${meta.followed_username}`;
                } else if (e.event_type === 'post_created') {
                    what = 'published a new post';
                    context = meta.has_caption ? `with caption` : 'image post';
                } else if (e.event_type === 'faction_battle') {
                    what = `battle at ${e.entity_id || 'territory'}`;
                    context = meta.attacker ? `${meta.attacker} vs ${meta.defender || '?'}` : '';
                } else if (e.event_type === 'faction_join') {
                    what = 'joined a faction';
                    context = meta.faction_name || '';
                } else if (e.event_type === 'vote_cast') {
                    what = `voted on ${e.entity_type}`;
                    context = meta.net_score !== undefined ? `score: ${meta.net_score}` : '';
                } else if (e.event_type === 'collab_snapshot') {
                    what = 'saved a canvas snapshot';
                }
                alerts.push({
                    type: 'event',
                    subtype: e.event_type,
                    who: e.username || 'someone',
                    what,
                    context,
                    time: e.created_at,
                    unread: false,
                    id: 'event-' + e.created_at + e.event_type
                });
            });

            // Process follows
            (followsR.data || []).forEach(f => {
                alerts.push({
                    type: 'follow',
                    who: f.follower_username,
                    what: 'followed you',
                    context: '',
                    time: f.created_at,
                    unread: false,
                    id: 'follow-' + f.follower_username + f.created_at
                });
            });

            // Process votes on posts (we need to filter for own posts ‚Äî approximate by showing all)
            (votesR.data || []).forEach(v => {
                alerts.push({
                    type: 'vote',
                    who: v.username,
                    what: `${v.vote_type > 0 ? 'upvoted' : 'downvoted'} a post`,
                    context: `Post #${v.post_id}`,
                    time: v.created_at,
                    unread: false,
                    id: 'vote-' + v.post_id + v.username + v.created_at
                });
            });

            // Process comments
            (commentsR.data || []).forEach(c => {
                alerts.push({
                    type: 'comment',
                    who: c.username,
                    what: 'commented on a post',
                    context: truncate(c.content, 60),
                    time: c.created_at,
                    unread: false,
                    id: 'comment-' + c.id
                });
            });

            // Process reactions
            (reactionsR.data || []).forEach(r => {
                alerts.push({
                    type: 'reaction',
                    who: r.username,
                    what: `reacted ${r.emoji} on a post`,
                    context: `Post #${r.post_id}`,
                    time: r.created_at,
                    unread: false,
                    id: 'reaction-' + r.post_id + r.emoji + r.username
                });
            });

            // Process battles
            (battlesR.data || []).forEach(b => {
                alerts.push({
                    type: 'battle',
                    who: b.attacker_username || 'someone',
                    what: b.result === 'victory' ? 'won a territory battle' : 'lost a territory battle',
                    context: b.territory_name ? `at ${b.territory_name}` : '',
                    time: b.created_at,
                    unread: false,
                    id: 'battle-' + b.created_at + (b.attacker_username || '')
                });
            });

            // Sort by time descending
            alerts.sort((a, b) => new Date(b.time) - new Date(a.time));

            // Deduplicate by id
            const seen = new Set();
            alerts = alerts.filter(a => { if (seen.has(a.id)) return false; seen.add(a.id); return true; });

            loading = false;
            updateCounters();
            renderGrid();
        }

        async function loadMore() {
            // For now, initial load fetches enough. Future: paginate each source.
            showToast('All alerts loaded');
        }

        function updateCounters() {
            const unread = alerts.filter(a => a.unread).length;
            document.getElementById('cUnread').textContent = unread;
            document.getElementById('cTotal').textContent = alerts.length;

            // Mention badge
            const mentionUnread = alerts.filter(a => a.type === 'mention' && a.unread).length;
            const bMention = document.getElementById('bMention');
            if (mentionUnread > 0) {
                bMention.textContent = mentionUnread;
                bMention.style.display = '';
            } else {
                bMention.style.display = 'none';
            }
        }

        // --- Filter ---
        window.setFilter = function(f) {
            activeFilter = f;
            document.querySelectorAll('.filter-btn').forEach(el => el.classList.toggle('active', el.dataset.filter === f));
            renderGrid();
        };

        // --- Mark all read ---
        window.markAllRead = async function() {
            if (!currentUser) return;
            // Mark mentions as seen
            await supabase.from('sloppygram_mentions')
                .update({ seen: true })
                .eq('mentioned_username', profile.username)
                .eq('seen', false);
            alerts.forEach(a => a.unread = false);
            updateCounters();
            renderGrid();
            showToast('All marked as read');
        };

        // --- Render ---
        function renderGrid() {
            const container = document.getElementById('grid');
            document.getElementById('gridLoading').style.display = 'none';

            let filtered = alerts;
            if (activeFilter !== 'all') {
                if (activeFilter === 'event') {
                    filtered = alerts.filter(a => a.type === 'event');
                } else {
                    filtered = alerts.filter(a => a.type === activeFilter);
                }
            }

            if (filtered.length === 0) {
                container.innerHTML = '<div class="grid-empty"><div class="icon">üîï</div>No alerts here yet.</div>';
                return;
            }

            // Group by day
            const groups = {};
            filtered.forEach(a => {
                const d = new Date(a.time);
                const today = new Date();
                const yesterday = new Date(today); yesterday.setDate(yesterday.getDate() - 1);
                let label;
                if (d.toDateString() === today.toDateString()) label = 'Today';
                else if (d.toDateString() === yesterday.toDateString()) label = 'Yesterday';
                else label = d.toLocaleDateString('en-US', { month: 'short', day: 'numeric' });
                if (!groups[label]) groups[label] = [];
                groups[label].push(a);
            });

            let html = '';
            for (const [label, items] of Object.entries(groups)) {
                html += `<div class="section-divider">${escapeHtml(label)}</div>`;
                html += items.map(a => renderAlertCard(a)).join('');
            }

            container.innerHTML = html;
        }

        function renderAlertCard(a) {
            const iconType = a.type === 'event' ? (a.subtype || 'event') : a.type;
            const icon = ICONS[iconType] || ICONS[a.type] || 'üì°';
            return `<div class="alert-card${a.unread ? ' unread' : ''}">
                <div class="alert-icon ${a.type}">${icon}</div>
                <div class="alert-body">
                    <span class="who">${escapeHtml(a.who)}</span>
                    <span class="what"> ${escapeHtml(a.what)}</span>
                    ${a.context ? `<div class="context">${escapeHtml(a.context)}</div>` : ''}
                </div>
                <div class="alert-time">${timeAgo(a.time)}</div>
            </div>`;
        }

        // --- Real-time ---
        function subscribeRealtime() {
            const channel = supabase.channel('sloppy-alerts-rt');

            // New mentions
            channel.on('postgres_changes', { event: 'INSERT', schema: 'public', table: 'sloppygram_mentions' }, payload => {
                const m = payload.new;
                if (m.mentioned_username !== profile.username) return;
                const alert = {
                    type: 'mention', who: m.source_username,
                    what: `mentioned you in a ${m.source_type}`,
                    context: `Source: ${m.source_type} #${m.source_id || '?'}`,
                    time: m.created_at, unread: !m.seen,
                    id: 'mention-' + m.created_at
                };
                if (!alerts.find(a => a.id === alert.id)) {
                    alerts.unshift(alert);
                    updateCounters();
                    renderGrid();
                }
            });

            // New AI events
            channel.on('postgres_changes', { event: 'INSERT', schema: 'public', table: 'ai_events' }, payload => {
                const e = payload.new;
                if (e.username === profile.username) return;
                const alert = {
                    type: 'event', subtype: e.event_type,
                    who: e.username || 'someone',
                    what: e.event_type.replace(/_/g, ' '),
                    context: '', time: e.created_at, unread: false,
                    id: 'event-' + e.created_at + e.event_type
                };
                if (!alerts.find(a => a.id === alert.id)) {
                    alerts.unshift(alert);
                    updateCounters();
                    renderGrid();
                }
            });

            // New follows
            channel.on('postgres_changes', { event: 'INSERT', schema: 'public', table: 'sloppygram_follows' }, payload => {
                const f = payload.new;
                if (f.followed_username !== profile.username) return;
                const alert = {
                    type: 'follow', who: f.follower_username,
                    what: 'followed you', context: '',
                    time: f.created_at, unread: false,
                    id: 'follow-' + f.follower_username + f.created_at
                };
                if (!alerts.find(a => a.id === alert.id)) {
                    alerts.unshift(alert);
                    updateCounters();
                    renderGrid();
                }
            });

            // New comments
            channel.on('postgres_changes', { event: 'INSERT', schema: 'public', table: 'sloppygram_post_comments' }, payload => {
                const c = payload.new;
                if (c.username === profile.username) return;
                const alert = {
                    type: 'comment', who: c.username,
                    what: 'commented on a post',
                    context: truncate(c.content, 60),
                    time: c.created_at, unread: false,
                    id: 'comment-' + c.id
                };
                if (!alerts.find(a => a.id === alert.id)) {
                    alerts.unshift(alert);
                    updateCounters();
                    renderGrid();
                }
            });

            // New battles
            channel.on('postgres_changes', { event: 'INSERT', schema: 'public', table: 'sloppygram_faction_battles' }, payload => {
                const b = payload.new;
                const alert = {
                    type: 'battle', who: b.attacker_username || 'someone',
                    what: b.result === 'victory' ? 'won a territory battle' : 'lost a territory battle',
                    context: b.territory_name ? `at ${b.territory_name}` : '',
                    time: b.created_at, unread: false,
                    id: 'battle-' + b.created_at + (b.attacker_username || '')
                };
                if (!alerts.find(a => a.id === alert.id)) {
                    alerts.unshift(alert);
                    updateCounters();
                    renderGrid();
                }
            });

            // Presence
            channel.on('presence', { event: 'sync' }, () => {
                const count = Object.keys(channel.presenceState()).length;
                document.getElementById('cOnline').textContent = Math.max(1, count);
            });

            channel.subscribe(async (status) => {
                if (status === 'SUBSCRIBED') {
                    await channel.track({ user: profile.username });
                }
            });
        }

        // --- Init ---
        async function init() {
            await initAuth();
            await loadAlerts();
            subscribeRealtime();
        }

        init().catch(err => {
            console.error('Init error:', err);
            document.getElementById('gridLoading').textContent = 'Failed to load. Refresh to try again.';
        });
    </script>
<script src="/vibelib-extended.js"></script>
<script>
  // Compatibility Patch for Legacy Apps
  window.addEventListener("load", () => {
    if (window.SloppyKarma && window.VibeLib.Economy) {
      // Redirect old calls to new engine
      window.SloppyKarma.track = window.VibeLib.Economy.track;
    }
  });
</script>
</body>
</html>