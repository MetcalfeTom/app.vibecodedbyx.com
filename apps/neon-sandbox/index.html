<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
  <title>Neon Sandbox</title>
  <link rel="icon" href="https://emojicdn.elk.sh/üîÆ">
  <meta property="og:title" content="Neon Sandbox">
  <meta property="og:description" content="Drop glowing shapes and watch them bounce around!">
  <meta property="og:url" content="https://sloppy.live/neon-sandbox">
  <meta property="og:image" content="https://sloppy.live/neon-sandbox/og-image.png">
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&display=swap" rel="stylesheet">
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
      touch-action: none;
    }

    body {
      background: #0a0a12;
      font-family: 'Orbitron', sans-serif;
      min-height: 100vh;
      overflow: hidden;
      display: flex;
      flex-direction: column;
    }

    #toolbar {
      display: flex;
      justify-content: center;
      gap: 10px;
      padding: 12px;
      background: linear-gradient(180deg, #1a1a2e 0%, #0f0f1a 100%);
      border-bottom: 2px solid #ff00ff44;
      flex-wrap: wrap;
      z-index: 10;
    }

    .tool-btn {
      padding: 10px 16px;
      background: #1a1a2e;
      border: 2px solid #444;
      border-radius: 8px;
      color: #888;
      font-family: 'Orbitron', sans-serif;
      font-size: 12px;
      cursor: pointer;
      transition: all 0.2s;
      display: flex;
      align-items: center;
      gap: 6px;
    }

    .tool-btn:hover {
      border-color: #888;
      color: #fff;
    }

    .tool-btn.active {
      border-color: var(--glow-color, #ff00ff);
      color: #fff;
      box-shadow: 0 0 15px var(--glow-color, #ff00ff)44;
      background: #2a2a4e;
    }

    .tool-btn .icon {
      font-size: 16px;
    }

    #canvas-container {
      flex: 1;
      position: relative;
      overflow: hidden;
    }

    #sandbox {
      display: block;
      width: 100%;
      height: 100%;
      cursor: crosshair;
    }

    #controls {
      position: fixed;
      bottom: 15px;
      left: 50%;
      transform: translateX(-50%);
      display: flex;
      gap: 10px;
      z-index: 10;
    }

    .control-btn {
      padding: 10px 20px;
      background: #1a1a2e;
      border: 2px solid #00ffff;
      border-radius: 8px;
      color: #00ffff;
      font-family: 'Orbitron', sans-serif;
      font-size: 11px;
      cursor: pointer;
      transition: all 0.2s;
    }

    .control-btn:hover {
      background: #00ffff22;
      box-shadow: 0 0 20px #00ffff44;
    }

    #backlink {
      position: fixed;
      bottom: 15px;
      right: 15px;
      z-index: 10;
    }

    #backlink a {
      color: #666;
      text-decoration: none;
      font-size: 11px;
      transition: color 0.2s;
    }

    #backlink a:hover {
      color: #ff00ff;
    }

    #shape-count {
      position: fixed;
      top: 70px;
      right: 15px;
      color: #666;
      font-size: 11px;
      z-index: 10;
    }

    #instructions {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      color: #444;
      font-size: 14px;
      text-align: center;
      pointer-events: none;
      transition: opacity 0.5s;
      z-index: 5;
    }

    #instructions.hidden {
      opacity: 0;
    }

    @media (max-width: 600px) {
      .tool-btn {
        padding: 8px 12px;
        font-size: 10px;
      }

      .tool-btn .label {
        display: none;
      }

      .tool-btn .icon {
        font-size: 18px;
      }
    }
  </style>
</head>
<body>
  <div id="toolbar">
    <button class="tool-btn active" data-shape="circle" style="--glow-color: #ff00ff">
      <span class="icon">‚óè</span>
      <span class="label">Ball</span>
    </button>
    <button class="tool-btn" data-shape="square" style="--glow-color: #00ffff">
      <span class="icon">‚ñ†</span>
      <span class="label">Square</span>
    </button>
    <button class="tool-btn" data-shape="triangle" style="--glow-color: #ffff00">
      <span class="icon">‚ñ≤</span>
      <span class="label">Triangle</span>
    </button>
    <button class="tool-btn" data-shape="star" style="--glow-color: #ff6600">
      <span class="icon">‚òÖ</span>
      <span class="label">Star</span>
    </button>
    <button class="tool-btn" data-shape="hexagon" style="--glow-color: #00ff88">
      <span class="icon">‚¨°</span>
      <span class="label">Hexagon</span>
    </button>
    <button class="tool-btn" data-shape="pig" style="--glow-color: #ff66aa">
      <span class="icon">üê∑</span>
      <span class="label">Pig</span>
    </button>
    <button class="tool-btn" data-shape="grab" style="--glow-color: #ff3366">
      <span class="icon">ü¶æ</span>
      <span class="label">Robot Arm</span>
    </button>
  </div>

  <div id="canvas-container">
    <canvas id="sandbox"></canvas>
  </div>

  <div id="controls">
    <button class="control-btn" onclick="clearAll()">CLEAR</button>
    <button class="control-btn" onclick="toggleGravity()">GRAVITY: ON</button>
    <button class="control-btn" onclick="shake()">SHAKE</button>
  </div>

  <div id="shape-count">Shapes: 0</div>
  <div id="instructions">Click or tap to spawn shapes</div>

  <div id="backlink">
    <a href="https://sloppy.live">‚Üê sloppy.live</a>
  </div>

  <script>
    const canvas = document.getElementById('sandbox');
    const ctx = canvas.getContext('2d');
    const container = document.getElementById('canvas-container');

    let shapes = [];
    let selectedShape = 'circle';
    let gravityEnabled = true;
    let hasInteracted = false;

    // Robot arm state
    const robotArm = {
      baseX: 0,
      baseY: 0,
      targetX: 0,
      targetY: 0,
      segments: [
        { length: 80, angle: -Math.PI / 2 },
        { length: 60, angle: 0 },
        { length: 40, angle: 0 }
      ],
      grabbedShape: null,
      clawOpen: true,
      prevX: 0,
      prevY: 0,
      velocityX: 0,
      velocityY: 0
    };

    const GRAVITY = 0.5;
    const FRICTION = 0.99;
    const BOUNCE = 0.7;
    const MAX_SHAPES = 200;

    const COLORS = [
      '#ff00ff', '#00ffff', '#ffff00', '#ff6600', '#00ff88',
      '#ff0066', '#6600ff', '#00ff00', '#ff3366', '#33ffcc'
    ];

    function resize() {
      canvas.width = container.clientWidth;
      canvas.height = container.clientHeight;
    }

    resize();
    window.addEventListener('resize', resize);

    // Tool buttons
    document.querySelectorAll('.tool-btn').forEach(btn => {
      btn.addEventListener('click', () => {
        document.querySelectorAll('.tool-btn').forEach(b => b.classList.remove('active'));
        btn.classList.add('active');
        selectedShape = btn.dataset.shape;
      });
    });

    class Shape {
      constructor(x, y, type) {
        this.x = x;
        this.y = y;
        this.vx = (Math.random() - 0.5) * 8;
        this.vy = (Math.random() - 0.5) * 4;
        this.type = type;
        this.size = type === 'pig' ? 30 + Math.random() * 20 : 20 + Math.random() * 25;
        this.rotation = type === 'pig' ? 0 : Math.random() * Math.PI * 2;
        this.rotationSpeed = type === 'pig' ? (Math.random() - 0.5) * 0.05 : (Math.random() - 0.5) * 0.15;
        this.color = type === 'pig' ? '#ff66aa' : COLORS[Math.floor(Math.random() * COLORS.length)];
        this.mass = this.size * this.size * 0.01;
      }

      update() {
        if (gravityEnabled) {
          this.vy += GRAVITY;
        }

        this.vx *= FRICTION;
        this.vy *= FRICTION;

        this.x += this.vx;
        this.y += this.vy;
        this.rotation += this.rotationSpeed;

        // Bounce off walls
        if (this.x - this.size < 0) {
          this.x = this.size;
          this.vx *= -BOUNCE;
          this.rotationSpeed *= -0.8;
        }
        if (this.x + this.size > canvas.width) {
          this.x = canvas.width - this.size;
          this.vx *= -BOUNCE;
          this.rotationSpeed *= -0.8;
        }
        if (this.y - this.size < 0) {
          this.y = this.size;
          this.vy *= -BOUNCE;
        }
        if (this.y + this.size > canvas.height) {
          this.y = canvas.height - this.size;
          this.vy *= -BOUNCE;
          this.rotationSpeed *= 0.95;

          // Extra friction on ground
          this.vx *= 0.98;
        }
      }

      draw() {
        ctx.save();
        ctx.translate(this.x, this.y);
        ctx.rotate(this.rotation);

        ctx.fillStyle = this.color;
        ctx.shadowColor = this.color;
        ctx.shadowBlur = 20;

        switch (this.type) {
          case 'circle':
            ctx.beginPath();
            ctx.arc(0, 0, this.size, 0, Math.PI * 2);
            ctx.fill();
            // Inner glow
            ctx.fillStyle = '#ffffff44';
            ctx.beginPath();
            ctx.arc(-this.size * 0.3, -this.size * 0.3, this.size * 0.3, 0, Math.PI * 2);
            ctx.fill();
            break;

          case 'square':
            ctx.fillRect(-this.size, -this.size, this.size * 2, this.size * 2);
            // Inner highlight
            ctx.fillStyle = '#ffffff22';
            ctx.fillRect(-this.size * 0.6, -this.size * 0.6, this.size * 0.8, this.size * 0.8);
            break;

          case 'triangle':
            ctx.beginPath();
            ctx.moveTo(0, -this.size);
            ctx.lineTo(-this.size, this.size);
            ctx.lineTo(this.size, this.size);
            ctx.closePath();
            ctx.fill();
            break;

          case 'star':
            this.drawStar(5, this.size, this.size * 0.5);
            break;

          case 'hexagon':
            this.drawPolygon(6, this.size);
            break;

          case 'pig':
            // Pink body
            ctx.fillStyle = '#ff66aa';
            ctx.shadowColor = '#ff66aa';
            ctx.beginPath();
            ctx.ellipse(0, 0, this.size, this.size * 0.8, 0, 0, Math.PI * 2);
            ctx.fill();

            // Snout
            ctx.fillStyle = '#ffaacc';
            ctx.beginPath();
            ctx.ellipse(this.size * 0.6, 0, this.size * 0.4, this.size * 0.35, 0, 0, Math.PI * 2);
            ctx.fill();

            // Nostrils
            ctx.fillStyle = '#cc4488';
            ctx.beginPath();
            ctx.ellipse(this.size * 0.55, -this.size * 0.08, this.size * 0.08, this.size * 0.1, 0, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.ellipse(this.size * 0.55, this.size * 0.08, this.size * 0.08, this.size * 0.1, 0, 0, Math.PI * 2);
            ctx.fill();

            // Eyes
            ctx.fillStyle = '#000';
            ctx.beginPath();
            ctx.arc(-this.size * 0.1, -this.size * 0.25, this.size * 0.12, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.arc(this.size * 0.2, -this.size * 0.25, this.size * 0.12, 0, Math.PI * 2);
            ctx.fill();

            // Eye shine
            ctx.fillStyle = '#fff';
            ctx.beginPath();
            ctx.arc(-this.size * 0.05, -this.size * 0.3, this.size * 0.05, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.arc(this.size * 0.25, -this.size * 0.3, this.size * 0.05, 0, Math.PI * 2);
            ctx.fill();

            // Ears
            ctx.fillStyle = '#ff66aa';
            ctx.beginPath();
            ctx.ellipse(-this.size * 0.5, -this.size * 0.6, this.size * 0.25, this.size * 0.35, -0.4, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.ellipse(this.size * 0.1, -this.size * 0.65, this.size * 0.25, this.size * 0.35, 0.4, 0, Math.PI * 2);
            ctx.fill();

            // Inner ears
            ctx.fillStyle = '#ffaacc';
            ctx.beginPath();
            ctx.ellipse(-this.size * 0.5, -this.size * 0.6, this.size * 0.12, this.size * 0.2, -0.4, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.ellipse(this.size * 0.1, -this.size * 0.65, this.size * 0.12, this.size * 0.2, 0.4, 0, Math.PI * 2);
            ctx.fill();
            break;
        }

        ctx.restore();
      }

      drawStar(points, outerRadius, innerRadius) {
        ctx.beginPath();
        for (let i = 0; i < points * 2; i++) {
          const radius = i % 2 === 0 ? outerRadius : innerRadius;
          const angle = (i * Math.PI) / points - Math.PI / 2;
          const x = Math.cos(angle) * radius;
          const y = Math.sin(angle) * radius;
          if (i === 0) {
            ctx.moveTo(x, y);
          } else {
            ctx.lineTo(x, y);
          }
        }
        ctx.closePath();
        ctx.fill();
      }

      drawPolygon(sides, radius) {
        ctx.beginPath();
        for (let i = 0; i < sides; i++) {
          const angle = (i * 2 * Math.PI) / sides - Math.PI / 2;
          const x = Math.cos(angle) * radius;
          const y = Math.sin(angle) * radius;
          if (i === 0) {
            ctx.moveTo(x, y);
          } else {
            ctx.lineTo(x, y);
          }
        }
        ctx.closePath();
        ctx.fill();
      }

      checkCollision(other) {
        const dx = other.x - this.x;
        const dy = other.y - this.y;
        const dist = Math.sqrt(dx * dx + dy * dy);
        const minDist = this.size + other.size;

        if (dist < minDist && dist > 0) {
          // Collision response
          const nx = dx / dist;
          const ny = dy / dist;

          // Relative velocity
          const dvx = this.vx - other.vx;
          const dvy = this.vy - other.vy;
          const dvn = dvx * nx + dvy * ny;

          // Only resolve if moving towards each other
          if (dvn > 0) {
            const totalMass = this.mass + other.mass;
            const impulse = (2 * dvn) / totalMass;

            this.vx -= impulse * other.mass * nx * BOUNCE;
            this.vy -= impulse * other.mass * ny * BOUNCE;
            other.vx += impulse * this.mass * nx * BOUNCE;
            other.vy += impulse * this.mass * ny * BOUNCE;

            // Separate overlapping shapes
            const overlap = minDist - dist;
            const sepX = (overlap / 2) * nx;
            const sepY = (overlap / 2) * ny;
            this.x -= sepX;
            this.y -= sepY;
            other.x += sepX;
            other.y += sepY;
          }
        }
      }
    }

    function spawnShape(x, y) {
      if (!hasInteracted) {
        hasInteracted = true;
        document.getElementById('instructions').classList.add('hidden');
      }

      if (shapes.length >= MAX_SHAPES) {
        shapes.shift(); // Remove oldest
      }

      shapes.push(new Shape(x, y, selectedShape));
      updateShapeCount();
    }

    function updateShapeCount() {
      document.getElementById('shape-count').textContent = `Shapes: ${shapes.length}`;
    }

    function clearAll() {
      shapes = [];
      updateShapeCount();
    }

    function toggleGravity() {
      gravityEnabled = !gravityEnabled;
      document.querySelector('[onclick="toggleGravity()"]').textContent =
        `GRAVITY: ${gravityEnabled ? 'ON' : 'OFF'}`;
    }

    function shake() {
      shapes.forEach(shape => {
        shape.vx += (Math.random() - 0.5) * 30;
        shape.vy += (Math.random() - 0.5) * 30;
      });
    }

    // Robot arm functions
    function updateRobotArm() {
      // Set base position at bottom center
      robotArm.baseX = canvas.width / 2;
      robotArm.baseY = canvas.height;

      // Calculate velocity for throwing
      const endPos = getRobotArmEndPos();
      robotArm.velocityX = (endPos.x - robotArm.prevX) * 0.8;
      robotArm.velocityY = (endPos.y - robotArm.prevY) * 0.8;
      robotArm.prevX = endPos.x;
      robotArm.prevY = endPos.y;

      // Update grabbed shape position
      if (robotArm.grabbedShape) {
        robotArm.grabbedShape.x = endPos.x;
        robotArm.grabbedShape.y = endPos.y;
        robotArm.grabbedShape.vx = 0;
        robotArm.grabbedShape.vy = 0;
      }

      // Inverse kinematics to reach target
      solveIK();
    }

    function solveIK() {
      const dx = robotArm.targetX - robotArm.baseX;
      const dy = robotArm.targetY - robotArm.baseY;
      const targetAngle = Math.atan2(dy, dx);
      const targetDist = Math.min(
        Math.sqrt(dx * dx + dy * dy),
        robotArm.segments.reduce((sum, s) => sum + s.length, 0) - 10
      );

      // Simple FABRIK-like solve
      let currentAngle = targetAngle;
      let remainingDist = targetDist;

      robotArm.segments.forEach((seg, i) => {
        if (i === 0) {
          seg.angle = currentAngle;
        } else {
          // Bend towards target
          const bendAmount = Math.sin(remainingDist / 100) * 0.3;
          seg.angle = bendAmount;
        }
        remainingDist -= seg.length * 0.7;
      });
    }

    function getRobotArmEndPos() {
      let x = robotArm.baseX;
      let y = robotArm.baseY;
      let angle = 0;

      robotArm.segments.forEach(seg => {
        angle += seg.angle;
        x += Math.cos(angle) * seg.length;
        y += Math.sin(angle) * seg.length;
      });

      return { x, y };
    }

    function drawRobotArm() {
      let x = robotArm.baseX;
      let y = robotArm.baseY;
      let angle = 0;

      // Draw base
      ctx.fillStyle = '#444466';
      ctx.shadowColor = '#ff3366';
      ctx.shadowBlur = 15;
      ctx.beginPath();
      ctx.arc(x, y, 25, Math.PI, 0);
      ctx.fill();

      // Draw segments
      robotArm.segments.forEach((seg, i) => {
        angle += seg.angle;
        const nextX = x + Math.cos(angle) * seg.length;
        const nextY = y + Math.sin(angle) * seg.length;

        // Arm segment
        ctx.strokeStyle = '#ff3366';
        ctx.lineWidth = 12 - i * 3;
        ctx.lineCap = 'round';
        ctx.beginPath();
        ctx.moveTo(x, y);
        ctx.lineTo(nextX, nextY);
        ctx.stroke();

        // Joint
        ctx.fillStyle = '#ff6688';
        ctx.beginPath();
        ctx.arc(x, y, 8 - i * 2, 0, Math.PI * 2);
        ctx.fill();

        x = nextX;
        y = nextY;
      });

      // Draw claw
      const clawAngle = angle;
      const clawOpen = robotArm.clawOpen ? 0.5 : 0.1;

      ctx.strokeStyle = '#ff3366';
      ctx.lineWidth = 4;

      // Left claw
      ctx.beginPath();
      ctx.moveTo(x, y);
      ctx.lineTo(
        x + Math.cos(clawAngle - clawOpen) * 25,
        y + Math.sin(clawAngle - clawOpen) * 25
      );
      ctx.stroke();

      // Right claw
      ctx.beginPath();
      ctx.moveTo(x, y);
      ctx.lineTo(
        x + Math.cos(clawAngle + clawOpen) * 25,
        y + Math.sin(clawAngle + clawOpen) * 25
      );
      ctx.stroke();

      // Claw tips
      ctx.fillStyle = '#ffaacc';
      ctx.beginPath();
      ctx.arc(
        x + Math.cos(clawAngle - clawOpen) * 25,
        y + Math.sin(clawAngle - clawOpen) * 25,
        5, 0, Math.PI * 2
      );
      ctx.fill();
      ctx.beginPath();
      ctx.arc(
        x + Math.cos(clawAngle + clawOpen) * 25,
        y + Math.sin(clawAngle + clawOpen) * 25,
        5, 0, Math.PI * 2
      );
      ctx.fill();

      ctx.shadowBlur = 0;
    }

    function tryGrabShape() {
      const endPos = getRobotArmEndPos();

      for (let i = shapes.length - 1; i >= 0; i--) {
        const shape = shapes[i];
        const dx = shape.x - endPos.x;
        const dy = shape.y - endPos.y;
        const dist = Math.sqrt(dx * dx + dy * dy);

        if (dist < shape.size + 20) {
          robotArm.grabbedShape = shape;
          robotArm.clawOpen = false;
          return;
        }
      }
    }

    function releaseShape() {
      if (robotArm.grabbedShape) {
        // Apply throwing velocity
        robotArm.grabbedShape.vx = robotArm.velocityX * 2;
        robotArm.grabbedShape.vy = robotArm.velocityY * 2;
        robotArm.grabbedShape = null;
      }
      robotArm.clawOpen = true;
    }

    // Input handling
    function getEventPos(e) {
      const rect = canvas.getBoundingClientRect();
      if (e.touches) {
        return {
          x: e.touches[0].clientX - rect.left,
          y: e.touches[0].clientY - rect.top
        };
      }
      return {
        x: e.clientX - rect.left,
        y: e.clientY - rect.top
      };
    }

    let isDrawing = false;
    let lastSpawnTime = 0;

    canvas.addEventListener('mousedown', (e) => {
      const pos = getEventPos(e);
      if (selectedShape === 'grab') {
        tryGrabShape();
      } else {
        isDrawing = true;
        spawnShape(pos.x, pos.y);
      }
    });

    canvas.addEventListener('mousemove', (e) => {
      const pos = getEventPos(e);
      robotArm.targetX = pos.x;
      robotArm.targetY = pos.y;

      if (selectedShape !== 'grab' && isDrawing && Date.now() - lastSpawnTime > 50) {
        spawnShape(pos.x, pos.y);
        lastSpawnTime = Date.now();
      }
    });

    canvas.addEventListener('mouseup', () => {
      isDrawing = false;
      if (selectedShape === 'grab') {
        releaseShape();
      }
    });
    canvas.addEventListener('mouseleave', () => isDrawing = false);

    canvas.addEventListener('touchstart', (e) => {
      e.preventDefault();
      const pos = getEventPos(e);
      robotArm.targetX = pos.x;
      robotArm.targetY = pos.y;

      if (selectedShape === 'grab') {
        tryGrabShape();
      } else {
        isDrawing = true;
        spawnShape(pos.x, pos.y);
      }
    });

    canvas.addEventListener('touchmove', (e) => {
      e.preventDefault();
      const pos = getEventPos(e);
      robotArm.targetX = pos.x;
      robotArm.targetY = pos.y;

      if (selectedShape !== 'grab' && isDrawing && Date.now() - lastSpawnTime > 50) {
        spawnShape(pos.x, pos.y);
        lastSpawnTime = Date.now();
      }
    });

    canvas.addEventListener('touchend', () => {
      isDrawing = false;
      if (selectedShape === 'grab') {
        releaseShape();
      }
    });

    function gameLoop() {
      // Clear with trail effect
      ctx.fillStyle = 'rgba(10, 10, 18, 0.3)';
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      // Update robot arm
      if (selectedShape === 'grab') {
        updateRobotArm();
      }

      // Update physics (skip grabbed shape)
      shapes.forEach(shape => {
        if (shape !== robotArm.grabbedShape) {
          shape.update();
        }
      });

      // Check collisions
      for (let i = 0; i < shapes.length; i++) {
        for (let j = i + 1; j < shapes.length; j++) {
          if (shapes[i] !== robotArm.grabbedShape && shapes[j] !== robotArm.grabbedShape) {
            shapes[i].checkCollision(shapes[j]);
          }
        }
      }

      // Draw shapes
      shapes.forEach(shape => shape.draw());

      // Draw robot arm when grab tool selected
      if (selectedShape === 'grab') {
        drawRobotArm();
      }

      // Draw ground line
      ctx.strokeStyle = '#333344';
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(0, canvas.height - 1);
      ctx.lineTo(canvas.width, canvas.height - 1);
      ctx.stroke();

      requestAnimationFrame(gameLoop);
    }

    // Initialize robot arm target
    robotArm.targetX = canvas.width / 2;
    robotArm.targetY = canvas.height / 2;

    gameLoop();
  </script>
</body>
</html>
