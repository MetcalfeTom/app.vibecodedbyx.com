<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
  <title>Neon Sandbox</title>
  <link rel="icon" href="https://emojicdn.elk.sh/üîÆ">
  <meta property="og:title" content="Neon Sandbox">
  <meta property="og:description" content="Drop glowing shapes and watch them bounce around!">
  <meta property="og:url" content="https://sloppy.live/neon-sandbox">
  <meta property="og:image" content="https://sloppy.live/neon-sandbox/og-image.png">
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&display=swap" rel="stylesheet">
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
      touch-action: none;
    }

    body {
      background: #0a0a12;
      font-family: 'Orbitron', sans-serif;
      min-height: 100vh;
      overflow: hidden;
      display: flex;
      flex-direction: column;
    }

    #toolbar {
      display: flex;
      justify-content: center;
      gap: 10px;
      padding: 12px;
      background: linear-gradient(180deg, #1a1a2e 0%, #0f0f1a 100%);
      border-bottom: 2px solid #ff00ff44;
      flex-wrap: wrap;
      z-index: 10;
    }

    .tool-btn {
      padding: 10px 16px;
      background: #1a1a2e;
      border: 2px solid #444;
      border-radius: 8px;
      color: #888;
      font-family: 'Orbitron', sans-serif;
      font-size: 12px;
      cursor: pointer;
      transition: all 0.2s;
      display: flex;
      align-items: center;
      gap: 6px;
    }

    .tool-btn:hover {
      border-color: #888;
      color: #fff;
    }

    .tool-btn.active {
      border-color: var(--glow-color, #ff00ff);
      color: #fff;
      box-shadow: 0 0 15px var(--glow-color, #ff00ff)44;
      background: #2a2a4e;
    }

    .tool-btn .icon {
      font-size: 16px;
    }

    #canvas-container {
      flex: 1;
      position: relative;
      overflow: hidden;
    }

    #sandbox {
      display: block;
      width: 100%;
      height: 100%;
      cursor: crosshair;
    }

    #controls {
      position: fixed;
      bottom: 15px;
      left: 50%;
      transform: translateX(-50%);
      display: flex;
      gap: 10px;
      z-index: 10;
    }

    .control-btn {
      padding: 10px 20px;
      background: #1a1a2e;
      border: 2px solid #00ffff;
      border-radius: 8px;
      color: #00ffff;
      font-family: 'Orbitron', sans-serif;
      font-size: 11px;
      cursor: pointer;
      transition: all 0.2s;
    }

    .control-btn:hover {
      background: #00ffff22;
      box-shadow: 0 0 20px #00ffff44;
    }

    #backlink {
      position: fixed;
      bottom: 15px;
      right: 15px;
      z-index: 10;
    }

    #backlink a {
      color: #666;
      text-decoration: none;
      font-size: 11px;
      transition: color 0.2s;
    }

    #backlink a:hover {
      color: #ff00ff;
    }

    #shape-count {
      position: fixed;
      top: 70px;
      right: 15px;
      color: #666;
      font-size: 11px;
      z-index: 10;
    }

    #instructions {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      color: #444;
      font-size: 14px;
      text-align: center;
      pointer-events: none;
      transition: opacity 0.5s;
      z-index: 5;
    }

    #instructions.hidden {
      opacity: 0;
    }

    @media (max-width: 600px) {
      .tool-btn {
        padding: 8px 12px;
        font-size: 10px;
      }

      .tool-btn .label {
        display: none;
      }

      .tool-btn .icon {
        font-size: 18px;
      }
    }
  </style>
</head>
<body>
  <div id="toolbar">
    <button class="tool-btn active" data-shape="circle" style="--glow-color: #ff00ff">
      <span class="icon">‚óè</span>
      <span class="label">Ball</span>
    </button>
    <button class="tool-btn" data-shape="square" style="--glow-color: #00ffff">
      <span class="icon">‚ñ†</span>
      <span class="label">Square</span>
    </button>
    <button class="tool-btn" data-shape="triangle" style="--glow-color: #ffff00">
      <span class="icon">‚ñ≤</span>
      <span class="label">Triangle</span>
    </button>
    <button class="tool-btn" data-shape="star" style="--glow-color: #ff6600">
      <span class="icon">‚òÖ</span>
      <span class="label">Star</span>
    </button>
    <button class="tool-btn" data-shape="hexagon" style="--glow-color: #00ff88">
      <span class="icon">‚¨°</span>
      <span class="label">Hexagon</span>
    </button>
    <button class="tool-btn" data-shape="pig" style="--glow-color: #ff66aa">
      <span class="icon">üê∑</span>
      <span class="label">Pig</span>
    </button>
    <button class="tool-btn" data-shape="giraffe" style="--glow-color: #ffdd00">
      <span class="icon">ü¶í</span>
      <span class="label">Giraffe</span>
    </button>
    <button class="tool-btn" data-shape="grab" style="--glow-color: #00ccff">
      <span class="icon">ü¶à</span>
      <span class="label">Shark Arm</span>
    </button>
  </div>

  <div id="canvas-container">
    <canvas id="sandbox"></canvas>
  </div>

  <div id="controls">
    <button class="control-btn" onclick="clearAll()">CLEAR</button>
    <button class="control-btn" onclick="toggleGravity()">GRAVITY: ON</button>
    <button class="control-btn" onclick="shake()">SHAKE</button>
  </div>

  <div id="shape-count">Shapes: 0</div>
  <div id="instructions">Click or tap to spawn shapes</div>

  <div id="backlink">
    <a href="https://sloppy.live">‚Üê sloppy.live</a>
  </div>

  <script>
    const canvas = document.getElementById('sandbox');
    const ctx = canvas.getContext('2d');
    const container = document.getElementById('canvas-container');

    let shapes = [];
    let selectedShape = 'circle';
    let gravityEnabled = true;
    let hasInteracted = false;

    // Robot arm state
    const robotArm = {
      baseX: 0,
      baseY: 0,
      targetX: 0,
      targetY: 0,
      smoothTargetX: 0,
      smoothTargetY: 0,
      segments: [
        { length: 160, angle: -Math.PI / 2, targetAngle: -Math.PI / 2 },
        { length: 120, angle: 0, targetAngle: 0 },
        { length: 80, angle: 0, targetAngle: 0 }
      ],
      grabbedShape: null,
      clawOpen: true,
      prevX: 0,
      prevY: 0,
      velocityX: 0,
      velocityY: 0
    };

    const GRAVITY = 0.5;
    const FRICTION = 0.99;
    const BOUNCE = 0.7;
    const MAX_SHAPES = 200;

    const COLORS = [
      '#ff00ff', '#00ffff', '#ffff00', '#ff6600', '#00ff88',
      '#ff0066', '#6600ff', '#00ff00', '#ff3366', '#33ffcc'
    ];

    function resize() {
      canvas.width = container.clientWidth;
      canvas.height = container.clientHeight;
    }

    resize();
    window.addEventListener('resize', resize);

    // Tool buttons
    document.querySelectorAll('.tool-btn').forEach(btn => {
      btn.addEventListener('click', () => {
        document.querySelectorAll('.tool-btn').forEach(b => b.classList.remove('active'));
        btn.classList.add('active');
        selectedShape = btn.dataset.shape;
      });
    });

    class Shape {
      constructor(x, y, type) {
        this.x = x;
        this.y = y;
        this.vx = (Math.random() - 0.5) * 8;
        this.vy = (Math.random() - 0.5) * 4;
        this.type = type;
        // Special sizes for animals
        if (type === 'pig') {
          this.size = 30 + Math.random() * 20;
        } else if (type === 'giraffe') {
          this.size = 35 + Math.random() * 20;
        } else {
          this.size = 20 + Math.random() * 25;
        }
        this.rotation = (type === 'pig' || type === 'giraffe') ? 0 : Math.random() * Math.PI * 2;
        this.rotationSpeed = (type === 'pig' || type === 'giraffe') ? (Math.random() - 0.5) * 0.03 : (Math.random() - 0.5) * 0.15;
        if (type === 'pig') {
          this.color = '#ff66aa';
        } else if (type === 'giraffe') {
          this.color = '#ffdd00';
        } else {
          this.color = COLORS[Math.floor(Math.random() * COLORS.length)];
        }
        this.mass = this.size * this.size * 0.01;
      }

      update() {
        if (gravityEnabled) {
          this.vy += GRAVITY;
        }

        this.vx *= FRICTION;
        this.vy *= FRICTION;

        this.x += this.vx;
        this.y += this.vy;
        this.rotation += this.rotationSpeed;

        // Bounce off walls
        if (this.x - this.size < 0) {
          this.x = this.size;
          this.vx *= -BOUNCE;
          this.rotationSpeed *= -0.8;
        }
        if (this.x + this.size > canvas.width) {
          this.x = canvas.width - this.size;
          this.vx *= -BOUNCE;
          this.rotationSpeed *= -0.8;
        }
        if (this.y - this.size < 0) {
          this.y = this.size;
          this.vy *= -BOUNCE;
        }
        if (this.y + this.size > canvas.height) {
          this.y = canvas.height - this.size;
          this.vy *= -BOUNCE;
          this.rotationSpeed *= 0.95;

          // Extra friction on ground
          this.vx *= 0.98;
        }
      }

      draw() {
        ctx.save();
        ctx.translate(this.x, this.y);
        ctx.rotate(this.rotation);

        ctx.fillStyle = this.color;
        ctx.shadowColor = this.color;
        ctx.shadowBlur = 20;

        switch (this.type) {
          case 'circle':
            ctx.beginPath();
            ctx.arc(0, 0, this.size, 0, Math.PI * 2);
            ctx.fill();
            // Inner glow
            ctx.fillStyle = '#ffffff44';
            ctx.beginPath();
            ctx.arc(-this.size * 0.3, -this.size * 0.3, this.size * 0.3, 0, Math.PI * 2);
            ctx.fill();
            break;

          case 'square':
            ctx.fillRect(-this.size, -this.size, this.size * 2, this.size * 2);
            // Inner highlight
            ctx.fillStyle = '#ffffff22';
            ctx.fillRect(-this.size * 0.6, -this.size * 0.6, this.size * 0.8, this.size * 0.8);
            break;

          case 'triangle':
            ctx.beginPath();
            ctx.moveTo(0, -this.size);
            ctx.lineTo(-this.size, this.size);
            ctx.lineTo(this.size, this.size);
            ctx.closePath();
            ctx.fill();
            break;

          case 'star':
            this.drawStar(5, this.size, this.size * 0.5);
            break;

          case 'hexagon':
            this.drawPolygon(6, this.size);
            break;

          case 'pig':
            // Pink body
            ctx.fillStyle = '#ff66aa';
            ctx.shadowColor = '#ff66aa';
            ctx.beginPath();
            ctx.ellipse(0, 0, this.size, this.size * 0.8, 0, 0, Math.PI * 2);
            ctx.fill();

            // Snout
            ctx.fillStyle = '#ffaacc';
            ctx.beginPath();
            ctx.ellipse(this.size * 0.6, 0, this.size * 0.4, this.size * 0.35, 0, 0, Math.PI * 2);
            ctx.fill();

            // Nostrils
            ctx.fillStyle = '#cc4488';
            ctx.beginPath();
            ctx.ellipse(this.size * 0.55, -this.size * 0.08, this.size * 0.08, this.size * 0.1, 0, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.ellipse(this.size * 0.55, this.size * 0.08, this.size * 0.08, this.size * 0.1, 0, 0, Math.PI * 2);
            ctx.fill();

            // Eyes
            ctx.fillStyle = '#000';
            ctx.beginPath();
            ctx.arc(-this.size * 0.1, -this.size * 0.25, this.size * 0.12, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.arc(this.size * 0.2, -this.size * 0.25, this.size * 0.12, 0, Math.PI * 2);
            ctx.fill();

            // Eye shine
            ctx.fillStyle = '#fff';
            ctx.beginPath();
            ctx.arc(-this.size * 0.05, -this.size * 0.3, this.size * 0.05, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.arc(this.size * 0.25, -this.size * 0.3, this.size * 0.05, 0, Math.PI * 2);
            ctx.fill();

            // Ears
            ctx.fillStyle = '#ff66aa';
            ctx.beginPath();
            ctx.ellipse(-this.size * 0.5, -this.size * 0.6, this.size * 0.25, this.size * 0.35, -0.4, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.ellipse(this.size * 0.1, -this.size * 0.65, this.size * 0.25, this.size * 0.35, 0.4, 0, Math.PI * 2);
            ctx.fill();

            // Inner ears
            ctx.fillStyle = '#ffaacc';
            ctx.beginPath();
            ctx.ellipse(-this.size * 0.5, -this.size * 0.6, this.size * 0.12, this.size * 0.2, -0.4, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.ellipse(this.size * 0.1, -this.size * 0.65, this.size * 0.12, this.size * 0.2, 0.4, 0, Math.PI * 2);
            ctx.fill();
            break;

          case 'giraffe':
            // Body
            ctx.fillStyle = '#ffdd00';
            ctx.shadowColor = '#ffdd00';
            ctx.beginPath();
            ctx.ellipse(0, this.size * 0.2, this.size * 0.6, this.size * 0.5, 0, 0, Math.PI * 2);
            ctx.fill();

            // Neck
            ctx.fillRect(-this.size * 0.15, -this.size * 0.8, this.size * 0.3, this.size);

            // Head
            ctx.beginPath();
            ctx.ellipse(0, -this.size * 0.9, this.size * 0.25, this.size * 0.2, 0, 0, Math.PI * 2);
            ctx.fill();

            // Spots
            ctx.fillStyle = '#cc8800';
            const spots = [
              { x: -0.2, y: 0.1 }, { x: 0.25, y: 0.3 }, { x: 0, y: 0.4 },
              { x: -0.05, y: -0.3 }, { x: 0.05, y: -0.5 }
            ];
            spots.forEach(spot => {
              ctx.beginPath();
              ctx.ellipse(this.size * spot.x, this.size * spot.y, this.size * 0.12, this.size * 0.1, Math.random(), 0, Math.PI * 2);
              ctx.fill();
            });

            // Ossicones (horns)
            ctx.fillStyle = '#cc8800';
            ctx.fillRect(-this.size * 0.15, -this.size * 1.15, this.size * 0.08, this.size * 0.25);
            ctx.fillRect(this.size * 0.07, -this.size * 1.15, this.size * 0.08, this.size * 0.25);

            // Horn tips
            ctx.fillStyle = '#663300';
            ctx.beginPath();
            ctx.arc(-this.size * 0.11, -this.size * 1.18, this.size * 0.06, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.arc(this.size * 0.11, -this.size * 1.18, this.size * 0.06, 0, Math.PI * 2);
            ctx.fill();

            // Eyes
            ctx.fillStyle = '#000';
            ctx.beginPath();
            ctx.arc(-this.size * 0.1, -this.size * 0.9, this.size * 0.06, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.arc(this.size * 0.1, -this.size * 0.9, this.size * 0.06, 0, Math.PI * 2);
            ctx.fill();

            // Eye shine
            ctx.fillStyle = '#fff';
            ctx.beginPath();
            ctx.arc(-this.size * 0.08, -this.size * 0.92, this.size * 0.025, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.arc(this.size * 0.12, -this.size * 0.92, this.size * 0.025, 0, Math.PI * 2);
            ctx.fill();

            // Legs
            ctx.fillStyle = '#ffdd00';
            ctx.fillRect(-this.size * 0.4, this.size * 0.4, this.size * 0.12, this.size * 0.5);
            ctx.fillRect(-this.size * 0.15, this.size * 0.4, this.size * 0.12, this.size * 0.5);
            ctx.fillRect(this.size * 0.05, this.size * 0.4, this.size * 0.12, this.size * 0.5);
            ctx.fillRect(this.size * 0.28, this.size * 0.4, this.size * 0.12, this.size * 0.5);

            // Hooves
            ctx.fillStyle = '#663300';
            ctx.fillRect(-this.size * 0.4, this.size * 0.85, this.size * 0.12, this.size * 0.08);
            ctx.fillRect(-this.size * 0.15, this.size * 0.85, this.size * 0.12, this.size * 0.08);
            ctx.fillRect(this.size * 0.05, this.size * 0.85, this.size * 0.12, this.size * 0.08);
            ctx.fillRect(this.size * 0.28, this.size * 0.85, this.size * 0.12, this.size * 0.08);

            // Tail
            ctx.strokeStyle = '#cc8800';
            ctx.lineWidth = this.size * 0.05;
            ctx.beginPath();
            ctx.moveTo(this.size * 0.5, this.size * 0.1);
            ctx.quadraticCurveTo(this.size * 0.7, this.size * 0.3, this.size * 0.6, this.size * 0.5);
            ctx.stroke();

            // Tail tuft
            ctx.fillStyle = '#663300';
            ctx.beginPath();
            ctx.ellipse(this.size * 0.6, this.size * 0.55, this.size * 0.08, this.size * 0.12, 0.3, 0, Math.PI * 2);
            ctx.fill();
            break;
        }

        ctx.restore();
      }

      drawStar(points, outerRadius, innerRadius) {
        ctx.beginPath();
        for (let i = 0; i < points * 2; i++) {
          const radius = i % 2 === 0 ? outerRadius : innerRadius;
          const angle = (i * Math.PI) / points - Math.PI / 2;
          const x = Math.cos(angle) * radius;
          const y = Math.sin(angle) * radius;
          if (i === 0) {
            ctx.moveTo(x, y);
          } else {
            ctx.lineTo(x, y);
          }
        }
        ctx.closePath();
        ctx.fill();
      }

      drawPolygon(sides, radius) {
        ctx.beginPath();
        for (let i = 0; i < sides; i++) {
          const angle = (i * 2 * Math.PI) / sides - Math.PI / 2;
          const x = Math.cos(angle) * radius;
          const y = Math.sin(angle) * radius;
          if (i === 0) {
            ctx.moveTo(x, y);
          } else {
            ctx.lineTo(x, y);
          }
        }
        ctx.closePath();
        ctx.fill();
      }

      checkCollision(other) {
        const dx = other.x - this.x;
        const dy = other.y - this.y;
        const dist = Math.sqrt(dx * dx + dy * dy);
        const minDist = this.size + other.size;

        if (dist < minDist && dist > 0) {
          // Collision response
          const nx = dx / dist;
          const ny = dy / dist;

          // Relative velocity
          const dvx = this.vx - other.vx;
          const dvy = this.vy - other.vy;
          const dvn = dvx * nx + dvy * ny;

          // Only resolve if moving towards each other
          if (dvn > 0) {
            const totalMass = this.mass + other.mass;
            const impulse = (2 * dvn) / totalMass;

            this.vx -= impulse * other.mass * nx * BOUNCE;
            this.vy -= impulse * other.mass * ny * BOUNCE;
            other.vx += impulse * this.mass * nx * BOUNCE;
            other.vy += impulse * this.mass * ny * BOUNCE;

            // Separate overlapping shapes
            const overlap = minDist - dist;
            const sepX = (overlap / 2) * nx;
            const sepY = (overlap / 2) * ny;
            this.x -= sepX;
            this.y -= sepY;
            other.x += sepX;
            other.y += sepY;
          }
        }
      }
    }

    function spawnShape(x, y) {
      if (!hasInteracted) {
        hasInteracted = true;
        document.getElementById('instructions').classList.add('hidden');
      }

      if (shapes.length >= MAX_SHAPES) {
        shapes.shift(); // Remove oldest
      }

      shapes.push(new Shape(x, y, selectedShape));
      updateShapeCount();
    }

    function updateShapeCount() {
      document.getElementById('shape-count').textContent = `Shapes: ${shapes.length}`;
    }

    function clearAll() {
      shapes = [];
      updateShapeCount();
    }

    function toggleGravity() {
      gravityEnabled = !gravityEnabled;
      document.querySelector('[onclick="toggleGravity()"]').textContent =
        `GRAVITY: ${gravityEnabled ? 'ON' : 'OFF'}`;
    }

    function shake() {
      shapes.forEach(shape => {
        shape.vx += (Math.random() - 0.5) * 30;
        shape.vy += (Math.random() - 0.5) * 30;
      });
    }

    // Fart system for giraffes
    let audioCtx = null;
    let fartParticles = [];

    function playGiraffeFart() {
      if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();

      // Create a funny fart sound
      const osc = audioCtx.createOscillator();
      const gain = audioCtx.createGain();
      const filter = audioCtx.createBiquadFilter();

      osc.type = 'sawtooth';
      osc.frequency.setValueAtTime(120, audioCtx.currentTime);
      osc.frequency.exponentialRampToValueAtTime(60, audioCtx.currentTime + 0.15);
      osc.frequency.exponentialRampToValueAtTime(40, audioCtx.currentTime + 0.4);

      filter.type = 'lowpass';
      filter.frequency.value = 400;

      gain.gain.setValueAtTime(0.4, audioCtx.currentTime);
      gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.5);

      osc.connect(filter);
      filter.connect(gain);
      gain.connect(audioCtx.destination);

      osc.start();
      osc.stop(audioCtx.currentTime + 0.5);

      // Add some noise for texture
      const noise = audioCtx.createOscillator();
      const noiseGain = audioCtx.createGain();
      noise.type = 'triangle';
      noise.frequency.setValueAtTime(80, audioCtx.currentTime);
      noise.frequency.linearRampToValueAtTime(30, audioCtx.currentTime + 0.3);
      noiseGain.gain.setValueAtTime(0.2, audioCtx.currentTime);
      noiseGain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.4);
      noise.connect(noiseGain);
      noiseGain.connect(audioCtx.destination);
      noise.start();
      noise.stop(audioCtx.currentTime + 0.4);
    }

    function spawnFartCloud(x, y) {
      // Spawn green fart particles
      for (let i = 0; i < 12; i++) {
        fartParticles.push({
          x: x,
          y: y,
          vx: (Math.random() - 0.5) * 6,
          vy: (Math.random() - 0.5) * 6 - 2,
          size: 15 + Math.random() * 20,
          life: 60 + Math.random() * 30,
          maxLife: 90,
          color: Math.random() > 0.5 ? '#88ff44' : '#66cc22'
        });
      }
    }

    function updateFartParticles() {
      for (let i = fartParticles.length - 1; i >= 0; i--) {
        const p = fartParticles[i];
        p.x += p.vx;
        p.y += p.vy;
        p.vy -= 0.05; // Float up
        p.vx *= 0.98;
        p.size *= 1.02; // Expand
        p.life--;
        if (p.life <= 0) {
          fartParticles.splice(i, 1);
        }
      }
    }

    function drawFartParticles() {
      fartParticles.forEach(p => {
        const alpha = p.life / p.maxLife;
        ctx.fillStyle = p.color;
        ctx.globalAlpha = alpha * 0.6;
        ctx.shadowColor = p.color;
        ctx.shadowBlur = 15;
        ctx.beginPath();
        ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
        ctx.fill();
      });
      ctx.globalAlpha = 1;
      ctx.shadowBlur = 0;
    }

    // Robot arm functions
    function updateRobotArm() {
      // Set base position at bottom center
      robotArm.baseX = canvas.width / 2;
      robotArm.baseY = canvas.height;

      // Fast target interpolation for snappy movement
      const smoothing = 0.45;
      robotArm.smoothTargetX += (robotArm.targetX - robotArm.smoothTargetX) * smoothing;
      robotArm.smoothTargetY += (robotArm.targetY - robotArm.smoothTargetY) * smoothing;

      // Inverse kinematics to reach smoothed target
      solveIK();

      // Fast angle interpolation for flexible joints
      const angleSmoothing = 0.55;
      robotArm.segments.forEach(seg => {
        seg.angle += (seg.targetAngle - seg.angle) * angleSmoothing;
      });

      // Calculate velocity for throwing from claw tip
      const clawTip = getClawTipPos();
      robotArm.velocityX = (clawTip.x - robotArm.prevX) * 0.8;
      robotArm.velocityY = (clawTip.y - robotArm.prevY) * 0.8;
      robotArm.prevX = clawTip.x;
      robotArm.prevY = clawTip.y;

      // Update grabbed shape position to claw tip
      if (robotArm.grabbedShape) {
        robotArm.grabbedShape.x = clawTip.x;
        robotArm.grabbedShape.y = clawTip.y;
        robotArm.grabbedShape.vx = 0;
        robotArm.grabbedShape.vy = 0;
      }
    }

    function solveIK() {
      // FABRIK inverse kinematics for flexible arm
      const segments = robotArm.segments;
      const totalLength = segments.reduce((sum, s) => sum + s.length, 0);

      // Get joint positions using current smoothed angles
      let joints = [{ x: robotArm.baseX, y: robotArm.baseY }];
      let angle = 0;
      for (let i = 0; i < segments.length; i++) {
        angle += segments[i].angle;
        joints.push({
          x: joints[i].x + Math.cos(angle) * segments[i].length,
          y: joints[i].y + Math.sin(angle) * segments[i].length
        });
      }

      // Use smoothed target position
      let targetX = robotArm.smoothTargetX;
      let targetY = robotArm.smoothTargetY;

      // Clamp target to reachable distance
      const dx = targetX - robotArm.baseX;
      const dy = targetY - robotArm.baseY;
      const dist = Math.sqrt(dx * dx + dy * dy);
      if (dist > totalLength - 5) {
        const scale = (totalLength - 5) / dist;
        targetX = robotArm.baseX + dx * scale;
        targetY = robotArm.baseY + dy * scale;
      }

      // FABRIK iterations
      for (let iter = 0; iter < 8; iter++) {
        // Backward pass - start from end effector
        joints[joints.length - 1] = { x: targetX, y: targetY };
        for (let i = joints.length - 2; i >= 0; i--) {
          const segLen = segments[i].length;
          const ddx = joints[i].x - joints[i + 1].x;
          const ddy = joints[i].y - joints[i + 1].y;
          const d = Math.sqrt(ddx * ddx + ddy * ddy) || 1;
          joints[i] = {
            x: joints[i + 1].x + (ddx / d) * segLen,
            y: joints[i + 1].y + (ddy / d) * segLen
          };
        }

        // Forward pass - start from base
        joints[0] = { x: robotArm.baseX, y: robotArm.baseY };
        for (let i = 0; i < segments.length; i++) {
          const segLen = segments[i].length;
          const ddx = joints[i + 1].x - joints[i].x;
          const ddy = joints[i + 1].y - joints[i].y;
          const d = Math.sqrt(ddx * ddx + ddy * ddy) || 1;
          joints[i + 1] = {
            x: joints[i].x + (ddx / d) * segLen,
            y: joints[i].y + (ddy / d) * segLen
          };
        }
      }

      // Convert joint positions to target angles (will be smoothly interpolated)
      let prevAngle = 0;
      for (let i = 0; i < segments.length; i++) {
        const ddx = joints[i + 1].x - joints[i].x;
        const ddy = joints[i + 1].y - joints[i].y;
        const absoluteAngle = Math.atan2(ddy, ddx);
        segments[i].targetAngle = absoluteAngle - prevAngle;
        prevAngle = absoluteAngle;
      }
    }

    function getRobotArmEndPos() {
      let x = robotArm.baseX;
      let y = robotArm.baseY;
      let angle = 0;

      robotArm.segments.forEach(seg => {
        angle += seg.angle;
        x += Math.cos(angle) * seg.length;
        y += Math.sin(angle) * seg.length;
      });

      return { x, y, angle };
    }

    function getClawTipPos() {
      const endPos = getRobotArmEndPos();
      // Sawshark jaw tip is 75 units past the end
      return {
        x: endPos.x + Math.cos(endPos.angle) * 75,
        y: endPos.y + Math.sin(endPos.angle) * 75
      };
    }

    function drawSharkSegment(x, y, angle, length, size) {
      ctx.save();
      ctx.translate(x, y);
      ctx.rotate(angle);

      // Shark body
      ctx.fillStyle = '#0088cc';
      ctx.shadowColor = '#00ccff';
      ctx.shadowBlur = 15;
      ctx.beginPath();
      ctx.ellipse(length / 2, 0, length / 2 + 5, size, 0, 0, Math.PI * 2);
      ctx.fill();

      // Darker belly
      ctx.fillStyle = '#006699';
      ctx.beginPath();
      ctx.ellipse(length / 2, size * 0.3, length / 2, size * 0.5, 0, 0, Math.PI);
      ctx.fill();

      // Dorsal fin
      ctx.fillStyle = '#0099dd';
      ctx.beginPath();
      ctx.moveTo(length * 0.3, -size);
      ctx.lineTo(length * 0.15, -size - 15);
      ctx.lineTo(length * 0.5, -size);
      ctx.closePath();
      ctx.fill();

      // Side fins
      ctx.fillStyle = '#0077aa';
      ctx.beginPath();
      ctx.moveTo(length * 0.4, size * 0.5);
      ctx.lineTo(length * 0.25, size + 12);
      ctx.lineTo(length * 0.55, size * 0.5);
      ctx.closePath();
      ctx.fill();
      ctx.beginPath();
      ctx.moveTo(length * 0.4, -size * 0.5);
      ctx.lineTo(length * 0.25, -size - 8);
      ctx.lineTo(length * 0.55, -size * 0.5);
      ctx.closePath();
      ctx.fill();

      // Tail fin
      ctx.fillStyle = '#0099dd';
      ctx.beginPath();
      ctx.moveTo(-5, 0);
      ctx.lineTo(-20, -size - 5);
      ctx.lineTo(-8, 0);
      ctx.lineTo(-20, size + 5);
      ctx.closePath();
      ctx.fill();

      // Eye
      ctx.shadowBlur = 0;
      ctx.fillStyle = '#000';
      ctx.beginPath();
      ctx.arc(length * 0.75, -size * 0.3, size * 0.25, 0, Math.PI * 2);
      ctx.fill();
      ctx.fillStyle = '#ff0000';
      ctx.beginPath();
      ctx.arc(length * 0.75, -size * 0.3, size * 0.15, 0, Math.PI * 2);
      ctx.fill();
      ctx.fillStyle = '#fff';
      ctx.beginPath();
      ctx.arc(length * 0.73, -size * 0.35, size * 0.08, 0, Math.PI * 2);
      ctx.fill();

      // Gills
      ctx.strokeStyle = '#004466';
      ctx.lineWidth = 2;
      for (let i = 0; i < 3; i++) {
        ctx.beginPath();
        ctx.moveTo(length * 0.6 + i * 4, -size * 0.4);
        ctx.lineTo(length * 0.6 + i * 4, size * 0.4);
        ctx.stroke();
      }

      ctx.restore();
    }

    function drawRobotArm() {
      let x = robotArm.baseX;
      let y = robotArm.baseY;
      let angle = 0;

      // Draw underwater base (coral/rock)
      ctx.fillStyle = '#224466';
      ctx.shadowColor = '#00ccff';
      ctx.shadowBlur = 25;
      ctx.beginPath();
      ctx.arc(x, y, 50, Math.PI, 0);
      ctx.fill();
      ctx.fillStyle = '#0066aa';
      ctx.beginPath();
      ctx.arc(x - 20, y, 20, Math.PI, 0);
      ctx.fill();
      ctx.beginPath();
      ctx.arc(x + 20, y, 25, Math.PI, 0);
      ctx.fill();

      // Draw shark chain segments
      const sizes = [22, 18, 14];
      robotArm.segments.forEach((seg, i) => {
        angle += seg.angle;
        const nextX = x + Math.cos(angle) * seg.length;
        const nextY = y + Math.sin(angle) * seg.length;

        // Draw shark body for this segment
        drawSharkSegment(x, y, angle, seg.length, sizes[i]);

        // Connection joint (like a bite mark / link)
        ctx.fillStyle = '#00aadd';
        ctx.shadowColor = '#00ffff';
        ctx.shadowBlur = 10;
        ctx.beginPath();
        ctx.arc(nextX, nextY, sizes[i] * 0.6, 0, Math.PI * 2);
        ctx.fill();

        x = nextX;
        y = nextY;
      });

      // Draw sawshark mouth
      const mouthAngle = angle;
      const jawOpen = robotArm.clawOpen ? 0.5 : 0.05;
      const sawLength = 70;

      ctx.save();
      ctx.translate(x, y);
      ctx.rotate(mouthAngle);

      // Shark body/head base
      ctx.fillStyle = '#0088cc';
      ctx.shadowColor = '#00ccff';
      ctx.shadowBlur = 20;
      ctx.beginPath();
      ctx.ellipse(-15, 0, 30, 22, 0, 0, Math.PI * 2);
      ctx.fill();

      // Upper saw blade jaw
      ctx.save();
      ctx.rotate(-jawOpen);
      ctx.fillStyle = '#0099dd';
      ctx.shadowColor = '#00ccff';
      ctx.shadowBlur = 15;
      ctx.beginPath();
      ctx.moveTo(5, 0);
      ctx.lineTo(sawLength, -4);
      ctx.lineTo(sawLength + 8, 0);
      ctx.lineTo(sawLength, 4);
      ctx.lineTo(5, 3);
      ctx.closePath();
      ctx.fill();

      // Upper saw teeth (along outer edge)
      ctx.fillStyle = '#ffffff';
      ctx.shadowColor = '#ffffff';
      ctx.shadowBlur = 3;
      for (let i = 0; i < 10; i++) {
        const tx = 12 + i * 6;
        ctx.beginPath();
        ctx.moveTo(tx, -4);
        ctx.lineTo(tx + 2, -10);
        ctx.lineTo(tx + 4, -4);
        ctx.closePath();
        ctx.fill();
      }
      ctx.restore();

      // Lower saw blade jaw
      ctx.save();
      ctx.rotate(jawOpen);
      ctx.fillStyle = '#0077bb';
      ctx.shadowColor = '#00ccff';
      ctx.shadowBlur = 15;
      ctx.beginPath();
      ctx.moveTo(5, 0);
      ctx.lineTo(sawLength, 4);
      ctx.lineTo(sawLength + 8, 0);
      ctx.lineTo(sawLength, -4);
      ctx.lineTo(5, -3);
      ctx.closePath();
      ctx.fill();

      // Lower saw teeth (along outer edge)
      ctx.fillStyle = '#ffffff';
      ctx.shadowColor = '#ffffff';
      ctx.shadowBlur = 3;
      for (let i = 0; i < 10; i++) {
        const tx = 12 + i * 6;
        ctx.beginPath();
        ctx.moveTo(tx, 4);
        ctx.lineTo(tx + 2, 10);
        ctx.lineTo(tx + 4, 4);
        ctx.closePath();
        ctx.fill();
      }
      ctx.restore();

      // Eyes (two small ones on sides like sawshark)
      ctx.shadowBlur = 0;
      ctx.fillStyle = '#000';
      ctx.beginPath();
      ctx.ellipse(-20, -12, 5, 4, 0, 0, Math.PI * 2);
      ctx.fill();
      ctx.beginPath();
      ctx.ellipse(-20, 12, 5, 4, 0, 0, Math.PI * 2);
      ctx.fill();
      // Red glow
      ctx.fillStyle = '#ff0000';
      ctx.beginPath();
      ctx.arc(-20, -12, 2.5, 0, Math.PI * 2);
      ctx.fill();
      ctx.beginPath();
      ctx.arc(-20, 12, 2.5, 0, Math.PI * 2);
      ctx.fill();
      // Eye shine
      ctx.fillStyle = '#fff';
      ctx.beginPath();
      ctx.arc(-21, -13, 1, 0, Math.PI * 2);
      ctx.fill();
      ctx.beginPath();
      ctx.arc(-21, 11, 1, 0, Math.PI * 2);
      ctx.fill();

      // Barbels (sawshark whiskers)
      ctx.strokeStyle = '#00aadd';
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(-5, -8);
      ctx.quadraticCurveTo(10, -15, 20, -12);
      ctx.stroke();
      ctx.beginPath();
      ctx.moveTo(-5, 8);
      ctx.quadraticCurveTo(10, 15, 20, 12);
      ctx.stroke();

      // Gills
      ctx.strokeStyle = '#006699';
      ctx.lineWidth = 2;
      for (let i = 0; i < 3; i++) {
        ctx.beginPath();
        ctx.moveTo(-35 + i * 5, -8);
        ctx.lineTo(-35 + i * 5, 8);
        ctx.stroke();
      }

      // Dorsal fin
      ctx.fillStyle = '#0088cc';
      ctx.shadowColor = '#00ccff';
      ctx.shadowBlur = 10;
      ctx.beginPath();
      ctx.moveTo(-10, -22);
      ctx.lineTo(-30, -25);
      ctx.lineTo(-18, -38);
      ctx.closePath();
      ctx.fill();

      ctx.restore();
      ctx.shadowBlur = 0;
    }

    function tryGrabShape() {
      const clawTip = getClawTipPos();

      for (let i = shapes.length - 1; i >= 0; i--) {
        const shape = shapes[i];
        const dx = shape.x - clawTip.x;
        const dy = shape.y - clawTip.y;
        const dist = Math.sqrt(dx * dx + dy * dy);

        // Only grab if shape is near the claw tip
        if (dist < shape.size + 15) {
          robotArm.grabbedShape = shape;
          robotArm.clawOpen = false;

          // Giraffe farts when grabbed!
          if (shape.type === 'giraffe') {
            playGiraffeFart();
            spawnFartCloud(shape.x, shape.y + shape.size * 0.5);
          }
          return;
        }
      }
    }

    function releaseShape() {
      if (robotArm.grabbedShape) {
        // Apply throwing velocity
        robotArm.grabbedShape.vx = robotArm.velocityX * 2;
        robotArm.grabbedShape.vy = robotArm.velocityY * 2;
        robotArm.grabbedShape = null;
      }
      robotArm.clawOpen = true;
    }

    // Input handling
    function getEventPos(e) {
      const rect = canvas.getBoundingClientRect();
      if (e.touches) {
        return {
          x: e.touches[0].clientX - rect.left,
          y: e.touches[0].clientY - rect.top
        };
      }
      return {
        x: e.clientX - rect.left,
        y: e.clientY - rect.top
      };
    }

    let isDrawing = false;
    let lastSpawnTime = 0;

    canvas.addEventListener('mousedown', (e) => {
      const pos = getEventPos(e);
      if (selectedShape === 'grab') {
        tryGrabShape();
      } else {
        isDrawing = true;
        spawnShape(pos.x, pos.y);
      }
    });

    canvas.addEventListener('mousemove', (e) => {
      const pos = getEventPos(e);
      robotArm.targetX = pos.x;
      robotArm.targetY = pos.y;

      if (selectedShape !== 'grab' && isDrawing && Date.now() - lastSpawnTime > 50) {
        spawnShape(pos.x, pos.y);
        lastSpawnTime = Date.now();
      }
    });

    canvas.addEventListener('mouseup', () => {
      isDrawing = false;
      if (selectedShape === 'grab') {
        releaseShape();
      }
    });
    canvas.addEventListener('mouseleave', () => isDrawing = false);

    canvas.addEventListener('touchstart', (e) => {
      e.preventDefault();
      const pos = getEventPos(e);
      robotArm.targetX = pos.x;
      robotArm.targetY = pos.y;

      if (selectedShape === 'grab') {
        tryGrabShape();
      } else {
        isDrawing = true;
        spawnShape(pos.x, pos.y);
      }
    });

    canvas.addEventListener('touchmove', (e) => {
      e.preventDefault();
      const pos = getEventPos(e);
      robotArm.targetX = pos.x;
      robotArm.targetY = pos.y;

      if (selectedShape !== 'grab' && isDrawing && Date.now() - lastSpawnTime > 50) {
        spawnShape(pos.x, pos.y);
        lastSpawnTime = Date.now();
      }
    });

    canvas.addEventListener('touchend', () => {
      isDrawing = false;
      if (selectedShape === 'grab') {
        releaseShape();
      }
    });

    function gameLoop() {
      // Clear with trail effect
      ctx.fillStyle = 'rgba(10, 10, 18, 0.3)';
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      // Update robot arm
      if (selectedShape === 'grab') {
        updateRobotArm();
      }

      // Update physics (skip grabbed shape)
      shapes.forEach(shape => {
        if (shape !== robotArm.grabbedShape) {
          shape.update();
        }
      });

      // Check collisions
      for (let i = 0; i < shapes.length; i++) {
        for (let j = i + 1; j < shapes.length; j++) {
          if (shapes[i] !== robotArm.grabbedShape && shapes[j] !== robotArm.grabbedShape) {
            shapes[i].checkCollision(shapes[j]);
          }
        }
      }

      // Draw shapes
      shapes.forEach(shape => shape.draw());

      // Update and draw fart particles
      updateFartParticles();
      drawFartParticles();

      // Draw robot arm when grab tool selected
      if (selectedShape === 'grab') {
        drawRobotArm();
      }

      // Draw ground line
      ctx.strokeStyle = '#333344';
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(0, canvas.height - 1);
      ctx.lineTo(canvas.width, canvas.height - 1);
      ctx.stroke();

      requestAnimationFrame(gameLoop);
    }

    // Initialize robot arm target
    robotArm.targetX = canvas.width / 2;
    robotArm.targetY = canvas.height / 2;

    gameLoop();
  </script>
</body>
</html>
