<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Sloppy Collab — Real-Time Co-Authoring</title>
<link rel="icon" href="https://emojicdn.elk.sh/✍️">
<meta property="og:title" content="Sloppy Collab">
<meta property="og:description" content="Write together in real-time. Live cursors, shared documents, instant sync.">
<meta property="og:url" content="https://sloppy.live/sloppy-collab">
<meta property="og:image" content="https://image.pollinations.ai/prompt/two%20glowing%20cursors%20editing%20same%20document%20dark%20background%20neon%20text%20lines%20collaborative%20writing?width=1200&height=630&nologo=true&referrer=sloppy.live">
<link href="https://fonts.googleapis.com/css2?family=Space+Grotesk:wght@300;500;700&family=Source+Code+Pro:wght@300;400;500&display=swap" rel="stylesheet">
<style>
*{margin:0;padding:0;box-sizing:border-box}
:root{
  --bg:#08090e;--surface:#0e1017;--surface2:#14161f;--border:#1c1e2c;--border-hi:#2c2e44;
  --text:#c4c8d8;--dim:#4e5270;--accent:#6366f1;--accent2:#818cf8;
  --green:#10b981;--amber:#f59e0b;--rose:#f43f5e;--sky:#38bdf8;
}
body{background:var(--bg);color:var(--text);font-family:'Source Code Pro',monospace;min-height:100vh;display:flex;flex-direction:column}

/* Layout */
.layout{display:flex;flex:1;overflow:hidden;max-height:100vh}
.sidebar{width:260px;background:var(--surface);border-right:1px solid var(--border);display:flex;flex-direction:column;flex-shrink:0}
.editor-area{flex:1;display:flex;flex-direction:column;min-width:0}

/* Sidebar */
.side-hdr{padding:14px 16px;border-bottom:1px solid var(--border)}
.side-hdr h1{font-family:'Space Grotesk',sans-serif;font-weight:700;font-size:1.2rem;
  background:linear-gradient(135deg,var(--accent2),var(--green));-webkit-background-clip:text;-webkit-text-fill-color:transparent}
.side-hdr .sub{font-size:.55rem;color:var(--dim);letter-spacing:.1em;text-transform:uppercase;margin-top:2px}
.doc-list{flex:1;overflow-y:auto;padding:6px}
.doc-item{display:flex;align-items:center;gap:8px;padding:8px 10px;border-radius:6px;cursor:pointer;
  transition:background .15s;margin-bottom:1px;font-size:.75rem}
.doc-item:hover{background:var(--surface2)}
.doc-item.active{background:var(--surface2);border-left:3px solid var(--accent)}
.doc-item .title{flex:1;white-space:nowrap;overflow:hidden;text-overflow:ellipsis;font-family:'Space Grotesk',sans-serif;font-weight:500}
.doc-item .meta{font-size:.5rem;color:var(--dim)}
.new-doc-btn{margin:8px;padding:8px;font-family:'Space Grotesk',sans-serif;font-weight:700;font-size:.7rem;
  border:1px dashed var(--border);border-radius:6px;background:transparent;color:var(--dim);cursor:pointer;
  transition:.2s;text-align:center}
.new-doc-btn:hover{border-color:var(--accent);color:var(--accent)}

/* Toolbar */
.toolbar{display:flex;align-items:center;gap:8px;padding:8px 16px;border-bottom:1px solid var(--border);background:var(--surface);flex-wrap:wrap}
.toolbar .doc-title-input{font-family:'Space Grotesk',sans-serif;font-weight:700;font-size:1rem;
  background:transparent;border:none;color:var(--text);outline:none;flex:1;min-width:120px}
.toolbar .doc-title-input::placeholder{color:var(--dim)}
.presence{display:flex;gap:-4px;align-items:center}
.presence-dot{width:24px;height:24px;border-radius:6px;display:flex;align-items:center;justify-content:center;
  font-size:.6rem;font-weight:700;color:#fff;margin-left:-6px;border:2px solid var(--surface);position:relative}
.presence-dot:first-child{margin-left:0}
.presence-count{font-size:.6rem;color:var(--dim);margin-left:4px}
.save-indicator{font-size:.55rem;color:var(--dim);margin-left:auto;display:flex;align-items:center;gap:4px}
.save-indicator .dot{width:6px;height:6px;border-radius:50%}
.save-indicator .dot.saved{background:var(--green)}
.save-indicator .dot.saving{background:var(--amber);animation:pulse-save 1s infinite}
.save-indicator .dot.unsaved{background:var(--rose)}
@keyframes pulse-save{0%,100%{opacity:1}50%{opacity:.4}}

.tb-btn{padding:4px 10px;font-size:.6rem;border:1px solid var(--border);border-radius:4px;
  background:transparent;color:var(--dim);cursor:pointer;font-family:'Source Code Pro',monospace;transition:.15s}
.tb-btn:hover{border-color:var(--accent);color:var(--accent)}

/* Editor */
.editor-wrap{flex:1;position:relative;overflow:hidden}
.editor{width:100%;height:100%;background:var(--bg);border:none;color:var(--text);
  font-family:'Source Code Pro',monospace;font-size:.85rem;line-height:1.7;padding:20px 24px;
  resize:none;outline:none;overflow-y:auto;tab-size:2}
.editor::placeholder{color:var(--dim)}

/* Remote cursors overlay */
.cursors-layer{position:absolute;inset:0;pointer-events:none;overflow:hidden}
.remote-cursor{position:absolute;pointer-events:none;transition:left .08s linear,top .08s linear;z-index:5}
.remote-cursor .caret{width:2px;height:18px;border-radius:1px;animation:blink-cursor 1s step-end infinite}
@keyframes blink-cursor{50%{opacity:.3}}
.remote-cursor .label{position:absolute;top:-18px;left:0;font-size:.5rem;padding:1px 5px;border-radius:3px;
  color:#fff;white-space:nowrap;font-family:'Space Grotesk',sans-serif;font-weight:500}

/* Status bar */
.status-bar{display:flex;align-items:center;gap:12px;padding:4px 16px;border-top:1px solid var(--border);
  background:var(--surface);font-size:.55rem;color:var(--dim)}

/* Empty state */
.empty-editor{flex:1;display:flex;align-items:center;justify-content:center;color:var(--dim);font-size:.8rem;text-align:center;padding:20px}

/* Mobile */
.mobile-back{display:none;padding:4px 8px;font-size:.65rem;border:1px solid var(--border);border-radius:4px;
  background:transparent;color:var(--dim);cursor:pointer;font-family:'Source Code Pro',monospace}
@media(max-width:700px){
  .sidebar{position:absolute;inset:0;width:100%;z-index:10;transition:transform .2s}
  .sidebar.hidden{transform:translateX(-100%)}
  .mobile-back{display:block}
}
</style>
</head>
<body>
<div class="layout">
  <div class="sidebar" id="sidebar">
    <div class="side-hdr">
      <h1>Collab</h1>
      <div class="sub">real-time co-authoring</div>
    </div>
    <div class="doc-list" id="doc-list">
      <div style="padding:16px;font-size:.7rem;color:var(--dim)">Loading...</div>
    </div>
    <button class="new-doc-btn" onclick="createDoc()">+ New Document</button>
  </div>

  <div class="editor-area" id="editor-area">
    <div class="empty-editor" id="empty-state">Select a document or create one to start writing together</div>
  </div>
</div>

<script type="module">
import { createBrowserClient } from "https://cdn.jsdelivr.net/npm/@supabase/ssr@0.7.0/+esm";

const SUPABASE_URL = 'https://yjyxteqzhhmtrgcaekgz.supabase.co';
const SUPABASE_ANON_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InlqeXh0ZXF6aGhtdHJnY2Fla2d6Iiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTczNTg3NDIsImV4cCI6MjA3MjkzNDc0Mn0.G8SRde7IN2QFW1EnASM8IS32IUYR2eenCCjdDdioiBU';

const supabase = createBrowserClient(SUPABASE_URL, SUPABASE_ANON_KEY, {
  cookieOptions: {
    name: 'sb-auth-token',
    domain: location.hostname.includes('sloppy.live') ? '.sloppy.live' : location.hostname,
    path: '/', sameSite: 'lax'
  }
});

const ESC = s => String(s||'').replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;');
const COLORS = ['#6366f1','#10b981','#f59e0b','#f43f5e','#38bdf8','#a855f7','#ec4899','#14b8a6'];
const MAX_CONTENT = 50000;

// ── State ──
let currentUser = null;
let profile = null;
let myColor = COLORS[0];
let docs = [];
let activeDocId = null;
let activeDoc = null;
let channel = null;
let saveTimeout = null;
let saveState = 'saved'; // saved, saving, unsaved
let remoteCursors = {}; // { uniqueKey: { username, color, pos } }
let isOwner = false;
let suppressBroadcast = false;
let lastBroadcastContent = '';

// ── Init ──
async function init() {
  const { data: { session } } = await supabase.auth.getSession();
  if (!session?.user) {
    document.getElementById('doc-list').innerHTML = '<div style="padding:16px;font-size:.7rem;color:var(--dim)">Sign in on sloppy.live to collaborate.</div>';
    return;
  }
  currentUser = session.user;
  myColor = COLORS[Math.abs(hashStr(currentUser.id)) % COLORS.length];

  const { data: prof } = await supabase.from('sloppygram_profiles').select('username,avatar').eq('user_id', currentUser.id).single();
  profile = prof || { username: 'anon' };

  await loadDocs();

  // Check URL for doc id
  const params = new URLSearchParams(location.search);
  const docId = params.get('doc');
  if (docId) openDoc(parseInt(docId));
}

function hashStr(s) {
  let h = 0;
  for (let i = 0; i < s.length; i++) h = ((h << 5) - h + s.charCodeAt(i)) | 0;
  return h;
}

// ── Load documents ──
async function loadDocs() {
  const { data } = await supabase.from('sloppygram_collab_documents')
    .select('id,title,created_by_username,last_edited_at,is_public,user_id')
    .eq('is_public', true)
    .order('last_edited_at', { ascending: false, nullsFirst: false })
    .limit(50);
  docs = data || [];
  renderDocList();
}

function renderDocList() {
  const el = document.getElementById('doc-list');
  if (docs.length === 0) {
    el.innerHTML = '<div style="padding:16px;font-size:.7rem;color:var(--dim)">No documents yet. Create one!</div>';
    return;
  }
  el.innerHTML = docs.map(d => {
    const active = d.id === activeDocId;
    const time = d.last_edited_at ? timeAgo(d.last_edited_at) : 'new';
    return `<div class="doc-item${active ? ' active' : ''}" onclick="openDoc(${d.id})">
      <div>
        <div class="title">${ESC(d.title || 'Untitled')}</div>
        <div class="meta">by ${ESC(d.created_by_username)} · ${time}</div>
      </div>
    </div>`;
  }).join('');
}

// ── Create document ──
window.createDoc = async function() {
  if (!currentUser || !profile) return;
  const { data, error } = await supabase.from('sloppygram_collab_documents').insert({
    title: 'Untitled',
    content: '',
    created_by_username: profile.username,
    last_edited_by: profile.username,
    last_edited_at: new Date().toISOString(),
    is_public: true,
    user_id: currentUser.id
  }).select().single();

  if (error || !data) { console.error('Create doc failed', error); return; }
  await loadDocs();
  openDoc(data.id);
};

// ── Open document ──
window.openDoc = async function(docId) {
  // Cleanup previous
  if (channel) { supabase.removeChannel(channel); channel = null; }
  remoteCursors = {};

  activeDocId = docId;
  renderDocList();

  // Hide sidebar on mobile
  document.getElementById('sidebar').classList.add('hidden');

  // Load full document
  const { data: doc } = await supabase.from('sloppygram_collab_documents')
    .select('*').eq('id', docId).single();

  if (!doc) {
    document.getElementById('editor-area').innerHTML = '<div class="empty-editor">Document not found</div>';
    return;
  }
  activeDoc = doc;
  isOwner = doc.user_id === currentUser.id;
  lastBroadcastContent = doc.content || '';

  // Render editor
  document.getElementById('editor-area').innerHTML = `
    <div class="toolbar">
      <button class="mobile-back" onclick="showSidebar()">←</button>
      <input class="doc-title-input" id="title-input" value="${ESC(doc.title || '')}" placeholder="Document title..." maxlength="200"
        ${isOwner ? '' : 'readonly'}>
      <div class="presence" id="presence"></div>
      <div class="save-indicator" id="save-ind"><div class="dot saved"></div> <span>Saved</span></div>
      <button class="tb-btn" onclick="copyLink()">Share</button>
      ${isOwner ? '<button class="tb-btn" onclick="deleteDoc()">Delete</button>' : ''}
    </div>
    <div class="editor-wrap">
      <div class="cursors-layer" id="cursors-layer"></div>
      <textarea class="editor" id="editor" placeholder="Start writing...">${ESC(doc.content || '')}</textarea>
    </div>
    <div class="status-bar">
      <span id="char-count">${(doc.content||'').length} chars</span>
      <span id="line-count">${(doc.content||'').split('\n').length} lines</span>
      <span id="cursor-pos">Ln 1, Col 1</span>
      <span style="margin-left:auto" id="editors-label">Only you</span>
    </div>`;

  setupEditor();
  setupChannel(docId);
};

// ── Editor event wiring ──
function setupEditor() {
  const editor = document.getElementById('editor');
  const titleInput = document.getElementById('title-input');
  if (!editor) return;

  // Text input → broadcast + schedule save
  editor.addEventListener('input', () => {
    const content = editor.value;
    if (content.length > MAX_CONTENT) {
      editor.value = content.slice(0, MAX_CONTENT);
    }
    updateCounts();
    setSaveState('unsaved');
    scheduleSave();

    // Broadcast content change
    if (!suppressBroadcast && channel) {
      const now = Date.now();
      // Throttle to every 100ms
      if (!editor._lastBroadcast || now - editor._lastBroadcast > 100) {
        editor._lastBroadcast = now;
        channel.send({
          type: 'broadcast', event: 'content',
          payload: { content: editor.value, username: profile.username, cursorPos: editor.selectionStart }
        });
        lastBroadcastContent = editor.value;
      }
    }
  });

  // Cursor position tracking
  editor.addEventListener('click', broadcastCursor);
  editor.addEventListener('keyup', broadcastCursor);
  editor.addEventListener('select', broadcastCursor);

  // Title change
  if (titleInput && isOwner) {
    titleInput.addEventListener('input', () => {
      setSaveState('unsaved');
      scheduleSave();
      if (channel) {
        channel.send({ type: 'broadcast', event: 'title', payload: { title: titleInput.value } });
      }
    });
  }

  // Tab key support
  editor.addEventListener('keydown', e => {
    if (e.key === 'Tab') {
      e.preventDefault();
      const start = editor.selectionStart;
      const end = editor.selectionEnd;
      editor.value = editor.value.substring(0, start) + '  ' + editor.value.substring(end);
      editor.selectionStart = editor.selectionEnd = start + 2;
      editor.dispatchEvent(new Event('input'));
    }
  });

  updateCounts();
}

function broadcastCursor() {
  const editor = document.getElementById('editor');
  if (!editor || !channel) return;
  const pos = editor.selectionStart;
  // Get line and column
  const before = editor.value.substring(0, pos);
  const line = before.split('\n').length;
  const col = pos - before.lastIndexOf('\n');

  document.getElementById('cursor-pos').textContent = `Ln ${line}, Col ${col}`;

  channel.send({
    type: 'broadcast', event: 'cursor',
    payload: { username: profile.username, color: myColor, pos, line, col }
  });
}

function updateCounts() {
  const editor = document.getElementById('editor');
  if (!editor) return;
  const text = editor.value;
  const cc = document.getElementById('char-count');
  const lc = document.getElementById('line-count');
  if (cc) cc.textContent = text.length + ' chars';
  if (lc) lc.textContent = text.split('\n').length + ' lines';
}

// ── Save (debounced, only owner can persist) ──
function scheduleSave() {
  clearTimeout(saveTimeout);
  saveTimeout = setTimeout(saveDoc, 1500);
}

async function saveDoc() {
  if (!activeDocId || !activeDoc) return;
  const editor = document.getElementById('editor');
  const titleInput = document.getElementById('title-input');
  if (!editor) return;

  // Anyone can save if they're the owner
  if (!isOwner) {
    // Non-owners broadcast changes but can't persist to DB
    setSaveState('saved');
    return;
  }

  setSaveState('saving');
  const { error } = await supabase.from('sloppygram_collab_documents')
    .update({
      content: editor.value,
      title: titleInput?.value || activeDoc.title,
      last_edited_by: profile.username,
      last_edited_at: new Date().toISOString()
    }).eq('id', activeDocId);

  setSaveState(error ? 'unsaved' : 'saved');
  if (!error) {
    activeDoc.content = editor.value;
    activeDoc.title = titleInput?.value || activeDoc.title;
  }
}

function setSaveState(state) {
  saveState = state;
  const el = document.getElementById('save-ind');
  if (!el) return;
  const labels = { saved: 'Saved', saving: 'Saving...', unsaved: 'Unsaved' };
  el.innerHTML = `<div class="dot ${state}"></div> <span>${labels[state]}</span>`;
}

// ── Real-time channel ──
function setupChannel(docId) {
  channel = supabase.channel('collab-doc-' + docId, {
    config: { broadcast: { self: false } }
  });

  // Remote content changes
  channel.on('broadcast', { event: 'content' }, ({ payload }) => {
    const editor = document.getElementById('editor');
    if (!editor) return;

    // Preserve local cursor position relative to content change
    const oldPos = editor.selectionStart;
    const oldLen = editor.value.length;
    suppressBroadcast = true;
    editor.value = payload.content;
    // Attempt to restore cursor intelligently
    const newLen = editor.value.length;
    const delta = newLen - oldLen;
    const newPos = Math.max(0, Math.min(oldPos + (payload.cursorPos <= oldPos ? delta : 0), newLen));
    editor.selectionStart = editor.selectionEnd = newPos;
    suppressBroadcast = false;
    lastBroadcastContent = payload.content;
    updateCounts();

    // If we're the owner, schedule save of remote changes too
    if (isOwner) {
      setSaveState('unsaved');
      scheduleSave();
    }
  });

  // Remote title changes
  channel.on('broadcast', { event: 'title' }, ({ payload }) => {
    const titleInput = document.getElementById('title-input');
    if (titleInput && !isOwner) titleInput.value = payload.title;
    if (isOwner) {
      // Owner saves title changes from others
      setSaveState('unsaved');
      scheduleSave();
    }
  });

  // Remote cursor positions
  channel.on('broadcast', { event: 'cursor' }, ({ payload }) => {
    remoteCursors[payload.username] = payload;
    renderRemoteCursors();
  });

  // Presence
  channel.on('presence', { event: 'sync' }, () => {
    const state = channel.presenceState();
    renderPresence(state);
  });

  channel.subscribe(async (status) => {
    if (status === 'SUBSCRIBED') {
      await channel.track({ username: profile.username, color: myColor });
    }
  });
}

function renderPresence(state) {
  const users = [];
  for (const key of Object.keys(state)) {
    const presences = state[key];
    if (presences && presences.length > 0) users.push(presences[0]);
  }

  const el = document.getElementById('presence');
  const label = document.getElementById('editors-label');
  if (el) {
    el.innerHTML = users.slice(0, 6).map(u => {
      const initial = (u.username || '?')[0].toUpperCase();
      return `<div class="presence-dot" style="background:${u.color}" title="${ESC(u.username)}">${initial}</div>`;
    }).join('') + (users.length > 6 ? `<span class="presence-count">+${users.length - 6}</span>` : '');
  }
  if (label) {
    if (users.length <= 1) label.textContent = 'Only you';
    else label.textContent = users.length + ' editors active';
  }
}

function renderRemoteCursors() {
  const layer = document.getElementById('cursors-layer');
  const editor = document.getElementById('editor');
  if (!layer || !editor) return;

  // Approximate cursor position from character offset
  // Using a measurement approach based on textarea geometry
  const style = getComputedStyle(editor);
  const lineHeight = parseFloat(style.lineHeight) || 22;
  const charWidth = 8.5; // approximate for monospace
  const padLeft = parseFloat(style.paddingLeft) || 24;
  const padTop = parseFloat(style.paddingTop) || 20;
  const editorWidth = editor.clientWidth - padLeft * 2;
  const charsPerLine = Math.floor(editorWidth / charWidth) || 80;

  let html = '';
  for (const [username, cursor] of Object.entries(remoteCursors)) {
    if (username === profile?.username) continue;
    // Use line/col from broadcast
    const top = padTop + (cursor.line - 1) * lineHeight - editor.scrollTop;
    const left = padLeft + (cursor.col - 1) * charWidth;

    if (top < -20 || top > editor.clientHeight + 20) continue;

    html += `<div class="remote-cursor" style="left:${left}px;top:${top}px">
      <div class="caret" style="background:${cursor.color}"></div>
      <div class="label" style="background:${cursor.color}">${ESC(username)}</div>
    </div>`;
  }
  layer.innerHTML = html;
}

// Rerender cursors on scroll
setInterval(() => {
  const layer = document.getElementById('cursors-layer');
  if (layer && Object.keys(remoteCursors).length > 0) renderRemoteCursors();
}, 200);

// ── Actions ──
window.copyLink = function() {
  const url = location.origin + location.pathname + '?doc=' + activeDocId;
  navigator.clipboard.writeText(url).then(() => {
    const el = document.getElementById('save-ind');
    if (el) { el.innerHTML = '<span style="color:var(--green)">Link copied!</span>'; setTimeout(() => setSaveState(saveState), 1500); }
  }).catch(() => {});
};

window.deleteDoc = async function() {
  if (!isOwner || !activeDocId) return;
  await supabase.from('sloppygram_collab_documents').delete().eq('id', activeDocId).eq('user_id', currentUser.id);
  if (channel) { supabase.removeChannel(channel); channel = null; }
  activeDocId = null;
  activeDoc = null;
  document.getElementById('editor-area').innerHTML = '<div class="empty-editor">Document deleted. Select or create another.</div>';
  await loadDocs();
};

window.showSidebar = function() { document.getElementById('sidebar').classList.remove('hidden'); };

function timeAgo(ts) {
  const s = Math.floor((Date.now() - new Date(ts).getTime()) / 1000);
  if (s < 60) return 'now';
  if (s < 3600) return Math.floor(s/60) + 'm';
  if (s < 86400) return Math.floor(s/3600) + 'h';
  return Math.floor(s/86400) + 'd';
}

init();
</script>
<script src="/sloppy-header/sloppy-bar.js" data-position="bottom" data-minimized="true"></script>
</body>
</html>
