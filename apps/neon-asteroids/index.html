<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
  <title>Neon Asteroids</title>
  <link rel="icon" href="https://emojicdn.elk.sh/☄️">
  <meta property="og:title" content="Neon Asteroids">
  <meta property="og:description" content="Classic asteroids with glowing neon explosions">
  <meta property="og:url" content="https://sloppy.live/neon-asteroids">
  <meta property="og:image" content="https://emojicdn.elk.sh/☄️?style=apple&size=512">
  <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&display=swap" rel="stylesheet">
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      background: #000;
      overflow: hidden;
      font-family: 'Orbitron', sans-serif;
    }
    canvas { display: block; }
    .ui {
      position: fixed;
      top: 15px;
      left: 15px;
      right: 15px;
      display: flex;
      justify-content: space-between;
      pointer-events: none;
      z-index: 100;
    }
    .score {
      color: #0ff;
      font-size: 28px;
      font-weight: 900;
      text-shadow: 0 0 10px #0ff, 0 0 20px #0ff;
    }
    .lives {
      display: flex;
      gap: 8px;
    }
    .life {
      width: 0;
      height: 0;
      border-left: 8px solid transparent;
      border-right: 8px solid transparent;
      border-bottom: 20px solid #0ff;
      filter: drop-shadow(0 0 5px #0ff);
    }
    .level {
      color: #f0f;
      font-size: 16px;
      text-shadow: 0 0 10px #f0f;
    }
    .game-over {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      text-align: center;
      display: none;
      z-index: 200;
    }
    .game-over h1 {
      font-size: 48px;
      color: #f00;
      text-shadow: 0 0 20px #f00, 0 0 40px #f00;
      margin-bottom: 20px;
    }
    .game-over p {
      color: #0ff;
      font-size: 24px;
      text-shadow: 0 0 10px #0ff;
      margin-bottom: 30px;
    }
    .btn {
      background: transparent;
      border: 2px solid #0ff;
      color: #0ff;
      padding: 15px 40px;
      font-family: 'Orbitron', sans-serif;
      font-size: 18px;
      cursor: pointer;
      text-shadow: 0 0 10px #0ff;
      box-shadow: 0 0 20px rgba(0,255,255,0.3);
      transition: all 0.3s;
    }
    .btn:hover {
      background: rgba(0,255,255,0.2);
      box-shadow: 0 0 40px rgba(0,255,255,0.5);
    }
    .start-screen {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      text-align: center;
      z-index: 200;
    }
    .start-screen h1 {
      font-size: 52px;
      color: #0ff;
      text-shadow: 0 0 20px #0ff, 0 0 40px #0ff, 0 0 60px #0ff;
      margin-bottom: 10px;
      letter-spacing: 5px;
    }
    .start-screen p {
      color: #f0f;
      font-size: 14px;
      text-shadow: 0 0 10px #f0f;
      margin-bottom: 40px;
    }
    .controls-hint {
      position: fixed;
      bottom: 15px;
      left: 50%;
      transform: translateX(-50%);
      color: rgba(255,255,255,0.4);
      font-size: 11px;
      z-index: 100;
    }
    .mobile-controls {
      position: fixed;
      bottom: 20px;
      left: 0;
      right: 0;
      display: none;
      justify-content: space-between;
      padding: 0 20px;
      z-index: 100;
    }
    .touch-btn {
      width: 65px;
      height: 65px;
      border-radius: 50%;
      background: rgba(0,255,255,0.15);
      border: 2px solid rgba(0,255,255,0.4);
      color: #0ff;
      font-size: 22px;
      display: flex;
      align-items: center;
      justify-content: center;
      user-select: none;
      -webkit-user-select: none;
    }
    .touch-btn.fire {
      background: rgba(255,0,255,0.2);
      border-color: rgba(255,0,255,0.5);
      color: #f0f;
      width: 75px;
      height: 75px;
    }
    .touch-group { display: flex; gap: 10px; }
    @media (max-width: 768px) {
      .mobile-controls { display: flex; }
      .controls-hint { display: none; }
      .score { font-size: 20px; }
    }
    .backlink {
      position: fixed;
      bottom: 15px;
      left: 15px;
      color: rgba(255,255,255,0.3);
      font-size: 10px;
      text-decoration: none;
      z-index: 50;
    }
  </style>
</head>
<body>
  <div class="ui">
    <div class="score" id="score">0</div>
    <div class="level" id="level">LEVEL 1</div>
    <div class="lives" id="lives"></div>
  </div>

  <canvas id="game"></canvas>

  <div class="start-screen" id="startScreen">
    <h1>NEON ASTEROIDS</h1>
    <p>DESTROY ALL ASTEROIDS • AVOID COLLISIONS</p>
    <button class="btn" id="startBtn">START GAME</button>
  </div>

  <div class="game-over" id="gameOver">
    <h1>GAME OVER</h1>
    <p>SCORE: <span id="finalScore">0</span></p>
    <button class="btn" id="restartBtn">PLAY AGAIN</button>
  </div>

  <div class="controls-hint">WASD/ARROWS to move • SPACE to fire</div>

  <div class="mobile-controls" id="mobileControls">
    <div class="touch-group">
      <button class="touch-btn" id="touchLeft">◀</button>
      <button class="touch-btn" id="touchRight">▶</button>
    </div>
    <div class="touch-group">
      <button class="touch-btn" id="touchThrust">▲</button>
      <button class="touch-btn fire" id="touchFire">●</button>
    </div>
  </div>

  <a href="https://sloppy.live" class="backlink">sloppy.live</a>

  <script>
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');

    function resize() {
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
    }
    resize();
    window.addEventListener('resize', resize);

    // Game state
    let gameRunning = false;
    let score = 0;
    let level = 1;
    let lives = 3;

    // Input
    const keys = {};

    // Colors
    const COLORS = {
      ship: '#00ffff',
      bullet: '#ffffff',
      asteroid: ['#ff00ff', '#00ffff', '#00ff00', '#ffff00', '#ff8800'],
      particle: ['#ff00ff', '#00ffff', '#00ff00', '#ffff00', '#ff8800', '#ffffff']
    };

    // Ship
    let ship = null;

    class Ship {
      constructor() {
        this.x = canvas.width / 2;
        this.y = canvas.height / 2;
        this.angle = -Math.PI / 2;
        this.vx = 0;
        this.vy = 0;
        this.radius = 15;
        this.rotSpeed = 0.1;
        this.thrust = 0.15;
        this.friction = 0.99;
        this.invincible = 0;
      }

      update() {
        if (keys['ArrowLeft'] || keys['a']) this.angle -= this.rotSpeed;
        if (keys['ArrowRight'] || keys['d']) this.angle += this.rotSpeed;
        
        if (keys['ArrowUp'] || keys['w']) {
          this.vx += Math.cos(this.angle) * this.thrust;
          this.vy += Math.sin(this.angle) * this.thrust;
          // Thrust particles
          if (Math.random() > 0.5) {
            const px = this.x - Math.cos(this.angle) * 20;
            const py = this.y - Math.sin(this.angle) * 20;
            particles.push(new Particle(px, py, '#ff8800', 2, 20));
          }
        }

        this.vx *= this.friction;
        this.vy *= this.friction;
        this.x += this.vx;
        this.y += this.vy;

        // Wrap around
        if (this.x < 0) this.x = canvas.width;
        if (this.x > canvas.width) this.x = 0;
        if (this.y < 0) this.y = canvas.height;
        if (this.y > canvas.height) this.y = 0;

        if (this.invincible > 0) this.invincible--;
      }

      draw() {
        if (this.invincible > 0 && Math.floor(this.invincible / 5) % 2) return;

        ctx.save();
        ctx.translate(this.x, this.y);
        ctx.rotate(this.angle + Math.PI / 2);

        ctx.strokeStyle = COLORS.ship;
        ctx.lineWidth = 2;
        ctx.shadowColor = COLORS.ship;
        ctx.shadowBlur = 15;

        ctx.beginPath();
        ctx.moveTo(0, -this.radius);
        ctx.lineTo(this.radius * 0.7, this.radius);
        ctx.lineTo(0, this.radius * 0.6);
        ctx.lineTo(-this.radius * 0.7, this.radius);
        ctx.closePath();
        ctx.stroke();

        ctx.shadowBlur = 0;
        ctx.restore();
      }
    }

    // Bullets
    let bullets = [];

    class Bullet {
      constructor(x, y, angle) {
        this.x = x;
        this.y = y;
        this.vx = Math.cos(angle) * 10;
        this.vy = Math.sin(angle) * 10;
        this.life = 60;
        this.radius = 3;
      }

      update() {
        this.x += this.vx;
        this.y += this.vy;
        this.life--;

        if (this.x < 0) this.x = canvas.width;
        if (this.x > canvas.width) this.x = 0;
        if (this.y < 0) this.y = canvas.height;
        if (this.y > canvas.height) this.y = 0;
      }

      draw() {
        ctx.fillStyle = COLORS.bullet;
        ctx.shadowColor = COLORS.bullet;
        ctx.shadowBlur = 10;
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
        ctx.fill();
        ctx.shadowBlur = 0;
      }
    }

    // Asteroids
    let asteroids = [];

    class Asteroid {
      constructor(x, y, size) {
        this.x = x || Math.random() * canvas.width;
        this.y = y || Math.random() * canvas.height;
        this.size = size || 3; // 3 = large, 2 = medium, 1 = small
        this.radius = this.size * 15 + 10;
        const speed = (4 - this.size) * 0.5 + Math.random() * 1.5;
        const angle = Math.random() * Math.PI * 2;
        this.vx = Math.cos(angle) * speed;
        this.vy = Math.sin(angle) * speed;
        this.rotation = 0;
        this.rotSpeed = (Math.random() - 0.5) * 0.05;
        this.color = COLORS.asteroid[Math.floor(Math.random() * COLORS.asteroid.length)];
        this.vertices = this.generateVertices();
      }

      generateVertices() {
        const verts = [];
        const numVerts = 8 + Math.floor(Math.random() * 5);
        for (let i = 0; i < numVerts; i++) {
          const angle = (i / numVerts) * Math.PI * 2;
          const dist = this.radius * (0.7 + Math.random() * 0.3);
          verts.push({ x: Math.cos(angle) * dist, y: Math.sin(angle) * dist });
        }
        return verts;
      }

      update() {
        this.x += this.vx;
        this.y += this.vy;
        this.rotation += this.rotSpeed;

        if (this.x < -this.radius) this.x = canvas.width + this.radius;
        if (this.x > canvas.width + this.radius) this.x = -this.radius;
        if (this.y < -this.radius) this.y = canvas.height + this.radius;
        if (this.y > canvas.height + this.radius) this.y = -this.radius;
      }

      draw() {
        ctx.save();
        ctx.translate(this.x, this.y);
        ctx.rotate(this.rotation);

        ctx.strokeStyle = this.color;
        ctx.lineWidth = 2;
        ctx.shadowColor = this.color;
        ctx.shadowBlur = 10;

        ctx.beginPath();
        ctx.moveTo(this.vertices[0].x, this.vertices[0].y);
        for (let i = 1; i < this.vertices.length; i++) {
          ctx.lineTo(this.vertices[i].x, this.vertices[i].y);
        }
        ctx.closePath();
        ctx.stroke();

        ctx.shadowBlur = 0;
        ctx.restore();
      }

      split() {
        if (this.size > 1) {
          for (let i = 0; i < 2; i++) {
            asteroids.push(new Asteroid(this.x, this.y, this.size - 1));
          }
        }
      }
    }

    // Particles
    let particles = [];

    class Particle {
      constructor(x, y, color, size = 3, life = 30) {
        this.x = x;
        this.y = y;
        this.color = color || COLORS.particle[Math.floor(Math.random() * COLORS.particle.length)];
        this.size = size;
        this.life = life;
        this.maxLife = life;
        const angle = Math.random() * Math.PI * 2;
        const speed = Math.random() * 4 + 1;
        this.vx = Math.cos(angle) * speed;
        this.vy = Math.sin(angle) * speed;
      }

      update() {
        this.x += this.vx;
        this.y += this.vy;
        this.vx *= 0.98;
        this.vy *= 0.98;
        this.life--;
      }

      draw() {
        const alpha = this.life / this.maxLife;
        ctx.fillStyle = this.color;
        ctx.globalAlpha = alpha;
        ctx.shadowColor = this.color;
        ctx.shadowBlur = 8;
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.size * alpha, 0, Math.PI * 2);
        ctx.fill();
        ctx.globalAlpha = 1;
        ctx.shadowBlur = 0;
      }
    }

    // Explosion effect
    function explode(x, y, color, count = 30, size = 4) {
      for (let i = 0; i < count; i++) {
        particles.push(new Particle(x, y, color, size, 40 + Math.random() * 20));
      }
    }

    // Spawn asteroids
    function spawnAsteroids(count) {
      for (let i = 0; i < count; i++) {
        let x, y;
        do {
          x = Math.random() * canvas.width;
          y = Math.random() * canvas.height;
        } while (ship && Math.hypot(x - ship.x, y - ship.y) < 150);
        asteroids.push(new Asteroid(x, y, 3));
      }
    }

    // Shooting
    let lastShot = 0;
    function shoot() {
      const now = Date.now();
      if (now - lastShot < 200) return;
      lastShot = now;
      
      const bx = ship.x + Math.cos(ship.angle) * ship.radius;
      const by = ship.y + Math.sin(ship.angle) * ship.radius;
      bullets.push(new Bullet(bx, by, ship.angle));
    }

    // Collision detection
    function circleCollision(a, b) {
      const dx = a.x - b.x;
      const dy = a.y - b.y;
      const dist = Math.sqrt(dx * dx + dy * dy);
      return dist < a.radius + b.radius;
    }

    // Update game
    function update() {
      if (!gameRunning) return;

      ship.update();
      
      bullets.forEach(b => b.update());
      bullets = bullets.filter(b => b.life > 0);

      asteroids.forEach(a => a.update());

      particles.forEach(p => p.update());
      particles = particles.filter(p => p.life > 0);

      // Bullet-asteroid collision
      for (let i = bullets.length - 1; i >= 0; i--) {
        for (let j = asteroids.length - 1; j >= 0; j--) {
          if (circleCollision(bullets[i], asteroids[j])) {
            explode(asteroids[j].x, asteroids[j].y, asteroids[j].color, 20 + asteroids[j].size * 10, asteroids[j].size + 2);
            score += (4 - asteroids[j].size) * 100;
            asteroids[j].split();
            asteroids.splice(j, 1);
            bullets.splice(i, 1);
            break;
          }
        }
      }

      // Ship-asteroid collision
      if (ship.invincible <= 0) {
        for (let i = asteroids.length - 1; i >= 0; i--) {
          if (circleCollision(ship, asteroids[i])) {
            explode(ship.x, ship.y, COLORS.ship, 40, 4);
            lives--;
            updateLives();
            
            if (lives <= 0) {
              gameOver();
            } else {
              ship.x = canvas.width / 2;
              ship.y = canvas.height / 2;
              ship.vx = 0;
              ship.vy = 0;
              ship.invincible = 180;
            }
            break;
          }
        }
      }

      // Next level
      if (asteroids.length === 0) {
        level++;
        document.getElementById('level').textContent = `LEVEL ${level}`;
        spawnAsteroids(2 + level);
      }

      document.getElementById('score').textContent = score;
    }

    // Draw game
    function draw() {
      // Clear with trail effect
      ctx.fillStyle = 'rgba(0, 0, 0, 0.2)';
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      // Stars (subtle)
      ctx.fillStyle = 'rgba(255,255,255,0.3)';
      for (let i = 0; i < 50; i++) {
        const x = (i * 137 + 50) % canvas.width;
        const y = (i * 97 + 30) % canvas.height;
        ctx.fillRect(x, y, 1, 1);
      }

      particles.forEach(p => p.draw());
      asteroids.forEach(a => a.draw());
      bullets.forEach(b => b.draw());
      if (ship && gameRunning) ship.draw();
    }

    // Game loop
    function gameLoop() {
      update();
      draw();
      requestAnimationFrame(gameLoop);
    }

    // Update lives display
    function updateLives() {
      const container = document.getElementById('lives');
      container.innerHTML = '';
      for (let i = 0; i < lives; i++) {
        const life = document.createElement('div');
        life.className = 'life';
        container.appendChild(life);
      }
    }

    // Start game
    function startGame() {
      gameRunning = true;
      score = 0;
      level = 1;
      lives = 3;
      ship = new Ship();
      bullets = [];
      asteroids = [];
      particles = [];
      
      document.getElementById('startScreen').style.display = 'none';
      document.getElementById('gameOver').style.display = 'none';
      document.getElementById('level').textContent = 'LEVEL 1';
      
      updateLives();
      spawnAsteroids(3);
    }

    // Game over
    function gameOver() {
      gameRunning = false;
      document.getElementById('finalScore').textContent = score;
      document.getElementById('gameOver').style.display = 'block';
    }

    // Input handlers
    document.addEventListener('keydown', e => {
      keys[e.key] = true;
      if (e.key === ' ' && gameRunning) {
        e.preventDefault();
        shoot();
      }
    });
    document.addEventListener('keyup', e => keys[e.key] = false);

    // Touch controls
    function setupTouch(id, key, isFire = false) {
      const btn = document.getElementById(id);
      if (!btn) return;
      
      btn.addEventListener('touchstart', e => {
        e.preventDefault();
        if (isFire) shoot();
        else keys[key] = true;
      }, { passive: false });
      
      btn.addEventListener('touchend', e => {
        e.preventDefault();
        if (!isFire) keys[key] = false;
      }, { passive: false });
    }

    setupTouch('touchLeft', 'ArrowLeft');
    setupTouch('touchRight', 'ArrowRight');
    setupTouch('touchThrust', 'ArrowUp');
    setupTouch('touchFire', '', true);

    // Auto-fire on hold
    let fireInterval;
    const fireBtn = document.getElementById('touchFire');
    if (fireBtn) {
      fireBtn.addEventListener('touchstart', e => {
        e.preventDefault();
        shoot();
        fireInterval = setInterval(shoot, 200);
      }, { passive: false });
      fireBtn.addEventListener('touchend', e => {
        e.preventDefault();
        clearInterval(fireInterval);
      }, { passive: false });
    }

    // Start/restart buttons
    document.getElementById('startBtn').addEventListener('click', startGame);
    document.getElementById('restartBtn').addEventListener('click', startGame);

    // Initialize
    updateLives();
    gameLoop();
  </script>
</body>
</html>
