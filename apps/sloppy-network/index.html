<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sloppy Network - Social Graph</title>
    <link rel="icon" href="https://emojicdn.elk.sh/üï∏Ô∏è">
    <meta property="og:title" content="Sloppy Network">
    <meta property="og:description" content="Live social graph of the sloppy.live community">
    <meta property="og:url" content="https://app.sloppy.live/sloppy-network">
    <meta property="og:image" content="https://emojicdn.elk.sh/üï∏Ô∏è?style=google">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link href="https://fonts.googleapis.com/css2?family=Newsreader:opsz,wght@6..72,200;6..72,400;6..72,700&family=Fira+Code:wght@300;400;500&display=swap" rel="stylesheet">
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        :root {
            --bg: #060610;
            --surface: #0c0c1a;
            --border: #1a1a30;
            --text: #c8c8d8;
            --text-dim: #606078;
            --link-color: rgba(80,120,200,0.25);
            --link-hover: rgba(120,160,240,0.5);
            --node-default: #5588cc;
            --highlight: #60a0ff;
        }
        body {
            background: var(--bg);
            color: var(--text);
            font-family: 'Fira Code', monospace;
            overflow: hidden;
            height: 100vh;
            width: 100vw;
        }
        canvas {
            display: block;
            position: absolute;
            top: 0; left: 0;
            cursor: grab;
        }
        canvas:active { cursor: grabbing; }

        /* HUD overlay */
        .hud-top {
            position: fixed;
            top: 16px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 10;
            text-align: center;
            pointer-events: none;
        }
        .hud-title {
            font-family: 'Newsreader', serif;
            font-weight: 700;
            font-size: clamp(1.6rem, 4vw, 2.4rem);
            color: var(--highlight);
            text-shadow: 0 0 30px rgba(96,160,255,0.3);
            letter-spacing: 1px;
        }
        .hud-sub {
            font-size: 0.65rem;
            color: var(--text-dim);
            margin-top: 2px;
            letter-spacing: 1px;
        }

        /* Stats bar */
        .stats-bar {
            position: fixed;
            top: 16px;
            right: 16px;
            z-index: 10;
            display: flex;
            flex-direction: column;
            gap: 6px;
            font-size: 0.65rem;
            color: var(--text-dim);
        }
        .stat-pill {
            background: rgba(12,12,26,0.85);
            border: 1px solid var(--border);
            border-radius: 6px;
            padding: 5px 10px;
            backdrop-filter: blur(8px);
        }
        .stat-pill span { color: var(--highlight); font-weight: 500; }

        /* Search */
        .search-box {
            position: fixed;
            top: 16px;
            left: 16px;
            z-index: 10;
        }
        .search-box input {
            background: rgba(12,12,26,0.85);
            border: 1px solid var(--border);
            border-radius: 6px;
            padding: 7px 12px;
            color: var(--text);
            font-family: 'Fira Code', monospace;
            font-size: 0.7rem;
            width: 180px;
            outline: none;
            backdrop-filter: blur(8px);
            transition: border-color 0.2s;
        }
        .search-box input:focus { border-color: var(--highlight); }
        .search-box input::placeholder { color: var(--text-dim); }

        /* Info card on hover */
        .info-card {
            position: fixed;
            display: none;
            background: rgba(12,12,26,0.92);
            border: 1px solid var(--border);
            border-radius: 10px;
            padding: 14px 18px;
            z-index: 20;
            min-width: 200px;
            max-width: 280px;
            backdrop-filter: blur(12px);
            pointer-events: none;
        }
        .info-card.visible { display: block; }
        .ic-name {
            font-family: 'Newsreader', serif;
            font-weight: 700;
            font-size: 1.1rem;
            margin-bottom: 6px;
        }
        .ic-row {
            font-size: 0.65rem;
            color: var(--text-dim);
            margin-bottom: 3px;
        }
        .ic-row span { color: var(--text); font-weight: 500; }
        .ic-badges {
            display: flex;
            gap: 4px;
            margin-top: 6px;
        }
        .ic-badge {
            font-size: 0.55rem;
            padding: 2px 6px;
            border-radius: 4px;
            background: rgba(96,160,255,0.15);
            color: var(--highlight);
        }
        .ic-badge.faction { background: rgba(255,160,60,0.15); color: #ffa03c; }
        .ic-badge.verified { background: rgba(60,200,120,0.15); color: #3cc878; }

        /* Legend */
        .legend {
            position: fixed;
            bottom: 60px;
            left: 16px;
            z-index: 10;
            font-size: 0.6rem;
            color: var(--text-dim);
        }
        .legend-row {
            display: flex;
            align-items: center;
            gap: 6px;
            margin-bottom: 4px;
        }
        .legend-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            flex-shrink: 0;
        }

        .controls-hint {
            position: fixed;
            bottom: 60px;
            right: 16px;
            z-index: 10;
            font-size: 0.55rem;
            color: var(--text-dim);
            text-align: right;
            line-height: 1.6;
            opacity: 1;
            transition: opacity 2s;
        }
        .controls-hint.hidden { opacity: 0; pointer-events: none; }

        /* Embed mode: hide chrome */
        body.embed-mode .hud-top,
        body.embed-mode .backlink,
        body.embed-mode .legend,
        body.embed-mode .controls-hint,
        body.embed-mode .search-box,
        body.embed-mode .stats-bar{display:none!important}

        .backlink {
            position: fixed;
            bottom: 16px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 10;
            font-size: 0.6rem;
        }
        .backlink a { color: var(--text-dim); text-decoration: none; }
        .backlink a:hover { color: var(--highlight); }

        .loading-overlay {
            position: fixed;
            inset: 0;
            background: var(--bg);
            z-index: 100;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            gap: 16px;
            transition: opacity 0.6s;
        }
        .loading-overlay.done { opacity: 0; pointer-events: none; }
        .loading-text {
            font-family: 'Newsreader', serif;
            font-size: 1.2rem;
            color: var(--highlight);
        }
        .loading-bar {
            width: 200px;
            height: 2px;
            background: var(--border);
            border-radius: 2px;
            overflow: hidden;
        }
        .loading-bar-fill {
            height: 100%;
            background: var(--highlight);
            width: 0%;
            transition: width 0.3s;
        }
    </style>
<script>
(function(){var Q=[],N=0,MAX=10;function send(e){var sb=window.supabase;if(!sb){Q.push(e);return;}if(N>=MAX)return;N++;sb.auth.getSession().then(function(r){var u=r&&r.data&&r.data.session&&r.data.session.user;if(!u)return;sb.from('ai_events').insert({event_type:'client_error',entity_type:'app',entity_id:u.id,username:location.pathname.split('/').filter(Boolean)[0]||'unknown',metadata:e,user_id:u.id}).then(function(){});}).catch(function(){});}window.onerror=function(m,s,l,c,e){send({type:'error',msg:String(m).slice(0,500),src:s||'',line:l,col:c,stack:e?String(e.stack).slice(0,1000):''});};window.addEventListener('unhandledrejection',function(ev){var r=ev.reason;send({type:'promise',msg:String(r&&r.message||r).slice(0,500),stack:r?String(r.stack||'').slice(0,1000):''});});var fi=setInterval(function(){if(window.supabase){Q.splice(0).forEach(send);clearInterval(fi);}},1000);setTimeout(function(){clearInterval(fi);},30000);})();
</script>
</head>
<body>
    <div class="loading-overlay" id="loader">
        <div class="loading-text">Mapping the network...</div>
        <div class="loading-bar"><div class="loading-bar-fill" id="loaderFill"></div></div>
    </div>

    <canvas id="graph"></canvas>

    <div class="hud-top">
        <div class="hud-title">SLOPPY NETWORK</div>
        <div class="hud-sub" id="hudSub">loading...</div>
    </div>

    <div class="search-box">
        <input type="text" id="searchInput" placeholder="Find user..." maxlength="40">
    </div>

    <div class="stats-bar" id="statsBar">
        <div class="stat-pill">Nodes: <span id="statNodes">0</span></div>
        <div class="stat-pill">Edges: <span id="statEdges">0</span></div>
        <div class="stat-pill">Factions: <span id="statFactions">0</span></div>
    </div>

    <div class="info-card" id="infoCard">
        <div class="ic-name" id="icName"></div>
        <div id="icBody"></div>
        <div class="ic-badges" id="icBadges"></div>
    </div>

    <div class="legend" id="legend"></div>

    <div class="controls-hint" id="controlsHint">
        Scroll to zoom<br>
        Drag to pan<br>
        Click node to pin<br>
        Search to highlight
    </div>

    <div class="backlink">
        <a href="https://sloppy.live">‚Üê sloppy.live</a>
    </div>

    <script src="/apps/sloppy-header/sloppy-bar.js" data-position="bottom"></script>
    <script type="module">
        import { createBrowserClient } from "https://cdn.jsdelivr.net/npm/@supabase/ssr@0.7.0/+esm";

        const SUPABASE_URL = 'https://yjyxteqzhhmtrgcaekgz.supabase.co';
        const SUPABASE_ANON_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InlqeXh0ZXF6aGhtdHJnY2Fla2d6Iiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTczNTg3NDIsImV4cCI6MjA3MjkzNDc0Mn0.G8SRde7IN2QFW1EnASM8IS32IUYR2eenCCjdDdioiBU';

        const supabase = createBrowserClient(SUPABASE_URL, SUPABASE_ANON_KEY, {
            cookieOptions: { name: 'sb-auth-token', domain: location.hostname.includes('sloppy.live') ? '.sloppy.live' : location.hostname, path: '/', sameSite: 'lax' }
        });
        window.supabase = supabase; // Expose for error catcher

        // --- Data ---
        const nodes = new Map();   // username -> { x, y, vx, vy, radius, color, karma, faction, factionColor, verified, followers, following, pinned }
        const edges = [];           // [{ from, to }]
        let factionMap = {};        // factionId -> { name, emoji, color }
        let memberFactions = {};    // username -> factionId

        // --- Camera ---
        let camX = 0, camY = 0, camZoom = 1;
        let dragStartX, dragStartY, camDragX, camDragY;
        let isDragging = false;
        let dragNode = null;
        let hoveredNode = null;
        let highlightedUser = null;

        const canvas = document.getElementById('graph');
        const ctx = canvas.getContext('2d');
        const loaderFill = document.getElementById('loaderFill');

        function resize() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        }
        window.addEventListener('resize', resize);
        resize();

        // --- Load Data ---
        async function loadData() {
            const sessRes = await supabase.auth.getSession();
            if (!sessRes.data.session) {
                // Auth delegation: skip anonymous sign-in if header already has auth
                let headerHasAuth = false;
                if (window.sloppyBarGetContext) {
                    const ctx = window.sloppyBarGetContext();
                    if (ctx && ctx.isAuthenticated && ctx.userId) headerHasAuth = true;
                }
                if (!headerHasAuth) await supabase.auth.signInAnonymously();
            }

            loaderFill.style.width = '15%';

            // Fetch all data in parallel
            const [followsRes, karmaRes, profilesRes, factionsRes, membersRes, verifRes] = await Promise.all([
                supabase.from('sloppygram_follows').select('follower_username, followed_username').limit(2000),
                supabase.from('sloppygram_karma').select('username, karma_total, karma_content, karma_social, karma_trust, rank').order('karma_total', { ascending: false }).limit(500),
                supabase.from('sloppygram_profiles').select('username, avatar, color').limit(500),
                supabase.from('sloppygram_factions').select('faction_id, name, emoji, color').limit(50),
                supabase.from('sloppygram_faction_members').select('username, faction_id').limit(500),
                supabase.from('sloppyid_verifications').select('username, verification_type, is_verified').eq('is_verified', true).limit(500),
            ]);

            loaderFill.style.width = '60%';

            const follows = followsRes.data || [];
            const karmaRows = karmaRes.data || [];
            const profiles = profilesRes.data || [];
            const factions = factionsRes.data || [];
            const members = membersRes.data || [];
            const verifs = verifRes.data || [];

            // Build faction lookup
            factions.forEach(f => { factionMap[f.faction_id] = { name: f.name, emoji: f.emoji, color: f.color }; });
            members.forEach(m => { memberFactions[m.username] = m.faction_id; });

            // Build profile lookup
            const profileMap = {};
            profiles.forEach(p => { profileMap[p.username] = p; });

            // Build karma lookup
            const karmaMap = {};
            karmaRows.forEach(k => { karmaMap[k.username] = k; });

            // Build verification lookup
            const verifMap = {};
            verifs.forEach(v => {
                if (!verifMap[v.username]) verifMap[v.username] = [];
                verifMap[v.username].push(v.verification_type);
            });

            // Collect all usernames from follows
            const allUsers = new Set();
            follows.forEach(f => {
                if (f.follower_username) allUsers.add(f.follower_username);
                if (f.followed_username) allUsers.add(f.followed_username);
            });
            // Also add top karma users even if no follows
            karmaRows.slice(0, 50).forEach(k => { if (k.username) allUsers.add(k.username); });

            loaderFill.style.width = '75%';

            // Create nodes
            const W = canvas.width, H = canvas.height;
            allUsers.forEach(username => {
                const karma = karmaMap[username];
                const profile = profileMap[username];
                const factionId = memberFactions[username];
                const faction = factionId ? factionMap[factionId] : null;
                const karmaTotal = karma ? karma.karma_total : 0;

                // Node radius based on karma (min 4, max 24)
                const radius = Math.max(4, Math.min(24, 4 + Math.sqrt(karmaTotal) * 0.5));

                // Color from faction or profile
                let color = 'var(--node-default)';
                if (faction && faction.color) color = faction.color;
                else if (profile && profile.color) color = profile.color;
                else color = '#5588cc';

                nodes.set(username, {
                    x: (Math.random() - 0.5) * W * 0.8,
                    y: (Math.random() - 0.5) * H * 0.8,
                    vx: 0, vy: 0,
                    radius,
                    color,
                    avatar: profile ? profile.avatar : null,
                    karma: karmaTotal,
                    karmaData: karma,
                    faction: faction ? `${faction.emoji} ${faction.name}` : null,
                    factionColor: faction ? faction.color : null,
                    verified: verifMap[username] || [],
                    followers: 0,
                    following: 0,
                    pinned: false
                });
            });

            // Create edges
            follows.forEach(f => {
                if (f.follower_username && f.followed_username && nodes.has(f.follower_username) && nodes.has(f.followed_username)) {
                    edges.push({ from: f.follower_username, to: f.followed_username });
                    const toNode = nodes.get(f.followed_username);
                    const fromNode = nodes.get(f.follower_username);
                    if (toNode) toNode.followers++;
                    if (fromNode) fromNode.following++;
                }
            });

            loaderFill.style.width = '100%';

            // Update HUD
            const factionCount = new Set(members.map(m => m.faction_id)).size;
            document.getElementById('statNodes').textContent = nodes.size;
            document.getElementById('statEdges').textContent = edges.length;
            document.getElementById('statFactions').textContent = factionCount;
            document.getElementById('hudSub').textContent = `${nodes.size} users ¬∑ ${edges.length} connections`;

            // Build legend from factions
            const legend = document.getElementById('legend');
            let legendHtml = '';
            Object.values(factionMap).slice(0, 8).forEach(f => {
                legendHtml += `<div class="legend-row"><div class="legend-dot" style="background:${f.color}"></div>${f.emoji} ${f.name}</div>`;
            });
            legendHtml += `<div class="legend-row"><div class="legend-dot" style="background:#5588cc"></div>No faction</div>`;
            legend.innerHTML = legendHtml;

            // Hide loader
            setTimeout(() => { document.getElementById('loader').classList.add('done'); }, 400);

            // Hide controls hint after interaction
            setTimeout(() => { document.getElementById('controlsHint').classList.add('hidden'); }, 8000);
        }

        // --- Force Simulation ---
        const REPULSION = 800;
        const ATTRACTION = 0.003;
        const DAMPING = 0.88;
        const CENTER_PULL = 0.0005;

        function simulate() {
            const nodeArr = Array.from(nodes.values());
            const N = nodeArr.length;
            if (N === 0) return;

            // Repulsion (Barnes-Hut would be better but brute force is ok for <500 nodes)
            for (let i = 0; i < N; i++) {
                const a = nodeArr[i];
                if (a.pinned) continue;
                for (let j = i + 1; j < N; j++) {
                    const b = nodeArr[j];
                    let dx = a.x - b.x;
                    let dy = a.y - b.y;
                    let distSq = dx * dx + dy * dy;
                    if (distSq < 1) distSq = 1;
                    const dist = Math.sqrt(distSq);
                    const force = REPULSION / distSq;
                    const fx = (dx / dist) * force;
                    const fy = (dy / dist) * force;
                    a.vx += fx;
                    a.vy += fy;
                    if (!b.pinned) {
                        b.vx -= fx;
                        b.vy -= fy;
                    }
                }
            }

            // Attraction along edges
            const nodeMap = nodes;
            edges.forEach(e => {
                const a = nodeMap.get(e.from);
                const b = nodeMap.get(e.to);
                if (!a || !b) return;
                const dx = b.x - a.x;
                const dy = b.y - a.y;
                const dist = Math.sqrt(dx * dx + dy * dy) || 1;
                const force = dist * ATTRACTION;
                const fx = (dx / dist) * force;
                const fy = (dy / dist) * force;
                if (!a.pinned) { a.vx += fx; a.vy += fy; }
                if (!b.pinned) { b.vx -= fx; b.vy -= fy; }
            });

            // Center pull + velocity update
            for (let i = 0; i < N; i++) {
                const n = nodeArr[i];
                if (n.pinned) { n.vx = 0; n.vy = 0; continue; }
                n.vx -= n.x * CENTER_PULL;
                n.vy -= n.y * CENTER_PULL;
                n.vx *= DAMPING;
                n.vy *= DAMPING;
                n.x += n.vx;
                n.y += n.vy;
            }
        }

        // --- Rendering ---
        function draw() {
            const W = canvas.width, H = canvas.height;
            ctx.clearRect(0, 0, W, H);

            ctx.save();
            ctx.translate(W / 2 + camX, H / 2 + camY);
            ctx.scale(camZoom, camZoom);

            // Draw edges
            ctx.lineWidth = 0.5 / camZoom;
            edges.forEach(e => {
                const a = nodes.get(e.from);
                const b = nodes.get(e.to);
                if (!a || !b) return;

                const isHighlighted = highlightedUser && (e.from === highlightedUser || e.to === highlightedUser);
                ctx.strokeStyle = isHighlighted ? 'rgba(96,160,255,0.5)' : 'rgba(80,120,200,0.12)';
                ctx.lineWidth = isHighlighted ? 1.5 / camZoom : 0.5 / camZoom;

                ctx.beginPath();
                ctx.moveTo(a.x, a.y);
                ctx.lineTo(b.x, b.y);
                ctx.stroke();
            });

            // Draw nodes
            nodes.forEach((n, username) => {
                const isHovered = hoveredNode === username;
                const isHighlighted = highlightedUser === username;
                const isConnected = highlightedUser && edges.some(e =>
                    (e.from === highlightedUser && e.to === username) ||
                    (e.to === highlightedUser && e.from === username)
                );
                const dimmed = highlightedUser && !isHighlighted && !isConnected;

                const r = n.radius;
                const alpha = dimmed ? 0.15 : 1;

                // Glow for highlighted/hovered
                if (isHighlighted || isHovered) {
                    ctx.beginPath();
                    ctx.arc(n.x, n.y, r + 6, 0, Math.PI * 2);
                    const glow = ctx.createRadialGradient(n.x, n.y, r, n.x, n.y, r + 6);
                    glow.addColorStop(0, n.color + '80');
                    glow.addColorStop(1, 'transparent');
                    ctx.fillStyle = glow;
                    ctx.fill();
                }

                // Node circle
                ctx.beginPath();
                ctx.arc(n.x, n.y, r, 0, Math.PI * 2);
                ctx.globalAlpha = alpha;
                ctx.fillStyle = n.color;
                ctx.fill();

                // Border for verified
                if (n.verified.length > 0 && !dimmed) {
                    ctx.strokeStyle = '#3cc878';
                    ctx.lineWidth = 1.5 / camZoom;
                    ctx.stroke();
                }

                // Avatar emoji
                if (n.avatar && r > 6 && !dimmed) {
                    ctx.font = `${Math.round(r * 1.1)}px sans-serif`;
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillStyle = '#fff';
                    ctx.fillText(n.avatar, n.x, n.y + 1);
                }

                // Label for large or hovered nodes
                if ((r > 10 || isHovered || isHighlighted) && !dimmed) {
                    ctx.font = `${Math.max(9, Math.round(10 / camZoom))}px "Fira Code", monospace`;
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'top';
                    ctx.fillStyle = 'rgba(200,200,216,0.8)';
                    ctx.fillText(username.length > 14 ? username.slice(0, 12) + '‚Ä¶' : username, n.x, n.y + r + 3);
                }

                ctx.globalAlpha = 1;
            });

            ctx.restore();
        }

        function loop() {
            simulate();
            draw();
            requestAnimationFrame(loop);
        }

        // --- Interaction ---
        function screenToWorld(sx, sy) {
            const W = canvas.width, H = canvas.height;
            return {
                x: (sx - W / 2 - camX) / camZoom,
                y: (sy - H / 2 - camY) / camZoom
            };
        }

        function findNodeAt(wx, wy) {
            let closest = null, closestDist = Infinity;
            nodes.forEach((n, username) => {
                const dx = n.x - wx, dy = n.y - wy;
                const dist = Math.sqrt(dx * dx + dy * dy);
                const hitR = Math.max(n.radius, 8);
                if (dist < hitR && dist < closestDist) {
                    closest = username;
                    closestDist = dist;
                }
            });
            return closest;
        }

        canvas.addEventListener('mousedown', e => {
            const w = screenToWorld(e.clientX, e.clientY);
            const hit = findNodeAt(w.x, w.y);
            if (hit) {
                dragNode = hit;
                const n = nodes.get(hit);
                n.pinned = true;
            } else {
                isDragging = true;
                dragStartX = e.clientX;
                dragStartY = e.clientY;
                camDragX = camX;
                camDragY = camY;
            }
        });

        canvas.addEventListener('mousemove', e => {
            if (dragNode) {
                const w = screenToWorld(e.clientX, e.clientY);
                const n = nodes.get(dragNode);
                n.x = w.x;
                n.y = w.y;
            } else if (isDragging) {
                camX = camDragX + (e.clientX - dragStartX);
                camY = camDragY + (e.clientY - dragStartY);
            } else {
                const w = screenToWorld(e.clientX, e.clientY);
                const hit = findNodeAt(w.x, w.y);
                hoveredNode = hit;
                canvas.style.cursor = hit ? 'pointer' : 'grab';
                showInfoCard(hit, e.clientX, e.clientY);
            }
        });

        canvas.addEventListener('mouseup', () => {
            if (dragNode) {
                const n = nodes.get(dragNode);
                // Toggle pin on click (if barely moved)
                dragNode = null;
            }
            isDragging = false;
        });

        canvas.addEventListener('wheel', e => {
            e.preventDefault();
            const factor = e.deltaY > 0 ? 0.9 : 1.1;
            const newZoom = Math.max(0.1, Math.min(8, camZoom * factor));

            // Zoom toward mouse
            const mx = e.clientX - canvas.width / 2;
            const my = e.clientY - canvas.height / 2;
            camX = mx - (mx - camX) * (newZoom / camZoom);
            camY = my - (my - camY) * (newZoom / camZoom);
            camZoom = newZoom;
        }, { passive: false });

        // Touch support
        let lastTouchDist = 0;
        canvas.addEventListener('touchstart', e => {
            if (e.touches.length === 1) {
                const t = e.touches[0];
                const w = screenToWorld(t.clientX, t.clientY);
                const hit = findNodeAt(w.x, w.y);
                if (hit) {
                    dragNode = hit;
                    nodes.get(hit).pinned = true;
                    showInfoCard(hit, t.clientX, t.clientY);
                } else {
                    isDragging = true;
                    dragStartX = t.clientX;
                    dragStartY = t.clientY;
                    camDragX = camX;
                    camDragY = camY;
                }
            } else if (e.touches.length === 2) {
                const dx = e.touches[0].clientX - e.touches[1].clientX;
                const dy = e.touches[0].clientY - e.touches[1].clientY;
                lastTouchDist = Math.sqrt(dx * dx + dy * dy);
            }
            e.preventDefault();
        }, { passive: false });

        canvas.addEventListener('touchmove', e => {
            if (e.touches.length === 1) {
                const t = e.touches[0];
                if (dragNode) {
                    const w = screenToWorld(t.clientX, t.clientY);
                    const n = nodes.get(dragNode);
                    n.x = w.x; n.y = w.y;
                } else if (isDragging) {
                    camX = camDragX + (t.clientX - dragStartX);
                    camY = camDragY + (t.clientY - dragStartY);
                }
            } else if (e.touches.length === 2) {
                const dx = e.touches[0].clientX - e.touches[1].clientX;
                const dy = e.touches[0].clientY - e.touches[1].clientY;
                const dist = Math.sqrt(dx * dx + dy * dy);
                if (lastTouchDist > 0) {
                    camZoom = Math.max(0.1, Math.min(8, camZoom * (dist / lastTouchDist)));
                }
                lastTouchDist = dist;
            }
            e.preventDefault();
        }, { passive: false });

        canvas.addEventListener('touchend', () => {
            dragNode = null;
            isDragging = false;
            lastTouchDist = 0;
        });

        // Info card
        function showInfoCard(username, mx, my) {
            const card = document.getElementById('infoCard');
            if (!username) {
                card.classList.remove('visible');
                return;
            }
            const n = nodes.get(username);
            card.classList.add('visible');

            // Position
            let left = mx + 16, top = my - 10;
            if (left + 280 > window.innerWidth) left = mx - 290;
            if (top + 200 > window.innerHeight) top = my - 180;
            card.style.left = left + 'px';
            card.style.top = top + 'px';

            document.getElementById('icName').textContent = username;
            document.getElementById('icName').style.color = n.color;

            let body = '';
            body += `<div class="ic-row">Karma: <span>${(n.karma || 0).toLocaleString()}</span></div>`;
            body += `<div class="ic-row">Followers: <span>${n.followers}</span> ¬∑ Following: <span>${n.following}</span></div>`;
            if (n.karmaData) {
                if (n.karmaData.rank) body += `<div class="ic-row">Rank: <span>#${n.karmaData.rank}</span></div>`;
            }
            document.getElementById('icBody').innerHTML = body;

            let badges = '';
            if (n.faction) badges += `<div class="ic-badge faction">${n.faction}</div>`;
            n.verified.forEach(v => {
                badges += `<div class="ic-badge verified">${v}</div>`;
            });
            document.getElementById('icBadges').innerHTML = badges;
        }

        // Search
        const searchInput = document.getElementById('searchInput');
        searchInput.addEventListener('input', () => {
            const q = searchInput.value.trim().toLowerCase();
            if (!q) {
                highlightedUser = null;
                return;
            }
            // Find best match
            let best = null;
            nodes.forEach((n, username) => {
                if (username.toLowerCase().startsWith(q)) best = username;
            });
            if (!best) {
                nodes.forEach((n, username) => {
                    if (username.toLowerCase().includes(q)) best = username;
                });
            }
            highlightedUser = best;

            // Center on found node
            if (best) {
                const n = nodes.get(best);
                camX = -n.x * camZoom;
                camY = -n.y * camZoom;
            }
        });

        // Double-click to unpin all
        canvas.addEventListener('dblclick', () => {
            nodes.forEach(n => { n.pinned = false; });
        });

        // --- Embed Mode ---
        const isEmbed = new URLSearchParams(location.search).get('embed') === 'true';
        if (isEmbed) document.body.classList.add('embed-mode');

        // On node click in embed mode, notify parent
        canvas.addEventListener('click', (e) => {
            if (!isEmbed) return;
            const w = screenToWorld(e.clientX, e.clientY);
            const hit = findNodeAt(w.x, w.y);
            if (hit) {
                window.parent.postMessage({ type: 'node-click', username: hit }, '*');
            }
        });

        // --- Init ---
        loadData().then(() => {
            loop();

            // Sync hub listeners ‚Äî update graph nodes live
            if (window.sloppyBarOn) {
                window.sloppyBarOn('identity-changed', function(data) {
                    if (!data || !data.username) return;
                    const node = nodes.get(data.username);
                    if (node && data.color) node.color = data.color;
                });
                window.sloppyBarOn('karma-changed', function(data) {
                    if (!data || !data.username) return;
                    const node = nodes.get(data.username);
                    if (node && typeof data.karma === 'number') {
                        node.karma = data.karma;
                        node.radius = Math.max(6, Math.min(30, 6 + Math.sqrt(data.karma) * 0.5));
                    }
                });
            }
        });
    </script>
<script src="/vibelib-extended.js"></script>
<script>
  // Compatibility Patch for Legacy Apps
  window.addEventListener("load", () => {
    if (window.SloppyKarma && window.VibeLib.Economy) {
      // Redirect old calls to new engine
      window.SloppyKarma.track = window.VibeLib.Economy.track;
    }
  });
</script>
</body>
</html>
