<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Ghost Runner - Neon Escape</title>
  <meta name="description" content="Dodge digital ghosts in this neon endless runner">
  <meta property="og:title" content="Ghost Runner">
  <meta property="og:description" content="Dodge digital ghosts in this neon endless runner">
  <meta property="og:url" content="https://app.sloppy.live/ghost-runner">
  <meta property="og:image" content="https://app.sloppy.live/ghost-runner/og-image.png">
  <link rel="icon" href="https://emojicdn.elk.sh/ðŸ‘»">
  <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      min-height: 100vh;
      background: #050508;
      font-family: 'Press Start 2P', monospace;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      overflow: hidden;
    }

    .game-container {
      position: relative;
      width: 100%;
      max-width: 900px;
      padding: 20px;
    }

    .header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 15px;
      padding: 0 10px;
    }

    .score {
      font-size: 1rem;
      color: #0ff;
      text-shadow: 0 0 10px #0ff, 0 0 20px #0ff;
    }

    .high-score {
      font-size: 0.7rem;
      color: #f0f;
      text-shadow: 0 0 10px #f0f;
    }

    #gameCanvas {
      width: 100%;
      height: 400px;
      background: linear-gradient(180deg, #0a0a15 0%, #151525 100%);
      border: 3px solid #333;
      border-radius: 8px;
      box-shadow:
        0 0 20px rgba(0, 255, 255, 0.2),
        inset 0 0 50px rgba(0, 0, 0, 0.5);
    }

    .controls-hint {
      margin-top: 15px;
      font-size: 0.6rem;
      color: #444;
      text-align: center;
      letter-spacing: 1px;
    }

    .overlay {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      text-align: center;
      z-index: 10;
      pointer-events: none;
    }

    .overlay.hidden {
      display: none;
    }

    .overlay h2 {
      font-size: 1.5rem;
      color: #0ff;
      text-shadow: 0 0 20px #0ff, 0 0 40px #0ff;
      margin-bottom: 20px;
    }

    .overlay p {
      font-size: 0.7rem;
      color: #f0f;
      text-shadow: 0 0 10px #f0f;
      margin-bottom: 10px;
    }

    .overlay .final-score {
      font-size: 1.2rem;
      color: #ff0;
      text-shadow: 0 0 15px #ff0;
      margin: 20px 0;
    }

    .start-btn {
      font-family: 'Press Start 2P', monospace;
      font-size: 0.8rem;
      padding: 15px 30px;
      background: transparent;
      border: 2px solid #0ff;
      color: #0ff;
      cursor: pointer;
      pointer-events: auto;
      transition: all 0.2s;
      text-shadow: 0 0 10px #0ff;
      box-shadow: 0 0 20px rgba(0, 255, 255, 0.3);
    }

    .start-btn:hover {
      background: #0ff;
      color: #000;
      box-shadow: 0 0 40px rgba(0, 255, 255, 0.6);
    }

    .back-link {
      position: fixed;
      bottom: 20px;
      color: #333;
      text-decoration: none;
      font-size: 0.5rem;
      transition: color 0.2s;
    }

    .back-link:hover {
      color: #0ff;
    }

    @media (max-width: 600px) {
      #gameCanvas {
        height: 300px;
      }

      .score { font-size: 0.8rem; }
      .high-score { font-size: 0.6rem; }
      .overlay h2 { font-size: 1rem; }
      .overlay p { font-size: 0.55rem; }
      .start-btn { font-size: 0.6rem; padding: 12px 20px; }
    }
  </style>
</head>
<body>
  <div class="game-container">
    <div class="header">
      <div class="score">SCORE: <span id="score">0</span></div>
      <div class="high-score">BEST: <span id="highScore">0</span></div>
    </div>

    <canvas id="gameCanvas"></canvas>

    <div class="overlay" id="startOverlay">
      <h2>ðŸ‘» GHOST RUNNER</h2>
      <p>DODGE THE DIGITAL GHOSTS</p>
      <p>JUMP OR SLIDE TO SURVIVE</p>
      <button class="start-btn" id="startBtn">START</button>
    </div>

    <div class="overlay hidden" id="gameOverOverlay">
      <h2>GAME OVER</h2>
      <div class="final-score">SCORE: <span id="finalScore">0</span></div>
      <button class="start-btn" id="restartBtn">TRY AGAIN</button>
    </div>

    <p class="controls-hint">SPACE / TAP = JUMP â€¢ DOWN / SWIPE = SLIDE</p>
  </div>

  <a href="https://sloppy.live" class="back-link">sloppy.live</a>

  <script>
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');

    // Responsive canvas
    function resizeCanvas() {
      const rect = canvas.getBoundingClientRect();
      canvas.width = rect.width * 2;
      canvas.height = rect.height * 2;
      ctx.scale(1, 1);
    }
    resizeCanvas();
    window.addEventListener('resize', resizeCanvas);

    // Game state
    let gameRunning = false;
    let score = 0;
    let highScore = parseInt(localStorage.getItem('ghostRunnerHigh') || '0');
    let gameSpeed = 6;
    let frameCount = 0;

    document.getElementById('highScore').textContent = highScore;

    // Ground
    const groundY = canvas.height * 0.75;

    // Player
    const player = {
      x: 150,
      y: groundY,
      width: 50,
      height: 80,
      velocityY: 0,
      jumping: false,
      sliding: false,
      slideTimer: 0,
      color: '#0ff',
      trail: []
    };

    // Ghosts
    let ghosts = [];
    const ghostTypes = [
      { width: 60, height: 70, y: groundY, color: '#f0f', speed: 1, type: 'ground' },
      { width: 50, height: 50, y: groundY - 100, color: '#ff0', speed: 1.2, type: 'air' },
      { width: 80, height: 40, y: groundY - 30, color: '#f00', speed: 0.8, type: 'low' }
    ];

    // Particles
    let particles = [];

    // Grid lines (background effect)
    let gridOffset = 0;

    // Physics
    const gravity = 0.8;
    const jumpForce = -18;
    const slideDuration = 30;

    // Spawn ghost
    function spawnGhost() {
      const type = ghostTypes[Math.floor(Math.random() * ghostTypes.length)];

      // Don't spawn air ghosts too often
      if (type.type === 'air' && Math.random() > 0.4) {
        return spawnGhost();
      }

      ghosts.push({
        x: canvas.width + 50,
        y: type.y - type.height,
        width: type.width,
        height: type.height,
        color: type.color,
        speed: type.speed,
        type: type.type,
        phase: Math.random() * Math.PI * 2,
        alpha: 0.8
      });
    }

    // Create particle
    function createParticle(x, y, color) {
      for (let i = 0; i < 5; i++) {
        particles.push({
          x, y,
          vx: (Math.random() - 0.5) * 8,
          vy: (Math.random() - 0.5) * 8,
          size: Math.random() * 6 + 2,
          color,
          life: 1
        });
      }
    }

    // Draw neon grid background
    function drawGrid() {
      ctx.strokeStyle = 'rgba(0, 255, 255, 0.1)';
      ctx.lineWidth = 1;

      // Vertical lines (moving)
      for (let x = -gridOffset % 80; x < canvas.width; x += 80) {
        ctx.beginPath();
        ctx.moveTo(x, 0);
        ctx.lineTo(x, canvas.height);
        ctx.stroke();
      }

      // Horizontal lines
      for (let y = 0; y < canvas.height; y += 80) {
        ctx.beginPath();
        ctx.moveTo(0, y);
        ctx.lineTo(canvas.width, y);
        ctx.stroke();
      }

      gridOffset += gameSpeed * 0.5;
    }

    // Draw ground
    function drawGround() {
      // Ground line with glow
      ctx.shadowColor = '#0ff';
      ctx.shadowBlur = 20;
      ctx.strokeStyle = '#0ff';
      ctx.lineWidth = 3;
      ctx.beginPath();
      ctx.moveTo(0, groundY);
      ctx.lineTo(canvas.width, groundY);
      ctx.stroke();
      ctx.shadowBlur = 0;

      // Ground pattern
      ctx.strokeStyle = 'rgba(0, 255, 255, 0.3)';
      ctx.lineWidth = 1;
      for (let x = -gridOffset % 40; x < canvas.width; x += 40) {
        ctx.beginPath();
        ctx.moveTo(x, groundY);
        ctx.lineTo(x + 20, groundY + 50);
        ctx.stroke();
      }
    }

    // Draw player
    function drawPlayer() {
      const p = player;
      const h = p.sliding ? p.height * 0.4 : p.height;
      const y = p.sliding ? groundY - h : p.y - h;

      // Trail effect
      p.trail.push({ x: p.x, y: y + h/2, alpha: 0.8 });
      if (p.trail.length > 8) p.trail.shift();

      p.trail.forEach((t, i) => {
        const alpha = (i / p.trail.length) * 0.3;
        ctx.fillStyle = `rgba(0, 255, 255, ${alpha})`;
        ctx.fillRect(t.x - 10, t.y - 20, 20, 40);
      });

      // Player body (neon rectangle with glow)
      ctx.shadowColor = p.color;
      ctx.shadowBlur = 30;
      ctx.fillStyle = p.color;
      ctx.fillRect(p.x - p.width/2, y, p.width, h);

      // Inner glow
      ctx.fillStyle = 'rgba(255, 255, 255, 0.3)';
      ctx.fillRect(p.x - p.width/2 + 8, y + 8, p.width - 16, h - 16);

      // Eyes
      ctx.shadowBlur = 10;
      ctx.fillStyle = '#000';
      const eyeY = y + (p.sliding ? 10 : 20);
      ctx.fillRect(p.x - 15, eyeY, 10, 10);
      ctx.fillRect(p.x + 5, eyeY, 10, 10);

      ctx.shadowBlur = 0;
    }

    // Draw ghost
    function drawGhost(g) {
      const wobble = Math.sin(frameCount * 0.1 + g.phase) * 5;

      ctx.shadowColor = g.color;
      ctx.shadowBlur = 25;
      ctx.globalAlpha = g.alpha;

      // Ghost body
      ctx.fillStyle = g.color;
      ctx.beginPath();
      ctx.moveTo(g.x, g.y + g.height);

      // Wavy bottom
      const waves = 4;
      const waveWidth = g.width / waves;
      for (let i = 0; i <= waves; i++) {
        const wx = g.x + i * waveWidth;
        const wy = g.y + g.height + (i % 2 === 0 ? 10 : 0);
        ctx.lineTo(wx, wy);
      }

      ctx.lineTo(g.x + g.width, g.y + g.height * 0.3);
      ctx.quadraticCurveTo(g.x + g.width/2, g.y - 10 + wobble, g.x, g.y + g.height * 0.3);
      ctx.closePath();
      ctx.fill();

      // Eyes
      ctx.fillStyle = '#000';
      ctx.shadowBlur = 0;
      const eyeSize = g.width * 0.15;
      ctx.beginPath();
      ctx.arc(g.x + g.width * 0.3, g.y + g.height * 0.4 + wobble, eyeSize, 0, Math.PI * 2);
      ctx.arc(g.x + g.width * 0.7, g.y + g.height * 0.4 + wobble, eyeSize, 0, Math.PI * 2);
      ctx.fill();

      ctx.globalAlpha = 1;
      ctx.shadowBlur = 0;
    }

    // Draw particles
    function drawParticles() {
      particles.forEach((p, i) => {
        ctx.globalAlpha = p.life;
        ctx.shadowColor = p.color;
        ctx.shadowBlur = 10;
        ctx.fillStyle = p.color;
        ctx.fillRect(p.x - p.size/2, p.y - p.size/2, p.size, p.size);

        p.x += p.vx;
        p.y += p.vy;
        p.life -= 0.03;
        p.size *= 0.95;

        if (p.life <= 0) particles.splice(i, 1);
      });
      ctx.globalAlpha = 1;
      ctx.shadowBlur = 0;
    }

    // Update player
    function updatePlayer() {
      // Gravity
      if (player.jumping) {
        player.velocityY += gravity;
        player.y += player.velocityY;

        if (player.y >= groundY) {
          player.y = groundY;
          player.jumping = false;
          player.velocityY = 0;
          createParticle(player.x, groundY, '#0ff');
        }
      }

      // Slide timer
      if (player.sliding) {
        player.slideTimer--;
        if (player.slideTimer <= 0) {
          player.sliding = false;
        }
      }
    }

    // Update ghosts
    function updateGhosts() {
      ghosts.forEach((g, i) => {
        g.x -= gameSpeed * g.speed;

        // Float effect for air ghosts
        if (g.type === 'air') {
          g.y += Math.sin(frameCount * 0.05 + g.phase) * 0.5;
        }

        // Remove off-screen ghosts
        if (g.x + g.width < 0) {
          ghosts.splice(i, 1);
          score += 10;
        }
      });
    }

    // Check collision
    function checkCollision() {
      const p = player;
      const ph = p.sliding ? p.height * 0.4 : p.height;
      const py = p.sliding ? groundY - ph : p.y - ph;

      const playerBox = {
        x: p.x - p.width/2 + 10,
        y: py + 10,
        width: p.width - 20,
        height: ph - 20
      };

      for (const g of ghosts) {
        const ghostBox = {
          x: g.x + 10,
          y: g.y + 10,
          width: g.width - 20,
          height: g.height - 20
        };

        if (playerBox.x < ghostBox.x + ghostBox.width &&
            playerBox.x + playerBox.width > ghostBox.x &&
            playerBox.y < ghostBox.y + ghostBox.height &&
            playerBox.y + playerBox.height > ghostBox.y) {
          return true;
        }
      }
      return false;
    }

    // Jump
    function jump() {
      if (!player.jumping && !player.sliding) {
        player.jumping = true;
        player.velocityY = jumpForce;
        createParticle(player.x, groundY, '#0ff');
      }
    }

    // Slide
    function slide() {
      if (!player.jumping && !player.sliding) {
        player.sliding = true;
        player.slideTimer = slideDuration;
        createParticle(player.x, groundY, '#0ff');
      }
    }

    // Game loop
    function gameLoop() {
      if (!gameRunning) return;

      // Clear
      ctx.fillStyle = '#050510';
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      // Draw
      drawGrid();
      drawGround();
      drawParticles();

      ghosts.forEach(g => drawGhost(g));
      drawPlayer();

      // Update
      updatePlayer();
      updateGhosts();

      // Spawn ghosts
      frameCount++;
      if (frameCount % Math.max(60, 120 - Math.floor(score / 50)) === 0) {
        spawnGhost();
      }

      // Increase difficulty
      if (frameCount % 500 === 0 && gameSpeed < 15) {
        gameSpeed += 0.5;
      }

      // Score
      if (frameCount % 10 === 0) {
        score++;
        document.getElementById('score').textContent = score;
      }

      // Collision
      if (checkCollision()) {
        gameOver();
        return;
      }

      requestAnimationFrame(gameLoop);
    }

    // Start game
    function startGame() {
      gameRunning = true;
      score = 0;
      gameSpeed = 6;
      frameCount = 0;
      ghosts = [];
      particles = [];
      player.y = groundY;
      player.jumping = false;
      player.sliding = false;
      player.velocityY = 0;
      player.trail = [];

      document.getElementById('score').textContent = '0';
      document.getElementById('startOverlay').classList.add('hidden');
      document.getElementById('gameOverOverlay').classList.add('hidden');

      gameLoop();
    }

    // Game over
    function gameOver() {
      gameRunning = false;

      if (score > highScore) {
        highScore = score;
        localStorage.setItem('ghostRunnerHigh', highScore);
        document.getElementById('highScore').textContent = highScore;
      }

      document.getElementById('finalScore').textContent = score;
      document.getElementById('gameOverOverlay').classList.remove('hidden');

      // Death particles
      for (let i = 0; i < 20; i++) {
        createParticle(player.x, player.y - player.height/2, '#f00');
      }
    }

    // Controls
    document.addEventListener('keydown', (e) => {
      if (!gameRunning) return;

      if (e.code === 'Space' || e.code === 'ArrowUp') {
        e.preventDefault();
        jump();
      }
      if (e.code === 'ArrowDown') {
        e.preventDefault();
        slide();
      }
    });

    // Touch controls
    let touchStartY = 0;
    canvas.addEventListener('touchstart', (e) => {
      e.preventDefault();
      touchStartY = e.touches[0].clientY;

      if (gameRunning) {
        jump();
      }
    });

    canvas.addEventListener('touchmove', (e) => {
      e.preventDefault();
      const touchY = e.touches[0].clientY;
      if (touchY - touchStartY > 30) {
        slide();
      }
    });

    // Click to jump
    canvas.addEventListener('click', () => {
      if (gameRunning) jump();
    });

    // Buttons
    document.getElementById('startBtn').addEventListener('click', startGame);
    document.getElementById('restartBtn').addEventListener('click', startGame);

    // Initial draw
    ctx.fillStyle = '#050510';
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    drawGrid();
    drawGround();
  </script>
<script src="/sloppy-header/sloppy-bar.js"></script>
<script src="/vibelib-extended.js"></script>
<script>
  // Compatibility Patch for Legacy Apps
  window.addEventListener("load", () => {
    if (window.SloppyKarma && window.VibeLib.Economy) {
      // Redirect old calls to new engine
      window.SloppyKarma.track = window.VibeLib.Economy.track;
    }
  });
</script>
</body>
</html>
