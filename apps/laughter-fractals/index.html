<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Laughter Fractals - Psychedelic Giggle Visualizer</title>
  <link rel="icon" href="https://emojicdn.elk.sh/ðŸ˜‚">
  <meta property="og:title" content="Laughter Fractals">
  <meta property="og:description" content="Psychedelic fractals that pulse to rhythmic giggles!">
  <meta property="og:url" content="https://sloppy.live/laughter-fractals">
  <meta property="og:image" content="https://emojicdn.elk.sh/ðŸŒ€?style=apple&size=512">
  <link href="https://fonts.googleapis.com/css2?family=Monoton&family=Quicksand:wght@300;400&display=swap" rel="stylesheet">
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }

    body {
      background: #000;
      min-height: 100vh;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      overflow: hidden;
      font-family: 'Quicksand', sans-serif;
      color: #fff;
    }

    canvas {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      z-index: 0;
    }

    .ui {
      position: fixed;
      z-index: 10;
      pointer-events: none;
    }

    .title {
      position: fixed;
      top: 20px;
      left: 50%;
      transform: translateX(-50%);
      font-family: 'Monoton', cursive;
      font-size: 2rem;
      background: linear-gradient(90deg, #ff0080, #ff8c00, #ffff00, #00ff00, #00ffff, #8000ff, #ff0080);
      background-size: 400% 100%;
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
      animation: rainbow 3s linear infinite;
      text-shadow: none;
      text-align: center;
    }

    @keyframes rainbow {
      0% { background-position: 0% 50%; }
      100% { background-position: 400% 50%; }
    }

    .start-overlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.9);
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      z-index: 100;
      transition: opacity 0.5s;
    }

    .start-overlay.hidden {
      opacity: 0;
      pointer-events: none;
    }

    .start-overlay h1 {
      font-family: 'Monoton', cursive;
      font-size: 3rem;
      background: linear-gradient(90deg, #ff0080, #ffff00, #00ffff, #ff0080);
      background-size: 300% 100%;
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
      animation: rainbow 2s linear infinite;
      margin-bottom: 20px;
      text-align: center;
    }

    .start-overlay p {
      color: #888;
      margin-bottom: 30px;
      font-size: 1.1rem;
    }

    .start-btn {
      font-family: 'Quicksand', sans-serif;
      font-size: 1.5rem;
      padding: 20px 60px;
      background: linear-gradient(135deg, #ff0080, #8000ff);
      border: none;
      color: #fff;
      cursor: pointer;
      border-radius: 50px;
      transition: all 0.3s;
      pointer-events: auto;
    }

    .start-btn:hover {
      transform: scale(1.1);
      box-shadow: 0 0 40px #ff0080, 0 0 80px #8000ff;
    }

    .controls {
      position: fixed;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      display: flex;
      gap: 15px;
      pointer-events: auto;
    }

    .ctrl-btn {
      font-family: 'Quicksand', sans-serif;
      font-size: 0.9rem;
      padding: 10px 20px;
      background: rgba(255, 255, 255, 0.1);
      border: 1px solid rgba(255, 255, 255, 0.3);
      color: #fff;
      cursor: pointer;
      border-radius: 25px;
      transition: all 0.3s;
      backdrop-filter: blur(10px);
    }

    .ctrl-btn:hover {
      background: rgba(255, 255, 255, 0.2);
      border-color: #fff;
    }

    .ctrl-btn.active {
      background: linear-gradient(135deg, #ff0080, #8000ff);
      border-color: transparent;
    }

    .intensity-meter {
      position: fixed;
      right: 20px;
      top: 50%;
      transform: translateY(-50%);
      width: 10px;
      height: 200px;
      background: rgba(255, 255, 255, 0.1);
      border-radius: 5px;
      overflow: hidden;
    }

    .intensity-fill {
      position: absolute;
      bottom: 0;
      width: 100%;
      background: linear-gradient(180deg, #ff0080, #ffff00, #00ffff);
      transition: height 0.05s;
      border-radius: 5px;
    }

    .backlink {
      position: fixed;
      bottom: 70px;
      left: 50%;
      transform: translateX(-50%);
      font-size: 0.8rem;
      opacity: 0.5;
      pointer-events: auto;
    }

    .backlink a {
      color: #fff;
      text-decoration: none;
    }

    @media (max-width: 600px) {
      .title { font-size: 1.3rem; }
      .start-overlay h1 { font-size: 2rem; }
      .controls { flex-wrap: wrap; justify-content: center; }
    }
  </style>
</head>
<body>
  <canvas id="fractal"></canvas>

  <div class="ui">
    <h1 class="title">LAUGHTER FRACTALS</h1>

    <div class="intensity-meter">
      <div class="intensity-fill" id="intensity"></div>
    </div>
  </div>

  <div class="start-overlay" id="start-overlay">
    <h1>ðŸ˜‚ LAUGHTER<br>FRACTALS ðŸŒ€</h1>
    <p>Psychedelic visuals that pulse to giggles</p>
    <button class="start-btn" id="start-btn">BEGIN THE TRIP</button>
  </div>

  <div class="controls">
    <button class="ctrl-btn active" data-mode="mandelbrot">Mandelbrot</button>
    <button class="ctrl-btn" data-mode="julia">Julia</button>
    <button class="ctrl-btn" data-mode="spiral">Spiral</button>
    <button class="ctrl-btn" data-mode="kaleidoscope">Kaleidoscope</button>
  </div>

  <div class="backlink">
    <a href="https://sloppy.live">ðŸŒˆ Back to sloppy.live</a>
  </div>

  <script>
    const canvas = document.getElementById('fractal');
    const ctx = canvas.getContext('2d');

    let W, H;
    function resize() {
      W = canvas.width = window.innerWidth;
      H = canvas.height = window.innerHeight;
    }
    resize();
    window.addEventListener('resize', resize);

    // Audio context
    let audioCtx;
    let analyser;
    let giggleInterval;
    let audioData;
    let intensity = 0;
    let smoothIntensity = 0;

    // Fractal state
    let mode = 'mandelbrot';
    let time = 0;
    let hueOffset = 0;
    let zoom = 1;
    let offsetX = -0.5;
    let offsetY = 0;
    let juliaC = { r: -0.7, i: 0.27 };

    // Giggle synthesizer
    function createGiggle() {
      if (!audioCtx) return;

      const now = audioCtx.currentTime;
      const duration = 0.15 + Math.random() * 0.1;

      // Multiple oscillators for richer sound
      for (let i = 0; i < 3; i++) {
        const osc = audioCtx.createOscillator();
        const gain = audioCtx.createGain();
        const filter = audioCtx.createBiquadFilter();

        // Giggle frequencies (higher pitches)
        const baseFreq = 400 + Math.random() * 400;
        osc.frequency.setValueAtTime(baseFreq, now);
        osc.frequency.exponentialRampToValueAtTime(baseFreq * 1.5, now + duration * 0.3);
        osc.frequency.exponentialRampToValueAtTime(baseFreq * 0.8, now + duration);

        osc.type = ['sine', 'triangle'][Math.floor(Math.random() * 2)];

        // Tremolo effect for giggle quality
        const lfo = audioCtx.createOscillator();
        const lfoGain = audioCtx.createGain();
        lfo.frequency.value = 20 + Math.random() * 30;
        lfoGain.gain.value = 0.3;
        lfo.connect(lfoGain);
        lfoGain.connect(gain.gain);
        lfo.start(now);
        lfo.stop(now + duration);

        // Filter for warmth
        filter.type = 'bandpass';
        filter.frequency.value = 1000 + Math.random() * 1000;
        filter.Q.value = 2;

        // Envelope
        gain.gain.setValueAtTime(0, now);
        gain.gain.linearRampToValueAtTime(0.15 / (i + 1), now + 0.02);
        gain.gain.exponentialRampToValueAtTime(0.01, now + duration);

        osc.connect(filter);
        filter.connect(gain);
        gain.connect(analyser);
        analyser.connect(audioCtx.destination);

        osc.start(now + i * 0.03);
        osc.stop(now + duration + i * 0.03);
      }
    }

    // Rhythmic giggle pattern
    function startGiggleTrack() {
      // Different giggle patterns
      const patterns = [
        [100, 150, 100, 400],  // ha-ha-ha...ha
        [120, 120, 120, 120, 300], // rapid giggles
        [200, 100, 200, 100, 400], // hee-haw pattern
        [80, 80, 80, 80, 80, 500], // machine gun giggles
      ];

      let patternIndex = 0;
      let noteIndex = 0;

      function playNext() {
        createGiggle();

        const pattern = patterns[patternIndex];
        const delay = pattern[noteIndex];

        noteIndex++;
        if (noteIndex >= pattern.length) {
          noteIndex = 0;
          patternIndex = (patternIndex + 1) % patterns.length;
        }

        giggleInterval = setTimeout(playNext, delay);
      }

      playNext();
    }

    // Color functions
    function hslToRgb(h, s, l) {
      let r, g, b;
      if (s === 0) {
        r = g = b = l;
      } else {
        const hue2rgb = (p, q, t) => {
          if (t < 0) t += 1;
          if (t > 1) t -= 1;
          if (t < 1/6) return p + (q - p) * 6 * t;
          if (t < 1/2) return q;
          if (t < 2/3) return p + (q - p) * (2/3 - t) * 6;
          return p;
        };
        const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
        const p = 2 * l - q;
        r = hue2rgb(p, q, h + 1/3);
        g = hue2rgb(p, q, h);
        b = hue2rgb(p, q, h - 1/3);
      }
      return [Math.round(r * 255), Math.round(g * 255), Math.round(b * 255)];
    }

    // Mandelbrot
    function mandelbrot(x, y, maxIter) {
      let zr = 0, zi = 0;
      let cr = x, ci = y;
      let iter = 0;

      while (zr * zr + zi * zi < 4 && iter < maxIter) {
        const temp = zr * zr - zi * zi + cr;
        zi = 2 * zr * zi + ci;
        zr = temp;
        iter++;
      }

      if (iter === maxIter) return -1;
      // Smooth coloring
      const log_zn = Math.log(zr * zr + zi * zi) / 2;
      const nu = Math.log(log_zn / Math.log(2)) / Math.log(2);
      return iter + 1 - nu;
    }

    // Julia set
    function julia(x, y, maxIter, cr, ci) {
      let zr = x, zi = y;
      let iter = 0;

      while (zr * zr + zi * zi < 4 && iter < maxIter) {
        const temp = zr * zr - zi * zi + cr;
        zi = 2 * zr * zi + ci;
        zr = temp;
        iter++;
      }

      if (iter === maxIter) return -1;
      return iter;
    }

    // Spiral fractal
    function spiral(x, y, t) {
      const dist = Math.sqrt(x * x + y * y);
      const angle = Math.atan2(y, x);
      const spiral = Math.sin(dist * 10 - t * 2 + angle * 5);
      const rings = Math.sin(dist * 20 + t);
      return (spiral + rings + 2) / 4;
    }

    // Kaleidoscope
    function kaleidoscope(x, y, t, segments = 8) {
      let angle = Math.atan2(y, x);
      const dist = Math.sqrt(x * x + y * y);

      // Mirror segments
      angle = Math.abs(((angle + Math.PI) % (Math.PI * 2 / segments)) - Math.PI / segments);

      const nx = Math.cos(angle) * dist;
      const ny = Math.sin(angle) * dist;

      // Psychedelic pattern
      const pattern = Math.sin(nx * 5 + t) * Math.cos(ny * 5 - t) +
                     Math.sin(dist * 8 - t * 2) +
                     Math.cos(angle * segments + t);

      return (pattern + 3) / 6;
    }

    // Main render
    function render() {
      const imageData = ctx.createImageData(W, H);
      const data = imageData.data;

      // Get audio intensity
      if (analyser && audioData) {
        analyser.getByteFrequencyData(audioData);
        let sum = 0;
        for (let i = 0; i < audioData.length; i++) {
          sum += audioData[i];
        }
        intensity = sum / audioData.length / 255;
      }

      smoothIntensity += (intensity - smoothIntensity) * 0.3;

      // Update intensity meter
      document.getElementById('intensity').style.height = (smoothIntensity * 100) + '%';

      // Dynamic zoom and movement based on audio
      const audioZoom = 1 + smoothIntensity * 0.5;
      const audioWobble = smoothIntensity * 0.1;

      // Animate Julia set parameters
      juliaC.r = -0.7 + Math.sin(time * 0.5) * 0.2;
      juliaC.i = 0.27 + Math.cos(time * 0.3) * 0.1;

      const scale = 3 / (zoom * audioZoom) / Math.min(W, H);
      const maxIter = 50 + Math.floor(smoothIntensity * 50);

      // Render based on mode
      for (let py = 0; py < H; py += 2) {
        for (let px = 0; px < W; px += 2) {
          const x = (px - W / 2) * scale + offsetX + Math.sin(time + py * 0.01) * audioWobble;
          const y = (py - H / 2) * scale + offsetY + Math.cos(time + px * 0.01) * audioWobble;

          let value;

          if (mode === 'mandelbrot') {
            value = mandelbrot(x, y, maxIter);
            if (value < 0) value = 0;
            else value = value / maxIter;
          } else if (mode === 'julia') {
            value = julia(x, y, maxIter, juliaC.r, juliaC.i);
            if (value < 0) value = 0;
            else value = value / maxIter;
          } else if (mode === 'spiral') {
            value = spiral(x * 2, y * 2, time);
          } else if (mode === 'kaleidoscope') {
            value = kaleidoscope(x * 3, y * 3, time, 6 + Math.floor(smoothIntensity * 6));
          }

          // Psychedelic coloring
          const hue = (value * 3 + hueOffset + smoothIntensity) % 1;
          const sat = 0.8 + smoothIntensity * 0.2;
          const light = value * 0.6 + smoothIntensity * 0.3;

          const [r, g, b] = hslToRgb(hue, sat, Math.min(1, light));

          // Set 2x2 block for performance
          for (let dy = 0; dy < 2 && py + dy < H; dy++) {
            for (let dx = 0; dx < 2 && px + dx < W; dx++) {
              const idx = ((py + dy) * W + (px + dx)) * 4;
              data[idx] = r;
              data[idx + 1] = g;
              data[idx + 2] = b;
              data[idx + 3] = 255;
            }
          }
        }
      }

      ctx.putImageData(imageData, 0, 0);

      // Overlay effects
      ctx.globalCompositeOperation = 'screen';
      const gradient = ctx.createRadialGradient(W/2, H/2, 0, W/2, H/2, Math.max(W, H) / 2);
      gradient.addColorStop(0, `rgba(255, 255, 255, ${smoothIntensity * 0.3})`);
      gradient.addColorStop(1, 'transparent');
      ctx.fillStyle = gradient;
      ctx.fillRect(0, 0, W, H);
      ctx.globalCompositeOperation = 'source-over';

      // Update state
      time += 0.02;
      hueOffset += 0.002 + smoothIntensity * 0.01;
      zoom += Math.sin(time * 0.5) * 0.001;
      zoom = Math.max(0.5, Math.min(3, zoom));
    }

    function animate() {
      render();
      requestAnimationFrame(animate);
    }

    // Start
    function startExperience() {
      audioCtx = new (window.AudioContext || window.webkitAudioContext)();
      analyser = audioCtx.createAnalyser();
      analyser.fftSize = 256;
      audioData = new Uint8Array(analyser.frequencyBinCount);

      document.getElementById('start-overlay').classList.add('hidden');

      startGiggleTrack();
      animate();
    }

    document.getElementById('start-btn').addEventListener('click', startExperience);

    // Mode buttons
    document.querySelectorAll('.ctrl-btn').forEach(btn => {
      btn.addEventListener('click', () => {
        document.querySelectorAll('.ctrl-btn').forEach(b => b.classList.remove('active'));
        btn.classList.add('active');
        mode = btn.dataset.mode;

        // Reset view for different modes
        if (mode === 'mandelbrot') {
          offsetX = -0.5;
          offsetY = 0;
          zoom = 1;
        } else if (mode === 'julia') {
          offsetX = 0;
          offsetY = 0;
          zoom = 1;
        } else {
          offsetX = 0;
          offsetY = 0;
          zoom = 1;
        }
      });
    });

    // Draw initial static frame
    ctx.fillStyle = '#000';
    ctx.fillRect(0, 0, W, H);
    ctx.fillStyle = '#333';
    ctx.font = '20px Quicksand';
    ctx.textAlign = 'center';
    ctx.fillText('Click to begin...', W/2, H/2);
  </script>
<script src="/sloppy-header/sloppy-bar.js"></script>
</body>
</html>
