<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Confetti Cannon</title>
  <link rel="icon" href="https://emojicdn.elk.sh/ðŸŽ‰">
  <meta property="og:title" content="Confetti Cannon">
  <meta property="og:description" content="Blast neon confetti with physics-based collisions">
  <meta property="og:url" content="https://sloppy.live/confetti-cannon">
  <meta property="og:image" content="https://emojicdn.elk.sh/ðŸŽ‰?style=apple&size=512">
  <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@700&display=swap" rel="stylesheet">
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }

    body {
      min-height: 100vh;
      background: #0a0a12;
      overflow: hidden;
      font-family: 'Orbitron', sans-serif;
    }

    canvas {
      display: block;
      cursor: crosshair;
    }

    .hud {
      position: fixed;
      top: 1rem;
      left: 1rem;
      color: #0ff;
      font-size: 0.7rem;
      text-shadow: 0 0 10px #0ff;
      z-index: 100;
    }

    .hud div { margin-bottom: 0.3rem; }
    .hud span { color: #fff; }

    .controls {
      position: fixed;
      top: 1rem;
      right: 1rem;
      display: flex;
      flex-direction: column;
      gap: 0.5rem;
      z-index: 100;
    }

    .btn {
      font-family: 'Orbitron', sans-serif;
      font-size: 0.65rem;
      padding: 0.5rem 1rem;
      background: rgba(0, 0, 0, 0.7);
      border: 1px solid #f0f;
      color: #f0f;
      border-radius: 4px;
      cursor: pointer;
      text-transform: uppercase;
      transition: all 0.2s;
    }

    .btn:hover {
      background: #f0f;
      color: #000;
      box-shadow: 0 0 20px #f0f;
    }

    .hint {
      position: fixed;
      bottom: 2rem;
      left: 50%;
      transform: translateX(-50%);
      color: #666;
      font-size: 0.65rem;
      text-align: center;
      pointer-events: none;
    }

    .info {
      position: fixed;
      bottom: 0.8rem;
      left: 50%;
      transform: translateX(-50%);
      font-size: 0.5rem;
      color: #333;
    }

    .info a { color: #444; text-decoration: none; }

    .slider-group {
      display: flex;
      align-items: center;
      gap: 0.5rem;
      background: rgba(0, 0, 0, 0.7);
      padding: 0.4rem 0.6rem;
      border-radius: 4px;
      border: 1px solid #333;
    }

    .slider-group label {
      font-size: 0.55rem;
      color: #888;
      min-width: 50px;
    }

    input[type="range"] {
      width: 80px;
      accent-color: #0ff;
    }
  </style>
</head>
<body>
  <canvas id="canvas"></canvas>

  <div class="hud">
    <div>PARTICLES: <span id="count">0</span></div>
    <div>FPS: <span id="fps">60</span></div>
    <div>COLLISIONS: <span id="collisions">0</span></div>
  </div>

  <div class="controls">
    <button class="btn" id="burst">MEGA BURST</button>
    <button class="btn" id="clear">CLEAR ALL</button>
    <div class="slider-group">
      <label>GRAVITY</label>
      <input type="range" id="gravity" min="0" max="2" step="0.1" value="0.5">
    </div>
    <div class="slider-group">
      <label>BOUNCE</label>
      <input type="range" id="bounce" min="0" max="1" step="0.1" value="0.7">
    </div>
  </div>

  <div class="hint">Click & drag to fire confetti â€¢ Hold for continuous blast</div>

  <div class="info"><a href="https://sloppy.live">sloppy.live</a></div>

  <script>
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');

    let width = canvas.width = window.innerWidth;
    let height = canvas.height = window.innerHeight;

    // Physics settings
    let gravity = 0.5;
    let bounceFactor = 0.7;
    const friction = 0.99;
    const airResistance = 0.998;

    // Neon colors
    const colors = [
      '#ff00ff', '#00ffff', '#ff0066', '#00ff66',
      '#ffff00', '#ff6600', '#6600ff', '#00ff99',
      '#ff0099', '#99ff00', '#0066ff', '#ff3300'
    ];

    // Particle pool for performance
    const MAX_PARTICLES = 3000;
    const particles = [];
    let activeCount = 0;
    let collisionCount = 0;

    // Spatial hash for collision detection
    const CELL_SIZE = 30;
    let grid = new Map();

    class Particle {
      constructor() {
        this.active = false;
        this.x = 0;
        this.y = 0;
        this.vx = 0;
        this.vy = 0;
        this.size = 8;
        this.color = colors[0];
        this.rotation = 0;
        this.rotationSpeed = 0;
        this.shape = 0; // 0: rect, 1: circle, 2: triangle
        this.mass = 1;
        this.life = 1;
      }

      init(x, y, vx, vy) {
        this.active = true;
        this.x = x;
        this.y = y;
        this.vx = vx;
        this.vy = vy;
        this.size = 5 + Math.random() * 10;
        this.color = colors[Math.floor(Math.random() * colors.length)];
        this.rotation = Math.random() * Math.PI * 2;
        this.rotationSpeed = (Math.random() - 0.5) * 0.3;
        this.shape = Math.floor(Math.random() * 3);
        this.mass = this.size * 0.1;
        this.life = 1;
      }

      update() {
        if (!this.active) return;

        // Apply physics
        this.vy += gravity;
        this.vx *= airResistance;
        this.vy *= airResistance;

        this.x += this.vx;
        this.y += this.vy;
        this.rotation += this.rotationSpeed;

        // Floor collision
        if (this.y + this.size > height) {
          this.y = height - this.size;
          this.vy *= -bounceFactor;
          this.vx *= friction;
          this.rotationSpeed *= 0.8;

          if (Math.abs(this.vy) < 0.5) {
            this.vy = 0;
            this.life -= 0.01;
          }
        }

        // Wall collisions
        if (this.x < this.size) {
          this.x = this.size;
          this.vx *= -bounceFactor;
        } else if (this.x + this.size > width) {
          this.x = width - this.size;
          this.vx *= -bounceFactor;
        }

        // Ceiling
        if (this.y < this.size) {
          this.y = this.size;
          this.vy *= -bounceFactor;
        }

        // Fade out settled particles
        if (this.y >= height - this.size - 1 && Math.abs(this.vx) < 0.1) {
          this.life -= 0.005;
        }

        if (this.life <= 0) {
          this.active = false;
        }
      }

      draw() {
        if (!this.active) return;

        ctx.save();
        ctx.translate(this.x, this.y);
        ctx.rotate(this.rotation);
        ctx.globalAlpha = this.life;

        // Glow effect
        ctx.shadowColor = this.color;
        ctx.shadowBlur = 10;
        ctx.fillStyle = this.color;

        const s = this.size;

        switch (this.shape) {
          case 0: // Rectangle
            ctx.fillRect(-s / 2, -s / 4, s, s / 2);
            break;
          case 1: // Circle
            ctx.beginPath();
            ctx.arc(0, 0, s / 2, 0, Math.PI * 2);
            ctx.fill();
            break;
          case 2: // Triangle
            ctx.beginPath();
            ctx.moveTo(0, -s / 2);
            ctx.lineTo(s / 2, s / 2);
            ctx.lineTo(-s / 2, s / 2);
            ctx.closePath();
            ctx.fill();
            break;
        }

        ctx.restore();
      }

      getCell() {
        return `${Math.floor(this.x / CELL_SIZE)},${Math.floor(this.y / CELL_SIZE)}`;
      }
    }

    // Initialize particle pool
    for (let i = 0; i < MAX_PARTICLES; i++) {
      particles.push(new Particle());
    }

    function getInactiveParticle() {
      for (let i = 0; i < particles.length; i++) {
        if (!particles[i].active) return particles[i];
      }
      return null;
    }

    function spawnConfetti(x, y, count = 20, spread = 15, power = 15) {
      for (let i = 0; i < count; i++) {
        const p = getInactiveParticle();
        if (!p) break;

        const angle = -Math.PI / 2 + (Math.random() - 0.5) * spread * 0.1;
        const speed = power * (0.5 + Math.random() * 0.5);

        p.init(
          x + (Math.random() - 0.5) * 20,
          y + (Math.random() - 0.5) * 20,
          Math.cos(angle) * speed + (Math.random() - 0.5) * 5,
          Math.sin(angle) * speed
        );
      }
    }

    function buildSpatialHash() {
      grid.clear();

      for (const p of particles) {
        if (!p.active) continue;

        const cell = p.getCell();
        if (!grid.has(cell)) {
          grid.set(cell, []);
        }
        grid.get(cell).push(p);
      }
    }

    function checkCollisions() {
      buildSpatialHash();
      let collisions = 0;

      for (const p of particles) {
        if (!p.active) continue;

        const cx = Math.floor(p.x / CELL_SIZE);
        const cy = Math.floor(p.y / CELL_SIZE);

        // Check neighboring cells
        for (let dx = -1; dx <= 1; dx++) {
          for (let dy = -1; dy <= 1; dy++) {
            const cell = `${cx + dx},${cy + dy}`;
            const neighbors = grid.get(cell);
            if (!neighbors) continue;

            for (const other of neighbors) {
              if (other === p || !other.active) continue;

              const diffX = other.x - p.x;
              const diffY = other.y - p.y;
              const dist = Math.sqrt(diffX * diffX + diffY * diffY);
              const minDist = (p.size + other.size) / 2;

              if (dist < minDist && dist > 0) {
                collisions++;

                // Collision response
                const nx = diffX / dist;
                const ny = diffY / dist;

                // Relative velocity
                const dvx = p.vx - other.vx;
                const dvy = p.vy - other.vy;
                const dvn = dvx * nx + dvy * ny;

                // Don't resolve if separating
                if (dvn > 0) continue;

                // Impulse scalar
                const restitution = 0.8;
                const totalMass = p.mass + other.mass;
                const impulse = (-(1 + restitution) * dvn) / totalMass;

                // Apply impulse
                p.vx -= impulse * other.mass * nx;
                p.vy -= impulse * other.mass * ny;
                other.vx += impulse * p.mass * nx;
                other.vy += impulse * p.mass * ny;

                // Separate particles
                const overlap = minDist - dist;
                const separateX = overlap * nx * 0.5;
                const separateY = overlap * ny * 0.5;

                p.x -= separateX;
                p.y -= separateY;
                other.x += separateX;
                other.y += separateY;
              }
            }
          }
        }
      }

      return collisions;
    }

    // FPS tracking
    let lastTime = performance.now();
    let frameCount = 0;
    let fps = 60;

    function updateFPS() {
      frameCount++;
      const now = performance.now();
      if (now - lastTime >= 1000) {
        fps = frameCount;
        frameCount = 0;
        lastTime = now;
        document.getElementById('fps').textContent = fps;
      }
    }

    function update() {
      activeCount = 0;

      for (const p of particles) {
        if (p.active) {
          p.update();
          activeCount++;
        }
      }

      // Only check collisions if reasonable particle count
      if (activeCount < 1500) {
        collisionCount += checkCollisions();
      }

      document.getElementById('count').textContent = activeCount;
      document.getElementById('collisions').textContent = collisionCount;
    }

    function draw() {
      // Clear with slight trail
      ctx.fillStyle = 'rgba(10, 10, 18, 0.2)';
      ctx.fillRect(0, 0, width, height);

      for (const p of particles) {
        p.draw();
      }
    }

    function animate() {
      update();
      draw();
      updateFPS();
      requestAnimationFrame(animate);
    }

    // Input handling
    let isMouseDown = false;
    let mouseX = 0, mouseY = 0;

    canvas.addEventListener('mousedown', (e) => {
      isMouseDown = true;
      mouseX = e.clientX;
      mouseY = e.clientY;
      spawnConfetti(mouseX, mouseY, 30, 20, 18);
    });

    canvas.addEventListener('mousemove', (e) => {
      mouseX = e.clientX;
      mouseY = e.clientY;
      if (isMouseDown) {
        spawnConfetti(mouseX, mouseY, 5, 15, 12);
      }
    });

    canvas.addEventListener('mouseup', () => isMouseDown = false);
    canvas.addEventListener('mouseleave', () => isMouseDown = false);

    // Touch support
    canvas.addEventListener('touchstart', (e) => {
      e.preventDefault();
      isMouseDown = true;
      mouseX = e.touches[0].clientX;
      mouseY = e.touches[0].clientY;
      spawnConfetti(mouseX, mouseY, 30, 20, 18);
    });

    canvas.addEventListener('touchmove', (e) => {
      e.preventDefault();
      mouseX = e.touches[0].clientX;
      mouseY = e.touches[0].clientY;
      if (isMouseDown) {
        spawnConfetti(mouseX, mouseY, 5, 15, 12);
      }
    });

    canvas.addEventListener('touchend', () => isMouseDown = false);

    // Controls
    document.getElementById('burst').addEventListener('click', () => {
      for (let i = 0; i < 5; i++) {
        setTimeout(() => {
          spawnConfetti(
            Math.random() * width,
            height,
            100,
            30,
            25
          );
        }, i * 100);
      }
    });

    document.getElementById('clear').addEventListener('click', () => {
      for (const p of particles) {
        p.active = false;
      }
      collisionCount = 0;
    });

    document.getElementById('gravity').addEventListener('input', (e) => {
      gravity = parseFloat(e.target.value);
    });

    document.getElementById('bounce').addEventListener('input', (e) => {
      bounceFactor = parseFloat(e.target.value);
    });

    window.addEventListener('resize', () => {
      width = canvas.width = window.innerWidth;
      height = canvas.height = window.innerHeight;
    });

    // Start
    animate();
  </script>
</body>
</html>
