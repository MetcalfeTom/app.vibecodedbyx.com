<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Layer Sovereign â€” Universal Schema Dashboard</title>
  <link rel="icon" href="https://emojicdn.elk.sh/ðŸ”·">
  <meta property="og:title" content="Layer Sovereign">
  <meta property="og:description" content="Neon cyberpunk dashboard visualizing 5 universal database layers in real-time.">
  <meta property="og:url" content="https://sloppy.live/layer-sovereign">
  <meta property="og:image" content="https://image.pollinations.ai/prompt/cyberpunk%20neon%20pentagon%20data%20visualization%20dashboard%20with%20cyan%20grid%20and%20glowing%20nodes%20tron%20aesthetic%20dark%20background?width=1200&height=630&nologo=true&referrer=sloppy.live">
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link href="https://fonts.googleapis.com/css2?family=Chakra+Petch:wght@300;600;700&family=Azeret+Mono:wght@300;400;500&display=swap" rel="stylesheet">
  <style>
    *{margin:0;padding:0;box-sizing:border-box}
    :root{
      --bg:#05080f;--surface:#0a0e18;--surface2:#0f1524;--border:#152035;
      --cyan:#00e5ff;--cyan-dim:rgba(0,229,255,.15);--cyan-glow:rgba(0,229,255,.3);
      --pink:#ff2d78;--gold:#ffe14d;--violet:#b44dff;--green:#39ff7a;
      --text:#c8d8e8;--text-dim:#4a5a6a;
      --font-head:'Chakra Petch',sans-serif;--font-data:'Azeret Mono',monospace;
    }
    html{font-size:14px}
    body{background:var(--bg);color:var(--text);font-family:var(--font-data);min-height:100vh;overflow-x:hidden;position:relative}
    /* Cyan grid overlay */
    body::before{content:'';position:fixed;inset:0;
      background:
        linear-gradient(rgba(0,229,255,.03) 1px,transparent 1px),
        linear-gradient(90deg,rgba(0,229,255,.03) 1px,transparent 1px);
      background-size:60px 60px;pointer-events:none;z-index:0}
    /* Scanlines */
    body::after{content:'';position:fixed;inset:0;
      background:repeating-linear-gradient(0deg,transparent,transparent 2px,rgba(0,0,0,.08) 2px,rgba(0,0,0,.08) 4px);
      pointer-events:none;z-index:9999}

    .container{max-width:1100px;margin:0 auto;padding:1rem;position:relative;z-index:1}

    /* Header */
    header{display:flex;align-items:center;justify-content:space-between;padding:1.2rem 0 .8rem;border-bottom:1px solid var(--border);margin-bottom:1.2rem;flex-wrap:wrap;gap:.5rem}
    h1{font-family:var(--font-head);font-weight:700;font-size:1.5rem;color:var(--cyan);text-shadow:0 0 20px var(--cyan-glow);letter-spacing:4px;text-transform:uppercase}
    .pulse-wrap{display:flex;align-items:center;gap:8px;font-size:.7rem;color:var(--text-dim)}
    .pulse-dot{width:8px;height:8px;border-radius:50%;background:var(--cyan);box-shadow:0 0 8px var(--cyan);animation:breathe 2s ease-in-out infinite}
    @keyframes breathe{0%,100%{opacity:1;transform:scale(1)}50%{opacity:.4;transform:scale(.8)}}
    .total-badge{font-family:var(--font-head);font-weight:600;font-size:.85rem;color:var(--cyan);margin-left:4px}

    /* Canvas */
    .canvas-wrap{background:var(--surface);border:1px solid var(--border);border-radius:8px;margin-bottom:1.2rem;position:relative;overflow:hidden}
    #pentCanvas{width:100%;height:380px;display:block}

    /* Layer Cards Grid */
    .layers-grid{display:grid;grid-template-columns:repeat(5,1fr);gap:.75rem;margin-bottom:1.2rem}
    @media(max-width:768px){.layers-grid{grid-template-columns:repeat(3,1fr)}}
    @media(max-width:480px){.layers-grid{grid-template-columns:1fr 1fr}}

    .layer-card{background:var(--surface);border:1px solid var(--border);border-radius:8px;padding:.8rem;cursor:pointer;position:relative;overflow:hidden;transition:border-color .2s,box-shadow .2s}
    .layer-card:hover{box-shadow:0 0 20px rgba(0,229,255,.08)}
    .layer-card::before{content:'';position:absolute;top:0;left:0;right:0;height:2px}
    .layer-card[data-layer="identity"]::before{background:var(--pink)}
    .layer-card[data-layer="identity"]:hover{border-color:var(--pink)}
    .layer-card[data-layer="social"]::before{background:var(--cyan)}
    .layer-card[data-layer="social"]:hover{border-color:var(--cyan)}
    .layer-card[data-layer="economy"]::before{background:var(--gold)}
    .layer-card[data-layer="economy"]:hover{border-color:var(--gold)}
    .layer-card[data-layer="gov"]::before{background:var(--violet)}
    .layer-card[data-layer="gov"]:hover{border-color:var(--violet)}
    .layer-card[data-layer="world"]::before{background:var(--green)}
    .layer-card[data-layer="world"]:hover{border-color:var(--green)}

    .layer-label{font-family:var(--font-head);font-weight:600;font-size:.75rem;letter-spacing:2px;text-transform:uppercase;margin-bottom:.3rem}
    .layer-card[data-layer="identity"] .layer-label{color:var(--pink)}
    .layer-card[data-layer="social"] .layer-label{color:var(--cyan)}
    .layer-card[data-layer="economy"] .layer-label{color:var(--gold)}
    .layer-card[data-layer="gov"] .layer-label{color:var(--violet)}
    .layer-card[data-layer="world"] .layer-label{color:var(--green)}

    .layer-count{font-family:var(--font-head);font-weight:700;font-size:1.8rem;color:var(--text);line-height:1.1}
    .layer-sub{font-size:.65rem;color:var(--text-dim);margin-top:.2rem}
    .table-badge{font-size:.6rem;padding:2px 6px;border-radius:3px;background:var(--cyan-dim);color:var(--cyan);display:inline-block;margin-top:.3rem}

    /* Expanded detail */
    .layer-detail{display:none;margin-top:.6rem;border-top:1px solid var(--border);padding-top:.5rem}
    .layer-card.expanded .layer-detail{display:block}
    .table-row{display:flex;justify-content:space-between;align-items:center;padding:3px 0;font-size:.65rem;border-bottom:1px solid rgba(255,255,255,.03)}
    .table-row:last-child{border-bottom:none}
    .table-name{color:var(--text-dim);flex:1;overflow:hidden;text-overflow:ellipsis;white-space:nowrap}
    .table-count{color:var(--text);font-weight:500;min-width:40px;text-align:right}
    .table-owner{font-size:.55rem;color:var(--text-dim);opacity:.6;margin-left:6px;white-space:nowrap}

    /* Pulse Feed */
    .section-title{font-family:var(--font-head);font-weight:600;font-size:.8rem;color:var(--cyan);letter-spacing:2px;text-transform:uppercase;margin-bottom:.6rem}
    .pulse-feed{background:var(--surface);border:1px solid var(--border);border-radius:8px;padding:.8rem;max-height:200px;overflow-y:auto;margin-bottom:1rem}
    .pulse-feed::-webkit-scrollbar{width:4px}
    .pulse-feed::-webkit-scrollbar-thumb{background:var(--border);border-radius:2px}
    .pulse-item{padding:6px 8px;border-left:2px solid var(--cyan);margin-bottom:6px;font-size:.65rem;color:var(--text-dim);line-height:1.3;border-radius:0 4px 4px 0;background:rgba(0,229,255,.02)}
    .pulse-item .pulse-type{font-weight:500;color:var(--cyan);text-transform:uppercase;font-size:.6rem;letter-spacing:1px}
    .pulse-item .pulse-time{float:right;opacity:.5;font-size:.58rem}
    .pulse-empty{text-align:center;color:var(--text-dim);font-size:.7rem;padding:1.5rem 0;opacity:.5}

    /* Backlink */
    .backlink{text-align:center;padding:1rem 0;font-size:.65rem}
    .backlink a{color:var(--text-dim);text-decoration:none;transition:color .2s}
    .backlink a:hover{color:var(--cyan)}

    /* Loading shimmer */
    .shimmer{background:linear-gradient(90deg,transparent 0%,rgba(0,229,255,.04) 50%,transparent 100%);background-size:200% 100%;animation:shimmer 1.5s infinite}
    @keyframes shimmer{0%{background-position:200% 0}100%{background-position:-200% 0}}

    /* Expand arrow */
    .expand-arrow{font-size:.6rem;color:var(--text-dim);float:right;transition:transform .2s}
    .layer-card.expanded .expand-arrow{transform:rotate(180deg)}
  </style>
</head>
<body>
  <div class="container">
    <header>
      <h1>Layer Sovereign</h1>
      <div class="pulse-wrap">
        <span class="pulse-dot"></span>
        <span id="statusText">Connecting...</span>
        <span class="total-badge" id="totalBadge">â€”</span>
      </div>
    </header>

    <div class="canvas-wrap">
      <canvas id="pentCanvas"></canvas>
    </div>

    <div class="layers-grid" id="layersGrid"></div>

    <div class="section-title">Ecosystem Pulse</div>
    <div class="pulse-feed" id="pulseFeed">
      <div class="pulse-empty">Awaiting signal...</div>
    </div>

    <div class="backlink"><a href="https://sloppy.live">sloppy.live</a></div>
  </div>

<script type="module">
import { createBrowserClient } from "https://cdn.jsdelivr.net/npm/@supabase/ssr@0.7.0/+esm";

const SUPABASE_URL = 'https://yjyxteqzhhmtrgcaekgz.supabase.co';
const SUPABASE_ANON_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InlqeXh0ZXF6aGhtdHJnY2Fla2d6Iiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTczNTg3NDIsImV4cCI6MjA3MjkzNDc0Mn0.G8SRde7IN2QFW1EnASM8IS32IUYR2eenCCjdDdioiBU';

// Cookie domain: must match supabase-config.js canonical pattern exactly.
// .sloppy.live covers app.sloppy.live + www.sloppy.live (SSO).
// .youreabsolutelyright.xyz is the Cloudflare origin domain.
const getCookieDomain = () => {
  const h = location.hostname;
  if (h.includes('sloppy.live')) return '.sloppy.live';
  if (h.includes('vibecodedbyx.com')) return '.vibecodedbyx.com';
  if (h.includes('youreabsolutelyright.xyz')) return '.youreabsolutelyright.xyz';
  return h; // localhost or unknown
};

const cookieDomain = getCookieDomain();
console.log('[layer-sovereign] hostname:', location.hostname, 'â†’ cookie domain:', cookieDomain);

const sb = createBrowserClient(SUPABASE_URL, SUPABASE_ANON_KEY, {
  cookieOptions: { name: 'sb-auth-token', domain: cookieDomain, path: '/', sameSite: 'lax' }
});

// Ensure session â€” validates JWT is usable
async function ensureSession() {
  try {
    const { data, error } = await sb.auth.getSession();
    if (error) console.warn('[auth] getSession error:', error.message);
    if (data?.session?.access_token) {
      console.log('[auth] existing session, user:', data.session.user?.id?.slice(0, 8));
      return data.session;
    }

    console.log('[auth] no existing session, signing in anonymously...');
    const { data: signData, error: signErr } = await sb.auth.signInAnonymously();
    if (signErr) {
      console.error('[auth] signInAnonymously error:', signErr.message, signErr.status);
      throw signErr;
    }
    if (signData?.session?.access_token) {
      console.log('[auth] anon session created, user:', signData.session.user?.id?.slice(0, 8));
      return signData.session;
    }
    console.warn('[auth] signInAnonymously returned no session/token');
    return null;
  } catch (e) {
    console.error('[auth] failed:', e.message);
    // Retry once after brief delay
    try {
      await new Promise(r => setTimeout(r, 1500));
      console.log('[auth] retrying signInAnonymously...');
      const { data, error } = await sb.auth.signInAnonymously();
      if (error) console.error('[auth] retry error:', error.message);
      if (data?.session?.access_token) {
        console.log('[auth] retry succeeded, user:', data.session.user?.id?.slice(0, 8));
        return data.session;
      }
      return null;
    } catch (e2) {
      console.error('[auth] retry failed:', e2.message);
      return null;
    }
  }
}

// â”€â”€ Layer definitions â”€â”€
// Maps logical layer names to physical sloppygram_* table names + owner
const LAYERS = {
  identity: {
    color: '#ff2d78', label: 'Identity', desc: 'Who you are',
    tables: [
      { name: 'sloppygram_profiles', label: 'profiles', owner: 'sloppy-id' }
    ]
  },
  social: {
    color: '#00e5ff', label: 'Social', desc: 'How you connect',
    tables: [
      { name: 'sloppygram_follows', label: 'follows', owner: 'sloppygram' },
      { name: 'sloppygram_mentions', label: 'mentions', owner: 'sloppygram' },
      { name: 'sloppygram_dm_conversations', label: 'dm_conversations', owner: 'sloppy-id' },
      { name: 'sloppygram_dm_messages', label: 'dm_messages', owner: 'sloppy-id' },
      { name: 'sloppygram_group_conversations', label: 'group_conversations', owner: 'sloppy-groups' },
      { name: 'sloppygram_group_members', label: 'group_members', owner: 'sloppy-groups' },
      { name: 'sloppygram_group_messages', label: 'group_messages', owner: 'sloppy-groups' },
      { name: 'sloppygram_posts', label: 'posts', owner: 'sloppy-feed' },
      { name: 'sloppygram_messages', label: 'messages', owner: 'sloppy-chat' },
      { name: 'sloppygram_manifestos', label: 'manifestos', owner: 'sloppy-manifestos' },
      { name: 'sloppygram_post_comments', label: 'post_comments', owner: 'sloppy-feed' },
      { name: 'sloppygram_manifesto_comments', label: 'manifesto_comments', owner: 'sloppy-manifestos' },
      { name: 'sloppygram_comment_threads', label: 'comment_threads', owner: 'sloppy-feed' },
      { name: 'sloppygram_doodle_comments', label: 'doodle_comments', owner: 'sloppygram' }
    ]
  },
  economy: {
    color: '#ffe14d', label: 'Economy', desc: 'Value signals',
    tables: [
      { name: 'sloppygram_karma', label: 'karma', owner: 'sloppy-quests' },
      { name: 'sloppygram_badges', label: 'badges', owner: 'sloppy-celebrate' },
      { name: 'sloppygram_post_likes', label: 'post_likes', owner: 'sloppy-feed' },
      { name: 'sloppygram_post_reactions', label: 'post_reactions', owner: 'sloppy-feed' },
      { name: 'sloppygram_post_tags', label: 'post_tags', owner: 'sloppy-feed' },
      { name: 'sloppygram_comment_votes', label: 'comment_votes', owner: 'sloppy-feed' },
      { name: 'sloppygram_message_votes', label: 'message_votes', owner: 'sloppy-chat' },
      { name: 'sloppygram_message_reactions', label: 'message_reactions', owner: 'sloppy-chat' },
      { name: 'sloppygram_message_tags', label: 'message_tags', owner: 'sloppy-chat' },
      { name: 'sloppygram_manifesto_votes', label: 'manifesto_votes', owner: 'sloppy-manifestos' },
      { name: 'sloppygram_manifesto_reactions', label: 'manifesto_reactions', owner: 'sloppy-manifestos' },
      { name: 'sloppygram_manifesto_tags', label: 'manifesto_tags', owner: 'sloppy-manifestos' },
      { name: 'sloppygram_manifesto_lineage', label: 'manifesto_lineage', owner: 'sloppy-manifestos' },
      { name: 'sloppygram_doodle_votes', label: 'doodle_votes', owner: 'sloppygram' }
    ]
  },
  gov: {
    color: '#b44dff', label: 'Gov', desc: 'Governance & territory',
    tables: [
      { name: 'sloppygram_factions', label: 'factions', owner: 'sloppy-factions' },
      { name: 'sloppygram_faction_members', label: 'faction_members', owner: 'sloppy-factions' },
      { name: 'sloppygram_faction_battles', label: 'faction_battles', owner: 'sloppy-factions' },
      { name: 'sloppygram_territories', label: 'territories', owner: 'sloppy-factions' },
      { name: 'sloppygram_global_settings', label: 'global_settings', owner: 'sloppygram' },
      { name: 'sloppygram_global_backgrounds', label: 'global_backgrounds', owner: 'sloppygram' }
    ]
  },
  world: {
    color: '#39ff7a', label: 'World', desc: 'Shared environment',
    tables: [
      { name: 'sloppygram_collab_strokes', label: 'collab_strokes', owner: 'sloppy-canvas' },
      { name: 'sloppygram_collab_documents', label: 'collab_documents', owner: 'sloppy-collab' },
      { name: 'sloppygram_radio', label: 'radio', owner: 'sloppy-radio' }
    ]
  }
};

const LAYER_ORDER = ['identity', 'social', 'economy', 'gov', 'world'];

// â”€â”€ State â”€â”€
let layerCounts = {};  // { identity: { total: N, tables: { name: count } }, ... }
let totalRows = 0;
let pulseItems = [];
const MAX_PULSE = 30;

// â”€â”€ Single table count with GET fallback â”€â”€
async function countTable(tableName) {
  // Primary: HEAD-based count (zero data transfer)
  const res = await sb.from(tableName).select('*', { count: 'exact', head: true });
  if (!res.error && res.count != null) return res.count;

  // Log the HEAD failure
  if (res.error) console.warn(`HEAD count error [${tableName}]:`, res.error.message, res.error.code);
  else console.warn(`HEAD count null [${tableName}], falling back to GET`);

  // Fallback: GET-based count (returns 1 row max but accurate total count)
  const res2 = await sb.from(tableName).select('user_id', { count: 'exact' }).limit(1);
  if (!res2.error && res2.count != null) return res2.count;

  if (res2.error) console.error(`GET count error [${tableName}]:`, res2.error.message, res2.error.code);
  return 0;
}

// â”€â”€ Fetch counts in batches to avoid connection pool exhaustion â”€â”€
async function fetchAllCounts() {
  // Build flat list of { layerKey, table }
  const jobs = [];
  for (const [layerKey, layer] of Object.entries(LAYERS)) {
    for (const t of layer.tables) {
      jobs.push({ layer: layerKey, table: t.name });
    }
  }

  const results = [];
  const BATCH = 8;
  for (let i = 0; i < jobs.length; i += BATCH) {
    const batch = jobs.slice(i, i + BATCH);
    const batchResults = await Promise.all(
      batch.map(j =>
        countTable(j.table)
          .then(count => ({ layer: j.layer, table: j.table, count }))
          .catch(() => ({ layer: j.layer, table: j.table, count: 0 }))
      )
    );
    results.push(...batchResults);
  }

  layerCounts = {};
  totalRows = 0;
  for (const lk of LAYER_ORDER) {
    layerCounts[lk] = { total: 0, tables: {} };
  }
  for (const r of results) {
    layerCounts[r.layer].tables[r.table] = r.count;
    layerCounts[r.layer].total += r.count;
    totalRows += r.count;
  }
}

// â”€â”€ Fetch pulse events â”€â”€
async function fetchPulseEvents() {
  const { data } = await sb.from('ai_events').select('*').order('created_at', { ascending: false }).limit(20);
  if (data) {
    pulseItems = data.map(e => ({
      type: e.event_type || e.type || 'event',
      content: e.content || e.message || e.description || JSON.stringify(e).slice(0, 120),
      time: e.created_at,
      layer: guessLayer(e)
    }));
  }
}

function guessLayer(ev) {
  const s = JSON.stringify(ev).toLowerCase();
  if (s.includes('profile') || s.includes('identity')) return 'identity';
  if (s.includes('faction') || s.includes('territory') || s.includes('gov')) return 'gov';
  if (s.includes('karma') || s.includes('badge') || s.includes('vote') || s.includes('react')) return 'economy';
  if (s.includes('canvas') || s.includes('radio') || s.includes('collab') || s.includes('world')) return 'world';
  return 'social';
}

// â”€â”€ Render Layer Cards â”€â”€
function renderCards() {
  const grid = document.getElementById('layersGrid');
  grid.innerHTML = '';
  for (const lk of LAYER_ORDER) {
    const layer = LAYERS[lk];
    const counts = layerCounts[lk] || { total: 0, tables: {} };
    const card = document.createElement('div');
    card.className = 'layer-card';
    card.dataset.layer = lk;
    card.innerHTML = `
      <div class="layer-label">${layer.label} <span class="expand-arrow">&#9660;</span></div>
      <div class="layer-count">${counts.total.toLocaleString()}</div>
      <div class="layer-sub">${layer.desc}</div>
      <span class="table-badge">${layer.tables.length} tables</span>
      <div class="layer-detail">
        ${layer.tables.map(t => `
          <div class="table-row">
            <span class="table-name">${t.label}</span>
            <span class="table-count">${(counts.tables[t.name] || 0).toLocaleString()}</span>
            <span class="table-owner">${t.owner}</span>
          </div>
        `).join('')}
      </div>
    `;
    card.addEventListener('click', () => card.classList.toggle('expanded'));
    grid.appendChild(card);
  }
}

// â”€â”€ Render Pulse Feed â”€â”€
function renderPulse() {
  const feed = document.getElementById('pulseFeed');
  if (!pulseItems.length) {
    feed.innerHTML = '<div class="pulse-empty">No ecosystem events yet</div>';
    return;
  }
  feed.innerHTML = pulseItems.slice(0, MAX_PULSE).map(p => {
    const layerColor = LAYERS[p.layer]?.color || '#00e5ff';
    const ago = timeAgo(p.time);
    const text = typeof p.content === 'string' ? p.content.slice(0, 140) : '';
    return `<div class="pulse-item" style="border-left-color:${layerColor}">
      <span class="pulse-type" style="color:${layerColor}">${p.type}</span>
      <span class="pulse-time">${ago}</span><br>
      ${text}
    </div>`;
  }).join('');
}

function timeAgo(ts) {
  if (!ts) return '';
  const diff = (Date.now() - new Date(ts).getTime()) / 1000;
  if (diff < 60) return `${Math.floor(diff)}s`;
  if (diff < 3600) return `${Math.floor(diff / 60)}m`;
  if (diff < 86400) return `${Math.floor(diff / 3600)}h`;
  return `${Math.floor(diff / 86400)}d`;
}

// â”€â”€ Canvas Pentagon â”€â”€
const canvas = document.getElementById('pentCanvas');
const ctx = canvas.getContext('2d');
let cW, cH, dpr;
let particles = [];
const PARTICLE_COUNT = 80;

function resizeCanvas() {
  dpr = window.devicePixelRatio || 1;
  const rect = canvas.parentElement.getBoundingClientRect();
  cW = rect.width;
  cH = 380;
  canvas.width = cW * dpr;
  canvas.height = cH * dpr;
  canvas.style.height = cH + 'px';
  ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
}

function getNodePositions() {
  const cx = cW / 2;
  const cy = cH / 2;
  const radius = Math.min(cW, cH) * 0.34;
  return LAYER_ORDER.map((lk, i) => {
    const angle = -Math.PI / 2 + (2 * Math.PI * i) / 5;
    const c = layerCounts[lk] || { total: 0 };
    const nodeR = Math.max(12, Math.min(40, 8 + Math.log2(c.total + 1) * 4));
    return {
      x: cx + Math.cos(angle) * radius,
      y: cy + Math.sin(angle) * radius,
      r: nodeR,
      color: LAYERS[lk].color,
      label: LAYERS[lk].label,
      count: c.total,
      key: lk
    };
  });
}

function initParticles(nodes) {
  particles = [];
  for (let i = 0; i < PARTICLE_COUNT; i++) {
    const a = Math.floor(Math.random() * 5);
    let b = Math.floor(Math.random() * 5);
    while (b === a) b = Math.floor(Math.random() * 5);
    particles.push({
      from: a, to: b,
      t: Math.random(),
      speed: 0.002 + Math.random() * 0.004,
      size: 1 + Math.random() * 1.5
    });
  }
}

let animFrame;
let time = 0;

function drawPentagon() {
  time += 0.016;
  ctx.clearRect(0, 0, cW, cH);

  const nodes = getNodePositions();
  const cx = cW / 2;
  const cy = cH / 2;

  // Concentric guide rings
  for (let r = 1; r <= 3; r++) {
    const ringR = Math.min(cW, cH) * 0.12 * r;
    ctx.beginPath();
    ctx.arc(cx, cy, ringR, 0, Math.PI * 2);
    ctx.strokeStyle = `rgba(0,229,255,${0.04 - r * 0.008})`;
    ctx.lineWidth = 1;
    ctx.stroke();
  }

  // Edges between all pairs
  for (let i = 0; i < 5; i++) {
    for (let j = i + 1; j < 5; j++) {
      const a = nodes[i], b = nodes[j];
      const grad = ctx.createLinearGradient(a.x, a.y, b.x, b.y);
      grad.addColorStop(0, a.color + '30');
      grad.addColorStop(1, b.color + '30');
      ctx.beginPath();
      ctx.moveTo(a.x, a.y);
      ctx.lineTo(b.x, b.y);
      ctx.strokeStyle = grad;
      ctx.lineWidth = 1;
      ctx.stroke();
    }
  }

  // Particles flowing along edges
  for (const p of particles) {
    p.t += p.speed;
    if (p.t > 1) {
      p.t = 0;
      p.from = p.to;
      let nb = Math.floor(Math.random() * 5);
      while (nb === p.from) nb = Math.floor(Math.random() * 5);
      p.to = nb;
    }
    const a = nodes[p.from], b = nodes[p.to];
    const px = a.x + (b.x - a.x) * p.t;
    const py = a.y + (b.y - a.y) * p.t;
    const col = LAYERS[LAYER_ORDER[p.from]].color;
    ctx.beginPath();
    ctx.arc(px, py, p.size, 0, Math.PI * 2);
    ctx.fillStyle = col + '80';
    ctx.fill();
  }

  // Center hub
  const breathe = 0.8 + 0.2 * Math.sin(time * 1.5);
  const hubR = 28 * breathe;
  const hubGrad = ctx.createRadialGradient(cx, cy, 0, cx, cy, hubR * 2);
  hubGrad.addColorStop(0, 'rgba(0,229,255,.15)');
  hubGrad.addColorStop(1, 'rgba(0,229,255,0)');
  ctx.beginPath();
  ctx.arc(cx, cy, hubR * 2, 0, Math.PI * 2);
  ctx.fillStyle = hubGrad;
  ctx.fill();

  ctx.beginPath();
  ctx.arc(cx, cy, hubR, 0, Math.PI * 2);
  ctx.fillStyle = '#0a0e18';
  ctx.strokeStyle = 'rgba(0,229,255,.4)';
  ctx.lineWidth = 1.5;
  ctx.fill();
  ctx.stroke();

  // Center total text
  ctx.fillStyle = '#00e5ff';
  ctx.font = `700 ${Math.max(14, cW * 0.018)}px 'Chakra Petch', sans-serif`;
  ctx.textAlign = 'center';
  ctx.textBaseline = 'middle';
  ctx.fillText(totalRows.toLocaleString(), cx, cy - 4);
  ctx.fillStyle = 'rgba(0,229,255,.5)';
  ctx.font = `300 ${Math.max(8, cW * 0.009)}px 'Azeret Mono', monospace`;
  ctx.fillText('ROWS', cx, cy + 12);

  // Layer nodes
  for (const n of nodes) {
    // Glow
    const glow = ctx.createRadialGradient(n.x, n.y, 0, n.x, n.y, n.r * 2.5);
    glow.addColorStop(0, n.color + '25');
    glow.addColorStop(1, n.color + '00');
    ctx.beginPath();
    ctx.arc(n.x, n.y, n.r * 2.5, 0, Math.PI * 2);
    ctx.fillStyle = glow;
    ctx.fill();

    // Node circle
    const breatheR = n.r * (0.95 + 0.05 * Math.sin(time * 2 + LAYER_ORDER.indexOf(n.key)));
    ctx.beginPath();
    ctx.arc(n.x, n.y, breatheR, 0, Math.PI * 2);
    ctx.fillStyle = '#0a0e18';
    ctx.strokeStyle = n.color + 'aa';
    ctx.lineWidth = 2;
    ctx.fill();
    ctx.stroke();

    // Count inside node
    ctx.fillStyle = n.color;
    ctx.font = `600 ${Math.max(9, n.r * 0.55)}px 'Chakra Petch', sans-serif`;
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText(n.count.toLocaleString(), n.x, n.y);

    // Label below node
    ctx.fillStyle = n.color + 'cc';
    ctx.font = `500 ${Math.max(8, cW * 0.01)}px 'Azeret Mono', monospace`;
    ctx.fillText(n.label.toUpperCase(), n.x, n.y + n.r + 14);
  }

  animFrame = requestAnimationFrame(drawPentagon);
}

// â”€â”€ Real-time pulse subscription â”€â”€
function subscribePulse() {
  sb.channel('ai-events-pulse')
    .on('postgres_changes', { event: 'INSERT', schema: 'public', table: 'ai_events' }, payload => {
      const e = payload.new;
      const item = {
        type: e.event_type || e.type || 'event',
        content: (e.content || e.message || e.description || '').slice(0, 140),
        time: e.created_at,
        layer: guessLayer(e)
      };
      pulseItems.unshift(item);
      if (pulseItems.length > MAX_PULSE) pulseItems.pop();
      renderPulse();
    })
    .subscribe();
}

// â”€â”€ Init â”€â”€
async function init() {
  resizeCanvas();
  window.addEventListener('resize', resizeCanvas);

  document.getElementById('statusText').textContent = 'Authenticating...';
  let session = await ensureSession();

  if (!session) {
    document.getElementById('statusText').textContent = 'Auth failed â€” retrying...';
    await new Promise(r => setTimeout(r, 2000));
    session = await ensureSession();
  }

  if (session?.access_token) {
    document.getElementById('statusText').textContent = 'Scanning layers...';
    console.log('[init] auth OK, scanning with JWT');
  } else {
    document.getElementById('statusText').textContent = 'No auth â€” read-only tables only';
    console.warn('[init] no JWT â€” RLS-protected tables will return 0');
  }

  await Promise.all([fetchAllCounts(), fetchPulseEvents()]);

  const statusLabel = totalRows > 0 ? 'Online' : 'Online (0 rows â€” check auth)';
  document.getElementById('statusText').textContent = statusLabel;
  document.getElementById('totalBadge').textContent = totalRows.toLocaleString() + ' rows';

  renderCards();
  renderPulse();

  // Wait for fonts before drawing canvas
  await document.fonts.ready;
  initParticles(getNodePositions());
  drawPentagon();

  subscribePulse();

  // Auto-refresh every 60s
  setInterval(async () => {
    await fetchAllCounts();
    document.getElementById('totalBadge').textContent = totalRows.toLocaleString() + ' rows';
    renderCards();
  }, 60000);
}

init().catch(err => {
  console.error('Layer Sovereign init error:', err);
  document.getElementById('statusText').textContent = 'Error: ' + (err.message || 'init failed');
});
</script>
</body>
</html>