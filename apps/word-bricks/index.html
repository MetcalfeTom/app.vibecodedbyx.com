<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Word Bricks</title>
  <link rel="icon" href="https://emojicdn.elk.sh/üß±">
  <meta name="description" content="Physics sandbox where chat messages fall as stackable bricks">
  <meta property="og:title" content="Word Bricks">
  <meta property="og:description" content="Drop words, build towers. A physics chat sandbox.">
  <meta property="og:url" content="https://app.sloppy.live/word-bricks">
  <meta property="og:image" content="https://app.sloppy.live/word-bricks/og-image.png">
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Archivo+Black&family=Space+Mono:wght@400;700&display=swap" rel="stylesheet">
  <style>
    :root {
      --bg: #1a1a2e;
      --ground: #16213e;
      --accent: #e94560;
      --accent2: #0f3460;
      --text: #eaeaea;
      --brick-shadow: rgba(0,0,0,0.4);
    }

    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: 'Space Mono', monospace;
      background: var(--bg);
      color: var(--text);
      min-height: 100vh;
      overflow: hidden;
      display: flex;
      flex-direction: column;
    }

    .header {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      z-index: 100;
      padding: 12px 20px;
      display: flex;
      justify-content: space-between;
      align-items: center;
      background: linear-gradient(180deg, var(--bg) 0%, transparent 100%);
    }

    .logo {
      font-family: 'Archivo Black', sans-serif;
      font-size: 1.4rem;
      color: var(--accent);
      text-shadow: 2px 2px 0 var(--accent2);
      letter-spacing: -0.02em;
    }

    .stats {
      font-size: 0.75rem;
      color: var(--text);
      opacity: 0.7;
    }

    .stats span {
      color: var(--accent);
      font-weight: 700;
    }

    #canvas {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      cursor: grab;
    }

    #canvas:active {
      cursor: grabbing;
    }

    .input-bar {
      position: fixed;
      bottom: 0;
      left: 0;
      right: 0;
      padding: 16px 20px;
      background: linear-gradient(0deg, var(--bg) 60%, transparent 100%);
      display: flex;
      gap: 12px;
      z-index: 100;
    }

    .input-bar input {
      flex: 1;
      background: var(--ground);
      border: 2px solid var(--accent2);
      border-radius: 8px;
      padding: 14px 18px;
      font-family: 'Space Mono', monospace;
      font-size: 1rem;
      color: var(--text);
      outline: none;
      transition: border-color 0.2s;
    }

    .input-bar input:focus {
      border-color: var(--accent);
    }

    .input-bar input::placeholder {
      color: rgba(234,234,234,0.3);
    }

    .input-bar button {
      background: var(--accent);
      border: none;
      border-radius: 8px;
      padding: 14px 24px;
      font-family: 'Archivo Black', sans-serif;
      font-size: 0.9rem;
      color: white;
      cursor: pointer;
      transition: transform 0.1s, background 0.2s;
    }

    .input-bar button:hover {
      background: #ff6b6b;
    }

    .input-bar button:active {
      transform: scale(0.95);
    }

    .controls {
      position: fixed;
      top: 60px;
      right: 20px;
      display: flex;
      flex-direction: column;
      gap: 8px;
      z-index: 100;
    }

    .control-btn {
      background: var(--ground);
      border: 2px solid var(--accent2);
      border-radius: 8px;
      padding: 10px 14px;
      font-family: 'Space Mono', monospace;
      font-size: 0.75rem;
      color: var(--text);
      cursor: pointer;
      transition: border-color 0.2s, background 0.2s;
    }

    .control-btn:hover {
      border-color: var(--accent);
      background: var(--accent2);
    }

    .back-link {
      position: fixed;
      bottom: 80px;
      left: 20px;
      font-size: 0.7rem;
      color: var(--text);
      opacity: 0.4;
      text-decoration: none;
      z-index: 100;
    }

    .back-link:hover {
      opacity: 0.8;
    }

    @media (max-width: 600px) {
      .header {
        padding: 10px 14px;
      }
      .logo {
        font-size: 1.1rem;
      }
      .controls {
        top: 50px;
        right: 10px;
      }
      .control-btn {
        padding: 8px 10px;
        font-size: 0.65rem;
      }
      .input-bar {
        padding: 12px 14px;
      }
      .input-bar input {
        padding: 12px 14px;
        font-size: 0.9rem;
      }
      .input-bar button {
        padding: 12px 16px;
        font-size: 0.8rem;
      }
    }
  </style>
</head>
<body>
  <header class="header">
    <div class="logo">WORD BRICKS</div>
    <div class="stats">Bricks: <span id="brickCount">0</span></div>
  </header>

  <div class="controls">
    <button class="control-btn" onclick="clearBricks()">Clear All</button>
    <button class="control-btn" onclick="addRandomBrick()">+ Random</button>
    <button class="control-btn" onclick="toggleGravity()">Gravity: ON</button>
    <button class="control-btn" onclick="explodeBricks()">üí• Explode</button>
  </div>

  <canvas id="canvas"></canvas>

  <div class="input-bar">
    <input type="text" id="messageInput" placeholder="Type a message to drop as a brick..." maxlength="50" autocomplete="off">
    <button onclick="dropBrick()">DROP</button>
  </div>

  <a href="https://sloppy.live" class="back-link">‚Üê sloppy.live</a>

  <script type="module">
    import supabase, { supabaseSession } from '../../supabase-config.js';

    // Canvas setup
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    let width, height;

    function resize() {
      width = canvas.width = window.innerWidth;
      height = canvas.height = window.innerHeight;
    }
    resize();
    window.addEventListener('resize', resize);

    // Physics constants
    const GRAVITY = 0.4;
    const FRICTION = 0.98;
    const BOUNCE = 0.5;
    const GROUND_Y = 80; // Distance from bottom

    // State
    let bricks = [];
    let gravityEnabled = true;
    let draggedBrick = null;
    let dragOffset = { x: 0, y: 0 };
    let currentUser = null;

    // Brick colors palette
    const COLORS = [
      '#e94560', '#ff6b6b', '#feca57', '#48dbfb', '#1dd1a1',
      '#5f27cd', '#ff9ff3', '#54a0ff', '#00d2d3', '#ff9f43',
      '#ee5a24', '#7158e2', '#3ae374', '#17c0eb', '#c56cf0'
    ];

    // Brick class
    class Brick {
      constructor(text, x, y) {
        this.text = text.substring(0, 50);
        this.x = x;
        this.y = y;
        this.vx = (Math.random() - 0.5) * 2;
        this.vy = 0;
        this.rotation = (Math.random() - 0.5) * 0.2;
        this.vr = (Math.random() - 0.5) * 0.02;
        this.color = COLORS[Math.floor(Math.random() * COLORS.length)];

        // Calculate size based on text
        ctx.font = 'bold 14px "Space Mono", monospace';
        const metrics = ctx.measureText(this.text);
        this.width = Math.max(80, metrics.width + 24);
        this.height = 36;

        this.grounded = false;
        this.id = Date.now() + Math.random();
      }

      update() {
        if (!gravityEnabled && !draggedBrick) return;
        if (draggedBrick === this) return;

        // Apply gravity
        if (gravityEnabled) {
          this.vy += GRAVITY;
        }

        // Apply velocity
        this.x += this.vx;
        this.y += this.vy;
        this.rotation += this.vr;

        // Friction
        this.vx *= FRICTION;
        this.vr *= FRICTION;

        // Ground collision
        const groundLevel = height - GROUND_Y;
        if (this.y + this.height / 2 > groundLevel) {
          this.y = groundLevel - this.height / 2;
          this.vy *= -BOUNCE;
          this.vr *= 0.8;
          if (Math.abs(this.vy) < 0.5) {
            this.vy = 0;
            this.grounded = true;
          }
        }

        // Wall collision
        if (this.x - this.width / 2 < 0) {
          this.x = this.width / 2;
          this.vx *= -BOUNCE;
        }
        if (this.x + this.width / 2 > width) {
          this.x = width - this.width / 2;
          this.vx *= -BOUNCE;
        }

        // Ceiling
        if (this.y - this.height / 2 < 0) {
          this.y = this.height / 2;
          this.vy *= -BOUNCE;
        }

        // Brick-to-brick collision (simplified)
        for (const other of bricks) {
          if (other === this) continue;
          if (this.intersects(other)) {
            this.resolveCollision(other);
          }
        }
      }

      intersects(other) {
        return Math.abs(this.x - other.x) < (this.width + other.width) / 2 * 0.9 &&
               Math.abs(this.y - other.y) < (this.height + other.height) / 2 * 0.9;
      }

      resolveCollision(other) {
        const dx = this.x - other.x;
        const dy = this.y - other.y;
        const dist = Math.sqrt(dx * dx + dy * dy) || 1;

        // Push apart
        const overlap = ((this.width + other.width) / 2 + (this.height + other.height) / 2) / 2 - dist;
        if (overlap > 0) {
          const pushX = (dx / dist) * overlap * 0.5;
          const pushY = (dy / dist) * overlap * 0.5;

          this.x += pushX;
          this.y += pushY;
          other.x -= pushX;
          other.y -= pushY;

          // Transfer velocity
          const tempVx = this.vx * 0.5;
          const tempVy = this.vy * 0.5;
          this.vx = other.vx * 0.5 * BOUNCE;
          this.vy = other.vy * 0.5 * BOUNCE;
          other.vx = tempVx * BOUNCE;
          other.vy = tempVy * BOUNCE;
        }
      }

      draw() {
        ctx.save();
        ctx.translate(this.x, this.y);
        ctx.rotate(this.rotation);

        // Shadow
        ctx.fillStyle = 'rgba(0,0,0,0.3)';
        ctx.fillRect(-this.width / 2 + 4, -this.height / 2 + 4, this.width, this.height);

        // Brick body
        ctx.fillStyle = this.color;
        ctx.fillRect(-this.width / 2, -this.height / 2, this.width, this.height);

        // Highlight
        ctx.fillStyle = 'rgba(255,255,255,0.2)';
        ctx.fillRect(-this.width / 2, -this.height / 2, this.width, 4);

        // Border
        ctx.strokeStyle = 'rgba(0,0,0,0.3)';
        ctx.lineWidth = 2;
        ctx.strokeRect(-this.width / 2, -this.height / 2, this.width, this.height);

        // Text
        ctx.fillStyle = '#fff';
        ctx.font = 'bold 14px "Space Mono", monospace';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.shadowColor = 'rgba(0,0,0,0.5)';
        ctx.shadowBlur = 2;
        ctx.fillText(this.text, 0, 1);

        ctx.restore();
      }

      contains(px, py) {
        const dx = px - this.x;
        const dy = py - this.y;
        // Rotate point to brick's local space
        const cos = Math.cos(-this.rotation);
        const sin = Math.sin(-this.rotation);
        const localX = dx * cos - dy * sin;
        const localY = dx * sin + dy * cos;
        return Math.abs(localX) < this.width / 2 && Math.abs(localY) < this.height / 2;
      }
    }

    // Animation loop
    function animate() {
      ctx.fillStyle = '#1a1a2e';
      ctx.fillRect(0, 0, width, height);

      // Draw ground
      const groundLevel = height - GROUND_Y;
      ctx.fillStyle = '#16213e';
      ctx.fillRect(0, groundLevel, width, GROUND_Y);

      // Ground line
      ctx.strokeStyle = '#e94560';
      ctx.lineWidth = 3;
      ctx.beginPath();
      ctx.moveTo(0, groundLevel);
      ctx.lineTo(width, groundLevel);
      ctx.stroke();

      // Grid pattern on ground
      ctx.strokeStyle = 'rgba(233, 69, 96, 0.1)';
      ctx.lineWidth = 1;
      for (let x = 0; x < width; x += 40) {
        ctx.beginPath();
        ctx.moveTo(x, groundLevel);
        ctx.lineTo(x, height);
        ctx.stroke();
      }

      // Update and draw bricks
      for (const brick of bricks) {
        brick.update();
        brick.draw();
      }

      // Update count
      document.getElementById('brickCount').textContent = bricks.length;

      requestAnimationFrame(animate);
    }

    // Drop a brick with text
    window.dropBrick = function() {
      const input = document.getElementById('messageInput');
      const text = input.value.trim();
      if (!text) return;

      const brick = new Brick(text, width / 2 + (Math.random() - 0.5) * 200, 50);
      bricks.push(brick);
      input.value = '';

      // Save to database
      saveBrick(text);
    };

    // Add random brick
    window.addRandomBrick = function() {
      const words = ['SLOPPY', 'VIBES', 'CHAOS', 'BUILD', 'CREATE', 'STACK', 'BRICK', 'DROP', 'FALL', 'RISE', 'TOWER', 'CRASH'];
      const text = words[Math.floor(Math.random() * words.length)];
      const brick = new Brick(text, Math.random() * (width - 200) + 100, 50);
      bricks.push(brick);
    };

    // Clear all bricks
    window.clearBricks = function() {
      bricks = [];
    };

    // Toggle gravity
    window.toggleGravity = function() {
      gravityEnabled = !gravityEnabled;
      document.querySelector('.controls button:nth-child(3)').textContent =
        `Gravity: ${gravityEnabled ? 'ON' : 'OFF'}`;
    };

    // Explode bricks
    window.explodeBricks = function() {
      const centerX = width / 2;
      const centerY = height / 2;
      for (const brick of bricks) {
        const dx = brick.x - centerX;
        const dy = brick.y - centerY;
        const dist = Math.sqrt(dx * dx + dy * dy) || 1;
        brick.vx += (dx / dist) * 20;
        brick.vy += (dy / dist) * 20 - 10;
        brick.vr += (Math.random() - 0.5) * 0.5;
        brick.grounded = false;
      }
    };

    // Mouse/touch interaction
    function getPointerPos(e) {
      const rect = canvas.getBoundingClientRect();
      const clientX = e.touches ? e.touches[0].clientX : e.clientX;
      const clientY = e.touches ? e.touches[0].clientY : e.clientY;
      return {
        x: clientX - rect.left,
        y: clientY - rect.top
      };
    }

    canvas.addEventListener('mousedown', startDrag);
    canvas.addEventListener('touchstart', startDrag, { passive: false });

    function startDrag(e) {
      if (e.touches) e.preventDefault();
      const pos = getPointerPos(e);

      // Find clicked brick (reverse order for top-most first)
      for (let i = bricks.length - 1; i >= 0; i--) {
        if (bricks[i].contains(pos.x, pos.y)) {
          draggedBrick = bricks[i];
          dragOffset.x = pos.x - draggedBrick.x;
          dragOffset.y = pos.y - draggedBrick.y;
          draggedBrick.vx = 0;
          draggedBrick.vy = 0;
          // Move to top
          bricks.splice(i, 1);
          bricks.push(draggedBrick);
          break;
        }
      }
    }

    canvas.addEventListener('mousemove', drag);
    canvas.addEventListener('touchmove', drag, { passive: false });

    function drag(e) {
      if (!draggedBrick) return;
      if (e.touches) e.preventDefault();
      const pos = getPointerPos(e);
      draggedBrick.x = pos.x - dragOffset.x;
      draggedBrick.y = pos.y - dragOffset.y;
    }

    canvas.addEventListener('mouseup', endDrag);
    canvas.addEventListener('touchend', endDrag);
    canvas.addEventListener('mouseleave', endDrag);

    function endDrag() {
      if (draggedBrick) {
        draggedBrick.grounded = false;
      }
      draggedBrick = null;
    }

    // Keyboard shortcut
    document.getElementById('messageInput').addEventListener('keydown', (e) => {
      if (e.key === 'Enter') {
        dropBrick();
      }
    });

    // Supabase integration
    async function saveBrick(text) {
      if (!supabase || !currentUser) return;
      try {
        await supabase.from('word_bricks').insert({
          content: text,
          user_id: currentUser.id
        });
      } catch (e) {
        console.log('Could not save brick:', e.message);
      }
    }

    async function loadRecentBricks() {
      if (!supabase) return;
      try {
        const { data } = await supabase
          .from('word_bricks')
          .select('content, created_at')
          .order('created_at', { ascending: false })
          .limit(20);

        if (data && data.length > 0) {
          // Drop recent bricks with stagger
          data.reverse().forEach((row, i) => {
            setTimeout(() => {
              const brick = new Brick(
                row.content,
                Math.random() * (width - 200) + 100,
                -50 - i * 40
              );
              bricks.push(brick);
            }, i * 150);
          });
        }
      } catch (e) {
        console.log('Could not load bricks:', e.message);
      }
    }

    function subscribeToNewBricks() {
      if (!supabase) return;
      try {
        supabase
          .channel('word_bricks_realtime')
          .on('postgres_changes', {
            event: 'INSERT',
            schema: 'public',
            table: 'word_bricks'
          }, (payload) => {
            // Don't duplicate our own bricks (already added locally)
            if (payload.new && payload.new.user_id !== currentUser?.id) {
              const brick = new Brick(
                payload.new.content,
                Math.random() * (width - 200) + 100,
                -50
              );
              bricks.push(brick);
            }
          })
          .subscribe();
      } catch (e) {
        console.log('Could not subscribe:', e.message);
      }
    }

    // Initialize
    async function init() {
      try {
        const { user } = await supabaseSession();
        currentUser = user;
        await loadRecentBricks();
        subscribeToNewBricks();
      } catch (e) {
        console.log('Running in offline mode');
      }

      // Start with a welcome brick
      setTimeout(() => {
        if (bricks.length === 0) {
          const brick = new Brick('DROP WORDS HERE', width / 2, 50);
          bricks.push(brick);
        }
      }, 500);
    }

    init();
    animate();
  </script>
<script src="/vibelib-extended.js"></script>
<script>
  // Compatibility Patch for Legacy Apps
  window.addEventListener("load", () => {
    if (window.SloppyKarma && window.VibeLib.Economy) {
      // Redirect old calls to new engine
      window.SloppyKarma.track = window.VibeLib.Economy.track;
    }
  });
</script>
</body>
</html>
