<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
  <title>Neon Lava Lamp</title>
  <link rel="icon" href="https://emojicdn.elk.sh/ü´ß">
  <meta name="description" content="Mesmerizing neon lava lamp with gooey physics">
  <meta property="og:title" content="Neon Lava Lamp">
  <meta property="og:description" content="Mesmerizing neon lava lamp with gooey physics">
  <meta property="og:image" content="https://emojicdn.elk.sh/ü´ß?style=google">
  <meta property="og:url" content="https://sloppy.live/lava-lamp">
  <style>
    @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700&display=swap');
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      background: linear-gradient(135deg, #0a0a0a 0%, #1a0a1a 50%, #0a0a1a 100%);
      min-height: 100vh;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      font-family: 'Orbitron', sans-serif;
      overflow: hidden;
    }
    .lamp-container { position: relative; width: 280px; height: 500px; }
    #lavaCanvas {
      position: absolute;
      top: 50px; left: 40px;
      width: 200px; height: 380px;
      border-radius: 100px / 30px;
    }
    .lamp-glass {
      position: absolute;
      top: 50px; left: 40px;
      width: 200px; height: 380px;
      border-radius: 100px / 30px;
      background: transparent;
      box-shadow: inset 0 0 60px rgba(255,255,255,0.05), inset 2px 0 10px rgba(255,255,255,0.1), 0 0 40px rgba(0,0,0,0.5);
      pointer-events: none; z-index: 10;
    }
    .lamp-glass::before {
      content: '';
      position: absolute;
      top: 10px; left: 15px;
      width: 40px; height: 150px;
      background: linear-gradient(180deg, rgba(255,255,255,0.15) 0%, rgba(255,255,255,0.05) 50%, transparent 100%);
      border-radius: 20px;
      transform: rotate(-5deg);
    }
    .lamp-cap {
      position: absolute;
      top: 0; left: 20px;
      width: 240px; height: 70px;
      background: linear-gradient(180deg, #333 0%, #1a1a1a 50%, #0d0d0d 100%);
      border-radius: 20px 20px 50% 50%;
      box-shadow: 0 5px 20px rgba(0,0,0,0.5), inset 0 2px 5px rgba(255,255,255,0.1);
      z-index: 20;
    }
    .lamp-cap::after {
      content: '';
      position: absolute;
      top: 5px; left: 50%;
      transform: translateX(-50%);
      width: 60px; height: 15px;
      background: linear-gradient(180deg, #444 0%, #222 100%);
      border-radius: 10px;
    }
    .lamp-base {
      position: absolute;
      bottom: 0; left: 10px;
      width: 260px; height: 80px;
      background: linear-gradient(180deg, #0d0d0d 0%, #1a1a1a 30%, #333 100%);
      border-radius: 50% 50% 30px 30px;
      box-shadow: 0 10px 30px rgba(0,0,0,0.7), inset 0 -5px 15px rgba(255,255,255,0.05);
      z-index: 20;
    }
    .lamp-base::before {
      content: '';
      position: absolute;
      top: 10px; left: 50%;
      transform: translateX(-50%);
      width: 200px; height: 30px;
      background: radial-gradient(ellipse, rgba(255,100,50,0.3) 0%, transparent 70%);
      filter: blur(5px);
    }
    .glow {
      position: absolute;
      top: 50px; left: 40px;
      width: 200px; height: 380px;
      border-radius: 100px / 30px;
      pointer-events: none; z-index: 5;
      filter: blur(30px);
      opacity: 0.5;
    }
    h1 {
      position: fixed; top: 20px;
      color: #ff66aa;
      font-size: 1.5rem;
      text-shadow: 0 0 20px #ff66aa, 0 0 40px #ff0066;
      letter-spacing: 4px;
      z-index: 100;
    }
    .controls {
      position: fixed; bottom: 20px;
      display: flex; gap: 15px;
      z-index: 100;
    }
    .control-btn {
      background: rgba(255,255,255,0.1);
      border: 1px solid rgba(255,255,255,0.2);
      color: #fff;
      padding: 10px 20px;
      font-family: 'Orbitron', sans-serif;
      font-size: 0.8rem;
      border-radius: 20px;
      cursor: pointer;
      transition: all 0.3s;
    }
    .control-btn:hover {
      background: rgba(255,255,255,0.2);
      box-shadow: 0 0 20px rgba(255,100,200,0.3);
    }
    .back-link {
      position: fixed; top: 20px; left: 20px;
      color: #aa66ff;
      text-decoration: none;
      font-size: 0.8rem;
      opacity: 0.7;
      z-index: 101;
    }
    .hint {
      position: fixed;
      top: 60px;
      left: 50%;
      transform: translateX(-50%);
      color: #666;
      font-size: 0.7rem;
      text-align: center;
      opacity: 1;
      transition: opacity 1s;
      z-index: 100;
    }
    .hint.hidden { opacity: 0; }
    #lavaCanvas { cursor: pointer; }
  </style>
</head>
<body>
  <a href="https://sloppy.live" class="back-link">‚Üê sloppy.live</a>
  <h1>NEON LAVA</h1>
  <p class="hint" id="hint">Click inside the lamp to create bubbles</p>
  <div class="lamp-container">
    <div class="glow" id="glow"></div>
    <div class="lamp-cap"></div>
    <canvas id="lavaCanvas"></canvas>
    <div class="lamp-glass"></div>
    <div class="lamp-base"></div>
  </div>
  <div class="controls">
    <button class="control-btn" onclick="changeColorScheme()">COLORS</button>
    <button class="control-btn" onclick="addBlob()">+ BLOB</button>
    <button class="control-btn" onclick="toggleHeat()">HEAT</button>
  </div>
  <script>
    const canvas = document.getElementById('lavaCanvas');
    const ctx = canvas.getContext('2d');
    const glow = document.getElementById('glow');
    const scale = 2;
    canvas.width = 200 * scale;
    canvas.height = 380 * scale;
    ctx.scale(scale, scale);

    const colorSchemes = [
      { primary: [255, 50, 150], secondary: [255, 100, 200], bg: [40, 0, 30] },
      { primary: [50, 200, 255], secondary: [100, 255, 255], bg: [0, 30, 50] },
      { primary: [255, 150, 50], secondary: [255, 200, 100], bg: [50, 20, 0] },
      { primary: [150, 50, 255], secondary: [200, 100, 255], bg: [30, 0, 50] },
      { primary: [50, 255, 150], secondary: [100, 255, 200], bg: [0, 40, 30] },
      { primary: [255, 255, 50], secondary: [255, 255, 150], bg: [50, 50, 0] },
    ];
    let currentScheme = 0;
    let targetColors = colorSchemes[0];
    let currentColors = JSON.parse(JSON.stringify(colorSchemes[0]));

    let heatIntensity = 1;
    const GRAVITY = 0.02;
    const HEAT_FORCE = 0.08;
    const DAMPING = 0.98;
    const BLOB_REPEL = 0.5;

    const blobs = [];

    class Blob {
      constructor(x, y, radius) {
        this.x = x; this.y = y;
        this.vx = (Math.random() - 0.5) * 0.5;
        this.vy = (Math.random() - 0.5) * 0.5;
        this.radius = radius;
        this.baseRadius = radius;
        this.temperature = Math.random();
        this.colorOffset = Math.random();
        this.pulsePhase = Math.random() * Math.PI * 2;
        this.wobblePhase = Math.random() * Math.PI * 2;
      }
      update() {
        this.pulsePhase += 0.02;
        this.wobblePhase += 0.03;
        this.radius = this.baseRadius + Math.sin(this.pulsePhase) * 3;
        const normalizedY = this.y / 380;
        if (normalizedY > 0.8) this.temperature += 0.01 * heatIntensity;
        else if (normalizedY < 0.2) this.temperature -= 0.008;
        else this.temperature -= 0.002;
        this.temperature = Math.max(0, Math.min(1, this.temperature));
        const buoyancy = (this.temperature - 0.5) * HEAT_FORCE * heatIntensity;
        this.vy -= buoyancy;
        this.vy += GRAVITY * (1 - this.temperature * 0.5);
        this.x += this.vx;
        this.y += this.vy;
        this.vx *= DAMPING;
        this.vy *= DAMPING;
        this.x += Math.sin(this.wobblePhase) * 0.3;
        const centerX = 100;
        const width = this.getWidthAtY(this.y);
        const minX = centerX - width / 2 + this.radius;
        const maxX = centerX + width / 2 - this.radius;
        if (this.x < minX) { this.x = minX; this.vx *= -0.5; }
        if (this.x > maxX) { this.x = maxX; this.vx *= -0.5; }
        if (this.y < this.radius + 10) { this.y = this.radius + 10; this.vy *= -0.3; this.temperature -= 0.05; }
        if (this.y > 370 - this.radius) { this.y = 370 - this.radius; this.vy *= -0.3; this.temperature += 0.1; }
      }
      getWidthAtY(y) {
        const normalized = y / 380;
        if (normalized < 0.1) return 120 + normalized * 600;
        else if (normalized > 0.9) return 180 - (normalized - 0.9) * 600;
        return 180;
      }
      getColor() {
        const t = (Math.sin(this.colorOffset * Math.PI * 2 + Date.now() * 0.001) + 1) / 2;
        return {
          r: Math.round(currentColors.primary[0] + (currentColors.secondary[0] - currentColors.primary[0]) * t),
          g: Math.round(currentColors.primary[1] + (currentColors.secondary[1] - currentColors.primary[1]) * t),
          b: Math.round(currentColors.primary[2] + (currentColors.secondary[2] - currentColors.primary[2]) * t)
        };
      }
    }

    function initBlobs() {
      blobs.length = 0;
      for (let i = 0; i < 8; i++) {
        blobs.push(new Blob(50 + Math.random() * 100, 50 + Math.random() * 280, 15 + Math.random() * 20));
      }
    }

    function addBlob() {
      if (blobs.length < 15) {
        blobs.push(new Blob(50 + Math.random() * 100, 300 + Math.random() * 50, 15 + Math.random() * 20));
      }
    }

    function handleBlobInteractions() {
      for (let i = 0; i < blobs.length; i++) {
        for (let j = i + 1; j < blobs.length; j++) {
          const b1 = blobs[i], b2 = blobs[j];
          const dx = b2.x - b1.x, dy = b2.y - b1.y;
          const dist = Math.sqrt(dx * dx + dy * dy);
          const minDist = b1.radius + b2.radius;
          if (dist < minDist * 1.5) {
            const force = (minDist * 1.5 - dist) * BLOB_REPEL / dist;
            const fx = dx * force * 0.01, fy = dy * force * 0.01;
            b1.vx -= fx; b1.vy -= fy;
            b2.vx += fx; b2.vy += fy;
          }
        }
      }
    }

    function renderMetaballs() {
      const width = 200, height = 380, threshold = 1;
      const imageData = ctx.createImageData(width, height);
      const data = imageData.data;
      const bgR = currentColors.bg[0], bgG = currentColors.bg[1], bgB = currentColors.bg[2];

      for (let y = 0; y < height; y++) {
        for (let x = 0; x < width; x++) {
          let sum = 0, colorR = 0, colorG = 0, colorB = 0, totalWeight = 0;
          for (const blob of blobs) {
            const dx = x - blob.x, dy = y - blob.y;
            const distSq = dx * dx + dy * dy;
            const r = blob.radius * 1.5;
            const contribution = (r * r) / (distSq + 1);
            sum += contribution;
            if (contribution > 0.1) {
              const color = blob.getColor();
              colorR += color.r * contribution;
              colorG += color.g * contribution;
              colorB += color.b * contribution;
              totalWeight += contribution;
            }
          }
          const idx = (y * width + x) * 4;
          if (sum > threshold) {
            if (totalWeight > 0) { colorR /= totalWeight; colorG /= totalWeight; colorB /= totalWeight; }
            const edgeFactor = Math.min((sum - threshold) * 2, 1);
            data[idx] = Math.min(255, colorR + (255 - colorR) * (1 - edgeFactor) * 0.5);
            data[idx + 1] = Math.min(255, colorG + (255 - colorG) * (1 - edgeFactor) * 0.5);
            data[idx + 2] = Math.min(255, colorB + (255 - colorB) * (1 - edgeFactor) * 0.5);
            data[idx + 3] = 255;
          } else if (sum > threshold * 0.5) {
            const glowIntensity = (sum - threshold * 0.5) / (threshold * 0.5);
            if (totalWeight > 0) { colorR /= totalWeight; colorG /= totalWeight; colorB /= totalWeight; }
            else { colorR = currentColors.primary[0]; colorG = currentColors.primary[1]; colorB = currentColors.primary[2]; }
            data[idx] = bgR + (colorR - bgR) * glowIntensity * 0.3;
            data[idx + 1] = bgG + (colorG - bgG) * glowIntensity * 0.3;
            data[idx + 2] = bgB + (colorB - bgB) * glowIntensity * 0.3;
            data[idx + 3] = 255;
          } else {
            data[idx] = bgR; data[idx + 1] = bgG; data[idx + 2] = bgB; data[idx + 3] = 255;
          }
        }
      }
      ctx.putImageData(imageData, 0, 0);
    }

    function updateColors() {
      const speed = 0.02;
      for (let i = 0; i < 3; i++) {
        currentColors.primary[i] += (targetColors.primary[i] - currentColors.primary[i]) * speed;
        currentColors.secondary[i] += (targetColors.secondary[i] - currentColors.secondary[i]) * speed;
        currentColors.bg[i] += (targetColors.bg[i] - currentColors.bg[i]) * speed;
      }
      const r = Math.round(currentColors.primary[0]), g = Math.round(currentColors.primary[1]), b = Math.round(currentColors.primary[2]);
      glow.style.background = `radial-gradient(ellipse, rgba(${r}, ${g}, ${b}, 0.4) 0%, transparent 70%)`;
    }

    function changeColorScheme() {
      currentScheme = (currentScheme + 1) % colorSchemes.length;
      targetColors = colorSchemes[currentScheme];
    }

    function toggleHeat() {
      heatIntensity = heatIntensity === 1 ? 2 : heatIntensity === 2 ? 0.3 : 1;
    }

    function animate() {
      blobs.forEach(blob => blob.update());
      handleBlobInteractions();
      updateColors();
      renderMetaballs();
      requestAnimationFrame(animate);
    }

    // Click interaction - create bubbles where you click
    const hint = document.getElementById('hint');
    let clickCount = 0;

    canvas.addEventListener('click', (e) => {
      const rect = canvas.getBoundingClientRect();
      const x = (e.clientX - rect.left) * (200 / rect.width);
      const y = (e.clientY - rect.top) * (380 / rect.height);

      clickCount++;
      if (clickCount >= 2) hint.classList.add('hidden');

      // Create 2-4 bubbles at click position
      const count = 2 + Math.floor(Math.random() * 3);
      for (let i = 0; i < count; i++) {
        if (blobs.length < 20) {
          const newBlob = new Blob(
            x + (Math.random() - 0.5) * 30,
            y + (Math.random() - 0.5) * 30,
            12 + Math.random() * 18
          );
          newBlob.temperature = 0.8; // Hot from the click energy
          newBlob.vy = -2 - Math.random() * 2; // Burst upward
          newBlob.vx = (Math.random() - 0.5) * 3;
          blobs.push(newBlob);
        }
      }

      // Push nearby blobs away from click
      blobs.forEach(blob => {
        const dx = blob.x - x;
        const dy = blob.y - y;
        const dist = Math.sqrt(dx * dx + dy * dy);
        if (dist < 80 && dist > 0) {
          const force = (80 - dist) / 80 * 3;
          blob.vx += (dx / dist) * force;
          blob.vy += (dy / dist) * force;
          blob.temperature += 0.2;
        }
      });
    });

    // Touch support for mobile
    canvas.addEventListener('touchstart', (e) => {
      e.preventDefault();
      const touch = e.touches[0];
      const rect = canvas.getBoundingClientRect();
      const x = (touch.clientX - rect.left) * (200 / rect.width);
      const y = (touch.clientY - rect.top) * (380 / rect.height);

      const count = 2 + Math.floor(Math.random() * 3);
      for (let i = 0; i < count; i++) {
        if (blobs.length < 20) {
          const newBlob = new Blob(
            x + (Math.random() - 0.5) * 30,
            y + (Math.random() - 0.5) * 30,
            12 + Math.random() * 18
          );
          newBlob.temperature = 0.8;
          newBlob.vy = -2 - Math.random() * 2;
          newBlob.vx = (Math.random() - 0.5) * 3;
          blobs.push(newBlob);
        }
      }

      blobs.forEach(blob => {
        const dx = blob.x - x;
        const dy = blob.y - y;
        const dist = Math.sqrt(dx * dx + dy * dy);
        if (dist < 80 && dist > 0) {
          const force = (80 - dist) / 80 * 3;
          blob.vx += (dx / dist) * force;
          blob.vy += (dy / dist) * force;
          blob.temperature += 0.2;
        }
      });
    });

    initBlobs();
    animate();
    setInterval(() => { if (Math.random() < 0.1) changeColorScheme(); }, 10000);
  </script>
<script src="/sloppy-header/sloppy-bar.js"></script>
</body>
</html>
