<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Fee Watchtower</title>
  <link rel="icon" href="https://emojicdn.elk.sh/ðŸ—¼">
  <meta property="og:title" content="Fee Watchtower">
  <meta property="og:description" content="Watch glowing token rewards rise in real-time 3D">
  <meta property="og:url" content="https://app.sloppy.live/fee-watchtower">
  <meta property="og:image" content="https://emojicdn.elk.sh/ðŸ—¼?style=apple&size=512">
  <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&family=Share+Tech+Mono&display=swap" rel="stylesheet">
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      background: #000;
      overflow: hidden;
      font-family: 'Share Tech Mono', monospace;
    }

    #canvas-container {
      position: fixed;
      top: 0; left: 0;
      width: 100%; height: 100%;
    }
    canvas { display: block; }

    .hud {
      position: fixed;
      top: 0; left: 0;
      width: 100%;
      padding: 20px;
      pointer-events: none;
      z-index: 100;
    }

    .title {
      font-family: 'Orbitron', sans-serif;
      font-size: 1.8rem;
      font-weight: 900;
      color: #00ffff;
      text-shadow: 0 0 20px #00ffff, 0 0 40px #00ffff;
      letter-spacing: 3px;
    }

    .subtitle {
      color: #888;
      font-size: 0.85rem;
      margin-top: 5px;
    }

    .stats {
      position: fixed;
      top: 20px;
      right: 20px;
      background: rgba(10, 10, 30, 0.9);
      border: 2px solid #00ffff;
      border-radius: 15px;
      padding: 20px;
      min-width: 220px;
      z-index: 100;
    }

    .stats h3 {
      font-family: 'Orbitron', sans-serif;
      color: #00ffff;
      font-size: 0.9rem;
      margin-bottom: 15px;
      text-shadow: 0 0 10px #00ffff;
    }

    .stat-row {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin: 10px 0;
      padding: 8px 0;
      border-bottom: 1px solid rgba(0,255,255,0.2);
    }

    .stat-row:last-child { border-bottom: none; }

    .token-indicator {
      width: 12px;
      height: 12px;
      border-radius: 50%;
      display: inline-block;
      margin-right: 8px;
      box-shadow: 0 0 10px currentColor;
    }

    .stat-label { color: #aaa; font-size: 0.85rem; }
    .stat-value {
      color: #fff;
      font-family: 'Orbitron', sans-serif;
      font-weight: 700;
    }

    .total-fees {
      margin-top: 15px;
      padding-top: 15px;
      border-top: 2px solid #ff00ff;
      text-align: center;
    }

    .total-label {
      color: #ff00ff;
      font-size: 0.8rem;
      text-transform: uppercase;
      letter-spacing: 2px;
    }

    .total-value {
      font-family: 'Orbitron', sans-serif;
      font-size: 1.5rem;
      font-weight: 900;
      color: #fff;
      text-shadow: 0 0 15px #ff00ff;
      margin-top: 5px;
    }

    .feed {
      position: fixed;
      bottom: 20px;
      left: 20px;
      background: rgba(10, 10, 30, 0.85);
      border: 1px solid #00ff88;
      border-radius: 10px;
      padding: 15px;
      width: 280px;
      max-height: 200px;
      overflow: hidden;
      z-index: 100;
    }

    .feed h4 {
      font-family: 'Orbitron', sans-serif;
      color: #00ff88;
      font-size: 0.75rem;
      margin-bottom: 10px;
      text-shadow: 0 0 10px #00ff88;
    }

    .feed-list {
      list-style: none;
    }

    .feed-item {
      font-size: 0.75rem;
      color: #aaa;
      padding: 5px 0;
      border-bottom: 1px solid rgba(0,255,136,0.1);
      animation: fadeIn 0.3s ease;
    }

    .feed-item .amount {
      color: #00ff88;
      font-weight: bold;
    }

    @keyframes fadeIn {
      from { opacity: 0; transform: translateX(-10px); }
      to { opacity: 1; transform: translateX(0); }
    }

    .controls {
      position: fixed;
      bottom: 20px;
      right: 20px;
      z-index: 100;
      display: flex;
      gap: 10px;
    }

    .control-btn {
      padding: 10px 20px;
      background: rgba(10, 10, 30, 0.9);
      border: 2px solid #ffff00;
      border-radius: 25px;
      color: #ffff00;
      font-family: 'Orbitron', sans-serif;
      font-size: 0.75rem;
      cursor: pointer;
      transition: all 0.3s;
    }

    .control-btn:hover {
      background: #ffff00;
      color: #000;
      box-shadow: 0 0 20px #ffff00;
    }

    .control-btn.active {
      background: #ffff00;
      color: #000;
    }

    .back-link {
      position: fixed;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      color: #666;
      font-size: 0.7rem;
      text-decoration: none;
      z-index: 100;
    }

    .back-link:hover { color: #00ffff; }

    .scanlines {
      position: fixed;
      top: 0; left: 0;
      width: 100%; height: 100%;
      pointer-events: none;
      z-index: 9999;
      background: repeating-linear-gradient(
        0deg,
        rgba(0,0,0,0.03) 0px,
        rgba(0,0,0,0.03) 1px,
        transparent 1px,
        transparent 2px
      );
    }
  </style>
</head>
<body>
  <div id="canvas-container"></div>

  <div class="hud">
    <div class="title">FEE WATCHTOWER</div>
    <div class="subtitle">Real-time token reward visualization</div>
  </div>

  <div class="stats">
    <h3>REWARDS COLLECTED</h3>
    <div class="stat-row">
      <span class="stat-label">
        <span class="token-indicator" style="background: #00ffff; color: #00ffff;"></span>ETH
      </span>
      <span class="stat-value" id="eth-value">0.000</span>
    </div>
    <div class="stat-row">
      <span class="stat-label">
        <span class="token-indicator" style="background: #ff00ff; color: #ff00ff;"></span>USDC
      </span>
      <span class="stat-value" id="usdc-value">0.00</span>
    </div>
    <div class="stat-row">
      <span class="stat-label">
        <span class="token-indicator" style="background: #00ff88; color: #00ff88;"></span>WBTC
      </span>
      <span class="stat-value" id="wbtc-value">0.0000</span>
    </div>
    <div class="stat-row">
      <span class="stat-label">
        <span class="token-indicator" style="background: #ffff00; color: #ffff00;"></span>ARB
      </span>
      <span class="stat-value" id="arb-value">0.00</span>
    </div>
    <div class="total-fees">
      <div class="total-label">Total USD Value</div>
      <div class="total-value" id="total-value">$0.00</div>
    </div>
  </div>

  <div class="feed">
    <h4>LIVE FEED</h4>
    <ul class="feed-list" id="feed-list"></ul>
  </div>

  <div class="controls">
    <button class="control-btn active" id="speed-normal">1x</button>
    <button class="control-btn" id="speed-fast">5x</button>
    <button class="control-btn" id="speed-turbo">10x</button>
  </div>

  <a href="https://sloppy.live" class="back-link">sloppy.live</a>

  <div class="scanlines"></div>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script>
    // Token types with colors and prices
    const tokens = [
      { name: 'ETH', color: 0x00ffff, price: 3200, decimals: 3, minFee: 0.0001, maxFee: 0.05 },
      { name: 'USDC', color: 0xff00ff, price: 1, decimals: 2, minFee: 0.5, maxFee: 50 },
      { name: 'WBTC', color: 0x00ff88, price: 95000, decimals: 4, minFee: 0.00001, maxFee: 0.001 },
      { name: 'ARB', color: 0xffff00, price: 0.8, decimals: 2, minFee: 1, maxFee: 100 }
    ];

    // Stats tracking
    const stats = { ETH: 0, USDC: 0, WBTC: 0, ARB: 0 };
    let totalUSD = 0;
    let speedMultiplier = 1;

    // Three.js setup
    let scene, camera, renderer;
    let tower, orbs = [];
    let clock = new THREE.Clock();

    function init() {
      scene = new THREE.Scene();
      scene.fog = new THREE.FogExp2(0x000011, 0.015);

      camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
      camera.position.set(30, 25, 40);
      camera.lookAt(0, 15, 0);

      renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
      renderer.setClearColor(0x000011);
      document.getElementById('canvas-container').appendChild(renderer.domElement);

      // Lighting
      const ambient = new THREE.AmbientLight(0x222244, 0.5);
      scene.add(ambient);

      const pointLight1 = new THREE.PointLight(0x00ffff, 1, 100);
      pointLight1.position.set(20, 30, 20);
      scene.add(pointLight1);

      const pointLight2 = new THREE.PointLight(0xff00ff, 0.8, 100);
      pointLight2.position.set(-20, 20, -20);
      scene.add(pointLight2);

      createTower();
      createGround();
      createParticles();

      // Start fee generation
      generateFee();

      animate();
    }

    function createTower() {
      tower = new THREE.Group();

      // Base platform
      const baseGeo = new THREE.CylinderGeometry(8, 10, 2, 8);
      const baseMat = new THREE.MeshPhongMaterial({
        color: 0x1a1a3a,
        emissive: 0x00ffff,
        emissiveIntensity: 0.1
      });
      const base = new THREE.Mesh(baseGeo, baseMat);
      base.position.y = 1;
      tower.add(base);

      // Tower segments
      const segmentCount = 6;
      for (let i = 0; i < segmentCount; i++) {
        const bottomRadius = 6 - i * 0.7;
        const topRadius = 5.3 - i * 0.7;
        const height = 5;
        const y = 2 + i * height;

        // Main segment
        const segGeo = new THREE.CylinderGeometry(topRadius, bottomRadius, height, 8);
        const segMat = new THREE.MeshPhongMaterial({
          color: 0x1a1a3a,
          emissive: 0x00ffff,
          emissiveIntensity: 0.05,
          transparent: true,
          opacity: 0.9
        });
        const segment = new THREE.Mesh(segGeo, segMat);
        segment.position.y = y + height/2;
        tower.add(segment);

        // Glowing ring at each level
        const ringGeo = new THREE.TorusGeometry(bottomRadius + 0.3, 0.15, 8, 32);
        const ringMat = new THREE.MeshBasicMaterial({
          color: i % 2 === 0 ? 0x00ffff : 0xff00ff,
          transparent: true,
          opacity: 0.8
        });
        const ring = new THREE.Mesh(ringGeo, ringMat);
        ring.rotation.x = Math.PI / 2;
        ring.position.y = y;
        tower.add(ring);
      }

      // Top beacon
      const beaconGeo = new THREE.SphereGeometry(2, 16, 16);
      const beaconMat = new THREE.MeshBasicMaterial({
        color: 0xffffff,
        transparent: true,
        opacity: 0.9
      });
      const beacon = new THREE.Mesh(beaconGeo, beaconMat);
      beacon.position.y = 35;
      tower.add(beacon);

      // Beacon glow
      const glowGeo = new THREE.SphereGeometry(3, 16, 16);
      const glowMat = new THREE.MeshBasicMaterial({
        color: 0x00ffff,
        transparent: true,
        opacity: 0.3
      });
      const glow = new THREE.Mesh(glowGeo, glowMat);
      glow.position.y = 35;
      tower.add(glow);
      tower.userData.glow = glow;
      tower.userData.beacon = beacon;

      scene.add(tower);
    }

    function createGround() {
      // Grid floor
      const gridSize = 100;
      const gridDivisions = 50;
      const grid = new THREE.GridHelper(gridSize, gridDivisions, 0x00ffff, 0x004444);
      grid.material.opacity = 0.3;
      grid.material.transparent = true;
      scene.add(grid);

      // Ground plane
      const groundGeo = new THREE.PlaneGeometry(200, 200);
      const groundMat = new THREE.MeshPhongMaterial({
        color: 0x000022,
        transparent: true,
        opacity: 0.8
      });
      const ground = new THREE.Mesh(groundGeo, groundMat);
      ground.rotation.x = -Math.PI / 2;
      ground.position.y = -0.1;
      scene.add(ground);
    }

    function createParticles() {
      const particleCount = 200;
      const geometry = new THREE.BufferGeometry();
      const positions = new Float32Array(particleCount * 3);

      for (let i = 0; i < particleCount; i++) {
        positions[i * 3] = (Math.random() - 0.5) * 100;
        positions[i * 3 + 1] = Math.random() * 50;
        positions[i * 3 + 2] = (Math.random() - 0.5) * 100;
      }

      geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));

      const material = new THREE.PointsMaterial({
        color: 0x00ffff,
        size: 0.3,
        transparent: true,
        opacity: 0.5
      });

      const particles = new THREE.Points(geometry, material);
      scene.add(particles);
    }

    function createOrb(token) {
      const group = new THREE.Group();

      // Core orb
      const orbGeo = new THREE.SphereGeometry(0.5, 16, 16);
      const orbMat = new THREE.MeshBasicMaterial({
        color: token.color,
        transparent: true,
        opacity: 0.9
      });
      const orb = new THREE.Mesh(orbGeo, orbMat);
      group.add(orb);

      // Outer glow
      const glowGeo = new THREE.SphereGeometry(0.8, 16, 16);
      const glowMat = new THREE.MeshBasicMaterial({
        color: token.color,
        transparent: true,
        opacity: 0.3
      });
      const glow = new THREE.Mesh(glowGeo, glowMat);
      group.add(glow);

      // Trail particles
      const trailGeo = new THREE.BufferGeometry();
      const trailPositions = new Float32Array(30);
      trailGeo.setAttribute('position', new THREE.BufferAttribute(trailPositions, 3));
      const trailMat = new THREE.PointsMaterial({
        color: token.color,
        size: 0.2,
        transparent: true,
        opacity: 0.5
      });
      const trail = new THREE.Points(trailGeo, trailMat);
      group.add(trail);

      // Random spawn position around tower base
      const angle = Math.random() * Math.PI * 2;
      const radius = 12 + Math.random() * 8;
      group.position.set(
        Math.cos(angle) * radius,
        0,
        Math.sin(angle) * radius
      );

      group.userData = {
        token,
        speed: 8 + Math.random() * 4,
        spiralSpeed: 0.5 + Math.random() * 0.5,
        angle: angle,
        radius: radius,
        collected: false
      };

      scene.add(group);
      orbs.push(group);

      return group;
    }

    function generateFee() {
      const token = tokens[Math.floor(Math.random() * tokens.length)];
      const amount = token.minFee + Math.random() * (token.maxFee - token.minFee);

      const orb = createOrb(token);
      orb.userData.amount = amount;

      // Add to feed
      addFeedItem(token, amount);

      // Schedule next fee
      const delay = (500 + Math.random() * 1500) / speedMultiplier;
      setTimeout(generateFee, delay);
    }

    function addFeedItem(token, amount) {
      const feedList = document.getElementById('feed-list');
      const item = document.createElement('li');
      item.className = 'feed-item';
      item.innerHTML = `+<span class="amount" style="color: #${token.color.toString(16).padStart(6, '0')}">${amount.toFixed(token.decimals)} ${token.name}</span> fee collected`;

      feedList.insertBefore(item, feedList.firstChild);

      // Keep only last 8 items
      while (feedList.children.length > 8) {
        feedList.removeChild(feedList.lastChild);
      }
    }

    function updateStats(token, amount) {
      stats[token.name] += amount;
      totalUSD += amount * token.price;

      document.getElementById('eth-value').textContent = stats.ETH.toFixed(3);
      document.getElementById('usdc-value').textContent = stats.USDC.toFixed(2);
      document.getElementById('wbtc-value').textContent = stats.WBTC.toFixed(4);
      document.getElementById('arb-value').textContent = stats.ARB.toFixed(2);
      document.getElementById('total-value').textContent = '$' + totalUSD.toFixed(2);
    }

    function animate() {
      requestAnimationFrame(animate);

      const delta = clock.getDelta();
      const time = clock.getElapsedTime();

      // Rotate camera slowly
      camera.position.x = Math.sin(time * 0.1) * 45;
      camera.position.z = Math.cos(time * 0.1) * 45;
      camera.lookAt(0, 15, 0);

      // Animate tower beacon
      if (tower.userData.glow) {
        tower.userData.glow.scale.setScalar(1 + Math.sin(time * 3) * 0.2);
        tower.userData.beacon.material.opacity = 0.7 + Math.sin(time * 5) * 0.3;
      }

      // Animate orbs
      for (let i = orbs.length - 1; i >= 0; i--) {
        const orb = orbs[i];
        const data = orb.userData;

        if (!data.collected) {
          // Rise and spiral toward tower
          orb.position.y += data.speed * delta * speedMultiplier;
          data.angle += data.spiralSpeed * delta * speedMultiplier;

          // Spiral inward
          const progress = Math.min(orb.position.y / 35, 1);
          const currentRadius = data.radius * (1 - progress * 0.8);

          orb.position.x = Math.cos(data.angle) * currentRadius;
          orb.position.z = Math.sin(data.angle) * currentRadius;

          // Pulse effect
          orb.children[0].scale.setScalar(1 + Math.sin(time * 10) * 0.1);
          orb.children[1].scale.setScalar(1 + Math.sin(time * 8) * 0.2);

          // Check if reached beacon
          if (orb.position.y >= 35) {
            data.collected = true;
            updateStats(data.token, data.amount);

            // Burst effect
            orb.children[1].scale.setScalar(3);
            orb.children[1].material.opacity = 0.8;

            // Remove after burst
            setTimeout(() => {
              scene.remove(orb);
              const idx = orbs.indexOf(orb);
              if (idx > -1) orbs.splice(idx, 1);
            }, 200);
          }
        }
      }

      renderer.render(scene, camera);
    }

    // Speed controls
    document.getElementById('speed-normal').addEventListener('click', () => {
      speedMultiplier = 1;
      updateSpeedButtons('speed-normal');
    });

    document.getElementById('speed-fast').addEventListener('click', () => {
      speedMultiplier = 5;
      updateSpeedButtons('speed-fast');
    });

    document.getElementById('speed-turbo').addEventListener('click', () => {
      speedMultiplier = 10;
      updateSpeedButtons('speed-turbo');
    });

    function updateSpeedButtons(activeId) {
      document.querySelectorAll('.control-btn').forEach(btn => {
        btn.classList.remove('active');
      });
      document.getElementById(activeId).classList.add('active');
    }

    // Resize handler
    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });

    init();
  </script>
<script src="/sloppy-header/sloppy-bar.js"></script>
<script src="/vibelib-extended.js"></script>
<script>
  // Compatibility Patch for Legacy Apps
  window.addEventListener("load", () => {
    if (window.SloppyKarma && window.VibeLib.Economy) {
      // Redirect old calls to new engine
      window.SloppyKarma.track = window.VibeLib.Economy.track;
    }
  });
</script>
</body>
</html>
