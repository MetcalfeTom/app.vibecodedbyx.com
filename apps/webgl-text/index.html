<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WebGL Text Distortion</title>
    <link rel="icon" href="https://emojicdn.elk.sh/‚ú®">

    <meta property="og:title" content="WebGL Text Distortion">
    <meta property="og:description" content="Interactive 3D text that reacts to your mouse">
    <meta property="og:url" content="https://app.sloppy.live/webgl-text">
    <meta property="og:image" content="https://emojicdn.elk.sh/‚ú®.png">

    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Arial Black', sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            overflow: hidden;
            cursor: none;
        }

        canvas {
            display: block;
            width: 100%;
            height: 100vh;
        }

        .cursor {
            position: fixed;
            width: 20px;
            height: 20px;
            border: 2px solid rgba(255, 255, 255, 0.8);
            border-radius: 50%;
            pointer-events: none;
            transform: translate(-50%, -50%);
            transition: width 0.2s, height 0.2s;
            z-index: 1000;
        }

        .cursor.hover {
            width: 40px;
            height: 40px;
            background: rgba(255, 255, 255, 0.1);
        }

        .info {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            color: rgba(255, 255, 255, 0.7);
            font-size: 14px;
            text-align: center;
        }

        .back-link {
            position: fixed;
            top: 20px;
            left: 20px;
            background: rgba(255, 255, 255, 0.9);
            color: #333;
            text-decoration: none;
            padding: 10px 20px;
            border-radius: 25px;
            font-weight: bold;
            transition: all 0.3s;
            z-index: 1000;
        }

        .back-link:hover {
            background: #fff;
            transform: translateY(-2px);
        }
    </style>
</head>
<body>
    <a href="https://sloppy.live" class="back-link">‚Üê Back</a>
            <a href="https://app.sloppy.live/overview" style="color:#4ecdc4;text-decoration:none;margin-left:10px">üé® View All Apps</a>
    <canvas id="canvas"></canvas>
    <div class="cursor" id="cursor"></div>
    <div class="info">Move your mouse to distort the text</div>

    <script id="vertexShader" type="x-shader/x-vertex">
        attribute vec2 a_position;
        attribute vec2 a_texCoord;

        uniform vec2 u_resolution;
        uniform vec2 u_mouse;
        uniform float u_time;

        varying vec2 v_texCoord;
        varying float v_distortion;

        void main() {
            vec2 position = a_position;

            // Calculate distance from mouse
            vec2 mousePos = u_mouse / u_resolution;
            vec2 vertexPos = (a_position + 1.0) * 0.5;
            float dist = distance(mousePos, vertexPos);

            // Distortion effect
            float maxDist = 0.3;
            if (dist < maxDist) {
                float distortion = (1.0 - dist / maxDist) * 0.15;
                vec2 direction = normalize(vertexPos - mousePos);
                position += direction * distortion * sin(u_time * 3.0 + dist * 10.0);
                v_distortion = distortion;
            } else {
                v_distortion = 0.0;
            }

            gl_Position = vec4(position, 0.0, 1.0);
            v_texCoord = a_texCoord;
        }
    </script>

    <script id="fragmentShader" type="x-shader/x-fragment">
        precision mediump float;

        uniform sampler2D u_texture;
        uniform vec2 u_mouse;
        uniform vec2 u_resolution;
        uniform float u_time;

        varying vec2 v_texCoord;
        varying float v_distortion;

        void main() {
            vec2 uv = v_texCoord;

            // Wave distortion on texture coordinates
            if (v_distortion > 0.0) {
                uv.x += sin(uv.y * 20.0 + u_time * 2.0) * v_distortion * 0.05;
                uv.y += cos(uv.x * 20.0 + u_time * 2.0) * v_distortion * 0.05;
            }

            vec4 texColor = texture2D(u_texture, uv);

            // Color shift based on distortion
            if (v_distortion > 0.0) {
                vec3 color = texColor.rgb;
                color.r += sin(u_time * 2.0) * v_distortion * 0.3;
                color.g += cos(u_time * 3.0) * v_distortion * 0.3;
                color.b += sin(u_time * 4.0) * v_distortion * 0.3;
                texColor.rgb = color;
            }

            gl_FragColor = texColor;
        }
    </script>

    <script>
        const canvas = document.getElementById('canvas');
        const gl = canvas.getContext('webgl');
        const cursor = document.getElementById('cursor');

        if (!gl) {
            alert('WebGL not supported');
            throw new Error('WebGL not supported');
        }

        // Resize canvas
        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            gl.viewport(0, 0, canvas.width, canvas.height);
        }
        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);

        // Mouse tracking
        let mouseX = canvas.width / 2;
        let mouseY = canvas.height / 2;
        let isHovering = false;

        document.addEventListener('mousemove', (e) => {
            mouseX = e.clientX;
            mouseY = e.clientY;
            cursor.style.left = mouseX + 'px';
            cursor.style.top = mouseY + 'px';

            // Check if hovering near center
            const centerX = canvas.width / 2;
            const centerY = canvas.height / 2;
            const dist = Math.sqrt((mouseX - centerX) ** 2 + (mouseY - centerY) ** 2);
            isHovering = dist < 200;
            cursor.classList.toggle('hover', isHovering);
        });

        // Compile shader
        function compileShader(gl, source, type) {
            const shader = gl.createShader(type);
            gl.shaderSource(shader, source);
            gl.compileShader(shader);

            if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                console.error('Shader compile error:', gl.getShaderInfoLog(shader));
                gl.deleteShader(shader);
                return null;
            }
            return shader;
        }

        // Create program
        function createProgram(gl, vertexShader, fragmentShader) {
            const program = gl.createProgram();
            gl.attachShader(program, vertexShader);
            gl.attachShader(program, fragmentShader);
            gl.linkProgram(program);

            if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
                console.error('Program link error:', gl.getProgramInfoLog(program));
                return null;
            }
            return program;
        }

        // Get shader sources
        const vertexSource = document.getElementById('vertexShader').textContent;
        const fragmentSource = document.getElementById('fragmentShader').textContent;

        // Compile shaders
        const vertexShader = compileShader(gl, vertexSource, gl.VERTEX_SHADER);
        const fragmentShader = compileShader(gl, fragmentSource, gl.FRAGMENT_SHADER);
        const program = createProgram(gl, vertexShader, fragmentShader);

        // Get attribute/uniform locations
        const positionLocation = gl.getAttribLocation(program, 'a_position');
        const texCoordLocation = gl.getAttribLocation(program, 'a_texCoord');
        const resolutionLocation = gl.getUniformLocation(program, 'u_resolution');
        const mouseLocation = gl.getUniformLocation(program, 'u_mouse');
        const timeLocation = gl.getUniformLocation(program, 'u_time');
        const textureLocation = gl.getUniformLocation(program, 'u_texture');

        // Create buffers
        const positionBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([
            -0.8, -0.3,
             0.8, -0.3,
            -0.8,  0.3,
            -0.8,  0.3,
             0.8, -0.3,
             0.8,  0.3,
        ]), gl.STATIC_DRAW);

        const texCoordBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, texCoordBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([
            0, 1,
            1, 1,
            0, 0,
            0, 0,
            1, 1,
            1, 0,
        ]), gl.STATIC_DRAW);

        // Create text texture
        function createTextTexture(text) {
            const textCanvas = document.createElement('canvas');
            textCanvas.width = 1024;
            textCanvas.height = 256;
            const ctx = textCanvas.getContext('2d');

            // Draw text
            ctx.fillStyle = 'rgba(0, 0, 0, 0)';
            ctx.fillRect(0, 0, textCanvas.width, textCanvas.height);

            ctx.font = 'bold 120px Arial Black';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';

            // Gradient fill
            const gradient = ctx.createLinearGradient(0, 0, textCanvas.width, 0);
            gradient.addColorStop(0, '#ff6b6b');
            gradient.addColorStop(0.5, '#4ecdc4');
            gradient.addColorStop(1, '#45b7d1');
            ctx.fillStyle = gradient;
            ctx.fillText(text, textCanvas.width / 2, textCanvas.height / 2);

            // Create WebGL texture
            const texture = gl.createTexture();
            gl.bindTexture(gl.TEXTURE_2D, texture);
            gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, textCanvas);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);

            return texture;
        }

        const texture = createTextTexture('VIBE CODE');

        // Render loop
        function render(time) {
            time *= 0.001; // Convert to seconds

            gl.clearColor(0, 0, 0, 0);
            gl.clear(gl.COLOR_BUFFER_BIT);

            gl.useProgram(program);

            // Set uniforms
            gl.uniform2f(resolutionLocation, canvas.width, canvas.height);
            gl.uniform2f(mouseLocation, mouseX, canvas.height - mouseY);
            gl.uniform1f(timeLocation, time);

            // Bind texture
            gl.activeTexture(gl.TEXTURE0);
            gl.bindTexture(gl.TEXTURE_2D, texture);
            gl.uniform1i(textureLocation, 0);

            // Set attributes
            gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
            gl.enableVertexAttribArray(positionLocation);
            gl.vertexAttribPointer(positionLocation, 2, gl.FLOAT, false, 0, 0);

            gl.bindBuffer(gl.ARRAY_BUFFER, texCoordBuffer);
            gl.enableVertexAttribArray(texCoordLocation);
            gl.vertexAttribPointer(texCoordLocation, 2, gl.FLOAT, false, 0, 0);

            // Enable blending for transparency
            gl.enable(gl.BLEND);
            gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);

            // Draw
            gl.drawArrays(gl.TRIANGLES, 0, 6);

            requestAnimationFrame(render);
        }

        requestAnimationFrame(render);
    </script>
<script src="/sloppy-header/sloppy-bar.js"></script>
</body>
</html>
