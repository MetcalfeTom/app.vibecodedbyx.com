<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Ghost Town Radio</title>
  <link rel="icon" href="https://emojicdn.elk.sh/ðŸŒµ">
  <meta name="description" content="Tune in to the loneliest station on earth.">
  <meta property="og:title" content="Ghost Town Radio">
  <meta property="og:description" content="Eerie winds and tumbleweeds from a forgotten desert town.">
  <meta property="og:url" content="https://sloppy.live/ghost-town-radio">
  <meta property="og:image" content="https://sloppy.live/ghost-town-radio/og-image.png">
  <meta property="og:type" content="website">
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link href="https://fonts.googleapis.com/css2?family=Rye&family=Special+Elite&display=swap" rel="stylesheet">
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }
    body {
      background: linear-gradient(180deg, #1a1510 0%, #2d2318 40%, #3d2f1f 70%, #4a3828 100%);
      font-family: 'Special Elite', monospace;
      min-height: 100vh;
      overflow: hidden;
      color: #c9a66b;
    }
    .sky {
      position: fixed;
      inset: 0;
      background: linear-gradient(180deg,
        #0d0908 0%,
        #1a1210 30%,
        #2a1f15 50%,
        #3d2a1a 70%,
        #5a3d25 100%
      );
    }
    .stars {
      position: fixed;
      inset: 0;
      pointer-events: none;
    }
    .star {
      position: absolute;
      width: 2px;
      height: 2px;
      background: #fff;
      border-radius: 50%;
      opacity: 0.3;
      animation: twinkle 3s ease-in-out infinite;
    }
    @keyframes twinkle {
      0%, 100% { opacity: 0.2; }
      50% { opacity: 0.6; }
    }
    .shooting-star {
      position: fixed;
      pointer-events: none;
      z-index: 1;
      width: 3px;
      height: 3px;
      background: #fff;
      border-radius: 50%;
      box-shadow: 0 0 6px 2px rgba(255, 255, 255, 0.8);
    }
    .shooting-star::after {
      content: '';
      position: absolute;
      top: 50%;
      right: 100%;
      transform: translateY(-50%);
      width: 80px;
      height: 2px;
      background: linear-gradient(to left, rgba(255, 255, 255, 0.8), rgba(255, 255, 255, 0.3), transparent);
      border-radius: 2px;
    }
    .moon {
      position: fixed;
      top: 60px;
      right: 15%;
      width: 80px;
      height: 80px;
      background: radial-gradient(circle at 30% 30%, #f5e6c8, #d4c4a0, #a89070);
      border-radius: 50%;
      box-shadow: 0 0 60px rgba(245, 230, 200, 0.3), 0 0 120px rgba(245, 230, 200, 0.1);
      opacity: 0.8;
    }
    .ground {
      position: fixed;
      bottom: 0;
      left: 0;
      right: 0;
      height: 30vh;
      background: linear-gradient(180deg, #3d2a1a 0%, #2a1d12 100%);
      cursor: crosshair;
      z-index: 2;
    }
    .planted-cactus {
      position: absolute;
      pointer-events: none;
      transform-origin: bottom center;
      animation: cactusGrow 0.5s ease-out forwards;
    }
    @keyframes cactusGrow {
      0% { transform: scale(0) translateY(10px); opacity: 0; }
      50% { transform: scale(1.1) translateY(-2px); }
      100% { transform: scale(1) translateY(0); opacity: 1; }
    }
    .plant-hint {
      position: fixed;
      bottom: 32vh;
      left: 50%;
      transform: translateX(-50%);
      font-size: 10px;
      color: #5a4020;
      opacity: 0.5;
      pointer-events: none;
      z-index: 3;
    }
    .horizon {
      position: fixed;
      bottom: 30vh;
      left: 0;
      right: 0;
      height: 4px;
      background: linear-gradient(90deg, transparent, rgba(90, 60, 30, 0.5), transparent);
    }
    .dust-overlay {
      position: fixed;
      inset: 0;
      background: url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 100 100"><circle cx="50" cy="50" r="1" fill="rgba(201,166,107,0.03)"/></svg>');
      background-size: 8px 8px;
      pointer-events: none;
      animation: dustDrift 20s linear infinite;
    }
    @keyframes dustDrift {
      from { transform: translateX(0); }
      to { transform: translateX(-100px); }
    }
    .container {
      position: relative;
      z-index: 10;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      min-height: 100vh;
      padding: 20px;
      text-align: center;
    }
    h1 {
      font-family: 'Rye', serif;
      font-size: clamp(32px, 8vw, 64px);
      color: #8b6914;
      text-shadow:
        0 2px 0 #3d2a1a,
        0 4px 10px rgba(0, 0, 0, 0.5),
        0 0 40px rgba(139, 105, 20, 0.3);
      margin-bottom: 10px;
      letter-spacing: 2px;
    }
    .subtitle {
      font-size: 14px;
      color: #7a6040;
      letter-spacing: 4px;
      text-transform: uppercase;
      margin-bottom: 40px;
    }
    .radio-dial {
      width: 200px;
      height: 200px;
      background: radial-gradient(circle, #2a2015 0%, #1a1510 100%);
      border-radius: 50%;
      border: 4px solid #5a4020;
      box-shadow:
        inset 0 0 30px rgba(0, 0, 0, 0.5),
        0 0 20px rgba(90, 64, 32, 0.3);
      display: flex;
      align-items: center;
      justify-content: center;
      position: relative;
      margin-bottom: 30px;
    }
    .dial-marks {
      position: absolute;
      inset: 10px;
      border-radius: 50%;
      border: 2px dashed rgba(139, 105, 20, 0.3);
    }
    .frequency {
      font-family: 'Special Elite', monospace;
      font-size: 28px;
      color: #c9a66b;
      text-shadow: 0 0 10px rgba(201, 166, 107, 0.5);
    }
    .frequency-label {
      font-size: 10px;
      color: #7a6040;
      margin-top: 5px;
    }
    .status {
      display: flex;
      align-items: center;
      gap: 10px;
      margin-bottom: 30px;
    }
    .status-dot {
      width: 10px;
      height: 10px;
      background: #5a3d25;
      border-radius: 50%;
      transition: all 0.3s;
    }
    .status-dot.active {
      background: #c9a66b;
      box-shadow: 0 0 10px rgba(201, 166, 107, 0.8);
      animation: pulse 2s ease-in-out infinite;
    }
    @keyframes pulse {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.5; }
    }
    .status-text {
      font-size: 12px;
      color: #7a6040;
      text-transform: uppercase;
      letter-spacing: 2px;
    }
    .play-btn {
      background: linear-gradient(180deg, #5a4020 0%, #3d2a1a 100%);
      border: 2px solid #8b6914;
      border-radius: 8px;
      padding: 15px 40px;
      color: #c9a66b;
      font-family: 'Rye', serif;
      font-size: 16px;
      cursor: pointer;
      transition: all 0.3s;
      text-transform: uppercase;
      letter-spacing: 2px;
    }
    .play-btn:hover {
      background: linear-gradient(180deg, #6a5030 0%, #4d3a2a 100%);
      box-shadow: 0 0 20px rgba(139, 105, 20, 0.4);
    }
    .play-btn.playing {
      background: linear-gradient(180deg, #8b6914 0%, #5a4020 100%);
      color: #1a1510;
    }
    .tumbleweed {
      position: fixed;
      pointer-events: none;
      z-index: 5;
      opacity: 0.7;
    }
    .tumbleweed svg {
      width: 100%;
      height: 100%;
    }
    .silhouettes {
      position: fixed;
      bottom: 30vh;
      left: 0;
      right: 0;
      height: 100px;
      pointer-events: none;
      z-index: 3;
    }
    .cactus {
      position: absolute;
      bottom: 0;
    }
    .building {
      position: absolute;
      bottom: 0;
      background: #1a1510;
    }
    .building::before {
      content: '';
      position: absolute;
      top: -20px;
      left: 50%;
      transform: translateX(-50%);
      border-left: 30px solid transparent;
      border-right: 30px solid transparent;
      border-bottom: 20px solid #1a1510;
    }
    .message {
      position: fixed;
      bottom: 60px;
      left: 50%;
      transform: translateX(-50%);
      font-size: 12px;
      color: #5a4020;
      letter-spacing: 1px;
      white-space: nowrap;
    }
    .backlink {
      position: fixed;
      bottom: 20px;
      right: 20px;
      color: #5a4020;
      font-size: 11px;
      text-decoration: none;
      z-index: 20;
    }
    .backlink:hover {
      color: #8b6914;
    }
    .wind-lines {
      position: fixed;
      inset: 0;
      pointer-events: none;
      overflow: hidden;
    }
    .wind-line {
      position: absolute;
      height: 1px;
      background: linear-gradient(90deg, transparent, rgba(201, 166, 107, 0.1), transparent);
      animation: windBlow 3s linear infinite;
      opacity: 0;
    }
    body.playing .wind-line {
      opacity: 1;
    }
    @keyframes windBlow {
      from { transform: translateX(-100%); }
      to { transform: translateX(100vw); }
    }
    .whisper-section {
      position: fixed;
      bottom: 100px;
      left: 50%;
      transform: translateX(-50%);
      z-index: 20;
      text-align: center;
    }
    .whisper-label {
      font-size: 11px;
      color: #5a4020;
      text-transform: uppercase;
      letter-spacing: 2px;
      margin-bottom: 10px;
      opacity: 0.7;
    }
    .whisper-input {
      background: rgba(26, 21, 16, 0.8);
      border: 1px solid #5a4020;
      border-radius: 25px;
      padding: 12px 20px;
      color: #c9a66b;
      font-family: 'Special Elite', monospace;
      font-size: 14px;
      width: 280px;
      max-width: 80vw;
      outline: none;
      transition: all 0.3s;
    }
    .whisper-input::placeholder {
      color: #5a4020;
      opacity: 0.6;
    }
    .whisper-input:focus {
      border-color: #8b6914;
      box-shadow: 0 0 20px rgba(139, 105, 20, 0.2);
    }
    .floating-whisper {
      position: fixed;
      pointer-events: none;
      z-index: 15;
      font-family: 'Special Elite', monospace;
      color: #c9a66b;
      text-shadow: 0 0 10px rgba(201, 166, 107, 0.3);
      white-space: nowrap;
      transition: none;
    }
    .whisper-hint {
      font-size: 10px;
      color: #5a4020;
      margin-top: 8px;
      opacity: 0.5;
    }
    .traveler {
      position: fixed;
      bottom: 30vh;
      pointer-events: none;
      z-index: 4;
      display: flex;
      flex-direction: column;
      align-items: center;
    }
    .traveler-figure {
      width: 20px;
      height: 45px;
      position: relative;
    }
    .traveler-body {
      position: absolute;
      bottom: 0;
      left: 50%;
      transform: translateX(-50%);
      width: 8px;
      height: 25px;
      background: #1a1510;
      border-radius: 3px 3px 0 0;
    }
    .traveler-head {
      position: absolute;
      bottom: 25px;
      left: 50%;
      transform: translateX(-50%);
      width: 10px;
      height: 10px;
      background: #1a1510;
      border-radius: 50%;
    }
    .traveler-hat {
      position: absolute;
      bottom: 33px;
      left: 50%;
      transform: translateX(-50%);
      width: 16px;
      height: 4px;
      background: #1a1510;
      border-radius: 2px;
    }
    .traveler-hat::before {
      content: '';
      position: absolute;
      bottom: 3px;
      left: 50%;
      transform: translateX(-50%);
      width: 8px;
      height: 6px;
      background: #1a1510;
      border-radius: 2px 2px 0 0;
    }
    .traveler-leg {
      position: absolute;
      bottom: -12px;
      width: 3px;
      height: 14px;
      background: #1a1510;
    }
    .traveler-leg.left {
      left: 3px;
      animation: walkLeft 0.8s ease-in-out infinite;
    }
    .traveler-leg.right {
      right: 3px;
      animation: walkRight 0.8s ease-in-out infinite;
    }
    @keyframes walkLeft {
      0%, 100% { transform: rotate(-15deg); }
      50% { transform: rotate(15deg); }
    }
    @keyframes walkRight {
      0%, 100% { transform: rotate(15deg); }
      50% { transform: rotate(-15deg); }
    }
    .lantern {
      position: absolute;
      right: -15px;
      bottom: 10px;
      width: 8px;
      height: 12px;
    }
    .lantern-handle {
      position: absolute;
      top: 0;
      left: 50%;
      transform: translateX(-50%);
      width: 6px;
      height: 3px;
      border: 1px solid #5a4020;
      border-bottom: none;
      border-radius: 3px 3px 0 0;
    }
    .lantern-body {
      position: absolute;
      top: 3px;
      left: 50%;
      transform: translateX(-50%);
      width: 6px;
      height: 8px;
      background: #2a1d12;
      border: 1px solid #5a4020;
      border-radius: 1px;
    }
    .lantern-glow {
      position: absolute;
      top: 4px;
      left: 50%;
      transform: translateX(-50%);
      width: 4px;
      height: 5px;
      background: #ffaa00;
      border-radius: 1px;
      box-shadow:
        0 0 8px 2px rgba(255, 170, 0, 0.8),
        0 0 20px 5px rgba(255, 170, 0, 0.4),
        0 0 40px 10px rgba(255, 170, 0, 0.2);
      animation: flicker 0.15s ease-in-out infinite;
    }
    @keyframes flicker {
      0%, 100% { opacity: 1; transform: translateX(-50%) scale(1); }
      25% { opacity: 0.8; transform: translateX(-50%) scale(0.95); }
      50% { opacity: 0.9; transform: translateX(-50%) scale(1.02); }
      75% { opacity: 0.7; transform: translateX(-50%) scale(0.98); }
    }
    .lantern-light-cone {
      position: absolute;
      top: 12px;
      left: 50%;
      transform: translateX(-50%);
      width: 0;
      height: 0;
      border-left: 15px solid transparent;
      border-right: 15px solid transparent;
      border-top: 30px solid rgba(255, 170, 0, 0.1);
      filter: blur(5px);
      animation: flicker 0.15s ease-in-out infinite;
    }
    @keyframes trackVibrate {
      0%, 100% { transform: translateY(0); }
      50% { transform: translateY(0.5px); }
    }
  </style>
</head>
<body>
  <div class="sky"></div>
  <div class="stars" id="stars"></div>
  <div class="moon"></div>
  <div class="ground" id="ground"></div>
  <div class="plant-hint">click the ground to plant a cactus</div>
  <div class="horizon"></div>
  <div class="dust-overlay"></div>
  <div class="wind-lines" id="windLines"></div>

  <div class="silhouettes">
    <svg class="cactus" style="left: 10%; height: 60px; width: 30px;" viewBox="0 0 30 60">
      <path d="M15 60 L15 20 M15 30 L5 30 L5 20 M15 25 L25 25 L25 15" stroke="#1a1510" stroke-width="6" fill="none" stroke-linecap="round"/>
    </svg>
    <svg class="cactus" style="left: 85%; height: 80px; width: 40px;" viewBox="0 0 40 80">
      <path d="M20 80 L20 25 M20 40 L8 40 L8 25 M20 35 L32 35 L32 20" stroke="#1a1510" stroke-width="6" fill="none" stroke-linecap="round"/>
    </svg>
    <div class="building" style="left: 30%; width: 40px; height: 50px;"></div>
    <div class="building" style="left: 35%; width: 60px; height: 70px;"></div>
    <div class="building" style="left: 60%; width: 50px; height: 55px;"></div>
  </div>

  <div class="container">
    <h1>Ghost Town Radio</h1>
    <p class="subtitle">Broadcasting from nowhere</p>

    <div class="radio-dial">
      <div class="dial-marks"></div>
      <div>
        <div class="frequency">66.6</div>
        <div class="frequency-label">FM</div>
      </div>
    </div>

    <div class="status">
      <div class="status-dot" id="statusDot"></div>
      <span class="status-text" id="statusText">Off Air</span>
    </div>

    <button class="play-btn" id="playBtn">Tune In</button>
  </div>

  <div class="whisper-section">
    <div class="whisper-label">Whisper to the Void</div>
    <input type="text" class="whisper-input" id="whisperInput" placeholder="Type your message..." maxlength="50">
    <div class="whisper-hint">Press Enter to release your words into the wind</div>
  </div>

  <div class="message">...nothing but dust and memories out here...</div>
  <a href="https://sloppy.live" class="backlink">sloppy.live</a>

  <script>
    // Create stars
    const starsEl = document.getElementById('stars');
    for (let i = 0; i < 50; i++) {
      const star = document.createElement('div');
      star.className = 'star';
      star.style.left = Math.random() * 100 + '%';
      star.style.top = Math.random() * 50 + '%';
      star.style.animationDelay = Math.random() * 3 + 's';
      star.style.width = (1 + Math.random() * 2) + 'px';
      star.style.height = star.style.width;
      starsEl.appendChild(star);
    }

    // Create wind lines
    const windLines = document.getElementById('windLines');
    for (let i = 0; i < 8; i++) {
      const line = document.createElement('div');
      line.className = 'wind-line';
      line.style.top = (20 + Math.random() * 60) + '%';
      line.style.width = (100 + Math.random() * 200) + 'px';
      line.style.animationDelay = Math.random() * 3 + 's';
      line.style.animationDuration = (2 + Math.random() * 2) + 's';
      windLines.appendChild(line);
    }

    // Tumbleweed SVG
    function createTumbleweedSVG() {
      return `<svg viewBox="0 0 100 100">
        <g fill="none" stroke="#5a4020" stroke-width="2">
          <circle cx="50" cy="50" r="35" opacity="0.6"/>
          <circle cx="50" cy="50" r="25" opacity="0.5"/>
          <circle cx="50" cy="50" r="15" opacity="0.4"/>
          <path d="M50 15 Q60 50 50 85" opacity="0.5"/>
          <path d="M15 50 Q50 60 85 50" opacity="0.5"/>
          <path d="M25 25 Q50 50 75 75" opacity="0.4"/>
          <path d="M75 25 Q50 50 25 75" opacity="0.4"/>
          <path d="M50 20 Q70 40 50 80" opacity="0.3"/>
          <path d="M20 50 Q40 70 80 50" opacity="0.3"/>
        </g>
      </svg>`;
    }

    // Spawn tumbleweeds
    const tumbleweeds = [];

    function spawnTumbleweed() {
      const tw = document.createElement('div');
      tw.className = 'tumbleweed';
      tw.innerHTML = createTumbleweedSVG();

      const size = 40 + Math.random() * 60;
      tw.style.width = size + 'px';
      tw.style.height = size + 'px';

      const startY = 50 + Math.random() * 30; // bottom half
      tw.style.top = startY + 'vh';
      tw.style.left = '-100px';

      document.body.appendChild(tw);

      const speed = 1 + Math.random() * 2;
      const rotationSpeed = 2 + Math.random() * 3;
      const bounceHeight = 5 + Math.random() * 15;
      const bounceSpeed = 0.5 + Math.random() * 0.5;

      tumbleweeds.push({
        el: tw,
        x: -100,
        baseY: startY,
        speed,
        rotationSpeed,
        rotation: 0,
        bounceHeight,
        bounceSpeed,
        time: Math.random() * Math.PI * 2
      });
    }

    function updateTumbleweeds() {
      for (let i = tumbleweeds.length - 1; i >= 0; i--) {
        const tw = tumbleweeds[i];
        tw.x += tw.speed;
        tw.rotation += tw.rotationSpeed;
        tw.time += 0.05 * tw.bounceSpeed;

        const bounce = Math.abs(Math.sin(tw.time)) * tw.bounceHeight;
        const y = tw.baseY - bounce;

        tw.el.style.left = tw.x + 'px';
        tw.el.style.top = y + 'vh';
        tw.el.style.transform = `rotate(${tw.rotation}deg)`;

        // Remove if off screen
        if (tw.x > window.innerWidth + 100) {
          tw.el.remove();
          tumbleweeds.splice(i, 1);
        }
      }

      requestAnimationFrame(updateTumbleweeds);
    }

    updateTumbleweeds();

    // Spawn tumbleweeds periodically
    setInterval(() => {
      if (tumbleweeds.length < 5) {
        spawnTumbleweed();
      }
    }, 3000);

    // Initial tumbleweed
    setTimeout(spawnTumbleweed, 1000);

    // Audio
    let audioContext = null;
    let isPlaying = false;
    let windNode = null;
    let radioNode = null;

    const playBtn = document.getElementById('playBtn');
    const statusDot = document.getElementById('statusDot');
    const statusText = document.getElementById('statusText');

    function createWindNoise() {
      const bufferSize = 2 * audioContext.sampleRate;
      const noiseBuffer = audioContext.createBuffer(1, bufferSize, audioContext.sampleRate);
      const output = noiseBuffer.getChannelData(0);

      for (let i = 0; i < bufferSize; i++) {
        output[i] = Math.random() * 2 - 1;
      }

      const whiteNoise = audioContext.createBufferSource();
      whiteNoise.buffer = noiseBuffer;
      whiteNoise.loop = true;

      // Low pass filter for wind effect
      const lowPass = audioContext.createBiquadFilter();
      lowPass.type = 'lowpass';
      lowPass.frequency.value = 400;
      lowPass.Q.value = 1;

      // High pass to remove rumble
      const highPass = audioContext.createBiquadFilter();
      highPass.type = 'highpass';
      highPass.frequency.value = 80;

      // Gain with LFO for gusting
      const gain = audioContext.createGain();
      gain.gain.value = 0.15;

      // LFO for wind gusts
      const lfo = audioContext.createOscillator();
      const lfoGain = audioContext.createGain();
      lfo.frequency.value = 0.1;
      lfoGain.gain.value = 0.08;
      lfo.connect(lfoGain);
      lfoGain.connect(gain.gain);
      lfo.start();

      // Modulate filter frequency for howling
      const filterLfo = audioContext.createOscillator();
      const filterLfoGain = audioContext.createGain();
      filterLfo.frequency.value = 0.05;
      filterLfoGain.gain.value = 200;
      filterLfo.connect(filterLfoGain);
      filterLfoGain.connect(lowPass.frequency);
      filterLfo.start();

      whiteNoise.connect(lowPass);
      lowPass.connect(highPass);
      highPass.connect(gain);
      gain.connect(audioContext.destination);

      whiteNoise.start();

      return { source: whiteNoise, lfo, filterLfo, gain };
    }

    function createRadioStatic() {
      const bufferSize = audioContext.sampleRate;
      const noiseBuffer = audioContext.createBuffer(1, bufferSize, audioContext.sampleRate);
      const output = noiseBuffer.getChannelData(0);

      for (let i = 0; i < bufferSize; i++) {
        output[i] = Math.random() * 2 - 1;
      }

      const noise = audioContext.createBufferSource();
      noise.buffer = noiseBuffer;
      noise.loop = true;

      // Band pass for radio crackle
      const bandPass = audioContext.createBiquadFilter();
      bandPass.type = 'bandpass';
      bandPass.frequency.value = 2000;
      bandPass.Q.value = 5;

      const gain = audioContext.createGain();
      gain.gain.value = 0.02;

      // Random crackle
      const crackleLfo = audioContext.createOscillator();
      crackleLfo.type = 'square';
      crackleLfo.frequency.value = 0.3;
      const crackleLfoGain = audioContext.createGain();
      crackleLfoGain.gain.value = 0.015;
      crackleLfo.connect(crackleLfoGain);
      crackleLfoGain.connect(gain.gain);
      crackleLfo.start();

      noise.connect(bandPass);
      bandPass.connect(gain);
      gain.connect(audioContext.destination);

      noise.start();

      return { source: noise, lfo: crackleLfo, gain };
    }

    function startAudio() {
      if (!audioContext) {
        audioContext = new (window.AudioContext || window.webkitAudioContext)();
      }

      windNode = createWindNoise();
      radioNode = createRadioStatic();

      isPlaying = true;
      document.body.classList.add('playing');
      playBtn.textContent = 'Sign Off';
      playBtn.classList.add('playing');
      statusDot.classList.add('active');
      statusText.textContent = 'On Air';
    }

    function stopAudio() {
      if (windNode) {
        windNode.source.stop();
        windNode.lfo.stop();
        windNode.filterLfo.stop();
        windNode = null;
      }
      if (radioNode) {
        radioNode.source.stop();
        radioNode.lfo.stop();
        radioNode = null;
      }

      isPlaying = false;
      document.body.classList.remove('playing');
      playBtn.textContent = 'Tune In';
      playBtn.classList.remove('playing');
      statusDot.classList.remove('active');
      statusText.textContent = 'Off Air';
    }

    playBtn.addEventListener('click', () => {
      if (isPlaying) {
        stopAudio();
      } else {
        startAudio();
      }
    });

    // Eerie messages that fade in/out
    const messages = [
      "...nothing but dust and memories out here...",
      "...last broadcast: unknown...",
      "...population: 0...",
      "...the wind remembers...",
      "...they all left years ago...",
      "...signal fading...",
      "...is anyone listening?...",
      "...tumbleweeds keep me company...",
      "...the desert speaks in whispers..."
    ];

    const messageEl = document.querySelector('.message');
    let msgIndex = 0;

    setInterval(() => {
      messageEl.style.opacity = 0;
      setTimeout(() => {
        msgIndex = (msgIndex + 1) % messages.length;
        messageEl.textContent = messages[msgIndex];
        messageEl.style.opacity = 1;
      }, 1000);
    }, 8000);

    // Whisper to the Void
    const whisperInput = document.getElementById('whisperInput');
    const floatingWhispers = [];

    function createFloatingWhisper(text) {
      const whisper = document.createElement('div');
      whisper.className = 'floating-whisper';
      whisper.textContent = text;

      // Start position - center bottom area
      const startX = window.innerWidth / 2;
      const startY = window.innerHeight - 150;

      whisper.style.left = startX + 'px';
      whisper.style.top = startY + 'px';
      whisper.style.fontSize = '16px';
      whisper.style.opacity = '1';

      document.body.appendChild(whisper);

      // Center the text
      const rect = whisper.getBoundingClientRect();
      whisper.style.left = (startX - rect.width / 2) + 'px';

      // Animation properties
      const windDirection = (Math.random() - 0.5) * 2; // -1 to 1
      const floatData = {
        el: whisper,
        x: startX - rect.width / 2,
        y: startY,
        vx: windDirection * 0.5,
        vy: -0.8 - Math.random() * 0.5,
        opacity: 1,
        scale: 1,
        rotation: 0,
        rotationSpeed: (Math.random() - 0.5) * 0.3,
        wobble: Math.random() * Math.PI * 2,
        wobbleSpeed: 0.02 + Math.random() * 0.02
      };

      floatingWhispers.push(floatData);
    }

    function updateFloatingWhispers() {
      for (let i = floatingWhispers.length - 1; i >= 0; i--) {
        const w = floatingWhispers[i];

        // Update position with wind drift
        w.wobble += w.wobbleSpeed;
        w.x += w.vx + Math.sin(w.wobble) * 0.3;
        w.y += w.vy;
        w.rotation += w.rotationSpeed;

        // Gradually fade and shrink
        w.opacity -= 0.003;
        w.scale -= 0.001;

        // Wind picks up as it rises
        w.vx += (Math.random() - 0.5) * 0.02;

        // Apply styles
        w.el.style.left = w.x + 'px';
        w.el.style.top = w.y + 'px';
        w.el.style.opacity = Math.max(0, w.opacity);
        w.el.style.transform = `scale(${Math.max(0.5, w.scale)}) rotate(${w.rotation}deg)`;
        w.el.style.filter = `blur(${Math.max(0, (1 - w.opacity) * 2)}px)`;

        // Remove when fully faded
        if (w.opacity <= 0 || w.y < -50) {
          w.el.remove();
          floatingWhispers.splice(i, 1);
        }
      }

      requestAnimationFrame(updateFloatingWhispers);
    }

    updateFloatingWhispers();

    whisperInput.addEventListener('keypress', (e) => {
      if (e.key === 'Enter' && whisperInput.value.trim()) {
        const text = whisperInput.value.trim();
        createFloatingWhisper(text);
        whisperInput.value = '';

        // Play a soft whisper sound if audio is on
        if (isPlaying && audioContext) {
          playWhisperSound();
        }
      }
    });

    function playWhisperSound() {
      const osc = audioContext.createOscillator();
      const gain = audioContext.createGain();
      const filter = audioContext.createBiquadFilter();

      osc.type = 'sine';
      osc.frequency.setValueAtTime(400 + Math.random() * 200, audioContext.currentTime);
      osc.frequency.exponentialRampToValueAtTime(200, audioContext.currentTime + 0.5);

      filter.type = 'lowpass';
      filter.frequency.value = 800;

      gain.gain.setValueAtTime(0.05, audioContext.currentTime);
      gain.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + 0.5);

      osc.connect(filter);
      filter.connect(gain);
      gain.connect(audioContext.destination);

      osc.start();
      osc.stop(audioContext.currentTime + 0.5);
    }

    // Lonely Traveler
    let currentTraveler = null;

    function createTraveler() {
      if (currentTraveler) return; // Only one traveler at a time

      const traveler = document.createElement('div');
      traveler.className = 'traveler';

      // Random direction
      const goingRight = Math.random() > 0.5;
      const startX = goingRight ? -50 : window.innerWidth + 50;

      traveler.innerHTML = `
        <div class="traveler-figure" style="transform: scaleX(${goingRight ? 1 : -1})">
          <div class="traveler-hat"></div>
          <div class="traveler-head"></div>
          <div class="traveler-body"></div>
          <div class="traveler-leg left"></div>
          <div class="traveler-leg right"></div>
          <div class="lantern">
            <div class="lantern-handle"></div>
            <div class="lantern-body"></div>
            <div class="lantern-glow"></div>
            <div class="lantern-light-cone"></div>
          </div>
        </div>
      `;

      traveler.style.left = startX + 'px';
      document.body.appendChild(traveler);

      const speed = 0.3 + Math.random() * 0.2;
      const direction = goingRight ? 1 : -1;

      currentTraveler = {
        el: traveler,
        x: startX,
        speed: speed * direction
      };
    }

    function updateTraveler() {
      if (currentTraveler) {
        currentTraveler.x += currentTraveler.speed;
        currentTraveler.el.style.left = currentTraveler.x + 'px';

        // Remove when off screen
        if (currentTraveler.x < -100 || currentTraveler.x > window.innerWidth + 100) {
          currentTraveler.el.remove();
          currentTraveler = null;
        }
      }

      requestAnimationFrame(updateTraveler);
    }

    updateTraveler();

    // Spawn traveler occasionally (every 30-60 seconds)
    function scheduleTraveler() {
      const delay = 30000 + Math.random() * 30000;
      setTimeout(() => {
        createTraveler();
        scheduleTraveler();
      }, delay);
    }

    // First traveler after 10-20 seconds
    setTimeout(() => {
      createTraveler();
      scheduleTraveler();
    }, 10000 + Math.random() * 10000);

    // Distant Train Whistle
    function playTrainWhistle() {
      if (!audioContext || !isPlaying) return;

      // Create the haunting whistle - two tones like a real train
      const now = audioContext.currentTime;

      // First tone (lower)
      const osc1 = audioContext.createOscillator();
      const gain1 = audioContext.createGain();
      const filter1 = audioContext.createBiquadFilter();

      osc1.type = 'sine';
      osc1.frequency.setValueAtTime(280, now);
      osc1.frequency.linearRampToValueAtTime(260, now + 2);

      filter1.type = 'lowpass';
      filter1.frequency.value = 600;
      filter1.Q.value = 2;

      // Distant, muffled sound with slow attack/decay
      gain1.gain.setValueAtTime(0, now);
      gain1.gain.linearRampToValueAtTime(0.04, now + 0.3);
      gain1.gain.setValueAtTime(0.04, now + 1.5);
      gain1.gain.linearRampToValueAtTime(0, now + 2.5);

      osc1.connect(filter1);
      filter1.connect(gain1);
      gain1.connect(audioContext.destination);
      osc1.start(now);
      osc1.stop(now + 2.5);

      // Second tone (higher, slight delay)
      setTimeout(() => {
        const osc2 = audioContext.createOscillator();
        const gain2 = audioContext.createGain();
        const filter2 = audioContext.createBiquadFilter();

        osc2.type = 'sine';
        osc2.frequency.setValueAtTime(380, audioContext.currentTime);
        osc2.frequency.linearRampToValueAtTime(350, audioContext.currentTime + 1.8);

        filter2.type = 'lowpass';
        filter2.frequency.value = 700;

        gain2.gain.setValueAtTime(0, audioContext.currentTime);
        gain2.gain.linearRampToValueAtTime(0.03, audioContext.currentTime + 0.2);
        gain2.gain.setValueAtTime(0.03, audioContext.currentTime + 1.2);
        gain2.gain.linearRampToValueAtTime(0, audioContext.currentTime + 2);

        osc2.connect(filter2);
        filter2.connect(gain2);
        gain2.connect(audioContext.destination);
        osc2.start();
        osc2.stop(audioContext.currentTime + 2);
      }, 100);

      // Add subtle vibration effect
      triggerTrackVibration();
    }

    // Track vibration - rhythmic rumble
    function triggerTrackVibration() {
      if (!audioContext || !isPlaying) return;

      const duration = 8; // seconds of faint rumble
      const now = audioContext.currentTime;

      // Low frequency rumble
      const rumble = audioContext.createOscillator();
      const rumbleGain = audioContext.createGain();
      const rumbleFilter = audioContext.createBiquadFilter();

      rumble.type = 'triangle';
      rumble.frequency.value = 30;

      rumbleFilter.type = 'lowpass';
      rumbleFilter.frequency.value = 80;

      // Very faint, rhythmic pulsing
      rumbleGain.gain.setValueAtTime(0, now);
      rumbleGain.gain.linearRampToValueAtTime(0.015, now + 1);
      rumbleGain.gain.setValueAtTime(0.015, now + duration - 2);
      rumbleGain.gain.linearRampToValueAtTime(0, now + duration);

      // Add rhythmic modulation (like train wheels on tracks)
      const lfo = audioContext.createOscillator();
      const lfoGain = audioContext.createGain();
      lfo.frequency.value = 3; // clickety-clack rhythm
      lfoGain.gain.value = 0.008;
      lfo.connect(lfoGain);
      lfoGain.connect(rumbleGain.gain);

      rumble.connect(rumbleFilter);
      rumbleFilter.connect(rumbleGain);
      rumbleGain.connect(audioContext.destination);

      rumble.start(now);
      lfo.start(now);
      rumble.stop(now + duration);
      lfo.stop(now + duration);

      // Visual vibration on ground element
      const ground = document.querySelector('.ground');
      ground.style.animation = 'trackVibrate 0.1s ease-in-out 30';
      setTimeout(() => {
        ground.style.animation = '';
      }, 3000);
    }

    // Schedule train whistle every 5 minutes
    setInterval(() => {
      playTrainWhistle();
    }, 300000); // 5 minutes

    // First whistle after 2-3 minutes
    setTimeout(() => {
      playTrainWhistle();
    }, 120000 + Math.random() * 60000);

    // Cactus Planting System
    const ground = document.getElementById('ground');
    const STORAGE_KEY = 'ghosttown_cacti';

    // Different cactus designs
    function getCactusSVG(type) {
      const color = '#1a1510';
      const designs = [
        // Simple saguaro
        `<svg viewBox="0 0 30 50" fill="none" stroke="${color}" stroke-width="4" stroke-linecap="round">
          <path d="M15 50 L15 15 M15 25 L8 25 L8 18 M15 20 L22 20 L22 12"/>
        </svg>`,
        // Small round cactus
        `<svg viewBox="0 0 20 25" fill="${color}">
          <ellipse cx="10" cy="18" rx="8" ry="7"/>
          <ellipse cx="10" cy="10" rx="5" ry="6"/>
        </svg>`,
        // Tall thin cactus
        `<svg viewBox="0 0 15 45" fill="none" stroke="${color}" stroke-width="4" stroke-linecap="round">
          <path d="M7.5 45 L7.5 5"/>
        </svg>`,
        // Branching cactus
        `<svg viewBox="0 0 35 40" fill="none" stroke="${color}" stroke-width="4" stroke-linecap="round">
          <path d="M17 40 L17 10 M17 25 L7 25 L7 15 M17 20 L27 20 L27 8"/>
        </svg>`,
        // Prickly pear style
        `<svg viewBox="0 0 30 35" fill="${color}">
          <ellipse cx="15" cy="28" rx="10" ry="7"/>
          <ellipse cx="10" cy="18" rx="7" ry="5"/>
          <ellipse cx="22" cy="15" rx="6" ry="5"/>
        </svg>`,
        // Baby saguaro
        `<svg viewBox="0 0 20 30" fill="none" stroke="${color}" stroke-width="3" stroke-linecap="round">
          <path d="M10 30 L10 8 M10 15 L5 15 L5 10"/>
        </svg>`
      ];
      return designs[type % designs.length];
    }

    function plantCactus(x, y, type, save = true) {
      const cactus = document.createElement('div');
      cactus.className = 'planted-cactus';

      const size = 15 + Math.random() * 20;
      cactus.style.width = size + 'px';
      cactus.style.height = (size * 1.5) + 'px';
      cactus.style.left = x + 'px';
      cactus.style.bottom = y + 'px';
      cactus.innerHTML = getCactusSVG(type);

      ground.appendChild(cactus);

      if (save) {
        saveCactus(x, y, type, size);

        // Play plant sound if audio is on
        if (isPlaying && audioContext) {
          playPlantSound();
        }
      }
    }

    function saveCactus(x, y, type, size) {
      const cacti = JSON.parse(localStorage.getItem(STORAGE_KEY) || '[]');
      // Store as percentage of screen width for responsiveness
      const xPercent = (x / ground.offsetWidth) * 100;
      const yPercent = (y / ground.offsetHeight) * 100;
      cacti.push({ xPercent, yPercent, type, size, time: Date.now() });

      // Limit to 50 cacti to prevent overcrowding
      if (cacti.length > 50) {
        cacti.shift();
      }

      localStorage.setItem(STORAGE_KEY, JSON.stringify(cacti));
    }

    function loadCacti() {
      const cacti = JSON.parse(localStorage.getItem(STORAGE_KEY) || '[]');
      cacti.forEach(c => {
        const x = (c.xPercent / 100) * ground.offsetWidth;
        const y = (c.yPercent / 100) * ground.offsetHeight;
        plantCactus(x, y, c.type, false);
      });
    }

    function playPlantSound() {
      const osc = audioContext.createOscillator();
      const gain = audioContext.createGain();

      osc.type = 'sine';
      osc.frequency.setValueAtTime(300, audioContext.currentTime);
      osc.frequency.exponentialRampToValueAtTime(500, audioContext.currentTime + 0.1);

      gain.gain.setValueAtTime(0.08, audioContext.currentTime);
      gain.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + 0.2);

      osc.connect(gain);
      gain.connect(audioContext.destination);

      osc.start();
      osc.stop(audioContext.currentTime + 0.2);
    }

    // Handle ground clicks
    ground.addEventListener('click', (e) => {
      const rect = ground.getBoundingClientRect();
      const x = e.clientX - rect.left;
      const y = rect.bottom - e.clientY; // Distance from bottom

      // Only plant in upper portion of ground (near horizon)
      if (y > ground.offsetHeight * 0.3) {
        const type = Math.floor(Math.random() * 6);
        plantCactus(x, y, type);
      }
    });

    // Load saved cacti on start
    loadCacti();

    // Reload cacti on window resize
    window.addEventListener('resize', () => {
      // Clear and reload to reposition
      ground.querySelectorAll('.planted-cactus').forEach(c => c.remove());
      loadCacti();
    });

    // Shooting Stars
    function createShootingStar() {
      const star = document.createElement('div');
      star.className = 'shooting-star';

      // Start from upper portion of sky (top 40%)
      const startX = Math.random() * window.innerWidth * 0.7;
      const startY = 20 + Math.random() * (window.innerHeight * 0.3);

      // Angle between 15-45 degrees downward
      const angle = (15 + Math.random() * 30) * (Math.PI / 180);
      const speed = 8 + Math.random() * 6;
      const distance = 300 + Math.random() * 400;

      star.style.left = startX + 'px';
      star.style.top = startY + 'px';
      star.style.transform = `rotate(${angle * (180 / Math.PI)}deg)`;

      document.body.appendChild(star);

      let traveled = 0;
      let opacity = 1;

      function animateStar() {
        traveled += speed;
        const x = startX + Math.cos(angle) * traveled;
        const y = startY + Math.sin(angle) * traveled;

        // Fade out in last third of journey
        if (traveled > distance * 0.6) {
          opacity -= 0.05;
        }

        star.style.left = x + 'px';
        star.style.top = y + 'px';
        star.style.opacity = Math.max(0, opacity);

        if (traveled < distance && opacity > 0) {
          requestAnimationFrame(animateStar);
        } else {
          star.remove();
        }
      }

      requestAnimationFrame(animateStar);
    }

    // Spawn shooting stars rarely (every 2-4 minutes)
    function scheduleShootingStar() {
      const delay = 120000 + Math.random() * 120000; // 2-4 minutes
      setTimeout(() => {
        createShootingStar();
        scheduleShootingStar();
      }, delay);
    }

    // First shooting star after 30-90 seconds
    setTimeout(() => {
      createShootingStar();
      scheduleShootingStar();
    }, 30000 + Math.random() * 60000);
  </script>
</body>
</html>
