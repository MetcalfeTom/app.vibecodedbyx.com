<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Train Signals</title>
  <meta name="description" content="Control switches and signals to guide colorful trains safely!">
  <meta property="og:title" content="Train Signals">
  <meta property="og:description" content="A railway switching puzzle game with colorful locomotives">
  <meta property="og:url" content="https://app.sloppy.live/train-signals">
  <meta property="og:image" content="https://app.sloppy.live/train-signals/og-image.png">
  <link rel="icon" href="https://emojicdn.elk.sh/üöÇ">
  <link href="https://fonts.googleapis.com/css2?family=Fredoka:wght@400;600;700&display=swap" rel="stylesheet">
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      min-height: 100vh;
      background: linear-gradient(180deg, #87CEEB 0%, #98D8AA 70%, #4A7C59 100%);
      font-family: 'Fredoka', sans-serif;
      overflow: hidden;
      user-select: none;
    }

    .game-container {
      position: relative;
      width: 100vw;
      height: 100vh;
    }

    canvas {
      display: block;
    }

    .ui {
      position: absolute;
      top: 15px;
      left: 15px;
      right: 15px;
      display: flex;
      justify-content: space-between;
      align-items: flex-start;
      pointer-events: none;
      z-index: 10;
    }

    .panel {
      background: rgba(255, 255, 255, 0.95);
      padding: 12px 20px;
      border-radius: 15px;
      box-shadow: 0 4px 15px rgba(0,0,0,0.2);
      border: 3px solid #5D4E37;
    }

    .panel-label {
      font-size: 0.7rem;
      color: #888;
      text-transform: uppercase;
      letter-spacing: 1px;
    }

    .panel-value {
      font-size: 1.6rem;
      font-weight: 700;
      color: #5D4E37;
    }

    .lives {
      font-size: 1.4rem;
      letter-spacing: 2px;
    }

    .difficulty-badge {
      padding: 8px 16px;
      border-radius: 20px;
      font-size: 0.85rem;
      font-weight: 600;
      text-transform: uppercase;
      letter-spacing: 1px;
    }

    .difficulty-badge.easy { background: #4CAF50; color: white; }
    .difficulty-badge.medium { background: #FF9800; color: white; }
    .difficulty-badge.hard { background: #f44336; color: white; }

    .start-screen, .game-over-screen {
      position: absolute;
      inset: 0;
      background: rgba(0, 0, 0, 0.85);
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      z-index: 100;
    }

    h1 {
      font-size: 3rem;
      color: #FFD93D;
      text-shadow: 3px 3px 0 #5D4E37;
      margin-bottom: 10px;
    }

    .subtitle {
      color: #fff;
      font-size: 1.1rem;
      margin-bottom: 30px;
      opacity: 0.9;
    }

    .train-preview {
      font-size: 3rem;
      margin-bottom: 25px;
      animation: chug 0.5s ease-in-out infinite alternate;
    }

    @keyframes chug {
      from { transform: translateX(-5px); }
      to { transform: translateX(5px); }
    }

    .difficulty-select {
      display: flex;
      gap: 15px;
      margin-bottom: 25px;
    }

    .diff-btn {
      padding: 15px 30px;
      font-size: 1.1rem;
      font-family: 'Fredoka', sans-serif;
      font-weight: 600;
      border: none;
      border-radius: 30px;
      cursor: pointer;
      transition: all 0.2s;
      pointer-events: auto;
    }

    .diff-btn.easy {
      background: linear-gradient(180deg, #66BB6A, #43A047);
      color: white;
    }

    .diff-btn.medium {
      background: linear-gradient(180deg, #FFA726, #FB8C00);
      color: white;
    }

    .diff-btn.hard {
      background: linear-gradient(180deg, #EF5350, #E53935);
      color: white;
    }

    .diff-btn:hover {
      transform: translateY(-3px);
      box-shadow: 0 6px 20px rgba(0,0,0,0.3);
    }

    .instructions {
      color: rgba(255,255,255,0.7);
      font-size: 0.9rem;
      text-align: center;
      line-height: 1.6;
    }

    .final-score {
      font-size: 1.5rem;
      color: #fff;
      margin-bottom: 15px;
    }

    .final-score span {
      color: #FFD93D;
      font-weight: 700;
    }

    .btn {
      padding: 15px 40px;
      font-size: 1.2rem;
      font-family: 'Fredoka', sans-serif;
      font-weight: 600;
      background: linear-gradient(180deg, #FFD93D, #F9A825);
      color: #5D4E37;
      border: none;
      border-radius: 30px;
      cursor: pointer;
      transition: all 0.2s;
      pointer-events: auto;
      margin-top: 15px;
    }

    .btn:hover {
      transform: translateY(-3px);
      box-shadow: 0 6px 20px rgba(0,0,0,0.3);
    }

    .hidden {
      display: none !important;
    }

    .tooltip {
      position: absolute;
      background: rgba(0,0,0,0.8);
      color: white;
      padding: 8px 12px;
      border-radius: 8px;
      font-size: 0.85rem;
      pointer-events: none;
      z-index: 50;
      opacity: 0;
      transition: opacity 0.2s;
    }

    .tooltip.show {
      opacity: 1;
    }

    .back-link {
      position: fixed;
      bottom: 10px;
      left: 50%;
      transform: translateX(-50%);
      color: rgba(255,255,255,0.6);
      text-decoration: none;
      font-size: 0.8rem;
      z-index: 50;
    }

    .back-link:hover {
      color: white;
    }

    @media (max-width: 600px) {
      h1 { font-size: 2rem; }
      .diff-btn { padding: 12px 20px; font-size: 1rem; }
      .panel { padding: 8px 12px; }
      .panel-value { font-size: 1.2rem; }
    }
  </style>
</head>
<body>
  <div class="game-container">
    <canvas id="game"></canvas>

    <div class="ui">
      <div class="panel">
        <div class="panel-label">Score</div>
        <div class="panel-value" id="score">0</div>
      </div>
      <div class="panel">
        <div class="panel-label">Trains Delivered</div>
        <div class="panel-value" id="delivered">0</div>
      </div>
      <div class="panel">
        <div class="panel-label">Lives</div>
        <div class="panel-value lives" id="lives">‚ù§Ô∏è‚ù§Ô∏è‚ù§Ô∏è</div>
      </div>
    </div>

    <div class="start-screen" id="startScreen">
      <div class="train-preview">üöÇüöÉüöÉ</div>
      <h1>Train Signals</h1>
      <p class="subtitle">Click switches to change tracks, guide trains safely!</p>
      <div class="difficulty-select">
        <button class="diff-btn easy" data-diff="easy">Easy</button>
        <button class="diff-btn medium" data-diff="medium">Medium</button>
        <button class="diff-btn hard" data-diff="hard">Hard</button>
      </div>
      <p class="instructions">
        üîÄ Click track switches to change direction<br>
        üö¶ Click signals to stop/start trains<br>
        üéØ Match train colors to station colors
      </p>
    </div>

    <div class="game-over-screen hidden" id="gameOverScreen">
      <div class="train-preview">üí•üöÇ</div>
      <h1>Game Over!</h1>
      <p class="final-score">Trains Delivered: <span id="finalDelivered">0</span></p>
      <p class="final-score">Final Score: <span id="finalScore">0</span></p>
      <button class="btn" id="restartBtn">Play Again</button>
    </div>

    <div class="tooltip" id="tooltip"></div>
  </div>

  <a href="https://sloppy.live" class="back-link">sloppy.live</a>

  <script>
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');

    let width, height;
    let gameRunning = false;
    let score = 0;
    let delivered = 0;
    let lives = 3;
    let difficulty = 'easy';

    // Game objects
    let tracks = [];
    let switches = [];
    let signals = [];
    let stations = [];
    let trains = [];
    let spawnTimer = 0;

    // Difficulty settings
    const difficulties = {
      easy: { trainSpeed: 1.5, spawnRate: 4000, maxTrains: 3 },
      medium: { trainSpeed: 2.5, spawnRate: 2500, maxTrains: 5 },
      hard: { trainSpeed: 3.5, spawnRate: 1500, maxTrains: 8 }
    };

    // Train colors
    const trainColors = [
      { name: 'red', primary: '#E53935', secondary: '#C62828' },
      { name: 'blue', primary: '#1E88E5', secondary: '#1565C0' },
      { name: 'green', primary: '#43A047', secondary: '#2E7D32' },
      { name: 'yellow', primary: '#FDD835', secondary: '#F9A825' },
      { name: 'purple', primary: '#8E24AA', secondary: '#6A1B9A' },
      { name: 'orange', primary: '#FB8C00', secondary: '#EF6C00' }
    ];

    function resize() {
      width = window.innerWidth;
      height = window.innerHeight;
      canvas.width = width;
      canvas.height = height;
    }

    // Track segment class
    class Track {
      constructor(x1, y1, x2, y2, type = 'straight') {
        this.x1 = x1;
        this.y1 = y1;
        this.x2 = x2;
        this.y2 = y2;
        this.type = type;
        this.controlX = (x1 + x2) / 2;
        this.controlY = (y1 + y2) / 2;
      }

      draw() {
        ctx.strokeStyle = '#5D4E37';
        ctx.lineWidth = 12;
        ctx.lineCap = 'round';
        ctx.beginPath();
        ctx.moveTo(this.x1, this.y1);
        ctx.lineTo(this.x2, this.y2);
        ctx.stroke();

        // Rails
        ctx.strokeStyle = '#8B7355';
        ctx.lineWidth = 4;
        ctx.beginPath();
        ctx.moveTo(this.x1, this.y1);
        ctx.lineTo(this.x2, this.y2);
        ctx.stroke();

        // Sleepers
        ctx.strokeStyle = '#6D4C41';
        ctx.lineWidth = 3;
        const len = Math.hypot(this.x2 - this.x1, this.y2 - this.y1);
        const steps = Math.floor(len / 20);
        for (let i = 0; i <= steps; i++) {
          const t = i / steps;
          const x = this.x1 + (this.x2 - this.x1) * t;
          const y = this.y1 + (this.y2 - this.y1) * t;
          const angle = Math.atan2(this.y2 - this.y1, this.x2 - this.x1) + Math.PI / 2;
          ctx.beginPath();
          ctx.moveTo(x + Math.cos(angle) * 8, y + Math.sin(angle) * 8);
          ctx.lineTo(x - Math.cos(angle) * 8, y - Math.sin(angle) * 8);
          ctx.stroke();
        }
      }

      getPointAt(t) {
        return {
          x: this.x1 + (this.x2 - this.x1) * t,
          y: this.y1 + (this.y2 - this.y1) * t
        };
      }

      getAngleAt(t) {
        return Math.atan2(this.y2 - this.y1, this.x2 - this.x1);
      }
    }

    // Switch class
    class Switch {
      constructor(x, y, tracks, defaultTrack = 0) {
        this.x = x;
        this.y = y;
        this.tracks = tracks; // Array of track indices
        this.currentTrack = defaultTrack;
        this.radius = 20;
      }

      toggle() {
        this.currentTrack = (this.currentTrack + 1) % this.tracks.length;
      }

      draw() {
        // Switch base
        ctx.fillStyle = '#3E2723';
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
        ctx.fill();

        // Lever
        ctx.fillStyle = '#FFD93D';
        ctx.strokeStyle = '#5D4E37';
        ctx.lineWidth = 3;
        const angle = (this.currentTrack / this.tracks.length) * Math.PI * 2 - Math.PI / 2;
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.radius - 5, 0, Math.PI * 2);
        ctx.fill();
        ctx.stroke();

        // Direction indicator
        ctx.fillStyle = '#E53935';
        ctx.beginPath();
        ctx.arc(
          this.x + Math.cos(angle) * (this.radius - 8),
          this.y + Math.sin(angle) * (this.radius - 8),
          6, 0, Math.PI * 2
        );
        ctx.fill();
      }

      containsPoint(px, py) {
        return Math.hypot(px - this.x, py - this.y) < this.radius + 10;
      }
    }

    // Signal class
    class Signal {
      constructor(x, y, trackIndex) {
        this.x = x;
        this.y = y;
        this.trackIndex = trackIndex;
        this.isGreen = true;
      }

      toggle() {
        this.isGreen = !this.isGreen;
      }

      draw() {
        // Pole
        ctx.fillStyle = '#424242';
        ctx.fillRect(this.x - 3, this.y, 6, 40);

        // Signal box
        ctx.fillStyle = '#212121';
        ctx.fillRect(this.x - 12, this.y - 30, 24, 35);

        // Lights
        ctx.fillStyle = this.isGreen ? '#444' : '#f44336';
        ctx.beginPath();
        ctx.arc(this.x, this.y - 20, 7, 0, Math.PI * 2);
        ctx.fill();
        if (!this.isGreen) {
          ctx.shadowColor = '#f44336';
          ctx.shadowBlur = 15;
          ctx.fill();
          ctx.shadowBlur = 0;
        }

        ctx.fillStyle = this.isGreen ? '#4CAF50' : '#444';
        ctx.beginPath();
        ctx.arc(this.x, this.y - 5, 7, 0, Math.PI * 2);
        ctx.fill();
        if (this.isGreen) {
          ctx.shadowColor = '#4CAF50';
          ctx.shadowBlur = 15;
          ctx.fill();
          ctx.shadowBlur = 0;
        }
      }

      containsPoint(px, py) {
        return px > this.x - 15 && px < this.x + 15 && py > this.y - 35 && py < this.y + 45;
      }
    }

    // Station class
    class Station {
      constructor(x, y, colorIndex) {
        this.x = x;
        this.y = y;
        this.color = trainColors[colorIndex];
        this.colorIndex = colorIndex;
        this.width = 80;
        this.height = 50;
      }

      draw() {
        // Platform
        ctx.fillStyle = '#9E9E9E';
        ctx.fillRect(this.x - this.width/2, this.y - 10, this.width, 20);

        // Building
        ctx.fillStyle = this.color.primary;
        ctx.fillRect(this.x - 30, this.y - 50, 60, 40);

        // Roof
        ctx.fillStyle = this.color.secondary;
        ctx.beginPath();
        ctx.moveTo(this.x - 35, this.y - 50);
        ctx.lineTo(this.x, this.y - 70);
        ctx.lineTo(this.x + 35, this.y - 50);
        ctx.closePath();
        ctx.fill();

        // Door
        ctx.fillStyle = '#5D4037';
        ctx.fillRect(this.x - 8, this.y - 35, 16, 25);

        // Station sign
        ctx.fillStyle = '#fff';
        ctx.font = '10px Fredoka';
        ctx.textAlign = 'center';
        ctx.fillText('STATION', this.x, this.y - 55);
      }

      containsTrain(train) {
        return Math.abs(train.x - this.x) < 30 && Math.abs(train.y - this.y) < 30;
      }
    }

    // Train class
    class Train {
      constructor(trackIndex, colorIndex, direction = 1) {
        this.trackIndex = trackIndex;
        this.t = direction > 0 ? 0 : 1;
        this.direction = direction;
        this.color = trainColors[colorIndex];
        this.colorIndex = colorIndex;
        this.speed = difficulties[difficulty].trainSpeed;
        this.x = 0;
        this.y = 0;
        this.angle = 0;
        this.stopped = false;
        this.carriages = 2;
        this.history = [];
      }

      update() {
        if (this.stopped) return;

        const track = tracks[this.trackIndex];
        if (!track) return;

        const len = Math.hypot(track.x2 - track.x1, track.y2 - track.y1);
        const step = (this.speed / len) * this.direction;
        this.t += step * 0.016 * 60;

        // Store position history for carriages
        this.history.unshift({ x: this.x, y: this.y, angle: this.angle });
        if (this.history.length > 30) this.history.pop();

        // Update position
        const pos = track.getPointAt(Math.max(0, Math.min(1, this.t)));
        this.x = pos.x;
        this.y = pos.y;
        this.angle = track.getAngleAt(this.t);

        // Check if reached end of track
        if (this.t >= 1 || this.t <= 0) {
          this.findNextTrack();
        }
      }

      findNextTrack() {
        // Find connected track at current position
        const threshold = 20;
        for (let i = 0; i < tracks.length; i++) {
          if (i === this.trackIndex) continue;
          const track = tracks[i];

          // Check if connected at start
          if (Math.hypot(this.x - track.x1, this.y - track.y1) < threshold) {
            // Check if switch affects this
            let canUse = true;
            for (const sw of switches) {
              if (sw.tracks.includes(i) && sw.tracks.includes(this.trackIndex)) {
                if (sw.tracks[sw.currentTrack] !== i) canUse = false;
              }
            }
            if (canUse) {
              this.trackIndex = i;
              this.t = 0;
              this.direction = 1;
              return;
            }
          }

          // Check if connected at end
          if (Math.hypot(this.x - track.x2, this.y - track.y2) < threshold) {
            let canUse = true;
            for (const sw of switches) {
              if (sw.tracks.includes(i) && sw.tracks.includes(this.trackIndex)) {
                if (sw.tracks[sw.currentTrack] !== i) canUse = false;
              }
            }
            if (canUse) {
              this.trackIndex = i;
              this.t = 1;
              this.direction = -1;
              return;
            }
          }
        }

        // No track found - train goes off
        this.offTrack = true;
      }

      draw() {
        // Draw carriages first
        for (let i = this.carriages - 1; i >= 0; i--) {
          const histIdx = (i + 1) * 12;
          if (this.history[histIdx]) {
            this.drawCarriage(this.history[histIdx].x, this.history[histIdx].y, this.history[histIdx].angle, i);
          }
        }

        // Draw locomotive
        ctx.save();
        ctx.translate(this.x, this.y);
        ctx.rotate(this.angle);

        // Body
        ctx.fillStyle = this.color.primary;
        ctx.beginPath();
        ctx.roundRect(-25, -12, 50, 24, 5);
        ctx.fill();

        // Cabin
        ctx.fillStyle = this.color.secondary;
        ctx.fillRect(-20, -15, 20, 30);

        // Chimney
        ctx.fillStyle = '#333';
        ctx.fillRect(10, -20, 8, 10);

        // Wheels
        ctx.fillStyle = '#333';
        ctx.beginPath();
        ctx.arc(-15, 12, 8, 0, Math.PI * 2);
        ctx.arc(10, 12, 8, 0, Math.PI * 2);
        ctx.fill();

        // Window
        ctx.fillStyle = '#81D4FA';
        ctx.fillRect(-18, -10, 12, 10);

        // Front
        ctx.fillStyle = '#FFD93D';
        ctx.beginPath();
        ctx.arc(25, 0, 5, 0, Math.PI * 2);
        ctx.fill();

        ctx.restore();
      }

      drawCarriage(x, y, angle, index) {
        ctx.save();
        ctx.translate(x, y);
        ctx.rotate(angle);

        // Body
        ctx.fillStyle = this.color.primary;
        ctx.globalAlpha = 0.8;
        ctx.beginPath();
        ctx.roundRect(-20, -10, 40, 20, 4);
        ctx.fill();
        ctx.globalAlpha = 1;

        // Wheels
        ctx.fillStyle = '#333';
        ctx.beginPath();
        ctx.arc(-12, 10, 6, 0, Math.PI * 2);
        ctx.arc(12, 10, 6, 0, Math.PI * 2);
        ctx.fill();

        // Windows
        ctx.fillStyle = '#81D4FA';
        ctx.fillRect(-15, -6, 8, 8);
        ctx.fillRect(5, -6, 8, 8);

        ctx.restore();
      }

      checkSignals() {
        for (const signal of signals) {
          const track = tracks[signal.trackIndex];
          if (!track) continue;
          const signalDist = Math.hypot(this.x - signal.x, this.y - signal.y);
          if (signalDist < 40 && !signal.isGreen) {
            this.stopped = true;
            return;
          }
        }
        this.stopped = false;
      }
    }

    function createLevel() {
      tracks = [];
      switches = [];
      signals = [];
      stations = [];

      const centerX = width / 2;
      const centerY = height / 2;

      // Create track layout based on difficulty
      if (difficulty === 'easy') {
        // Simple oval with one switch
        tracks.push(new Track(100, centerY, centerX - 100, centerY));
        tracks.push(new Track(centerX - 100, centerY, centerX + 100, centerY));
        tracks.push(new Track(centerX + 100, centerY, width - 100, centerY));
        tracks.push(new Track(centerX - 100, centerY, centerX, centerY - 100)); // Branch up
        tracks.push(new Track(centerX, centerY - 100, centerX + 100, centerY - 100));
        tracks.push(new Track(centerX + 100, centerY - 100, centerX + 100, centerY));

        switches.push(new Switch(centerX - 100, centerY, [1, 3], 0));
        signals.push(new Signal(centerX - 50, centerY - 40, 1));

        stations.push(new Station(width - 150, centerY, 0)); // Red
        stations.push(new Station(centerX + 50, centerY - 100, 1)); // Blue

      } else if (difficulty === 'medium') {
        // More complex with multiple switches
        tracks.push(new Track(50, centerY, centerX - 150, centerY));
        tracks.push(new Track(centerX - 150, centerY, centerX, centerY));
        tracks.push(new Track(centerX, centerY, centerX + 150, centerY));
        tracks.push(new Track(centerX + 150, centerY, width - 50, centerY));

        // Upper branch
        tracks.push(new Track(centerX - 150, centerY, centerX - 100, centerY - 120));
        tracks.push(new Track(centerX - 100, centerY - 120, centerX + 100, centerY - 120));
        tracks.push(new Track(centerX + 100, centerY - 120, centerX + 150, centerY));

        // Lower branch
        tracks.push(new Track(centerX, centerY, centerX, centerY + 100));
        tracks.push(new Track(centerX, centerY + 100, centerX + 150, centerY + 100));

        switches.push(new Switch(centerX - 150, centerY, [1, 4], 0));
        switches.push(new Switch(centerX + 150, centerY, [3, 6], 0));
        switches.push(new Switch(centerX, centerY, [2, 7], 0));

        signals.push(new Signal(centerX - 80, centerY - 40, 1));
        signals.push(new Signal(centerX + 80, centerY - 40, 2));

        stations.push(new Station(width - 100, centerY, 0)); // Red
        stations.push(new Station(centerX, centerY - 120, 1)); // Blue
        stations.push(new Station(centerX + 100, centerY + 100, 2)); // Green

      } else {
        // Hard - complex network
        // Main horizontal
        tracks.push(new Track(30, centerY, centerX - 200, centerY));
        tracks.push(new Track(centerX - 200, centerY, centerX - 80, centerY));
        tracks.push(new Track(centerX - 80, centerY, centerX + 80, centerY));
        tracks.push(new Track(centerX + 80, centerY, centerX + 200, centerY));
        tracks.push(new Track(centerX + 200, centerY, width - 30, centerY));

        // Upper route
        tracks.push(new Track(centerX - 200, centerY, centerX - 150, centerY - 100));
        tracks.push(new Track(centerX - 150, centerY - 100, centerX, centerY - 150));
        tracks.push(new Track(centerX, centerY - 150, centerX + 150, centerY - 100));
        tracks.push(new Track(centerX + 150, centerY - 100, centerX + 200, centerY));

        // Lower route
        tracks.push(new Track(centerX - 80, centerY, centerX - 80, centerY + 100));
        tracks.push(new Track(centerX - 80, centerY + 100, centerX + 80, centerY + 100));
        tracks.push(new Track(centerX + 80, centerY + 100, centerX + 80, centerY));

        // Cross track
        tracks.push(new Track(centerX, centerY - 150, centerX, centerY - 80));
        tracks.push(new Track(centerX, centerY - 80, centerX - 80, centerY));

        switches.push(new Switch(centerX - 200, centerY, [1, 5], 0));
        switches.push(new Switch(centerX + 200, centerY, [4, 8], 0));
        switches.push(new Switch(centerX - 80, centerY, [2, 9, 13], 0));
        switches.push(new Switch(centerX + 80, centerY, [3, 11], 0));

        signals.push(new Signal(centerX - 130, centerY - 40, 1));
        signals.push(new Signal(centerX + 130, centerY - 40, 3));
        signals.push(new Signal(centerX - 30, centerY + 60, 2));

        stations.push(new Station(width - 80, centerY, 0)); // Red
        stations.push(new Station(centerX, centerY - 150, 1)); // Blue
        stations.push(new Station(centerX, centerY + 100, 2)); // Green
        stations.push(new Station(centerX - 150, centerY - 100, 3)); // Yellow
      }
    }

    function spawnTrain() {
      if (trains.length >= difficulties[difficulty].maxTrains) return;

      // Pick a random color that matches a station
      const stationColors = stations.map(s => s.colorIndex);
      const colorIndex = stationColors[Math.floor(Math.random() * stationColors.length)];

      const train = new Train(0, colorIndex, 1);
      train.t = 0;
      const pos = tracks[0].getPointAt(0);
      train.x = pos.x;
      train.y = pos.y;
      trains.push(train);
    }

    function update() {
      if (!gameRunning) return;

      // Spawn trains
      spawnTimer += 16;
      if (spawnTimer >= difficulties[difficulty].spawnRate) {
        spawnTrain();
        spawnTimer = 0;
      }

      // Update trains
      for (let i = trains.length - 1; i >= 0; i--) {
        const train = trains[i];
        train.checkSignals();
        train.update();

        // Check if train went off track
        if (train.offTrack) {
          trains.splice(i, 1);
          lives--;
          updateUI();
          if (lives <= 0) {
            gameOver();
          }
          continue;
        }

        // Check if train reached correct station
        for (const station of stations) {
          if (station.containsTrain(train)) {
            if (station.colorIndex === train.colorIndex) {
              // Correct station!
              score += 100;
              delivered++;
              trains.splice(i, 1);
              updateUI();
            } else {
              // Wrong station!
              score -= 25;
              lives--;
              trains.splice(i, 1);
              updateUI();
              if (lives <= 0) {
                gameOver();
              }
            }
            break;
          }
        }

        // Check train collisions
        for (let j = i - 1; j >= 0; j--) {
          const other = trains[j];
          if (Math.hypot(train.x - other.x, train.y - other.y) < 30) {
            // Collision!
            trains.splice(i, 1);
            trains.splice(j, 1);
            lives--;
            updateUI();
            if (lives <= 0) {
              gameOver();
            }
            break;
          }
        }
      }
    }

    function draw() {
      // Clear
      ctx.fillStyle = '#7CB342';
      ctx.fillRect(0, 0, width, height);

      // Grass pattern
      ctx.fillStyle = '#689F38';
      for (let i = 0; i < 100; i++) {
        const x = (i * 137) % width;
        const y = (i * 89) % height;
        ctx.beginPath();
        ctx.arc(x, y, 3, 0, Math.PI * 2);
        ctx.fill();
      }

      // Draw tracks
      tracks.forEach(track => track.draw());

      // Draw stations
      stations.forEach(station => station.draw());

      // Draw switches
      switches.forEach(sw => sw.draw());

      // Draw signals
      signals.forEach(signal => signal.draw());

      // Draw trains
      trains.forEach(train => train.draw());
    }

    function gameLoop() {
      update();
      draw();
      requestAnimationFrame(gameLoop);
    }

    function updateUI() {
      document.getElementById('score').textContent = score;
      document.getElementById('delivered').textContent = delivered;
      document.getElementById('lives').textContent = '‚ù§Ô∏è'.repeat(Math.max(0, lives));
    }

    function startGame(diff) {
      difficulty = diff;
      gameRunning = true;
      score = 0;
      delivered = 0;
      lives = 3;
      trains = [];
      spawnTimer = 0;

      createLevel();
      updateUI();

      document.getElementById('startScreen').classList.add('hidden');
      document.getElementById('gameOverScreen').classList.add('hidden');

      // Spawn first train
      setTimeout(spawnTrain, 1000);
    }

    function gameOver() {
      gameRunning = false;
      document.getElementById('finalScore').textContent = score;
      document.getElementById('finalDelivered').textContent = delivered;
      document.getElementById('gameOverScreen').classList.remove('hidden');
    }

    // Input handling
    canvas.addEventListener('click', (e) => {
      if (!gameRunning) return;

      const rect = canvas.getBoundingClientRect();
      const x = e.clientX - rect.left;
      const y = e.clientY - rect.top;

      // Check switches
      for (const sw of switches) {
        if (sw.containsPoint(x, y)) {
          sw.toggle();
          return;
        }
      }

      // Check signals
      for (const signal of signals) {
        if (signal.containsPoint(x, y)) {
          signal.toggle();
          return;
        }
      }
    });

    // Tooltip
    const tooltip = document.getElementById('tooltip');
    canvas.addEventListener('mousemove', (e) => {
      if (!gameRunning) return;

      const rect = canvas.getBoundingClientRect();
      const x = e.clientX - rect.left;
      const y = e.clientY - rect.top;

      let showTooltip = false;

      for (const sw of switches) {
        if (sw.containsPoint(x, y)) {
          tooltip.textContent = 'Click to switch tracks';
          tooltip.style.left = `${e.clientX + 10}px`;
          tooltip.style.top = `${e.clientY + 10}px`;
          tooltip.classList.add('show');
          showTooltip = true;
          break;
        }
      }

      if (!showTooltip) {
        for (const signal of signals) {
          if (signal.containsPoint(x, y)) {
            tooltip.textContent = signal.isGreen ? 'Click to stop trains' : 'Click to let trains pass';
            tooltip.style.left = `${e.clientX + 10}px`;
            tooltip.style.top = `${e.clientY + 10}px`;
            tooltip.classList.add('show');
            showTooltip = true;
            break;
          }
        }
      }

      if (!showTooltip) {
        tooltip.classList.remove('show');
      }
    });

    canvas.addEventListener('mouseleave', () => {
      tooltip.classList.remove('show');
    });

    // Difficulty buttons
    document.querySelectorAll('.diff-btn').forEach(btn => {
      btn.addEventListener('click', () => {
        startGame(btn.dataset.diff);
      });
    });

    document.getElementById('restartBtn').addEventListener('click', () => {
      document.getElementById('gameOverScreen').classList.add('hidden');
      document.getElementById('startScreen').classList.remove('hidden');
    });

    // Init
    window.addEventListener('resize', resize);
    resize();
    gameLoop();
  </script>
<script src="/sloppy-header/sloppy-bar.js"></script>
</body>
</html>
