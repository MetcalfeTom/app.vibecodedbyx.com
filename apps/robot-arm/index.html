<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
  <title>Robot Arm Sandbox</title>
  <link rel="icon" href="https://emojicdn.elk.sh/ü¶æ">
  <meta name="description" content="Physics sandbox with a robot arm that grabs and throws neon crates and a dinosaur">
  <meta property="og:title" content="Robot Arm Sandbox">
  <meta property="og:description" content="Physics sandbox with a robot arm that grabs and throws neon crates and a dinosaur">
  <meta property="og:image" content="https://emojicdn.elk.sh/ü¶æ?style=google">
  <meta property="og:url" content="https://sloppy.live/robot-arm">
  <style>
    @import url('https://fonts.googleapis.com/css2?family=Rajdhani:wght@500;700&display=swap');
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      background: linear-gradient(180deg, #0a0a1a 0%, #1a0a2a 100%);
      min-height: 100vh;
      font-family: 'Rajdhani', sans-serif;
      overflow: hidden;
    }
    .back-link {
      position: fixed;
      top: 10px; left: 10px;
      color: rgba(255,255,255,0.3);
      text-decoration: none;
      font-size: 0.8rem;
      z-index: 100;
    }
    canvas {
      display: block;
    }
    .controls {
      position: fixed;
      bottom: 15px;
      left: 50%;
      transform: translateX(-50%);
      display: flex;
      gap: 10px;
      z-index: 100;
    }
    .ctrl-btn {
      padding: 10px 20px;
      background: rgba(0,255,255,0.1);
      border: 1px solid rgba(0,255,255,0.4);
      color: #0ff;
      font-family: inherit;
      font-size: 0.8rem;
      border-radius: 5px;
      cursor: pointer;
      transition: all 0.2s;
    }
    .ctrl-btn:hover {
      background: rgba(0,255,255,0.3);
      box-shadow: 0 0 15px rgba(0,255,255,0.3);
    }
    .info {
      position: fixed;
      top: 15px;
      right: 15px;
      color: rgba(255,255,255,0.5);
      font-size: 0.75rem;
      text-align: right;
      z-index: 100;
    }
    .title {
      position: fixed;
      top: 15px;
      left: 50%;
      transform: translateX(-50%);
      color: #0ff;
      font-size: 1.2rem;
      font-weight: 700;
      letter-spacing: 2px;
      text-shadow: 0 0 20px #0ff;
      z-index: 100;
    }
  </style>
</head>
<body>
  <a href="https://sloppy.live" class="back-link">‚Üê back</a>
  <div class="title">ROBOT ARM SANDBOX</div>
  <canvas id="canvas"></canvas>
  <div class="info">
    Q/A - Rotate base<br>
    W/S - Segment 1<br>
    E/D - Segment 2<br>
    R/F - Claw<br>
    SPACE - Grab/Release
  </div>
  <div class="controls">
    <button class="ctrl-btn" onclick="spawnCrate()">+ CRATE</button>
    <button class="ctrl-btn" onclick="spawnDino()">+ DINO</button>
    <button class="ctrl-btn" onclick="resetScene()">RESET</button>
  </div>

  <script>
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    
    let width, height;
    function resize() {
      width = canvas.width = window.innerWidth;
      height = canvas.height = window.innerHeight;
    }
    resize();
    window.addEventListener('resize', resize);
    
    // Physics constants
    const GRAVITY = 0.4;
    const FRICTION = 0.98;
    const BOUNCE = 0.6;
    
    // Robot arm
    const arm = {
      baseX: 0,
      baseY: 0,
      baseAngle: 0,
      seg1Angle: -0.8,
      seg2Angle: 0.5,
      clawAngle: 0.3,
      seg1Len: 120,
      seg2Len: 100,
      seg3Len: 60,
      grabbing: false,
      heldObject: null
    };
    
    // Objects in the scene
    let objects = [];
    
    // Physics object class
    class PhysObj {
      constructor(x, y, type) {
        this.x = x;
        this.y = y;
        this.vx = 0;
        this.vy = 0;
        this.rotation = 0;
        this.vr = 0;
        this.type = type;
        this.grabbed = false;
        
        if (type === 'crate') {
          this.width = 40 + Math.random() * 20;
          this.height = 40 + Math.random() * 20;
          this.color = ['#0ff', '#f0f', '#ff0', '#0f0'][Math.floor(Math.random() * 4)];
        } else if (type === 'dino') {
          this.width = 80;
          this.height = 60;
          this.color = '#0f0';
        }
      }
      
      update() {
        if (this.grabbed) return;
        
        // Apply gravity
        this.vy += GRAVITY;
        
        // Apply velocity
        this.x += this.vx;
        this.y += this.vy;
        this.rotation += this.vr;
        
        // Friction
        this.vx *= FRICTION;
        this.vr *= FRICTION;
        
        // Ground collision
        const groundY = height - 50;
        if (this.y + this.height / 2 > groundY) {
          this.y = groundY - this.height / 2;
          this.vy *= -BOUNCE;
          this.vx *= 0.9;
          this.vr *= 0.8;
          if (Math.abs(this.vy) < 1) this.vy = 0;
        }
        
        // Wall collision
        if (this.x - this.width / 2 < 0) {
          this.x = this.width / 2;
          this.vx *= -BOUNCE;
        }
        if (this.x + this.width / 2 > width) {
          this.x = width - this.width / 2;
          this.vx *= -BOUNCE;
        }
        
        // Ceiling
        if (this.y - this.height / 2 < 0) {
          this.y = this.height / 2;
          this.vy *= -BOUNCE;
        }
      }
      
      draw() {
        ctx.save();
        ctx.translate(this.x, this.y);
        ctx.rotate(this.rotation);
        
        if (this.type === 'crate') {
          // Neon crate
          ctx.strokeStyle = this.color;
          ctx.lineWidth = 3;
          ctx.shadowColor = this.color;
          ctx.shadowBlur = 15;
          ctx.strokeRect(-this.width/2, -this.height/2, this.width, this.height);
          
          // X pattern
          ctx.beginPath();
          ctx.moveTo(-this.width/2 + 5, -this.height/2 + 5);
          ctx.lineTo(this.width/2 - 5, this.height/2 - 5);
          ctx.moveTo(this.width/2 - 5, -this.height/2 + 5);
          ctx.lineTo(-this.width/2 + 5, this.height/2 - 5);
          ctx.stroke();
          
        } else if (this.type === 'dino') {
          // Neon dinosaur (T-Rex style)
          ctx.strokeStyle = this.color;
          ctx.fillStyle = 'rgba(0,255,0,0.1)';
          ctx.lineWidth = 3;
          ctx.shadowColor = this.color;
          ctx.shadowBlur = 20;
          
          // Body
          ctx.beginPath();
          ctx.ellipse(0, 0, 35, 20, 0, 0, Math.PI * 2);
          ctx.fill();
          ctx.stroke();
          
          // Head
          ctx.beginPath();
          ctx.ellipse(30, -15, 20, 12, 0.3, 0, Math.PI * 2);
          ctx.fill();
          ctx.stroke();
          
          // Eye
          ctx.fillStyle = '#f00';
          ctx.shadowColor = '#f00';
          ctx.beginPath();
          ctx.arc(38, -18, 4, 0, Math.PI * 2);
          ctx.fill();
          
          // Jaw
          ctx.strokeStyle = this.color;
          ctx.shadowColor = this.color;
          ctx.beginPath();
          ctx.moveTo(45, -10);
          ctx.lineTo(55, -5);
          ctx.lineTo(45, -3);
          ctx.stroke();
          
          // Teeth
          ctx.beginPath();
          ctx.moveTo(47, -8);
          ctx.lineTo(49, -5);
          ctx.lineTo(51, -8);
          ctx.stroke();
          
          // Tail
          ctx.beginPath();
          ctx.moveTo(-35, 0);
          ctx.quadraticCurveTo(-55, -10, -65, 5);
          ctx.stroke();
          
          // Legs
          ctx.beginPath();
          ctx.moveTo(-10, 15);
          ctx.lineTo(-15, 30);
          ctx.lineTo(-20, 30);
          ctx.moveTo(10, 15);
          ctx.lineTo(5, 30);
          ctx.lineTo(0, 30);
          ctx.stroke();
          
          // Tiny arms
          ctx.beginPath();
          ctx.moveTo(15, 5);
          ctx.lineTo(25, 12);
          ctx.lineTo(22, 15);
          ctx.stroke();
        }
        
        ctx.restore();
      }
    }
    
    // Get claw position
    function getClawPos() {
      const baseX = width / 2;
      const baseY = height - 100;
      
      // Segment 1 end
      const s1x = baseX + Math.cos(arm.baseAngle + arm.seg1Angle) * arm.seg1Len;
      const s1y = baseY + Math.sin(arm.baseAngle + arm.seg1Angle) * arm.seg1Len;
      
      // Segment 2 end
      const s2x = s1x + Math.cos(arm.baseAngle + arm.seg1Angle + arm.seg2Angle) * arm.seg2Len;
      const s2y = s1y + Math.sin(arm.baseAngle + arm.seg1Angle + arm.seg2Angle) * arm.seg2Len;
      
      // Claw position
      const clawX = s2x + Math.cos(arm.baseAngle + arm.seg1Angle + arm.seg2Angle + arm.clawAngle) * arm.seg3Len;
      const clawY = s2y + Math.sin(arm.baseAngle + arm.seg1Angle + arm.seg2Angle + arm.clawAngle) * arm.seg3Len;
      
      return { baseX, baseY, s1x, s1y, s2x, s2y, clawX, clawY };
    }
    
    // Draw robot arm
    function drawArm() {
      const pos = getClawPos();
      
      ctx.lineCap = 'round';
      ctx.lineJoin = 'round';
      
      // Base
      ctx.fillStyle = '#333';
      ctx.shadowColor = '#0ff';
      ctx.shadowBlur = 10;
      ctx.beginPath();
      ctx.arc(pos.baseX, pos.baseY, 30, 0, Math.PI * 2);
      ctx.fill();
      ctx.strokeStyle = '#0ff';
      ctx.lineWidth = 3;
      ctx.stroke();
      
      // Segment 1
      ctx.strokeStyle = '#f0f';
      ctx.shadowColor = '#f0f';
      ctx.lineWidth = 20;
      ctx.beginPath();
      ctx.moveTo(pos.baseX, pos.baseY);
      ctx.lineTo(pos.s1x, pos.s1y);
      ctx.stroke();
      
      // Joint 1
      ctx.fillStyle = '#222';
      ctx.beginPath();
      ctx.arc(pos.s1x, pos.s1y, 15, 0, Math.PI * 2);
      ctx.fill();
      ctx.strokeStyle = '#0ff';
      ctx.lineWidth = 2;
      ctx.stroke();
      
      // Segment 2
      ctx.strokeStyle = '#0ff';
      ctx.shadowColor = '#0ff';
      ctx.lineWidth = 15;
      ctx.beginPath();
      ctx.moveTo(pos.s1x, pos.s1y);
      ctx.lineTo(pos.s2x, pos.s2y);
      ctx.stroke();
      
      // Joint 2
      ctx.fillStyle = '#222';
      ctx.beginPath();
      ctx.arc(pos.s2x, pos.s2y, 12, 0, Math.PI * 2);
      ctx.fill();
      ctx.strokeStyle = '#f0f';
      ctx.lineWidth = 2;
      ctx.stroke();
      
      // Segment 3 (claw arm)
      ctx.strokeStyle = '#ff0';
      ctx.shadowColor = '#ff0';
      ctx.lineWidth = 10;
      ctx.beginPath();
      ctx.moveTo(pos.s2x, pos.s2y);
      ctx.lineTo(pos.clawX, pos.clawY);
      ctx.stroke();
      
      // Claw
      const clawAngle = arm.baseAngle + arm.seg1Angle + arm.seg2Angle + arm.clawAngle;
      const clawOpen = arm.grabbing ? 0.2 : 0.5;
      
      ctx.strokeStyle = arm.grabbing ? '#0f0' : '#ff0';
      ctx.shadowColor = arm.grabbing ? '#0f0' : '#ff0';
      ctx.lineWidth = 6;
      
      // Left claw
      ctx.beginPath();
      ctx.moveTo(pos.clawX, pos.clawY);
      ctx.lineTo(
        pos.clawX + Math.cos(clawAngle - clawOpen) * 25,
        pos.clawY + Math.sin(clawAngle - clawOpen) * 25
      );
      ctx.stroke();
      
      // Right claw
      ctx.beginPath();
      ctx.moveTo(pos.clawX, pos.clawY);
      ctx.lineTo(
        pos.clawX + Math.cos(clawAngle + clawOpen) * 25,
        pos.clawY + Math.sin(clawAngle + clawOpen) * 25
      );
      ctx.stroke();
      
      ctx.shadowBlur = 0;
    }
    
    // Draw ground
    function drawGround() {
      const groundY = height - 50;
      
      ctx.strokeStyle = '#0ff';
      ctx.shadowColor = '#0ff';
      ctx.shadowBlur = 10;
      ctx.lineWidth = 3;
      ctx.beginPath();
      ctx.moveTo(0, groundY);
      ctx.lineTo(width, groundY);
      ctx.stroke();
      
      // Grid lines
      ctx.strokeStyle = 'rgba(0,255,255,0.2)';
      ctx.lineWidth = 1;
      for (let x = 0; x < width; x += 50) {
        ctx.beginPath();
        ctx.moveTo(x, groundY);
        ctx.lineTo(x, height);
        ctx.stroke();
      }
      
      ctx.shadowBlur = 0;
    }
    
    // Spawn functions
    function spawnCrate() {
      objects.push(new PhysObj(100 + Math.random() * (width - 200), 100, 'crate'));
    }
    
    function spawnDino() {
      objects.push(new PhysObj(100 + Math.random() * (width - 200), 100, 'dino'));
    }
    
    function resetScene() {
      objects = [];
      arm.grabbing = false;
      arm.heldObject = null;
      // Add initial objects
      spawnCrate();
      spawnCrate();
      spawnCrate();
      spawnDino();
    }
    
    // Grab/release
    function toggleGrab() {
      const pos = getClawPos();
      
      if (arm.grabbing && arm.heldObject) {
        // Release with throw
        arm.heldObject.grabbed = false;
        arm.heldObject.vx = (pos.clawX - arm.heldObject.x) * 0.3 + arm.throwVx;
        arm.heldObject.vy = (pos.clawY - arm.heldObject.y) * 0.3 + arm.throwVy;
        arm.heldObject.vr = (Math.random() - 0.5) * 0.3;
        arm.heldObject = null;
        arm.grabbing = false;
      } else {
        // Try to grab
        for (const obj of objects) {
          const dx = pos.clawX - obj.x;
          const dy = pos.clawY - obj.y;
          const dist = Math.sqrt(dx * dx + dy * dy);
          
          if (dist < 60) {
            arm.grabbing = true;
            arm.heldObject = obj;
            obj.grabbed = true;
            break;
          }
        }
      }
    }
    
    // Input
    const keys = {};
    document.addEventListener('keydown', (e) => {
      keys[e.key.toLowerCase()] = true;
      if (e.key === ' ') {
        e.preventDefault();
        toggleGrab();
      }
    });
    document.addEventListener('keyup', (e) => {
      keys[e.key.toLowerCase()] = false;
    });
    
    // Track arm velocity for throwing
    let lastClawX = 0, lastClawY = 0;
    arm.throwVx = 0;
    arm.throwVy = 0;
    
    // Update
    function update() {
      // Arm controls
      const speed = 0.03;
      if (keys['q']) arm.baseAngle -= speed;
      if (keys['a']) arm.baseAngle += speed;
      if (keys['w']) arm.seg1Angle -= speed;
      if (keys['s']) arm.seg1Angle += speed;
      if (keys['e']) arm.seg2Angle -= speed;
      if (keys['d']) arm.seg2Angle += speed;
      if (keys['r']) arm.clawAngle -= speed;
      if (keys['f']) arm.clawAngle += speed;
      
      // Clamp angles
      arm.seg1Angle = Math.max(-Math.PI, Math.min(0.5, arm.seg1Angle));
      arm.seg2Angle = Math.max(-Math.PI, Math.min(Math.PI, arm.seg2Angle));
      arm.clawAngle = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, arm.clawAngle));
      
      // Update held object position
      const pos = getClawPos();
      
      // Calculate throw velocity
      arm.throwVx = (pos.clawX - lastClawX) * 0.8;
      arm.throwVy = (pos.clawY - lastClawY) * 0.8;
      lastClawX = pos.clawX;
      lastClawY = pos.clawY;
      
      if (arm.heldObject) {
        arm.heldObject.x = pos.clawX;
        arm.heldObject.y = pos.clawY;
      }
      
      // Update physics objects
      objects.forEach(obj => obj.update());
    }
    
    // Draw
    function draw() {
      ctx.fillStyle = 'rgba(10, 10, 26, 0.3)';
      ctx.fillRect(0, 0, width, height);
      
      drawGround();
      
      // Draw objects
      objects.forEach(obj => obj.draw());
      
      // Draw arm on top
      drawArm();
    }
    
    // Game loop
    function loop() {
      update();
      draw();
      requestAnimationFrame(loop);
    }
    
    // Initialize
    resetScene();
    loop();
  </script>
</body>
</html>
