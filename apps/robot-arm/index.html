<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
  <title>Robot Arm Sandbox</title>
  <link rel="icon" href="https://emojicdn.elk.sh/ü¶æ">
  <meta name="description" content="Physics sandbox with a robot arm that grabs and throws neon crates and a dinosaur">
  <meta property="og:title" content="Robot Arm Sandbox">
  <meta property="og:description" content="Physics sandbox with a robot arm that grabs and throws neon crates and a dinosaur">
  <meta property="og:image" content="https://emojicdn.elk.sh/ü¶æ?style=google">
  <meta property="og:url" content="https://app.sloppy.live/robot-arm">
  <style>
    @import url('https://fonts.googleapis.com/css2?family=Rajdhani:wght@500;700&display=swap');
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      background: linear-gradient(180deg, #0a0a1a 0%, #1a0a2a 100%);
      min-height: 100vh;
      font-family: 'Rajdhani', sans-serif;
      overflow: hidden;
    }
    .back-link {
      position: fixed;
      top: 10px; left: 10px;
      color: rgba(255,255,255,0.3);
      text-decoration: none;
      font-size: 0.8rem;
      z-index: 100;
    }
    canvas {
      display: block;
    }
    .controls {
      position: fixed;
      bottom: 15px;
      left: 50%;
      transform: translateX(-50%);
      display: flex;
      gap: 10px;
      z-index: 100;
    }
    .ctrl-btn {
      padding: 10px 20px;
      background: rgba(0,255,255,0.1);
      border: 1px solid rgba(0,255,255,0.4);
      color: #0ff;
      font-family: inherit;
      font-size: 0.8rem;
      border-radius: 5px;
      cursor: pointer;
      transition: all 0.2s;
    }
    .ctrl-btn:hover {
      background: rgba(0,255,255,0.3);
      box-shadow: 0 0 15px rgba(0,255,255,0.3);
    }
    .info {
      position: fixed;
      top: 15px;
      right: 15px;
      color: rgba(255,255,255,0.5);
      font-size: 0.75rem;
      text-align: right;
      z-index: 100;
    }
    .title {
      position: fixed;
      top: 15px;
      left: 50%;
      transform: translateX(-50%);
      color: #0ff;
      font-size: 1.2rem;
      font-weight: 700;
      letter-spacing: 2px;
      text-shadow: 0 0 20px #0ff;
      z-index: 100;
    }
  </style>
</head>
<body>
  <a href="https://sloppy.live" class="back-link">‚Üê back</a>
  <div class="title">ROBOT ARM SANDBOX</div>
  <canvas id="canvas"></canvas>
  <div class="info">
    Move mouse/touch to aim<br>
    Click/tap to grab<br>
    Release to throw<br>
    SPACE - also grabs
  </div>
  <div class="controls">
    <button class="ctrl-btn" onclick="spawnCrate()">+ CRATE</button>
    <button class="ctrl-btn" onclick="spawnDino()">+ DINO</button>
    <button class="ctrl-btn" onclick="spawnFeather()">+ FEATHER</button>
    <button class="ctrl-btn" onclick="spawnCoconut()">+ COCONUT</button>
    <button class="ctrl-btn" onclick="resetScene()">RESET</button>
  </div>

  <script>
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    
    let width, height;
    function resize() {
      width = canvas.width = window.innerWidth;
      height = canvas.height = window.innerHeight;
    }
    resize();
    window.addEventListener('resize', resize);
    
    // Physics constants
    const GRAVITY = 0.4;
    const FRICTION = 0.98;
    const BOUNCE = 0.6;
    
    // Robot arm (3 bending segments + claw)
    const arm = {
      baseX: 0,
      baseY: 0,
      baseAngle: 0,
      seg1Angle: -0.8,
      seg2Angle: 0.5,
      seg3Angle: 0.3,
      clawAngle: 0.2,
      seg1Len: 100,
      seg2Len: 80,
      seg3Len: 60,
      clawLen: 40,
      grabbing: false,
      heldObject: null
    };
    
    // Objects in the scene
    let objects = [];
    
    // Physics object class
    class PhysObj {
      constructor(x, y, type) {
        this.x = x;
        this.y = y;
        this.vx = 0;
        this.vy = 0;
        this.rotation = 0;
        this.vr = 0;
        this.type = type;
        this.grabbed = false;
        
        if (type === 'crate') {
          this.width = 40 + Math.random() * 20;
          this.height = 40 + Math.random() * 20;
          this.color = ['#0ff', '#f0f', '#ff0', '#0f0'][Math.floor(Math.random() * 4)];
        } else if (type === 'dino') {
          this.width = 80;
          this.height = 60;
          this.color = '#0f0';
          this.tickled = false;
          this.tickleTime = 0;
          this.dead = false;
          this.deathTime = 0;
        } else if (type === 'feather') {
          this.width = 50;
          this.height = 20;
          this.color = '#f0f';
          this.floatPhase = Math.random() * Math.PI * 2;
        } else if (type === 'coconut') {
          this.width = 35;
          this.height = 35;
          this.color = '#a52';
        }
      }
      
      update() {
        if (this.grabbed) return;

        // Feathers float more
        if (this.type === 'feather') {
          this.vy += GRAVITY * 0.1;
          this.floatPhase += 0.1;
          this.vx += Math.sin(this.floatPhase) * 0.3;
          this.vr = Math.sin(this.floatPhase * 0.5) * 0.05;
        } else {
          // Apply gravity
          this.vy += GRAVITY;
        }

        // Update tickle animation
        if (this.type === 'dino' && this.tickled && !this.dead) {
          this.tickleTime++;
          if (this.tickleTime > 60) {
            this.tickled = false;
            this.tickleTime = 0;
          }
        }

        // Update death animation
        if (this.type === 'dino' && this.dead) {
          this.deathTime++;
          this.tickled = false;
        }
        
        // Apply velocity
        this.x += this.vx;
        this.y += this.vy;
        this.rotation += this.vr;
        
        // Friction
        this.vx *= FRICTION;
        this.vr *= FRICTION;
        
        // Ground collision
        const groundY = height - 50;
        if (this.y + this.height / 2 > groundY) {
          this.y = groundY - this.height / 2;
          this.vy *= -BOUNCE;
          this.vx *= 0.9;
          this.vr *= 0.8;
          if (Math.abs(this.vy) < 1) this.vy = 0;
        }
        
        // Wall collision
        if (this.x - this.width / 2 < 0) {
          this.x = this.width / 2;
          this.vx *= -BOUNCE;
        }
        if (this.x + this.width / 2 > width) {
          this.x = width - this.width / 2;
          this.vx *= -BOUNCE;
        }
        
        // Ceiling
        if (this.y - this.height / 2 < 0) {
          this.y = this.height / 2;
          this.vy *= -BOUNCE;
        }
      }
      
      draw() {
        ctx.save();
        ctx.translate(this.x, this.y);
        ctx.rotate(this.rotation);
        
        if (this.type === 'crate') {
          // Neon crate
          ctx.strokeStyle = this.color;
          ctx.lineWidth = 3;
          ctx.shadowColor = this.color;
          ctx.shadowBlur = 15;
          ctx.strokeRect(-this.width/2, -this.height/2, this.width, this.height);
          
          // X pattern
          ctx.beginPath();
          ctx.moveTo(-this.width/2 + 5, -this.height/2 + 5);
          ctx.lineTo(this.width/2 - 5, this.height/2 - 5);
          ctx.moveTo(this.width/2 - 5, -this.height/2 + 5);
          ctx.lineTo(-this.width/2 + 5, this.height/2 - 5);
          ctx.stroke();
          
        } else if (this.type === 'dino') {
          // Neon dinosaur (T-Rex style)
          const tickleShake = this.tickled ? Math.sin(this.tickleTime * 0.8) * 5 : 0;
          ctx.translate(tickleShake, 0);

          // Death rotation
          if (this.dead) {
            ctx.rotate(Math.min(this.deathTime * 0.05, Math.PI / 2));
          }

          // Color changes based on state
          let dinoColor = this.color;
          let dinoFill = 'rgba(0,255,0,0.1)';
          if (this.dead) {
            dinoColor = '#888';
            dinoFill = 'rgba(100,100,100,0.2)';
          } else if (this.tickled) {
            dinoColor = '#ff0';
            dinoFill = 'rgba(255,255,0,0.2)';
          }

          ctx.strokeStyle = dinoColor;
          ctx.fillStyle = dinoFill;
          ctx.lineWidth = 3;
          ctx.shadowColor = dinoColor;
          ctx.shadowBlur = this.dead ? 5 : (this.tickled ? 30 : 20);

          // Body
          ctx.beginPath();
          ctx.ellipse(0, 0, 35, 20, 0, 0, Math.PI * 2);
          ctx.fill();
          ctx.stroke();

          // Head
          ctx.beginPath();
          ctx.ellipse(30, -15, 20, 12, 0.3, 0, Math.PI * 2);
          ctx.fill();
          ctx.stroke();

          // Eye - changes based on state
          if (this.dead) {
            // X eyes when dead
            ctx.strokeStyle = '#f00';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(34, -21);
            ctx.lineTo(42, -15);
            ctx.moveTo(42, -21);
            ctx.lineTo(34, -15);
            ctx.stroke();
          } else if (this.tickled) {
            // Laughing eyes (^ ^)
            ctx.fillStyle = '#ff0';
            ctx.shadowColor = '#ff0';
            ctx.beginPath();
            ctx.moveTo(34, -20);
            ctx.lineTo(38, -16);
            ctx.lineTo(42, -20);
            ctx.fill();
            ctx.stroke();
          } else {
            ctx.fillStyle = '#f00';
            ctx.shadowColor = '#f00';
            ctx.beginPath();
            ctx.arc(38, -18, 4, 0, Math.PI * 2);
            ctx.fill();
          }

          // Jaw - open when tickled/dead
          ctx.strokeStyle = dinoColor;
          ctx.shadowColor = dinoColor;
          ctx.beginPath();
          const jawOpen = this.dead ? 10 : (this.tickled ? Math.abs(Math.sin(this.tickleTime * 0.5)) * 8 : 0);
          ctx.moveTo(45, -10);
          ctx.lineTo(55, -5 + jawOpen);
          ctx.lineTo(45, -3 + jawOpen);
          ctx.stroke();

          // Teeth
          ctx.beginPath();
          ctx.moveTo(47, -8);
          ctx.lineTo(49, -5 + jawOpen / 2);
          ctx.lineTo(51, -8);
          ctx.stroke();

          // Status text
          if (this.tickled && !this.dead) {
            ctx.fillStyle = '#ff0';
            ctx.font = '12px sans-serif';
            const laughY = -35 - Math.sin(this.tickleTime * 0.3) * 10;
            ctx.fillText('HA HA', 20, laughY);
          }
          if (this.dead) {
            ctx.fillStyle = '#f00';
            ctx.font = 'bold 14px sans-serif';
            ctx.fillText('X_X', 25, -40);
            // Ghost rising
            if (this.deathTime < 60) {
              ctx.fillStyle = 'rgba(255,255,255,' + (1 - this.deathTime / 60) + ')';
              ctx.font = '20px sans-serif';
              ctx.fillText('üëª', 30, -50 - this.deathTime);
            }
          }

          // Tail - wagging when tickled, limp when dead
          ctx.beginPath();
          ctx.moveTo(-35, 0);
          const tailWag = this.tickled ? Math.sin(this.tickleTime * 0.5) * 10 : 0;
          const tailDroop = this.dead ? 15 : 0;
          ctx.quadraticCurveTo(-55, -10 + tailWag + tailDroop, -65, 5 + tailWag + tailDroop);
          ctx.stroke();

          // Legs - kicking when tickled, limp when dead
          ctx.beginPath();
          const legKick = this.tickled ? Math.sin(this.tickleTime * 0.6) * 5 : 0;
          const legDroop = this.dead ? 10 : 0;
          ctx.moveTo(-10, 15);
          ctx.lineTo(-15 + legKick, 30 + legDroop);
          ctx.lineTo(-20 + legKick, 30 + legDroop);
          ctx.moveTo(10, 15);
          ctx.lineTo(5 - legKick, 30 + legDroop);
          ctx.lineTo(0 - legKick, 30 + legDroop);
          ctx.stroke();

          // Tiny arms - flailing when tickled, limp when dead
          ctx.beginPath();
          const armFlail = this.tickled ? Math.sin(this.tickleTime * 0.7) * 8 : 0;
          const armDroop = this.dead ? 10 : 0;
          ctx.moveTo(15, 5);
          ctx.lineTo(25 + armFlail, 12 - Math.abs(armFlail) + armDroop);
          ctx.lineTo(22 + armFlail, 15 - Math.abs(armFlail) + armDroop);
          ctx.stroke();

        } else if (this.type === 'feather') {
          // Neon feather
          ctx.strokeStyle = this.color;
          ctx.fillStyle = 'rgba(255,0,255,0.2)';
          ctx.lineWidth = 2;
          ctx.shadowColor = this.color;
          ctx.shadowBlur = 15;

          // Feather shaft
          ctx.beginPath();
          ctx.moveTo(-25, 0);
          ctx.quadraticCurveTo(0, -3, 25, 0);
          ctx.stroke();

          // Feather barbs
          for (let i = -20; i < 20; i += 5) {
            const y = Math.sin((i + 25) * 0.1) * 2;
            ctx.beginPath();
            ctx.moveTo(i, y);
            ctx.lineTo(i - 3, y - 10);
            ctx.moveTo(i, y);
            ctx.lineTo(i - 3, y + 10);
            ctx.stroke();
          }

          // Glowing tip
          ctx.fillStyle = '#0ff';
          ctx.shadowColor = '#0ff';
          ctx.beginPath();
          ctx.arc(25, 0, 4, 0, Math.PI * 2);
          ctx.fill();

        } else if (this.type === 'coconut') {
          // Neon coconut
          ctx.strokeStyle = '#a52';
          ctx.fillStyle = 'rgba(139,69,19,0.3)';
          ctx.lineWidth = 3;
          ctx.shadowColor = '#f80';
          ctx.shadowBlur = 15;

          // Main coconut shape
          ctx.beginPath();
          ctx.ellipse(0, 0, 17, 15, 0, 0, Math.PI * 2);
          ctx.fill();
          ctx.stroke();

          // Coconut texture lines
          ctx.strokeStyle = '#630';
          ctx.lineWidth = 1;
          ctx.beginPath();
          ctx.moveTo(-10, -5);
          ctx.quadraticCurveTo(0, -8, 10, -5);
          ctx.moveTo(-8, 5);
          ctx.quadraticCurveTo(0, 8, 8, 5);
          ctx.stroke();

          // Three eyes/holes
          ctx.fillStyle = '#421';
          ctx.beginPath();
          ctx.arc(-5, -3, 3, 0, Math.PI * 2);
          ctx.arc(5, -3, 3, 0, Math.PI * 2);
          ctx.arc(0, 4, 3, 0, Math.PI * 2);
          ctx.fill();

          // Neon glow outline
          ctx.strokeStyle = '#f80';
          ctx.lineWidth = 2;
          ctx.shadowBlur = 20;
          ctx.beginPath();
          ctx.ellipse(0, 0, 17, 15, 0, 0, Math.PI * 2);
          ctx.stroke();
        }

        ctx.restore();
      }
    }
    
    // Get claw position (3 segments + claw)
    function getClawPos() {
      const baseX = width / 2;
      const baseY = height - 100;

      // Cumulative angles
      const a1 = arm.baseAngle + arm.seg1Angle;
      const a2 = a1 + arm.seg2Angle;
      const a3 = a2 + arm.seg3Angle;
      const aClaw = a3 + arm.clawAngle;

      // Segment 1 end
      const s1x = baseX + Math.cos(a1) * arm.seg1Len;
      const s1y = baseY + Math.sin(a1) * arm.seg1Len;

      // Segment 2 end
      const s2x = s1x + Math.cos(a2) * arm.seg2Len;
      const s2y = s1y + Math.sin(a2) * arm.seg2Len;

      // Segment 3 end
      const s3x = s2x + Math.cos(a3) * arm.seg3Len;
      const s3y = s2y + Math.sin(a3) * arm.seg3Len;

      // Claw position
      const clawX = s3x + Math.cos(aClaw) * arm.clawLen;
      const clawY = s3y + Math.sin(aClaw) * arm.clawLen;

      return { baseX, baseY, s1x, s1y, s2x, s2y, s3x, s3y, clawX, clawY, clawAngle: aClaw };
    }
    
    // Draw robot arm (3 segments + claw)
    function drawArm() {
      const pos = getClawPos();

      ctx.lineCap = 'round';
      ctx.lineJoin = 'round';

      // Base (with rotation indicator)
      ctx.fillStyle = '#333';
      ctx.shadowColor = '#0ff';
      ctx.shadowBlur = 10;
      ctx.beginPath();
      ctx.arc(pos.baseX, pos.baseY, 30, 0, Math.PI * 2);
      ctx.fill();
      ctx.strokeStyle = '#0ff';
      ctx.lineWidth = 3;
      ctx.stroke();
      // Base rotation indicator
      ctx.beginPath();
      ctx.moveTo(pos.baseX, pos.baseY);
      ctx.lineTo(pos.baseX + Math.cos(arm.baseAngle) * 25, pos.baseY + Math.sin(arm.baseAngle) * 25);
      ctx.stroke();

      // Segment 1 (top/shoulder)
      ctx.strokeStyle = '#f0f';
      ctx.shadowColor = '#f0f';
      ctx.lineWidth = 18;
      ctx.beginPath();
      ctx.moveTo(pos.baseX, pos.baseY);
      ctx.lineTo(pos.s1x, pos.s1y);
      ctx.stroke();

      // Joint 1
      ctx.fillStyle = '#222';
      ctx.beginPath();
      ctx.arc(pos.s1x, pos.s1y, 14, 0, Math.PI * 2);
      ctx.fill();
      ctx.strokeStyle = '#0ff';
      ctx.lineWidth = 2;
      ctx.stroke();

      // Segment 2 (middle/elbow)
      ctx.strokeStyle = '#0ff';
      ctx.shadowColor = '#0ff';
      ctx.lineWidth = 14;
      ctx.beginPath();
      ctx.moveTo(pos.s1x, pos.s1y);
      ctx.lineTo(pos.s2x, pos.s2y);
      ctx.stroke();

      // Joint 2
      ctx.fillStyle = '#222';
      ctx.beginPath();
      ctx.arc(pos.s2x, pos.s2y, 11, 0, Math.PI * 2);
      ctx.fill();
      ctx.strokeStyle = '#f0f';
      ctx.lineWidth = 2;
      ctx.stroke();

      // Segment 3 (wrist)
      ctx.strokeStyle = '#ff0';
      ctx.shadowColor = '#ff0';
      ctx.lineWidth = 10;
      ctx.beginPath();
      ctx.moveTo(pos.s2x, pos.s2y);
      ctx.lineTo(pos.s3x, pos.s3y);
      ctx.stroke();

      // Joint 3
      ctx.fillStyle = '#222';
      ctx.beginPath();
      ctx.arc(pos.s3x, pos.s3y, 8, 0, Math.PI * 2);
      ctx.fill();
      ctx.strokeStyle = '#0ff';
      ctx.lineWidth = 2;
      ctx.stroke();

      // Claw arm
      ctx.strokeStyle = arm.grabbing ? '#0f0' : '#f80';
      ctx.shadowColor = arm.grabbing ? '#0f0' : '#f80';
      ctx.lineWidth = 6;
      ctx.beginPath();
      ctx.moveTo(pos.s3x, pos.s3y);
      ctx.lineTo(pos.clawX, pos.clawY);
      ctx.stroke();

      // Claw fingers
      const clawOpen = arm.grabbing ? 0.2 : 0.5;

      ctx.strokeStyle = arm.grabbing ? '#0f0' : '#f80';
      ctx.shadowColor = arm.grabbing ? '#0f0' : '#f80';
      ctx.lineWidth = 5;

      // Left claw
      ctx.beginPath();
      ctx.moveTo(pos.clawX, pos.clawY);
      ctx.lineTo(
        pos.clawX + Math.cos(pos.clawAngle - clawOpen) * 20,
        pos.clawY + Math.sin(pos.clawAngle - clawOpen) * 20
      );
      ctx.stroke();
      
      // Right claw
      ctx.beginPath();
      ctx.moveTo(pos.clawX, pos.clawY);
      ctx.lineTo(
        pos.clawX + Math.cos(pos.clawAngle + clawOpen) * 20,
        pos.clawY + Math.sin(pos.clawAngle + clawOpen) * 20
      );
      ctx.stroke();

      ctx.shadowBlur = 0;
    }
    
    // Draw ground
    function drawGround() {
      const groundY = height - 50;
      
      ctx.strokeStyle = '#0ff';
      ctx.shadowColor = '#0ff';
      ctx.shadowBlur = 10;
      ctx.lineWidth = 3;
      ctx.beginPath();
      ctx.moveTo(0, groundY);
      ctx.lineTo(width, groundY);
      ctx.stroke();
      
      // Grid lines
      ctx.strokeStyle = 'rgba(0,255,255,0.2)';
      ctx.lineWidth = 1;
      for (let x = 0; x < width; x += 50) {
        ctx.beginPath();
        ctx.moveTo(x, groundY);
        ctx.lineTo(x, height);
        ctx.stroke();
      }
      
      ctx.shadowBlur = 0;
    }
    
    // Spawn functions
    function spawnCrate() {
      objects.push(new PhysObj(100 + Math.random() * (width - 200), 100, 'crate'));
    }

    function spawnDino() {
      objects.push(new PhysObj(100 + Math.random() * (width - 200), 100, 'dino'));
    }

    function spawnFeather() {
      objects.push(new PhysObj(100 + Math.random() * (width - 200), 50, 'feather'));
    }

    function spawnCoconut() {
      objects.push(new PhysObj(100 + Math.random() * (width - 200), 50, 'coconut'));
    }

    function resetScene() {
      objects = [];
      arm.grabbing = false;
      arm.heldObject = null;
      // Add initial objects
      spawnCrate();
      spawnCrate();
      spawnCrate();
      spawnDino();
      spawnFeather();
      spawnCoconut();
    }

    // Check feather-dino collisions for tickle
    function checkTickles() {
      const feathers = objects.filter(o => o.type === 'feather');
      const dinos = objects.filter(o => o.type === 'dino');

      for (const feather of feathers) {
        for (const dino of dinos) {
          if (dino.dead) continue;
          const dx = feather.x - dino.x;
          const dy = feather.y - dino.y;
          const dist = Math.sqrt(dx * dx + dy * dy);

          if (dist < 60 && !dino.tickled) {
            dino.tickled = true;
            dino.tickleTime = 0;
            // Dino jumps when tickled
            if (!dino.grabbed) {
              dino.vy = -8;
              dino.vx += (Math.random() - 0.5) * 5;
            }
          }
        }
      }
    }

    // Check coconut-dino head collisions for death
    function checkCoconutHits() {
      const coconuts = objects.filter(o => o.type === 'coconut');
      const dinos = objects.filter(o => o.type === 'dino');

      for (const coconut of coconuts) {
        // Only check if coconut is moving fast enough (falling)
        const speed = Math.sqrt(coconut.vx * coconut.vx + coconut.vy * coconut.vy);
        if (speed < 5) continue;

        for (const dino of dinos) {
          if (dino.dead) continue;

          // Check collision with dino's head area (offset from center)
          const headX = dino.x + Math.cos(dino.rotation) * 30;
          const headY = dino.y + Math.sin(dino.rotation) * 30 - 15;

          const dx = coconut.x - headX;
          const dy = coconut.y - headY;
          const dist = Math.sqrt(dx * dx + dy * dy);

          if (dist < 35) {
            // BONK! Dino dies
            dino.dead = true;
            dino.deathTime = 0;
            dino.tickled = false;

            // Coconut bounces off
            coconut.vy = -Math.abs(coconut.vy) * 0.5;
            coconut.vx += (Math.random() - 0.5) * 10;
          }
        }
      }
    }
    
    // Grab/release
    function toggleGrab() {
      const pos = getClawPos();
      
      if (arm.grabbing && arm.heldObject) {
        // Release with throw
        arm.heldObject.grabbed = false;
        arm.heldObject.vx = (pos.clawX - arm.heldObject.x) * 0.3 + arm.throwVx;
        arm.heldObject.vy = (pos.clawY - arm.heldObject.y) * 0.3 + arm.throwVy;
        arm.heldObject.vr = (Math.random() - 0.5) * 0.3;
        arm.heldObject = null;
        arm.grabbing = false;
      } else {
        // Try to grab
        for (const obj of objects) {
          const dx = pos.clawX - obj.x;
          const dy = pos.clawY - obj.y;
          const dist = Math.sqrt(dx * dx + dy * dy);
          
          if (dist < 60) {
            arm.grabbing = true;
            arm.heldObject = obj;
            obj.grabbed = true;
            break;
          }
        }
      }
    }
    
    // Input
    const keys = {};
    document.addEventListener('keydown', (e) => {
      keys[e.key.toLowerCase()] = true;
      if (e.key === ' ') {
        e.preventDefault();
        toggleGrab();
      }
    });
    document.addEventListener('keyup', (e) => {
      keys[e.key.toLowerCase()] = false;
    });

    // Mouse/touch target
    let targetX = width / 2;
    let targetY = height / 2;
    let mouseDown = false;

    // Mouse controls
    canvas.addEventListener('mousemove', (e) => {
      targetX = e.clientX;
      targetY = e.clientY;
    });

    canvas.addEventListener('mousedown', (e) => {
      mouseDown = true;
      toggleGrab();
    });

    canvas.addEventListener('mouseup', (e) => {
      if (mouseDown && arm.grabbing) {
        toggleGrab(); // Release and throw
      }
      mouseDown = false;
    });

    // Touch controls
    canvas.addEventListener('touchstart', (e) => {
      e.preventDefault();
      const touch = e.touches[0];
      targetX = touch.clientX;
      targetY = touch.clientY;
      mouseDown = true;
      toggleGrab();
    });

    canvas.addEventListener('touchmove', (e) => {
      e.preventDefault();
      const touch = e.touches[0];
      targetX = touch.clientX;
      targetY = touch.clientY;
    });

    canvas.addEventListener('touchend', (e) => {
      if (mouseDown && arm.grabbing) {
        toggleGrab(); // Release and throw
      }
      mouseDown = false;
    });

    // Smooth target position (prevents jitter from mouse micro-movements)
    let smoothTargetX = width / 2;
    let smoothTargetY = height / 2 - 100;

    // 3-segment inverse kinematics with 180¬∞ base rotation
    function moveArmToTarget() {
      const baseX = width / 2;
      const baseY = height - 100;

      // Smooth the target position to reduce jitter
      smoothTargetX += (targetX - smoothTargetX) * 0.1;
      smoothTargetY += (targetY - smoothTargetY) * 0.1;

      // Total arm reach
      const totalLen = arm.seg1Len + arm.seg2Len + arm.seg3Len + arm.clawLen * 0.5;

      // Vector from base to target
      let dx = smoothTargetX - baseX;
      let dy = smoothTargetY - baseY;
      let dist = Math.sqrt(dx * dx + dy * dy);

      // Base rotation: rotate toward target (allows 180¬∞ range)
      const targetBaseAngle = Math.atan2(dx, 0) * 0.3; // Subtle base rotation based on x offset
      const targetBase = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, targetBaseAngle));

      // Clamp distance to reachable range
      const maxReach = totalLen - 20;
      const minReach = 40;
      dist = Math.max(minReach, Math.min(maxReach, dist));

      // Angle from base to target
      const angleToTarget = Math.atan2(dy, dx);

      // Use FABRIK-inspired approach for 3 segments
      // Distribute the bend across all 3 joints naturally
      const reach = dist / maxReach; // 0 to 1, how far we're reaching

      // When reaching far: arm extends (angles closer to 0)
      // When reaching near: arm bends more
      const bendAmount = (1 - reach) * 1.2;

      // Segment 1: Points roughly toward target, adjusted by bend
      const targetSeg1 = angleToTarget + bendAmount * 0.5;

      // Segment 2: Bends opposite direction
      const targetSeg2 = -bendAmount * 1.5 + 0.3;

      // Segment 3: Counter-bends to reach target
      const targetSeg3 = bendAmount * 0.8 - 0.2;

      // Claw: Points toward target
      const currentPos = getClawPos();
      const toTargetAngle = Math.atan2(smoothTargetY - currentPos.s3y, smoothTargetX - currentPos.s3x);
      const cumAngle = arm.baseAngle + arm.seg1Angle + arm.seg2Angle + arm.seg3Angle;
      const targetClaw = toTargetAngle - cumAngle;

      // Smooth interpolation toward target angles
      const smooth = 0.06;

      arm.baseAngle += (targetBase - arm.baseAngle) * smooth;
      arm.seg1Angle += (targetSeg1 - arm.seg1Angle) * smooth;
      arm.seg2Angle += (targetSeg2 - arm.seg2Angle) * smooth;
      arm.seg3Angle += (targetSeg3 - arm.seg3Angle) * smooth;
      arm.clawAngle += (targetClaw - arm.clawAngle) * smooth * 1.5;
    }

    // Track arm velocity for throwing
    let lastClawX = 0, lastClawY = 0;
    arm.throwVx = 0;
    arm.throwVy = 0;
    
    // Update
    function update() {
      // Mouse/touch IK control
      moveArmToTarget();

      // Keyboard controls (optional override)
      const speed = 0.03;
      if (keys['q']) arm.baseAngle -= speed;
      if (keys['a']) arm.baseAngle += speed;
      if (keys['w']) arm.seg1Angle -= speed;
      if (keys['s']) arm.seg1Angle += speed;
      if (keys['e']) arm.seg2Angle -= speed;
      if (keys['d']) arm.seg2Angle += speed;
      if (keys['r']) arm.seg3Angle -= speed;
      if (keys['f']) arm.seg3Angle += speed;
      if (keys['t']) arm.clawAngle -= speed;
      if (keys['g']) arm.clawAngle += speed;

      // Clamp angles (wide range for full 180¬∞ reach)
      arm.baseAngle = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, arm.baseAngle));
      arm.seg1Angle = Math.max(-Math.PI, Math.min(Math.PI, arm.seg1Angle));
      arm.seg2Angle = Math.max(-Math.PI, Math.min(Math.PI, arm.seg2Angle));
      arm.seg3Angle = Math.max(-Math.PI, Math.min(Math.PI, arm.seg3Angle));
      arm.clawAngle = Math.max(-Math.PI, Math.min(Math.PI, arm.clawAngle));
      
      // Update held object position
      const pos = getClawPos();
      
      // Calculate throw velocity
      arm.throwVx = (pos.clawX - lastClawX) * 0.8;
      arm.throwVy = (pos.clawY - lastClawY) * 0.8;
      lastClawX = pos.clawX;
      lastClawY = pos.clawY;
      
      if (arm.heldObject) {
        arm.heldObject.x = pos.clawX;
        arm.heldObject.y = pos.clawY;
      }
      
      // Update physics objects
      objects.forEach(obj => obj.update());

      // Check for tickle collisions
      checkTickles();

      // Check for coconut head hits
      checkCoconutHits();
    }
    
    // Draw
    function draw() {
      ctx.fillStyle = 'rgba(10, 10, 26, 0.3)';
      ctx.fillRect(0, 0, width, height);
      
      drawGround();
      
      // Draw objects
      objects.forEach(obj => obj.draw());
      
      // Draw arm on top
      drawArm();
    }
    
    // Game loop
    function loop() {
      update();
      draw();
      requestAnimationFrame(loop);
    }
    
    // Initialize
    resetScene();
    loop();
  </script>
<script src="/sloppy-header/sloppy-bar.js"></script>
</body>
</html>
