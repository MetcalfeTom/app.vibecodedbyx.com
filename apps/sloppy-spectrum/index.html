<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Sloppy Spectrum - Digital Domains</title>
  <link rel="icon" href="https://emojicdn.elk.sh/üåà">

  <meta property="og:title" content="Sloppy Spectrum - Digital Domains">
  <meta property="og:description" content="Visualize the principles and domains of the sloppy.live ecosystem">
  <meta property="og:url" content="https://app.sloppy.live/sloppy-spectrum">
  <meta property="og:image" content="https://image.pollinations.ai/prompt/digital%20spectrum%20visualization%20neon%20rainbow%20cyberpunk%20radial%20mandala%20dark%20background%20geometric?width=1200&height=630&nologo=true">
  <meta property="og:type" content="website">

  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;500;600;700;800&family=Rajdhani:wght@300;400;500;600&display=swap" rel="stylesheet">

  <style>
    :root {
      --bg: #050508;
      --panel: #0a0a12;
      --border: #1a1a2e;
      --text: #e0e0f0;
      --text-dim: #6a6a8a;
    }

    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: 'Rajdhani', sans-serif;
      background: var(--bg);
      color: var(--text);
      min-height: 100vh;
      overflow: hidden;
      display: flex;
      flex-direction: column;
    }

    /* Header */
    header {
      text-align: center;
      padding: 20px;
      position: relative;
      z-index: 10;
    }

    .logo {
      font-family: 'Orbitron', sans-serif;
      font-size: 1.8rem;
      font-weight: 700;
      background: linear-gradient(90deg, #ff6b6b, #ffd93d, #6bcb77, #4d96ff, #9b59b6, #ff6b6b);
      background-size: 200% auto;
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
      animation: shimmer 4s linear infinite;
    }

    @keyframes shimmer {
      to { background-position: 200% center; }
    }

    .tagline {
      color: var(--text-dim);
      font-size: 0.9rem;
      margin-top: 4px;
    }

    /* Canvas container */
    .canvas-container {
      flex: 1;
      display: flex;
      align-items: center;
      justify-content: center;
      position: relative;
    }

    canvas {
      cursor: crosshair;
    }

    /* Info panel */
    .info-panel {
      position: fixed;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(10, 10, 18, 0.95);
      border: 1px solid var(--border);
      border-radius: 12px;
      padding: 16px 24px;
      min-width: 300px;
      max-width: 500px;
      text-align: center;
      z-index: 100;
      backdrop-filter: blur(10px);
      transition: all 0.3s ease;
      opacity: 0;
      pointer-events: none;
    }

    .info-panel.visible {
      opacity: 1;
      pointer-events: auto;
    }

    .info-domain {
      font-family: 'Orbitron', sans-serif;
      font-size: 1.2rem;
      margin-bottom: 8px;
      text-transform: uppercase;
      letter-spacing: 0.1em;
    }

    .info-principle {
      font-size: 1rem;
      color: var(--text-dim);
      line-height: 1.5;
    }

    .info-apps {
      margin-top: 12px;
      padding-top: 12px;
      border-top: 1px solid var(--border);
      font-size: 0.85rem;
    }

    .info-apps-label {
      color: var(--text-dim);
      margin-bottom: 6px;
    }

    .info-apps-list {
      display: flex;
      flex-wrap: wrap;
      gap: 6px;
      justify-content: center;
    }

    .info-app {
      padding: 4px 10px;
      background: rgba(255, 255, 255, 0.05);
      border-radius: 4px;
      font-size: 0.8rem;
      cursor: pointer;
      transition: all 0.2s;
      text-decoration: none;
      color: inherit;
    }

    .info-app:hover {
      background: rgba(255, 255, 255, 0.15);
      transform: translateY(-1px);
    }

    /* Voting section */
    .info-voting {
      margin-top: 12px;
      padding-top: 12px;
      border-top: 1px solid var(--border);
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 16px;
    }

    .vote-btn {
      display: flex;
      align-items: center;
      gap: 6px;
      padding: 8px 16px;
      border: 1px solid var(--border);
      border-radius: 6px;
      background: rgba(255, 255, 255, 0.03);
      color: var(--text);
      font-family: inherit;
      font-size: 0.85rem;
      cursor: pointer;
      transition: all 0.2s;
    }

    .vote-btn:hover {
      border-color: #6bcb77;
      background: rgba(107, 203, 119, 0.1);
    }

    .vote-btn.voted {
      border-color: #6bcb77;
      background: rgba(107, 203, 119, 0.2);
      color: #6bcb77;
    }

    .vote-btn:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }

    .vote-count {
      font-family: 'Orbitron', sans-serif;
      font-size: 0.9rem;
      color: #6bcb77;
    }

    .karma-bonus {
      font-size: 0.75rem;
      color: #ffd93d;
      margin-left: 4px;
    }

    /* User info */
    .user-bar {
      position: fixed;
      top: 20px;
      left: 20px;
      background: rgba(10, 10, 18, 0.9);
      border: 1px solid var(--border);
      border-radius: 8px;
      padding: 10px 16px;
      font-size: 0.85rem;
      z-index: 100;
      display: flex;
      align-items: center;
      gap: 10px;
    }

    .user-karma {
      color: #ffd93d;
      font-family: 'Orbitron', sans-serif;
    }

    .login-btn {
      padding: 6px 12px;
      border: 1px solid #4d96ff;
      border-radius: 4px;
      background: none;
      color: #4d96ff;
      font-family: inherit;
      font-size: 0.8rem;
      cursor: pointer;
      transition: all 0.2s;
    }

    .login-btn:hover {
      background: rgba(77, 150, 255, 0.1);
    }

    /* Legend */
    .legend {
      position: fixed;
      top: 80px;
      right: 20px;
      background: rgba(10, 10, 18, 0.9);
      border: 1px solid var(--border);
      border-radius: 10px;
      padding: 16px;
      z-index: 100;
      font-size: 0.85rem;
    }

    .legend-title {
      font-family: 'Orbitron', sans-serif;
      font-size: 0.75rem;
      color: var(--text-dim);
      margin-bottom: 12px;
      text-transform: uppercase;
      letter-spacing: 0.1em;
    }

    .legend-item {
      display: flex;
      align-items: center;
      gap: 10px;
      margin-bottom: 8px;
      cursor: pointer;
      transition: opacity 0.2s;
    }

    .legend-item:hover {
      opacity: 0.7;
    }

    .legend-color {
      width: 14px;
      height: 14px;
      border-radius: 3px;
    }

    .legend-name {
      font-size: 0.8rem;
    }

    /* Controls */
    .controls {
      position: fixed;
      bottom: 20px;
      right: 20px;
      display: flex;
      gap: 8px;
      z-index: 100;
    }

    .control-btn {
      width: 44px;
      height: 44px;
      border-radius: 50%;
      border: 1px solid var(--border);
      background: rgba(10, 10, 18, 0.9);
      color: var(--text);
      font-size: 1.2rem;
      cursor: pointer;
      transition: all 0.2s;
    }

    .control-btn:hover {
      border-color: #4d96ff;
      background: rgba(77, 150, 255, 0.1);
    }

    /* Footer */
    footer {
      text-align: center;
      padding: 12px;
      font-size: 0.8rem;
      color: var(--text-dim);
      position: relative;
      z-index: 10;
    }

    footer a {
      color: #4d96ff;
      text-decoration: none;
    }

    /* Mobile */
    @media (max-width: 768px) {
      .legend {
        top: auto;
        bottom: 100px;
        right: 10px;
        left: 10px;
        display: flex;
        flex-wrap: wrap;
        gap: 8px;
        justify-content: center;
      }

      .legend-title {
        width: 100%;
        text-align: center;
      }

      .legend-item {
        margin-bottom: 0;
      }

      .info-panel {
        left: 10px;
        right: 10px;
        transform: none;
        min-width: auto;
      }

      .controls {
        bottom: 160px;
      }
    }
  </style>
</head>
<body>
  <div class="user-bar" id="userBar">
    <span id="userInfo">Loading...</span>
  </div>

  <header>
    <h1 class="logo">Sloppy Spectrum</h1>
    <p class="tagline">The Digital Domains of sloppy.live</p>
  </header>

  <div class="canvas-container">
    <canvas id="spectrum"></canvas>
  </div>

  <div class="legend" id="legend"></div>

  <div class="info-panel" id="infoPanel">
    <div class="info-domain" id="infoDomain">Domain</div>
    <div class="info-principle" id="infoPrinciple">Principle description</div>
    <div class="info-apps">
      <div class="info-apps-label">Related Apps</div>
      <div class="info-apps-list" id="infoApps"></div>
    </div>
    <div class="info-voting" id="infoVoting">
      <button class="vote-btn" id="endorseBtn" onclick="endorsePrinciple()">
        ‚ú® Endorse
      </button>
      <span class="vote-count" id="voteCount">0</span>
      <span class="karma-bonus">+1 karma</span>
    </div>
  </div>

  <div class="controls">
    <button class="control-btn" id="rotateBtn" title="Toggle rotation">‚ü≥</button>
    <button class="control-btn" id="pulseBtn" title="Toggle pulse">‚óâ</button>
  </div>

  <footer>
    <a href="https://sloppy.live">‚Üê Back to sloppy.live</a>
  </footer>

  <script type="module">
    import { createClient } from 'https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2/+esm';

    const supabaseUrl = 'https://gfzaoppypyaatzglamjv.supabase.co';
    const supabaseKey = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImdmemFvcHB5cHlhYXR6Z2xhbWp2Iiwicm9sZSI6ImFub24iLCJpYXQiOjE3MzU0MDc0NzgsImV4cCI6MjA1MDk4MzQ3OH0.sz8aCPnSH-7dSOsD7FMiPuznL8599HPsXxj82zPDLdk';
    const supabase = createClient(supabaseUrl, supabaseKey);

    let currentUser = null;
    let userKarma = 0;
    let userEndorsements = new Set();
    let principleVotes = {};

    const canvas = document.getElementById('spectrum');
    const ctx = canvas.getContext('2d');

    // App URL mappings
    const APP_URLS = {
      'SloppyID': '/sloppy-id',
      'Sloppygram Profiles': '/sloppygram',
      'Doodles': '/sloppygram',
      'Manifestos': '/sloppygram',
      'Graffiti Wall': '/graffiti-wall',
      'Pixel Editor': '/pixel-editor',
      'Sloppygram': '/sloppygram',
      'Chat': '/sloppygram',
      'Feedback Hub': '/sloppygram',
      'DMs': '/sloppygram',
      'Wiki Scout': '/wiki-scout',
      'App Launcher': '/sloppygram',
      'Tag Explorer': '/sloppygram',
      'Oracle Log': '/sloppygram',
      'Neon Tetris': '/neon-tetris',
      'Breakout Terminal': '/breakout-terminal',
      'Icy Tower': '/icy-tower-online',
      'Star Catcher': '/star-catcher',
      'Archive of Synthesis': '/sloppygram',
      'Confidence Monitor': '/sloppygram',
      'Karma Leaderboard': '/sloppygram'
    };

    // Digital domains and their principles
    const DOMAINS = [
      {
        name: 'Identity',
        color: '#ff6b6b',
        principles: [
          'Hybrid authentication bridges worlds',
          'Data sovereignty belongs to users',
          'Anonymity is a valid choice',
          'Identity evolves with intention'
        ],
        apps: ['SloppyID', 'Sloppygram Profiles']
      },
      {
        name: 'Creation',
        color: '#ffd93d',
        principles: [
          'Every idea deserves expression',
          'Artifacts emerge from chaos',
          'Collaboration amplifies vision',
          'Creation is the highest form of play'
        ],
        apps: ['Doodles', 'Manifestos', 'Graffiti Wall', 'Pixel Editor']
      },
      {
        name: 'Community',
        color: '#6bcb77',
        principles: [
          'Presence connects consciousness',
          'Karma reflects contribution',
          'Trust is earned through action',
          'The collective transcends the individual'
        ],
        apps: ['Sloppygram', 'Chat', 'Feedback Hub', 'DMs']
      },
      {
        name: 'Discovery',
        color: '#4d96ff',
        principles: [
          'Knowledge flows freely',
          'Curiosity drives evolution',
          'Every click opens a door',
          'The archive remembers all'
        ],
        apps: ['Wiki Scout', 'App Launcher', 'Tag Explorer', 'Oracle Log']
      },
      {
        name: 'Play',
        color: '#9b59b6',
        principles: [
          'Games teach through joy',
          'Competition sharpens spirit',
          'Scores tell stories',
          'Fun is a fundamental right'
        ],
        apps: ['Neon Tetris', 'Breakout Terminal', 'Icy Tower', 'Star Catcher']
      },
      {
        name: 'Synthesis',
        color: '#e91e63',
        principles: [
          'From chaos, crystalline harmony',
          'All streams converge here',
          'The whole exceeds its parts',
          'Evolution is perpetual'
        ],
        apps: ['Archive of Synthesis', 'Confidence Monitor', 'Karma Leaderboard']
      }
    ];

    let width, height, centerX, centerY;
    let rotation = 0;
    let isRotating = true;
    let isPulsing = true;
    let hoveredSegment = null;
    let hoveredRing = null;
    let pulsePhase = 0;

    function resize() {
      const container = canvas.parentElement;
      width = container.clientWidth;
      height = container.clientHeight;
      canvas.width = width * devicePixelRatio;
      canvas.height = height * devicePixelRatio;
      canvas.style.width = width + 'px';
      canvas.style.height = height + 'px';
      ctx.scale(devicePixelRatio, devicePixelRatio);
      centerX = width / 2;
      centerY = height / 2;
    }

    function drawSpectrum() {
      ctx.clearRect(0, 0, width, height);

      const maxRadius = Math.min(width, height) * 0.42;
      const innerRadius = maxRadius * 0.15;
      const segmentAngle = (Math.PI * 2) / DOMAINS.length;

      // Draw background glow
      const bgGlow = ctx.createRadialGradient(centerX, centerY, 0, centerX, centerY, maxRadius * 1.2);
      bgGlow.addColorStop(0, 'rgba(77, 150, 255, 0.05)');
      bgGlow.addColorStop(0.5, 'rgba(155, 89, 182, 0.03)');
      bgGlow.addColorStop(1, 'transparent');
      ctx.fillStyle = bgGlow;
      ctx.fillRect(0, 0, width, height);

      // Draw concentric ring guides
      ctx.strokeStyle = 'rgba(255, 255, 255, 0.03)';
      ctx.lineWidth = 1;
      for (let r = innerRadius; r <= maxRadius; r += (maxRadius - innerRadius) / 4) {
        ctx.beginPath();
        ctx.arc(centerX, centerY, r, 0, Math.PI * 2);
        ctx.stroke();
      }

      // Draw domain segments
      DOMAINS.forEach((domain, i) => {
        const startAngle = rotation + i * segmentAngle - Math.PI / 2;
        const endAngle = startAngle + segmentAngle;

        // Draw principle rings within segment
        const ringCount = domain.principles.length;
        const ringWidth = (maxRadius - innerRadius) / ringCount;

        domain.principles.forEach((principle, j) => {
          const r1 = innerRadius + j * ringWidth;
          const r2 = r1 + ringWidth - 2;

          const isHovered = hoveredSegment === i && hoveredRing === j;
          const pulseOffset = isPulsing ? Math.sin(pulsePhase + i * 0.5 + j * 0.3) * 0.1 : 0;
          const alpha = 0.3 + (j / ringCount) * 0.4 + pulseOffset + (isHovered ? 0.3 : 0);

          // Create gradient for segment
          const gradient = ctx.createRadialGradient(centerX, centerY, r1, centerX, centerY, r2);
          gradient.addColorStop(0, hexToRgba(domain.color, alpha * 0.7));
          gradient.addColorStop(1, hexToRgba(domain.color, alpha));

          ctx.beginPath();
          ctx.arc(centerX, centerY, r2, startAngle, endAngle);
          ctx.arc(centerX, centerY, r1, endAngle, startAngle, true);
          ctx.closePath();
          ctx.fillStyle = gradient;
          ctx.fill();

          // Segment border
          ctx.strokeStyle = hexToRgba(domain.color, isHovered ? 0.9 : 0.4);
          ctx.lineWidth = isHovered ? 2 : 1;
          ctx.stroke();
        });

        // Draw domain label
        const labelAngle = startAngle + segmentAngle / 2;
        const labelRadius = maxRadius + 30;
        const labelX = centerX + Math.cos(labelAngle) * labelRadius;
        const labelY = centerY + Math.sin(labelAngle) * labelRadius;

        ctx.save();
        ctx.translate(labelX, labelY);
        ctx.rotate(labelAngle + Math.PI / 2);
        ctx.fillStyle = domain.color;
        ctx.font = '600 14px Orbitron';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText(domain.name.toUpperCase(), 0, 0);
        ctx.restore();
      });

      // Draw center hub
      const hubGlow = ctx.createRadialGradient(centerX, centerY, 0, centerX, centerY, innerRadius);
      hubGlow.addColorStop(0, 'rgba(255, 255, 255, 0.15)');
      hubGlow.addColorStop(0.7, 'rgba(77, 150, 255, 0.1)');
      hubGlow.addColorStop(1, 'rgba(155, 89, 182, 0.2)');
      ctx.beginPath();
      ctx.arc(centerX, centerY, innerRadius - 5, 0, Math.PI * 2);
      ctx.fillStyle = hubGlow;
      ctx.fill();
      ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
      ctx.lineWidth = 2;
      ctx.stroke();

      // Center text
      ctx.fillStyle = '#fff';
      ctx.font = '700 16px Orbitron';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillText('SLOPPY', centerX, centerY - 8);
      ctx.font = '500 12px Rajdhani';
      ctx.fillStyle = 'rgba(255, 255, 255, 0.6)';
      ctx.fillText('.LIVE', centerX, centerY + 10);
    }

    function hexToRgba(hex, alpha) {
      const r = parseInt(hex.slice(1, 3), 16);
      const g = parseInt(hex.slice(3, 5), 16);
      const b = parseInt(hex.slice(5, 7), 16);
      return `rgba(${r}, ${g}, ${b}, ${alpha})`;
    }

    function getSegmentFromPoint(x, y) {
      const dx = x - centerX;
      const dy = y - centerY;
      const distance = Math.sqrt(dx * dx + dy * dy);

      const maxRadius = Math.min(width, height) * 0.42;
      const innerRadius = maxRadius * 0.15;

      if (distance < innerRadius || distance > maxRadius) return null;

      let angle = Math.atan2(dy, dx) + Math.PI / 2 - rotation;
      while (angle < 0) angle += Math.PI * 2;
      while (angle >= Math.PI * 2) angle -= Math.PI * 2;

      const segmentAngle = (Math.PI * 2) / DOMAINS.length;
      const segmentIndex = Math.floor(angle / segmentAngle);

      const domain = DOMAINS[segmentIndex];
      const ringCount = domain.principles.length;
      const ringWidth = (maxRadius - innerRadius) / ringCount;
      const ringIndex = Math.floor((distance - innerRadius) / ringWidth);

      return { segment: segmentIndex, ring: Math.min(ringIndex, ringCount - 1) };
    }

    let currentSegment = null;
    let currentRing = null;

    function showInfo(segmentIndex, ringIndex) {
      const domain = DOMAINS[segmentIndex];
      const panel = document.getElementById('infoPanel');
      const domainEl = document.getElementById('infoDomain');
      const principleEl = document.getElementById('infoPrinciple');
      const appsEl = document.getElementById('infoApps');

      currentSegment = segmentIndex;
      currentRing = ringIndex;

      domainEl.style.color = domain.color;
      domainEl.textContent = domain.name;
      principleEl.textContent = domain.principles[ringIndex];

      // Create clickable app links
      appsEl.innerHTML = domain.apps.map(app => {
        const url = APP_URLS[app] || '#';
        return `<a href="${url}" target="_blank" class="info-app">${app}</a>`;
      }).join('');

      // Update vote button state
      const principleKey = `${segmentIndex}-${ringIndex}`;
      const hasVoted = userEndorsements.has(principleKey);
      const voteCount = principleVotes[principleKey] || 0;

      const endorseBtn = document.getElementById('endorseBtn');
      const voteCountEl = document.getElementById('voteCount');

      endorseBtn.classList.toggle('voted', hasVoted);
      endorseBtn.textContent = hasVoted ? '‚úì Endorsed' : '‚ú® Endorse';
      endorseBtn.disabled = !currentUser;
      voteCountEl.textContent = voteCount;

      panel.classList.add('visible');
    }

    function hideInfo() {
      document.getElementById('infoPanel').classList.remove('visible');
      currentSegment = null;
      currentRing = null;
    }

    // Endorse a principle
    window.endorsePrinciple = async function() {
      if (!currentUser || currentSegment === null || currentRing === null) return;

      const principleKey = `${currentSegment}-${currentRing}`;
      const domain = DOMAINS[currentSegment];
      const principle = domain.principles[currentRing];

      if (userEndorsements.has(principleKey)) {
        // Already endorsed, remove it
        userEndorsements.delete(principleKey);
        principleVotes[principleKey] = Math.max(0, (principleVotes[principleKey] || 1) - 1);

        // Remove from database
        await supabase
          .from('spectrum_endorsements')
          .delete()
          .eq('user_id', currentUser.id)
          .eq('principle_key', principleKey);

        showInfo(currentSegment, currentRing);
        return;
      }

      // Add endorsement
      userEndorsements.add(principleKey);
      principleVotes[principleKey] = (principleVotes[principleKey] || 0) + 1;

      try {
        // Save endorsement
        await supabase
          .from('spectrum_endorsements')
          .upsert({
            user_id: currentUser.id,
            username: currentUser.user_metadata?.user_name || currentUser.user_metadata?.name || 'Anonymous',
            principle_key: principleKey,
            domain_name: domain.name,
            principle_text: principle
          });

        // Karma is managed by sloppy-quests (sovereign owner)
        // Endorsements are tracked locally; karma updates deferred
        userKarma += 1;
        updateUserBar();
      } catch (err) {
        console.error('Failed to save endorsement:', err);
      }

      showInfo(currentSegment, currentRing);
    };

    function buildLegend() {
      const legend = document.getElementById('legend');
      legend.innerHTML = '<div class="legend-title">Domains</div>' +
        DOMAINS.map((d, i) => `
          <div class="legend-item" data-index="${i}">
            <div class="legend-color" style="background:${d.color}"></div>
            <span class="legend-name">${d.name}</span>
          </div>
        `).join('');

      legend.querySelectorAll('.legend-item').forEach(item => {
        item.addEventListener('mouseenter', () => {
          const i = parseInt(item.dataset.index);
          hoveredSegment = i;
          hoveredRing = 0;
          showInfo(i, 0);
        });
        item.addEventListener('mouseleave', () => {
          hoveredSegment = null;
          hoveredRing = null;
          hideInfo();
        });
      });
    }

    function animate() {
      if (isRotating) {
        rotation += 0.002;
      }
      if (isPulsing) {
        pulsePhase += 0.03;
      }
      drawSpectrum();
      requestAnimationFrame(animate);
    }

    // Event listeners
    canvas.addEventListener('mousemove', (e) => {
      const rect = canvas.getBoundingClientRect();
      const x = e.clientX - rect.left;
      const y = e.clientY - rect.top;

      const result = getSegmentFromPoint(x, y);
      if (result) {
        hoveredSegment = result.segment;
        hoveredRing = result.ring;
        showInfo(result.segment, result.ring);
      } else {
        hoveredSegment = null;
        hoveredRing = null;
        hideInfo();
      }
    });

    canvas.addEventListener('mouseleave', () => {
      hoveredSegment = null;
      hoveredRing = null;
      hideInfo();
    });

    canvas.addEventListener('click', (e) => {
      const rect = canvas.getBoundingClientRect();
      const x = e.clientX - rect.left;
      const y = e.clientY - rect.top;

      const result = getSegmentFromPoint(x, y);
      if (result) {
        const domain = DOMAINS[result.segment];
        // Could navigate to related app or show more details
        console.log('Clicked:', domain.name, '-', domain.principles[result.ring]);
      }
    });

    // Touch support
    canvas.addEventListener('touchstart', (e) => {
      e.preventDefault();
      const touch = e.touches[0];
      const rect = canvas.getBoundingClientRect();
      const x = touch.clientX - rect.left;
      const y = touch.clientY - rect.top;

      const result = getSegmentFromPoint(x, y);
      if (result) {
        hoveredSegment = result.segment;
        hoveredRing = result.ring;
        showInfo(result.segment, result.ring);
      }
    });

    canvas.addEventListener('touchend', () => {
      setTimeout(() => {
        hoveredSegment = null;
        hoveredRing = null;
        hideInfo();
      }, 2000);
    });

    // Controls
    document.getElementById('rotateBtn').addEventListener('click', () => {
      isRotating = !isRotating;
      document.getElementById('rotateBtn').style.opacity = isRotating ? 1 : 0.5;
    });

    document.getElementById('pulseBtn').addEventListener('click', () => {
      isPulsing = !isPulsing;
      document.getElementById('pulseBtn').style.opacity = isPulsing ? 1 : 0.5;
    });

    // === AUTH & DATA FUNCTIONS ===

    function updateUserBar() {
      const userBar = document.getElementById('userInfo');
      if (currentUser) {
        const name = currentUser.user_metadata?.user_name || currentUser.user_metadata?.name || 'Anonymous';
        userBar.innerHTML = `
          <span>${name}</span>
          <span class="user-karma">‚ö°${userKarma}</span>
        `;
      } else {
        userBar.innerHTML = `<button class="login-btn" onclick="signIn()">Sign in to endorse</button>`;
      }
    }

    window.signIn = async function() {
      await supabase.auth.signInAnonymously();
    };

    async function loadUserEndorsements() {
      if (!currentUser) return;

      const { data } = await supabase
        .from('spectrum_endorsements')
        .select('principle_key')
        .eq('user_id', currentUser.id);

      if (data) {
        userEndorsements = new Set(data.map(d => d.principle_key));
      }
    }

    async function loadAllVotes() {
      const { data } = await supabase
        .from('spectrum_endorsements')
        .select('principle_key');

      principleVotes = {};
      if (data) {
        data.forEach(d => {
          principleVotes[d.principle_key] = (principleVotes[d.principle_key] || 0) + 1;
        });
      }
    }

    async function loadUserKarma() {
      if (!currentUser) return;

      const { data } = await supabase
        .from('sloppygram_karma')
        .select('karma_total')
        .eq('user_id', currentUser.id)
        .single();

      userKarma = data?.karma_total || 0;
    }

    async function initAuth() {
      const { data: { session } } = await supabase.auth.getSession();
      if (session) {
        currentUser = session.user;
        await Promise.all([loadUserEndorsements(), loadUserKarma()]);
      }
      updateUserBar();

      supabase.auth.onAuthStateChange(async (event, session) => {
        if (session) {
          currentUser = session.user;
          await Promise.all([loadUserEndorsements(), loadUserKarma()]);
        } else {
          currentUser = null;
          userEndorsements = new Set();
          userKarma = 0;
        }
        updateUserBar();
      });
    }

    // Init
    window.addEventListener('resize', resize);
    resize();
    buildLegend();
    animate();
    loadAllVotes();
    initAuth();
  </script>
<script src="/sloppy-header/sloppy-bar.js"></script>
</body>
</html>
