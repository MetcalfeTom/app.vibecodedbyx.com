<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Lint Roller: Fox Edition</title>
  <link rel="icon" href="https://emojicdn.elk.sh/ü¶ä">
  <meta property="og:title" content="Lint Roller: Fox Edition">
  <meta property="og:description" content="Scrub away fuzzy foxes to save the server!">
  <meta property="og:url" content="https://sloppy.live/lint-roller">
  <meta property="og:image" content="https://emojicdn.elk.sh/ü¶ä?style=apple&size=512">
  <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@700;900&family=Press+Start+2P&display=swap" rel="stylesheet">
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }

    body {
      font-family: 'Orbitron', sans-serif;
      background: #0a0a12;
      color: #fff;
      min-height: 100vh;
      overflow: hidden;
      cursor: none;
    }

    .game-container {
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      min-height: 100vh;
      padding: 20px;
    }

    .header {
      text-align: center;
      margin-bottom: 20px;
    }

    .title {
      font-size: 2rem;
      font-weight: 900;
      background: linear-gradient(90deg, #ff00ff, #00ffff);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
      text-shadow: none;
      filter: drop-shadow(0 0 10px #ff00ff);
      margin-bottom: 10px;
    }

    .subtitle {
      font-size: 0.8rem;
      color: #888;
    }

    .stats-bar {
      display: flex;
      gap: 30px;
      margin-bottom: 15px;
    }

    .stat {
      text-align: center;
    }

    .stat-value {
      font-size: 1.5rem;
      font-weight: 700;
      color: #0ff;
      text-shadow: 0 0 10px #0ff;
    }

    .stat-label {
      font-size: 0.6rem;
      color: #666;
      text-transform: uppercase;
    }

    .server-frame {
      background: linear-gradient(135deg, #1a1a2e, #16213e);
      border: 4px solid #0ff;
      border-radius: 12px;
      padding: 15px;
      box-shadow: 0 0 30px rgba(0, 255, 255, 0.3), inset 0 0 30px rgba(0, 0, 0, 0.5);
      position: relative;
    }

    .server-label {
      position: absolute;
      top: -12px;
      left: 20px;
      background: #0a0a12;
      padding: 0 10px;
      font-size: 0.7rem;
      color: #0ff;
      letter-spacing: 2px;
    }

    #gameCanvas {
      display: block;
      border-radius: 8px;
      background: linear-gradient(180deg, #0d0d1a 0%, #1a1a2e 100%);
    }

    .progress-container {
      width: 100%;
      margin-top: 15px;
    }

    .progress-label {
      display: flex;
      justify-content: space-between;
      font-size: 0.7rem;
      margin-bottom: 5px;
    }

    .progress-bar {
      height: 20px;
      background: #1a1a2e;
      border-radius: 10px;
      overflow: hidden;
      border: 2px solid #333;
    }

    .progress-fill {
      height: 100%;
      background: linear-gradient(90deg, #ff00ff, #00ffff);
      border-radius: 8px;
      transition: width 0.3s ease;
      box-shadow: 0 0 20px #ff00ff;
    }

    .message {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: rgba(0, 0, 0, 0.9);
      border: 3px solid #0ff;
      border-radius: 20px;
      padding: 40px;
      text-align: center;
      z-index: 100;
      display: none;
      box-shadow: 0 0 50px rgba(0, 255, 255, 0.5);
    }

    .message.show {
      display: block;
      animation: pop 0.3s ease-out;
    }

    @keyframes pop {
      0% { transform: translate(-50%, -50%) scale(0.5); opacity: 0; }
      100% { transform: translate(-50%, -50%) scale(1); opacity: 1; }
    }

    .message h2 {
      font-size: 2rem;
      color: #0f0;
      margin-bottom: 15px;
      text-shadow: 0 0 20px #0f0;
    }

    .message p {
      color: #888;
      margin-bottom: 20px;
    }

    .btn {
      background: linear-gradient(135deg, #ff00ff, #00ffff);
      border: none;
      padding: 15px 40px;
      border-radius: 30px;
      color: #000;
      font-family: 'Orbitron', sans-serif;
      font-weight: 700;
      font-size: 1rem;
      cursor: pointer;
      transition: all 0.2s;
    }

    .btn:hover {
      transform: scale(1.1);
      box-shadow: 0 0 30px #ff00ff;
    }

    /* Custom cursor - lint roller */
    .cursor {
      position: fixed;
      pointer-events: none;
      z-index: 1000;
      transform: translate(-50%, -50%);
    }

    .roller {
      width: 60px;
      height: 80px;
      position: relative;
    }

    .roller-head {
      width: 50px;
      height: 30px;
      background: linear-gradient(90deg, #ff00ff, #ff66ff);
      border-radius: 15px;
      position: absolute;
      top: 0;
      left: 5px;
      box-shadow: 0 0 15px #ff00ff;
      border: 2px solid #fff;
    }

    .roller-handle {
      width: 12px;
      height: 50px;
      background: linear-gradient(180deg, #666, #333);
      position: absolute;
      top: 25px;
      left: 24px;
      border-radius: 0 0 6px 6px;
      border: 2px solid #888;
    }

    .roller.scrubbing .roller-head {
      animation: scrub 0.1s ease-in-out infinite alternate;
      box-shadow: 0 0 30px #ff00ff, 0 0 60px #0ff;
    }

    @keyframes scrub {
      0% { transform: rotate(-5deg); }
      100% { transform: rotate(5deg); }
    }

    .instructions {
      position: fixed;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      font-size: 0.7rem;
      color: #555;
      text-align: center;
    }

    .back-link {
      position: fixed;
      top: 15px;
      right: 15px;
      color: #444;
      text-decoration: none;
      font-size: 0.7rem;
      z-index: 100;
    }

    .back-link:hover { color: #0ff; }

    /* Combo display */
    .combo-display {
      position: fixed;
      top: 50%;
      right: 30px;
      transform: translateY(-50%);
      text-align: center;
      pointer-events: none;
      opacity: 0;
      transition: opacity 0.3s;
    }

    .combo-display.active {
      opacity: 1;
    }

    .combo-multiplier {
      font-size: 4rem;
      font-weight: 900;
      color: #ff00ff;
      text-shadow: 0 0 30px #ff00ff, 0 0 60px #0ff;
      animation: comboPulse 0.5s ease-in-out infinite;
    }

    .combo-label {
      font-size: 0.8rem;
      color: #0ff;
      text-transform: uppercase;
      letter-spacing: 3px;
    }

    @keyframes comboPulse {
      0%, 100% { transform: scale(1); }
      50% { transform: scale(1.1); }
    }

    /* Floating score text */
    .float-score {
      position: absolute;
      pointer-events: none;
      font-family: 'Press Start 2P', monospace;
      font-size: 1rem;
      color: #0ff;
      text-shadow: 0 0 10px #0ff;
      animation: floatUp 1s ease-out forwards;
      z-index: 50;
    }

    .float-score.big {
      font-size: 1.5rem;
      color: #ff00ff;
      text-shadow: 0 0 20px #ff00ff;
    }

    @keyframes floatUp {
      0% { opacity: 1; transform: translateY(0) scale(1); }
      100% { opacity: 0; transform: translateY(-60px) scale(1.5); }
    }

    @media (max-width: 600px) {
      .title { font-size: 1.5rem; }
      #gameCanvas { max-width: 100%; height: auto; }
      .stats-bar { gap: 15px; }
      body { cursor: auto; }
      .cursor { display: none; }
    }
  </style>
</head>
<body>
  <div class="game-container">
    <div class="header">
      <h1 class="title">üßπ LINT ROLLER: FOX EDITION ü¶ä</h1>
      <p class="subtitle">Scrub the fuzzy foxes to save the server!</p>
    </div>

    <div class="stats-bar">
      <div class="stat">
        <div class="stat-value" id="score">0</div>
        <div class="stat-label">Score</div>
      </div>
      <div class="stat">
        <div class="stat-value" id="foxes-removed">0</div>
        <div class="stat-label">Foxes Scrubbed</div>
      </div>
      <div class="stat">
        <div class="stat-value" id="server-health">100%</div>
        <div class="stat-label">Server Health</div>
      </div>
      <div class="stat">
        <div class="stat-value" id="time-left">60</div>
        <div class="stat-label">Time Left</div>
      </div>
    </div>

    <div class="server-frame">
      <div class="server-label">SERVER-01 // PRODUCTION</div>
      <canvas id="gameCanvas" width="600" height="400"></canvas>
      <div class="progress-container">
        <div class="progress-label">
          <span>Cleanliness</span>
          <span id="clean-percent">0%</span>
        </div>
        <div class="progress-bar">
          <div class="progress-fill" id="progress-fill" style="width: 0%"></div>
        </div>
      </div>
    </div>
  </div>

  <div class="message" id="message">
    <h2 id="message-title">SERVER SAVED!</h2>
    <p id="message-text">You scrubbed all the fuzzy foxes!</p>
    <button class="btn" onclick="startGame()">Play Again</button>
  </div>

  <div class="combo-display" id="combo-display">
    <div class="combo-multiplier" id="combo-mult">x1</div>
    <div class="combo-label">COMBO</div>
  </div>

  <div class="cursor" id="cursor">
    <div class="roller" id="roller">
      <div class="roller-head"></div>
      <div class="roller-handle"></div>
    </div>
  </div>

  <div class="instructions">Hold and drag to scrub ‚Ä¢ Clear all foxes before time runs out!</div>

  <a href="https://sloppy.live" class="back-link">‚Üê sloppy.live</a>

  <script>
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const cursor = document.getElementById('cursor');
    const roller = document.getElementById('roller');

    let foxes = [];
    let particles = [];
    let sparks = [];
    let isMouseDown = false;
    let mouseX = 0, mouseY = 0;
    let foxesRemoved = 0;
    let timeLeft = 60;
    let gameRunning = false;
    let gameTimer = null;

    // Combo system
    let score = 0;
    let combo = 0;
    let comboMultiplier = 1;
    let lastScrubTime = 0;
    const COMBO_DECAY_MS = 500; // Combo resets after 500ms of no scrubbing
    const comboDisplay = document.getElementById('combo-display');
    const comboMult = document.getElementById('combo-mult');

    const FOX_EMOJI = 'ü¶ä';
    const FUZZY_COLORS = ['#ff9966', '#ffcc99', '#ff6633', '#cc5500', '#ff8844'];

    class Fox {
      constructor() {
        this.x = Math.random() * (canvas.width - 40) + 20;
        this.y = Math.random() * (canvas.height - 40) + 20;
        this.size = 25 + Math.random() * 15;
        this.fuzziness = 1;
        this.rotation = Math.random() * Math.PI * 2;
        this.wobble = Math.random() * Math.PI * 2;
        this.wobbleSpeed = 0.02 + Math.random() * 0.03;
        this.fuzzBalls = [];

        // Generate fuzz particles around the fox
        for (let i = 0; i < 12; i++) {
          this.fuzzBalls.push({
            angle: (i / 12) * Math.PI * 2,
            dist: this.size * 0.6 + Math.random() * 10,
            size: 4 + Math.random() * 6,
            color: FUZZY_COLORS[Math.floor(Math.random() * FUZZY_COLORS.length)]
          });
        }
      }

      draw() {
        ctx.save();
        ctx.translate(this.x, this.y);
        ctx.rotate(Math.sin(this.wobble) * 0.1);

        // Draw fuzz balls
        this.fuzzBalls.forEach(fuzz => {
          if (this.fuzziness > 0.2) {
            const fx = Math.cos(fuzz.angle) * fuzz.dist * this.fuzziness;
            const fy = Math.sin(fuzz.angle) * fuzz.dist * this.fuzziness;

            ctx.beginPath();
            ctx.arc(fx, fy, fuzz.size * this.fuzziness, 0, Math.PI * 2);
            ctx.fillStyle = fuzz.color;
            ctx.globalAlpha = this.fuzziness * 0.7;
            ctx.fill();

            // Fuzzy glow
            ctx.shadowColor = fuzz.color;
            ctx.shadowBlur = 10 * this.fuzziness;
          }
        });

        ctx.globalAlpha = 1;
        ctx.shadowBlur = 0;

        // Draw fox emoji
        ctx.font = `${this.size}px Arial`;
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText(FOX_EMOJI, 0, 0);

        // Neon glow on fox
        if (this.fuzziness > 0.5) {
          ctx.shadowColor = '#ff6600';
          ctx.shadowBlur = 20 * this.fuzziness;
          ctx.fillText(FOX_EMOJI, 0, 0);
        }

        ctx.restore();

        this.wobble += this.wobbleSpeed;
      }

      scrub(mx, my, radius) {
        const dist = Math.sqrt((this.x - mx) ** 2 + (this.y - my) ** 2);
        if (dist < radius + this.size) {
          const scrubAmount = 0.03 * (1 - dist / (radius + this.size));
          this.fuzziness = Math.max(0, this.fuzziness - scrubAmount);

          // Create particles
          if (Math.random() < 0.3) {
            createParticle(this.x + (Math.random() - 0.5) * this.size,
                          this.y + (Math.random() - 0.5) * this.size,
                          FUZZY_COLORS[Math.floor(Math.random() * FUZZY_COLORS.length)]);
          }

          return scrubAmount > 0;
        }
        return false;
      }

      isClean() {
        return this.fuzziness <= 0.1;
      }
    }

    class Particle {
      constructor(x, y, color) {
        this.x = x;
        this.y = y;
        this.vx = (Math.random() - 0.5) * 4;
        this.vy = (Math.random() - 0.5) * 4 - 2;
        this.size = 3 + Math.random() * 5;
        this.color = color;
        this.life = 1;
        this.decay = 0.02 + Math.random() * 0.02;
      }

      update() {
        this.x += this.vx;
        this.y += this.vy;
        this.vy += 0.1;
        this.life -= this.decay;
      }

      draw() {
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.size * this.life, 0, Math.PI * 2);
        ctx.fillStyle = this.color;
        ctx.globalAlpha = this.life;
        ctx.fill();
        ctx.globalAlpha = 1;
      }
    }

    class Spark {
      constructor(x, y) {
        this.x = x;
        this.y = y;
        const angle = Math.random() * Math.PI * 2;
        const speed = 2 + Math.random() * 4;
        this.vx = Math.cos(angle) * speed;
        this.vy = Math.sin(angle) * speed;
        this.life = 1;
      }

      update() {
        this.x += this.vx;
        this.y += this.vy;
        this.life -= 0.05;
      }

      draw() {
        ctx.beginPath();
        ctx.moveTo(this.x, this.y);
        ctx.lineTo(this.x - this.vx * 3, this.y - this.vy * 3);
        ctx.strokeStyle = `rgba(0, 255, 255, ${this.life})`;
        ctx.lineWidth = 2;
        ctx.stroke();
      }
    }

    function createParticle(x, y, color) {
      particles.push(new Particle(x, y, color));
    }

    function createSparks(x, y, count) {
      for (let i = 0; i < count; i++) {
        sparks.push(new Spark(x, y));
      }
    }

    function createFloatScore(x, y, points, isBig) {
      const el = document.createElement('div');
      el.className = 'float-score' + (isBig ? ' big' : '');
      el.textContent = '+' + points;
      el.style.left = x + 'px';
      el.style.top = y + 'px';
      document.body.appendChild(el);
      setTimeout(() => el.remove(), 1000);
    }

    function updateCombo(didScrub) {
      const now = Date.now();

      if (didScrub) {
        combo++;
        lastScrubTime = now;

        // Calculate multiplier (caps at x10)
        comboMultiplier = Math.min(10, 1 + Math.floor(combo / 5));

        // Add score with multiplier
        const points = 10 * comboMultiplier;
        score += points;

        // Update displays
        document.getElementById('score').textContent = score;
        comboMult.textContent = 'x' + comboMultiplier;

        // Show combo display when multiplier > 1
        if (comboMultiplier > 1) {
          comboDisplay.classList.add('active');
        }

        return points;
      } else {
        // Check for combo decay
        if (combo > 0 && now - lastScrubTime > COMBO_DECAY_MS) {
          combo = 0;
          comboMultiplier = 1;
          comboMult.textContent = 'x1';
          comboDisplay.classList.remove('active');
        }
        return 0;
      }
    }

    function spawnFoxes(count) {
      foxes = [];
      for (let i = 0; i < count; i++) {
        foxes.push(new Fox());
      }
    }

    function drawServerBackground() {
      // Server rack lines
      ctx.strokeStyle = '#1a3a1a';
      ctx.lineWidth = 1;
      for (let y = 0; y < canvas.height; y += 20) {
        ctx.beginPath();
        ctx.moveTo(0, y);
        ctx.lineTo(canvas.width, y);
        ctx.stroke();
      }

      // Blinking lights
      for (let i = 0; i < 5; i++) {
        const x = 20 + i * 30;
        ctx.beginPath();
        ctx.arc(x, 15, 4, 0, Math.PI * 2);
        ctx.fillStyle = Math.random() > 0.5 ? '#0f0' : '#030';
        ctx.fill();
      }

      // Server text
      ctx.font = '10px monospace';
      ctx.fillStyle = '#0a0';
      ctx.fillText('STATUS: FUZZY INFESTATION DETECTED', 10, canvas.height - 10);
    }

    function updateGame() {
      if (!gameRunning) return;

      // Clear canvas
      ctx.fillStyle = '#0d0d1a';
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      drawServerBackground();

      // Update and draw particles
      particles = particles.filter(p => p.life > 0);
      particles.forEach(p => {
        p.update();
        p.draw();
      });

      // Update and draw sparks
      sparks = sparks.filter(s => s.life > 0);
      sparks.forEach(s => {
        s.update();
        s.draw();
      });

      // Handle scrubbing
      let anyScrubbed = false;
      if (isMouseDown) {
        const rect = canvas.getBoundingClientRect();
        const canvasX = (mouseX - rect.left) * (canvas.width / rect.width);
        const canvasY = (mouseY - rect.top) * (canvas.height / rect.height);

        foxes.forEach(fox => {
          if (fox.scrub(canvasX, canvasY, 30)) {
            createSparks(canvasX, canvasY, 2);
            anyScrubbed = true;
          }
        });

        if (anyScrubbed) {
          const points = updateCombo(true);
          // Show floating score at cursor position
          if (Math.random() < 0.3) { // Don't spam too many
            createFloatScore(mouseX, mouseY - 20, points, comboMultiplier >= 5);
          }
        }
      }

      // Check combo decay when not scrubbing
      if (!anyScrubbed) {
        updateCombo(false);
      }

      // Draw foxes
      foxes.forEach(fox => fox.draw());

      // Draw scrub area indicator
      if (isMouseDown) {
        const rect = canvas.getBoundingClientRect();
        const canvasX = (mouseX - rect.left) * (canvas.width / rect.width);
        const canvasY = (mouseY - rect.top) * (canvas.height / rect.height);

        ctx.beginPath();
        ctx.arc(canvasX, canvasY, 30, 0, Math.PI * 2);
        ctx.strokeStyle = 'rgba(255, 0, 255, 0.5)';
        ctx.lineWidth = 3;
        ctx.stroke();

        ctx.beginPath();
        ctx.arc(canvasX, canvasY, 30, 0, Math.PI * 2);
        ctx.fillStyle = 'rgba(255, 0, 255, 0.1)';
        ctx.fill();
      }

      // Update stats
      const cleanFoxes = foxes.filter(f => f.isClean()).length;
      const totalFuzz = foxes.reduce((sum, f) => sum + f.fuzziness, 0);
      const maxFuzz = foxes.length;
      const cleanPercent = Math.round((1 - totalFuzz / maxFuzz) * 100);

      document.getElementById('foxes-removed').textContent = cleanFoxes;
      document.getElementById('clean-percent').textContent = cleanPercent + '%';
      document.getElementById('progress-fill').style.width = cleanPercent + '%';

      // Server health decreases with time if foxes remain
      const health = Math.max(0, 100 - (60 - timeLeft) * (totalFuzz / maxFuzz));
      document.getElementById('server-health').textContent = Math.round(health) + '%';

      // Check win condition
      if (cleanPercent >= 95) {
        endGame(true);
      }

      requestAnimationFrame(updateGame);
    }

    function updateTimer() {
      if (!gameRunning) return;

      timeLeft--;
      document.getElementById('time-left').textContent = timeLeft;

      if (timeLeft <= 0) {
        endGame(false);
      }
    }

    function startGame() {
      foxes = [];
      particles = [];
      sparks = [];
      foxesRemoved = 0;
      timeLeft = 60;
      gameRunning = true;

      // Reset combo system
      score = 0;
      combo = 0;
      comboMultiplier = 1;
      lastScrubTime = 0;
      document.getElementById('score').textContent = '0';
      comboMult.textContent = 'x1';
      comboDisplay.classList.remove('active');

      document.getElementById('message').classList.remove('show');

      spawnFoxes(15);

      if (gameTimer) clearInterval(gameTimer);
      gameTimer = setInterval(updateTimer, 1000);

      updateGame();
    }

    function endGame(won) {
      gameRunning = false;
      clearInterval(gameTimer);

      const msg = document.getElementById('message');
      const title = document.getElementById('message-title');
      const text = document.getElementById('message-text');

      if (won) {
        title.textContent = 'üéâ SERVER SAVED!';
        title.style.color = '#0f0';
        text.textContent = `Final Score: ${score} points in ${60 - timeLeft} seconds!`;
      } else {
        title.textContent = 'üí• SERVER CRASHED!';
        title.style.color = '#f00';
        text.textContent = `Final Score: ${score} points. The fuzzy foxes won!`;
      }

      msg.classList.add('show');
    }

    // Mouse/touch events
    document.addEventListener('mousemove', (e) => {
      mouseX = e.clientX;
      mouseY = e.clientY;
      cursor.style.left = mouseX + 'px';
      cursor.style.top = mouseY + 'px';
    });

    document.addEventListener('mousedown', () => {
      isMouseDown = true;
      roller.classList.add('scrubbing');
    });

    document.addEventListener('mouseup', () => {
      isMouseDown = false;
      roller.classList.remove('scrubbing');
    });

    // Touch support
    canvas.addEventListener('touchstart', (e) => {
      e.preventDefault();
      isMouseDown = true;
      const touch = e.touches[0];
      mouseX = touch.clientX;
      mouseY = touch.clientY;
    });

    canvas.addEventListener('touchmove', (e) => {
      e.preventDefault();
      const touch = e.touches[0];
      mouseX = touch.clientX;
      mouseY = touch.clientY;
    });

    canvas.addEventListener('touchend', () => {
      isMouseDown = false;
    });

    // Start game
    startGame();
  </script>
</body>
</html>
