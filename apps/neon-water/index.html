<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
  <title>NEON WATER</title>
  <link rel="icon" href="https://emojicdn.elk.sh/ðŸŒŠ">
  <meta property="og:title" content="NEON WATER">
  <meta property="og:description" content="Splash and create waves in a neon water simulation">
  <meta property="og:image" content="https://app.sloppy.live/neon-water/og-image.png">
  <meta property="og:url" content="https://app.sloppy.live/neon-water">
  <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700&display=swap" rel="stylesheet">
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }

    body {
      background: #000;
      min-height: 100vh;
      overflow: hidden;
      font-family: 'Orbitron', sans-serif;
      display: flex;
      flex-direction: column;
    }

    #canvas {
      display: block;
      width: 100%;
      height: 100%;
      position: fixed;
      top: 0;
      left: 0;
      cursor: crosshair;
    }

    .ui {
      position: fixed;
      top: 15px;
      left: 15px;
      z-index: 10;
      color: #0ff;
      font-size: 0.9em;
      text-shadow: 0 0 10px #0ff;
    }

    .ui h1 {
      font-size: 1.5em;
      margin-bottom: 5px;
      letter-spacing: 3px;
    }

    .ui p {
      font-size: 0.7em;
      color: #088;
      margin-bottom: 15px;
    }

    .controls {
      display: flex;
      flex-direction: column;
      gap: 10px;
      background: rgba(0,0,0,0.7);
      padding: 15px;
      border-radius: 10px;
      border: 1px solid #0ff;
    }

    .control-row {
      display: flex;
      align-items: center;
      gap: 10px;
    }

    .control-row label {
      font-size: 0.7em;
      min-width: 80px;
      color: #0aa;
    }

    .control-row input[type="range"] {
      flex: 1;
      accent-color: #0ff;
    }

    .control-row span {
      font-size: 0.7em;
      min-width: 40px;
      text-align: right;
    }

    .buttons {
      display: flex;
      gap: 8px;
      flex-wrap: wrap;
    }

    button {
      background: transparent;
      border: 1px solid #0ff;
      color: #0ff;
      font-family: inherit;
      font-size: 0.7em;
      padding: 8px 12px;
      cursor: pointer;
      border-radius: 4px;
      transition: all 0.2s;
    }

    button:hover {
      background: #0ff;
      color: #000;
    }

    button.active {
      background: #0ff;
      color: #000;
    }

    .color-btn {
      width: 25px;
      height: 25px;
      border-radius: 50%;
      padding: 0;
    }

    .stats {
      position: fixed;
      bottom: 15px;
      left: 15px;
      color: #066;
      font-size: 0.65em;
      z-index: 10;
    }

    .backlink {
      position: fixed;
      bottom: 10px;
      right: 10px;
      color: #333;
      text-decoration: none;
      font-size: 0.7em;
      z-index: 10;
    }

    .hint {
      position: fixed;
      bottom: 50%;
      left: 50%;
      transform: translate(-50%, 50%);
      color: #044;
      font-size: 1.2em;
      pointer-events: none;
      opacity: 0.5;
      text-align: center;
      z-index: 5;
    }

    @media (max-width: 600px) {
      .controls { padding: 10px; }
      .ui h1 { font-size: 1.2em; }
    }
  </style>
</head>
<body>
  <canvas id="canvas"></canvas>

  <div class="ui">
    <h1>ðŸŒŠ NEON WATER</h1>
    <p>Click & drag to splash</p>

    <div class="controls">
      <div class="control-row">
        <label>Tension</label>
        <input type="range" id="tension" min="0.01" max="0.1" step="0.005" value="0.025">
        <span id="tensionVal">0.025</span>
      </div>
      <div class="control-row">
        <label>Dampening</label>
        <input type="range" id="dampening" min="0.9" max="0.999" step="0.001" value="0.975">
        <span id="dampeningVal">0.975</span>
      </div>
      <div class="control-row">
        <label>Spread</label>
        <input type="range" id="spread" min="0.1" max="0.5" step="0.01" value="0.25">
        <span id="spreadVal">0.25</span>
      </div>
      <div class="control-row">
        <label>Splash Force</label>
        <input type="range" id="splashForce" min="50" max="500" step="10" value="200">
        <span id="splashForceVal">200</span>
      </div>

      <div class="buttons">
        <button onclick="createRipple()">Ripple</button>
        <button onclick="createWave()">Wave</button>
        <button onclick="createStorm()">Storm</button>
        <button onclick="resetWater()">Calm</button>
      </div>

      <div class="control-row">
        <label>Color</label>
        <div class="buttons">
          <button class="color-btn active" style="background:#0ff;border-color:#0ff" onclick="setColor('#0ff', this)"></button>
          <button class="color-btn" style="background:#f0f;border-color:#f0f" onclick="setColor('#f0f', this)"></button>
          <button class="color-btn" style="background:#0f0;border-color:#0f0" onclick="setColor('#0f0', this)"></button>
          <button class="color-btn" style="background:#f80;border-color:#f80" onclick="setColor('#f80', this)"></button>
          <button class="color-btn" style="background:#80f;border-color:#80f" onclick="setColor('#80f', this)"></button>
        </div>
      </div>
    </div>
  </div>

  <div class="hint" id="hint">Click anywhere to splash!</div>

  <div class="stats" id="stats"></div>

  <a href="https://sloppy.live" class="backlink">sloppy.live</a>

  <script>
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');

    let W, H, waterY, columns, columnWidth;
    let waterColor = '#0ff';

    // Physics parameters
    let tension = 0.025;
    let dampening = 0.975;
    let spread = 0.25;
    let splashForce = 200;

    // Column data
    let heights = [];
    let velocities = [];
    let targetHeight;

    // Particles
    let droplets = [];

    function resize() {
      W = canvas.width = window.innerWidth;
      H = canvas.height = window.innerHeight;
      waterY = H * 0.5;
      targetHeight = waterY;

      // More columns for smoother water
      columns = Math.ceil(W / 4);
      columnWidth = W / columns;

      // Initialize or resize arrays
      const newHeights = [];
      const newVelocities = [];

      for (let i = 0; i < columns; i++) {
        newHeights[i] = heights[i] || waterY;
        newVelocities[i] = velocities[i] || 0;
      }

      heights = newHeights;
      velocities = newVelocities;
    }
    resize();
    window.addEventListener('resize', resize);

    // Update controls
    document.getElementById('tension').oninput = e => {
      tension = parseFloat(e.target.value);
      document.getElementById('tensionVal').textContent = tension.toFixed(3);
    };
    document.getElementById('dampening').oninput = e => {
      dampening = parseFloat(e.target.value);
      document.getElementById('dampeningVal').textContent = dampening.toFixed(3);
    };
    document.getElementById('spread').oninput = e => {
      spread = parseFloat(e.target.value);
      document.getElementById('spreadVal').textContent = spread.toFixed(2);
    };
    document.getElementById('splashForce').oninput = e => {
      splashForce = parseFloat(e.target.value);
      document.getElementById('splashForceVal').textContent = splashForce;
    };

    function setColor(color, btn) {
      waterColor = color;
      document.querySelectorAll('.color-btn').forEach(b => b.classList.remove('active'));
      btn.classList.add('active');
    }

    function splash(x, force) {
      const col = Math.floor(x / columnWidth);
      if (col >= 0 && col < columns) {
        velocities[col] = force;

        // Create droplets
        const numDroplets = Math.abs(force) / 20;
        for (let i = 0; i < numDroplets; i++) {
          droplets.push({
            x: x + (Math.random() - 0.5) * 30,
            y: heights[col],
            vx: (Math.random() - 0.5) * 5,
            vy: -Math.abs(force) * 0.03 * Math.random() - 2,
            radius: 2 + Math.random() * 4,
            life: 1
          });
        }
      }
    }

    function createRipple() {
      const x = W / 2;
      splash(x, -splashForce);
    }

    function createWave() {
      for (let i = 0; i < columns; i++) {
        velocities[i] = Math.sin(i * 0.1) * splashForce * 0.5;
      }
    }

    function createStorm() {
      for (let i = 0; i < 20; i++) {
        setTimeout(() => {
          splash(Math.random() * W, (Math.random() - 0.5) * splashForce * 2);
        }, i * 100);
      }
    }

    function resetWater() {
      for (let i = 0; i < columns; i++) {
        heights[i] = targetHeight;
        velocities[i] = 0;
      }
      droplets = [];
    }

    function updateWater() {
      // Update velocities based on spring physics
      for (let i = 0; i < columns; i++) {
        const diff = targetHeight - heights[i];
        velocities[i] += tension * diff;
        velocities[i] *= dampening;
      }

      // Update heights
      for (let i = 0; i < columns; i++) {
        heights[i] += velocities[i];
      }

      // Propagate waves to neighbors
      const leftDeltas = [];
      const rightDeltas = [];

      for (let i = 0; i < columns; i++) {
        leftDeltas[i] = 0;
        rightDeltas[i] = 0;
      }

      // Multiple passes for smoother spreading
      for (let pass = 0; pass < 4; pass++) {
        for (let i = 0; i < columns; i++) {
          if (i > 0) {
            leftDeltas[i] = spread * (heights[i] - heights[i - 1]);
            velocities[i - 1] += leftDeltas[i];
          }
          if (i < columns - 1) {
            rightDeltas[i] = spread * (heights[i] - heights[i + 1]);
            velocities[i + 1] += rightDeltas[i];
          }
        }

        for (let i = 0; i < columns; i++) {
          if (i > 0) heights[i - 1] += leftDeltas[i];
          if (i < columns - 1) heights[i + 1] += rightDeltas[i];
        }
      }

      // Update droplets
      droplets.forEach(d => {
        d.vy += 0.3; // Gravity
        d.x += d.vx;
        d.y += d.vy;
        d.life -= 0.015;

        // Splash back into water
        const col = Math.floor(d.x / columnWidth);
        if (col >= 0 && col < columns && d.y > heights[col] && d.vy > 0) {
          velocities[col] += d.vy * 0.5;
          d.life = 0;
        }
      });

      droplets = droplets.filter(d => d.life > 0 && d.y < H + 50);
    }

    function drawWater() {
      ctx.fillStyle = '#000';
      ctx.fillRect(0, 0, W, H);

      // Parse color for gradients
      const rgb = hexToRgb(waterColor);

      // Draw sky reflection
      const skyGrad = ctx.createLinearGradient(0, 0, 0, waterY);
      skyGrad.addColorStop(0, '#000');
      skyGrad.addColorStop(1, `rgba(${rgb.r}, ${rgb.g}, ${rgb.b}, 0.1)`);
      ctx.fillStyle = skyGrad;
      ctx.fillRect(0, 0, W, waterY);

      // Draw water body
      ctx.beginPath();
      ctx.moveTo(0, H);

      for (let i = 0; i < columns; i++) {
        ctx.lineTo(i * columnWidth, heights[i]);
      }

      ctx.lineTo(W, heights[columns - 1]);
      ctx.lineTo(W, H);
      ctx.closePath();

      // Water gradient
      const waterGrad = ctx.createLinearGradient(0, waterY - 100, 0, H);
      waterGrad.addColorStop(0, `rgba(${rgb.r}, ${rgb.g}, ${rgb.b}, 0.6)`);
      waterGrad.addColorStop(0.5, `rgba(${rgb.r * 0.5}, ${rgb.g * 0.5}, ${rgb.b * 0.5}, 0.8)`);
      waterGrad.addColorStop(1, `rgba(${rgb.r * 0.2}, ${rgb.g * 0.2}, ${rgb.b * 0.2}, 0.95)`);
      ctx.fillStyle = waterGrad;
      ctx.fill();

      // Draw glowing surface line
      ctx.beginPath();
      ctx.moveTo(0, heights[0]);

      for (let i = 1; i < columns; i++) {
        const xc = (i - 0.5) * columnWidth;
        const yc = (heights[i - 1] + heights[i]) / 2;
        ctx.quadraticCurveTo((i - 1) * columnWidth, heights[i - 1], xc, yc);
      }
      ctx.lineTo(W, heights[columns - 1]);

      ctx.strokeStyle = waterColor;
      ctx.lineWidth = 3;
      ctx.shadowColor = waterColor;
      ctx.shadowBlur = 20;
      ctx.stroke();

      // Second glow pass
      ctx.lineWidth = 1;
      ctx.shadowBlur = 40;
      ctx.stroke();

      ctx.shadowBlur = 0;

      // Draw highlights on waves
      ctx.strokeStyle = `rgba(255, 255, 255, 0.3)`;
      ctx.lineWidth = 1;
      ctx.beginPath();

      for (let i = 1; i < columns - 1; i++) {
        const slope = heights[i + 1] - heights[i - 1];
        if (slope < -2) { // Rising wave
          ctx.moveTo(i * columnWidth, heights[i] - 2);
          ctx.lineTo((i + 1) * columnWidth, heights[i + 1] - 2);
        }
      }
      ctx.stroke();

      // Draw caustics (light patterns underwater)
      ctx.globalAlpha = 0.1;
      for (let i = 0; i < columns; i += 3) {
        const x = i * columnWidth;
        const y = heights[i];
        const distort = velocities[i] * 2;

        ctx.beginPath();
        ctx.moveTo(x, y);
        ctx.lineTo(x + distort + 20, H);
        ctx.lineTo(x + distort - 20, H);
        ctx.closePath();
        ctx.fillStyle = waterColor;
        ctx.fill();
      }
      ctx.globalAlpha = 1;

      // Draw droplets
      droplets.forEach(d => {
        ctx.beginPath();
        ctx.arc(d.x, d.y, d.radius * d.life, 0, Math.PI * 2);
        ctx.fillStyle = waterColor;
        ctx.shadowColor = waterColor;
        ctx.shadowBlur = 10;
        ctx.globalAlpha = d.life;
        ctx.fill();
      });

      ctx.globalAlpha = 1;
      ctx.shadowBlur = 0;

      // Draw ripple rings on surface
      for (let i = 2; i < columns - 2; i++) {
        const vel = Math.abs(velocities[i]);
        if (vel > 1) {
          const x = i * columnWidth;
          const y = heights[i];
          ctx.strokeStyle = `rgba(${rgb.r}, ${rgb.g}, ${rgb.b}, ${Math.min(vel / 10, 0.5)})`;
          ctx.lineWidth = 1;
          ctx.beginPath();
          ctx.ellipse(x, y, vel * 2, vel * 0.5, 0, 0, Math.PI * 2);
          ctx.stroke();
        }
      }
    }

    function hexToRgb(hex) {
      const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
      if (result) {
        return {
          r: parseInt(result[1], 16),
          g: parseInt(result[2], 16),
          b: parseInt(result[3], 16)
        };
      }
      // Handle shorthand hex
      const short = /^#?([a-f\d])([a-f\d])([a-f\d])$/i.exec(hex);
      if (short) {
        return {
          r: parseInt(short[1] + short[1], 16),
          g: parseInt(short[2] + short[2], 16),
          b: parseInt(short[3] + short[3], 16)
        };
      }
      return { r: 0, g: 255, b: 255 };
    }

    // Input handling
    let isPointerDown = false;
    let lastX = 0;
    let hintHidden = false;

    function handlePointerDown(e) {
      isPointerDown = true;
      const x = e.clientX || e.touches[0].clientX;
      const y = e.clientY || e.touches[0].clientY;
      lastX = x;

      // Only splash if clicking in water area
      if (y > waterY - 100) {
        splash(x, -splashForce);
      }

      if (!hintHidden) {
        document.getElementById('hint').style.opacity = '0';
        hintHidden = true;
      }
    }

    function handlePointerMove(e) {
      if (!isPointerDown) return;

      const x = e.clientX || (e.touches && e.touches[0].clientX);
      const y = e.clientY || (e.touches && e.touches[0].clientY);

      if (x === undefined) return;

      const dx = x - lastX;
      const force = -Math.sign(dx) * Math.min(Math.abs(dx) * 3, splashForce);

      if (y > waterY - 100) {
        splash(x, force);
      }

      lastX = x;
    }

    function handlePointerUp() {
      isPointerDown = false;
    }

    canvas.addEventListener('mousedown', handlePointerDown);
    canvas.addEventListener('mousemove', handlePointerMove);
    canvas.addEventListener('mouseup', handlePointerUp);
    canvas.addEventListener('mouseleave', handlePointerUp);

    canvas.addEventListener('touchstart', e => {
      e.preventDefault();
      handlePointerDown(e);
    });
    canvas.addEventListener('touchmove', e => {
      e.preventDefault();
      handlePointerMove(e);
    });
    canvas.addEventListener('touchend', handlePointerUp);

    // Animation loop
    let fps = 0;
    let frames = 0;
    let lastFpsTime = performance.now();

    function animate() {
      updateWater();
      drawWater();

      // FPS counter
      frames++;
      const now = performance.now();
      if (now - lastFpsTime >= 1000) {
        fps = frames;
        frames = 0;
        lastFpsTime = now;
      }

      document.getElementById('stats').textContent =
        `${columns} columns | ${droplets.length} droplets | ${fps} fps`;

      requestAnimationFrame(animate);
    }

    animate();

    // Initial gentle waves
    setTimeout(() => {
      for (let i = 0; i < columns; i++) {
        heights[i] = waterY + Math.sin(i * 0.05) * 10;
      }
    }, 500);
  </script>
<script src="/sloppy-header/sloppy-bar.js"></script>
</body>
</html>
