<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Finance Shorts Storyboarder</title>
  <link rel="icon" href="https://emojicdn.elk.sh/üìà">
  <meta property="og:title" content="Finance Shorts Storyboarder">
  <meta property="og:description" content="Create viral finance shorts with neon charts!">
  <meta property="og:url" content="https://app.sloppy.live/finance-shorts">
  <meta property="og:image" content="https://emojicdn.elk.sh/üìà?style=apple&size=512">
  <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&family=Space+Mono:wght@400;700&display=swap" rel="stylesheet">
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }

    body {
      font-family: 'Space Mono', monospace;
      background: linear-gradient(135deg, #0a0a12 0%, #1a1a2e 100%);
      color: #fff;
      min-height: 100vh;
    }

    .app-container {
      display: flex;
      min-height: 100vh;
    }

    /* Left Panel - Controls */
    .controls-panel {
      width: 320px;
      background: rgba(0, 0, 0, 0.5);
      border-right: 1px solid #333;
      padding: 20px;
      overflow-y: auto;
      flex-shrink: 0;
    }

    .logo {
      font-family: 'Orbitron', sans-serif;
      font-size: 1.2rem;
      font-weight: 900;
      background: linear-gradient(90deg, #00ff88, #00ccff);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
      margin-bottom: 5px;
    }

    .tagline {
      font-size: 0.7rem;
      color: #666;
      margin-bottom: 25px;
    }

    .section {
      margin-bottom: 25px;
    }

    .section-title {
      font-family: 'Orbitron', sans-serif;
      font-size: 0.75rem;
      color: #00ff88;
      letter-spacing: 2px;
      margin-bottom: 12px;
      text-transform: uppercase;
    }

    .input-group {
      margin-bottom: 12px;
    }

    .input-label {
      font-size: 0.7rem;
      color: #888;
      margin-bottom: 5px;
      display: block;
    }

    input, textarea, select {
      width: 100%;
      background: #1a1a2e;
      border: 1px solid #333;
      border-radius: 8px;
      padding: 10px 12px;
      color: #fff;
      font-family: 'Space Mono', monospace;
      font-size: 0.85rem;
      transition: border-color 0.2s;
    }

    input:focus, textarea:focus, select:focus {
      outline: none;
      border-color: #00ff88;
    }

    textarea {
      min-height: 80px;
      resize: vertical;
    }

    .btn {
      width: 100%;
      padding: 12px;
      border: none;
      border-radius: 8px;
      font-family: 'Orbitron', sans-serif;
      font-weight: 700;
      font-size: 0.8rem;
      cursor: pointer;
      transition: all 0.2s;
      letter-spacing: 1px;
    }

    .btn-primary {
      background: linear-gradient(135deg, #00ff88, #00ccff);
      color: #000;
    }

    .btn-primary:hover {
      transform: translateY(-2px);
      box-shadow: 0 5px 20px rgba(0, 255, 136, 0.3);
    }

    .btn-secondary {
      background: #1a1a2e;
      color: #00ff88;
      border: 1px solid #00ff88;
      margin-top: 8px;
    }

    .btn-secondary:hover {
      background: rgba(0, 255, 136, 0.1);
    }

    .chart-types {
      display: grid;
      grid-template-columns: repeat(3, 1fr);
      gap: 8px;
    }

    .chart-type-btn {
      padding: 12px 8px;
      background: #1a1a2e;
      border: 1px solid #333;
      border-radius: 8px;
      color: #888;
      font-size: 1.2rem;
      cursor: pointer;
      transition: all 0.2s;
      text-align: center;
    }

    .chart-type-btn:hover {
      border-color: #666;
    }

    .chart-type-btn.active {
      border-color: #00ff88;
      color: #fff;
      background: rgba(0, 255, 136, 0.1);
    }

    .chart-type-btn span {
      display: block;
      font-size: 0.6rem;
      margin-top: 4px;
    }

    /* Center - Preview */
    .preview-panel {
      flex: 1;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      padding: 20px;
      background: #0d0d1a;
    }

    .phone-frame {
      width: 270px;
      height: 480px;
      background: #000;
      border-radius: 24px;
      padding: 8px;
      box-shadow: 0 0 50px rgba(0, 255, 136, 0.2);
      position: relative;
    }

    .phone-notch {
      position: absolute;
      top: 8px;
      left: 50%;
      transform: translateX(-50%);
      width: 80px;
      height: 20px;
      background: #000;
      border-radius: 0 0 12px 12px;
      z-index: 10;
    }

    .phone-screen {
      width: 100%;
      height: 100%;
      border-radius: 18px;
      overflow: hidden;
      position: relative;
    }

    #previewCanvas {
      width: 100%;
      height: 100%;
      display: block;
    }

    .frame-nav {
      display: flex;
      align-items: center;
      gap: 15px;
      margin-top: 20px;
    }

    .nav-btn {
      width: 40px;
      height: 40px;
      border-radius: 50%;
      background: #1a1a2e;
      border: 1px solid #333;
      color: #888;
      font-size: 1.2rem;
      cursor: pointer;
      transition: all 0.2s;
    }

    .nav-btn:hover {
      border-color: #00ff88;
      color: #00ff88;
    }

    .frame-indicator {
      font-family: 'Orbitron', sans-serif;
      font-size: 0.9rem;
      color: #666;
    }

    .frame-indicator span {
      color: #00ff88;
    }

    /* Right Panel - Timeline */
    .timeline-panel {
      width: 200px;
      background: rgba(0, 0, 0, 0.5);
      border-left: 1px solid #333;
      padding: 20px;
      overflow-y: auto;
      flex-shrink: 0;
    }

    .timeline-title {
      font-family: 'Orbitron', sans-serif;
      font-size: 0.75rem;
      color: #00ccff;
      letter-spacing: 2px;
      margin-bottom: 15px;
    }

    .frame-list {
      display: flex;
      flex-direction: column;
      gap: 10px;
    }

    .frame-thumb {
      aspect-ratio: 9/16;
      background: #1a1a2e;
      border: 2px solid #333;
      border-radius: 8px;
      cursor: pointer;
      transition: all 0.2s;
      position: relative;
      overflow: hidden;
    }

    .frame-thumb:hover {
      border-color: #666;
    }

    .frame-thumb.active {
      border-color: #00ff88;
      box-shadow: 0 0 15px rgba(0, 255, 136, 0.3);
    }

    .frame-thumb canvas {
      width: 100%;
      height: 100%;
    }

    .frame-number {
      position: absolute;
      top: 5px;
      left: 5px;
      background: rgba(0, 0, 0, 0.7);
      color: #00ff88;
      font-size: 0.6rem;
      padding: 2px 6px;
      border-radius: 4px;
    }

    .add-frame-btn {
      width: 100%;
      aspect-ratio: 9/16;
      background: transparent;
      border: 2px dashed #333;
      border-radius: 8px;
      color: #444;
      font-size: 2rem;
      cursor: pointer;
      transition: all 0.2s;
    }

    .add-frame-btn:hover {
      border-color: #00ff88;
      color: #00ff88;
    }

    .back-link {
      position: fixed;
      bottom: 15px;
      right: 15px;
      color: #444;
      text-decoration: none;
      font-size: 0.7rem;
      z-index: 100;
    }

    .back-link:hover { color: #0ff; }

    .generating {
      opacity: 0.6;
      pointer-events: none;
    }

    @media (max-width: 900px) {
      .app-container {
        flex-direction: column;
      }
      .controls-panel, .timeline-panel {
        width: 100%;
        border: none;
        border-bottom: 1px solid #333;
      }
      .timeline-panel {
        order: -1;
        border-bottom: 1px solid #333;
        border-left: none;
      }
      .frame-list {
        flex-direction: row;
        overflow-x: auto;
        padding-bottom: 10px;
      }
      .frame-thumb, .add-frame-btn {
        width: 60px;
        flex-shrink: 0;
      }
      .phone-frame {
        width: 220px;
        height: 390px;
      }
    }
  </style>
</head>
<body>
  <div class="app-container">
    <!-- Left Controls -->
    <div class="controls-panel">
      <div class="logo">FINANCE SHORTS</div>
      <div class="tagline">9:16 Storyboarder</div>

      <div class="section">
        <div class="section-title">Topic</div>
        <div class="input-group">
          <input type="text" id="topicInput" placeholder="e.g., Bitcoin price prediction" value="S&P 500 Analysis">
        </div>
        <button class="btn btn-primary" id="generateBtn">‚ö° GENERATE SCRIPT</button>
      </div>

      <div class="section">
        <div class="section-title">Frame Settings</div>
        <div class="input-group">
          <label class="input-label">Headline</label>
          <input type="text" id="headlineInput" placeholder="Chart headline">
        </div>
        <div class="input-group">
          <label class="input-label">Script (voiceover)</label>
          <textarea id="scriptInput" placeholder="What you'll say..."></textarea>
        </div>
      </div>

      <div class="section">
        <div class="section-title">Chart Type</div>
        <div class="chart-types">
          <button class="chart-type-btn active" data-chart="line">üìà<span>Line</span></button>
          <button class="chart-type-btn" data-chart="bar">üìä<span>Bar</span></button>
          <button class="chart-type-btn" data-chart="candle">üïØÔ∏è<span>Candle</span></button>
          <button class="chart-type-btn" data-chart="pie">ü•ß<span>Pie</span></button>
          <button class="chart-type-btn" data-chart="area">üìâ<span>Area</span></button>
          <button class="chart-type-btn" data-chart="stats">üî¢<span>Stats</span></button>
        </div>
      </div>

      <div class="section">
        <div class="section-title">Chart Color</div>
        <div class="chart-types">
          <button class="chart-type-btn active" data-color="#00ff88" style="color:#00ff88">‚óè<span>Green</span></button>
          <button class="chart-type-btn" data-color="#ff3366" style="color:#ff3366">‚óè<span>Red</span></button>
          <button class="chart-type-btn" data-color="#00ccff" style="color:#00ccff">‚óè<span>Cyan</span></button>
          <button class="chart-type-btn" data-color="#ffcc00" style="color:#ffcc00">‚óè<span>Gold</span></button>
          <button class="chart-type-btn" data-color="#ff00ff" style="color:#ff00ff">‚óè<span>Pink</span></button>
          <button class="chart-type-btn" data-color="#ffffff" style="color:#ffffff">‚óè<span>White</span></button>
        </div>
      </div>

      <button class="btn btn-secondary" id="deleteFrameBtn">üóëÔ∏è DELETE FRAME</button>
    </div>

    <!-- Center Preview -->
    <div class="preview-panel">
      <div class="phone-frame">
        <div class="phone-notch"></div>
        <div class="phone-screen">
          <canvas id="previewCanvas" width="270" height="480"></canvas>
        </div>
      </div>
      <div class="frame-nav">
        <button class="nav-btn" id="prevBtn">‚óÄ</button>
        <div class="frame-indicator">Frame <span id="currentFrame">1</span> / <span id="totalFrames">1</span></div>
        <button class="nav-btn" id="nextBtn">‚ñ∂</button>
      </div>
    </div>

    <!-- Right Timeline -->
    <div class="timeline-panel">
      <div class="timeline-title">STORYBOARD</div>
      <div class="frame-list" id="frameList">
        <!-- Frames added dynamically -->
      </div>
      <button class="add-frame-btn" id="addFrameBtn">+</button>
    </div>
  </div>

  <a href="https://sloppy.live" class="back-link">‚Üê sloppy.live</a>

  <script>
    const previewCanvas = document.getElementById('previewCanvas');
    const previewCtx = previewCanvas.getContext('2d');

    // Set actual canvas resolution
    previewCanvas.width = 1080;
    previewCanvas.height = 1920;

    let frames = [];
    let currentFrameIndex = 0;

    // Default frame template
    function createFrame() {
      return {
        headline: 'MARKET UPDATE',
        script: 'Here\'s what you need to know...',
        chartType: 'line',
        chartColor: '#00ff88',
        data: generateRandomData()
      };
    }

    function generateRandomData() {
      const data = [];
      let value = 50 + Math.random() * 50;
      for (let i = 0; i < 12; i++) {
        value += (Math.random() - 0.45) * 15;
        value = Math.max(10, Math.min(100, value));
        data.push(value);
      }
      return data;
    }

    // Initialize with one frame
    frames.push(createFrame());

    // Draw frame to canvas
    function drawFrame(ctx, frame, width, height) {
      // Background gradient
      const bgGrad = ctx.createLinearGradient(0, 0, 0, height);
      bgGrad.addColorStop(0, '#0a0a12');
      bgGrad.addColorStop(0.5, '#0d1a1a');
      bgGrad.addColorStop(1, '#0a0a12');
      ctx.fillStyle = bgGrad;
      ctx.fillRect(0, 0, width, height);

      // Grid pattern
      ctx.strokeStyle = 'rgba(0, 255, 136, 0.05)';
      ctx.lineWidth = 1;
      const gridSize = width / 12;
      for (let x = 0; x < width; x += gridSize) {
        ctx.beginPath();
        ctx.moveTo(x, 0);
        ctx.lineTo(x, height);
        ctx.stroke();
      }
      for (let y = 0; y < height; y += gridSize) {
        ctx.beginPath();
        ctx.moveTo(0, y);
        ctx.lineTo(width, y);
        ctx.stroke();
      }

      // Headline
      ctx.font = `bold ${width * 0.07}px Orbitron, sans-serif`;
      ctx.textAlign = 'center';
      ctx.fillStyle = '#fff';
      ctx.shadowColor = frame.chartColor;
      ctx.shadowBlur = 20;
      ctx.fillText(frame.headline.toUpperCase(), width / 2, height * 0.12);
      ctx.shadowBlur = 0;

      // Chart area
      const chartX = width * 0.08;
      const chartY = height * 0.18;
      const chartW = width * 0.84;
      const chartH = height * 0.4;

      // Chart background
      ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
      ctx.fillRect(chartX, chartY, chartW, chartH);
      ctx.strokeStyle = 'rgba(255, 255, 255, 0.1)';
      ctx.strokeRect(chartX, chartY, chartW, chartH);

      // Draw chart based on type
      drawChart(ctx, frame, chartX, chartY, chartW, chartH);

      // Script text area
      const scriptY = height * 0.65;
      const scriptH = height * 0.28;

      // Script background
      ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
      ctx.fillRect(width * 0.05, scriptY, width * 0.9, scriptH);

      // Script label
      ctx.font = `bold ${width * 0.035}px Orbitron, sans-serif`;
      ctx.fillStyle = frame.chartColor;
      ctx.textAlign = 'left';
      ctx.fillText('SCRIPT', width * 0.08, scriptY + width * 0.06);

      // Script text
      ctx.font = `${width * 0.04}px Space Mono, monospace`;
      ctx.fillStyle = '#ccc';
      wrapText(ctx, frame.script, width * 0.08, scriptY + width * 0.12, width * 0.84, width * 0.055);

      // Bottom branding
      ctx.font = `bold ${width * 0.03}px Orbitron, sans-serif`;
      ctx.textAlign = 'center';
      ctx.fillStyle = '#444';
      ctx.fillText('FINANCE SHORTS', width / 2, height * 0.97);
    }

    function drawChart(ctx, frame, x, y, w, h) {
      const data = frame.data;
      const color = frame.chartColor;
      const padding = w * 0.05;

      const minVal = Math.min(...data) * 0.9;
      const maxVal = Math.max(...data) * 1.1;
      const range = maxVal - minVal;

      switch (frame.chartType) {
        case 'line':
          drawLineChart(ctx, data, x, y, w, h, color, minVal, range, padding);
          break;
        case 'bar':
          drawBarChart(ctx, data, x, y, w, h, color, minVal, range, padding);
          break;
        case 'candle':
          drawCandleChart(ctx, data, x, y, w, h, padding);
          break;
        case 'pie':
          drawPieChart(ctx, data.slice(0, 5), x, y, w, h, color);
          break;
        case 'area':
          drawAreaChart(ctx, data, x, y, w, h, color, minVal, range, padding);
          break;
        case 'stats':
          drawStatsCard(ctx, x, y, w, h, color);
          break;
      }
    }

    function drawLineChart(ctx, data, x, y, w, h, color, minVal, range, padding) {
      const stepX = (w - padding * 2) / (data.length - 1);

      // Glow effect
      ctx.shadowColor = color;
      ctx.shadowBlur = 15;
      ctx.strokeStyle = color;
      ctx.lineWidth = 4;
      ctx.beginPath();

      data.forEach((val, i) => {
        const px = x + padding + i * stepX;
        const py = y + h - padding - ((val - minVal) / range) * (h - padding * 2);
        if (i === 0) ctx.moveTo(px, py);
        else ctx.lineTo(px, py);
      });
      ctx.stroke();
      ctx.shadowBlur = 0;

      // Data points
      data.forEach((val, i) => {
        const px = x + padding + i * stepX;
        const py = y + h - padding - ((val - minVal) / range) * (h - padding * 2);
        ctx.beginPath();
        ctx.arc(px, py, 6, 0, Math.PI * 2);
        ctx.fillStyle = color;
        ctx.fill();
        ctx.beginPath();
        ctx.arc(px, py, 3, 0, Math.PI * 2);
        ctx.fillStyle = '#000';
        ctx.fill();
      });
    }

    function drawBarChart(ctx, data, x, y, w, h, color, minVal, range, padding) {
      const barW = (w - padding * 2) / data.length * 0.7;
      const gap = (w - padding * 2) / data.length * 0.3;

      data.forEach((val, i) => {
        const barH = ((val - minVal) / range) * (h - padding * 2);
        const px = x + padding + i * (barW + gap) + gap / 2;
        const py = y + h - padding - barH;

        // Glow
        ctx.shadowColor = color;
        ctx.shadowBlur = 10;

        // Bar gradient
        const grad = ctx.createLinearGradient(px, py, px, y + h - padding);
        grad.addColorStop(0, color);
        grad.addColorStop(1, 'rgba(0,0,0,0.5)');
        ctx.fillStyle = grad;
        ctx.fillRect(px, py, barW, barH);

        ctx.shadowBlur = 0;
      });
    }

    function drawCandleChart(ctx, data, x, y, w, h, padding) {
      const candleW = (w - padding * 2) / data.length * 0.6;
      const gap = (w - padding * 2) / data.length;

      data.forEach((val, i) => {
        const open = val + (Math.random() - 0.5) * 10;
        const close = val;
        const high = Math.max(open, close) + Math.random() * 5;
        const low = Math.min(open, close) - Math.random() * 5;

        const isGreen = close >= open;
        const color = isGreen ? '#00ff88' : '#ff3366';

        const px = x + padding + i * gap + (gap - candleW) / 2;
        const minVal = Math.min(...data) * 0.8;
        const range = Math.max(...data) * 1.2 - minVal;

        const highY = y + h - padding - ((high - minVal) / range) * (h - padding * 2);
        const lowY = y + h - padding - ((low - minVal) / range) * (h - padding * 2);
        const openY = y + h - padding - ((open - minVal) / range) * (h - padding * 2);
        const closeY = y + h - padding - ((close - minVal) / range) * (h - padding * 2);

        // Wick
        ctx.strokeStyle = color;
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(px + candleW / 2, highY);
        ctx.lineTo(px + candleW / 2, lowY);
        ctx.stroke();

        // Body
        ctx.shadowColor = color;
        ctx.shadowBlur = 8;
        ctx.fillStyle = color;
        ctx.fillRect(px, Math.min(openY, closeY), candleW, Math.abs(closeY - openY) || 2);
        ctx.shadowBlur = 0;
      });
    }

    function drawPieChart(ctx, data, x, y, w, h, baseColor) {
      const centerX = x + w / 2;
      const centerY = y + h / 2;
      const radius = Math.min(w, h) * 0.35;
      const total = data.reduce((a, b) => a + b, 0);
      const colors = ['#00ff88', '#ff3366', '#00ccff', '#ffcc00', '#ff00ff'];

      let startAngle = -Math.PI / 2;

      data.forEach((val, i) => {
        const sliceAngle = (val / total) * Math.PI * 2;
        const endAngle = startAngle + sliceAngle;

        ctx.beginPath();
        ctx.moveTo(centerX, centerY);
        ctx.arc(centerX, centerY, radius, startAngle, endAngle);
        ctx.closePath();

        ctx.shadowColor = colors[i % colors.length];
        ctx.shadowBlur = 15;
        ctx.fillStyle = colors[i % colors.length];
        ctx.fill();
        ctx.shadowBlur = 0;

        // Label
        const midAngle = startAngle + sliceAngle / 2;
        const labelX = centerX + Math.cos(midAngle) * radius * 0.6;
        const labelY = centerY + Math.sin(midAngle) * radius * 0.6;
        ctx.font = `bold ${w * 0.05}px Orbitron`;
        ctx.fillStyle = '#000';
        ctx.textAlign = 'center';
        ctx.fillText(Math.round(val / total * 100) + '%', labelX, labelY);

        startAngle = endAngle;
      });
    }

    function drawAreaChart(ctx, data, x, y, w, h, color, minVal, range, padding) {
      const stepX = (w - padding * 2) / (data.length - 1);

      // Area fill
      ctx.beginPath();
      ctx.moveTo(x + padding, y + h - padding);

      data.forEach((val, i) => {
        const px = x + padding + i * stepX;
        const py = y + h - padding - ((val - minVal) / range) * (h - padding * 2);
        ctx.lineTo(px, py);
      });

      ctx.lineTo(x + w - padding, y + h - padding);
      ctx.closePath();

      const grad = ctx.createLinearGradient(0, y, 0, y + h);
      grad.addColorStop(0, color);
      grad.addColorStop(1, 'rgba(0,0,0,0)');
      ctx.fillStyle = grad;
      ctx.globalAlpha = 0.3;
      ctx.fill();
      ctx.globalAlpha = 1;

      // Line on top
      drawLineChart(ctx, data, x, y, w, h, color, minVal, range, padding);
    }

    function drawStatsCard(ctx, x, y, w, h, color) {
      const stats = [
        { label: 'PRICE', value: '$' + (Math.random() * 1000 + 100).toFixed(2) },
        { label: 'CHANGE', value: (Math.random() > 0.5 ? '+' : '-') + (Math.random() * 10).toFixed(2) + '%' },
        { label: 'VOLUME', value: (Math.random() * 100).toFixed(1) + 'M' },
        { label: 'MARKET CAP', value: '$' + (Math.random() * 500).toFixed(0) + 'B' }
      ];

      const cardH = h / stats.length;

      stats.forEach((stat, i) => {
        const cardY = y + i * cardH;

        ctx.fillStyle = i % 2 === 0 ? 'rgba(0,0,0,0.2)' : 'rgba(0,0,0,0.1)';
        ctx.fillRect(x, cardY, w, cardH);

        ctx.font = `${w * 0.06}px Space Mono`;
        ctx.fillStyle = '#666';
        ctx.textAlign = 'left';
        ctx.fillText(stat.label, x + w * 0.05, cardY + cardH * 0.6);

        ctx.font = `bold ${w * 0.1}px Orbitron`;
        ctx.fillStyle = stat.value.includes('+') ? '#00ff88' : stat.value.includes('-') ? '#ff3366' : color;
        ctx.shadowColor = ctx.fillStyle;
        ctx.shadowBlur = 10;
        ctx.textAlign = 'right';
        ctx.fillText(stat.value, x + w * 0.95, cardY + cardH * 0.65);
        ctx.shadowBlur = 0;
      });
    }

    function wrapText(ctx, text, x, y, maxWidth, lineHeight) {
      const words = text.split(' ');
      let line = '';
      let lineCount = 0;

      for (let i = 0; i < words.length; i++) {
        const testLine = line + words[i] + ' ';
        const metrics = ctx.measureText(testLine);

        if (metrics.width > maxWidth && i > 0) {
          ctx.fillText(line.trim(), x, y + lineCount * lineHeight);
          line = words[i] + ' ';
          lineCount++;
          if (lineCount >= 4) {
            ctx.fillText(line.trim() + '...', x, y + lineCount * lineHeight);
            return;
          }
        } else {
          line = testLine;
        }
      }
      ctx.fillText(line.trim(), x, y + lineCount * lineHeight);
    }

    // Update preview
    function updatePreview() {
      const frame = frames[currentFrameIndex];
      drawFrame(previewCtx, frame, previewCanvas.width, previewCanvas.height);
      updateFrameList();
      updateInputs();
    }

    // Update inputs from current frame
    function updateInputs() {
      const frame = frames[currentFrameIndex];
      document.getElementById('headlineInput').value = frame.headline;
      document.getElementById('scriptInput').value = frame.script;

      document.querySelectorAll('.chart-type-btn[data-chart]').forEach(btn => {
        btn.classList.toggle('active', btn.dataset.chart === frame.chartType);
      });

      document.querySelectorAll('.chart-type-btn[data-color]').forEach(btn => {
        btn.classList.toggle('active', btn.dataset.color === frame.chartColor);
      });

      document.getElementById('currentFrame').textContent = currentFrameIndex + 1;
      document.getElementById('totalFrames').textContent = frames.length;
    }

    // Update frame list thumbnails
    function updateFrameList() {
      const list = document.getElementById('frameList');
      list.innerHTML = '';

      frames.forEach((frame, i) => {
        const thumb = document.createElement('div');
        thumb.className = 'frame-thumb' + (i === currentFrameIndex ? ' active' : '');
        thumb.innerHTML = `<span class="frame-number">${i + 1}</span><canvas width="108" height="192"></canvas>`;

        const thumbCanvas = thumb.querySelector('canvas');
        const thumbCtx = thumbCanvas.getContext('2d');
        drawFrame(thumbCtx, frame, 108, 192);

        thumb.addEventListener('click', () => {
          currentFrameIndex = i;
          updatePreview();
        });

        list.appendChild(thumb);
      });
    }

    // Event listeners
    document.getElementById('headlineInput').addEventListener('input', (e) => {
      frames[currentFrameIndex].headline = e.target.value;
      updatePreview();
    });

    document.getElementById('scriptInput').addEventListener('input', (e) => {
      frames[currentFrameIndex].script = e.target.value;
      updatePreview();
    });

    document.querySelectorAll('.chart-type-btn[data-chart]').forEach(btn => {
      btn.addEventListener('click', () => {
        frames[currentFrameIndex].chartType = btn.dataset.chart;
        frames[currentFrameIndex].data = generateRandomData();
        updatePreview();
      });
    });

    document.querySelectorAll('.chart-type-btn[data-color]').forEach(btn => {
      btn.addEventListener('click', () => {
        frames[currentFrameIndex].chartColor = btn.dataset.color;
        updatePreview();
      });
    });

    document.getElementById('addFrameBtn').addEventListener('click', () => {
      frames.push(createFrame());
      currentFrameIndex = frames.length - 1;
      updatePreview();
    });

    document.getElementById('deleteFrameBtn').addEventListener('click', () => {
      if (frames.length > 1) {
        frames.splice(currentFrameIndex, 1);
        currentFrameIndex = Math.min(currentFrameIndex, frames.length - 1);
        updatePreview();
      }
    });

    document.getElementById('prevBtn').addEventListener('click', () => {
      currentFrameIndex = (currentFrameIndex - 1 + frames.length) % frames.length;
      updatePreview();
    });

    document.getElementById('nextBtn').addEventListener('click', () => {
      currentFrameIndex = (currentFrameIndex + 1) % frames.length;
      updatePreview();
    });

    // Generate script with AI
    document.getElementById('generateBtn').addEventListener('click', async () => {
      const topic = document.getElementById('topicInput').value || 'stock market';
      const btn = document.getElementById('generateBtn');
      btn.classList.add('generating');
      btn.textContent = '‚è≥ GENERATING...';

      try {
        const prompt = `Write a 3-frame TikTok script about ${topic}. Format as JSON array with 3 objects, each having "headline" (short, max 3 words) and "script" (2-3 sentences for voiceover). Make it engaging and educational. Only output valid JSON, nothing else.`;

        const response = await fetch(`https://text.pollinations.ai/${encodeURIComponent(prompt)}?referrer=sloppy.live`);
        const text = await response.text();

        // Parse JSON from response
        const jsonMatch = text.match(/\[[\s\S]*\]/);
        if (jsonMatch) {
          const data = JSON.parse(jsonMatch[0]);

          // Clear and create new frames
          frames = data.map((item, i) => ({
            headline: item.headline || 'FRAME ' + (i + 1),
            script: item.script || 'Script here...',
            chartType: ['line', 'bar', 'candle', 'area', 'stats'][i % 5],
            chartColor: ['#00ff88', '#00ccff', '#ffcc00'][i % 3],
            data: generateRandomData()
          }));

          currentFrameIndex = 0;
          updatePreview();
        }
      } catch (err) {
        console.error('Generation failed:', err);
      }

      btn.classList.remove('generating');
      btn.textContent = '‚ö° GENERATE SCRIPT';
    });

    // Initialize
    updatePreview();
  </script>
<script src="/sloppy-header/sloppy-bar.js"></script>
</body>
</html>
