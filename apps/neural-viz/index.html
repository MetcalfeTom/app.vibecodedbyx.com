<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Neural Network Visualizer</title>
  <link rel="icon" href="https://emojicdn.elk.sh/ðŸ§ ">
  <meta property="og:title" content="Neural Network Visualizer">
  <meta property="og:description" content="Watch signals pulse through a glowing neural network">
  <meta property="og:url" content="https://sloppy.live/neural-viz">
  <meta property="og:image" content="https://emojicdn.elk.sh/ðŸ§ ?style=apple&size=512">
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link href="https://fonts.googleapis.com/css2?family=IBM+Plex+Mono:wght@400;600&family=Exo+2:wght@300;600&display=swap" rel="stylesheet">
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      min-height: 100vh;
      background: #05080f;
      font-family: 'IBM Plex Mono', monospace;
      overflow: hidden;
      display: flex;
      flex-direction: column;
    }

    canvas {
      display: block;
      flex: 1;
    }

    .header {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      padding: 1rem 2rem;
      display: flex;
      justify-content: space-between;
      align-items: center;
      background: linear-gradient(to bottom, rgba(5, 8, 15, 0.95), transparent);
      z-index: 100;
      pointer-events: none;
    }

    .header > * {
      pointer-events: auto;
    }

    .title {
      font-family: 'Exo 2', sans-serif;
      font-size: 1.3rem;
      font-weight: 600;
      color: #fff;
      text-shadow: 0 0 20px #00f7ff, 0 0 40px #00f7ff;
      letter-spacing: 2px;
    }

    .stats {
      font-size: 0.75rem;
      color: #00f7ff;
      text-shadow: 0 0 10px #00f7ff;
      text-align: right;
    }

    .controls {
      position: fixed;
      bottom: 1.5rem;
      left: 50%;
      transform: translateX(-50%);
      display: flex;
      gap: 0.5rem;
      flex-wrap: wrap;
      justify-content: center;
      z-index: 100;
    }

    .btn {
      font-family: 'IBM Plex Mono', monospace;
      font-size: 0.75rem;
      padding: 0.6rem 1rem;
      background: rgba(0, 247, 255, 0.1);
      border: 1px solid #00f7ff;
      color: #00f7ff;
      cursor: pointer;
      transition: all 0.2s;
      text-transform: uppercase;
      letter-spacing: 1px;
    }

    .btn:hover {
      background: rgba(0, 247, 255, 0.3);
      box-shadow: 0 0 20px rgba(0, 247, 255, 0.5);
    }

    .btn.active {
      background: #00f7ff;
      color: #05080f;
    }

    .info {
      position: fixed;
      bottom: 0.5rem;
      left: 50%;
      transform: translateX(-50%);
      font-size: 0.65rem;
      color: #335;
      z-index: 100;
    }

    .info a {
      color: #446;
      text-decoration: none;
    }

    /* Layer labels */
    .layer-labels {
      position: fixed;
      top: 50%;
      transform: translateY(-50%);
      left: 0;
      right: 0;
      display: flex;
      justify-content: space-around;
      pointer-events: none;
      z-index: 50;
      padding: 0 5%;
    }

    .layer-label {
      font-family: 'Exo 2', sans-serif;
      font-size: 0.7rem;
      color: rgba(0, 247, 255, 0.4);
      text-transform: uppercase;
      letter-spacing: 2px;
      writing-mode: vertical-rl;
      text-orientation: mixed;
      transform: rotate(180deg);
    }
  </style>
</head>
<body>
  <div class="header">
    <div class="title">NEURAL NETWORK</div>
    <div class="stats">
      <div>Nodes: <span id="nodeCount">0</span></div>
      <div>Signals: <span id="signalCount">0</span></div>
    </div>
  </div>

  <div class="layer-labels" id="layerLabels"></div>

  <canvas id="canvas"></canvas>

  <div class="controls">
    <button class="btn" id="fireBtn">Fire Signal</button>
    <button class="btn" id="burstBtn">Burst</button>
    <button class="btn" id="autoBtn">Auto: Off</button>
    <button class="btn" id="reshapeBtn">Reshape</button>
  </div>

  <div class="info"><a href="https://sloppy.live">sloppy.live</a></div>

  <script>
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    const nodeCountEl = document.getElementById('nodeCount');
    const signalCountEl = document.getElementById('signalCount');
    const layerLabelsEl = document.getElementById('layerLabels');

    let width, height;
    let nodes = [];
    let connections = [];
    let signals = [];
    let autoMode = false;
    let autoInterval = null;

    const layerNames = ['INPUT', 'HIDDEN 1', 'HIDDEN 2', 'HIDDEN 3', 'OUTPUT'];

    // Colors
    const colors = {
      node: '#00f7ff',
      nodeGlow: 'rgba(0, 247, 255, 0.6)',
      connection: 'rgba(0, 247, 255, 0.15)',
      signal: '#ff00ff',
      signalGlow: 'rgba(255, 0, 255, 0.8)',
      activated: '#00ff88',
      activatedGlow: 'rgba(0, 255, 136, 0.8)'
    };

    function resize() {
      width = canvas.width = window.innerWidth;
      height = canvas.height = window.innerHeight;
    }

    function createNetwork() {
      nodes = [];
      connections = [];
      signals = [];

      // Layer configuration
      const layers = [4, 6, 8, 6, 3];
      const layerX = [];
      const padding = width * 0.12;
      const layerSpacing = (width - padding * 2) / (layers.length - 1);

      for (let i = 0; i < layers.length; i++) {
        layerX.push(padding + i * layerSpacing);
      }

      // Create nodes
      layers.forEach((count, layerIndex) => {
        const nodeSpacing = (height - 200) / (count + 1);
        for (let i = 0; i < count; i++) {
          nodes.push({
            x: layerX[layerIndex],
            y: 100 + nodeSpacing * (i + 1),
            layer: layerIndex,
            radius: 8 + Math.random() * 4,
            activation: 0,
            pulsePhase: Math.random() * Math.PI * 2,
            connections: []
          });
        }
      });

      // Create connections between adjacent layers
      let nodeIndex = 0;
      for (let l = 0; l < layers.length - 1; l++) {
        const currentLayerStart = nodeIndex;
        const currentLayerEnd = nodeIndex + layers[l];
        const nextLayerStart = currentLayerEnd;
        const nextLayerEnd = nextLayerStart + layers[l + 1];

        for (let i = currentLayerStart; i < currentLayerEnd; i++) {
          for (let j = nextLayerStart; j < nextLayerEnd; j++) {
            // Random connection probability for visual variety
            if (Math.random() > 0.2) {
              const conn = {
                from: i,
                to: j,
                weight: 0.3 + Math.random() * 0.7,
                pulsePhase: Math.random() * Math.PI * 2
              };
              connections.push(conn);
              nodes[i].connections.push(connections.length - 1);
            }
          }
        }
        nodeIndex += layers[l];
      }

      nodeCountEl.textContent = nodes.length;
      updateLayerLabels(layerX);
    }

    function updateLayerLabels(layerX) {
      layerLabelsEl.innerHTML = '';
      layerNames.forEach((name, i) => {
        if (layerX[i]) {
          const label = document.createElement('div');
          label.className = 'layer-label';
          label.textContent = name;
          label.style.position = 'absolute';
          label.style.left = layerX[i] + 'px';
          layerLabelsEl.appendChild(label);
        }
      });
    }

    function fireSignal(nodeIndex) {
      const node = nodes[nodeIndex];
      if (!node || node.layer === nodes[nodes.length - 1].layer) return;

      node.activation = 1;

      node.connections.forEach(connIndex => {
        const conn = connections[connIndex];
        signals.push({
          connection: connIndex,
          progress: 0,
          speed: 0.018 + Math.random() * 0.008,
          strength: 1.0  // Start at full strength
        });
      });
    }

    function fireRandomInput() {
      const inputNodes = nodes.filter(n => n.layer === 0);
      const randomNode = inputNodes[Math.floor(Math.random() * inputNodes.length)];
      const nodeIndex = nodes.indexOf(randomNode);
      fireSignal(nodeIndex);
    }

    function fireBurst() {
      const inputNodes = nodes.filter(n => n.layer === 0);
      inputNodes.forEach((node, i) => {
        setTimeout(() => {
          const nodeIndex = nodes.indexOf(node);
          fireSignal(nodeIndex);
        }, i * 50);
      });
    }

    function update() {
      // Update signals
      signals = signals.filter(signal => {
        signal.progress += signal.speed;

        if (signal.progress >= 1) {
          // Signal reached destination
          const conn = connections[signal.connection];
          const targetNode = nodes[conn.to];
          targetNode.activation = Math.min(1, targetNode.activation + signal.strength * 0.5);

          // Propagate signal forward - always propagate through all layers
          if (targetNode.connections.length > 0) {
            targetNode.connections.forEach(nextConnIndex => {
              const nextConn = connections[nextConnIndex];
              // Keep strength above minimum so signals stay visible
              const newStrength = Math.max(0.4, signal.strength * nextConn.weight * 0.95);
              signals.push({
                connection: nextConnIndex,
                progress: 0,
                speed: 0.018 + Math.random() * 0.008,
                strength: newStrength
              });
            });
          }
          return false;
        }
        return true;
      });

      // Decay node activations
      nodes.forEach(node => {
        node.activation *= 0.97;
        node.pulsePhase += 0.03;
      });

      // Update connection pulses
      connections.forEach(conn => {
        conn.pulsePhase += 0.02;
      });

      signalCountEl.textContent = signals.length;
    }

    function draw() {
      // Clear with fade effect
      ctx.fillStyle = 'rgba(5, 8, 15, 0.15)';
      ctx.fillRect(0, 0, width, height);

      // Draw connections
      connections.forEach((conn, index) => {
        const fromNode = nodes[conn.from];
        const toNode = nodes[conn.to];

        // Base connection line
        const pulse = Math.sin(conn.pulsePhase) * 0.3 + 0.7;
        const alpha = 0.08 + pulse * 0.07;

        ctx.beginPath();
        ctx.moveTo(fromNode.x, fromNode.y);
        ctx.lineTo(toNode.x, toNode.y);
        ctx.strokeStyle = `rgba(0, 247, 255, ${alpha * conn.weight})`;
        ctx.lineWidth = 1;
        ctx.stroke();
      });

      // Draw signals on connections
      signals.forEach(signal => {
        const conn = connections[signal.connection];
        const fromNode = nodes[conn.from];
        const toNode = nodes[conn.to];

        const x = fromNode.x + (toNode.x - fromNode.x) * signal.progress;
        const y = fromNode.y + (toNode.y - fromNode.y) * signal.progress;

        // Signal glow
        const gradient = ctx.createRadialGradient(x, y, 0, x, y, 20 * signal.strength);
        gradient.addColorStop(0, colors.signalGlow);
        gradient.addColorStop(1, 'transparent');
        ctx.fillStyle = gradient;
        ctx.beginPath();
        ctx.arc(x, y, 20 * signal.strength, 0, Math.PI * 2);
        ctx.fill();

        // Signal core
        ctx.beginPath();
        ctx.arc(x, y, 4 * signal.strength, 0, Math.PI * 2);
        ctx.fillStyle = colors.signal;
        ctx.fill();

        // Bright connection line behind signal
        ctx.beginPath();
        ctx.moveTo(fromNode.x, fromNode.y);
        ctx.lineTo(x, y);
        ctx.strokeStyle = `rgba(255, 0, 255, ${0.4 * signal.strength})`;
        ctx.lineWidth = 2;
        ctx.stroke();
      });

      // Draw nodes
      nodes.forEach((node, index) => {
        const pulse = Math.sin(node.pulsePhase) * 0.2 + 0.8;
        const activated = node.activation > 0.1;

        // Outer glow
        const glowSize = node.radius * (2 + node.activation * 2) * pulse;
        const glowGradient = ctx.createRadialGradient(
          node.x, node.y, 0,
          node.x, node.y, glowSize
        );

        if (activated) {
          glowGradient.addColorStop(0, colors.activatedGlow);
          glowGradient.addColorStop(0.5, 'rgba(0, 255, 136, 0.2)');
          glowGradient.addColorStop(1, 'transparent');
        } else {
          glowGradient.addColorStop(0, colors.nodeGlow);
          glowGradient.addColorStop(0.5, 'rgba(0, 247, 255, 0.1)');
          glowGradient.addColorStop(1, 'transparent');
        }

        ctx.fillStyle = glowGradient;
        ctx.beginPath();
        ctx.arc(node.x, node.y, glowSize, 0, Math.PI * 2);
        ctx.fill();

        // Node core
        const coreRadius = node.radius * (1 + node.activation * 0.3);
        ctx.beginPath();
        ctx.arc(node.x, node.y, coreRadius, 0, Math.PI * 2);
        ctx.fillStyle = activated ? colors.activated : colors.node;
        ctx.fill();

        // Inner bright spot
        ctx.beginPath();
        ctx.arc(node.x - coreRadius * 0.3, node.y - coreRadius * 0.3, coreRadius * 0.3, 0, Math.PI * 2);
        ctx.fillStyle = 'rgba(255, 255, 255, 0.6)';
        ctx.fill();
      });
    }

    function animate() {
      update();
      draw();
      requestAnimationFrame(animate);
    }

    // Event listeners
    document.getElementById('fireBtn').addEventListener('click', fireRandomInput);
    document.getElementById('burstBtn').addEventListener('click', fireBurst);

    document.getElementById('autoBtn').addEventListener('click', function() {
      autoMode = !autoMode;
      this.textContent = autoMode ? 'Auto: On' : 'Auto: Off';
      this.classList.toggle('active', autoMode);

      if (autoMode) {
        autoInterval = setInterval(() => {
          if (Math.random() > 0.5) {
            fireRandomInput();
          }
        }, 300);
      } else {
        clearInterval(autoInterval);
      }
    });

    document.getElementById('reshapeBtn').addEventListener('click', () => {
      createNetwork();
    });

    // Click on canvas to activate nearest input node
    canvas.addEventListener('click', (e) => {
      const rect = canvas.getBoundingClientRect();
      const x = e.clientX - rect.left;
      const y = e.clientY - rect.top;

      // Find nearest input node
      const inputNodes = nodes.filter(n => n.layer === 0);
      let nearest = null;
      let nearestDist = Infinity;

      inputNodes.forEach(node => {
        const dist = Math.hypot(node.x - x, node.y - y);
        if (dist < nearestDist) {
          nearestDist = dist;
          nearest = node;
        }
      });

      if (nearest && nearestDist < 100) {
        fireSignal(nodes.indexOf(nearest));
      }
    });

    // Initialize
    window.addEventListener('resize', () => {
      resize();
      createNetwork();
    });

    resize();
    createNetwork();
    animate();

    // Start with a burst for visual impact
    setTimeout(fireBurst, 500);
  </script>
</body>
</html>
