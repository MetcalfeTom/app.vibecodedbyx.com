<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
  <title>Pancake Stack</title>
  <link rel="icon" href="https://emojicdn.elk.sh/ü•û">
  <meta name="description" content="Stack wobbling pancakes and keep the angry butter from sliding off!">
  <meta property="og:title" content="Pancake Stack">
  <meta property="og:description" content="Stack wobbling pancakes and keep the angry butter from sliding off!">
  <meta property="og:image" content="https://emojicdn.elk.sh/ü•û?style=google">
  <meta property="og:url" content="https://sloppy.live/pancake-stack">
  <style>
    @import url('https://fonts.googleapis.com/css2?family=Fredoka:wght@400;600;700&display=swap');

    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      background: linear-gradient(180deg, #1a0a05 0%, #2d1810 50%, #4a2a1a 100%);
      min-height: 100vh;
      display: flex;
      flex-direction: column;
      align-items: center;
      font-family: 'Fredoka', sans-serif;
      overflow: hidden;
      touch-action: none;
    }

    header {
      padding: 15px;
      text-align: center;
      z-index: 10;
    }

    h1 {
      font-size: 2.2rem;
      font-weight: 700;
      color: #ffcc66;
      text-shadow: 0 0 20px #ff9900, 0 4px 0 #aa6600;
      letter-spacing: 2px;
    }

    .score-display {
      font-size: 1.3rem;
      color: #ffeecc;
      margin-top: 8px;
      text-shadow: 0 0 10px #ff6600;
    }

    #gameCanvas {
      display: block;
      cursor: pointer;
      touch-action: none;
    }

    .instructions {
      position: fixed;
      bottom: 15px;
      left: 50%;
      transform: translateX(-50%);
      color: #ffcc99;
      font-size: 0.95rem;
      text-align: center;
      opacity: 0.8;
      text-shadow: 0 0 10px #ff6600;
    }

    .back-link {
      position: fixed;
      top: 10px;
      left: 10px;
      color: #ffcc66;
      text-decoration: none;
      font-size: 0.9rem;
      opacity: 0.7;
      transition: opacity 0.2s;
    }

    .back-link:hover {
      opacity: 1;
    }

    .game-over {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: rgba(30, 15, 5, 0.95);
      border: 3px solid #ff9900;
      border-radius: 20px;
      padding: 30px 50px;
      text-align: center;
      z-index: 100;
      display: none;
      box-shadow: 0 0 40px #ff660066;
    }

    .game-over h2 {
      color: #ff6644;
      font-size: 2rem;
      margin-bottom: 15px;
      text-shadow: 0 0 15px #ff3300;
    }

    .game-over p {
      color: #ffcc99;
      font-size: 1.2rem;
      margin-bottom: 20px;
    }

    .restart-btn {
      background: linear-gradient(180deg, #ff9900, #cc6600);
      border: none;
      color: #fff;
      padding: 12px 30px;
      font-size: 1.1rem;
      font-family: 'Fredoka', sans-serif;
      font-weight: 600;
      border-radius: 25px;
      cursor: pointer;
      box-shadow: 0 4px 0 #884400, 0 0 20px #ff660066;
      transition: transform 0.1s;
    }

    .restart-btn:hover {
      transform: translateY(-2px);
    }

    .restart-btn:active {
      transform: translateY(2px);
      box-shadow: 0 2px 0 #884400;
    }
  </style>
</head>
<body>
  <a href="https://sloppy.live" class="back-link">‚Üê sloppy.live</a>

  <header>
    <h1>ü•û PANCAKE STACK ü•û</h1>
    <div class="score-display">Pancakes: <span id="score">0</span> | Best: <span id="best">0</span></div>
  </header>

  <canvas id="gameCanvas"></canvas>

  <div class="instructions" id="instructions">Click or tap to drop a pancake!</div>

  <div class="game-over" id="gameOver">
    <h2>üßà BUTTER ESCAPED! üßà</h2>
    <p>You stacked <span id="finalScore">0</span> pancakes!</p>
    <button class="restart-btn" onclick="restartGame()">Stack Again!</button>
  </div>

  <script>
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');

    // Resize canvas
    function resize() {
      canvas.width = Math.min(window.innerWidth, 500);
      canvas.height = window.innerHeight - 120;
    }
    resize();
    window.addEventListener('resize', resize);

    // Game state
    let pancakes = [];
    let butter = null;
    let score = 0;
    let best = parseInt(localStorage.getItem('pancakeBest') || '0');
    let gameRunning = true;
    let pendingPancake = null;
    let dropX = 0;

    document.getElementById('best').textContent = best;

    // Physics constants
    const GRAVITY = 0.4;
    const FRICTION = 0.92;
    const BOUNCE = 0.3;
    const WOBBLE_DECAY = 0.96;

    // Plate (base)
    const plate = {
      x: 0,
      y: 0,
      width: 180,
      height: 20
    };

    class Pancake {
      constructor(x, y, width) {
        this.x = x;
        this.y = y;
        this.width = width;
        this.height = 22 + Math.random() * 8;
        this.vx = 0;
        this.vy = 0;
        this.angle = 0;
        this.angularVel = 0;
        this.wobble = 0;
        this.wobblePhase = Math.random() * Math.PI * 2;
        this.color = this.randomColor();
        this.settled = false;
      }

      randomColor() {
        const browns = ['#e8a84c', '#d4944a', '#c98b42', '#dda050', '#e0954d'];
        return browns[Math.floor(Math.random() * browns.length)];
      }

      update() {
        // Apply gravity
        this.vy += GRAVITY;

        // Apply velocities
        this.x += this.vx;
        this.y += this.vy;
        this.angle += this.angularVel;

        // Friction
        this.vx *= FRICTION;
        this.angularVel *= FRICTION;

        // Wobble effect
        this.wobble *= WOBBLE_DECAY;
        this.wobblePhase += 0.15;

        // Floor collision (plate level)
        const floorY = plate.y - this.height / 2;
        if (this.y > floorY) {
          this.y = floorY;
          this.vy *= -BOUNCE;
          if (Math.abs(this.vy) < 1) {
            this.vy = 0;
            this.settled = true;
          }
          this.wobble = Math.min(this.wobble + Math.abs(this.vx) * 0.1, 0.3);
          this.angularVel += (Math.random() - 0.5) * 0.02;
        }

        // Wall collisions
        if (this.x - this.width / 2 < 0) {
          this.x = this.width / 2;
          this.vx *= -0.5;
        }
        if (this.x + this.width / 2 > canvas.width) {
          this.x = canvas.width - this.width / 2;
          this.vx *= -0.5;
        }

        // Check if fell off screen
        if (this.y > canvas.height + 100) {
          return false; // Remove this pancake
        }

        return true;
      }

      draw() {
        ctx.save();
        ctx.translate(this.x, this.y);

        const wobbleAngle = Math.sin(this.wobblePhase) * this.wobble;
        ctx.rotate(this.angle + wobbleAngle);

        // Shadow
        ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
        ctx.beginPath();
        ctx.ellipse(3, 5, this.width / 2, this.height / 2, 0, 0, Math.PI * 2);
        ctx.fill();

        // Main pancake body
        ctx.fillStyle = this.color;
        ctx.beginPath();
        ctx.ellipse(0, 0, this.width / 2, this.height / 2, 0, 0, Math.PI * 2);
        ctx.fill();

        // Top highlight
        ctx.fillStyle = 'rgba(255, 220, 150, 0.4)';
        ctx.beginPath();
        ctx.ellipse(-this.width * 0.15, -this.height * 0.15, this.width * 0.25, this.height * 0.2, -0.3, 0, Math.PI * 2);
        ctx.fill();

        // Edge detail
        ctx.strokeStyle = '#b87830';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.ellipse(0, 0, this.width / 2, this.height / 2, 0, 0, Math.PI * 2);
        ctx.stroke();

        ctx.restore();
      }

      getTopY() {
        return this.y - this.height / 2;
      }
    }

    class Butter {
      constructor(x, y) {
        this.x = x;
        this.y = y;
        this.width = 40;
        this.height = 30;
        this.vx = 0;
        this.vy = 0;
        this.angle = 0;
        this.angularVel = 0;
        this.mood = 'angry'; // Always angry!
        this.eyeOffset = 0;
        this.escapeTimer = 0;
        this.slideDirection = Math.random() > 0.5 ? 1 : -1;
      }

      update(topPancake) {
        if (!topPancake) {
          // Fall if no pancakes
          this.vy += GRAVITY;
          this.y += this.vy;
          return this.y < canvas.height + 50;
        }

        // Target position is top of stack
        const targetY = topPancake.getTopY() - this.height / 2 - 5;

        // Angry butter tries to escape!
        this.escapeTimer++;
        if (this.escapeTimer > 60) {
          // Change direction randomly
          if (Math.random() < 0.02) {
            this.slideDirection *= -1;
          }
          // Apply escape force
          this.vx += this.slideDirection * (0.15 + Math.random() * 0.1);
        }

        // Physics
        this.vy += GRAVITY * 0.5;
        this.x += this.vx;
        this.y += this.vy;

        // Stay on top of pancake (with wobble influence)
        const pancakeWobble = Math.sin(topPancake.wobblePhase) * topPancake.wobble * 30;

        if (this.y > targetY) {
          this.y = targetY;
          this.vy = 0;
          // Add pancake's wobble to butter's position
          this.vx += pancakeWobble * 0.02;
        }

        // Friction
        this.vx *= 0.95;
        this.angularVel *= 0.9;

        // Update angle based on velocity
        this.angularVel += this.vx * 0.01;
        this.angle += this.angularVel;

        // Eye tracking (looks in escape direction)
        this.eyeOffset = this.vx * 2;

        // Check if fell off
        if (this.x < -50 || this.x > canvas.width + 50 || this.y > canvas.height + 50) {
          return false; // Butter escaped!
        }

        return true;
      }

      draw() {
        ctx.save();
        ctx.translate(this.x, this.y);
        ctx.rotate(this.angle);

        // Shadow
        ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
        ctx.fillRect(-this.width / 2 + 3, -this.height / 2 + 5, this.width, this.height);

        // Butter body
        const gradient = ctx.createLinearGradient(0, -this.height / 2, 0, this.height / 2);
        gradient.addColorStop(0, '#fff4a3');
        gradient.addColorStop(0.5, '#ffdd44');
        gradient.addColorStop(1, '#ddaa22');
        ctx.fillStyle = gradient;
        ctx.fillRect(-this.width / 2, -this.height / 2, this.width, this.height);

        // Butter highlight
        ctx.fillStyle = 'rgba(255, 255, 200, 0.6)';
        ctx.fillRect(-this.width / 2 + 3, -this.height / 2 + 3, this.width * 0.4, this.height * 0.3);

        // Angry eyes
        const eyeY = -this.height * 0.1;
        const eyeSpacing = 8;

        // Eye whites
        ctx.fillStyle = '#fff';
        ctx.beginPath();
        ctx.ellipse(-eyeSpacing + this.eyeOffset, eyeY, 6, 7, 0, 0, Math.PI * 2);
        ctx.fill();
        ctx.beginPath();
        ctx.ellipse(eyeSpacing + this.eyeOffset, eyeY, 6, 7, 0, 0, Math.PI * 2);
        ctx.fill();

        // Angry eyebrows
        ctx.strokeStyle = '#553300';
        ctx.lineWidth = 3;
        ctx.lineCap = 'round';
        ctx.beginPath();
        ctx.moveTo(-eyeSpacing - 7, eyeY - 10);
        ctx.lineTo(-eyeSpacing + 5, eyeY - 6);
        ctx.stroke();
        ctx.beginPath();
        ctx.moveTo(eyeSpacing + 7, eyeY - 10);
        ctx.lineTo(eyeSpacing - 5, eyeY - 6);
        ctx.stroke();

        // Pupils (looking in slide direction)
        ctx.fillStyle = '#221100';
        ctx.beginPath();
        ctx.arc(-eyeSpacing + this.eyeOffset + this.slideDirection * 2, eyeY + 1, 3, 0, Math.PI * 2);
        ctx.fill();
        ctx.beginPath();
        ctx.arc(eyeSpacing + this.eyeOffset + this.slideDirection * 2, eyeY + 1, 3, 0, Math.PI * 2);
        ctx.fill();

        // Angry mouth
        ctx.strokeStyle = '#553300';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(-6, this.height * 0.2);
        ctx.quadraticCurveTo(0, this.height * 0.1, 6, this.height * 0.2);
        ctx.stroke();

        // Steam/rage lines
        if (this.escapeTimer > 60 && Math.random() > 0.7) {
          ctx.strokeStyle = '#ff6600';
          ctx.lineWidth = 2;
          for (let i = 0; i < 3; i++) {
            const sx = (Math.random() - 0.5) * this.width;
            ctx.beginPath();
            ctx.moveTo(sx, -this.height / 2 - 5);
            ctx.lineTo(sx + (Math.random() - 0.5) * 10, -this.height / 2 - 15);
            ctx.stroke();
          }
        }

        ctx.restore();
      }
    }

    // Pancake collision handling
    function handlePancakeCollisions() {
      for (let i = 0; i < pancakes.length; i++) {
        for (let j = i + 1; j < pancakes.length; j++) {
          const p1 = pancakes[i];
          const p2 = pancakes[j];

          // Simple vertical stacking collision
          const dx = p2.x - p1.x;
          const dy = p2.y - p1.y;
          const minDist = (p1.height + p2.height) / 2;

          if (Math.abs(dy) < minDist && Math.abs(dx) < (p1.width + p2.width) / 3) {
            // Vertical collision - stack them
            if (dy < 0) {
              // p2 is above p1
              p2.y = p1.y - minDist;
              if (p2.vy > 0) {
                p2.vy *= -BOUNCE;
                p1.wobble = Math.min(p1.wobble + 0.15, 0.4);
                p2.wobble = Math.min(p2.wobble + 0.1, 0.3);
              }
            } else {
              // p1 is above p2
              p1.y = p2.y - minDist;
              if (p1.vy > 0) {
                p1.vy *= -BOUNCE;
                p2.wobble = Math.min(p2.wobble + 0.15, 0.4);
                p1.wobble = Math.min(p1.wobble + 0.1, 0.3);
              }
            }

            // Horizontal influence
            const pushForce = dx * 0.02;
            p1.vx -= pushForce;
            p2.vx += pushForce;

            // Transfer wobble
            const avgWobble = (p1.wobble + p2.wobble) / 2;
            p1.wobble = avgWobble;
            p2.wobble = avgWobble;
          }
        }
      }
    }

    function getTopPancake() {
      if (pancakes.length === 0) return null;
      let top = pancakes[0];
      for (const p of pancakes) {
        if (p.y < top.y) top = p;
      }
      return top;
    }

    function dropPancake(x) {
      if (!gameRunning) return;

      const width = 80 + Math.random() * 40;
      const pancake = new Pancake(x, -50, width);
      pancakes.push(pancake);

      // Create butter on first pancake
      if (!butter && pancakes.length === 1) {
        setTimeout(() => {
          if (gameRunning) {
            butter = new Butter(canvas.width / 2, -80);
          }
        }, 500);
      }
    }

    function updateScore() {
      // Count settled pancakes
      score = pancakes.filter(p => p.settled).length;
      document.getElementById('score').textContent = score;

      if (score > best) {
        best = score;
        localStorage.setItem('pancakeBest', best.toString());
        document.getElementById('best').textContent = best;
      }
    }

    function gameOver() {
      gameRunning = false;
      document.getElementById('finalScore').textContent = score;
      document.getElementById('gameOver').style.display = 'block';
    }

    function restartGame() {
      pancakes = [];
      butter = null;
      score = 0;
      gameRunning = true;
      document.getElementById('score').textContent = '0';
      document.getElementById('gameOver').style.display = 'none';
      document.getElementById('instructions').style.display = 'block';
    }

    function drawPlate() {
      plate.x = canvas.width / 2;
      plate.y = canvas.height - 50;

      // Plate shadow
      ctx.fillStyle = 'rgba(0, 0, 0, 0.4)';
      ctx.beginPath();
      ctx.ellipse(plate.x + 5, plate.y + 10, plate.width / 2 + 10, 15, 0, 0, Math.PI * 2);
      ctx.fill();

      // Plate
      const plateGradient = ctx.createLinearGradient(plate.x, plate.y - 20, plate.x, plate.y + 20);
      plateGradient.addColorStop(0, '#f5f5f0');
      plateGradient.addColorStop(0.5, '#e8e8e0');
      plateGradient.addColorStop(1, '#d0d0c8');
      ctx.fillStyle = plateGradient;
      ctx.beginPath();
      ctx.ellipse(plate.x, plate.y, plate.width / 2, plate.height, 0, 0, Math.PI * 2);
      ctx.fill();

      // Plate rim
      ctx.strokeStyle = '#c0c0b8';
      ctx.lineWidth = 3;
      ctx.beginPath();
      ctx.ellipse(plate.x, plate.y, plate.width / 2, plate.height, 0, 0, Math.PI * 2);
      ctx.stroke();

      // Plate highlight
      ctx.fillStyle = 'rgba(255, 255, 255, 0.5)';
      ctx.beginPath();
      ctx.ellipse(plate.x - 30, plate.y - 5, 30, 8, -0.3, 0, Math.PI * 2);
      ctx.fill();
    }

    function drawBackground() {
      // Table surface
      const tableGradient = ctx.createLinearGradient(0, canvas.height - 150, 0, canvas.height);
      tableGradient.addColorStop(0, '#5c3a28');
      tableGradient.addColorStop(1, '#3d2518');
      ctx.fillStyle = tableGradient;
      ctx.fillRect(0, canvas.height - 120, canvas.width, 120);

      // Table edge highlight
      ctx.strokeStyle = '#7a5040';
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(0, canvas.height - 120);
      ctx.lineTo(canvas.width, canvas.height - 120);
      ctx.stroke();
    }

    // Input handling
    function handleInput(x) {
      if (!gameRunning) return;
      dropPancake(x);
      document.getElementById('instructions').style.display = 'none';
    }

    canvas.addEventListener('click', (e) => {
      const rect = canvas.getBoundingClientRect();
      handleInput(e.clientX - rect.left);
    });

    canvas.addEventListener('touchstart', (e) => {
      e.preventDefault();
      const rect = canvas.getBoundingClientRect();
      const touch = e.touches[0];
      handleInput(touch.clientX - rect.left);
    });

    // Game loop
    function gameLoop() {
      // Clear
      ctx.fillStyle = '#2d1810';
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      drawBackground();
      drawPlate();

      // Update and filter pancakes
      pancakes = pancakes.filter(p => p.update());
      handlePancakeCollisions();

      // Draw pancakes (bottom to top)
      pancakes.sort((a, b) => b.y - a.y);
      pancakes.forEach(p => p.draw());

      // Update and draw butter
      if (butter) {
        const topPancake = getTopPancake();
        const butterAlive = butter.update(topPancake);
        if (!butterAlive && gameRunning) {
          gameOver();
        }
        butter.draw();
      }

      updateScore();

      requestAnimationFrame(gameLoop);
    }

    gameLoop();
  </script>
<script src="/sloppy-header/sloppy-bar.js"></script>
</body>
</html>
