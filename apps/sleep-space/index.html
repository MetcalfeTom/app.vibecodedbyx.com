<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Sleep Space</title>
    <link rel="icon" href="https://emojicdn.elk.sh/ðŸŒ™">

    <meta property="og:title" content="Sleep Space">
    <meta property="og:description" content="Drift off with a starfield and lo-fi ambient sounds.">
    <meta property="og:url" content="https://sloppy.live/sleep-space">
    <meta property="og:image" content="https://image.pollinations.ai/prompt/peaceful%20starfield%20night%20sky%20dark%20blue%20purple%20sleep%20calm?width=1200&height=630&nologo=true">
    <meta property="og:type" content="website">

    <link href="https://fonts.googleapis.com/css2?family=Nunito:wght@300;400&display=swap" rel="stylesheet">

    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Nunito', sans-serif;
            background: #0a0a12;
            min-height: 100vh;
            overflow: hidden;
            color: #8090a0;
            cursor: none;
        }

        body.show-ui {
            cursor: default;
        }

        #starfield {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 0;
        }

        .ui {
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            padding: 30px;
            background: linear-gradient(transparent, rgba(10, 10, 18, 0.95));
            z-index: 10;
            opacity: 0;
            transition: opacity 0.5s ease;
            pointer-events: none;
        }

        body.show-ui .ui {
            opacity: 1;
            pointer-events: auto;
        }

        .ui-content {
            max-width: 500px;
            margin: 0 auto;
        }

        .title {
            font-size: 1.5rem;
            font-weight: 300;
            color: #b0c0d0;
            margin-bottom: 20px;
            text-align: center;
            letter-spacing: 0.2em;
        }

        .controls {
            display: flex;
            flex-direction: column;
            gap: 16px;
        }

        .control-row {
            display: flex;
            align-items: center;
            gap: 16px;
        }

        .control-label {
            font-size: 0.85rem;
            width: 80px;
            flex-shrink: 0;
            text-transform: uppercase;
            letter-spacing: 0.1em;
        }

        .slider-container {
            flex: 1;
            position: relative;
        }

        input[type="range"] {
            width: 100%;
            height: 4px;
            -webkit-appearance: none;
            appearance: none;
            background: #1a1a2a;
            border-radius: 2px;
            outline: none;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: #4a5a70;
            cursor: pointer;
            transition: background 0.2s;
        }

        input[type="range"]::-webkit-slider-thumb:hover {
            background: #6a7a90;
        }

        input[type="range"]::-moz-range-thumb {
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: #4a5a70;
            cursor: pointer;
            border: none;
        }

        .sound-toggles {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
        }

        .sound-btn {
            padding: 8px 16px;
            background: #1a1a2a;
            border: 1px solid #2a2a3a;
            border-radius: 20px;
            color: #6a7a8a;
            font-family: inherit;
            font-size: 0.85rem;
            cursor: pointer;
            transition: all 0.2s;
        }

        .sound-btn:hover {
            background: #2a2a3a;
        }

        .sound-btn.active {
            background: #2a3a4a;
            border-color: #4a5a6a;
            color: #a0b0c0;
        }

        .play-btn {
            width: 60px;
            height: 60px;
            border-radius: 50%;
            background: #1a2a3a;
            border: 2px solid #3a4a5a;
            color: #8090a0;
            font-size: 24px;
            cursor: pointer;
            transition: all 0.3s;
            display: flex;
            align-items: center;
            justify-content: center;
            margin: 20px auto 0;
        }

        .play-btn:hover {
            background: #2a3a4a;
            border-color: #5a6a7a;
        }

        .play-btn.playing {
            background: #2a3a4a;
            border-color: #6a7a8a;
        }

        .hint {
            text-align: center;
            font-size: 0.75rem;
            color: #4a5a6a;
            margin-top: 20px;
        }

        .backlink {
            position: fixed;
            bottom: 10px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 0.7rem;
            color: #3a4a5a;
            z-index: 5;
            opacity: 0;
            transition: opacity 0.5s;
        }

        body.show-ui .backlink {
            opacity: 1;
        }

        .backlink a {
            color: #5a6a7a;
            text-decoration: none;
        }

        /* Shooting star */
        .shooting-star {
            position: fixed;
            width: 100px;
            height: 1px;
            background: linear-gradient(90deg, rgba(255,255,255,0.8), transparent);
            pointer-events: none;
            z-index: 1;
            opacity: 0;
        }
    </style>
</head>
<body class="show-ui">
    <canvas id="starfield"></canvas>

    <div class="ui">
        <div class="ui-content">
            <div class="title">S L E E P &nbsp; S P A C E</div>

            <div class="controls">
                <div class="control-row">
                    <span class="control-label">Volume</span>
                    <div class="slider-container">
                        <input type="range" id="volumeSlider" min="0" max="100" value="50">
                    </div>
                </div>

                <div class="control-row">
                    <span class="control-label">Stars</span>
                    <div class="slider-container">
                        <input type="range" id="starSpeed" min="1" max="10" value="3">
                    </div>
                </div>

                <div class="control-row">
                    <span class="control-label">Sounds</span>
                    <div class="sound-toggles">
                        <button class="sound-btn active" data-sound="rain">Rain</button>
                        <button class="sound-btn" data-sound="wind">Wind</button>
                        <button class="sound-btn" data-sound="static">Static</button>
                        <button class="sound-btn" data-sound="drone">Drone</button>
                        <button class="sound-btn" data-sound="piano">Piano</button>
                    </div>
                </div>
            </div>

            <button class="play-btn" id="playBtn">â–¶</button>

            <div class="hint">tap anywhere to hide controls</div>
        </div>
    </div>

    <div class="backlink">
        <a href="https://sloppy.live">sloppy.live</a>
    </div>

    <div class="shooting-star" id="shootingStar"></div>

    <script>
        // === STARFIELD ===
        const canvas = document.getElementById('starfield');
        const ctx = canvas.getContext('2d');
        let stars = [];
        let starSpeed = 0.3;
        let animationId;

        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            initStars();
        }

        function initStars() {
            stars = [];
            const numStars = Math.floor((canvas.width * canvas.height) / 3000);
            for (let i = 0; i < numStars; i++) {
                stars.push({
                    x: Math.random() * canvas.width,
                    y: Math.random() * canvas.height,
                    size: Math.random() * 1.5 + 0.5,
                    speed: Math.random() * 0.5 + 0.1,
                    brightness: Math.random(),
                    twinkleSpeed: Math.random() * 0.02 + 0.005
                });
            }
        }

        function drawStars() {
            ctx.fillStyle = '#0a0a12';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            stars.forEach(star => {
                // Twinkle effect
                star.brightness += star.twinkleSpeed;
                if (star.brightness > 1 || star.brightness < 0.3) {
                    star.twinkleSpeed *= -1;
                }

                const alpha = star.brightness * 0.8;
                ctx.beginPath();
                ctx.arc(star.x, star.y, star.size, 0, Math.PI * 2);
                ctx.fillStyle = `rgba(200, 210, 230, ${alpha})`;
                ctx.fill();

                // Move star slowly
                star.y += star.speed * starSpeed;
                if (star.y > canvas.height) {
                    star.y = 0;
                    star.x = Math.random() * canvas.width;
                }
            });

            animationId = requestAnimationFrame(drawStars);
        }

        window.addEventListener('resize', resizeCanvas);
        resizeCanvas();
        drawStars();

        // Star speed control
        document.getElementById('starSpeed').addEventListener('input', (e) => {
            starSpeed = e.target.value / 10;
        });

        // === SHOOTING STARS ===
        const shootingStar = document.getElementById('shootingStar');

        function createShootingStar() {
            const x = Math.random() * canvas.width;
            const y = Math.random() * (canvas.height / 2);
            const angle = 20 + Math.random() * 20;
            const duration = 800 + Math.random() * 400;

            shootingStar.style.left = x + 'px';
            shootingStar.style.top = y + 'px';
            shootingStar.style.transform = `rotate(${angle}deg)`;
            shootingStar.style.opacity = '1';
            shootingStar.style.transition = `transform ${duration}ms linear, opacity ${duration}ms ease-out`;

            requestAnimationFrame(() => {
                shootingStar.style.transform = `rotate(${angle}deg) translateX(${300 + Math.random() * 200}px)`;
                shootingStar.style.opacity = '0';
            });

            // Random interval for next shooting star
            setTimeout(createShootingStar, 5000 + Math.random() * 15000);
        }

        setTimeout(createShootingStar, 3000);

        // === AUDIO ENGINE (Lo-Fi Procedural) ===
        let audioCtx = null;
        let masterGain = null;
        let isPlaying = false;
        let activeSounds = {
            rain: true,
            wind: false,
            static: false,
            drone: false,
            piano: false
        };
        let soundNodes = {};
        let pianoInterval = null;

        function initAudio() {
            if (audioCtx) return;
            audioCtx = new (window.AudioContext || window.webkitAudioContext)();
            masterGain = audioCtx.createGain();
            masterGain.gain.value = 0.5;
            masterGain.connect(audioCtx.destination);
        }

        // Brown noise for rain
        function createBrownNoise() {
            const bufferSize = 2 * audioCtx.sampleRate;
            const buffer = audioCtx.createBuffer(1, bufferSize, audioCtx.sampleRate);
            const output = buffer.getChannelData(0);

            let lastOut = 0;
            for (let i = 0; i < bufferSize; i++) {
                const white = Math.random() * 2 - 1;
                output[i] = (lastOut + (0.02 * white)) / 1.02;
                lastOut = output[i];
                output[i] *= 3.5;
            }

            const source = audioCtx.createBufferSource();
            source.buffer = buffer;
            source.loop = true;

            // Filter for rain-like sound
            const filter = audioCtx.createBiquadFilter();
            filter.type = 'lowpass';
            filter.frequency.value = 400;

            const gain = audioCtx.createGain();
            gain.gain.value = 0.4;

            source.connect(filter);
            filter.connect(gain);

            return { source, gain, filter };
        }

        // Pink noise for wind
        function createPinkNoise() {
            const bufferSize = 2 * audioCtx.sampleRate;
            const buffer = audioCtx.createBuffer(1, bufferSize, audioCtx.sampleRate);
            const output = buffer.getChannelData(0);

            let b0 = 0, b1 = 0, b2 = 0, b3 = 0, b4 = 0, b5 = 0, b6 = 0;
            for (let i = 0; i < bufferSize; i++) {
                const white = Math.random() * 2 - 1;
                b0 = 0.99886 * b0 + white * 0.0555179;
                b1 = 0.99332 * b1 + white * 0.0750759;
                b2 = 0.96900 * b2 + white * 0.1538520;
                b3 = 0.86650 * b3 + white * 0.3104856;
                b4 = 0.55000 * b4 + white * 0.5329522;
                b5 = -0.7616 * b5 - white * 0.0168980;
                output[i] = b0 + b1 + b2 + b3 + b4 + b5 + b6 + white * 0.5362;
                output[i] *= 0.11;
                b6 = white * 0.115926;
            }

            const source = audioCtx.createBufferSource();
            source.buffer = buffer;
            source.loop = true;

            // LFO for wind variation
            const lfo = audioCtx.createOscillator();
            lfo.frequency.value = 0.1;
            const lfoGain = audioCtx.createGain();
            lfoGain.gain.value = 0.15;

            const gain = audioCtx.createGain();
            gain.gain.value = 0.3;

            lfo.connect(lfoGain);
            lfoGain.connect(gain.gain);
            lfo.start();

            source.connect(gain);

            return { source, gain, lfo };
        }

        // White noise for static
        function createStaticNoise() {
            const bufferSize = 2 * audioCtx.sampleRate;
            const buffer = audioCtx.createBuffer(1, bufferSize, audioCtx.sampleRate);
            const output = buffer.getChannelData(0);

            for (let i = 0; i < bufferSize; i++) {
                output[i] = Math.random() * 2 - 1;
            }

            const source = audioCtx.createBufferSource();
            source.buffer = buffer;
            source.loop = true;

            // Heavy filter for lo-fi static
            const filter = audioCtx.createBiquadFilter();
            filter.type = 'bandpass';
            filter.frequency.value = 1000;
            filter.Q.value = 0.5;

            const gain = audioCtx.createGain();
            gain.gain.value = 0.08;

            source.connect(filter);
            filter.connect(gain);

            return { source, gain, filter };
        }

        // Low drone
        function createDrone() {
            const osc1 = audioCtx.createOscillator();
            const osc2 = audioCtx.createOscillator();
            const osc3 = audioCtx.createOscillator();

            osc1.type = 'sine';
            osc2.type = 'sine';
            osc3.type = 'triangle';

            osc1.frequency.value = 55; // A1
            osc2.frequency.value = 82.5; // E2
            osc3.frequency.value = 110; // A2

            // Slow detune LFO
            const lfo = audioCtx.createOscillator();
            lfo.frequency.value = 0.05;
            const lfoGain = audioCtx.createGain();
            lfoGain.gain.value = 2;
            lfo.connect(lfoGain);
            lfoGain.connect(osc1.frequency);
            lfoGain.connect(osc2.frequency);

            const filter = audioCtx.createBiquadFilter();
            filter.type = 'lowpass';
            filter.frequency.value = 200;

            const gain = audioCtx.createGain();
            gain.gain.value = 0.15;

            osc1.connect(filter);
            osc2.connect(filter);
            osc3.connect(filter);
            filter.connect(gain);

            return { oscs: [osc1, osc2, osc3], lfo, gain, filter };
        }

        // Procedural piano melodies
        function createPiano() {
            // Pentatonic scale frequencies (A minor pentatonic, multiple octaves)
            const notes = [
                220.00, 261.63, 293.66, 349.23, 392.00,  // A3, C4, D4, F4, G4
                440.00, 523.25, 587.33, 698.46, 783.99,  // A4, C5, D5, F5, G5
                880.00, 1046.50  // A5, C6
            ];

            const gain = audioCtx.createGain();
            gain.gain.value = 0.12;

            // Simple reverb using delays
            const delay1 = audioCtx.createDelay();
            delay1.delayTime.value = 0.15;
            const delay1Gain = audioCtx.createGain();
            delay1Gain.gain.value = 0.3;

            const delay2 = audioCtx.createDelay();
            delay2.delayTime.value = 0.3;
            const delay2Gain = audioCtx.createGain();
            delay2Gain.gain.value = 0.2;

            const filter = audioCtx.createBiquadFilter();
            filter.type = 'lowpass';
            filter.frequency.value = 2000;

            gain.connect(filter);
            filter.connect(delay1);
            delay1.connect(delay1Gain);
            delay1Gain.connect(masterGain);
            filter.connect(delay2);
            delay2.connect(delay2Gain);
            delay2Gain.connect(masterGain);
            filter.connect(masterGain);

            // Play random notes at random intervals
            function playNote() {
                if (!activeSounds.piano || !isPlaying) return;

                const freq = notes[Math.floor(Math.random() * notes.length)];
                const osc = audioCtx.createOscillator();
                const noteGain = audioCtx.createGain();

                // Mix triangle and sine for softer piano-like tone
                osc.type = Math.random() > 0.3 ? 'triangle' : 'sine';
                osc.frequency.value = freq;

                // Soft attack, medium decay envelope
                const now = audioCtx.currentTime;
                noteGain.gain.setValueAtTime(0, now);
                noteGain.gain.linearRampToValueAtTime(0.3, now + 0.02);
                noteGain.gain.exponentialRampToValueAtTime(0.01, now + 2.5);

                osc.connect(noteGain);
                noteGain.connect(gain);

                osc.start(now);
                osc.stop(now + 3);

                // Schedule next note (2-5 seconds)
                const nextDelay = 2000 + Math.random() * 3000;
                pianoInterval = setTimeout(playNote, nextDelay);
            }

            // Start first note after a short delay
            pianoInterval = setTimeout(playNote, 500);

            return { gain };
        }

        function startSound(type) {
            if (soundNodes[type]) return;

            let node;
            switch (type) {
                case 'rain':
                    node = createBrownNoise();
                    node.source.start();
                    break;
                case 'wind':
                    node = createPinkNoise();
                    node.source.start();
                    break;
                case 'static':
                    node = createStaticNoise();
                    node.source.start();
                    break;
                case 'drone':
                    node = createDrone();
                    node.oscs.forEach(o => o.start());
                    node.lfo.start();
                    break;
                case 'piano':
                    node = createPiano();
                    break;
            }

            if (node) {
                if (type !== 'piano') {
                    node.gain.connect(masterGain);
                }
                soundNodes[type] = node;
            }
        }

        function stopSound(type) {
            const node = soundNodes[type];
            if (!node) return;

            if (node.source) {
                node.source.stop();
            }
            if (node.oscs) {
                node.oscs.forEach(o => o.stop());
                node.lfo.stop();
            }
            if (type === 'piano') {
                clearTimeout(pianoInterval);
                pianoInterval = null;
            }

            delete soundNodes[type];
        }

        function togglePlayback() {
            const btn = document.getElementById('playBtn');

            if (!isPlaying) {
                initAudio();
                if (audioCtx.state === 'suspended') {
                    audioCtx.resume();
                }

                Object.keys(activeSounds).forEach(sound => {
                    if (activeSounds[sound]) {
                        startSound(sound);
                    }
                });

                isPlaying = true;
                btn.textContent = 'â¸';
                btn.classList.add('playing');
            } else {
                Object.keys(soundNodes).forEach(stopSound);
                isPlaying = false;
                btn.textContent = 'â–¶';
                btn.classList.remove('playing');
            }
        }

        // === UI CONTROLS ===
        document.getElementById('playBtn').addEventListener('click', togglePlayback);

        document.getElementById('volumeSlider').addEventListener('input', (e) => {
            if (masterGain) {
                masterGain.gain.value = e.target.value / 100;
            }
        });

        document.querySelectorAll('.sound-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                const sound = btn.dataset.sound;
                btn.classList.toggle('active');
                activeSounds[sound] = btn.classList.contains('active');

                if (isPlaying) {
                    if (activeSounds[sound]) {
                        startSound(sound);
                    } else {
                        stopSound(sound);
                    }
                }
            });
        });

        // === UI VISIBILITY ===
        let hideTimeout;

        function showUI() {
            document.body.classList.add('show-ui');
            clearTimeout(hideTimeout);
            hideTimeout = setTimeout(hideUI, 5000);
        }

        function hideUI() {
            if (isPlaying) {
                document.body.classList.remove('show-ui');
            }
        }

        document.addEventListener('mousemove', showUI);
        document.addEventListener('touchstart', () => {
            if (document.body.classList.contains('show-ui') && isPlaying) {
                hideUI();
            } else {
                showUI();
            }
        });

        document.addEventListener('click', (e) => {
            if (!e.target.closest('.ui') && isPlaying) {
                document.body.classList.toggle('show-ui');
                if (document.body.classList.contains('show-ui')) {
                    clearTimeout(hideTimeout);
                    hideTimeout = setTimeout(hideUI, 5000);
                }
            }
        });

        // Prevent sleep on mobile
        if ('wakeLock' in navigator) {
            let wakeLock = null;
            async function requestWakeLock() {
                try {
                    wakeLock = await navigator.wakeLock.request('screen');
                } catch (e) {
                    console.log('Wake lock error:', e);
                }
            }

            document.addEventListener('visibilitychange', () => {
                if (document.visibilityState === 'visible' && isPlaying) {
                    requestWakeLock();
                }
            });

            document.getElementById('playBtn').addEventListener('click', () => {
                if (isPlaying) requestWakeLock();
            });
        }
    </script>
<script src="/sloppy-header/sloppy-bar.js"></script>
</body>
</html>
