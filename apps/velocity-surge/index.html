<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
  <title>Velocity Surge</title>
  <link rel="icon" href="https://emojicdn.elk.sh/üèéÔ∏è">
  <meta name="description" content="Dodge obstacles at breakneck speed in this neon racing surge">
  <meta property="og:title" content="Velocity Surge">
  <meta property="og:description" content="Dodge obstacles at breakneck speed in this neon racing surge">
  <meta property="og:image" content="https://image.pollinations.ai/prompt/neon%20racing%20game%20high%20speed%20futuristic%20road%20cyan%20magenta%20dark%20background%20motion%20blur?width=1200&height=630&nologo=true&referrer=sloppy.live">
  <meta property="og:url" content="https://app.sloppy.live/velocity-surge">
  <style>
    @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&family=Share+Tech+Mono&display=swap');
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      background: #06060e;
      overflow: hidden;
      width: 100vw;
      height: 100vh;
      font-family: 'Share Tech Mono', monospace;
      user-select: none;
      -webkit-user-select: none;
    }
    canvas { display: block; width: 100%; height: 100%; }

    #hud {
      position: fixed;
      top: 0; left: 0; right: 0;
      display: flex;
      justify-content: space-between;
      align-items: flex-start;
      padding: 18px 24px;
      pointer-events: none;
      z-index: 10;
    }
    .hud-box {
      text-align: center;
    }
    .hud-label {
      font-size: 9px;
      letter-spacing: 3px;
      text-transform: uppercase;
      color: #555;
    }
    .hud-val {
      font-family: 'Orbitron', sans-serif;
      font-weight: 900;
      font-size: clamp(1.2rem, 3vw, 1.8rem);
      color: #0ff;
      text-shadow: 0 0 12px rgba(0,255,255,0.5);
    }
    .hud-val.speed { color: #ff2266; text-shadow: 0 0 12px rgba(255,34,102,0.5); }
    .hud-val.multi { color: #ff0; text-shadow: 0 0 12px rgba(255,255,0,0.5); }

    #overlay {
      position: fixed;
      inset: 0;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      z-index: 20;
      background: rgba(6,6,14,0.92);
    }
    #overlay.hidden { display: none; }
    .ov-title {
      font-family: 'Orbitron', sans-serif;
      font-weight: 900;
      font-size: clamp(2rem, 7vw, 4.5rem);
      letter-spacing: 0.08em;
      background: linear-gradient(135deg, #0ff, #ff2266);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
      margin-bottom: 8px;
    }
    .ov-sub {
      font-size: 0.75rem;
      color: #555;
      letter-spacing: 4px;
      text-transform: uppercase;
      margin-bottom: 36px;
    }
    .ov-score {
      font-family: 'Orbitron', sans-serif;
      font-size: 1.6rem;
      color: #0ff;
      margin-bottom: 8px;
      display: none;
    }
    .ov-score.show { display: block; }
    .ov-best {
      font-size: 0.8rem;
      color: #555;
      margin-bottom: 32px;
      display: none;
    }
    .ov-best.show { display: block; }
    .ov-btn {
      font-family: 'Orbitron', sans-serif;
      font-weight: 700;
      font-size: 0.95rem;
      letter-spacing: 3px;
      padding: 14px 40px;
      border: 2px solid #0ff;
      border-radius: 4px;
      background: transparent;
      color: #0ff;
      cursor: pointer;
      transition: all 0.2s;
      text-transform: uppercase;
    }
    .ov-btn:hover {
      background: rgba(0,255,255,0.12);
      box-shadow: 0 0 24px rgba(0,255,255,0.3);
      transform: scale(1.04);
    }
    .ov-controls {
      margin-top: 28px;
      font-size: 0.65rem;
      color: #444;
      letter-spacing: 2px;
      text-align: center;
      line-height: 1.8;
    }
    .back-link {
      position: fixed;
      bottom: 16px;
      left: 50%;
      transform: translateX(-50%);
      color: #333;
      text-decoration: none;
      font-size: 0.65rem;
      letter-spacing: 2px;
      z-index: 30;
    }
    .back-link:hover { color: #0ff; }

    /* Mobile touch zones */
    .touch-zone {
      position: fixed;
      bottom: 0;
      width: 50%;
      height: 120px;
      z-index: 15;
      display: none;
    }
    .touch-zone.left { left: 0; }
    .touch-zone.right { right: 0; }
    @media (pointer: coarse) {
      .touch-zone { display: block; }
    }
  </style>
</head>
<body>

<canvas id="game"></canvas>

<div id="hud">
  <div class="hud-box"><div class="hud-label">Distance</div><div class="hud-val" id="hudDist">0</div></div>
  <div class="hud-box"><div class="hud-label">Speed</div><div class="hud-val speed" id="hudSpeed">0</div></div>
  <div class="hud-box"><div class="hud-label">Multi</div><div class="hud-val multi" id="hudMulti">x1</div></div>
</div>

<div id="overlay">
  <div class="ov-title">VELOCITY SURGE</div>
  <div class="ov-sub">burn the toxic energy</div>
  <div class="ov-score" id="ovScore"></div>
  <div class="ov-best" id="ovBest"></div>
  <button class="ov-btn" id="ovBtn">IGNITE</button>
  <div class="ov-controls">‚Üê ‚Üí or A/D to steer &middot; SPACE to boost<br>tap left/right on mobile</div>
</div>

<div class="touch-zone left" id="touchL"></div>
<div class="touch-zone right" id="touchR"></div>

<a href="https://sloppy.live" class="back-link">sloppy.live</a>

<script>
const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d');

// --- Constants ---
const LANES = 5;
const LANE_W = 60;
const ROAD_W = LANES * LANE_W;
const HORIZON_Y = 0.32;
const CAR_W = 36;
const CAR_H = 60;
const BASE_SPEED = 6;
const MAX_SPEED = 22;
const BOOST_SPEED = 30;
const ACCEL = 0.004;
const STEER_SPEED = 6;
const OBS_MIN_GAP = 180;

let W, H, roadLeft, roadRight, vanishY;

// --- State ---
let state = 'menu'; // menu, play, dead
let distance = 0;
let speed = 0;
let playerX = 0; // road-relative, center = 0
let playerLane = 2;
let targetX = 0;
let boosting = false;
let boostFuel = 100;
let multiplier = 1;
let nearMissTimer = 0;
let shakeX = 0, shakeY = 0;
let obstacles = [];
let particles = [];
let sparks = [];
let roadLines = [];
let stars = [];
let bestScore = parseInt(localStorage.getItem('vs_best') || '0');
let flashAlpha = 0;

// --- Input ---
let keys = {};
document.addEventListener('keydown', e => { keys[e.code] = true; if (e.code === 'Space') e.preventDefault(); });
document.addEventListener('keyup', e => keys[e.code] = false);

document.getElementById('touchL').addEventListener('touchstart', e => { e.preventDefault(); keys['ArrowLeft'] = true; }, { passive: false });
document.getElementById('touchL').addEventListener('touchend', () => keys['ArrowLeft'] = false);
document.getElementById('touchR').addEventListener('touchstart', e => { e.preventDefault(); keys['ArrowRight'] = true; }, { passive: false });
document.getElementById('touchR').addEventListener('touchend', () => keys['ArrowRight'] = false);

// Swipe support
let touchStartX = 0;
canvas.addEventListener('touchstart', e => { touchStartX = e.touches[0].clientX; }, { passive: true });
canvas.addEventListener('touchend', e => {
  const dx = e.changedTouches[0].clientX - touchStartX;
  if (Math.abs(dx) > 30) {
    if (dx < 0) playerLane = Math.max(0, playerLane - 1);
    else playerLane = Math.min(LANES - 1, playerLane + 1);
  }
}, { passive: true });

// Double-tap boost
let lastTap = 0;
canvas.addEventListener('touchstart', () => {
  const now = Date.now();
  if (now - lastTap < 300) boosting = true;
  lastTap = now;
}, { passive: true });
canvas.addEventListener('touchend', () => boosting = false, { passive: true });

// --- Resize ---
function resize() {
  W = canvas.width = window.innerWidth;
  H = canvas.height = window.innerHeight;
  vanishY = H * HORIZON_Y;
  roadLeft = W / 2 - ROAD_W / 2;
  roadRight = W / 2 + ROAD_W / 2;
  initStars();
}
window.addEventListener('resize', resize);

function initStars() {
  stars = [];
  for (let i = 0; i < 120; i++) {
    stars.push({ x: Math.random() * W, y: Math.random() * vanishY, s: Math.random() * 1.5 + 0.5, b: Math.random() });
  }
}

// --- Audio ---
const audioCtx = new (window.AudioContext || window.webkitAudioContext)();

function playTone(freq, dur, vol = 0.1, type = 'square') {
  const osc = audioCtx.createOscillator();
  const gain = audioCtx.createGain();
  osc.type = type;
  osc.frequency.value = freq;
  gain.gain.setValueAtTime(vol, audioCtx.currentTime);
  gain.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + dur);
  osc.connect(gain).connect(audioCtx.destination);
  osc.start();
  osc.stop(audioCtx.currentTime + dur);
}

function playEngine() {
  const freq = 40 + speed * 4;
  playTone(freq, 0.08, 0.03, 'sawtooth');
}

function playCrash() {
  for (let i = 0; i < 5; i++) {
    setTimeout(() => playTone(80 + Math.random() * 200, 0.2, 0.15, 'sawtooth'), i * 40);
  }
}

function playNearMiss() {
  playTone(800, 0.1, 0.08, 'sine');
  playTone(1200, 0.08, 0.06, 'sine');
}

function playBoost() {
  playTone(200, 0.3, 0.08, 'sawtooth');
  playTone(400, 0.2, 0.06, 'sine');
}

function playMineBeep() {
  playTone(900, 0.06, 0.1, 'square');
  setTimeout(() => playTone(900, 0.06, 0.1, 'square'), 80);
}

function playMineExplode() {
  playTone(60, 0.4, 0.2, 'sawtooth');
  playTone(120, 0.3, 0.15, 'square');
  setTimeout(() => playTone(40, 0.5, 0.18, 'sawtooth'), 50);
}

// --- Obstacles ---
const OBS_TYPES = [
  { name: 'barrier', w: 50, h: 20, color: '#ff2266', glow: '#ff2266' },
  { name: 'cube', w: 35, h: 35, color: '#ff8800', glow: '#ff8800' },
  { name: 'spike', w: 28, h: 50, color: '#ff00ff', glow: '#ff00ff' },
  { name: 'wall', w: LANE_W * 2, h: 16, color: '#ff4444', glow: '#ff4444' },
  { name: 'pillar', w: 22, h: 55, color: '#aa00ff', glow: '#aa00ff' },
  { name: 'mine', w: 30, h: 30, color: '#ff1133', glow: '#ff1133', proximity: 70 },
];

function spawnObstacle() {
  const type = OBS_TYPES[Math.floor(Math.random() * OBS_TYPES.length)];
  let lane;
  // Wall type spans 2 lanes
  if (type.name === 'wall') {
    lane = Math.floor(Math.random() * (LANES - 1));
  } else {
    lane = Math.floor(Math.random() * LANES);
  }
  obstacles.push({
    type,
    lane,
    z: 800 + Math.random() * 200, // distance ahead
    hit: false
  });
}

// --- Particles ---
function emitSparks(x, y, color, count = 15) {
  for (let i = 0; i < count; i++) {
    const angle = Math.random() * Math.PI * 2;
    const spd = 2 + Math.random() * 6;
    sparks.push({
      x, y,
      vx: Math.cos(angle) * spd,
      vy: Math.sin(angle) * spd - 2,
      life: 0.5 + Math.random() * 0.5,
      color,
      size: 1 + Math.random() * 3
    });
  }
}

function emitExhaust() {
  const px = W / 2 + playerX;
  const py = H - 40;
  particles.push({
    x: px + (Math.random() - 0.5) * 16,
    y: py + Math.random() * 6,
    vx: (Math.random() - 0.5) * 0.5,
    vy: 1 + Math.random() * 2,
    life: 0.3 + Math.random() * 0.3,
    size: 2 + Math.random() * 3,
    color: boosting ? '#0ff' : '#ff2266'
  });
}

// --- Projection ---
function project(roadX, z) {
  // Simple perspective: z=0 is at player, larger z = farther
  const scale = 300 / (z + 1);
  const screenX = W / 2 + roadX * scale;
  const screenY = H - 60 - (z * scale * 0.5);
  return { x: screenX, y: Math.max(vanishY, screenY), scale };
}

// --- Game Loop ---
function startGame() {
  state = 'play';
  distance = 0;
  speed = BASE_SPEED;
  playerX = 0;
  playerLane = 2;
  targetX = 0;
  boosting = false;
  boostFuel = 100;
  multiplier = 1;
  nearMissTimer = 0;
  obstacles = [];
  particles = [];
  sparks = [];
  flashAlpha = 0;
  document.getElementById('overlay').classList.add('hidden');
  if (audioCtx.state === 'suspended') audioCtx.resume();
}

function die() {
  state = 'dead';
  playCrash();
  shakeX = 15;
  shakeY = 10;
  flashAlpha = 0.6;

  // Explosion
  const px = W / 2 + playerX;
  const py = H - 70;
  for (let i = 0; i < 40; i++) emitSparks(px, py, '#ff2266');
  for (let i = 0; i < 20; i++) emitSparks(px, py, '#0ff');
  for (let i = 0; i < 15; i++) emitSparks(px, py, '#ff8800');

  const score = Math.floor(distance);
  if (score > bestScore) {
    bestScore = score;
    localStorage.setItem('vs_best', bestScore.toString());
  }

  setTimeout(() => {
    const ov = document.getElementById('overlay');
    const sc = document.getElementById('ovScore');
    const bs = document.getElementById('ovBest');
    sc.textContent = 'DISTANCE: ' + score;
    sc.classList.add('show');
    bs.textContent = 'BEST: ' + bestScore;
    bs.classList.add('show');
    document.getElementById('ovBtn').textContent = 'REIGNITE';
    ov.querySelector('.ov-sub').textContent = 'wrecked at ' + Math.floor(speed * 12) + ' km/h';
    ov.classList.remove('hidden');
    state = 'menu';
  }, 1200);
}

function update() {
  if (state !== 'play') return;

  // Speed
  const targetSpeed = boosting && boostFuel > 0 ? BOOST_SPEED : Math.min(MAX_SPEED, BASE_SPEED + distance * ACCEL);
  speed += (targetSpeed - speed) * 0.05;

  if (boosting && boostFuel > 0) {
    boostFuel = Math.max(0, boostFuel - 0.8);
    if (boostFuel <= 0) boosting = false;
  } else {
    boostFuel = Math.min(100, boostFuel + 0.15);
  }

  // Boost input
  boosting = keys['Space'] || keys['ShiftLeft'];

  // Steering
  if (keys['ArrowLeft'] || keys['KeyA']) playerLane = Math.max(0, playerLane - 0.06);
  if (keys['ArrowRight'] || keys['KeyD']) playerLane = Math.min(LANES - 1, playerLane + 0.06);

  // Snap to nearest lane when not pressing
  if (!keys['ArrowLeft'] && !keys['KeyA'] && !keys['ArrowRight'] && !keys['KeyD']) {
    const nearest = Math.round(playerLane);
    playerLane += (nearest - playerLane) * 0.12;
  }

  targetX = (playerLane - (LANES - 1) / 2) * LANE_W;
  playerX += (targetX - playerX) * 0.15;

  distance += speed * 0.016;

  // Spawn obstacles
  const lastObs = obstacles[obstacles.length - 1];
  const gap = OBS_MIN_GAP - Math.min(60, distance * 0.05);
  if (!lastObs || lastObs.z < 700) {
    spawnObstacle();
    // Occasionally spawn clusters
    if (Math.random() < 0.3 + distance * 0.0005) {
      setTimeout(spawnObstacle, 0); // Extra in same batch
    }
  }

  // Move obstacles
  for (let i = obstacles.length - 1; i >= 0; i--) {
    const obs = obstacles[i];
    obs.z -= speed * 0.35;

    // Proximity mine detection ‚Äî explodes at wider radius
    if (!obs.hit && obs.type.name === 'mine' && obs.z < 80 && obs.z > -10) {
      const obsX = (obs.lane - (LANES - 1) / 2) * LANE_W;
      const dx = Math.abs(playerX - obsX);
      const dz = Math.abs(obs.z);
      const dist2d = Math.sqrt(dx * dx + dz * dz);

      // Beep warning when approaching
      if (dist2d < obs.type.proximity * 1.5 && !obs.warned) {
        obs.warned = true;
        playMineBeep();
      }

      if (dist2d < obs.type.proximity) {
        obs.hit = true;
        // Mine explosion ‚Äî big particle burst at mine screen position
        const scale = 300 / (obs.z + 1);
        const sy = H - 60 - obs.z * scale * 0.5;
        const progress = Math.max(0, (sy - vanishY) / (H - vanishY));
        const bL = W / 2 - ROAD_W / 2 - 30, bR = W / 2 + ROAD_W / 2 + 30;
        const tL = W / 2 - 40, tR = W / 2 + 40;
        const leftAtY = tL + (bL - tL) * progress;
        const rightAtY = tR + (bR - tR) * progress;
        const msx = leftAtY + (rightAtY - leftAtY) * ((obs.lane + 0.5) / LANES);

        playMineExplode();
        for (let j = 0; j < 35; j++) emitSparks(msx, sy, '#ff1133');
        for (let j = 0; j < 20; j++) emitSparks(msx, sy, '#ff6600');
        for (let j = 0; j < 10; j++) emitSparks(msx, sy, '#ffcc00');
        shakeX = 12;
        shakeY = 8;
        flashAlpha = 0.4;
        die();
        return;
      }
    }

    // Collision check
    if (!obs.hit && obs.z < 30 && obs.z > -20) {
      const obsX = (obs.lane - (LANES - 1) / 2) * LANE_W;
      const hw = obs.type.w / 2;
      const phw = CAR_W / 2;

      // Wall spans 2 lanes
      const obsLeft = obs.type.name === 'wall' ? obsX - LANE_W / 2 : obsX - hw;
      const obsRight = obs.type.name === 'wall' ? obsX + LANE_W * 1.5 : obsX + hw;

      if (playerX + phw > obsLeft && playerX - phw < obsRight) {
        obs.hit = true;
        die();
        return;
      }

      // Near miss detection
      const nearDist = 20;
      if (playerX + phw + nearDist > obsLeft && playerX - phw - nearDist < obsRight) {
        if (nearMissTimer <= 0) {
          multiplier = Math.min(8, multiplier + 0.5);
          nearMissTimer = 20;
          playNearMiss();
          emitSparks(W / 2 + playerX, H - 80, '#ff0', 8);
        }
      }
    }

    // Remove passed obstacles
    if (obs.z < -100) obstacles.splice(i, 1);
  }

  if (nearMissTimer > 0) nearMissTimer--;
  if (multiplier > 1) multiplier -= 0.002;
  if (multiplier < 1) multiplier = 1;

  // Exhaust
  if (Math.random() < 0.6) emitExhaust();
  if (boosting) { emitExhaust(); emitExhaust(); }

  // Engine sound
  if (Math.random() < 0.15) playEngine();
  if (boosting && Math.random() < 0.05) playBoost();

  // Particles
  for (let i = particles.length - 1; i >= 0; i--) {
    const p = particles[i];
    p.x += p.vx;
    p.y += p.vy;
    p.life -= 0.02;
    if (p.life <= 0) particles.splice(i, 1);
  }

  for (let i = sparks.length - 1; i >= 0; i--) {
    const s = sparks[i];
    s.x += s.vx;
    s.y += s.vy;
    s.vy += 0.15;
    s.life -= 0.025;
    if (s.life <= 0) sparks.splice(i, 1);
  }

  // Shake decay
  shakeX *= 0.9;
  shakeY *= 0.9;
  flashAlpha *= 0.92;
}

// --- Drawing ---
function draw() {
  ctx.save();
  ctx.translate((Math.random() - 0.5) * shakeX, (Math.random() - 0.5) * shakeY);

  // Sky
  const skyGrad = ctx.createLinearGradient(0, 0, 0, vanishY);
  skyGrad.addColorStop(0, '#06060e');
  skyGrad.addColorStop(1, '#0d0d1a');
  ctx.fillStyle = skyGrad;
  ctx.fillRect(0, 0, W, vanishY);

  // Stars
  for (const s of stars) {
    const flicker = 0.5 + Math.sin(Date.now() * 0.002 + s.b * 100) * 0.3;
    ctx.fillStyle = `rgba(200,220,255,${flicker * 0.6})`;
    ctx.fillRect(s.x, s.y, s.s, s.s);
  }

  // Ground
  const gndGrad = ctx.createLinearGradient(0, vanishY, 0, H);
  gndGrad.addColorStop(0, '#0a0a14');
  gndGrad.addColorStop(1, '#08080f');
  ctx.fillStyle = gndGrad;
  ctx.fillRect(0, vanishY, W, H - vanishY);

  // Road perspective
  drawRoad();

  // Obstacles
  drawObstacles();

  // Player car
  drawCar();

  // Particles
  for (const p of particles) {
    ctx.globalAlpha = p.life;
    ctx.fillStyle = p.color;
    ctx.shadowBlur = 6;
    ctx.shadowColor = p.color;
    ctx.fillRect(p.x - p.size / 2, p.y - p.size / 2, p.size, p.size);
  }
  ctx.globalAlpha = 1;
  ctx.shadowBlur = 0;

  // Sparks
  for (const s of sparks) {
    ctx.globalAlpha = s.life;
    ctx.fillStyle = s.color;
    ctx.shadowBlur = 4;
    ctx.shadowColor = s.color;
    ctx.beginPath();
    ctx.arc(s.x, s.y, s.size, 0, Math.PI * 2);
    ctx.fill();
  }
  ctx.globalAlpha = 1;
  ctx.shadowBlur = 0;

  // Speed lines
  if (speed > 12) {
    const intensity = (speed - 12) / 18;
    ctx.strokeStyle = `rgba(0,255,255,${intensity * 0.15})`;
    ctx.lineWidth = 1;
    for (let i = 0; i < 8; i++) {
      const sx = Math.random() * W;
      const sy = vanishY + Math.random() * (H - vanishY) * 0.6;
      ctx.beginPath();
      ctx.moveTo(sx, sy);
      ctx.lineTo(sx + (sx - W / 2) * 0.3, sy + 30 + speed * 2);
      ctx.stroke();
    }
  }

  // Flash overlay
  if (flashAlpha > 0.01) {
    ctx.fillStyle = `rgba(255,34,102,${flashAlpha})`;
    ctx.fillRect(0, 0, W, H);
  }

  // Boost bar
  if (state === 'play') {
    const bw = 120, bh = 4;
    const bx = W / 2 - bw / 2, by = H - 16;
    ctx.fillStyle = '#111';
    ctx.fillRect(bx, by, bw, bh);
    const fill = boostFuel / 100;
    const bColor = boosting ? '#0ff' : '#ff2266';
    ctx.fillStyle = bColor;
    ctx.shadowBlur = 6;
    ctx.shadowColor = bColor;
    ctx.fillRect(bx, by, bw * fill, bh);
    ctx.shadowBlur = 0;
  }

  ctx.restore();

  // HUD
  if (state === 'play' || state === 'dead') {
    document.getElementById('hudDist').textContent = Math.floor(distance);
    document.getElementById('hudSpeed').textContent = Math.floor(speed * 12);
    document.getElementById('hudMulti').textContent = 'x' + multiplier.toFixed(1);
  }
}

function drawRoad() {
  // Draw road as trapezoid
  const bottomL = W / 2 - ROAD_W / 2 - 30;
  const bottomR = W / 2 + ROAD_W / 2 + 30;
  const topL = W / 2 - 40;
  const topR = W / 2 + 40;

  // Road surface
  const grad = ctx.createLinearGradient(0, vanishY, 0, H);
  grad.addColorStop(0, '#111118');
  grad.addColorStop(1, '#0c0c14');
  ctx.fillStyle = grad;
  ctx.beginPath();
  ctx.moveTo(topL, vanishY);
  ctx.lineTo(topR, vanishY);
  ctx.lineTo(bottomR, H);
  ctx.lineTo(bottomL, H);
  ctx.closePath();
  ctx.fill();

  // Edge lines (neon)
  ctx.strokeStyle = '#0ff';
  ctx.shadowBlur = 10;
  ctx.shadowColor = '#0ff';
  ctx.lineWidth = 2;
  ctx.beginPath();
  ctx.moveTo(topL, vanishY);
  ctx.lineTo(bottomL, H);
  ctx.stroke();
  ctx.beginPath();
  ctx.moveTo(topR, vanishY);
  ctx.lineTo(bottomR, H);
  ctx.stroke();
  ctx.shadowBlur = 0;

  // Lane markers
  for (let l = 1; l < LANES; l++) {
    const frac = l / LANES;
    const bx = bottomL + (bottomR - bottomL) * frac;
    const tx = topL + (topR - topL) * frac;

    ctx.strokeStyle = 'rgba(0,255,255,0.15)';
    ctx.lineWidth = 1;
    ctx.setLineDash([20, 30]);
    // Animate dashes
    ctx.lineDashOffset = -(distance * 15) % 50;
    ctx.beginPath();
    ctx.moveTo(tx, vanishY);
    ctx.lineTo(bx, H);
    ctx.stroke();
    ctx.setLineDash([]);
  }

  // Road markings - periodic cross lines
  for (let z = (distance * 15) % 80; z < 600; z += 80) {
    const scale = 300 / (z + 1);
    const y = H - 60 - z * scale * 0.5;
    if (y < vanishY || y > H) continue;
    const progress = (y - vanishY) / (H - vanishY);
    const left = topL + (bottomL - topL) * progress;
    const right = topR + (bottomR - topR) * progress;

    ctx.strokeStyle = `rgba(0,255,255,${0.08 * (1 - progress * 0.5)})`;
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.moveTo(left, y);
    ctx.lineTo(right, y);
    ctx.stroke();
  }
}

function drawObstacles() {
  // Sort by z (far first)
  const sorted = [...obstacles].sort((a, b) => b.z - a.z);

  for (const obs of sorted) {
    if (obs.z < -20 || obs.z > 800) continue;

    const scale = 300 / (obs.z + 1);
    const roadFrac = (obs.lane + 0.5) / LANES;

    const bottomL = W / 2 - ROAD_W / 2 - 30;
    const bottomR = W / 2 + ROAD_W / 2 + 30;
    const topL = W / 2 - 40;
    const topR = W / 2 + 40;

    const y = H - 60 - obs.z * scale * 0.5;
    if (y < vanishY) continue;
    const progress = (y - vanishY) / (H - vanishY);
    const laneX = topL + (bottomL - topL) * progress + ((topR - topL) + (bottomR - bottomR - topR + topL) * progress) * roadFrac;

    // Simpler: use progress to interpolate x
    const leftAtY = topL + (bottomL - topL) * progress;
    const rightAtY = topR + (bottomR - topR) * progress;
    const cx = leftAtY + (rightAtY - leftAtY) * roadFrac;

    const w = obs.type.w * scale * 0.4;
    const h = obs.type.h * scale * 0.4;

    if (w < 1 || h < 1) continue;

    ctx.fillStyle = obs.type.color;
    ctx.shadowBlur = 12 * Math.min(1, scale);
    ctx.shadowColor = obs.type.glow;
    ctx.globalAlpha = Math.min(1, scale * 2);

    if (obs.type.name === 'mine') {
      // Pulsing mine circle
      const pulse = 0.7 + Math.sin(Date.now() * 0.008) * 0.3;
      const mineR = w * 0.5 * pulse;

      // Danger ring pulses outward
      const ringPhase = (Date.now() * 0.003) % 1;
      const ringR = mineR + w * 1.2 * ringPhase;
      ctx.strokeStyle = `rgba(255,17,51,${(1 - ringPhase) * 0.3 * ctx.globalAlpha})`;
      ctx.lineWidth = 1.5;
      ctx.beginPath();
      ctx.arc(cx, y - h / 2, ringR, 0, Math.PI * 2);
      ctx.stroke();

      // Second ring offset
      const ring2 = (Date.now() * 0.003 + 0.5) % 1;
      const ring2R = mineR + w * 1.2 * ring2;
      ctx.strokeStyle = `rgba(255,17,51,${(1 - ring2) * 0.2 * ctx.globalAlpha})`;
      ctx.beginPath();
      ctx.arc(cx, y - h / 2, ring2R, 0, Math.PI * 2);
      ctx.stroke();

      // Core glow
      const mineGrad = ctx.createRadialGradient(cx, y - h / 2, 0, cx, y - h / 2, mineR * 1.5);
      mineGrad.addColorStop(0, `rgba(255,17,51,${0.6 * pulse})`);
      mineGrad.addColorStop(0.5, `rgba(255,50,20,${0.3 * pulse})`);
      mineGrad.addColorStop(1, 'transparent');
      ctx.fillStyle = mineGrad;
      ctx.beginPath();
      ctx.arc(cx, y - h / 2, mineR * 1.5, 0, Math.PI * 2);
      ctx.fill();

      // Solid core
      ctx.fillStyle = obs.type.color;
      ctx.shadowBlur = 16 * Math.min(1, scale) * pulse;
      ctx.beginPath();
      ctx.arc(cx, y - h / 2, mineR, 0, Math.PI * 2);
      ctx.fill();

      // Inner dot
      ctx.fillStyle = '#ff8866';
      ctx.beginPath();
      ctx.arc(cx, y - h / 2, mineR * 0.35, 0, Math.PI * 2);
      ctx.fill();

    } else if (obs.type.name === 'spike') {
      ctx.beginPath();
      ctx.moveTo(cx, y - h);
      ctx.lineTo(cx + w / 2, y);
      ctx.lineTo(cx - w / 2, y);
      ctx.closePath();
      ctx.fill();
    } else {
      ctx.fillRect(cx - w / 2, y - h, w, h);
    }

    // Outline (skip for mines ‚Äî they have their own glow)
    if (obs.type.name !== 'mine') {
      ctx.strokeStyle = obs.type.glow;
      ctx.lineWidth = 1;
      ctx.globalAlpha *= 0.5;
      if (obs.type.name === 'spike') {
        ctx.beginPath();
        ctx.moveTo(cx, y - h);
        ctx.lineTo(cx + w / 2, y);
        ctx.lineTo(cx - w / 2, y);
        ctx.closePath();
        ctx.stroke();
      } else {
        ctx.strokeRect(cx - w / 2, y - h, w, h);
      }
    }

    ctx.globalAlpha = 1;
    ctx.shadowBlur = 0;
  }
}

function drawCar() {
  const cx = W / 2 + playerX;
  const cy = H - 70;

  ctx.save();
  ctx.translate(cx, cy);

  // Tilt based on steering
  const steerTilt = (targetX - playerX) * 0.003;
  ctx.rotate(steerTilt);

  // Car shadow
  ctx.fillStyle = 'rgba(0,0,0,0.3)';
  ctx.fillRect(-CAR_W / 2 + 3, -CAR_H / 2 + 5, CAR_W, CAR_H);

  // Car body
  const bodyGrad = ctx.createLinearGradient(0, -CAR_H / 2, 0, CAR_H / 2);
  bodyGrad.addColorStop(0, '#0af');
  bodyGrad.addColorStop(0.5, '#08c');
  bodyGrad.addColorStop(1, '#066');
  ctx.fillStyle = bodyGrad;

  // Rounded car shape
  ctx.beginPath();
  ctx.moveTo(-CAR_W / 2 + 6, CAR_H / 2);
  ctx.lineTo(-CAR_W / 2, CAR_H / 2 - 10);
  ctx.lineTo(-CAR_W / 2 + 2, -CAR_H / 2 + 10);
  ctx.lineTo(-CAR_W / 2 + 8, -CAR_H / 2);
  ctx.lineTo(CAR_W / 2 - 8, -CAR_H / 2);
  ctx.lineTo(CAR_W / 2 - 2, -CAR_H / 2 + 10);
  ctx.lineTo(CAR_W / 2, CAR_H / 2 - 10);
  ctx.lineTo(CAR_W / 2 - 6, CAR_H / 2);
  ctx.closePath();
  ctx.fill();

  // Neon edge
  ctx.strokeStyle = '#0ff';
  ctx.shadowBlur = boosting ? 20 : 10;
  ctx.shadowColor = boosting ? '#0ff' : '#0af';
  ctx.lineWidth = boosting ? 2 : 1.5;
  ctx.stroke();

  // Cockpit
  ctx.fillStyle = '#022';
  ctx.fillRect(-8, -12, 16, 16);
  ctx.strokeStyle = 'rgba(0,255,255,0.4)';
  ctx.lineWidth = 0.5;
  ctx.strokeRect(-8, -12, 16, 16);

  // Headlights
  ctx.fillStyle = '#0ff';
  ctx.shadowBlur = 8;
  ctx.shadowColor = '#0ff';
  ctx.fillRect(-12, -CAR_H / 2 - 2, 6, 4);
  ctx.fillRect(6, -CAR_H / 2 - 2, 6, 4);

  // Tail lights
  ctx.fillStyle = '#ff2266';
  ctx.shadowColor = '#ff2266';
  ctx.fillRect(-14, CAR_H / 2 - 4, 8, 3);
  ctx.fillRect(6, CAR_H / 2 - 4, 8, 3);

  ctx.shadowBlur = 0;
  ctx.restore();

  // Boost trail
  if (boosting) {
    ctx.fillStyle = 'rgba(0,255,255,0.15)';
    ctx.beginPath();
    ctx.moveTo(cx - 10, cy + CAR_H / 2);
    ctx.lineTo(cx + 10, cy + CAR_H / 2);
    ctx.lineTo(cx, cy + CAR_H / 2 + 40 + Math.random() * 20);
    ctx.closePath();
    ctx.fill();
  }
}

// --- Main Loop ---
let lastFrame = 0;
function loop(ts) {
  requestAnimationFrame(loop);
  const dt = ts - lastFrame;
  if (dt < 14) return; // cap ~70fps
  lastFrame = ts;

  update();
  draw();
}

// --- Init ---
resize();
requestAnimationFrame(loop);

document.getElementById('ovBtn').addEventListener('click', () => {
  startGame();
});

document.addEventListener('keydown', e => {
  if (e.code === 'Enter' && state === 'menu') startGame();
});
</script>
<script src="/sloppy-header/sloppy-bar.js"></script>
<script src="/vibelib-extended.js"></script>
<script>
  // Compatibility Patch for Legacy Apps
  window.addEventListener("load", () => {
    if (window.SloppyKarma && window.VibeLib.Economy) {
      // Redirect old calls to new engine
      window.SloppyKarma.track = window.VibeLib.Economy.track;
    }
  });
</script>
</body>
</html>
