<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Sloppy Civ</title>
  <link rel="icon" href="https://emojicdn.elk.sh/üèõÔ∏è">
  <meta property="og:title" content="Sloppy Civ">
  <meta property="og:description" content="Minimalist hex-grid civilization builder">
  <meta property="og:url" content="https://sloppy.live/sloppy-civ">
  <meta property="og:image" content="https://emojicdn.elk.sh/üèõÔ∏è?style=apple&size=512">
  <link href="https://fonts.googleapis.com/css2?family=Space+Mono:wght@400;700&display=swap" rel="stylesheet">
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }

    :root {
      --bg: #0a0a0f;
      --panel: #12121a;
      --border: #2a2a3f;
      --text: #e8e8e8;
      --muted: #6b7b8f;
      --bitcoin: #f7931a;
      --fans: #00ffff;
      --crystal: #ff00ff;
      --energy: #00ff00;
      --accent: #3498db;
    }

    body {
      background: var(--bg);
      font-family: 'Space Mono', monospace;
      color: var(--text);
      overflow: hidden;
      height: 100vh;
    }

    .game-container {
      display: flex;
      height: 100vh;
    }

    /* Side Panel */
    .panel {
      width: 280px;
      background: var(--panel);
      border-right: 1px solid var(--border);
      padding: 20px;
      display: flex;
      flex-direction: column;
      gap: 20px;
      overflow-y: auto;
    }

    .panel h1 {
      font-size: 1.4rem;
      color: var(--fans);
      letter-spacing: 2px;
      text-align: center;
      padding-bottom: 15px;
      border-bottom: 1px solid var(--border);
      text-shadow: 0 0 20px var(--fans);
    }

    .section {
      background: rgba(0,0,0,0.2);
      border-radius: 8px;
      padding: 15px;
    }

    .section-title {
      font-size: 0.7rem;
      color: var(--muted);
      text-transform: uppercase;
      letter-spacing: 1px;
      margin-bottom: 12px;
    }

    .resources {
      display: flex;
      flex-direction: column;
      gap: 10px;
    }

    .resource {
      display: flex;
      align-items: center;
      justify-content: space-between;
    }

    .resource-icon {
      width: 24px;
      height: 24px;
      border-radius: 4px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 0.8rem;
    }

    .resource-icon.bitcoin { background: var(--bitcoin); color: #000; box-shadow: 0 0 10px var(--bitcoin); }
    .resource-icon.fans { background: var(--fans); color: #000; box-shadow: 0 0 10px var(--fans); }
    .resource-icon.crystal { background: var(--crystal); color: #fff; box-shadow: 0 0 10px var(--crystal); }
    .resource-icon.energy { background: var(--energy); color: #000; box-shadow: 0 0 10px var(--energy); }

    .resource-info {
      flex: 1;
      margin-left: 10px;
    }

    .resource-name {
      font-size: 0.75rem;
      color: var(--muted);
    }

    .resource-value {
      font-size: 1rem;
      font-weight: 700;
    }

    .resource-rate {
      font-size: 0.7rem;
      color: var(--energy);
    }

    /* Build Menu */
    .build-options {
      display: flex;
      flex-direction: column;
      gap: 8px;
    }

    .build-btn {
      background: rgba(52, 152, 219, 0.1);
      border: 1px solid var(--border);
      color: var(--text);
      padding: 12px;
      border-radius: 6px;
      cursor: pointer;
      text-align: left;
      transition: all 0.2s;
      font-family: inherit;
      font-size: 0.8rem;
    }

    .build-btn:hover {
      border-color: var(--accent);
      background: rgba(52, 152, 219, 0.2);
    }

    .build-btn.selected {
      border-color: var(--fans);
      background: rgba(0, 255, 255, 0.1);
      box-shadow: 0 0 15px rgba(0, 255, 255, 0.3);
    }

    .build-btn.disabled {
      opacity: 0.4;
      cursor: not-allowed;
    }

    .build-name {
      font-weight: 700;
      margin-bottom: 4px;
    }

    .build-cost {
      font-size: 0.7rem;
      color: var(--muted);
    }

    .build-desc {
      font-size: 0.65rem;
      color: var(--muted);
      margin-top: 4px;
    }

    /* Turn Button */
    .turn-btn {
      background: linear-gradient(135deg, var(--fans), var(--crystal));
      border: none;
      color: #000;
      padding: 14px;
      border-radius: 6px;
      cursor: pointer;
      font-family: inherit;
      font-size: 0.9rem;
      font-weight: 700;
      letter-spacing: 1px;
      transition: all 0.2s;
      box-shadow: 0 0 20px rgba(0, 255, 255, 0.3);
    }

    .turn-btn:hover {
      transform: translateY(-2px);
      box-shadow: 0 4px 20px rgba(0, 255, 255, 0.5), 0 0 30px rgba(255, 0, 255, 0.3);
    }

    .turn-counter {
      text-align: center;
      font-size: 0.8rem;
      color: var(--muted);
    }

    .turn-counter span {
      color: var(--fans);
      font-weight: 700;
      text-shadow: 0 0 10px var(--fans);
    }

    /* Stats */
    .stats {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 10px;
    }

    .stat-box {
      text-align: center;
      padding: 10px;
      background: rgba(0,0,0,0.2);
      border-radius: 6px;
    }

    .stat-value {
      font-size: 1.2rem;
      font-weight: 700;
      color: var(--accent);
    }

    .stat-label {
      font-size: 0.6rem;
      color: var(--muted);
      text-transform: uppercase;
    }

    /* Canvas Area */
    .canvas-container {
      flex: 1;
      position: relative;
      overflow: hidden;
    }

    canvas {
      display: block;
      cursor: pointer;
    }

    /* Tile Info Tooltip */
    .tooltip {
      position: absolute;
      background: var(--panel);
      border: 1px solid var(--border);
      border-radius: 6px;
      padding: 10px 14px;
      pointer-events: none;
      opacity: 0;
      transition: opacity 0.2s;
      z-index: 100;
      font-size: 0.8rem;
      min-width: 120px;
    }

    .tooltip.visible {
      opacity: 1;
    }

    .tooltip-title {
      font-weight: 700;
      margin-bottom: 4px;
    }

    .tooltip-info {
      color: var(--muted);
      font-size: 0.7rem;
    }

    /* Messages */
    .message {
      position: fixed;
      top: 20px;
      left: 50%;
      transform: translateX(-50%);
      background: var(--panel);
      border: 1px solid var(--fans);
      padding: 12px 24px;
      border-radius: 6px;
      z-index: 200;
      animation: slideDown 0.3s ease, fadeOut 0.3s ease 2s forwards;
      box-shadow: 0 0 20px rgba(0, 255, 255, 0.3);
    }

    @keyframes slideDown {
      from { transform: translateX(-50%) translateY(-20px); opacity: 0; }
      to { transform: translateX(-50%) translateY(0); opacity: 1; }
    }

    @keyframes fadeOut {
      to { opacity: 0; }
    }

    .back-link {
      position: fixed;
      bottom: 10px;
      right: 10px;
      color: var(--muted);
      text-decoration: none;
      font-size: 0.7rem;
      z-index: 100;
    }

    .back-link:hover {
      color: var(--fans);
    }

    @media (max-width: 700px) {
      .panel { width: 220px; padding: 15px; }
      .panel h1 { font-size: 1.1rem; }
    }

    @media (max-width: 500px) {
      .game-container { flex-direction: column; }
      .panel { width: 100%; height: auto; max-height: 40vh; border-right: none; border-bottom: 1px solid var(--border); }
      .canvas-container { flex: 1; min-height: 60vh; }
    }
  </style>
</head>
<body>
  <div class="game-container">
    <div class="panel">
      <h1>SLOPPY CIV</h1>

      <div class="section">
        <div class="section-title">Resources</div>
        <div class="resources">
          <div class="resource">
            <div class="resource-icon bitcoin">‚Çø</div>
            <div class="resource-info">
              <div class="resource-name">Bitcoin</div>
              <div class="resource-value" id="res-bitcoin">50</div>
            </div>
            <div class="resource-rate" id="rate-bitcoin">+0</div>
          </div>
          <div class="resource">
            <div class="resource-icon fans">üåÄ</div>
            <div class="resource-info">
              <div class="resource-name">Cooling Fans</div>
              <div class="resource-value" id="res-fans">20</div>
            </div>
            <div class="resource-rate" id="rate-fans">+0</div>
          </div>
          <div class="resource">
            <div class="resource-icon crystal">üíé</div>
            <div class="resource-info">
              <div class="resource-name">Data Crystals</div>
              <div class="resource-value" id="res-crystal">10</div>
            </div>
            <div class="resource-rate" id="rate-crystal">+0</div>
          </div>
          <div class="resource">
            <div class="resource-icon energy">‚ö°</div>
            <div class="resource-info">
              <div class="resource-name">Energy</div>
              <div class="resource-value" id="res-energy">30</div>
            </div>
            <div class="resource-rate" id="rate-energy">+0</div>
          </div>
        </div>
      </div>

      <div class="section">
        <div class="section-title">Build</div>
        <div class="build-options" id="build-options">
          <button class="build-btn" data-building="node">
            <div class="build-name">üñ•Ô∏è Server Node</div>
            <div class="build-cost">20 Fans, 10 Crystals</div>
            <div class="build-desc">+2 BTC/turn, claims adjacent tiles</div>
          </button>
          <button class="build-btn" data-building="reactor">
            <div class="build-name">‚ö° Power Reactor</div>
            <div class="build-cost">10 Fans, 5 BTC</div>
            <div class="build-desc">+3 Energy/turn (place on plains)</div>
          </button>
          <button class="build-btn" data-building="cooler">
            <div class="build-name">‚ùÑÔ∏è Cooling Station</div>
            <div class="build-cost">15 BTC</div>
            <div class="build-desc">+3 Fans/turn (place on tundra)</div>
          </button>
          <button class="build-btn" data-building="mine">
            <div class="build-name">üíé Crystal Mine</div>
            <div class="build-cost">20 BTC, 10 Fans</div>
            <div class="build-desc">+2 Crystals/turn (place on mountains)</div>
          </button>
          <button class="build-btn" data-building="exchange">
            <div class="build-name">üìà Crypto Exchange</div>
            <div class="build-cost">30 Fans, 20 Crystals</div>
            <div class="build-desc">+5 BTC/turn (place on node)</div>
          </button>
        </div>
      </div>

      <div class="section">
        <div class="section-title">Statistics</div>
        <div class="stats">
          <div class="stat-box">
            <div class="stat-value" id="stat-tiles">0</div>
            <div class="stat-label">Tiles</div>
          </div>
          <div class="stat-box">
            <div class="stat-value" id="stat-buildings">0</div>
            <div class="stat-label">Buildings</div>
          </div>
        </div>
      </div>

      <div class="turn-counter">Turn <span id="turn-number">1</span></div>
      <button class="turn-btn" id="next-turn">END TURN ‚Üí</button>
    </div>

    <div class="canvas-container">
      <canvas id="game-canvas"></canvas>
      <div class="tooltip" id="tooltip">
        <div class="tooltip-title">Plains</div>
        <div class="tooltip-info">Empty tile</div>
      </div>
    </div>
  </div>

  <a href="https://sloppy.live" class="back-link">‚Üê sloppy.live</a>

  <script>
    const canvas = document.getElementById('game-canvas');
    const ctx = canvas.getContext('2d');
    const tooltip = document.getElementById('tooltip');

    // Hex dimensions
    const HEX_SIZE = 40;
    const HEX_WIDTH = HEX_SIZE * 2;
    const HEX_HEIGHT = Math.sqrt(3) * HEX_SIZE;

    // Game state
    let gameState = {
      turn: 1,
      resources: { bitcoin: 50, fans: 20, crystal: 10, energy: 30 },
      rates: { bitcoin: 0, fans: 0, crystal: 0, energy: 0 },
      selectedBuilding: null,
      tiles: [],
      buildings: [],
      claimed: new Set()
    };

    // Terrain types - Neon cyber theme
    const TERRAINS = {
      grid: { color: '#1a3a2a', name: 'Data Grid', resource: null },
      tundra: { color: '#0a4a5a', name: 'Cooling Tundra', resource: 'fans' },
      mountain: { color: '#3a1a4a', name: 'Crystal Peak', resource: 'crystal' },
      void: { color: '#0a0a1a', name: 'Digital Void', resource: null, blocked: true },
      wasteland: { color: '#4a3a0a', name: 'Bitcoin Wasteland', resource: 'bitcoin' }
    };

    // Building definitions - Neon cyber theme
    const BUILDINGS = {
      node: {
        name: 'Server Node',
        icon: 'üñ•Ô∏è',
        cost: { fans: 20, crystal: 10 },
        production: { bitcoin: 2 },
        validTerrain: ['grid', 'wasteland'],
        claimRadius: 1
      },
      reactor: {
        name: 'Power Reactor',
        icon: '‚ö°',
        cost: { fans: 10, bitcoin: 5 },
        production: { energy: 3 },
        validTerrain: ['grid']
      },
      cooler: {
        name: 'Cooling Station',
        icon: '‚ùÑÔ∏è',
        cost: { bitcoin: 15 },
        production: { fans: 3 },
        validTerrain: ['tundra']
      },
      mine: {
        name: 'Crystal Mine',
        icon: 'üíé',
        cost: { bitcoin: 20, fans: 10 },
        production: { crystal: 2 },
        validTerrain: ['mountain']
      },
      exchange: {
        name: 'Crypto Exchange',
        icon: 'üìà',
        cost: { fans: 30, crystal: 20 },
        production: { bitcoin: 5 },
        requiresBuilding: 'node'
      }
    };

    // Grid setup
    const GRID_WIDTH = 15;
    const GRID_HEIGHT = 11;
    let offsetX = 0, offsetY = 0;

    function resizeCanvas() {
      const container = canvas.parentElement;
      canvas.width = container.clientWidth;
      canvas.height = container.clientHeight;

      offsetX = canvas.width / 2 - (GRID_WIDTH * HEX_WIDTH * 0.75) / 2;
      offsetY = canvas.height / 2 - (GRID_HEIGHT * HEX_HEIGHT) / 2;

      render();
    }

    function generateMap() {
      gameState.tiles = [];

      for (let q = 0; q < GRID_WIDTH; q++) {
        for (let r = 0; r < GRID_HEIGHT; r++) {
          const rand = Math.random();
          let terrain;

          if (rand < 0.35) terrain = 'grid';
          else if (rand < 0.55) terrain = 'tundra';
          else if (rand < 0.70) terrain = 'mountain';
          else if (rand < 0.85) terrain = 'void';
          else terrain = 'wasteland';

          // Ensure starting area is grid
          const centerQ = Math.floor(GRID_WIDTH / 2);
          const centerR = Math.floor(GRID_HEIGHT / 2);
          if (Math.abs(q - centerQ) <= 1 && Math.abs(r - centerR) <= 1) {
            terrain = 'grid';
          }

          gameState.tiles.push({
            q, r,
            terrain,
            building: null,
            resourceNode: TERRAINS[terrain].resource && Math.random() > 0.5
          });
        }
      }

      // Place initial server node
      const centerTile = getTile(Math.floor(GRID_WIDTH / 2), Math.floor(GRID_HEIGHT / 2));
      if (centerTile) {
        centerTile.building = 'node';
        gameState.buildings.push({ q: centerTile.q, r: centerTile.r, type: 'node' });
        claimTiles(centerTile.q, centerTile.r, 1);
      }

      calculateRates();
    }

    function getTile(q, r) {
      return gameState.tiles.find(t => t.q === q && t.r === r);
    }

    function hexToPixel(q, r) {
      const x = HEX_SIZE * (3/2 * q);
      const y = HEX_SIZE * (Math.sqrt(3)/2 * q + Math.sqrt(3) * r);
      return { x: x + offsetX, y: y + offsetY };
    }

    function pixelToHex(x, y) {
      const px = x - offsetX;
      const py = y - offsetY;
      const q = (2/3 * px) / HEX_SIZE;
      const r = (-1/3 * px + Math.sqrt(3)/3 * py) / HEX_SIZE;
      return hexRound(q, r);
    }

    function hexRound(q, r) {
      const s = -q - r;
      let rq = Math.round(q);
      let rr = Math.round(r);
      let rs = Math.round(s);

      const qDiff = Math.abs(rq - q);
      const rDiff = Math.abs(rr - r);
      const sDiff = Math.abs(rs - s);

      if (qDiff > rDiff && qDiff > sDiff) {
        rq = -rr - rs;
      } else if (rDiff > sDiff) {
        rr = -rq - rs;
      }

      return { q: rq, r: rr };
    }

    function getHexNeighbors(q, r) {
      const directions = [
        [1, 0], [1, -1], [0, -1],
        [-1, 0], [-1, 1], [0, 1]
      ];
      return directions.map(([dq, dr]) => ({ q: q + dq, r: r + dr }));
    }

    function claimTiles(q, r, radius) {
      gameState.claimed.add(`${q},${r}`);
      if (radius > 0) {
        const neighbors = getHexNeighbors(q, r);
        neighbors.forEach(n => {
          gameState.claimed.add(`${n.q},${n.r}`);
        });
      }
    }

    function isClaimed(q, r) {
      return gameState.claimed.has(`${q},${r}`);
    }

    function drawHex(x, y, size, fillColor, strokeColor, claimed = false) {
      ctx.beginPath();
      for (let i = 0; i < 6; i++) {
        const angle = Math.PI / 180 * (60 * i - 30);
        const hx = x + size * Math.cos(angle);
        const hy = y + size * Math.sin(angle);
        if (i === 0) ctx.moveTo(hx, hy);
        else ctx.lineTo(hx, hy);
      }
      ctx.closePath();

      ctx.fillStyle = fillColor;
      ctx.fill();

      if (claimed) {
        ctx.fillStyle = 'rgba(244, 208, 63, 0.15)';
        ctx.fill();
      }

      ctx.strokeStyle = strokeColor;
      ctx.lineWidth = claimed ? 2 : 1;
      ctx.stroke();
    }

    function render() {
      ctx.fillStyle = '#0f0f1a';
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      // Draw tiles
      gameState.tiles.forEach(tile => {
        const { x, y } = hexToPixel(tile.q, tile.r);
        const terrain = TERRAINS[tile.terrain];
        const claimed = isClaimed(tile.q, tile.r);

        // Darken unclaimed tiles
        let color = terrain.color;
        if (!claimed) {
          color = shadeColor(color, -40);
        }

        const strokeColor = claimed ? '#f4d03f' : '#1a1a2e';
        drawHex(x, y, HEX_SIZE - 2, color, strokeColor, claimed);

        // Draw resource node indicator
        if (tile.resourceNode && !tile.building) {
          ctx.fillStyle = 'rgba(255,255,255,0.6)';
          ctx.beginPath();
          ctx.arc(x, y, 6, 0, Math.PI * 2);
          ctx.fill();
        }

        // Draw building
        if (tile.building) {
          const building = BUILDINGS[tile.building];
          ctx.font = '20px sans-serif';
          ctx.textAlign = 'center';
          ctx.textBaseline = 'middle';
          ctx.fillText(building.icon, x, y);
        }
      });

      // Highlight valid placement tiles if building selected
      if (gameState.selectedBuilding) {
        gameState.tiles.forEach(tile => {
          if (canBuild(tile, gameState.selectedBuilding)) {
            const { x, y } = hexToPixel(tile.q, tile.r);
            ctx.strokeStyle = '#00ff00';
            ctx.lineWidth = 3;
            ctx.beginPath();
            for (let i = 0; i < 6; i++) {
              const angle = Math.PI / 180 * (60 * i - 30);
              const hx = x + (HEX_SIZE - 4) * Math.cos(angle);
              const hy = y + (HEX_SIZE - 4) * Math.sin(angle);
              if (i === 0) ctx.moveTo(hx, hy);
              else ctx.lineTo(hx, hy);
            }
            ctx.closePath();
            ctx.stroke();
          }
        });
      }
    }

    function shadeColor(color, percent) {
      const num = parseInt(color.replace('#', ''), 16);
      const amt = Math.round(2.55 * percent);
      const R = (num >> 16) + amt;
      const G = (num >> 8 & 0x00FF) + amt;
      const B = (num & 0x0000FF) + amt;
      return '#' + (0x1000000 +
        (R < 255 ? R < 1 ? 0 : R : 255) * 0x10000 +
        (G < 255 ? G < 1 ? 0 : G : 255) * 0x100 +
        (B < 255 ? B < 1 ? 0 : B : 255)
      ).toString(16).slice(1);
    }

    function canAfford(cost) {
      for (const [res, amount] of Object.entries(cost)) {
        if ((gameState.resources[res] || 0) < amount) return false;
      }
      return true;
    }

    function canBuild(tile, buildingType) {
      const building = BUILDINGS[buildingType];
      if (!building) return false;
      if (tile.building && buildingType !== 'exchange') return false;
      if (buildingType === 'exchange' && tile.building !== 'node') return false;
      if (TERRAINS[tile.terrain].blocked) return false;
      if (!isClaimed(tile.q, tile.r)) return false;
      if (building.validTerrain && !building.validTerrain.includes(tile.terrain)) return false;
      return canAfford(building.cost);
    }

    function build(tile, buildingType) {
      const building = BUILDINGS[buildingType];

      // Deduct cost
      for (const [res, amount] of Object.entries(building.cost)) {
        gameState.resources[res] -= amount;
      }

      // Place building
      if (buildingType === 'exchange') {
        // Exchange upgrades server node
        const existing = gameState.buildings.find(b => b.q === tile.q && b.r === tile.r);
        if (existing) existing.type = 'exchange';
        tile.building = 'exchange';
      } else {
        tile.building = buildingType;
        gameState.buildings.push({ q: tile.q, r: tile.r, type: buildingType });
      }

      // Claim tiles if settlement
      if (building.claimRadius) {
        claimTiles(tile.q, tile.r, building.claimRadius);
      }

      calculateRates();
      updateUI();
      render();
      showMessage(`Built ${building.name}!`);
    }

    function calculateRates() {
      const rates = { bitcoin: 0, fans: 0, crystal: 0, energy: 0 };

      gameState.buildings.forEach(b => {
        const building = BUILDINGS[b.type];
        if (building && building.production) {
          for (const [res, amount] of Object.entries(building.production)) {
            rates[res] += amount;
          }
        }
      });

      // Bonus from resource nodes
      gameState.tiles.forEach(tile => {
        if (tile.building && tile.resourceNode) {
          const terrain = TERRAINS[tile.terrain];
          if (terrain.resource) {
            rates[terrain.resource] += 1;
          }
        }
      });

      gameState.rates = rates;
    }

    function nextTurn() {
      // Apply production
      for (const [res, rate] of Object.entries(gameState.rates)) {
        gameState.resources[res] += rate;
      }

      gameState.turn++;
      updateUI();
      render();
    }

    function updateUI() {
      document.getElementById('res-bitcoin').textContent = gameState.resources.bitcoin;
      document.getElementById('res-fans').textContent = gameState.resources.fans;
      document.getElementById('res-crystal').textContent = gameState.resources.crystal;
      document.getElementById('res-energy').textContent = gameState.resources.energy;

      document.getElementById('rate-bitcoin').textContent = `+${gameState.rates.bitcoin}`;
      document.getElementById('rate-fans').textContent = `+${gameState.rates.fans}`;
      document.getElementById('rate-crystal').textContent = `+${gameState.rates.crystal}`;
      document.getElementById('rate-energy').textContent = `+${gameState.rates.energy}`;

      document.getElementById('turn-number').textContent = gameState.turn;
      document.getElementById('stat-tiles').textContent = gameState.claimed.size;
      document.getElementById('stat-buildings').textContent = gameState.buildings.length;

      // Update build buttons
      document.querySelectorAll('.build-btn').forEach(btn => {
        const type = btn.dataset.building;
        const building = BUILDINGS[type];
        const affordable = canAfford(building.cost);
        btn.classList.toggle('disabled', !affordable);
        btn.classList.toggle('selected', gameState.selectedBuilding === type);
      });
    }

    function showMessage(text) {
      const msg = document.createElement('div');
      msg.className = 'message';
      msg.textContent = text;
      document.body.appendChild(msg);
      setTimeout(() => msg.remove(), 2500);
    }

    // Event listeners
    canvas.addEventListener('click', (e) => {
      const rect = canvas.getBoundingClientRect();
      const { q, r } = pixelToHex(e.clientX - rect.left, e.clientY - rect.top);
      const tile = getTile(q, r);

      if (tile && gameState.selectedBuilding) {
        if (canBuild(tile, gameState.selectedBuilding)) {
          build(tile, gameState.selectedBuilding);
          gameState.selectedBuilding = null;
          updateUI();
        }
      }
    });

    canvas.addEventListener('mousemove', (e) => {
      const rect = canvas.getBoundingClientRect();
      const { q, r } = pixelToHex(e.clientX - rect.left, e.clientY - rect.top);
      const tile = getTile(q, r);

      if (tile) {
        const terrain = TERRAINS[tile.terrain];
        let info = isClaimed(tile.q, tile.r) ? 'Claimed' : 'Unclaimed';
        if (tile.building) {
          info = BUILDINGS[tile.building].name;
        } else if (tile.resourceNode) {
          info += ' ‚Ä¢ Resource node';
        }

        tooltip.querySelector('.tooltip-title').textContent = terrain.name;
        tooltip.querySelector('.tooltip-info').textContent = info;
        tooltip.style.left = (e.clientX - rect.left + 15) + 'px';
        tooltip.style.top = (e.clientY - rect.top + 15) + 'px';
        tooltip.classList.add('visible');
      } else {
        tooltip.classList.remove('visible');
      }
    });

    canvas.addEventListener('mouseleave', () => {
      tooltip.classList.remove('visible');
    });

    document.querySelectorAll('.build-btn').forEach(btn => {
      btn.addEventListener('click', () => {
        const type = btn.dataset.building;
        if (canAfford(BUILDINGS[type].cost)) {
          gameState.selectedBuilding = gameState.selectedBuilding === type ? null : type;
          updateUI();
          render();
        }
      });
    });

    document.getElementById('next-turn').addEventListener('click', nextTurn);

    // Initialize
    window.addEventListener('resize', resizeCanvas);
    generateMap();
    resizeCanvas();
    updateUI();
  </script>
</body>
</html>
