<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Springfield Road Rush â€” Three.js Drive</title>
    <meta
      name="description"
      content="Race through a low-poly Springfield inspired by Simpsons Road Rage. Custom Three.js playground with handmade textures and no sound."
    />
    <meta property="og:title" content="Springfield Road Rush" />
    <meta
      property="og:description"
      content="Hop in the Pink Sedan, drift past blocky Springfield landmarks, and grab donuts before the timer runs out."
    />
    <meta property="og:type" content="website" />
    <meta property="og:url" content="https://app.vibecodedbyx.com/simpsons-road-rage/" />
    <meta property="og:image" content="https://app.vibecodedbyx.com/simpsons-road-rage/og-image.png" />
    <meta name="twitter:card" content="summary_large_image" />
    <meta name="twitter:title" content="Springfield Road Rush" />
    <meta name="twitter:description" content="A Simpsons Road Rage inspired Three.js mini racer with original textures." />
    <meta name="twitter:image" content="https://app.vibecodedbyx.com/simpsons-road-rage/og-image.png" />
    <link rel="icon" href="./favicon.svg" type="image/svg+xml" />
    <meta name="theme-color" content="#fdda42" />
    <style>
      :root {
        color-scheme: light;
        font-family: "Inter", "Segoe UI", sans-serif;
        --hud-bg: rgba(255, 255, 255, 0.78);
        --hud-border: rgba(17, 24, 39, 0.18);
        --accent: #ff6b6b;
        --text: #101222;
      }

      *, *::before, *::after {
        box-sizing: border-box;
      }

      body {
        margin: 0;
        background: radial-gradient(circle at 20% -10%, rgba(255, 247, 131, 0.6), transparent 65%), #87ceeb;
        color: var(--text);
        overflow: hidden;
      }

      canvas {
        display: block;
      }

      .hud {
        position: fixed;
        top: 16px;
        left: 16px;
        display: grid;
        gap: 12px;
        padding: 16px 18px;
        max-width: min(340px, 80vw);
        background: var(--hud-bg);
        border: 1px solid var(--hud-border);
        border-radius: 18px;
        backdrop-filter: blur(12px);
        box-shadow: 0 14px 32px rgba(17, 24, 39, 0.16);
      }

      .hud h1 {
        margin: 0;
        font-size: 1.4rem;
        letter-spacing: 0.08em;
        text-transform: uppercase;
      }

      .hud p {
        margin: 0;
        font-size: 0.92rem;
        line-height: 1.5;
      }

      .status-grid {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(110px, 1fr));
        gap: 8px;
      }

      .status {
        background: rgba(255, 255, 255, 0.8);
        border-radius: 12px;
        padding: 8px 10px;
        border: 1px solid rgba(17, 24, 39, 0.08);
        text-align: center;
      }

      .status .label {
        display: block;
        font-size: 0.7rem;
        letter-spacing: 0.16em;
        text-transform: uppercase;
        color: rgba(17, 24, 39, 0.56);
      }

      .status .value {
        font-size: 1.05rem;
        font-weight: 600;
      }

      .hud a {
        color: var(--accent);
        text-decoration: none;
        font-weight: 600;
      }

      .hud a:hover,
      .hud a:focus-visible {
        text-decoration: underline;
      }

      #message {
        font-size: 0.9rem;
        color: rgba(17, 24, 39, 0.72);
      }

      .mobile-hint {
        display: none;
        font-size: 0.85rem;
        color: rgba(17, 24, 39, 0.7);
      }

      @media (max-width: 720px), (hover: none) {
        .hud {
          max-width: 92vw;
          padding: 14px 16px;
        }
        .mobile-hint {
          display: block;
        }
      }

      .touch-controls {
        position: fixed;
        bottom: 18px;
        right: 20px;
        display: none;
        gap: 10px;
        pointer-events: none;
      }

      .touch-controls button {
        width: 56px;
        height: 56px;
        border-radius: 16px;
        border: 1px solid rgba(17, 24, 39, 0.18);
        background: rgba(255, 255, 255, 0.82);
        color: rgba(17, 24, 39, 0.8);
        font-size: 1.4rem;
        font-weight: 600;
        pointer-events: auto;
      }

      .touch-stick {
        position: fixed;
        bottom: 18px;
        left: 20px;
        width: 120px;
        height: 120px;
        border-radius: 50%;
        border: 1px solid rgba(17, 24, 39, 0.16);
        background: rgba(255, 255, 255, 0.5);
        pointer-events: auto;
        touch-action: none;
        display: none;
      }

      .touch-stick::after {
        content: "";
        position: absolute;
        width: 60px;
        height: 60px;
        border-radius: 50%;
        background: rgba(255, 255, 255, 0.82);
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
      }

      @media (hover: none) {
        .touch-controls,
        .touch-stick {
          display: block;
        }
      }
    </style>
  </head>
  <body>
    <div class="hud" id="hud">
      <h1>Springfield Road Rush</h1>
      <p>
        Arrow keys or WASD steer the Pink Sedan. Hold Space for turbo. Collect donuts, avoid buses, and beat the clock across
        blocky Springfield.
      </p>
      <div class="status-grid">
        <div class="status"><span class="label">Timer</span><span class="value" id="timer">60.0</span></div>
        <div class="status"><span class="label">Donuts</span><span class="value" id="donuts">0</span></div>
        <div class="status"><span class="label">Speed</span><span class="value" id="speed">0</span></div>
      </div>
      <p id="message">Deliveries pending â€” cruise past Moe's and the Nuclear Plant for bonus donuts.</p>
      <p class="mobile-hint">Drag left circle to steer, tap â–² for boost, â­• brake, ðŸŒŸ place-hold to reset.</p>
      <a href="https://www.vibecodedbyx.com" target="_blank" rel="noreferrer noopener">â¬… Back to the livestream</a>
    </div>

    <div class="touch-stick" id="touchStick"></div>
    <div class="touch-controls" id="touchButtons">
      <button id="boostBtn" aria-label="Boost">â–²</button>
      <button id="brakeBtn" aria-label="Brake">â­•</button>
      <button id="resetBtn" aria-label="Reset">âŸ³</button>
    </div>

    <script type="importmap">
      {
        "imports": {
          "three": "https://cdn.jsdelivr.net/npm/three@0.167.0/build/three.module.js",
          "three/examples/": "https://cdn.jsdelivr.net/npm/three@0.167.0/examples/"
        }
      }
    </script>

    <script type="module">
      import * as THREE from "three";
      import { OrbitControls } from "three/examples/jsm/controls/OrbitControls.js";

      const scene = new THREE.Scene();
      scene.background = new THREE.Color(0x87ceeb);
      scene.fog = new THREE.Fog(0x87ceeb, 80, 220);

      const renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
      renderer.shadowMap.enabled = true;
      document.body.appendChild(renderer.domElement);

      const camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.1, 400);
      camera.position.set(0, 12, 18);

      const orbit = new OrbitControls(camera, renderer.domElement);
      orbit.enableDamping = true;
      orbit.target.set(0, 3, 0);
      orbit.maxDistance = 200;
      orbit.maxPolarAngle = Math.PI / 2.1;
      orbit.enablePan = false;
      orbit.dampingFactor = 0.08;

      const hemiLight = new THREE.HemisphereLight(0xfff7a6, 0x1e2a4f, 0.9);
      scene.add(hemiLight);

      const sun = new THREE.DirectionalLight(0xffffff, 0.9);
      sun.position.set(-80, 120, 60);
      sun.castShadow = true;
      sun.shadow.mapSize.set(2048, 2048);
      sun.shadow.camera.left = -120;
      sun.shadow.camera.right = 120;
      sun.shadow.camera.top = 120;
      sun.shadow.camera.bottom = -120;
      scene.add(sun);

      const world = new THREE.Group();
      scene.add(world);

      const textures = createTextures();

      const ground = new THREE.Mesh(new THREE.PlaneGeometry(400, 400), textures.grass);
      ground.rotation.x = -Math.PI / 2;
      ground.receiveShadow = true;
      world.add(ground);

      const road = buildRoadNetwork();
      world.add(road);

      const buildings = buildBuildings();
      world.add(buildings);

      const donutsGroup = new THREE.Group();
      world.add(donutsGroup);
      populateDonuts();

      const trafficGroup = new THREE.Group();
      world.add(trafficGroup);
      spawnTraffic();

      const car = buildCar();
      world.add(car.mesh);

      const dustGroup = new THREE.Group();
      world.add(dustGroup);

      const clock = new THREE.Clock();
      let elapsed = 0;
      const TOTAL_TIME = 75;

      const keyState = {};
      document.addEventListener("keydown", (e) => (keyState[e.code] = true));
      document.addEventListener("keyup", (e) => (keyState[e.code] = false));

      const touchStick = document.getElementById("touchStick");
      const boostBtn = document.getElementById("boostBtn");
      const brakeBtn = document.getElementById("brakeBtn");
      const resetBtn = document.getElementById("resetBtn");
      setupTouchControls();

      const timerEl = document.getElementById("timer");
      const donutsEl = document.getElementById("donuts");
      const speedEl = document.getElementById("speed");
      const messageEl = document.getElementById("message");

      const state = {
        donuts: 0,
        bestCombo: 0,
        combo: 0,
        timeBonus: 0,
        playing: true,
      };

      function buildCar() {
        const group = new THREE.Group();
        group.castShadow = true;

        const body = new THREE.Mesh(new THREE.BoxGeometry(2.8, 1.1, 5), textures.carBodyPink);
        body.position.y = 1.2;
        body.castShadow = true;
        group.add(body);

        const roof = new THREE.Mesh(new THREE.BoxGeometry(2.6, 0.9, 2.4), textures.carRoofYellow);
        roof.position.set(0, 1.9, -0.4);
        roof.castShadow = true;
        group.add(roof);

        const bumper = new THREE.Mesh(new THREE.BoxGeometry(2.9, 0.6, 0.6), textures.carBumper);
        bumper.position.set(0, 0.8, 2.4);
        group.add(bumper);

        const wheelGeo = new THREE.CylinderGeometry(0.6, 0.6, 0.4, 20);
        wheelGeo.rotateZ(Math.PI / 2);
        const wheelMat = new THREE.MeshStandardMaterial({ color: 0x222222, roughness: 0.6 });
        const wheelPositions = [
          [-1.4, 0.6, 1.8],
          [1.4, 0.6, 1.8],
          [-1.4, 0.6, -1.8],
          [1.4, 0.6, -1.8],
        ];
        wheelPositions.forEach((pos) => {
          const wheel = new THREE.Mesh(wheelGeo, wheelMat);
          wheel.position.set(...pos);
          wheel.castShadow = true;
          group.add(wheel);
        });

        const carState = {
          mesh: group,
          velocity: new THREE.Vector3(),
          direction: new THREE.Vector3(0, 0, 1),
          speed: 0,
          targetSpeed: 0,
          heading: 0,
        };
        return carState;
      }

      function createTextures() {
        const textures = {};

        textures.grass = makeCanvasTexture((ctx) => {
          const { canvas } = ctx;
          const shades = ["#7ed957", "#6bc149", "#8ae36c"];
          ctx.fillStyle = "#6fc148";
          ctx.fillRect(0, 0, canvas.width, canvas.height);
          for (let i = 0; i < 200; i++) {
            ctx.fillStyle = shades[(Math.random() * shades.length) | 0];
            const size = Math.random() * 12 + 4;
            ctx.globalAlpha = 0.25;
            ctx.fillRect(Math.random() * canvas.width, Math.random() * canvas.height, size, size);
          }
          ctx.globalAlpha = 1;
        });

        textures.road = makeCanvasTexture((ctx) => {
          const { canvas } = ctx;
          ctx.fillStyle = "#44424a";
          ctx.fillRect(0, 0, canvas.width, canvas.height);
          ctx.fillStyle = "#2f2d36";
          ctx.fillRect(0, canvas.height / 2 - 6, canvas.width, 12);
          ctx.strokeStyle = "#f5f5dc";
          ctx.lineWidth = 4;
          for (let x = 0; x < canvas.width; x += 64) {
            ctx.beginPath();
            ctx.moveTo(x + 16, canvas.height / 2);
            ctx.lineTo(x + 48, canvas.height / 2);
            ctx.stroke();
          }
        }, 256, 256);

        textures.sidewalk = makeCanvasTexture((ctx) => {
          const { canvas } = ctx;
          ctx.fillStyle = "#c9c3c3";
          ctx.fillRect(0, 0, canvas.width, canvas.height);
          ctx.strokeStyle = "#9e9898";
          ctx.lineWidth = 4;
          ctx.strokeRect(2, 2, canvas.width - 4, canvas.height - 4);
        }, 128, 128);

        textures.building = makeCanvasTexture((ctx) => {
          const { canvas } = ctx;
          ctx.fillStyle = "#f9a1a1";
          ctx.fillRect(0, 0, canvas.width, canvas.height);
          ctx.fillStyle = "#8c3353";
          for (let y = 12; y < canvas.height; y += 24) {
            for (let x = 12; x < canvas.width; x += 24) {
              ctx.fillRect(x, y, 14, 18);
            }
          }
        });

        textures.nuclear = makeCanvasTexture((ctx) => {
          const { canvas } = ctx;
          ctx.fillStyle = "#ffe066";
          ctx.fillRect(0, 0, canvas.width, canvas.height);
          ctx.fillStyle = "#ff6b6b";
          ctx.beginPath();
          ctx.moveTo(canvas.width / 2, 10);
          ctx.lineTo(canvas.width - 10, canvas.height - 10);
          ctx.lineTo(10, canvas.height - 10);
          ctx.closePath();
          ctx.fill();
        });

        textures.carBodyPink = new THREE.MeshStandardMaterial({ color: 0xff89c7, roughness: 0.4, metalness: 0.1 });
        textures.carRoofYellow = new THREE.MeshStandardMaterial({ color: 0xffe066, roughness: 0.35 });
        textures.carBumper = new THREE.MeshStandardMaterial({ color: 0xffffff, roughness: 0.2 });

        textures.donut = makeCanvasTexture((ctx) => {
          const { canvas } = ctx;
          ctx.fillStyle = "#fdd09f";
          ctx.beginPath();
          ctx.arc(canvas.width / 2, canvas.height / 2, canvas.width / 2 - 6, 0, Math.PI * 2);
          ctx.fill();
          ctx.fillStyle = "#ff6b9a";
          ctx.beginPath();
          ctx.arc(canvas.width / 2, canvas.height / 2, canvas.width / 2 - 18, 0, Math.PI * 2);
          ctx.fill();
          ctx.fillStyle = "#fce4ec";
          for (let i = 0; i < 40; i++) {
            ctx.fillRect(Math.random() * canvas.width, Math.random() * canvas.height, 4, 8);
          }
          ctx.globalCompositeOperation = "destination-out";
          ctx.beginPath();
          ctx.arc(canvas.width / 2, canvas.height / 2, 18, 0, Math.PI * 2);
          ctx.fill();
          ctx.globalCompositeOperation = "source-over";
        }, 128, 128);

        textures.bus = new THREE.MeshStandardMaterial({ color: 0xfcbf49, roughness: 0.5 });

        return textures;
      }

      function makeCanvasTexture(drawFn, width = 256, height = 256) {
        const canvas = document.createElement("canvas");
        canvas.width = width;
        canvas.height = height;
        const ctx = canvas.getContext("2d");
        drawFn(ctx);
        const texture = new THREE.CanvasTexture(canvas);
        texture.wrapS = texture.wrapT = THREE.RepeatWrapping;
        texture.anisotropy = 16;
        texture.colorSpace = THREE.SRGBColorSpace;
        return new THREE.MeshStandardMaterial({ map: texture, roughness: 0.8 });
      }

      function buildRoadNetwork() {
        const group = new THREE.Group();
        const roadMat = textures.road.clone();
        roadMat.map.repeat.set(20, 1);
        const straight = new THREE.Mesh(new THREE.BoxGeometry(400, 0.2, 18), roadMat);
        straight.position.y = 0.11;
        straight.receiveShadow = true;
        group.add(straight);

        const vertical = new THREE.Mesh(new THREE.BoxGeometry(18, 0.2, 400), roadMat);
        vertical.position.y = 0.11;
        vertical.receiveShadow = true;
        group.add(vertical);

        const sidewalkMat = textures.sidewalk.clone();
        sidewalkMat.map.repeat.set(25, 1);
        const sidewalk1 = new THREE.Mesh(new THREE.BoxGeometry(400, 0.4, 6), sidewalkMat);
        sidewalk1.position.set(0, 0.2, 12);
        sidewalk1.receiveShadow = true;
        group.add(sidewalk1);

        const sidewalk2 = sidewalk1.clone();
        sidewalk2.position.z = -12;
        group.add(sidewalk2);

        const sidewalk3 = new THREE.Mesh(new THREE.BoxGeometry(6, 0.4, 400), sidewalkMat);
        sidewalk3.position.set(12, 0.2, 0);
        sidewalk3.receiveShadow = true;
        group.add(sidewalk3);

        const sidewalk4 = sidewalk3.clone();
        sidewalk4.position.x = -12;
        group.add(sidewalk4);

        return group;
      }

      function buildBuildings() {
        const group = new THREE.Group();
        const rng = THREE.MathUtils.seededRandom(1337);
        const buildingPositions = [];
        const ranges = [
          [-180, -60],
          [60, 180],
        ];
        ranges.forEach(([minX, maxX]) => {
          for (let x = minX; x <= maxX; x += 18) {
            for (let z = -180; z <= 180; z += 30) {
              if (Math.abs(z) < 24) continue;
              buildingPositions.push(new THREE.Vector3(x + (Math.random() - 0.5) * 6, 0, z + (Math.random() - 0.5) * 6));
            }
          }
        });

        buildingPositions.forEach((pos, idx) => {
          const height = THREE.MathUtils.randFloat(12, 32);
          const width = THREE.MathUtils.randFloat(8, 18);
          const depth = THREE.MathUtils.randFloat(8, 18);
          const geo = new THREE.BoxGeometry(width, height, depth);
          const mat = textures.building.clone();
          mat.map.repeat.set(width / 8, height / 8);
          const mesh = new THREE.Mesh(geo, mat);
          mesh.position.set(pos.x, height / 2, pos.z);
          mesh.castShadow = true;
          mesh.receiveShadow = true;
          group.add(mesh);

          if (idx % 12 === 0) {
            const billboard = new THREE.Mesh(new THREE.BoxGeometry(width * 0.6, height * 0.4, 1), textures.nuclear);
            billboard.position.set(pos.x, height + 2, pos.z);
            group.add(billboard);
          }
        });

        const plantTowers = new THREE.Group();
        for (let i = 0; i < 2; i++) {
          const tower = new THREE.Mesh(
            new THREE.CylinderGeometry(10, 6, 28, 24),
            new THREE.MeshStandardMaterial({ color: 0xd0d0d0, roughness: 0.6 })
          );
          tower.position.set(-40 + i * 20, 14, -80);
          tower.castShadow = true;
          tower.receiveShadow = true;
          plantTowers.add(tower);
        }
        group.add(plantTowers);

        return group;
      }

      function populateDonuts() {
        const donutGeo = new THREE.TorusGeometry(1.2, 0.4, 16, 32);
        const donutMat = new THREE.MeshStandardMaterial({ map: textures.donut.map, roughness: 0.5, metalness: 0.1 });
        for (let i = 0; i < 30; i++) {
          const donut = new THREE.Mesh(donutGeo, donutMat.clone());
          const angle = Math.random() * Math.PI * 2;
          const radius = THREE.MathUtils.randFloat(20, 140);
          donut.position.set(Math.cos(angle) * radius, 2.4, Math.sin(angle) * radius);
          donut.rotation.x = Math.random() * Math.PI;
          donut.rotation.y = Math.random() * Math.PI;
          donut.castShadow = true;
          donutsGroup.add(donut);
        }
      }

      function spawnTraffic() {
        const busGeo = new THREE.BoxGeometry(4, 3, 10);
        for (let i = 0; i < 6; i++) {
          const bus = new THREE.Mesh(busGeo, textures.bus);
          bus.position.set(-150 + i * 60, 1.6, i % 2 === 0 ? 6 : -6);
          bus.castShadow = true;
          bus.userData = {
            speed: THREE.MathUtils.randFloat(14, 22) * (i % 2 === 0 ? 1 : -1),
          };
          trafficGroup.add(bus);
        }
      }

      function setupTouchControls() {
        if (!matchMedia("(hover: none)").matches) return;
        touchStick.addEventListener("touchstart", (event) => {
          const touch = event.touches[0];
          touchStick.dataset.startX = touch.clientX;
          touchStick.dataset.startY = touch.clientY;
          event.preventDefault();
        });

        touchStick.addEventListener("touchmove", (event) => {
          const touch = event.touches[0];
          const startX = parseFloat(touchStick.dataset.startX || "0");
          const startY = parseFloat(touchStick.dataset.startY || "0");
          const dx = (touch.clientX - startX) / 45;
          const dy = (touch.clientY - startY) / 45;
          keyState["ArrowUp"] = dy < -0.3;
          keyState["ArrowDown"] = dy > 0.3;
          keyState["ArrowLeft"] = dx < -0.3;
          keyState["ArrowRight"] = dx > 0.3;
          event.preventDefault();
        });

        touchStick.addEventListener("touchend", () => {
          keyState["ArrowUp"] = keyState["ArrowDown"] = keyState["ArrowLeft"] = keyState["ArrowRight"] = false;
        });

        boostBtn.addEventListener("touchstart", (event) => {
          event.preventDefault();
          keyState["Space"] = true;
        });
        boostBtn.addEventListener("touchend", () => (keyState["Space"] = false));

        brakeBtn.addEventListener("touchstart", (event) => {
          event.preventDefault();
          keyState["ArrowDown"] = true;
        });
        brakeBtn.addEventListener("touchend", () => (keyState["ArrowDown"] = false));

        resetBtn.addEventListener("touchstart", (event) => {
          event.preventDefault();
          resetCar();
        });
      }

      function resetCar() {
        car.mesh.position.set(0, 0, 0);
        car.mesh.rotation.set(0, 0, 0);
        car.velocity.set(0, 0, 0);
        car.speed = 0;
        car.heading = 0;
        messageEl.textContent = "Back on the road â€” deliver those donuts!";
      }

      function updateCar(delta) {
        const forward = new THREE.Vector3(Math.sin(car.heading), 0, Math.cos(car.heading));
        const right = new THREE.Vector3().crossVectors(forward, new THREE.Vector3(0, 1, 0));

        const accel = keyState["ArrowUp"] || keyState["KeyW"] ? 18 : 0;
        const brake = keyState["ArrowDown"] || keyState["KeyS"] ? 25 : 0;
        const boost = keyState["Space"] ? 10 : 0;

        const turn = (keyState["ArrowLeft"] || keyState["KeyA"] ? 1 : 0) - (keyState["ArrowRight"] || keyState["KeyD"] ? 1 : 0);

        const targetSpeed = Math.max(0, Math.min(60, car.speed + (accel + boost - brake) * delta));
        car.speed = THREE.MathUtils.damp(car.speed, targetSpeed, 4.5, delta);

        car.heading += turn * delta * (car.speed / 18);
        car.heading = THREE.MathUtils.euclideanModulo(car.heading, Math.PI * 2);

        const movement = forward.clone().multiplyScalar(car.speed * delta);
        car.mesh.position.add(movement);
        car.mesh.rotation.y = car.heading;

        car.mesh.position.x = THREE.MathUtils.clamp(car.mesh.position.x, -190, 190);
        car.mesh.position.z = THREE.MathUtils.clamp(car.mesh.position.z, -190, 190);

        car.velocity.copy(movement.divideScalar(Math.max(delta, 1e-5)));

        camera.position.lerp(
          car.mesh.position
            .clone()
            .add(new THREE.Vector3(Math.sin(car.heading) * -12, 7 + boost * 0.1, Math.cos(car.heading) * -12)),
          0.08
        );
        orbit.target.lerp(car.mesh.position.clone().add(new THREE.Vector3(0, 2.5, 0)), 0.12);

        speedEl.textContent = Math.round(car.speed).toString();
      }

      function updateTraffic(delta) {
        trafficGroup.children.forEach((bus) => {
          bus.position.z += bus.userData.speed * delta;
          if (bus.position.z > 200) bus.position.z = -200;
          if (bus.position.z < -200) bus.position.z = 200;
        });
      }

      function checkCollisions(delta) {
        const carPos = car.mesh.position;
        donutsGroup.children.forEach((donut) => {
          if (!donut.visible) return;
          if (donut.position.distanceTo(carPos) < 3) {
            donut.visible = false;
            state.donuts += 1;
            state.combo += 1;
            state.bestCombo = Math.max(state.bestCombo, state.combo);
            elapsed = Math.max(0, elapsed - 2);
            messageEl.textContent = "Nice delivery! +2s";
          }
        });
        donutsGroup.children = donutsGroup.children.filter((donut) => donut.visible);

        trafficGroup.children.forEach((bus) => {
          if (bus.position.distanceTo(carPos) < 4.5) {
            car.speed *= 0.4;
            messageEl.textContent = "Ouch! Watch those buses.";
            state.combo = 0;
            spawnDustEffect(bus.position);
          }
        });

        donutsEl.textContent = `${state.donuts}`;
      }

      function spawnDustEffect(position) {
        const dust = new THREE.Mesh(
          new THREE.SphereGeometry(THREE.MathUtils.randFloat(1, 2), 10, 10),
          new THREE.MeshStandardMaterial({ color: 0xf2b880, transparent: true, opacity: 0.6 })
        );
        dust.position.copy(position).add(new THREE.Vector3(0, 1.4, 0));
        dust.userData = { life: 0.7 };
        dustGroup.add(dust);
      }

      function updateDust(delta) {
        for (let i = dustGroup.children.length - 1; i >= 0; i--) {
          const dust = dustGroup.children[i];
          dust.userData.life -= delta;
          dust.material.opacity = Math.max(0, dust.userData.life / 0.7);
          dust.scale.multiplyScalar(1 + delta * 2);
          if (dust.userData.life <= 0) {
            dustGroup.remove(dust);
            dust.geometry.dispose();
            dust.material.dispose();
          }
        }
      }

      function resetIfOutOfBounds() {
        if (Math.abs(car.mesh.position.x) > 198 || Math.abs(car.mesh.position.z) > 198) {
          resetCar();
        }
      }

      function animate() {
        const delta = Math.min(clock.getDelta(), 0.033);
        if (state.playing) {
          elapsed += delta;
          const timeLeft = Math.max(0, TOTAL_TIME - elapsed);
          timerEl.textContent = timeLeft.toFixed(1);
          if (timeLeft <= 0) {
            state.playing = false;
            messageEl.textContent = `Shift done! ${state.donuts} donuts delivered. Best combo ${state.bestCombo}.`;
          }
        }

        if (state.playing) {
          updateCar(delta);
          updateTraffic(delta);
          checkCollisions(delta);
          updateDust(delta);
          resetIfOutOfBounds();
        }

        orbit.update();
        renderer.render(scene, camera);
        requestAnimationFrame(animate);
      }

      animate();

      window.addEventListener("resize", () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      });
    </script>
  </body>
</html>
