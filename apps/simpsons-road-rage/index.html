<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Springfield Road Rush â€” Three.js Drive</title>
    <meta
      name="description"
      content="Race through a low-poly Springfield inspired by Simpsons Road Rage. Custom Three.js playground with handmade textures and no sound."
    />
    <meta property="og:title" content="Springfield Road Rush" />
    <meta
      property="og:description"
      content="Hop in the Pink Sedan, drift past blocky Springfield landmarks, and grab donuts before the timer runs out."
    />
    <meta property="og:type" content="website" />
    <meta property="og:url" content="https://app.vibecodedbyx.com/simpsons-road-rage/" />
    <meta property="og:image" content="https://app.vibecodedbyx.com/simpsons-road-rage/og-image.png" />
    <meta name="twitter:card" content="summary_large_image" />
    <meta name="twitter:title" content="Springfield Road Rush" />
    <meta name="twitter:description" content="A Simpsons Road Rage inspired Three.js mini racer with original textures." />
    <meta name="twitter:image" content="https://app.vibecodedbyx.com/simpsons-road-rage/og-image.png" />
    <link rel="icon" href="./favicon.svg" type="image/svg+xml" />
    <meta name="theme-color" content="#fdda42" />
    <style>
      :root {
        color-scheme: light;
        font-family: "Inter", "Segoe UI", sans-serif;
        --hud-bg: rgba(255, 255, 255, 0.78);
        --hud-border: rgba(17, 24, 39, 0.18);
        --accent: #ff6b6b;
        --text: #101222;
      }

      *, *::before, *::after {
        box-sizing: border-box;
      }

      body {
        margin: 0;
        background: radial-gradient(circle at 20% -10%, rgba(255, 247, 131, 0.6), transparent 65%), #87ceeb;
        color: var(--text);
        overflow: hidden;
      }

      canvas {
        display: block;
      }

      .hud {
        position: fixed;
        top: 16px;
        left: 16px;
        display: grid;
        gap: 12px;
        padding: 16px 18px;
        max-width: min(340px, 80vw);
        background: var(--hud-bg);
        border: 1px solid var(--hud-border);
        border-radius: 18px;
        backdrop-filter: blur(12px);
        box-shadow: 0 14px 32px rgba(17, 24, 39, 0.16);
      }

      .hud h1 {
        margin: 0;
        font-size: 1.4rem;
        letter-spacing: 0.08em;
        text-transform: uppercase;
      }

      .hud p {
        margin: 0;
        font-size: 0.92rem;
        line-height: 1.5;
      }

      .status-grid {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(110px, 1fr));
        gap: 8px;
      }

      .status {
        background: rgba(255, 255, 255, 0.8);
        border-radius: 12px;
        padding: 8px 10px;
        border: 1px solid rgba(17, 24, 39, 0.08);
        text-align: center;
      }

      .status .label {
        display: block;
        font-size: 0.7rem;
        letter-spacing: 0.16em;
        text-transform: uppercase;
        color: rgba(17, 24, 39, 0.56);
      }

      .status .value {
        font-size: 1.05rem;
        font-weight: 600;
      }

      .hud a {
        color: var(--accent);
        text-decoration: none;
        font-weight: 600;
      }

      .hud a:hover,
      .hud a:focus-visible {
        text-decoration: underline;
      }

      #message {
        font-size: 0.9rem;
        color: rgba(17, 24, 39, 0.72);
      }

      .mobile-hint {
        display: none;
        font-size: 0.85rem;
        color: rgba(17, 24, 39, 0.7);
      }

      @media (max-width: 720px), (hover: none) {
        .hud {
          max-width: 92vw;
          padding: 14px 16px;
        }
        .mobile-hint {
          display: block;
        }
      }

      .touch-controls {
        position: fixed;
        bottom: 18px;
        right: 20px;
        display: none;
        gap: 10px;
        pointer-events: none;
      }

      .touch-controls button {
        width: 56px;
        height: 56px;
        border-radius: 16px;
        border: 1px solid rgba(17, 24, 39, 0.18);
        background: rgba(255, 255, 255, 0.82);
        color: rgba(17, 24, 39, 0.8);
        font-size: 1.4rem;
        font-weight: 600;
        pointer-events: auto;
      }

      .touch-stick {
        position: fixed;
        bottom: 18px;
        left: 20px;
        width: 120px;
        height: 120px;
        border-radius: 50%;
        border: 1px solid rgba(17, 24, 39, 0.16);
        background: rgba(255, 255, 255, 0.5);
        pointer-events: auto;
        touch-action: none;
        display: none;
      }

      .touch-stick::after {
        content: "";
        position: absolute;
        width: 60px;
        height: 60px;
        border-radius: 50%;
        background: rgba(255, 255, 255, 0.82);
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
      }

      @media (hover: none) {
        .touch-controls,
        .touch-stick {
          display: block;
        }
      }

      /* Leaderboard + submit UI */
      .right-panel {
        position: fixed;
        top: 16px;
        right: 16px;
        display: grid;
        gap: 12px;
        padding: 14px 16px;
        width: min(360px, 86vw);
        background: var(--hud-bg);
        border: 1px solid var(--hud-border);
        border-radius: 16px;
        backdrop-filter: blur(12px);
        box-shadow: 0 14px 32px rgba(17, 24, 39, 0.16);
      }
      .right-panel h2 { margin: 0; font-size: 1.1rem; letter-spacing: 0.06em; text-transform: uppercase; }
      .leaderboard-list {
        display: grid;
        grid-template-columns: 1fr auto;
        gap: 6px 10px;
      }
      .leaderboard-list .name { overflow: hidden; text-overflow: ellipsis; white-space: nowrap; }
      .muted { color: rgba(17,24,39,0.62); font-size: 0.86rem; }
      .error { color: #b00020; font-weight: 600; font-size: 0.9rem; }
      .success { color: #056608; font-weight: 600; font-size: 0.9rem; }

      .submit-card { display: none; }
      .submit-card.active { display: block; }
      .submit-card input {
        width: 100%;
        border: 1px solid rgba(17, 24, 39, 0.2);
        border-radius: 10px;
        padding: 10px 12px;
        font-size: 1rem;
      }
      .submit-card button {
        margin-top: 8px;
        border: 1px solid rgba(17, 24, 39, 0.2);
        border-radius: 10px;
        padding: 10px 12px;
        font-weight: 600;
        background: white;
      }

      @media (max-width: 720px) {
        .right-panel { top: auto; bottom: 16px; }
      }
    </style>
  </head>
  <body>
    <div class="hud" id="hud">
      <h1>Springfield Road Rush</h1>
      <p>
        Arrow keys or WASD steer the Pink Sedan. Hold Space for turbo. Collect donuts, avoid buses, and beat the clock across
        blocky Springfield.
      </p>
      <div class="status-grid">
        <div class="status"><span class="label">Timer</span><span class="value" id="timer">60.0</span></div>
        <div class="status"><span class="label">Donuts</span><span class="value" id="donuts">0</span></div>
        <div class="status"><span class="label">Speed</span><span class="value" id="speed">0</span></div>
      </div>
      <p id="message">Deliveries pending â€” cruise past Moe's and the Nuclear Plant for bonus donuts.</p>
      <p class="mobile-hint">Drag left circle to steer, tap â–² for boost, â­• brake, ðŸŒŸ place-hold to reset.</p>
      <a href="https://www.vibecodedbyx.com" target="_blank" rel="noreferrer noopener">â¬… Back to the livestream</a>
    </div>

    <div class="touch-stick" id="touchStick"></div>
    <div class="touch-controls" id="touchButtons">
      <button id="boostBtn" aria-label="Boost">â–²</button>
      <button id="brakeBtn" aria-label="Brake">â­•</button>
      <button id="resetBtn" aria-label="Reset">âŸ³</button>
    </div>

    <aside class="right-panel" id="rightPanel">
      <section>
        <h2>Leaderboard</h2>
        <p class="muted" id="lbStatus">Top donut deliveries</p>
        <div id="leaderboard" class="leaderboard-list"></div>
      </section>
      <section class="submit-card" id="submitCard">
        <h2>Submit Your Score</h2>
        <p class="muted">Enter a name to save your run.</p>
        <input id="playerName" maxlength="24" placeholder="Your name (e.g. Homer)" />
        <button id="submitScoreBtn">Save Score</button>
        <div id="submitMsg" class="muted" aria-live="polite"></div>
      </section>
    </aside>

    <script type="importmap">
      {
        "imports": {
          "three": "https://cdn.jsdelivr.net/npm/three@0.167.0/build/three.module.js",
          "three/examples/": "https://cdn.jsdelivr.net/npm/three@0.167.0/examples/"
        }
      }
    </script>

    <script type="module">
      import { createClient } from "https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2/+esm";

      const SUPABASE_URL = 'https://yjyxteqzhhmtrgcaekgz.supabase.co';
      const SUPABASE_ANON_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InlqeXh0ZXF6aGhtdHJnY2Fla2d6Iiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTczNTg3NDIsImV4cCI6MjA3MjkzNDc0Mn0.G8SRde7IN2QFW1EnASM8IS32IUYR2eenCCjdDdioiBU';
      const supabase = createClient(SUPABASE_URL, SUPABASE_ANON_KEY);

      async function ensureSession() {
        const { data: sess } = await supabase.auth.getSession();
        if (!sess?.session) {
          const { error } = await supabase.auth.signInAnonymously();
          if (error) throw new Error(`Auth failed: ${error.message}`);
        }
      }

      const TABLE = 'simpsons_road_rage_scores';

      async function loadLeaderboard() {
        const lb = document.getElementById('leaderboard');
        const status = document.getElementById('lbStatus');
        status.textContent = 'Loadingâ€¦';
        lb.innerHTML = '';
        try {
          await ensureSession();
          const { data, error } = await supabase
            .from(TABLE)
            .select('name, score, created_at')
            .order('score', { ascending: false })
            .limit(10);
          if (error) throw error;
          if (!data || data.length === 0) {
            status.textContent = 'No scores yet â€” be first!';
            return;
          }
          status.textContent = 'Top donut deliveries';
          data.forEach((row, idx) => {
            const name = document.createElement('div');
            name.className = 'name';
            name.textContent = `${idx + 1}. ${row.name || 'Anonymous'}`;
            const score = document.createElement('div');
            score.textContent = `${row.score}`;
            lb.appendChild(name);
            lb.appendChild(score);
          });
        } catch (e) {
          console.error(e);
          status.textContent = 'Failed to load leaderboard';
        }
      }

      async function submitScore(name, score) {
        const msg = document.getElementById('submitMsg');
        msg.className = 'muted';
        msg.textContent = 'Savingâ€¦';
        try {
          await ensureSession();
          const { data: { user } } = await supabase.auth.getUser();
          if (!user?.id) throw new Error('No user');
          const cleanName = (name || '').toString().trim().slice(0, 24) || 'Anonymous';
          const { error } = await supabase
            .from(TABLE)
            .insert({ name: cleanName, score: Math.max(0, Math.floor(score)), user_id: user.id });
          if (error) throw error;
          msg.className = 'success';
          msg.textContent = 'Score saved!';
          document.getElementById('submitCard').classList.remove('active');
          await loadLeaderboard();
        } catch (e) {
          console.error('Submit failed', e);
          msg.className = 'error';
          msg.textContent = 'Could not save score. Please try again.';
        }
      }
      import * as THREE from "three";
      import { OrbitControls } from "three/examples/jsm/controls/OrbitControls.js";

      const scene = new THREE.Scene();
      scene.background = new THREE.Color(0x87ceeb);
      scene.fog = new THREE.Fog(0x87ceeb, 80, 220);

      const renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
      renderer.shadowMap.enabled = true;
      document.body.appendChild(renderer.domElement);

      const camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.1, 400);
      camera.position.set(0, 12, 18);

      const orbit = new OrbitControls(camera, renderer.domElement);
      orbit.enableDamping = true;
      orbit.target.set(0, 3, 0);
      orbit.maxDistance = 200;
      orbit.maxPolarAngle = Math.PI / 2.1;
      orbit.enablePan = false;
      orbit.dampingFactor = 0.08;

      const hemiLight = new THREE.HemisphereLight(0xfff7a6, 0x1e2a4f, 0.9);
      scene.add(hemiLight);

      const sun = new THREE.DirectionalLight(0xffffff, 0.9);
      sun.position.set(-80, 120, 60);
      sun.castShadow = true;
      sun.shadow.mapSize.set(2048, 2048);
      sun.shadow.camera.left = -120;
      sun.shadow.camera.right = 120;
      sun.shadow.camera.top = 120;
      sun.shadow.camera.bottom = -120;
      scene.add(sun);

      const world = new THREE.Group();
      scene.add(world);

      const textures = createTextures();

      const ground = new THREE.Mesh(new THREE.PlaneGeometry(400, 400), textures.grass);
      ground.rotation.x = -Math.PI / 2;
      ground.receiveShadow = true;
      world.add(ground);

      const road = buildRoadNetwork();
      world.add(road);

      const buildings = buildBuildings();
      world.add(buildings);

      const donutsGroup = new THREE.Group();
      world.add(donutsGroup);
      populateDonuts();

      const trafficGroup = new THREE.Group();
      world.add(trafficGroup);
      spawnTraffic();

      const car = buildCar();
      world.add(car.mesh);

      const dustGroup = new THREE.Group();
      world.add(dustGroup);
      const skidGroup = new THREE.Group();
      world.add(skidGroup);

      const clock = new THREE.Clock();
      let elapsed = 0;
      const TOTAL_TIME = 75;

      const keyState = {};
      document.addEventListener("keydown", (e) => (keyState[e.code] = true));
      document.addEventListener("keyup", (e) => (keyState[e.code] = false));

      const touchStick = document.getElementById("touchStick");
      const boostBtn = document.getElementById("boostBtn");
      const brakeBtn = document.getElementById("brakeBtn");
      const resetBtn = document.getElementById("resetBtn");
      setupTouchControls();

      const timerEl = document.getElementById("timer");
      const donutsEl = document.getElementById("donuts");
      const speedEl = document.getElementById("speed");
      const messageEl = document.getElementById("message");
      const submitCard = document.getElementById('submitCard');
      const submitBtn = document.getElementById('submitScoreBtn');
      const nameInput = document.getElementById('playerName');
      submitBtn.addEventListener('click', () => {
        const name = nameInput.value;
        submitScore(name, state.donuts);
      });

      const state = {
        donuts: 0,
        bestCombo: 0,
        combo: 0,
        timeBonus: 0,
        playing: true,
        gameOverShown: false,
        skidTimer: 0,
      };

      function buildCar() {
        const group = new THREE.Group();
        group.castShadow = true;

        const body = new THREE.Mesh(new THREE.BoxGeometry(2.8, 1.1, 5), textures.carBodyPink);
        body.position.y = 1.2;
        body.castShadow = true;
        group.add(body);

        const roof = new THREE.Mesh(new THREE.BoxGeometry(2.6, 0.9, 2.4), textures.carRoofYellow);
        roof.position.set(0, 1.9, -0.4);
        roof.castShadow = true;
        group.add(roof);

        const bumper = new THREE.Mesh(new THREE.BoxGeometry(2.9, 0.6, 0.6), textures.carBumper);
        bumper.position.set(0, 0.8, 2.4);
        group.add(bumper);

        const wheelGeo = new THREE.CylinderGeometry(0.6, 0.6, 0.4, 20);
        wheelGeo.rotateZ(Math.PI / 2);
        const wheelMat = new THREE.MeshStandardMaterial({ color: 0x222222, roughness: 0.6 });
        const wheelPositions = [
          [-1.4, 0.6, 1.8],
          [1.4, 0.6, 1.8],
          [-1.4, 0.6, -1.8],
          [1.4, 0.6, -1.8],
        ];
        wheelPositions.forEach((pos) => {
          const wheel = new THREE.Mesh(wheelGeo, wheelMat);
          wheel.position.set(...pos);
          wheel.castShadow = true;
          group.add(wheel);
        });

        const carState = {
          mesh: group,
          velocity: new THREE.Vector3(),
          direction: new THREE.Vector3(0, 0, 1),
          speed: 0,
          targetSpeed: 0,
          heading: 0,
        };
        return carState;
      }

      function createTextures() {
        const textures = {};

        textures.grass = makeCanvasTexture((ctx) => {
          const { canvas } = ctx;
          const shades = ["#7ed957", "#6bc149", "#8ae36c"];
          ctx.fillStyle = "#6fc148";
          ctx.fillRect(0, 0, canvas.width, canvas.height);
          for (let i = 0; i < 200; i++) {
            ctx.fillStyle = shades[(Math.random() * shades.length) | 0];
            const size = Math.random() * 12 + 4;
            ctx.globalAlpha = 0.25;
            ctx.fillRect(Math.random() * canvas.width, Math.random() * canvas.height, size, size);
          }
          ctx.globalAlpha = 1;
        });

        textures.road = makeCanvasTexture((ctx) => {
          const { canvas } = ctx;
          ctx.fillStyle = "#44424a";
          ctx.fillRect(0, 0, canvas.width, canvas.height);
          ctx.fillStyle = "#2f2d36";
          ctx.fillRect(0, canvas.height / 2 - 6, canvas.width, 12);
          ctx.strokeStyle = "#f5f5dc";
          ctx.lineWidth = 4;
          for (let x = 0; x < canvas.width; x += 64) {
            ctx.beginPath();
            ctx.moveTo(x + 16, canvas.height / 2);
            ctx.lineTo(x + 48, canvas.height / 2);
            ctx.stroke();
          }
        }, 256, 256);

        textures.sidewalk = makeCanvasTexture((ctx) => {
          const { canvas } = ctx;
          ctx.fillStyle = "#c9c3c3";
          ctx.fillRect(0, 0, canvas.width, canvas.height);
          ctx.strokeStyle = "#9e9898";
          ctx.lineWidth = 4;
          ctx.strokeRect(2, 2, canvas.width - 4, canvas.height - 4);
        }, 128, 128);

        textures.building = makeCanvasTexture((ctx) => {
          const { canvas } = ctx;
          ctx.fillStyle = "#f9a1a1";
          ctx.fillRect(0, 0, canvas.width, canvas.height);
          ctx.fillStyle = "#8c3353";
          for (let y = 12; y < canvas.height; y += 24) {
            for (let x = 12; x < canvas.width; x += 24) {
              ctx.fillRect(x, y, 14, 18);
            }
          }
        });

        textures.nuclear = makeCanvasTexture((ctx) => {
          const { canvas } = ctx;
          ctx.fillStyle = "#ffe066";
          ctx.fillRect(0, 0, canvas.width, canvas.height);
          ctx.fillStyle = "#ff6b6b";
          ctx.beginPath();
          ctx.moveTo(canvas.width / 2, 10);
          ctx.lineTo(canvas.width - 10, canvas.height - 10);
          ctx.lineTo(10, canvas.height - 10);
          ctx.closePath();
          ctx.fill();
        });

        textures.carBodyPink = new THREE.MeshStandardMaterial({ color: 0xff89c7, roughness: 0.4, metalness: 0.1 });
        textures.carRoofYellow = new THREE.MeshStandardMaterial({ color: 0xffe066, roughness: 0.35 });
        textures.carBumper = new THREE.MeshStandardMaterial({ color: 0xffffff, roughness: 0.2 });

        textures.donut = makeCanvasTexture((ctx) => {
          const { canvas } = ctx;
          ctx.fillStyle = "#fdd09f";
          ctx.beginPath();
          ctx.arc(canvas.width / 2, canvas.height / 2, canvas.width / 2 - 6, 0, Math.PI * 2);
          ctx.fill();
          ctx.fillStyle = "#ff6b9a";
          ctx.beginPath();
          ctx.arc(canvas.width / 2, canvas.height / 2, canvas.width / 2 - 18, 0, Math.PI * 2);
          ctx.fill();
          ctx.fillStyle = "#fce4ec";
          for (let i = 0; i < 40; i++) {
            ctx.fillRect(Math.random() * canvas.width, Math.random() * canvas.height, 4, 8);
          }
          ctx.globalCompositeOperation = "destination-out";
          ctx.beginPath();
          ctx.arc(canvas.width / 2, canvas.height / 2, 18, 0, Math.PI * 2);
          ctx.fill();
          ctx.globalCompositeOperation = "source-over";
        }, 128, 128);

        textures.bus = new THREE.MeshStandardMaterial({ color: 0xfcbf49, roughness: 0.5 });

        // Skid texture (dark twin stripes with soft edges)
        {
          const canvas = document.createElement('canvas');
          canvas.width = 128;
          canvas.height = 64;
          const ctx = canvas.getContext('2d');
          ctx.clearRect(0, 0, canvas.width, canvas.height);
          for (let i = 0; i < 2; i++) {
            const y = 20 + i * 20;
            const grad = ctx.createLinearGradient(0, y - 10, 0, y + 10);
            grad.addColorStop(0, 'rgba(20,20,20,0)');
            grad.addColorStop(0.2, 'rgba(20,20,20,0.5)');
            grad.addColorStop(0.5, 'rgba(20,20,20,0.9)');
            grad.addColorStop(0.8, 'rgba(20,20,20,0.5)');
            grad.addColorStop(1, 'rgba(20,20,20,0)');
            ctx.fillStyle = grad;
            ctx.fillRect(8, y - 10, canvas.width - 16, 20);
          }
          const tex = new THREE.CanvasTexture(canvas);
          tex.colorSpace = THREE.SRGBColorSpace;
          tex.anisotropy = 8;
          textures.skidMap = tex;
        }

        return textures;
      }

      function makeCanvasTexture(drawFn, width = 256, height = 256) {
        const canvas = document.createElement("canvas");
        canvas.width = width;
        canvas.height = height;
        const ctx = canvas.getContext("2d");
        drawFn(ctx);
        const texture = new THREE.CanvasTexture(canvas);
        texture.wrapS = texture.wrapT = THREE.RepeatWrapping;
        texture.anisotropy = 16;
        texture.colorSpace = THREE.SRGBColorSpace;
        return new THREE.MeshStandardMaterial({ map: texture, roughness: 0.8 });
      }

      function buildRoadNetwork() {
        const group = new THREE.Group();
        const roadMat = textures.road.clone();
        roadMat.map.repeat.set(20, 1);
        const straight = new THREE.Mesh(new THREE.BoxGeometry(400, 0.2, 18), roadMat);
        straight.position.y = 0.11;
        straight.receiveShadow = true;
        group.add(straight);

        const vertical = new THREE.Mesh(new THREE.BoxGeometry(18, 0.2, 400), roadMat);
        vertical.position.y = 0.11;
        vertical.receiveShadow = true;
        group.add(vertical);

        const sidewalkMat = textures.sidewalk.clone();
        sidewalkMat.map.repeat.set(25, 1);
        const sidewalk1 = new THREE.Mesh(new THREE.BoxGeometry(400, 0.4, 6), sidewalkMat);
        sidewalk1.position.set(0, 0.2, 12);
        sidewalk1.receiveShadow = true;
        group.add(sidewalk1);

        const sidewalk2 = sidewalk1.clone();
        sidewalk2.position.z = -12;
        group.add(sidewalk2);

        const sidewalk3 = new THREE.Mesh(new THREE.BoxGeometry(6, 0.4, 400), sidewalkMat);
        sidewalk3.position.set(12, 0.2, 0);
        sidewalk3.receiveShadow = true;
        group.add(sidewalk3);

        const sidewalk4 = sidewalk3.clone();
        sidewalk4.position.x = -12;
        group.add(sidewalk4);

        return group;
      }

      function buildBuildings() {
        const group = new THREE.Group();
        const rng = THREE.MathUtils.seededRandom(1337);
        const buildingPositions = [];
        const ranges = [
          [-180, -60],
          [60, 180],
        ];
        ranges.forEach(([minX, maxX]) => {
          for (let x = minX; x <= maxX; x += 18) {
            for (let z = -180; z <= 180; z += 30) {
              if (Math.abs(z) < 24) continue;
              buildingPositions.push(new THREE.Vector3(x + (Math.random() - 0.5) * 6, 0, z + (Math.random() - 0.5) * 6));
            }
          }
        });

        buildingPositions.forEach((pos, idx) => {
          const height = THREE.MathUtils.randFloat(12, 32);
          const width = THREE.MathUtils.randFloat(8, 18);
          const depth = THREE.MathUtils.randFloat(8, 18);
          const geo = new THREE.BoxGeometry(width, height, depth);
          const mat = textures.building.clone();
          mat.map.repeat.set(width / 8, height / 8);
          const mesh = new THREE.Mesh(geo, mat);
          mesh.position.set(pos.x, height / 2, pos.z);
          mesh.castShadow = true;
          mesh.receiveShadow = true;
          group.add(mesh);

          if (idx % 12 === 0) {
            const billboard = new THREE.Mesh(new THREE.BoxGeometry(width * 0.6, height * 0.4, 1), textures.nuclear);
            billboard.position.set(pos.x, height + 2, pos.z);
            group.add(billboard);
          }
        });

        const plantTowers = new THREE.Group();
        for (let i = 0; i < 2; i++) {
          const tower = new THREE.Mesh(
            new THREE.CylinderGeometry(10, 6, 28, 24),
            new THREE.MeshStandardMaterial({ color: 0xd0d0d0, roughness: 0.6 })
          );
          tower.position.set(-40 + i * 20, 14, -80);
          tower.castShadow = true;
          tower.receiveShadow = true;
          plantTowers.add(tower);
        }
        group.add(plantTowers);

        return group;
      }

      function populateDonuts() {
        const donutGeo = new THREE.TorusGeometry(1.2, 0.4, 16, 32);
        const donutMat = new THREE.MeshStandardMaterial({ map: textures.donut.map, roughness: 0.5, metalness: 0.1 });
        for (let i = 0; i < 30; i++) {
          const donut = new THREE.Mesh(donutGeo, donutMat.clone());
          const angle = Math.random() * Math.PI * 2;
          const radius = THREE.MathUtils.randFloat(20, 140);
          donut.position.set(Math.cos(angle) * radius, 2.4, Math.sin(angle) * radius);
          donut.rotation.x = Math.random() * Math.PI;
          donut.rotation.y = Math.random() * Math.PI;
          donut.castShadow = true;
          donutsGroup.add(donut);
        }
      }

      function spawnTraffic() {
        const busGeo = new THREE.BoxGeometry(4, 3, 10);
        for (let i = 0; i < 6; i++) {
          const bus = new THREE.Mesh(busGeo, textures.bus);
          bus.position.set(-150 + i * 60, 1.6, i % 2 === 0 ? 6 : -6);
          bus.castShadow = true;
          bus.userData = {
            speed: THREE.MathUtils.randFloat(14, 22) * (i % 2 === 0 ? 1 : -1),
          };
          trafficGroup.add(bus);
        }
      }

      function setupTouchControls() {
        if (!matchMedia("(hover: none)").matches) return;
        touchStick.addEventListener("touchstart", (event) => {
          const touch = event.touches[0];
          touchStick.dataset.startX = touch.clientX;
          touchStick.dataset.startY = touch.clientY;
          event.preventDefault();
        });

        touchStick.addEventListener("touchmove", (event) => {
          const touch = event.touches[0];
          const startX = parseFloat(touchStick.dataset.startX || "0");
          const startY = parseFloat(touchStick.dataset.startY || "0");
          const dx = (touch.clientX - startX) / 45;
          const dy = (touch.clientY - startY) / 45;
          keyState["ArrowUp"] = dy < -0.3;
          keyState["ArrowDown"] = dy > 0.3;
          keyState["ArrowLeft"] = dx < -0.3;
          keyState["ArrowRight"] = dx > 0.3;
          event.preventDefault();
        });

        touchStick.addEventListener("touchend", () => {
          keyState["ArrowUp"] = keyState["ArrowDown"] = keyState["ArrowLeft"] = keyState["ArrowRight"] = false;
        });

        boostBtn.addEventListener("touchstart", (event) => {
          event.preventDefault();
          keyState["Space"] = true;
        });
        boostBtn.addEventListener("touchend", () => (keyState["Space"] = false));

        brakeBtn.addEventListener("touchstart", (event) => {
          event.preventDefault();
          keyState["ArrowDown"] = true;
        });
        brakeBtn.addEventListener("touchend", () => (keyState["ArrowDown"] = false));

        resetBtn.addEventListener("touchstart", (event) => {
          event.preventDefault();
          resetCar();
        });
      }

      function resetCar() {
        car.mesh.position.set(0, 0, 0);
        car.mesh.rotation.set(0, 0, 0);
        car.velocity.set(0, 0, 0);
        car.speed = 0;
        car.heading = 0;
        messageEl.textContent = "Back on the road â€” deliver those donuts!";
      }

      function updateCar(delta) {
        const forward = new THREE.Vector3(Math.sin(car.heading), 0, Math.cos(car.heading));
        const right = new THREE.Vector3().crossVectors(forward, new THREE.Vector3(0, 1, 0));

        // More punchy acceleration and much stronger braking
        const accel = keyState["ArrowUp"] || keyState["KeyW"] ? 80 : 0;
        const brake = keyState["ArrowDown"] || keyState["KeyS"] ? 120 : 0;
        const boost = keyState["Space"] ? 12 : 0;
        const brakingActive = brake > 0;

        const turn = (keyState["ArrowLeft"] || keyState["KeyA"] ? 1 : 0) - (keyState["ArrowRight"] || keyState["KeyD"] ? 1 : 0);
        // Turning state used in both yaw and drift sections
        const turningActive = (keyState["ArrowLeft"] || keyState["KeyA"] || keyState["ArrowRight"] || keyState["KeyD"]);

        const topSpeed = 60;
        const targetSpeed = Math.max(0, Math.min(topSpeed, car.speed + (accel + boost - brake) * delta));
        // Snappier response towards target speed
        car.speed = THREE.MathUtils.damp(car.speed, targetSpeed, 9.0, delta);

        // Smaller base turn radius; much tighter when braking (handbrake feel)
        const speedNorm = Math.min(1, car.speed / topSpeed);
        let turnGain = THREE.MathUtils.lerp(4.1, 2.0, speedNorm); // slightly reduced base turn rate
        if (brakingActive && turningActive) turnGain *= 1.6; // toned-down extra yaw while braking
        car.heading += turn * delta * turnGain;
        car.heading = THREE.MathUtils.euclideanModulo(car.heading, Math.PI * 2);

        // Drifting: when braking while turning, reduce traction so velocity doesn't align with heading quickly
        const desiredVel = forward.clone().multiplyScalar(car.speed);
        const gripRate = (brakingActive && turningActive) ? 1.6 : 6.5; // lower = more slide; stronger drift when braking
        const lerpT = 1 - Math.exp(-gripRate * delta);
        car.velocity.lerp(desiredVel, lerpT);
        const movement = car.velocity.clone().multiplyScalar(delta);
        car.mesh.position.add(movement);
        car.mesh.rotation.y = car.heading;

        // Visual skid marks when drifting (brake + turn + slip)
        state.skidTimer -= delta;
        if (brakingActive && turningActive && car.velocity.length() > 1) {
          const velDir = car.velocity.clone().normalize();
          const slip = 1 - Math.max(-1, Math.min(1, velDir.dot(forward.clone().normalize())));
          if (slip > 0.12 && state.skidTimer <= 0) {
            spawnSkidMarks(car.mesh.position, forward, right, car.heading, Math.min(1, slip * 2));
            state.skidTimer = 0.045; // throttle spawning
          }
        }

        car.mesh.position.x = THREE.MathUtils.clamp(car.mesh.position.x, -190, 190);
        car.mesh.position.z = THREE.MathUtils.clamp(car.mesh.position.z, -190, 190);

        // car.velocity already updated via drift model

        camera.position.lerp(
          car.mesh.position
            .clone()
            .add(new THREE.Vector3(Math.sin(car.heading) * -12, 7 + boost * 0.1, Math.cos(car.heading) * -12)),
          0.08
        );
        orbit.target.lerp(car.mesh.position.clone().add(new THREE.Vector3(0, 2.5, 0)), 0.12);

        speedEl.textContent = Math.round(car.speed).toString();
      }

      function updateTraffic(delta) {
        trafficGroup.children.forEach((bus) => {
          bus.position.z += bus.userData.speed * delta;
          if (bus.position.z > 200) bus.position.z = -200;
          if (bus.position.z < -200) bus.position.z = 200;
        });
      }

      function checkCollisions(delta) {
        const carPos = car.mesh.position;
        donutsGroup.children.forEach((donut) => {
          if (!donut.visible) return;
          if (donut.position.distanceTo(carPos) < 3) {
            donut.visible = false;
            state.donuts += 1;
            state.combo += 1;
            state.bestCombo = Math.max(state.bestCombo, state.combo);
            elapsed = Math.max(0, elapsed - 2);
            messageEl.textContent = "Nice delivery! +2s";
          }
        });
        donutsGroup.children = donutsGroup.children.filter((donut) => donut.visible);

        trafficGroup.children.forEach((bus) => {
          if (bus.position.distanceTo(carPos) < 4.5) {
            car.speed *= 0.4;
            messageEl.textContent = "Ouch! Watch those buses.";
            state.combo = 0;
            spawnDustEffect(bus.position);
          }
        });

        donutsEl.textContent = `${state.donuts}`;
      }

      function spawnDustEffect(position) {
        const dust = new THREE.Mesh(
          new THREE.SphereGeometry(THREE.MathUtils.randFloat(1, 2), 10, 10),
          new THREE.MeshStandardMaterial({ color: 0xf2b880, transparent: true, opacity: 0.6 })
        );
        dust.position.copy(position).add(new THREE.Vector3(0, 1.4, 0));
        dust.userData = { life: 0.7 };
        dustGroup.add(dust);
      }

      function updateDust(delta) {
        for (let i = dustGroup.children.length - 1; i >= 0; i--) {
          const dust = dustGroup.children[i];
          dust.userData.life -= delta;
          dust.material.opacity = Math.max(0, dust.userData.life / 0.7);
          dust.scale.multiplyScalar(1 + delta * 2);
          if (dust.userData.life <= 0) {
            dustGroup.remove(dust);
            dust.geometry.dispose();
            dust.material.dispose();
          }
        }
      }

      function spawnSkidMarks(carPos, forward, right, heading, strength = 1) {
        const base = carPos.clone().add(forward.clone().multiplyScalar(-1.7));
        const offsets = [-0.9, 0.9];
        offsets.forEach((off) => {
          const pos = base.clone().add(right.clone().multiplyScalar(off));
          const geo = new THREE.PlaneGeometry(1.2 + strength * 0.8, 0.28);
          const mat = new THREE.MeshBasicMaterial({
            map: textures.skidMap,
            transparent: true,
            opacity: Math.min(0.9, 0.4 + strength * 0.5),
            depthWrite: false,
          });
          mat.polygonOffset = true;
          mat.polygonOffsetFactor = -1;
          const skid = new THREE.Mesh(geo, mat);
          skid.position.set(pos.x, 0.06, pos.z);
          skid.rotation.x = -Math.PI / 2; // lay flat
          skid.rotation.y = heading; // align with car
          skid.userData = { life: 0.9 };
          skidGroup.add(skid);
        });

        // Cap total skid marks to avoid perf issues
        const MAX_SKIDS = 220;
        while (skidGroup.children.length > MAX_SKIDS) {
          const old = skidGroup.children.shift();
          if (old) {
            old.geometry.dispose();
            old.material.map?.dispose?.();
            old.material.dispose();
          }
        }
      }

      function updateSkids(delta) {
        for (let i = skidGroup.children.length - 1; i >= 0; i--) {
          const skid = skidGroup.children[i];
          skid.userData.life -= delta;
          const life = skid.userData.life;
          const mat = skid.material;
          mat.opacity = Math.max(0, Math.min(1, life / 0.9));
          if (life <= 0) {
            skidGroup.remove(skid);
            skid.geometry.dispose();
            mat.map?.dispose?.();
            mat.dispose();
          }
        }
      }

      function resetIfOutOfBounds() {
        if (Math.abs(car.mesh.position.x) > 198 || Math.abs(car.mesh.position.z) > 198) {
          resetCar();
        }
      }

      function animate() {
        const delta = Math.min(clock.getDelta(), 0.033);
        if (state.playing) {
          elapsed += delta;
          const timeLeft = Math.max(0, TOTAL_TIME - elapsed);
          timerEl.textContent = timeLeft.toFixed(1);
          if (timeLeft <= 0) {
            state.playing = false;
            if (!state.gameOverShown) {
              state.gameOverShown = true;
              messageEl.textContent = `Shift done! ${state.donuts} donuts delivered. Best combo ${state.bestCombo}.`;
              submitCard.classList.add('active');
              nameInput.focus({ preventScroll: true });
            }
          }
        }

        if (state.playing) {
          updateCar(delta);
          updateTraffic(delta);
          checkCollisions(delta);
          updateDust(delta);
          updateSkids(delta);
          resetIfOutOfBounds();
        }

        orbit.update();
        renderer.render(scene, camera);
        requestAnimationFrame(animate);
      }

      animate();

      // Initialize leaderboard once scene boots
      loadLeaderboard();

      window.addEventListener("resize", () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      });
    </script>
  </body>
</html>
