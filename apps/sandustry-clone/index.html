<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Boom Miner - TNT Mining Game</title>
    <link rel="icon" href="https://emojicdn.elk.sh/üí£">

    <meta property="og:title" content="Boom Miner">
    <meta property="og:description" content="Mine with TNT explosions! Blow up terrain in this explosive physics game">
    <meta property="og:url" content="https://app.vibecodedbyx.com/sandustry-clone">
    <meta property="og:image" content="https://app.vibecodedbyx.com/sandustry-clone/og-image.png">

    <script src="https://cdn.jsdelivr.net/npm/phaser@3.70.0/dist/phaser.min.js"></script>

    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Courier New', monospace;
            background: #1a1a2e;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            color: #fff;
        }

        .back-link {
            position: absolute;
            top: 20px;
            left: 20px;
            color: white;
            text-decoration: none;
            padding: 10px 20px;
            background: rgba(255,255,255,0.1);
            border-radius: 8px;
            font-size: 14px;
            z-index: 1000;
        }

        .back-link:hover {
            background: rgba(255,255,255,0.2);
        }

        #game-container {
            box-shadow: 0 8px 32px rgba(0,0,0,0.5);
            border-radius: 8px;
            overflow: hidden;
        }

        .ui-overlay {
            position: absolute;
            top: 80px;
            left: 20px;
            background: rgba(0,0,0,0.7);
            padding: 15px;
            border-radius: 8px;
            font-size: 14px;
            z-index: 100;
            min-width: 200px;
        }

        .ui-stat {
            margin: 8px 0;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .ui-label {
            color: #aaa;
        }

        .ui-value {
            color: #4ecdc4;
            font-weight: bold;
            margin-left: 15px;
        }

        .controls {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0,0,0,0.7);
            padding: 15px 25px;
            border-radius: 8px;
            font-size: 12px;
            z-index: 100;
            text-align: center;
        }

        .controls-title {
            font-weight: bold;
            margin-bottom: 10px;
            color: #ffd700;
        }

        .control-item {
            margin: 5px 0;
        }

        @media (max-width: 768px) {
            .ui-overlay {
                top: 60px;
                left: 10px;
                font-size: 12px;
                padding: 10px;
            }

            .controls {
                bottom: 10px;
                font-size: 10px;
                padding: 10px 15px;
            }
        }
    </style>
</head>
<body>
    <a href="https://www.vibecodedbyx.com" class="back-link">‚Üê Back</a>
            <a href="https://app.vibecodedbyx.com/overview" style="color:#4ecdc4;text-decoration:none;margin-left:10px">üé® View All Apps</a>

    <div class="ui-overlay">
        <div class="ui-stat">
            <span class="ui-label">Sand:</span>
            <span class="ui-value" id="sandCount">0</span>
        </div>
        <div class="ui-stat">
            <span class="ui-label">Gold:</span>
            <span class="ui-value" id="goldCount">0</span>
        </div>
        <div class="ui-stat">
            <span class="ui-label">Stone:</span>
            <span class="ui-value" id="stoneCount">0</span>
        </div>
        <div class="ui-stat">
            <span class="ui-label">üí£ TNT:</span>
            <span class="ui-value" id="tntCount">5</span>
        </div>
        <div class="ui-stat">
            <span class="ui-label">Depth:</span>
            <span class="ui-value" id="depth">0m</span>
        </div>
    </div>

    <div id="game-container"></div>

    <div class="controls">
        <div class="controls-title">CONTROLS</div>
        <div class="control-item">‚Üê‚Üí Move | ‚Üë Jump</div>
        <div class="control-item">Left Click - Mine | Right Click - Place TNT üí£</div>
        <div class="control-item">Middle Click (or T key) - Detonate All TNT!</div>
        <div class="control-item">Place TNT and watch it BOOM! üí•</div>
    </div>

    <script>
        const TILE_SIZE = 8;
        const WORLD_WIDTH = 100;
        const WORLD_HEIGHT = 150;

        // Material types
        const MATERIALS = {
            AIR: 0,
            SAND: 1,
            STONE: 2,
            GOLD: 3,
            BEDROCK: 4,
            TNT: 5
        };

        const MATERIAL_COLORS = {
            [MATERIALS.AIR]: 0x87ceeb,
            [MATERIALS.SAND]: 0xf4a460,
            [MATERIALS.STONE]: 0x808080,
            [MATERIALS.GOLD]: 0xffd700,
            [MATERIALS.BEDROCK]: 0x2f2f2f,
            [MATERIALS.TNT]: 0xff0000
        };

        class GameScene extends Phaser.Scene {
            constructor() {
                super({ key: 'GameScene' });
            }

            create() {
                // Initialize world grid
                this.world = [];
                this.resources = { sand: 0, gold: 0, stone: 0, tnt: 5 };
                this.playerDepth = 0;
                this.tntEntities = []; // TNT as physics objects instead of blocks

                // Generate world
                this.generateWorld();

                // Create graphics
                this.worldGraphics = this.add.graphics();
                this.renderWorld();

                // Create player
                this.player = this.add.circle(400, 100, 10, 0xff0000);
                this.physics.add.existing(this.player);
                this.player.body.setCollideWorldBounds(false);
                this.player.body.setGravityY(600);

                // Camera
                this.cameras.main.setBounds(0, 0, WORLD_WIDTH * TILE_SIZE, WORLD_HEIGHT * TILE_SIZE);
                this.cameras.main.startFollow(this.player, true, 0.1, 0.1);

                // Input
                this.cursors = this.input.keyboard.createCursorKeys();
                this.input.on('pointerdown', this.handleClick, this);
                this.input.keyboard.on('keydown-T', this.detonateAllTNT, this);

                // Physics update
                this.time.addEvent({
                    delay: 100,
                    callback: this.updatePhysics,
                    callbackScope: this,
                    loop: true
                });

                // UI update
                this.time.addEvent({
                    delay: 100,
                    callback: this.updateUI,
                    callbackScope: this,
                    loop: true
                });
            }

            generateWorld() {
                for (let y = 0; y < WORLD_HEIGHT; y++) {
                    this.world[y] = [];
                    for (let x = 0; x < WORLD_WIDTH; x++) {
                        if (y < 10) {
                            this.world[y][x] = MATERIALS.AIR;
                        } else if (y > WORLD_HEIGHT - 5) {
                            this.world[y][x] = MATERIALS.BEDROCK;
                        } else {
                            const rand = Math.random();
                            if (rand < 0.05) {
                                // Spawn TNT entity at this location (5% chance)
                                const worldX = x * TILE_SIZE + TILE_SIZE;
                                const worldY = y * TILE_SIZE + TILE_SIZE;

                                // Delay spawning until after create() finishes
                                this.time.delayedCall(100, () => {
                                    this.spawnTNT(worldX, worldY);
                                });

                                this.world[y][x] = MATERIALS.AIR; // TNT entities need air space
                            } else if (rand < 0.55) {
                                this.world[y][x] = MATERIALS.SAND;
                            } else if (rand < 0.85) {
                                this.world[y][x] = MATERIALS.STONE;
                            } else {
                                this.world[y][x] = MATERIALS.GOLD;
                            }
                        }
                    }
                }

                // Create starting area
                for (let y = 0; y < 15; y++) {
                    for (let x = 45; x < 55; x++) {
                        this.world[y][x] = MATERIALS.AIR;
                    }
                }
            }

            renderWorld() {
                this.worldGraphics.clear();
                const camX = Math.floor(this.cameras.main.scrollX / TILE_SIZE);
                const camY = Math.floor(this.cameras.main.scrollY / TILE_SIZE);
                const camW = Math.ceil(this.cameras.main.width / TILE_SIZE) + 2;
                const camH = Math.ceil(this.cameras.main.height / TILE_SIZE) + 2;

                for (let y = Math.max(0, camY); y < Math.min(WORLD_HEIGHT, camY + camH); y++) {
                    for (let x = Math.max(0, camX); x < Math.min(WORLD_WIDTH, camX + camW); x++) {
                        const material = this.world[y][x];
                        if (material !== MATERIALS.AIR) {
                            this.worldGraphics.fillStyle(MATERIAL_COLORS[material]);
                            this.worldGraphics.fillRect(x * TILE_SIZE, y * TILE_SIZE, TILE_SIZE, TILE_SIZE);

                            // Draw TNT text
                            if (material === MATERIALS.TNT) {
                                this.worldGraphics.fillStyle(0xffffff);
                                this.worldGraphics.fillRect(x * TILE_SIZE + 2, y * TILE_SIZE + 2, 4, 4);
                            }
                        }
                    }
                }
            }

            spawnTNT(x, y) {
                // Create a 2x2 TNT sprite
                const tnt = this.add.rectangle(x, y, TILE_SIZE * 2, TILE_SIZE * 2, 0xff0000);
                this.physics.add.existing(tnt);
                tnt.body.setGravityY(600);
                tnt.body.setBounce(0.3);

                // Add white fuse marker
                const fuse = this.add.rectangle(x, y - 8, 4, 4, 0xffffff);

                this.tntEntities.push({ sprite: tnt, fuse: fuse });
            }

            detonateAllTNT() {
                if (this.tntEntities.length === 0) return;

                // Create explosions at each TNT position
                for (const tntData of this.tntEntities) {
                    const gridX = Math.floor(tntData.sprite.x / TILE_SIZE);
                    const gridY = Math.floor(tntData.sprite.y / TILE_SIZE);
                    this.createExplosion(gridX, gridY);

                    // Destroy TNT sprites
                    tntData.sprite.destroy();
                    tntData.fuse.destroy();
                }

                this.tntEntities = [];
                this.renderWorld();
            }

            createExplosion(centerX, centerY) {
                const explosionRadius = 8; // Radius in tiles

                // Camera shake
                this.cameras.main.shake(300, 0.01);

                // Create particle effect
                const particles = this.add.particles(centerX * TILE_SIZE + TILE_SIZE/2, centerY * TILE_SIZE + TILE_SIZE/2);
                const emitter = particles.createEmitter({
                    speed: { min: 100, max: 300 },
                    angle: { min: 0, max: 360 },
                    scale: { start: 1, end: 0 },
                    blendMode: 'ADD',
                    lifespan: 600,
                    quantity: 30,
                    tint: [0xff0000, 0xff6600, 0xffff00]
                });
                emitter.explode();

                // Destroy particles after animation
                this.time.delayedCall(1000, () => {
                    particles.destroy();
                });

                // Check for chain reactions with other TNT entities
                const explosionWorldX = centerX * TILE_SIZE;
                const explosionWorldY = centerY * TILE_SIZE;
                const explosionWorldRadius = explosionRadius * TILE_SIZE;

                for (let i = this.tntEntities.length - 1; i >= 0; i--) {
                    const tntData = this.tntEntities[i];
                    const dist = Phaser.Math.Distance.Between(
                        explosionWorldX, explosionWorldY,
                        tntData.sprite.x, tntData.sprite.y
                    );

                    if (dist <= explosionWorldRadius) {
                        // Chain reaction!
                        const tntGridX = Math.floor(tntData.sprite.x / TILE_SIZE);
                        const tntGridY = Math.floor(tntData.sprite.y / TILE_SIZE);

                        tntData.sprite.destroy();
                        tntData.fuse.destroy();
                        this.tntEntities.splice(i, 1);

                        this.time.delayedCall(100, () => {
                            this.createExplosion(tntGridX, tntGridY);
                        });
                    }
                }

                // Destroy blocks in explosion radius
                for (let dy = -explosionRadius; dy <= explosionRadius; dy++) {
                    for (let dx = -explosionRadius; dx <= explosionRadius; dx++) {
                        const x = centerX + dx;
                        const y = centerY + dy;
                        const dist = Math.sqrt(dx * dx + dy * dy);

                        if (dist <= explosionRadius && x >= 0 && x < WORLD_WIDTH && y >= 0 && y < WORLD_HEIGHT) {
                            const material = this.world[y][x];

                            // Don't destroy bedrock or TNT blocks
                            if (material !== MATERIALS.BEDROCK && material !== MATERIALS.TNT) {
                                // Collect resources before destroying
                                if (material === MATERIALS.SAND) this.resources.sand++;
                                else if (material === MATERIALS.STONE) this.resources.stone++;
                                else if (material === MATERIALS.GOLD) this.resources.gold++;

                                this.world[y][x] = MATERIALS.AIR;
                            }
                        }
                    }
                }
            }

            update() {
                // Player movement
                const speed = 200;
                if (this.cursors.left.isDown) {
                    this.player.body.setVelocityX(-speed);
                } else if (this.cursors.right.isDown) {
                    this.player.body.setVelocityX(speed);
                } else {
                    this.player.body.setVelocityX(0);
                }

                // Jump
                if (this.cursors.up.isDown && this.isOnGround()) {
                    this.player.body.setVelocityY(-300);
                }

                // Check collisions with terrain
                this.handleTerrainCollision();

                // Update TNT entities
                for (let i = this.tntEntities.length - 1; i >= 0; i--) {
                    const tntData = this.tntEntities[i];

                    // Update fuse position to follow TNT
                    tntData.fuse.x = tntData.sprite.x;
                    tntData.fuse.y = tntData.sprite.y - 8;

                    // Check collision with terrain
                    const gridX = Math.floor(tntData.sprite.x / TILE_SIZE);
                    const gridY = Math.floor((tntData.sprite.y + TILE_SIZE) / TILE_SIZE);

                    // Check 2x2 area below TNT
                    let hasGround = false;
                    for (let dx = 0; dx < 2; dx++) {
                        const checkX = gridX + dx;
                        if (checkX >= 0 && checkX < WORLD_WIDTH && gridY >= 0 && gridY < WORLD_HEIGHT) {
                            const material = this.world[gridY][checkX];
                            if (material !== MATERIALS.AIR) {
                                hasGround = true;
                                break;
                            }
                        }
                    }

                    if (hasGround) {
                        // Stop TNT
                        tntData.sprite.body.setVelocityY(0);
                        // Snap to grid
                        tntData.sprite.y = (gridY - 1) * TILE_SIZE + TILE_SIZE;
                    }
                }

                // Update depth
                this.playerDepth = Math.max(0, Math.floor((this.player.y / TILE_SIZE) - 10));
            }

            isOnGround() {
                const gridX = Math.floor(this.player.x / TILE_SIZE);
                const gridY = Math.floor((this.player.y + 11) / TILE_SIZE);

                for (let dx = -1; dx <= 1; dx++) {
                    const x = gridX + dx;
                    if (x >= 0 && x < WORLD_WIDTH && gridY >= 0 && gridY < WORLD_HEIGHT) {
                        if (this.world[gridY][x] !== MATERIALS.AIR) {
                            return true;
                        }
                    }
                }
                return false;
            }

            handleTerrainCollision() {
                const gridX = Math.floor(this.player.x / TILE_SIZE);
                const gridY = Math.floor(this.player.y / TILE_SIZE);

                // Check if player is inside terrain
                if (gridX >= 0 && gridX < WORLD_WIDTH && gridY >= 0 && gridY < WORLD_HEIGHT) {
                    if (this.world[gridY][gridX] !== MATERIALS.AIR) {
                        // Push player up
                        this.player.y = gridY * TILE_SIZE - 11;
                        this.player.body.setVelocityY(0);
                    }
                }
            }

            handleClick(pointer) {
                const worldX = pointer.worldX;
                const worldY = pointer.worldY;
                const gridX = Math.floor(worldX / TILE_SIZE);
                const gridY = Math.floor(worldY / TILE_SIZE);

                if (gridX < 0 || gridX >= WORLD_WIDTH || gridY < 0 || gridY >= WORLD_HEIGHT) return;

                // Check distance from player
                const playerGridX = Math.floor(this.player.x / TILE_SIZE);
                const playerGridY = Math.floor(this.player.y / TILE_SIZE);
                const dist = Math.sqrt(Math.pow(gridX - playerGridX, 2) + Math.pow(gridY - playerGridY, 2));

                if (dist > 5) return; // Mining range

                if (pointer.leftButtonDown()) {
                    // Mine block
                    const material = this.world[gridY][gridX];
                    if (material !== MATERIALS.AIR && material !== MATERIALS.BEDROCK && material !== MATERIALS.TNT) {
                        this.world[gridY][gridX] = MATERIALS.AIR;

                        // Add to resources
                        if (material === MATERIALS.SAND) this.resources.sand++;
                        else if (material === MATERIALS.STONE) this.resources.stone++;
                        else if (material === MATERIALS.GOLD) this.resources.gold++;

                        this.renderWorld();
                    }
                } else if (pointer.rightButtonDown()) {
                    // Place TNT entity (2x2)
                    if (this.resources.tnt > 0) {
                        // Check if there's space for 2x2 TNT
                        let canPlace = true;
                        for (let dy = 0; dy < 2; dy++) {
                            for (let dx = 0; dx < 2; dx++) {
                                const checkX = gridX + dx;
                                const checkY = gridY + dy;
                                if (checkX >= WORLD_WIDTH || checkY >= WORLD_HEIGHT ||
                                    this.world[checkY][checkX] !== MATERIALS.AIR) {
                                    canPlace = false;
                                }
                            }
                        }

                        if (canPlace) {
                            this.resources.tnt--;
                            this.spawnTNT(worldX, worldY);
                        }
                    }
                } else if (pointer.button === 1) {
                    // Middle click - detonate
                    this.detonateAllTNT();
                }
            }

            updatePhysics() {
                // Simple falling sand physics
                for (let y = WORLD_HEIGHT - 2; y >= 0; y--) {
                    for (let x = 0; x < WORLD_WIDTH; x++) {
                        const material = this.world[y][x];

                        if (material === MATERIALS.SAND) {
                            const below = this.world[y + 1][x];

                            if (below === MATERIALS.AIR) {
                                // Fall straight down
                                this.world[y][x] = MATERIALS.AIR;
                                this.world[y + 1][x] = MATERIALS.SAND;
                            } else if (Math.random() < 0.5) {
                                // Try to slide sideways
                                const dir = Math.random() < 0.5 ? -1 : 1;
                                const sideX = x + dir;

                                if (sideX >= 0 && sideX < WORLD_WIDTH) {
                                    const side = this.world[y + 1][sideX];
                                    const sideBlock = this.world[y][sideX];

                                    if (side === MATERIALS.AIR && sideBlock === MATERIALS.AIR) {
                                        this.world[y][x] = MATERIALS.AIR;
                                        this.world[y + 1][sideX] = MATERIALS.SAND;
                                    }
                                }
                            }
                        }
                    }
                }

                this.renderWorld();
            }

            updateUI() {
                document.getElementById('sandCount').textContent = this.resources.sand;
                document.getElementById('goldCount').textContent = this.resources.gold;
                document.getElementById('stoneCount').textContent = this.resources.stone;
                document.getElementById('tntCount').textContent = this.resources.tnt;
                document.getElementById('depth').textContent = this.playerDepth + 'm';
            }
        }

        const config = {
            type: Phaser.AUTO,
            width: 800,
            height: 600,
            parent: 'game-container',
            backgroundColor: '#87ceeb',
            physics: {
                default: 'arcade',
                arcade: {
                    gravity: { y: 0 },
                    debug: false
                }
            },
            scene: [GameScene]
        };

        const game = new Phaser.Game(config);
    </script>
</body>
</html>
