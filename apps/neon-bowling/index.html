<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Neon Bowling - Explosive Strikes</title>
  <link rel="icon" href="https://emojicdn.elk.sh/ðŸŽ³">
  <meta property="og:title" content="Neon Bowling">
  <meta property="og:description" content="3D bowling with explosive neon pins">
  <meta property="og:url" content="https://app.sloppy.live/neon-bowling">
  <meta property="og:image" content="https://emojicdn.elk.sh/ðŸŽ³?style=apple&size=512">
  <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&display=swap" rel="stylesheet">
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      background: #0a0a15;
      overflow: hidden;
      font-family: 'Orbitron', sans-serif;
    }
    canvas { display: block; }

    .ui {
      position: fixed;
      top: 20px;
      left: 50%;
      transform: translateX(-50%);
      text-align: center;
      z-index: 100;
      pointer-events: none;
    }

    .score {
      font-size: 2.5rem;
      font-weight: 900;
      color: #00ffff;
      text-shadow: 0 0 30px #00ffff, 0 0 60px #00ffff;
    }

    .frame-info {
      font-size: 1rem;
      color: #ff00ff;
      text-shadow: 0 0 15px #ff00ff;
      margin-top: 10px;
    }

    .message {
      font-size: 3rem;
      font-weight: 900;
      color: #ffff00;
      text-shadow: 0 0 40px #ffff00, 0 0 80px #ff6600;
      margin-top: 20px;
      opacity: 0;
      transition: opacity 0.3s;
    }

    .message.show { opacity: 1; }

    .power-container {
      position: fixed;
      bottom: 30px;
      left: 50%;
      transform: translateX(-50%);
      z-index: 100;
      text-align: center;
    }

    .power-bar {
      width: 300px;
      height: 25px;
      background: rgba(0, 0, 0, 0.6);
      border: 3px solid #ff00ff;
      border-radius: 15px;
      overflow: hidden;
      margin-bottom: 10px;
    }

    .power-fill {
      height: 100%;
      width: 0%;
      background: linear-gradient(90deg, #00ff00, #ffff00, #ff0000);
      box-shadow: 0 0 20px #00ff00;
      transition: width 0.05s;
    }

    .aim-indicator {
      width: 200px;
      height: 15px;
      background: rgba(0, 0, 0, 0.6);
      border: 2px solid #00ffff;
      border-radius: 10px;
      margin: 0 auto 15px;
      position: relative;
    }

    .aim-marker {
      position: absolute;
      width: 10px;
      height: 100%;
      background: #00ffff;
      box-shadow: 0 0 15px #00ffff;
      border-radius: 5px;
      left: 50%;
      transform: translateX(-50%);
    }

    .instructions {
      color: rgba(255, 255, 255, 0.5);
      font-size: 0.7rem;
      margin-top: 10px;
    }

    .backlink {
      position: fixed;
      bottom: 10px;
      right: 15px;
      color: rgba(255, 255, 255, 0.3);
      font-size: 0.7rem;
      text-decoration: none;
      z-index: 100;
    }
    .backlink:hover { color: #00ffff; }

    .reset-btn {
      position: fixed;
      top: 20px;
      right: 20px;
      padding: 10px 20px;
      background: rgba(255, 0, 255, 0.2);
      border: 2px solid #ff00ff;
      color: #ff00ff;
      font-family: 'Orbitron', sans-serif;
      font-size: 0.8rem;
      cursor: pointer;
      border-radius: 10px;
      z-index: 100;
    }
    .reset-btn:hover {
      background: rgba(255, 0, 255, 0.4);
      box-shadow: 0 0 20px #ff00ff;
    }
  </style>
</head>
<body>
  <div class="ui">
    <div class="score">SCORE: <span id="score">0</span></div>
    <div class="frame-info">Frame <span id="frame">1</span> | Roll <span id="roll">1</span></div>
    <div class="message" id="message">STRIKE!</div>
  </div>

  <div class="power-container">
    <div class="aim-indicator">
      <div class="aim-marker" id="aim-marker"></div>
    </div>
    <div class="power-bar">
      <div class="power-fill" id="power-fill"></div>
    </div>
    <div class="instructions">Click/Tap and hold to charge, release to throw</div>
  </div>

  <button class="reset-btn" id="reset-btn">RESET</button>
  <a href="https://sloppy.live" class="backlink">sloppy.live</a>

  <script type="importmap">
    {
      "imports": {
        "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
        "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
      }
    }
  </script>

  <script type="module">
    import * as THREE from 'three';

    // Scene setup
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x0a0a15);
    scene.fog = new THREE.Fog(0x0a0a15, 10, 50);

    const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 100);
    camera.position.set(0, 3, 8);
    camera.lookAt(0, 0, -10);

    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    renderer.shadowMap.enabled = true;
    document.body.appendChild(renderer.domElement);

    // Resize
    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });

    // Lighting
    const ambientLight = new THREE.AmbientLight(0x222233, 0.5);
    scene.add(ambientLight);

    const spotlight = new THREE.SpotLight(0xffffff, 2);
    spotlight.position.set(0, 15, -5);
    spotlight.angle = 0.4;
    spotlight.penumbra = 0.5;
    spotlight.castShadow = true;
    scene.add(spotlight);

    // Neon lights
    const neonColors = [0xff00ff, 0x00ffff, 0xff6600, 0x00ff00];
    neonColors.forEach((color, i) => {
      const light = new THREE.PointLight(color, 1, 15);
      light.position.set(-3 + i * 2, 3, -15);
      scene.add(light);
    });

    // Lane
    const laneGeom = new THREE.BoxGeometry(3, 0.1, 25);
    const laneMat = new THREE.MeshStandardMaterial({
      color: 0x1a1a2e,
      emissive: 0x0a0a15,
      metalness: 0.8,
      roughness: 0.3
    });
    const lane = new THREE.Mesh(laneGeom, laneMat);
    lane.position.set(0, -0.05, -7);
    lane.receiveShadow = true;
    scene.add(lane);

    // Lane stripes (neon)
    const stripeGeom = new THREE.BoxGeometry(0.05, 0.12, 25);
    const stripeMat = new THREE.MeshBasicMaterial({ color: 0xff00ff });
    [-1.4, 1.4].forEach(x => {
      const stripe = new THREE.Mesh(stripeGeom, stripeMat);
      stripe.position.set(x, 0, -7);
      scene.add(stripe);
    });

    // Gutter markers
    const gutterMat = new THREE.MeshBasicMaterial({ color: 0x00ffff });
    for (let z = 0; z > -20; z -= 2) {
      [-1.2, 1.2].forEach(x => {
        const dot = new THREE.Mesh(new THREE.SphereGeometry(0.05), gutterMat);
        dot.position.set(x, 0.05, z);
        scene.add(dot);
      });
    }

    // Pin positions (standard bowling)
    const pinPositions = [
      [0, 0],
      [-0.3, -0.5], [0.3, -0.5],
      [-0.6, -1], [0, -1], [0.6, -1],
      [-0.9, -1.5], [-0.3, -1.5], [0.3, -1.5], [0.9, -1.5]
    ];

    // Pin class
    class Pin {
      constructor(x, z, index) {
        this.index = index;
        this.baseX = x;
        this.baseZ = z - 18;
        this.knocked = false;

        // Pin geometry (cylinder with rounded top)
        const group = new THREE.Group();

        // Body
        const bodyGeom = new THREE.CylinderGeometry(0.08, 0.12, 0.5, 16);
        const bodyMat = new THREE.MeshStandardMaterial({
          color: 0xffffff,
          emissive: 0x00ffff,
          emissiveIntensity: 0.3
        });
        const body = new THREE.Mesh(bodyGeom, bodyMat);
        body.position.y = 0.25;
        body.castShadow = true;
        group.add(body);

        // Neck
        const neckGeom = new THREE.CylinderGeometry(0.06, 0.08, 0.15, 16);
        const neck = new THREE.Mesh(neckGeom, bodyMat);
        neck.position.y = 0.55;
        group.add(neck);

        // Head
        const headGeom = new THREE.SphereGeometry(0.07, 16, 16);
        const head = new THREE.Mesh(headGeom, bodyMat);
        head.position.y = 0.68;
        group.add(head);

        // Stripe
        const stripeGeom = new THREE.CylinderGeometry(0.085, 0.095, 0.08, 16);
        const stripeMat = new THREE.MeshBasicMaterial({ color: 0xff0066 });
        const stripe = new THREE.Mesh(stripeGeom, stripeMat);
        stripe.position.y = 0.35;
        group.add(stripe);

        // Glow
        const glowGeom = new THREE.SphereGeometry(0.25, 16, 16);
        const glowMat = new THREE.MeshBasicMaterial({
          color: 0x00ffff,
          transparent: true,
          opacity: 0.15
        });
        const glow = new THREE.Mesh(glowGeom, glowMat);
        glow.position.y = 0.35;
        group.add(glow);

        this.mesh = group;
        this.mesh.position.set(this.baseX, 0, this.baseZ);
        scene.add(this.mesh);

        // Physics
        this.vx = 0;
        this.vy = 0;
        this.vz = 0;
        this.rotX = 0;
        this.rotZ = 0;
        this.vRotX = 0;
        this.vRotZ = 0;
      }

      reset() {
        this.mesh.position.set(this.baseX, 0, this.baseZ);
        this.mesh.rotation.set(0, 0, 0);
        this.vx = 0;
        this.vy = 0;
        this.vz = 0;
        this.vRotX = 0;
        this.vRotZ = 0;
        this.knocked = false;
        this.mesh.visible = true;
      }

      update(dt) {
        if (!this.knocked) return;

        // Gravity
        this.vy -= 15 * dt;

        // Update position
        this.mesh.position.x += this.vx * dt;
        this.mesh.position.y += this.vy * dt;
        this.mesh.position.z += this.vz * dt;

        // Update rotation
        this.mesh.rotation.x += this.vRotX * dt;
        this.mesh.rotation.z += this.vRotZ * dt;

        // Floor collision
        if (this.mesh.position.y < 0) {
          this.mesh.position.y = 0;
          this.vy *= -0.3;
          this.vx *= 0.7;
          this.vz *= 0.7;
          this.vRotX *= 0.7;
          this.vRotZ *= 0.7;
        }

        // Friction
        this.vx *= 0.98;
        this.vz *= 0.98;
      }

      hit(force, angle) {
        if (this.knocked) return;
        this.knocked = true;

        const spread = (Math.random() - 0.5) * 2;
        this.vx = Math.sin(angle) * force * 0.5 + spread * 3;
        this.vy = force * 0.3 + Math.random() * 2;
        this.vz = Math.cos(angle) * force * 0.3;
        this.vRotX = (Math.random() - 0.5) * 15;
        this.vRotZ = (Math.random() - 0.5) * 15;

        // Spawn explosion particles
        spawnExplosion(this.mesh.position.x, this.mesh.position.y + 0.3, this.mesh.position.z);
      }
    }

    // Create pins
    let pins = [];
    function createPins() {
      pins.forEach(p => scene.remove(p.mesh));
      pins = [];
      pinPositions.forEach((pos, i) => {
        pins.push(new Pin(pos[0], pos[1], i));
      });
    }
    createPins();

    // Ball
    const ballGeom = new THREE.SphereGeometry(0.2, 32, 32);
    const ballMat = new THREE.MeshStandardMaterial({
      color: 0xff00ff,
      emissive: 0xff00ff,
      emissiveIntensity: 0.4,
      metalness: 0.9,
      roughness: 0.1
    });
    const ball = new THREE.Mesh(ballGeom, ballMat);
    ball.castShadow = true;
    scene.add(ball);

    // Ball glow
    const ballGlow = new THREE.PointLight(0xff00ff, 1, 3);
    ball.add(ballGlow);

    // Ball state
    let ballState = {
      x: 0,
      y: 0.2,
      z: 5,
      vx: 0,
      vy: 0,
      vz: 0,
      thrown: false,
      settled: false
    };

    function resetBall() {
      ballState = {
        x: 0,
        y: 0.2,
        z: 5,
        vx: 0,
        vy: 0,
        vz: 0,
        thrown: false,
        settled: false
      };
      ball.position.set(0, 0.2, 5);
    }

    // Explosion particles
    let particles = [];

    function spawnExplosion(x, y, z) {
      const colors = [0xff00ff, 0x00ffff, 0xffff00, 0xff6600, 0x00ff00];

      for (let i = 0; i < 25; i++) {
        const geom = new THREE.SphereGeometry(0.05 + Math.random() * 0.08);
        const mat = new THREE.MeshBasicMaterial({
          color: colors[Math.floor(Math.random() * colors.length)],
          transparent: true
        });
        const particle = new THREE.Mesh(geom, mat);
        particle.position.set(x, y, z);

        const angle = Math.random() * Math.PI * 2;
        const upAngle = Math.random() * Math.PI * 0.5;
        const speed = 3 + Math.random() * 5;

        particle.userData = {
          vx: Math.cos(angle) * Math.cos(upAngle) * speed,
          vy: Math.sin(upAngle) * speed + 2,
          vz: Math.sin(angle) * Math.cos(upAngle) * speed,
          life: 1
        };

        scene.add(particle);
        particles.push(particle);
      }
    }

    function updateParticles(dt) {
      for (let i = particles.length - 1; i >= 0; i--) {
        const p = particles[i];
        const d = p.userData;

        d.vy -= 10 * dt;
        p.position.x += d.vx * dt;
        p.position.y += d.vy * dt;
        p.position.z += d.vz * dt;

        d.life -= dt * 2;
        p.material.opacity = d.life;

        if (d.life <= 0) {
          scene.remove(p);
          particles.splice(i, 1);
        }
      }
    }

    // Game state
    let score = 0;
    let frame = 1;
    let rollNum = 1;
    let power = 0;
    let charging = false;
    let aimX = 0;
    let aimDir = 1;

    // UI
    const powerFill = document.getElementById('power-fill');
    const aimMarker = document.getElementById('aim-marker');
    const messageEl = document.getElementById('message');

    function updateUI() {
      document.getElementById('score').textContent = score;
      document.getElementById('frame').textContent = frame;
      document.getElementById('roll').textContent = rollNum;
    }

    function showMessage(text) {
      messageEl.textContent = text;
      messageEl.classList.add('show');
      setTimeout(() => messageEl.classList.remove('show'), 2000);
    }

    // Input
    let isDown = false;

    function startCharge() {
      if (ballState.thrown) return;
      isDown = true;
      charging = true;
      power = 0;
    }

    function releaseThrow() {
      if (!charging || ballState.thrown) return;
      isDown = false;
      charging = false;

      // Throw ball
      ballState.thrown = true;
      ballState.vx = aimX * 3;
      ballState.vz = -power * 0.3;
      ballState.vy = 0;

      powerFill.style.width = '0%';
    }

    document.addEventListener('mousedown', startCharge);
    document.addEventListener('mouseup', releaseThrow);
    document.addEventListener('touchstart', e => { e.preventDefault(); startCharge(); });
    document.addEventListener('touchend', e => { e.preventDefault(); releaseThrow(); });

    document.getElementById('reset-btn').addEventListener('click', () => {
      score = 0;
      frame = 1;
      rollNum = 1;
      updateUI();
      createPins();
      resetBall();
    });

    // Check pins
    function countKnockedPins() {
      return pins.filter(p => p.knocked).length;
    }

    function endRoll() {
      const knocked = countKnockedPins();

      if (rollNum === 1 && knocked === 10) {
        // Strike!
        score += 30;
        showMessage('STRIKE!');
        setTimeout(() => {
          frame++;
          rollNum = 1;
          if (frame > 10) {
            showMessage('GAME OVER!');
            frame = 1;
          }
          createPins();
          resetBall();
          updateUI();
        }, 2500);
      } else if (rollNum === 1) {
        score += knocked;
        rollNum = 2;
        resetBall();
        updateUI();
      } else {
        const secondKnocked = knocked - pins.filter(p => p.knocked && p.wasKnockedFirstRoll).length;
        if (knocked === 10) {
          score += 15;
          showMessage('SPARE!');
        } else {
          score += secondKnocked;
        }
        setTimeout(() => {
          frame++;
          rollNum = 1;
          if (frame > 10) {
            showMessage('GAME OVER!');
            frame = 1;
          }
          createPins();
          resetBall();
          updateUI();
        }, 2000);
      }
      updateUI();
    }

    // Animation loop
    let lastTime = 0;
    let settleTimer = 0;

    function animate(time) {
      requestAnimationFrame(animate);

      const dt = Math.min((time - lastTime) / 1000, 0.05);
      lastTime = time;

      // Aim oscillation
      if (!ballState.thrown) {
        aimX += aimDir * dt * 2;
        if (aimX > 1) { aimX = 1; aimDir = -1; }
        if (aimX < -1) { aimX = -1; aimDir = 1; }
        aimMarker.style.left = (50 + aimX * 45) + '%';

        // Ball follows aim
        ball.position.x = aimX * 1.2;
      }

      // Power charging
      if (charging && !ballState.thrown) {
        power = Math.min(100, power + dt * 80);
        powerFill.style.width = power + '%';
      }

      // Ball physics
      if (ballState.thrown && !ballState.settled) {
        ballState.vy -= 5 * dt;
        ballState.x += ballState.vx * dt;
        ballState.y += ballState.vy * dt;
        ballState.z += ballState.vz * dt;

        // Floor
        if (ballState.y < 0.2) {
          ballState.y = 0.2;
          ballState.vy = 0;
        }

        // Lane boundaries
        if (Math.abs(ballState.x) > 1.3) {
          ballState.vx *= -0.5;
          ballState.x = Math.sign(ballState.x) * 1.3;
        }

        ball.position.set(ballState.x, ballState.y, ballState.z);
        ball.rotation.x -= ballState.vz * dt * 3;

        // Pin collision
        pins.forEach(pin => {
          if (pin.knocked) return;
          const dx = ballState.x - pin.mesh.position.x;
          const dz = ballState.z - pin.mesh.position.z;
          const dist = Math.sqrt(dx * dx + dz * dz);

          if (dist < 0.35) {
            const angle = Math.atan2(dx, dz);
            const force = Math.sqrt(ballState.vx * ballState.vx + ballState.vz * ballState.vz);
            pin.hit(force, angle);

            // Slow ball slightly
            ballState.vx *= 0.9;
            ballState.vz *= 0.9;
          }
        });

        // Pin-to-pin collision
        for (let i = 0; i < pins.length; i++) {
          for (let j = i + 1; j < pins.length; j++) {
            const p1 = pins[i];
            const p2 = pins[j];
            if (!p1.knocked && !p2.knocked) continue;
            if (!p1.knocked || !p2.knocked) {
              // Moving pin hits stationary pin
              const moving = p1.knocked ? p1 : p2;
              const stationary = p1.knocked ? p2 : p1;

              const dx = moving.mesh.position.x - stationary.mesh.position.x;
              const dz = moving.mesh.position.z - stationary.mesh.position.z;
              const dist = Math.sqrt(dx * dx + dz * dz);

              if (dist < 0.3) {
                const speed = Math.sqrt(moving.vx * moving.vx + moving.vz * moving.vz);
                if (speed > 1) {
                  const angle = Math.atan2(dx, dz);
                  stationary.hit(speed * 0.7, angle + Math.PI);
                }
              }
            }
          }
        }

        // Check if ball passed pins
        if (ballState.z < -20) {
          ballState.settled = true;
          settleTimer = 1.5;
        }

        // Friction
        ballState.vx *= 0.995;
        ballState.vz *= 0.998;
      }

      // Update pins
      pins.forEach(pin => pin.update(dt));

      // Update particles
      updateParticles(dt);

      // Wait for settle
      if (ballState.settled) {
        settleTimer -= dt;
        if (settleTimer <= 0) {
          endRoll();
          ballState.settled = false;
        }
      }

      renderer.render(scene, camera);
    }

    updateUI();
    animate(0);
  </script>
<script src="/sloppy-header/sloppy-bar.js"></script>
<script src="/vibelib-extended.js"></script>
<script>
  // Compatibility Patch for Legacy Apps
  window.addEventListener("load", () => {
    if (window.SloppyKarma && window.VibeLib.Economy) {
      // Redirect old calls to new engine
      window.SloppyKarma.track = window.VibeLib.Economy.track;
    }
  });
</script>
</body>
</html>
