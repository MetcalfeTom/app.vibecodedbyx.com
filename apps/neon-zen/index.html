<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Neon Zen</title>
  <link rel="icon" href="https://emojicdn.elk.sh/üéØ">
  <meta name="description" content="Tap glowing particles before they fade in this cyberpunk reflex game">
  <meta property="og:title" content="Neon Zen">
  <meta property="og:description" content="Cyberpunk reflex game - tap the glowing orbs before they vanish!">
  <meta property="og:url" content="https://app.sloppy.live/neon-zen">
  <meta property="og:image" content="https://app.sloppy.live/neon-zen/og-image.png">
  <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700&family=Rajdhani:wght@300;400&display=swap" rel="stylesheet">
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      min-height: 100vh;
      overflow: hidden;
      font-family: 'Rajdhani', sans-serif;
      background: linear-gradient(135deg, #0a0a12 0%, #1a0a20 50%, #0a1520 100%);
      user-select: none;
      -webkit-user-select: none;
    }

    canvas {
      position: fixed;
      top: 0;
      left: 0;
      z-index: 1;
    }

    #steamCanvas {
      z-index: 5;
      pointer-events: none;
    }

    #gameCanvas {
      z-index: 3;
      cursor: crosshair;
    }

    .ui {
      position: fixed;
      top: 20px;
      left: 20px;
      z-index: 10;
      font-family: 'Orbitron', monospace;
    }

    .stat {
      margin-bottom: 10px;
    }

    .stat-label {
      font-size: 10px;
      color: rgba(0, 255, 255, 0.5);
      letter-spacing: 2px;
    }

    .stat-value {
      font-size: 28px;
      font-weight: 700;
      background: linear-gradient(90deg, #00ffff, #ff00ff);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
    }

    .level-display {
      position: fixed;
      top: 20px;
      right: 20px;
      text-align: right;
      z-index: 10;
      font-family: 'Orbitron', monospace;
    }

    .level-number {
      font-size: 48px;
      font-weight: 700;
      color: #ff00ff;
      text-shadow: 0 0 20px #ff00ff;
    }

    .level-label {
      font-size: 12px;
      color: rgba(255, 0, 255, 0.6);
      letter-spacing: 3px;
    }

    .lives {
      position: fixed;
      top: 100px;
      right: 20px;
      z-index: 10;
      font-size: 24px;
      letter-spacing: 5px;
    }

    .title {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      text-align: center;
      z-index: 20;
    }

    .title h1 {
      font-family: 'Orbitron', monospace;
      font-size: 56px;
      font-weight: 700;
      letter-spacing: 15px;
      background: linear-gradient(90deg, #ff00ff, #00ffff, #ff00ff);
      background-size: 200% 100%;
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
      animation: shimmer 3s linear infinite;
      margin-bottom: 20px;
    }

    @keyframes shimmer {
      0% { background-position: 0% 50%; }
      100% { background-position: 200% 50%; }
    }

    .title p {
      color: rgba(0, 255, 255, 0.6);
      font-size: 16px;
      letter-spacing: 5px;
      margin-bottom: 40px;
    }

    .start-btn {
      padding: 16px 48px;
      font-family: 'Orbitron', monospace;
      font-size: 18px;
      font-weight: 700;
      letter-spacing: 3px;
      background: transparent;
      border: 2px solid #00ffff;
      color: #00ffff;
      cursor: pointer;
      transition: all 0.3s;
      text-transform: uppercase;
    }

    .start-btn:hover {
      background: rgba(0, 255, 255, 0.1);
      box-shadow: 0 0 30px rgba(0, 255, 255, 0.3);
      transform: scale(1.05);
    }

    .game-over {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      text-align: center;
      z-index: 20;
      display: none;
    }

    .game-over h2 {
      font-family: 'Orbitron', monospace;
      font-size: 48px;
      color: #ff0080;
      text-shadow: 0 0 30px #ff0080;
      margin-bottom: 20px;
    }

    .final-score {
      font-family: 'Orbitron', monospace;
      font-size: 24px;
      color: #00ffff;
      margin-bottom: 10px;
    }

    .final-level {
      font-size: 18px;
      color: rgba(255, 0, 255, 0.7);
      margin-bottom: 40px;
    }

    .combo-display {
      position: fixed;
      bottom: 100px;
      left: 50%;
      transform: translateX(-50%);
      font-family: 'Orbitron', monospace;
      font-size: 24px;
      color: #ffff00;
      text-shadow: 0 0 20px #ffff00;
      z-index: 10;
      opacity: 0;
      transition: opacity 0.3s;
    }

    .combo-display.show {
      opacity: 1;
    }

    .level-up {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      font-family: 'Orbitron', monospace;
      font-size: 64px;
      font-weight: 700;
      color: #00ffff;
      text-shadow: 0 0 40px #00ffff;
      z-index: 15;
      opacity: 0;
      pointer-events: none;
    }

    .level-up.show {
      animation: levelUp 1.5s ease-out forwards;
    }

    @keyframes levelUp {
      0% { opacity: 0; transform: translate(-50%, -50%) scale(0.5); }
      20% { opacity: 1; transform: translate(-50%, -50%) scale(1.2); }
      80% { opacity: 1; }
      100% { opacity: 0; transform: translate(-50%, -50%) scale(1.5); }
    }

    .steam-warning {
      position: fixed;
      bottom: 60px;
      left: 50%;
      transform: translateX(-50%);
      font-family: 'Orbitron', monospace;
      font-size: 12px;
      color: rgba(255, 0, 128, 0.7);
      letter-spacing: 2px;
      z-index: 10;
      opacity: 0;
      transition: opacity 0.5s;
    }

    .steam-warning.show {
      opacity: 1;
    }

    .grid {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background-image:
        linear-gradient(rgba(0, 255, 255, 0.03) 1px, transparent 1px),
        linear-gradient(90deg, rgba(0, 255, 255, 0.03) 1px, transparent 1px);
      background-size: 50px 50px;
      z-index: 0;
    }

    .backlink {
      position: fixed;
      bottom: 20px;
      right: 20px;
      color: rgba(0, 255, 255, 0.3);
      text-decoration: none;
      font-size: 12px;
      z-index: 20;
      font-family: 'Orbitron', monospace;
      letter-spacing: 2px;
    }

    .backlink:hover {
      color: rgba(0, 255, 255, 0.6);
    }

    .hidden {
      display: none !important;
    }

    @media (max-width: 600px) {
      .title h1 {
        font-size: 32px;
        letter-spacing: 8px;
      }

      .level-number {
        font-size: 36px;
      }

      .stat-value {
        font-size: 22px;
      }
    }
  </style>
</head>
<body>
  <div class="grid"></div>

  <canvas id="bgCanvas"></canvas>
  <canvas id="gameCanvas"></canvas>
  <canvas id="steamCanvas"></canvas>

  <div class="ui hidden" id="gameUI">
    <div class="stat">
      <div class="stat-label">SCORE</div>
      <div class="stat-value" id="score">0</div>
    </div>
    <div class="stat">
      <div class="stat-label">TARGETS</div>
      <div class="stat-value" id="targets">0</div>
    </div>
  </div>

  <div class="level-display hidden" id="levelDisplay">
    <div class="level-label">LEVEL</div>
    <div class="level-number" id="level">1</div>
  </div>

  <div class="lives hidden" id="livesDisplay">‚ù§Ô∏è‚ù§Ô∏è‚ù§Ô∏è</div>

  <div class="combo-display" id="combo">COMBO x1</div>

  <div class="level-up" id="levelUp">LEVEL UP!</div>

  <div class="steam-warning" id="steamWarning">‚ö†Ô∏è STEAM CLOUDS INCOMING ‚ö†Ô∏è</div>

  <div class="title" id="titleScreen">
    <h1>NEON ZEN</h1>
    <p>TAP THE GLOWING ORBS BEFORE THEY FADE</p>
    <button class="start-btn" onclick="startGame()">START GAME</button>
  </div>

  <div class="game-over" id="gameOver">
    <h2>GAME OVER</h2>
    <div class="final-score">SCORE: <span id="finalScore">0</span></div>
    <div class="final-level">Reached Level <span id="finalLevel">1</span></div>
    <button class="start-btn" onclick="startGame()">PLAY AGAIN</button>
  </div>

  <a href="https://sloppy.live" class="backlink">sloppy.live</a>

  <script>
    const bgCanvas = document.getElementById('bgCanvas');
    const bgCtx = bgCanvas.getContext('2d');
    const gameCanvas = document.getElementById('gameCanvas');
    const gameCtx = gameCanvas.getContext('2d');
    const steamCanvas = document.getElementById('steamCanvas');
    const steamCtx = steamCanvas.getContext('2d');

    let width, height;
    let gameRunning = false;
    let score = 0;
    let level = 1;
    let lives = 3;
    let combo = 0;
    let targetsHit = 0;
    let targetsMissed = 0;

    let targets = [];
    let particles = [];
    let steamClouds = [];
    let audioCtx;

    const COLORS = ['#00ffff', '#ff00ff', '#ff0080', '#80ff00', '#ffff00', '#00ff80'];

    function resize() {
      width = bgCanvas.width = gameCanvas.width = steamCanvas.width = window.innerWidth;
      height = bgCanvas.height = gameCanvas.height = steamCanvas.height = window.innerHeight;
    }

    class Target {
      constructor() {
        const margin = 80;
        this.x = margin + Math.random() * (width - margin * 2);
        this.y = margin + Math.random() * (height - margin * 2);
        this.radius = 25 + Math.random() * 15;
        this.maxLife = this.getLifespan();
        this.life = this.maxLife;
        this.color = COLORS[Math.floor(Math.random() * COLORS.length)];
        this.pulse = 0;
        this.hit = false;
      }

      getLifespan() {
        // Faster fade at higher levels
        const base = 180; // 3 seconds at 60fps
        const reduction = Math.min(level * 8, 120);
        return base - reduction;
      }

      update() {
        this.life--;
        this.pulse += 0.15;
        return this.life > 0 && !this.hit;
      }

      draw() {
        const lifeRatio = this.life / this.maxLife;
        const pulseScale = 1 + Math.sin(this.pulse) * 0.1;
        const r = this.radius * pulseScale * lifeRatio;

        // Outer glow
        gameCtx.beginPath();
        gameCtx.arc(this.x, this.y, r * 1.5, 0, Math.PI * 2);
        gameCtx.fillStyle = this.color;
        gameCtx.globalAlpha = lifeRatio * 0.2;
        gameCtx.shadowColor = this.color;
        gameCtx.shadowBlur = 30;
        gameCtx.fill();

        // Main circle
        gameCtx.beginPath();
        gameCtx.arc(this.x, this.y, r, 0, Math.PI * 2);
        gameCtx.globalAlpha = lifeRatio * 0.8;
        gameCtx.fill();

        // Inner bright core
        gameCtx.beginPath();
        gameCtx.arc(this.x, this.y, r * 0.5, 0, Math.PI * 2);
        gameCtx.fillStyle = '#fff';
        gameCtx.globalAlpha = lifeRatio * 0.9;
        gameCtx.fill();

        // Ring indicator showing time left
        gameCtx.beginPath();
        gameCtx.arc(this.x, this.y, r + 5, -Math.PI / 2, -Math.PI / 2 + (Math.PI * 2 * lifeRatio), false);
        gameCtx.strokeStyle = this.color;
        gameCtx.lineWidth = 3;
        gameCtx.globalAlpha = lifeRatio * 0.6;
        gameCtx.shadowBlur = 10;
        gameCtx.stroke();

        gameCtx.globalAlpha = 1;
        gameCtx.shadowBlur = 0;
      }

      contains(x, y) {
        const dx = x - this.x;
        const dy = y - this.y;
        return dx * dx + dy * dy <= this.radius * this.radius * 2;
      }
    }

    class Particle {
      constructor(x, y, color) {
        this.x = x;
        this.y = y;
        const angle = Math.random() * Math.PI * 2;
        const speed = 3 + Math.random() * 5;
        this.vx = Math.cos(angle) * speed;
        this.vy = Math.sin(angle) * speed;
        this.size = 2 + Math.random() * 4;
        this.life = 1;
        this.color = color;
      }

      update() {
        this.x += this.vx;
        this.y += this.vy;
        this.vx *= 0.96;
        this.vy *= 0.96;
        this.life -= 0.03;
        return this.life > 0;
      }

      draw() {
        bgCtx.beginPath();
        bgCtx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
        bgCtx.fillStyle = this.color;
        bgCtx.globalAlpha = this.life;
        bgCtx.shadowColor = this.color;
        bgCtx.shadowBlur = 10;
        bgCtx.fill();
        bgCtx.globalAlpha = 1;
        bgCtx.shadowBlur = 0;
      }
    }

    class SteamCloud {
      constructor() {
        this.x = Math.random() * width;
        this.y = height + 100;
        this.radius = 100 + Math.random() * 150;
        this.vx = (Math.random() - 0.5) * 1;
        this.vy = -0.5 - Math.random() * 1;
        this.opacity = 0.3 + Math.random() * 0.3;
        this.color = Math.random() > 0.5 ? '#ff00ff' : '#00ffff';
      }

      update() {
        this.x += this.vx;
        this.y += this.vy;
        this.vx += (Math.random() - 0.5) * 0.1;
        this.radius += 0.5;
        return this.y + this.radius > -100;
      }

      draw() {
        steamCtx.beginPath();
        const gradient = steamCtx.createRadialGradient(
          this.x, this.y, 0,
          this.x, this.y, this.radius
        );
        gradient.addColorStop(0, this.color);
        gradient.addColorStop(1, 'transparent');
        steamCtx.fillStyle = gradient;
        steamCtx.globalAlpha = this.opacity;
        steamCtx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
        steamCtx.fill();
        steamCtx.globalAlpha = 1;
      }
    }

    function spawnTarget() {
      if (!gameRunning) return;

      targets.push(new Target());

      // Spawn rate increases with level
      const baseDelay = 1500;
      const minDelay = 400;
      const delay = Math.max(minDelay, baseDelay - level * 100);
      setTimeout(spawnTarget, delay + Math.random() * 500);
    }

    function spawnSteamCloud() {
      if (!gameRunning) return;

      // Steam starts at level 3
      if (level >= 3) {
        steamClouds.push(new SteamCloud());
      }

      // More clouds at higher levels
      const cloudRate = level >= 3 ? Math.max(500, 2000 - (level - 3) * 200) : 2000;
      setTimeout(spawnSteamCloud, cloudRate + Math.random() * 1000);
    }

    function hitTarget(target, x, y) {
      target.hit = true;
      combo++;
      targetsHit++;

      // Score based on remaining life and combo
      const lifeBonus = Math.floor((target.life / target.maxLife) * 50);
      const comboBonus = Math.min(combo, 10);
      const points = (10 + lifeBonus) * comboBonus;
      score += points;

      // Spawn particles
      for (let i = 0; i < 15; i++) {
        particles.push(new Particle(target.x, target.y, target.color));
      }

      // Play sound
      playHitSound(target.life / target.maxLife);

      // Update UI
      updateUI();

      // Check level up
      if (targetsHit > 0 && targetsHit % 10 === 0) {
        levelUp();
      }
    }

    function missTarget() {
      combo = 0;
      targetsMissed++;
      lives--;
      updateUI();

      if (lives <= 0) {
        gameOver();
      }

      playMissSound();
    }

    function levelUp() {
      level++;
      document.getElementById('level').textContent = level;

      const levelUpEl = document.getElementById('levelUp');
      levelUpEl.classList.add('show');
      setTimeout(() => levelUpEl.classList.remove('show'), 1500);

      // Show steam warning at level 3
      if (level === 3) {
        const warning = document.getElementById('steamWarning');
        warning.classList.add('show');
        setTimeout(() => warning.classList.remove('show'), 3000);
      }

      playLevelUpSound();
    }

    function updateUI() {
      document.getElementById('score').textContent = score;
      document.getElementById('targets').textContent = targetsHit;

      const livesDisplay = document.getElementById('livesDisplay');
      livesDisplay.textContent = '‚ù§Ô∏è'.repeat(lives) + 'üñ§'.repeat(3 - lives);

      const comboEl = document.getElementById('combo');
      if (combo > 1) {
        comboEl.textContent = `COMBO x${combo}`;
        comboEl.classList.add('show');
      } else {
        comboEl.classList.remove('show');
      }
    }

    function playHitSound(lifeRatio) {
      if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();

      const osc = audioCtx.createOscillator();
      const gain = audioCtx.createGain();
      osc.connect(gain);
      gain.connect(audioCtx.destination);

      osc.type = 'sine';
      osc.frequency.setValueAtTime(600 + lifeRatio * 600, audioCtx.currentTime);
      osc.frequency.exponentialRampToValueAtTime(800, audioCtx.currentTime + 0.1);

      gain.gain.setValueAtTime(0.15, audioCtx.currentTime);
      gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.2);

      osc.start(audioCtx.currentTime);
      osc.stop(audioCtx.currentTime + 0.2);
    }

    function playMissSound() {
      if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();

      const osc = audioCtx.createOscillator();
      const gain = audioCtx.createGain();
      osc.connect(gain);
      gain.connect(audioCtx.destination);

      osc.type = 'sawtooth';
      osc.frequency.setValueAtTime(200, audioCtx.currentTime);
      osc.frequency.exponentialRampToValueAtTime(50, audioCtx.currentTime + 0.3);

      gain.gain.setValueAtTime(0.1, audioCtx.currentTime);
      gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.3);

      osc.start(audioCtx.currentTime);
      osc.stop(audioCtx.currentTime + 0.3);
    }

    function playLevelUpSound() {
      if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();

      [0, 100, 200].forEach((delay, i) => {
        setTimeout(() => {
          const osc = audioCtx.createOscillator();
          const gain = audioCtx.createGain();
          osc.connect(gain);
          gain.connect(audioCtx.destination);

          osc.type = 'sine';
          osc.frequency.setValueAtTime(400 + i * 200, audioCtx.currentTime);

          gain.gain.setValueAtTime(0.1, audioCtx.currentTime);
          gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.3);

          osc.start(audioCtx.currentTime);
          osc.stop(audioCtx.currentTime + 0.3);
        }, delay);
      });
    }

    function startGame() {
      document.getElementById('titleScreen').classList.add('hidden');
      document.getElementById('gameOver').style.display = 'none';
      document.getElementById('gameUI').classList.remove('hidden');
      document.getElementById('levelDisplay').classList.remove('hidden');
      document.getElementById('livesDisplay').classList.remove('hidden');

      score = 0;
      level = 1;
      lives = 3;
      combo = 0;
      targetsHit = 0;
      targetsMissed = 0;
      targets = [];
      particles = [];
      steamClouds = [];

      document.getElementById('level').textContent = '1';
      updateUI();

      gameRunning = true;
      spawnTarget();
      spawnSteamCloud();
    }

    function gameOver() {
      gameRunning = false;

      document.getElementById('gameUI').classList.add('hidden');
      document.getElementById('levelDisplay').classList.add('hidden');
      document.getElementById('livesDisplay').classList.add('hidden');
      document.getElementById('combo').classList.remove('show');

      document.getElementById('finalScore').textContent = score;
      document.getElementById('finalLevel').textContent = level;
      document.getElementById('gameOver').style.display = 'block';
    }

    function handleClick(x, y) {
      if (!gameRunning) return;

      let hit = false;
      for (let i = targets.length - 1; i >= 0; i--) {
        if (targets[i].contains(x, y) && !targets[i].hit) {
          hitTarget(targets[i], x, y);
          hit = true;
          break;
        }
      }

      // Misclick penalty (optional - removed for better feel)
    }

    function update() {
      // Update targets
      for (let i = targets.length - 1; i >= 0; i--) {
        if (!targets[i].update()) {
          if (!targets[i].hit && targets[i].life <= 0) {
            missTarget();
          }
          targets.splice(i, 1);
        }
      }

      // Update particles
      particles = particles.filter(p => p.update());

      // Update steam clouds
      steamClouds = steamClouds.filter(c => c.update());
    }

    function draw() {
      // Clear all canvases
      bgCtx.clearRect(0, 0, width, height);
      gameCtx.clearRect(0, 0, width, height);
      steamCtx.clearRect(0, 0, width, height);

      // Draw particles (background)
      particles.forEach(p => p.draw());

      // Draw targets
      targets.forEach(t => t.draw());

      // Draw steam clouds (foreground, obscures targets)
      steamClouds.forEach(c => c.draw());
    }

    function animate() {
      update();
      draw();
      requestAnimationFrame(animate);
    }

    // Event listeners
    window.addEventListener('resize', resize);

    gameCanvas.addEventListener('click', (e) => {
      handleClick(e.clientX, e.clientY);
    });

    gameCanvas.addEventListener('touchstart', (e) => {
      e.preventDefault();
      const touch = e.touches[0];
      handleClick(touch.clientX, touch.clientY);
    }, { passive: false });

    // Initialize
    resize();
    animate();
  </script>
<script src="/sloppy-header/sloppy-bar.js"></script>
<script src="/vibelib-extended.js"></script>
<script>
  // Compatibility Patch for Legacy Apps
  window.addEventListener("load", () => {
    if (window.SloppyKarma && window.VibeLib.Economy) {
      // Redirect old calls to new engine
      window.SloppyKarma.track = window.VibeLib.Economy.track;
    }
  });
</script>
</body>
</html>
