<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>CAT-ZAP - Neon Laser Chase</title>
  <link rel="icon" href="https://emojicdn.elk.sh/ðŸ±">
  <meta property="og:title" content="CAT-ZAP">
  <meta property="og:description" content="Control a neon laser pointer and watch cats go crazy">
  <meta property="og:url" content="https://sloppy.live/cat-zap">
  <meta property="og:image" content="https://emojicdn.elk.sh/ðŸ”´?style=apple&size=512">
  <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&family=Exo+2:wght@400;700&display=swap" rel="stylesheet">
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }

    body {
      background: #0a0a0f;
      overflow: hidden;
      font-family: 'Exo 2', sans-serif;
      cursor: none;
    }

    canvas {
      display: block;
    }

    .ui {
      position: fixed;
      top: 20px;
      left: 20px;
      z-index: 100;
      pointer-events: none;
    }

    .score {
      font-family: 'Orbitron', sans-serif;
      font-size: 1.8rem;
      font-weight: 700;
      color: #f00;
      text-shadow: 0 0 10px #f00, 0 0 20px #f00, 0 0 40px #f00;
    }

    .treats {
      font-size: 1rem;
      color: #ff0;
      text-shadow: 0 0 10px #ff0;
      margin-top: 5px;
    }

    .cat-count {
      font-size: 0.9rem;
      color: #0ff;
      text-shadow: 0 0 10px #0ff;
      margin-top: 5px;
    }

    /* Purr Meter */
    .purr-meter {
      position: fixed;
      top: 20px;
      right: 20px;
      z-index: 100;
      pointer-events: none;
      text-align: right;
    }

    .purr-label {
      font-family: 'Orbitron', sans-serif;
      font-size: 0.9rem;
      color: #f0f;
      text-shadow: 0 0 10px #f0f;
      margin-bottom: 8px;
      display: flex;
      align-items: center;
      justify-content: flex-end;
      gap: 8px;
    }

    .purr-icon {
      font-size: 1.2rem;
      animation: purrBounce 0.3s ease-in-out infinite;
    }

    @keyframes purrBounce {
      0%, 100% { transform: scale(1); }
      50% { transform: scale(1.1); }
    }

    .purr-bar-container {
      width: 150px;
      height: 20px;
      background: rgba(255, 0, 255, 0.1);
      border: 2px solid #f0f;
      border-radius: 10px;
      overflow: hidden;
      box-shadow: 0 0 15px rgba(255, 0, 255, 0.3);
    }

    .purr-bar {
      height: 100%;
      width: 0%;
      background: linear-gradient(90deg, #f0f, #0ff, #f0f);
      background-size: 200% 100%;
      animation: purrGradient 1s linear infinite;
      transition: width 0.2s;
      box-shadow: 0 0 20px #f0f;
    }

    @keyframes purrGradient {
      0% { background-position: 0% 50%; }
      100% { background-position: 200% 50%; }
    }

    .purr-text {
      font-family: 'Orbitron', sans-serif;
      font-size: 0.7rem;
      color: #fff;
      margin-top: 5px;
      opacity: 0;
      transition: opacity 0.3s;
    }

    .purr-text.visible {
      opacity: 1;
    }

    .start-screen {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: radial-gradient(ellipse at center, #1a0a0a 0%, #0a0a0f 100%);
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      z-index: 200;
      cursor: default;
    }

    .start-screen h1 {
      font-family: 'Orbitron', sans-serif;
      font-size: 4rem;
      font-weight: 900;
      color: #f00;
      text-shadow: 0 0 20px #f00, 0 0 40px #f00, 0 0 80px #f00;
      margin-bottom: 10px;
      animation: pulse 1.5s ease-in-out infinite;
    }

    .start-screen .subtitle {
      font-size: 1.2rem;
      color: #0ff;
      text-shadow: 0 0 15px #0ff;
      margin-bottom: 40px;
      letter-spacing: 4px;
    }

    .start-btn {
      font-family: 'Orbitron', sans-serif;
      font-size: 1.3rem;
      font-weight: 700;
      padding: 20px 60px;
      background: transparent;
      border: 3px solid #f00;
      color: #f00;
      cursor: pointer;
      transition: all 0.3s;
      text-shadow: 0 0 10px #f00;
      box-shadow: 0 0 30px rgba(255, 0, 0, 0.3);
    }

    .start-btn:hover {
      background: #f00;
      color: #000;
      box-shadow: 0 0 60px #f00;
    }

    .instructions {
      margin-top: 30px;
      color: #666;
      font-size: 0.9rem;
      text-align: center;
    }

    @keyframes pulse {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.7; }
    }

    .game-over {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      text-align: center;
      z-index: 200;
      display: none;
      cursor: default;
    }

    .game-over h2 {
      font-family: 'Orbitron', sans-serif;
      font-size: 3rem;
      color: #f0f;
      text-shadow: 0 0 30px #f0f;
      margin-bottom: 20px;
    }

    .game-over .final-score {
      font-family: 'Orbitron', sans-serif;
      font-size: 1.5rem;
      color: #ff0;
      text-shadow: 0 0 15px #ff0;
      margin-bottom: 30px;
    }

    .restart-btn {
      font-family: 'Orbitron', sans-serif;
      font-size: 1rem;
      padding: 15px 40px;
      background: transparent;
      border: 2px solid #0ff;
      color: #0ff;
      cursor: pointer;
      transition: all 0.3s;
    }

    .restart-btn:hover {
      background: #0ff;
      color: #000;
    }

    .backlink {
      position: fixed;
      bottom: 15px;
      right: 15px;
      color: #333;
      font-size: 0.7rem;
      text-decoration: none;
      z-index: 100;
      cursor: default;
    }

    .backlink:hover { color: #f00; }

    @media (max-width: 600px) {
      .start-screen h1 { font-size: 2.5rem; }
      .score { font-size: 1.4rem; }
      .purr-bar-container { width: 100px; }
    }
  </style>
</head>
<body>
  <canvas id="game"></canvas>

  <div class="ui">
    <div class="score">SCORE: <span id="score">0</span></div>
    <div class="treats">TREATS: <span id="treats">0</span> / <span id="treats-total">0</span></div>
    <div class="cat-count">CATS: <span id="cats">1</span></div>
  </div>

  <div class="purr-meter">
    <div class="purr-label">
      <span>PURR METER</span>
      <span class="purr-icon">ðŸ˜»</span>
    </div>
    <div class="purr-bar-container">
      <div class="purr-bar" id="purr-bar"></div>
    </div>
    <div class="purr-text" id="purr-text">MAXIMUM PURR!</div>
  </div>

  <div class="start-screen" id="start-screen">
    <h1>CAT-ZAP</h1>
    <p class="subtitle">NEON LASER CHASE</p>
    <button class="start-btn" id="start-btn">START GAME</button>
    <p class="instructions">Move laser to guide cats to treats<br>Collect all treats to spawn more cats!<br>Fill the purr meter for disco mode!</p>
  </div>

  <div class="game-over" id="game-over">
    <h2>PURRFECT!</h2>
    <p class="final-score">Final Score: <span id="final-score">0</span></p>
    <button class="restart-btn" id="restart-btn">PLAY AGAIN</button>
  </div>

  <a href="https://sloppy.live" class="backlink">sloppy.live</a>

  <script>
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');

    let W, H;
    function resize() {
      W = canvas.width = window.innerWidth;
      H = canvas.height = window.innerHeight;
    }
    resize();
    window.addEventListener('resize', resize);

    // Game state
    let gameRunning = false;
    let score = 0;
    let treatsCollected = 0;
    let level = 1;
    let purrLevel = 0;
    let discoMode = false;
    let discoTime = 0;

    // Disco lights
    let discoLights = [];
    const discoColors = ['#f00', '#0f0', '#00f', '#ff0', '#f0f', '#0ff', '#f80', '#8f0'];

    // Laser pointer
    const laser = {
      x: W / 2,
      y: H / 2,
      targetX: W / 2,
      targetY: H / 2,
      radius: 8,
      trail: [],
      pulsePhase: 0
    };

    // Cats
    let cats = [];

    // Treats
    let treats = [];

    // Particles
    let particles = [];

    // Mouse/touch tracking
    canvas.addEventListener('mousemove', e => {
      laser.targetX = e.clientX;
      laser.targetY = e.clientY;
    });

    canvas.addEventListener('touchmove', e => {
      e.preventDefault();
      laser.targetX = e.touches[0].clientX;
      laser.targetY = e.touches[0].clientY;
    });

    canvas.addEventListener('touchstart', e => {
      e.preventDefault();
      laser.targetX = e.touches[0].clientX;
      laser.targetY = e.touches[0].clientY;
    });

    function createCat(x, y) {
      const colors = ['#ff6b00', '#888', '#222', '#fff', '#d4a574'];
      return {
        x: x || Math.random() * (W - 100) + 50,
        y: y || Math.random() * (H - 100) + 50,
        vx: 0,
        vy: 0,
        size: 30,
        color: colors[Math.floor(Math.random() * colors.length)],
        eyePhase: Math.random() * Math.PI * 2,
        tailPhase: Math.random() * Math.PI * 2,
        excitement: 0,
        purring: 0,
        targetLocked: false,
        pounceTimer: 0
      };
    }

    function createTreat() {
      return {
        x: Math.random() * (W - 100) + 50,
        y: Math.random() * (H - 100) + 50,
        radius: 12,
        collected: false,
        sparkle: 0
      };
    }

    function createDiscoLight() {
      return {
        x: Math.random() * W,
        y: Math.random() * H,
        angle: Math.random() * Math.PI * 2,
        speed: 0.5 + Math.random() * 2,
        length: 100 + Math.random() * 200,
        width: 20 + Math.random() * 40,
        color: discoColors[Math.floor(Math.random() * discoColors.length)],
        rotateSpeed: (Math.random() - 0.5) * 3,
        pulse: Math.random() * Math.PI * 2
      };
    }

    function spawnParticle(x, y, color, count = 5) {
      for (let i = 0; i < count; i++) {
        const angle = Math.random() * Math.PI * 2;
        const speed = 50 + Math.random() * 100;
        particles.push({
          x, y,
          vx: Math.cos(angle) * speed,
          vy: Math.sin(angle) * speed,
          life: 1,
          color,
          size: 3 + Math.random() * 4
        });
      }
    }

    function initGame() {
      score = 0;
      treatsCollected = 0;
      level = 1;
      purrLevel = 0;
      discoMode = false;
      discoTime = 0;
      cats = [createCat()];
      treats = [];
      particles = [];
      discoLights = [];

      // Create disco lights
      for (let i = 0; i < 8; i++) {
        discoLights.push(createDiscoLight());
      }

      for (let i = 0; i < 5; i++) {
        treats.push(createTreat());
      }

      laser.x = W / 2;
      laser.y = H / 2;
      laser.trail = [];

      updateUI();
    }

    function update(dt) {
      if (!gameRunning) return;

      // Update laser position (smooth follow)
      laser.x += (laser.targetX - laser.x) * 0.3;
      laser.y += (laser.targetY - laser.y) * 0.3;
      laser.pulsePhase += dt * 10;

      // Add to trail
      laser.trail.push({ x: laser.x, y: laser.y, alpha: 1 });
      if (laser.trail.length > 20) laser.trail.shift();
      laser.trail.forEach(t => t.alpha -= dt * 3);
      laser.trail = laser.trail.filter(t => t.alpha > 0);

      // Update disco lights
      discoTime += dt;
      discoLights.forEach(light => {
        light.angle += light.rotateSpeed * dt;
        light.pulse += dt * 5;

        // Move lights around during disco mode
        if (discoMode) {
          light.x += Math.cos(light.angle) * light.speed * 30 * dt;
          light.y += Math.sin(light.angle) * light.speed * 30 * dt;

          // Wrap around screen
          if (light.x < -100) light.x = W + 100;
          if (light.x > W + 100) light.x = -100;
          if (light.y < -100) light.y = H + 100;
          if (light.y > H + 100) light.y = -100;
        }
      });

      // Calculate average purr level from all cats
      let totalPurr = 0;

      // Update cats
      cats.forEach(cat => {
        // Calculate distance to laser
        const dx = laser.x - cat.x;
        const dy = laser.y - cat.y;
        const dist = Math.sqrt(dx * dx + dy * dy);

        // Cat excitement based on laser movement
        const laserSpeed = Math.sqrt(
          Math.pow(laser.targetX - laser.x, 2) +
          Math.pow(laser.targetY - laser.y, 2)
        );
        cat.excitement = Math.min(1, cat.excitement + laserSpeed * 0.01);
        cat.excitement *= 0.98;

        // Purring increases when close to laser and calm
        if (dist < 100) {
          cat.purring = Math.min(1, cat.purring + dt * 0.5);
        } else {
          cat.purring *= 0.95;
        }
        totalPurr += cat.purring;

        // Chase behavior
        if (dist > 30) {
          const chaseSpeed = 150 + cat.excitement * 200 + (discoMode ? 100 : 0);
          const ax = (dx / dist) * chaseSpeed;
          const ay = (dy / dist) * chaseSpeed;

          cat.vx += (ax - cat.vx) * dt * 3;
          cat.vy += (ay - cat.vy) * dt * 3;
        } else {
          // Pounce!
          cat.vx *= 0.9;
          cat.vy *= 0.9;
          cat.pounceTimer += dt;

          if (cat.pounceTimer > 0.5) {
            // Random pounce direction
            const pounceAngle = Math.random() * Math.PI * 2;
            cat.vx = Math.cos(pounceAngle) * 200;
            cat.vy = Math.sin(pounceAngle) * 200;
            cat.pounceTimer = 0;
            spawnParticle(cat.x, cat.y, '#f00', 3);
          }
        }

        // Apply velocity
        cat.x += cat.vx * dt;
        cat.y += cat.vy * dt;

        // Bounce off walls
        if (cat.x < cat.size) { cat.x = cat.size; cat.vx *= -0.5; }
        if (cat.x > W - cat.size) { cat.x = W - cat.size; cat.vx *= -0.5; }
        if (cat.y < cat.size) { cat.y = cat.size; cat.vy *= -0.5; }
        if (cat.y > H - cat.size) { cat.y = H - cat.size; cat.vy *= -0.5; }

        // Animation phases
        cat.eyePhase += dt * 5;
        cat.tailPhase += dt * (8 + (discoMode ? 10 : 0));

        // Check treat collision
        treats.forEach(treat => {
          if (treat.collected) return;
          const tdx = cat.x - treat.x;
          const tdy = cat.y - treat.y;
          const tDist = Math.sqrt(tdx * tdx + tdy * tdy);

          if (tDist < cat.size + treat.radius) {
            treat.collected = true;
            treatsCollected++;
            score += 100 * level * (discoMode ? 2 : 1);
            spawnParticle(treat.x, treat.y, '#ff0', 10);
            spawnParticle(treat.x, treat.y, '#f0f', 5);

            // Boost purr on treat collection
            cat.purring = Math.min(1, cat.purring + 0.3);
          }
        });
      });

      // Update global purr level
      const avgPurr = cats.length > 0 ? totalPurr / cats.length : 0;
      purrLevel = purrLevel * 0.95 + avgPurr * 0.05;

      // Activate disco mode when purr meter is full
      if (purrLevel > 0.8 && !discoMode) {
        discoMode = true;
        score += 1000;
        // Spawn celebration particles
        for (let i = 0; i < 50; i++) {
          spawnParticle(
            Math.random() * W,
            Math.random() * H,
            discoColors[Math.floor(Math.random() * discoColors.length)],
            1
          );
        }
      }

      // Disco mode slowly decays
      if (discoMode && purrLevel < 0.3) {
        discoMode = false;
      }

      // Remove collected treats
      treats = treats.filter(t => !t.collected);

      // Level up - spawn more cats and treats
      if (treats.length === 0) {
        level++;
        cats.push(createCat());

        const treatCount = 5 + level * 2;
        for (let i = 0; i < treatCount; i++) {
          treats.push(createTreat());
        }

        score += 500 * level;
        spawnParticle(W / 2, H / 2, '#0ff', 20);
      }

      // Update treats sparkle
      treats.forEach(t => t.sparkle += dt * 5);

      // Update particles
      particles.forEach(p => {
        p.x += p.vx * dt;
        p.y += p.vy * dt;
        p.vx *= 0.95;
        p.vy *= 0.95;
        p.life -= dt * 2;
      });
      particles = particles.filter(p => p.life > 0);

      updateUI();
    }

    function drawDiscoLights() {
      const intensity = discoMode ? 1 : 0.2 + purrLevel * 0.3;

      discoLights.forEach(light => {
        ctx.save();
        ctx.translate(light.x, light.y);
        ctx.rotate(light.angle);

        const pulseScale = 1 + Math.sin(light.pulse) * 0.2;
        const gradient = ctx.createLinearGradient(0, 0, light.length * pulseScale, 0);
        gradient.addColorStop(0, light.color);
        gradient.addColorStop(1, 'transparent');

        ctx.globalAlpha = intensity * (0.3 + Math.sin(light.pulse) * 0.2);
        ctx.fillStyle = gradient;

        // Draw cone shape
        ctx.beginPath();
        ctx.moveTo(0, 0);
        ctx.lineTo(light.length * pulseScale, -light.width * pulseScale / 2);
        ctx.lineTo(light.length * pulseScale, light.width * pulseScale / 2);
        ctx.closePath();
        ctx.fill();

        // Add glow at source
        ctx.beginPath();
        ctx.arc(0, 0, 10, 0, Math.PI * 2);
        ctx.fillStyle = light.color;
        ctx.shadowBlur = 20;
        ctx.shadowColor = light.color;
        ctx.globalAlpha = intensity;
        ctx.fill();

        ctx.restore();
      });

      ctx.shadowBlur = 0;
      ctx.globalAlpha = 1;
    }

    function drawCat(cat) {
      ctx.save();
      ctx.translate(cat.x, cat.y);

      // Calculate facing direction
      const facingAngle = Math.atan2(cat.vy, cat.vx);

      // Body glow - changes color in disco mode
      ctx.shadowBlur = 20 + (discoMode ? 20 : 0);
      ctx.shadowColor = discoMode
        ? discoColors[Math.floor(discoTime * 5) % discoColors.length]
        : '#f0f';

      // Body
      ctx.fillStyle = cat.color;
      ctx.beginPath();
      ctx.ellipse(0, 0, cat.size, cat.size * 0.7, 0, 0, Math.PI * 2);
      ctx.fill();

      // Ears
      ctx.beginPath();
      ctx.moveTo(-cat.size * 0.6, -cat.size * 0.3);
      ctx.lineTo(-cat.size * 0.3, -cat.size * 0.9);
      ctx.lineTo(-cat.size * 0.1, -cat.size * 0.3);
      ctx.fillStyle = cat.color;
      ctx.fill();

      ctx.beginPath();
      ctx.moveTo(cat.size * 0.6, -cat.size * 0.3);
      ctx.lineTo(cat.size * 0.3, -cat.size * 0.9);
      ctx.lineTo(cat.size * 0.1, -cat.size * 0.3);
      ctx.fill();

      // Inner ears
      ctx.fillStyle = '#faa';
      ctx.beginPath();
      ctx.moveTo(-cat.size * 0.5, -cat.size * 0.35);
      ctx.lineTo(-cat.size * 0.35, -cat.size * 0.7);
      ctx.lineTo(-cat.size * 0.2, -cat.size * 0.35);
      ctx.fill();

      ctx.beginPath();
      ctx.moveTo(cat.size * 0.5, -cat.size * 0.35);
      ctx.lineTo(cat.size * 0.35, -cat.size * 0.7);
      ctx.lineTo(cat.size * 0.2, -cat.size * 0.35);
      ctx.fill();

      // Eyes (glowing, tracking laser) - disco colors when in disco mode
      const eyeGlow = 0.5 + cat.excitement * 0.5;
      ctx.shadowBlur = 10 + cat.excitement * 20;
      const eyeColor = discoMode
        ? discoColors[Math.floor(discoTime * 8 + cats.indexOf(cat)) % discoColors.length]
        : '#0f0';
      ctx.shadowColor = eyeColor;

      ctx.fillStyle = discoMode
        ? eyeColor
        : `rgba(0, 255, 0, ${eyeGlow})`;
      ctx.beginPath();
      ctx.ellipse(-cat.size * 0.25, -cat.size * 0.1, 6, 8, 0, 0, Math.PI * 2);
      ctx.fill();
      ctx.beginPath();
      ctx.ellipse(cat.size * 0.25, -cat.size * 0.1, 6, 8, 0, 0, Math.PI * 2);
      ctx.fill();

      // Pupils (dilate with excitement)
      const pupilSize = 2 + (1 - cat.excitement) * 3;
      ctx.fillStyle = '#000';
      ctx.beginPath();
      ctx.ellipse(-cat.size * 0.25, -cat.size * 0.1, pupilSize, pupilSize * 1.5, 0, 0, Math.PI * 2);
      ctx.fill();
      ctx.beginPath();
      ctx.ellipse(cat.size * 0.25, -cat.size * 0.1, pupilSize, pupilSize * 1.5, 0, 0, Math.PI * 2);
      ctx.fill();

      ctx.shadowBlur = 0;

      // Nose
      ctx.fillStyle = '#f99';
      ctx.beginPath();
      ctx.moveTo(0, cat.size * 0.1);
      ctx.lineTo(-4, cat.size * 0.2);
      ctx.lineTo(4, cat.size * 0.2);
      ctx.fill();

      // Purr vibration lines when purring
      if (cat.purring > 0.3) {
        ctx.strokeStyle = `rgba(255, 0, 255, ${cat.purring * 0.5})`;
        ctx.lineWidth = 2;
        for (let i = 0; i < 3; i++) {
          const offset = Math.sin(discoTime * 20 + i) * 3;
          ctx.beginPath();
          ctx.arc(0, 0, cat.size + 10 + i * 8, 0, Math.PI * 2);
          ctx.stroke();
        }
      }

      // Tail (wagging)
      ctx.strokeStyle = cat.color;
      ctx.lineWidth = 6;
      ctx.lineCap = 'round';
      ctx.beginPath();
      const tailWag = Math.sin(cat.tailPhase) * (0.3 + cat.excitement * 0.5);
      ctx.moveTo(-cat.size * 0.8, cat.size * 0.3);
      ctx.quadraticCurveTo(
        -cat.size * 1.5 + tailWag * 30, cat.size * 0.1,
        -cat.size * 1.2 + tailWag * 40, -cat.size * 0.3
      );
      ctx.stroke();

      ctx.restore();
    }

    function draw() {
      // Clear with slight trail for disco effect
      if (discoMode) {
        ctx.fillStyle = 'rgba(10, 10, 15, 0.3)';
      } else {
        ctx.fillStyle = '#0a0a0f';
      }
      ctx.fillRect(0, 0, W, H);

      // Draw disco lights (behind everything)
      drawDiscoLights();

      // Draw grid pattern
      const gridColor = discoMode
        ? `rgba(${Math.sin(discoTime * 2) * 127 + 128}, 0, ${Math.cos(discoTime * 2) * 127 + 128}, 0.05)`
        : 'rgba(255, 0, 0, 0.03)';
      ctx.strokeStyle = gridColor;
      ctx.lineWidth = 1;
      for (let x = 0; x < W; x += 50) {
        ctx.beginPath();
        ctx.moveTo(x, 0);
        ctx.lineTo(x, H);
        ctx.stroke();
      }
      for (let y = 0; y < H; y += 50) {
        ctx.beginPath();
        ctx.moveTo(0, y);
        ctx.lineTo(W, y);
        ctx.stroke();
      }

      // Draw treats
      treats.forEach(treat => {
        const sparkleOffset = Math.sin(treat.sparkle) * 3;

        // Glow
        ctx.shadowBlur = 15;
        ctx.shadowColor = discoMode
          ? discoColors[Math.floor(treat.sparkle) % discoColors.length]
          : '#ff0';

        // Treat (fish shape)
        ctx.fillStyle = discoMode
          ? discoColors[Math.floor(treat.sparkle) % discoColors.length]
          : '#ff0';
        ctx.beginPath();
        ctx.ellipse(treat.x, treat.y, treat.radius + sparkleOffset, treat.radius * 0.6, 0, 0, Math.PI * 2);
        ctx.fill();

        // Tail
        ctx.beginPath();
        ctx.moveTo(treat.x - treat.radius, treat.y);
        ctx.lineTo(treat.x - treat.radius - 8, treat.y - 6);
        ctx.lineTo(treat.x - treat.radius - 8, treat.y + 6);
        ctx.fill();

        // Sparkle
        ctx.fillStyle = '#fff';
        ctx.beginPath();
        ctx.arc(treat.x + 3, treat.y - 3, 2, 0, Math.PI * 2);
        ctx.fill();
      });
      ctx.shadowBlur = 0;

      // Draw particles
      particles.forEach(p => {
        ctx.globalAlpha = p.life;
        ctx.fillStyle = p.color;
        ctx.shadowBlur = 10;
        ctx.shadowColor = p.color;
        ctx.beginPath();
        ctx.arc(p.x, p.y, p.size * p.life, 0, Math.PI * 2);
        ctx.fill();
      });
      ctx.globalAlpha = 1;
      ctx.shadowBlur = 0;

      // Draw cats
      cats.forEach(drawCat);

      // Draw laser trail
      laser.trail.forEach((t, i) => {
        ctx.globalAlpha = t.alpha * 0.5;
        ctx.fillStyle = discoMode
          ? discoColors[Math.floor(discoTime * 10 + i) % discoColors.length]
          : '#f00';
        ctx.shadowBlur = 10;
        ctx.shadowColor = ctx.fillStyle;
        ctx.beginPath();
        ctx.arc(t.x, t.y, 4, 0, Math.PI * 2);
        ctx.fill();
      });
      ctx.globalAlpha = 1;

      // Draw laser pointer
      const pulseSize = Math.sin(laser.pulsePhase) * 3;

      // Outer glow
      ctx.shadowBlur = 30;
      const laserColor = discoMode
        ? discoColors[Math.floor(discoTime * 15) % discoColors.length]
        : '#f00';
      ctx.shadowColor = laserColor;

      ctx.fillStyle = laserColor;
      ctx.beginPath();
      ctx.arc(laser.x, laser.y, laser.radius + pulseSize, 0, Math.PI * 2);
      ctx.fill();

      // Inner bright spot
      ctx.fillStyle = '#fff';
      ctx.beginPath();
      ctx.arc(laser.x, laser.y, laser.radius * 0.4, 0, Math.PI * 2);
      ctx.fill();

      ctx.shadowBlur = 0;

      // Draw level indicator
      if (gameRunning) {
        ctx.fillStyle = discoMode
          ? `rgba(${Math.sin(discoTime) * 127 + 128}, ${Math.cos(discoTime) * 127 + 128}, 255, 0.4)`
          : 'rgba(255, 0, 255, 0.3)';
        ctx.font = '100px Orbitron';
        ctx.textAlign = 'center';
        ctx.fillText(`LVL ${level}`, W / 2, H / 2 + 30);

        // Disco mode indicator
        if (discoMode) {
          ctx.fillStyle = discoColors[Math.floor(discoTime * 5) % discoColors.length];
          ctx.font = '40px Orbitron';
          ctx.fillText('DISCO MODE!', W / 2, H / 2 + 80);
        }
      }
    }

    function updateUI() {
      document.getElementById('score').textContent = score;
      document.getElementById('treats').textContent = treatsCollected;
      document.getElementById('treats-total').textContent = treatsCollected + treats.length;
      document.getElementById('cats').textContent = cats.length;

      // Update purr meter
      const purrBar = document.getElementById('purr-bar');
      const purrText = document.getElementById('purr-text');
      purrBar.style.width = (purrLevel * 100) + '%';

      if (discoMode) {
        purrText.textContent = 'DISCO MODE!';
        purrText.classList.add('visible');
        purrText.style.color = discoColors[Math.floor(discoTime * 5) % discoColors.length];
      } else if (purrLevel > 0.6) {
        purrText.textContent = 'MAXIMUM PURR!';
        purrText.classList.add('visible');
        purrText.style.color = '#f0f';
      } else {
        purrText.classList.remove('visible');
      }
    }

    function startGame() {
      document.getElementById('start-screen').style.display = 'none';
      document.getElementById('game-over').style.display = 'none';
      initGame();
      gameRunning = true;
    }

    document.getElementById('start-btn').addEventListener('click', startGame);
    document.getElementById('restart-btn').addEventListener('click', startGame);

    // Game loop
    let lastTime = 0;
    function gameLoop(time) {
      const dt = Math.min((time - lastTime) / 1000, 0.05);
      lastTime = time;

      update(dt);
      draw();

      requestAnimationFrame(gameLoop);
    }

    // Initial draw
    draw();
    requestAnimationFrame(gameLoop);
  </script>
</body>
</html>
