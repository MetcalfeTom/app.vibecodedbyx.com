<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Neon Synth - Glowing Keys</title>
  <meta name="description" content="Play a neon synthesizer with pulsing, color-changing keys">
  <meta property="og:title" content="Neon Synth">
  <meta property="og:description" content="Glowing synthesizer with pulsing neon keys">
  <meta property="og:url" content="https://app.sloppy.live/neon-synth">
  <meta property="og:image" content="https://app.sloppy.live/neon-synth/og-image.png">
  <link rel="icon" href="https://emojicdn.elk.sh/ðŸŽ¹">
  <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&display=swap" rel="stylesheet">
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      min-height: 100vh;
      background: #0a0a0f;
      font-family: 'Orbitron', sans-serif;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      overflow: hidden;
    }

    .container {
      text-align: center;
      padding: 20px;
    }

    h1 {
      font-size: 2.5rem;
      font-weight: 900;
      margin-bottom: 10px;
      background: linear-gradient(135deg, #ff00ff, #00ffff);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
      text-shadow: 0 0 30px rgba(255, 0, 255, 0.5);
    }

    .subtitle {
      color: #666;
      font-size: 0.8rem;
      margin-bottom: 30px;
      letter-spacing: 2px;
    }

    .controls {
      display: flex;
      gap: 15px;
      justify-content: center;
      margin-bottom: 30px;
      flex-wrap: wrap;
    }

    .control-group {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 5px;
    }

    .control-label {
      font-size: 0.65rem;
      color: #888;
      text-transform: uppercase;
      letter-spacing: 1px;
    }

    select, input[type="range"] {
      background: #151520;
      border: 1px solid #333;
      color: #fff;
      padding: 8px 12px;
      border-radius: 8px;
      font-family: 'Orbitron', sans-serif;
      font-size: 0.75rem;
      cursor: pointer;
    }

    select:focus, input:focus {
      outline: none;
      border-color: #ff00ff;
      box-shadow: 0 0 10px rgba(255, 0, 255, 0.3);
    }

    input[type="range"] {
      width: 100px;
      -webkit-appearance: none;
      height: 6px;
      padding: 0;
    }

    input[type="range"]::-webkit-slider-thumb {
      -webkit-appearance: none;
      width: 16px;
      height: 16px;
      background: linear-gradient(135deg, #ff00ff, #00ffff);
      border-radius: 50%;
      cursor: pointer;
      box-shadow: 0 0 10px #ff00ff;
    }

    .keyboard {
      display: flex;
      gap: 8px;
      justify-content: center;
      flex-wrap: wrap;
      max-width: 900px;
      perspective: 1000px;
    }

    .key {
      width: 70px;
      height: 180px;
      background: linear-gradient(180deg, #1a1a25 0%, #0f0f15 100%);
      border: 2px solid #222;
      border-radius: 0 0 12px 12px;
      cursor: pointer;
      position: relative;
      transition: all 0.1s ease;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: flex-end;
      padding-bottom: 15px;
      user-select: none;
      -webkit-tap-highlight-color: transparent;
    }

    .key::before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      border-radius: 0 0 10px 10px;
      opacity: 0;
      transition: opacity 0.1s ease;
    }

    .key:hover {
      transform: translateY(-3px);
    }

    .key.active {
      transform: translateY(3px);
    }

    .key.active::before {
      opacity: 1;
    }

    /* Color themes for each key */
    .key[data-color="magenta"] { --glow: #ff00ff; --glow-rgb: 255, 0, 255; }
    .key[data-color="cyan"] { --glow: #00ffff; --glow-rgb: 0, 255, 255; }
    .key[data-color="yellow"] { --glow: #ffff00; --glow-rgb: 255, 255, 0; }
    .key[data-color="lime"] { --glow: #00ff00; --glow-rgb: 0, 255, 0; }
    .key[data-color="orange"] { --glow: #ff8800; --glow-rgb: 255, 136, 0; }
    .key[data-color="pink"] { --glow: #ff0088; --glow-rgb: 255, 0, 136; }
    .key[data-color="blue"] { --glow: #0088ff; --glow-rgb: 0, 136, 255; }
    .key[data-color="red"] { --glow: #ff0044; --glow-rgb: 255, 0, 68; }
    .key[data-color="purple"] { --glow: #aa00ff; --glow-rgb: 170, 0, 255; }
    .key[data-color="teal"] { --glow: #00ffaa; --glow-rgb: 0, 255, 170; }
    .key[data-color="coral"] { --glow: #ff6655; --glow-rgb: 255, 102, 85; }
    .key[data-color="gold"] { --glow: #ffcc00; --glow-rgb: 255, 204, 0; }

    .key::before {
      background: radial-gradient(ellipse at center bottom, rgba(var(--glow-rgb), 0.4) 0%, transparent 70%);
      box-shadow:
        inset 0 0 30px rgba(var(--glow-rgb), 0.3),
        0 0 40px rgba(var(--glow-rgb), 0.5),
        0 0 80px rgba(var(--glow-rgb), 0.3);
    }

    .key.active {
      border-color: var(--glow);
      box-shadow:
        0 0 20px var(--glow),
        0 0 40px var(--glow),
        0 0 60px rgba(var(--glow-rgb), 0.5);
    }

    .key-note {
      font-size: 1.2rem;
      font-weight: 700;
      color: #444;
      transition: color 0.1s, text-shadow 0.1s;
    }

    .key.active .key-note {
      color: var(--glow);
      text-shadow: 0 0 10px var(--glow);
    }

    .key-label {
      font-size: 0.6rem;
      color: #333;
      margin-top: 5px;
      transition: color 0.1s;
    }

    .key.active .key-label {
      color: #666;
    }

    /* Pulse animation when active */
    @keyframes pulse {
      0%, 100% { transform: translateY(3px) scale(1); }
      50% { transform: translateY(3px) scale(1.02); }
    }

    .key.active {
      animation: pulse 0.15s ease infinite;
    }

    .visualizer {
      width: 100%;
      max-width: 900px;
      height: 80px;
      margin-top: 30px;
      background: #0f0f15;
      border-radius: 12px;
      border: 1px solid #222;
      overflow: hidden;
    }

    .visualizer canvas {
      width: 100%;
      height: 100%;
    }

    .hint {
      margin-top: 20px;
      font-size: 0.7rem;
      color: #444;
      letter-spacing: 1px;
    }

    .back-link {
      position: fixed;
      bottom: 20px;
      color: #444;
      text-decoration: none;
      font-size: 0.7rem;
      transition: color 0.2s;
    }

    .back-link:hover {
      color: #ff00ff;
    }

    .synth-only.hidden {
      display: none;
    }

    body.comedy-mode {
      background: linear-gradient(135deg, #1a0a1f 0%, #0f1a0a 100%);
    }

    body.comedy-mode h1 {
      background: linear-gradient(135deg, #ffff00, #ff6600, #ff00ff);
      -webkit-background-clip: text;
      background-clip: text;
      animation: rainbow 2s linear infinite;
    }

    @keyframes rainbow {
      0% { filter: hue-rotate(0deg); }
      100% { filter: hue-rotate(360deg); }
    }

    body.comedy-mode .subtitle {
      color: #ff6600;
    }

    body.tickle-mode {
      background: linear-gradient(135deg, #1a0f1f 0%, #1f0a1a 100%);
    }

    body.tickle-mode h1 {
      background: linear-gradient(135deg, #ff69b4, #ffb6c1, #ff1493);
      -webkit-background-clip: text;
      background-clip: text;
      animation: wiggle 0.3s ease-in-out infinite;
    }

    @keyframes wiggle {
      0%, 100% { transform: rotate(-1deg); }
      50% { transform: rotate(1deg); }
    }

    body.tickle-mode .subtitle {
      color: #ff69b4;
    }

    body.tickle-mode .key.active {
      animation: tickle-shake 0.1s ease-in-out infinite;
    }

    @keyframes tickle-shake {
      0%, 100% { transform: translateY(3px) translateX(-2px); }
      50% { transform: translateY(3px) translateX(2px); }
    }

    @media (max-width: 768px) {
      h1 { font-size: 1.8rem; }

      .key {
        width: 50px;
        height: 130px;
      }

      .key-note { font-size: 1rem; }
      .key-label { font-size: 0.5rem; }

      .controls { gap: 10px; }

      .visualizer { height: 60px; }
    }

    @media (max-width: 500px) {
      .key {
        width: 40px;
        height: 100px;
      }

      .keyboard { gap: 5px; }
    }
  </style>
</head>
<body>
  <div class="container">
    <h1>NEON SYNTH</h1>
    <p class="subtitle">CLICK KEYS OR USE KEYBOARD</p>

    <div class="controls">
      <div class="control-group">
        <label class="control-label">Mode</label>
        <select id="mode">
          <option value="synth">Synth</option>
          <option value="comedy">Comedy</option>
          <option value="tickle">Tickle</option>
        </select>
      </div>
      <div class="control-group synth-only">
        <label class="control-label">Waveform</label>
        <select id="waveform">
          <option value="sine">Sine</option>
          <option value="square">Square</option>
          <option value="sawtooth" selected>Sawtooth</option>
          <option value="triangle">Triangle</option>
        </select>
      </div>
      <div class="control-group synth-only">
        <label class="control-label">Octave</label>
        <select id="octave">
          <option value="2">Low</option>
          <option value="3" selected>Mid</option>
          <option value="4">High</option>
          <option value="5">Ultra</option>
        </select>
      </div>
      <div class="control-group synth-only">
        <label class="control-label">Attack</label>
        <input type="range" id="attack" min="0" max="500" value="10">
      </div>
      <div class="control-group synth-only">
        <label class="control-label">Release</label>
        <input type="range" id="release" min="50" max="2000" value="300">
      </div>
    </div>

    <div class="keyboard" id="keyboard"></div>

    <div class="visualizer">
      <canvas id="visualizer"></canvas>
    </div>

    <p class="hint">A S D F G H J K L ; ' for notes â€¢ Z X for octave</p>
  </div>

  <a href="https://sloppy.live" class="back-link">sloppy.live</a>

  <script>
    // Audio context
    let audioCtx = null;
    let analyser = null;
    let activeOscillators = {};

    // Notes and frequencies (C major scale + extras)
    const notes = [
      { note: 'C', key: 'a', color: 'magenta' },
      { note: 'D', key: 's', color: 'cyan' },
      { note: 'E', key: 'd', color: 'yellow' },
      { note: 'F', key: 'f', color: 'lime' },
      { note: 'G', key: 'g', color: 'orange' },
      { note: 'A', key: 'h', color: 'pink' },
      { note: 'B', key: 'j', color: 'blue' },
      { note: 'C+', key: 'k', color: 'red' },
      { note: 'D+', key: 'l', color: 'purple' },
      { note: 'E+', key: ';', color: 'teal' },
      { note: 'F+', key: "'", color: 'coral' },
      { note: 'G+', key: '\\', color: 'gold' }
    ];

    // Frequency calculation
    function getFrequency(note, octave) {
      const noteFreqs = {
        'C': 261.63, 'D': 293.66, 'E': 329.63, 'F': 349.23,
        'G': 392.00, 'A': 440.00, 'B': 493.88,
        'C+': 523.25, 'D+': 587.33, 'E+': 659.25, 'F+': 698.46, 'G+': 783.99
      };
      const baseOctave = 4;
      const multiplier = Math.pow(2, octave - baseOctave);
      return noteFreqs[note] * multiplier;
    }

    // Initialize audio
    function initAudio() {
      if (audioCtx) return;
      audioCtx = new (window.AudioContext || window.webkitAudioContext)();
      analyser = audioCtx.createAnalyser();
      analyser.fftSize = 256;
      analyser.connect(audioCtx.destination);
      startVisualizer();
    }

    // Comedy sound definitions for each key
    const comedySounds = {
      'C': 'honk',       // Classic honk
      'D': 'laugh',      // Ha ha ha
      'E': 'boing',      // Spring boing
      'F': 'quack',      // Duck quack
      'G': 'fart',       // Whoopee cushion
      'A': 'whistle',    // Slide whistle up
      'B': 'bonk',       // Cartoon bonk
      'C+': 'giggle',    // High pitched giggle
      'D+': 'horn',      // Bicycle horn
      'E+': 'splat',     // Pie splat
      'F+': 'wah',       // Sad trombone
      'G+': 'party'      // Party horn
    };

    // Play comedy sound
    function playComedySound(noteData) {
      initAudio();
      const soundType = comedySounds[noteData.note];
      const t = audioCtx.currentTime;

      switch(soundType) {
        case 'honk': {
          // Classic car honk
          const osc = audioCtx.createOscillator();
          const gain = audioCtx.createGain();
          osc.type = 'sawtooth';
          osc.frequency.setValueAtTime(400, t);
          osc.frequency.linearRampToValueAtTime(300, t + 0.1);
          osc.frequency.setValueAtTime(300, t + 0.3);
          gain.gain.setValueAtTime(0.4, t);
          gain.gain.linearRampToValueAtTime(0, t + 0.4);
          osc.connect(gain);
          gain.connect(analyser);
          osc.start(t);
          osc.stop(t + 0.4);
          break;
        }
        case 'laugh': {
          // Ha ha ha laugh
          for(let i = 0; i < 4; i++) {
            const osc = audioCtx.createOscillator();
            const gain = audioCtx.createGain();
            osc.type = 'triangle';
            osc.frequency.setValueAtTime(300 + Math.random() * 100, t + i * 0.12);
            osc.frequency.linearRampToValueAtTime(200, t + i * 0.12 + 0.08);
            gain.gain.setValueAtTime(0, t + i * 0.12);
            gain.gain.linearRampToValueAtTime(0.3, t + i * 0.12 + 0.02);
            gain.gain.linearRampToValueAtTime(0, t + i * 0.12 + 0.1);
            osc.connect(gain);
            gain.connect(analyser);
            osc.start(t + i * 0.12);
            osc.stop(t + i * 0.12 + 0.12);
          }
          break;
        }
        case 'boing': {
          // Spring boing
          const osc = audioCtx.createOscillator();
          const gain = audioCtx.createGain();
          osc.type = 'sine';
          osc.frequency.setValueAtTime(100, t);
          osc.frequency.exponentialRampToValueAtTime(800, t + 0.1);
          osc.frequency.exponentialRampToValueAtTime(200, t + 0.3);
          osc.frequency.exponentialRampToValueAtTime(600, t + 0.4);
          osc.frequency.exponentialRampToValueAtTime(150, t + 0.6);
          gain.gain.setValueAtTime(0.4, t);
          gain.gain.linearRampToValueAtTime(0, t + 0.6);
          osc.connect(gain);
          gain.connect(analyser);
          osc.start(t);
          osc.stop(t + 0.6);
          break;
        }
        case 'quack': {
          // Duck quack
          const osc = audioCtx.createOscillator();
          const gain = audioCtx.createGain();
          osc.type = 'sawtooth';
          osc.frequency.setValueAtTime(800, t);
          osc.frequency.linearRampToValueAtTime(300, t + 0.08);
          osc.frequency.setValueAtTime(300, t + 0.15);
          gain.gain.setValueAtTime(0.3, t);
          gain.gain.setValueAtTime(0.3, t + 0.12);
          gain.gain.linearRampToValueAtTime(0, t + 0.2);
          osc.connect(gain);
          gain.connect(analyser);
          osc.start(t);
          osc.stop(t + 0.2);
          break;
        }
        case 'fart': {
          // Whoopee cushion
          const osc = audioCtx.createOscillator();
          const osc2 = audioCtx.createOscillator();
          const gain = audioCtx.createGain();
          osc.type = 'sawtooth';
          osc2.type = 'square';
          osc.frequency.setValueAtTime(80, t);
          osc.frequency.linearRampToValueAtTime(40, t + 0.5);
          osc2.frequency.setValueAtTime(85, t);
          osc2.frequency.linearRampToValueAtTime(35, t + 0.5);
          gain.gain.setValueAtTime(0.3, t);
          gain.gain.linearRampToValueAtTime(0.1, t + 0.3);
          gain.gain.linearRampToValueAtTime(0, t + 0.5);
          osc.connect(gain);
          osc2.connect(gain);
          gain.connect(analyser);
          osc.start(t);
          osc2.start(t);
          osc.stop(t + 0.5);
          osc2.stop(t + 0.5);
          break;
        }
        case 'whistle': {
          // Slide whistle up
          const osc = audioCtx.createOscillator();
          const gain = audioCtx.createGain();
          osc.type = 'sine';
          osc.frequency.setValueAtTime(300, t);
          osc.frequency.exponentialRampToValueAtTime(2000, t + 0.5);
          gain.gain.setValueAtTime(0.25, t);
          gain.gain.linearRampToValueAtTime(0, t + 0.55);
          osc.connect(gain);
          gain.connect(analyser);
          osc.start(t);
          osc.stop(t + 0.55);
          break;
        }
        case 'bonk': {
          // Cartoon bonk
          const osc = audioCtx.createOscillator();
          const gain = audioCtx.createGain();
          osc.type = 'square';
          osc.frequency.setValueAtTime(600, t);
          osc.frequency.exponentialRampToValueAtTime(100, t + 0.15);
          gain.gain.setValueAtTime(0.4, t);
          gain.gain.linearRampToValueAtTime(0, t + 0.2);
          osc.connect(gain);
          gain.connect(analyser);
          osc.start(t);
          osc.stop(t + 0.2);
          break;
        }
        case 'giggle': {
          // High pitched giggle
          for(let i = 0; i < 6; i++) {
            const osc = audioCtx.createOscillator();
            const gain = audioCtx.createGain();
            osc.type = 'sine';
            osc.frequency.setValueAtTime(800 + Math.random() * 200, t + i * 0.08);
            osc.frequency.linearRampToValueAtTime(600, t + i * 0.08 + 0.05);
            gain.gain.setValueAtTime(0, t + i * 0.08);
            gain.gain.linearRampToValueAtTime(0.2, t + i * 0.08 + 0.01);
            gain.gain.linearRampToValueAtTime(0, t + i * 0.08 + 0.06);
            osc.connect(gain);
            gain.connect(analyser);
            osc.start(t + i * 0.08);
            osc.stop(t + i * 0.08 + 0.08);
          }
          break;
        }
        case 'horn': {
          // Bicycle horn - double honk
          for(let i = 0; i < 2; i++) {
            const osc = audioCtx.createOscillator();
            const gain = audioCtx.createGain();
            osc.type = 'square';
            osc.frequency.setValueAtTime(500, t + i * 0.2);
            osc.frequency.linearRampToValueAtTime(400, t + i * 0.2 + 0.1);
            gain.gain.setValueAtTime(0.3, t + i * 0.2);
            gain.gain.linearRampToValueAtTime(0, t + i * 0.2 + 0.15);
            osc.connect(gain);
            gain.connect(analyser);
            osc.start(t + i * 0.2);
            osc.stop(t + i * 0.2 + 0.15);
          }
          break;
        }
        case 'splat': {
          // Pie splat / wet splat
          const osc = audioCtx.createOscillator();
          const osc2 = audioCtx.createOscillator();
          const gain = audioCtx.createGain();
          osc.type = 'sawtooth';
          osc2.type = 'triangle';
          osc.frequency.setValueAtTime(200, t);
          osc.frequency.linearRampToValueAtTime(60, t + 0.2);
          osc2.frequency.setValueAtTime(180, t);
          osc2.frequency.linearRampToValueAtTime(40, t + 0.25);
          gain.gain.setValueAtTime(0.4, t);
          gain.gain.linearRampToValueAtTime(0, t + 0.3);
          osc.connect(gain);
          osc2.connect(gain);
          gain.connect(analyser);
          osc.start(t);
          osc2.start(t);
          osc.stop(t + 0.3);
          osc2.stop(t + 0.3);
          break;
        }
        case 'wah': {
          // Sad trombone wah wah wah
          const notes = [300, 280, 260, 200];
          notes.forEach((freq, i) => {
            const osc = audioCtx.createOscillator();
            const gain = audioCtx.createGain();
            osc.type = 'sawtooth';
            osc.frequency.setValueAtTime(freq, t + i * 0.25);
            osc.frequency.linearRampToValueAtTime(freq * 0.9, t + i * 0.25 + 0.2);
            gain.gain.setValueAtTime(0.25, t + i * 0.25);
            gain.gain.linearRampToValueAtTime(0, t + i * 0.25 + 0.22);
            osc.connect(gain);
            gain.connect(analyser);
            osc.start(t + i * 0.25);
            osc.stop(t + i * 0.25 + 0.25);
          });
          break;
        }
        case 'party': {
          // Party horn / kazoo
          const osc = audioCtx.createOscillator();
          const osc2 = audioCtx.createOscillator();
          const gain = audioCtx.createGain();
          osc.type = 'sawtooth';
          osc2.type = 'square';
          osc.frequency.setValueAtTime(400, t);
          osc.frequency.linearRampToValueAtTime(600, t + 0.1);
          osc.frequency.setValueAtTime(600, t + 0.5);
          osc2.frequency.setValueAtTime(402, t);
          osc2.frequency.linearRampToValueAtTime(605, t + 0.1);
          gain.gain.setValueAtTime(0, t);
          gain.gain.linearRampToValueAtTime(0.3, t + 0.05);
          gain.gain.setValueAtTime(0.3, t + 0.4);
          gain.gain.linearRampToValueAtTime(0, t + 0.5);
          osc.connect(gain);
          osc2.connect(gain);
          gain.connect(analyser);
          osc.start(t);
          osc2.start(t);
          osc.stop(t + 0.5);
          osc2.stop(t + 0.5);
          break;
        }
      }
    }

    // Tickle phrases for each key
    const ticklePhrases = {
      'C': 'Gah!',
      'D': 'Ehehehehe!!',
      'E': 'Yee Yow!',
      'F': 'I am so ticklish!',
      'G': 'Stop it! Hahaha!',
      'A': 'Nohoho not there!',
      'B': 'Eeek!',
      'C+': 'That tickles so much!',
      'D+': 'Ahaha I can\'t!',
      'E+': 'Mercy! Mercy!',
      'F+': 'Heeheehee!',
      'G+': 'I\'m gonna pee!'
    };

    // Play tickle speech
    function playTickleSound(noteData) {
      const phrase = ticklePhrases[noteData.note];
      if (!phrase) return;

      // Cancel any ongoing speech
      speechSynthesis.cancel();

      const utterance = new SpeechSynthesisUtterance(phrase);

      // Randomize pitch and rate for variety
      utterance.pitch = 1.2 + Math.random() * 0.6; // Higher pitched
      utterance.rate = 1.1 + Math.random() * 0.4; // Slightly faster
      utterance.volume = 1;

      // Try to get a fun voice
      const voices = speechSynthesis.getVoices();
      const funVoices = voices.filter(v =>
        v.lang.startsWith('en') && (v.name.includes('Female') || v.name.includes('Samantha') || v.name.includes('Victoria'))
      );
      if (funVoices.length > 0) {
        utterance.voice = funVoices[Math.floor(Math.random() * funVoices.length)];
      } else if (voices.length > 0) {
        const englishVoices = voices.filter(v => v.lang.startsWith('en'));
        if (englishVoices.length > 0) {
          utterance.voice = englishVoices[Math.floor(Math.random() * englishVoices.length)];
        }
      }

      speechSynthesis.speak(utterance);

      // Also play a quick tickle sound effect
      initAudio();
      const t = audioCtx.currentTime;
      const osc = audioCtx.createOscillator();
      const gain = audioCtx.createGain();
      osc.type = 'sine';
      osc.frequency.setValueAtTime(800 + Math.random() * 400, t);
      osc.frequency.linearRampToValueAtTime(400, t + 0.1);
      gain.gain.setValueAtTime(0.15, t);
      gain.gain.linearRampToValueAtTime(0, t + 0.15);
      osc.connect(gain);
      gain.connect(analyser);
      osc.start(t);
      osc.stop(t + 0.15);
    }

    // Get current mode
    function getMode() {
      return document.getElementById('mode').value;
    }

    function isComedyMode() {
      return getMode() === 'comedy';
    }

    function isTickleMode() {
      return getMode() === 'tickle';
    }

    // Play note (mode aware)
    function playNote(noteData) {
      initAudio();

      if (isComedyMode()) {
        playComedySound(noteData);
        return;
      }

      if (isTickleMode()) {
        playTickleSound(noteData);
        return;
      }

      const id = noteData.note;
      if (activeOscillators[id]) return;

      const octave = parseInt(document.getElementById('octave').value);
      const waveform = document.getElementById('waveform').value;
      const attackTime = document.getElementById('attack').value / 1000;

      const osc = audioCtx.createOscillator();
      const gain = audioCtx.createGain();

      osc.type = waveform;
      osc.frequency.value = getFrequency(noteData.note, octave);

      gain.gain.setValueAtTime(0, audioCtx.currentTime);
      gain.gain.linearRampToValueAtTime(0.3, audioCtx.currentTime + attackTime);

      osc.connect(gain);
      gain.connect(analyser);

      osc.start();
      activeOscillators[id] = { osc, gain };
    }

    // Stop note
    function stopNote(noteData) {
      if (isComedyMode() || isTickleMode()) return; // Comedy/Tickle sounds are one-shots

      const id = noteData.note;
      const active = activeOscillators[id];
      if (!active) return;

      const releaseTime = document.getElementById('release').value / 1000;

      active.gain.gain.cancelScheduledValues(audioCtx.currentTime);
      active.gain.gain.setValueAtTime(active.gain.gain.value, audioCtx.currentTime);
      active.gain.gain.linearRampToValueAtTime(0, audioCtx.currentTime + releaseTime);

      setTimeout(() => {
        active.osc.stop();
        active.osc.disconnect();
        active.gain.disconnect();
      }, releaseTime * 1000 + 50);

      delete activeOscillators[id];
    }

    // Create keyboard
    function createKeyboard() {
      const keyboard = document.getElementById('keyboard');

      notes.forEach(noteData => {
        const key = document.createElement('div');
        key.className = 'key';
        key.dataset.note = noteData.note;
        key.dataset.color = noteData.color;
        key.innerHTML = `
          <span class="key-note">${noteData.note.replace('+', '')}</span>
          <span class="key-label">${noteData.key.toUpperCase()}</span>
        `;

        // Mouse/touch events
        key.addEventListener('mousedown', (e) => {
          e.preventDefault();
          key.classList.add('active');
          playNote(noteData);
        });

        key.addEventListener('mouseup', () => {
          key.classList.remove('active');
          stopNote(noteData);
        });

        key.addEventListener('mouseleave', () => {
          if (key.classList.contains('active')) {
            key.classList.remove('active');
            stopNote(noteData);
          }
        });

        // Touch events
        key.addEventListener('touchstart', (e) => {
          e.preventDefault();
          key.classList.add('active');
          playNote(noteData);
        });

        key.addEventListener('touchend', () => {
          key.classList.remove('active');
          stopNote(noteData);
        });

        keyboard.appendChild(key);
      });
    }

    // Keyboard input
    const keyMap = {};
    notes.forEach(n => keyMap[n.key] = n);

    document.addEventListener('keydown', (e) => {
      if (e.repeat) return;

      const key = e.key.toLowerCase();

      // Octave controls
      if (key === 'z') {
        const octaveSelect = document.getElementById('octave');
        const idx = octaveSelect.selectedIndex;
        if (idx > 0) octaveSelect.selectedIndex = idx - 1;
        return;
      }
      if (key === 'x') {
        const octaveSelect = document.getElementById('octave');
        const idx = octaveSelect.selectedIndex;
        if (idx < octaveSelect.options.length - 1) octaveSelect.selectedIndex = idx + 1;
        return;
      }

      const noteData = keyMap[key];
      if (noteData) {
        const keyEl = document.querySelector(`[data-note="${noteData.note}"]`);
        if (keyEl && !keyEl.classList.contains('active')) {
          keyEl.classList.add('active');
          playNote(noteData);
        }
      }
    });

    document.addEventListener('keyup', (e) => {
      const key = e.key.toLowerCase();
      const noteData = keyMap[key];
      if (noteData) {
        const keyEl = document.querySelector(`[data-note="${noteData.note}"]`);
        if (keyEl) {
          keyEl.classList.remove('active');
          stopNote(noteData);
        }
      }
    });

    // Visualizer
    function startVisualizer() {
      const canvas = document.getElementById('visualizer');
      const ctx = canvas.getContext('2d');

      function resize() {
        canvas.width = canvas.offsetWidth * 2;
        canvas.height = canvas.offsetHeight * 2;
      }
      resize();
      window.addEventListener('resize', resize);

      const bufferLength = analyser.frequencyBinCount;
      const dataArray = new Uint8Array(bufferLength);

      function draw() {
        requestAnimationFrame(draw);

        analyser.getByteFrequencyData(dataArray);

        ctx.fillStyle = '#0f0f15';
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        const barWidth = canvas.width / bufferLength * 2.5;
        let x = 0;

        for (let i = 0; i < bufferLength; i++) {
          const barHeight = (dataArray[i] / 255) * canvas.height;

          // Rainbow gradient based on frequency
          const hue = (i / bufferLength) * 300;
          const lightness = 50 + (dataArray[i] / 255) * 30;

          ctx.fillStyle = `hsl(${hue}, 100%, ${lightness}%)`;
          ctx.shadowColor = `hsl(${hue}, 100%, 50%)`;
          ctx.shadowBlur = 15;

          ctx.fillRect(x, canvas.height - barHeight, barWidth - 2, barHeight);

          x += barWidth;
        }
      }

      draw();
    }

    // Mode toggle handler
    document.getElementById('mode').addEventListener('change', (e) => {
      const mode = e.target.value;
      const isComedy = mode === 'comedy';
      const isTickle = mode === 'tickle';

      document.body.classList.remove('comedy-mode', 'tickle-mode');
      if (isComedy) document.body.classList.add('comedy-mode');
      if (isTickle) document.body.classList.add('tickle-mode');

      document.querySelectorAll('.synth-only').forEach(el => {
        el.classList.toggle('hidden', isComedy || isTickle);
      });

      // Update subtitle
      const subtitles = {
        'synth': 'CLICK KEYS OR USE KEYBOARD',
        'comedy': 'HONKS â€¢ LAUGHS â€¢ BOINGS â€¢ FARTS',
        'tickle': 'GAH! â€¢ EHEHEHE â€¢ STOP IT!'
      };
      document.querySelector('.subtitle').textContent = subtitles[mode];

      // Pre-load voices for tickle mode
      if (isTickle) {
        speechSynthesis.getVoices();
      }
    });

    // Init
    createKeyboard();
  </script>
<script src="/apps/sloppy-header/sloppy-bar.js"></script>
<script src="/vibelib-extended.js"></script>
<script>
  // Compatibility Patch for Legacy Apps
  window.addEventListener("load", () => {
    if (window.SloppyKarma && window.VibeLib.Economy) {
      // Redirect old calls to new engine
      window.SloppyKarma.track = window.VibeLib.Economy.track;
    }
  });
</script>
</body>
</html>
