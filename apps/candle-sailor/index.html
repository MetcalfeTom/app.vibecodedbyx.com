<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
  <title>Candle Sailor - Pixel Ocean</title>
  <link rel="icon" href="https://emojicdn.elk.sh/⛵">
  <meta property="og:title" content="Candle Sailor">
  <meta property="og:description" content="Sail through a dark pixel ocean dodging red candles!">
  <meta property="og:url" content="https://app.sloppy.live/candle-sailor">
  <meta property="og:image" content="https://app.sloppy.live/candle-sailor/og-image.png">
  <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      background: #0a0a12;
      min-height: 100vh;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      font-family: 'Press Start 2P', monospace;
      overflow: hidden;
    }

    .game-container {
      position: relative;
      image-rendering: pixelated;
    }

    canvas {
      display: block;
      border: 4px solid #1a1a2e;
      box-shadow: 0 0 30px rgba(100, 0, 150, 0.3);
    }

    .ui-overlay {
      position: absolute;
      top: 10px;
      left: 10px;
      right: 10px;
      display: flex;
      justify-content: space-between;
      color: #8888aa;
      font-size: 10px;
      text-shadow: 2px 2px 0 #000;
      pointer-events: none;
    }

    .start-screen, .game-over {
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      background: rgba(5, 5, 15, 0.95);
      color: #6688cc;
      text-align: center;
      padding: 20px;
    }

    .title {
      font-size: 18px;
      margin-bottom: 10px;
      color: #88aaee;
      text-shadow: 0 0 10px #4466aa;
    }

    .subtitle {
      font-size: 8px;
      color: #ff4444;
      margin-bottom: 30px;
    }

    .instructions {
      font-size: 7px;
      line-height: 2;
      color: #5566aa;
      margin-bottom: 30px;
    }

    .start-btn {
      background: transparent;
      border: 2px solid #4466aa;
      color: #88aaee;
      padding: 12px 30px;
      font-family: 'Press Start 2P', monospace;
      font-size: 10px;
      cursor: pointer;
      transition: all 0.2s;
    }

    .start-btn:hover {
      background: #4466aa;
      color: #0a0a12;
      box-shadow: 0 0 20px #4466aa;
    }

    .game-over {
      display: none;
    }

    .game-over.active {
      display: flex;
    }

    .start-screen.hidden {
      display: none;
    }

    .final-score {
      font-size: 24px;
      color: #ff6666;
      margin: 20px 0;
      text-shadow: 0 0 10px #ff4444;
    }

    .high-score-text {
      font-size: 8px;
      color: #44aa44;
      margin-bottom: 20px;
    }

    .mobile-controls {
      display: none;
      position: fixed;
      bottom: 20px;
      left: 0;
      right: 0;
      justify-content: center;
      gap: 20px;
      padding: 10px;
    }

    .mobile-btn {
      width: 70px;
      height: 70px;
      background: rgba(100, 100, 150, 0.3);
      border: 2px solid #4466aa;
      border-radius: 10px;
      color: #88aaee;
      font-size: 24px;
      display: flex;
      align-items: center;
      justify-content: center;
      user-select: none;
      -webkit-tap-highlight-color: transparent;
    }

    .mobile-btn:active {
      background: rgba(100, 100, 150, 0.6);
    }

    .back-link {
      position: fixed;
      bottom: 10px;
      left: 50%;
      transform: translateX(-50%);
      color: #333;
      font-size: 8px;
      text-decoration: none;
    }

    .back-link:hover {
      color: #4466aa;
    }

    @media (max-width: 600px) {
      .mobile-controls {
        display: flex;
      }
      canvas {
        max-width: 100vw;
        max-height: 60vh;
      }
      .title { font-size: 14px; }
      .instructions { font-size: 6px; }
    }
  </style>
</head>
<body>
  <div class="game-container">
    <canvas id="game" width="400" height="500"></canvas>
    <div class="ui-overlay">
      <span id="score">SCORE: 0</span>
      <span id="highScore">BEST: 0</span>
    </div>

    <div class="start-screen" id="startScreen">
      <div class="title">CANDLE SAILOR</div>
      <div class="subtitle">▼ BEARISH WATERS ▼</div>
      <div class="instructions">
        SAIL THROUGH THE DARK OCEAN<br>
        DODGE THE RED CANDLES<br>
        COLLECT GREEN FOR POINTS<br><br>
        ← → OR A/D TO STEER
      </div>
      <button class="start-btn" id="startBtn">SET SAIL</button>
    </div>

    <div class="game-over" id="gameOver">
      <div class="title" style="color: #ff6666;">CAPSIZED!</div>
      <div class="final-score" id="finalScore">0</div>
      <div class="high-score-text" id="newHighScore"></div>
      <button class="start-btn" id="restartBtn">SAIL AGAIN</button>
    </div>
  </div>

  <div class="mobile-controls" id="mobileControls">
    <button class="mobile-btn" id="leftBtn">◀</button>
    <button class="mobile-btn" id="rightBtn">▶</button>
  </div>

  <a class="back-link" href="https://sloppy.live">[ sloppy.live ]</a>

  <script>
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');

    // Game state
    let gameRunning = false;
    let score = 0;
    let highScore = parseInt(localStorage.getItem('candleSailorHigh')) || 0;
    let gameSpeed = 1;

    // Boat
    const boat = {
      x: 200,
      y: 400,
      width: 32,
      height: 40,
      speed: 0,
      maxSpeed: 5,
      accel: 0.4,
      friction: 0.92
    };

    // Candles
    let candles = [];
    let greenCandles = [];

    // Ocean waves
    let waveOffset = 0;

    // Stars
    const stars = [];
    for (let i = 0; i < 50; i++) {
      stars.push({
        x: Math.random() * 400,
        y: Math.random() * 200,
        size: Math.random() < 0.3 ? 2 : 1,
        twinkle: Math.random() * Math.PI * 2
      });
    }

    // Controls
    const keys = { left: false, right: false };

    // Input handlers
    document.addEventListener('keydown', e => {
      if (e.key === 'ArrowLeft' || e.key === 'a' || e.key === 'A') keys.left = true;
      if (e.key === 'ArrowRight' || e.key === 'd' || e.key === 'D') keys.right = true;
    });

    document.addEventListener('keyup', e => {
      if (e.key === 'ArrowLeft' || e.key === 'a' || e.key === 'A') keys.left = false;
      if (e.key === 'ArrowRight' || e.key === 'd' || e.key === 'D') keys.right = false;
    });

    // Mobile controls
    const leftBtn = document.getElementById('leftBtn');
    const rightBtn = document.getElementById('rightBtn');

    leftBtn.addEventListener('touchstart', e => { e.preventDefault(); keys.left = true; });
    leftBtn.addEventListener('touchend', e => { e.preventDefault(); keys.left = false; });
    rightBtn.addEventListener('touchstart', e => { e.preventDefault(); keys.right = true; });
    rightBtn.addEventListener('touchend', e => { e.preventDefault(); keys.right = false; });

    // Start/restart buttons
    document.getElementById('startBtn').addEventListener('click', startGame);
    document.getElementById('restartBtn').addEventListener('click', startGame);

    // Draw pixel boat
    function drawBoat() {
      const bx = Math.floor(boat.x);
      const by = Math.floor(boat.y);
      const tilt = boat.speed * 2;

      ctx.save();
      ctx.translate(bx, by);
      ctx.rotate(tilt * Math.PI / 180);

      // Hull (dark wood)
      ctx.fillStyle = '#3d2817';
      ctx.fillRect(-14, 8, 28, 12);
      ctx.fillRect(-12, 20, 24, 6);
      ctx.fillRect(-10, 26, 20, 4);

      // Hull highlight
      ctx.fillStyle = '#5a3d2b';
      ctx.fillRect(-12, 10, 24, 4);

      // Mast
      ctx.fillStyle = '#2a1a0a';
      ctx.fillRect(-2, -20, 4, 30);

      // Sail
      ctx.fillStyle = '#c4b8a8';
      ctx.beginPath();
      ctx.moveTo(2, -18);
      ctx.lineTo(2, 5);
      ctx.lineTo(18 + Math.sin(waveOffset * 2) * 2, -5);
      ctx.closePath();
      ctx.fill();

      // Sail shadow
      ctx.fillStyle = '#9a8e7e';
      ctx.beginPath();
      ctx.moveTo(2, -10);
      ctx.lineTo(2, 5);
      ctx.lineTo(12 + Math.sin(waveOffset * 2) * 2, -2);
      ctx.closePath();
      ctx.fill();

      // Flag
      ctx.fillStyle = '#6688cc';
      ctx.fillRect(0, -24, 8, 5);

      ctx.restore();
    }

    // Draw red candle
    function drawRedCandle(c) {
      const cx = Math.floor(c.x);
      const cy = Math.floor(c.y);

      // Wick
      ctx.fillStyle = '#222';
      ctx.fillRect(cx - 1, cy - c.height/2 - 6, 2, 6);

      // Body
      ctx.fillStyle = '#aa2222';
      ctx.fillRect(cx - 6, cy - c.height/2, 12, c.height);

      // Darker edge
      ctx.fillStyle = '#881818';
      ctx.fillRect(cx + 4, cy - c.height/2, 2, c.height);

      // Top wick glow
      ctx.fillStyle = '#ff4444';
      ctx.fillRect(cx - 2, cy - c.height/2 - 8, 4, 3);
    }

    // Draw green candle
    function drawGreenCandle(c) {
      const cx = Math.floor(c.x);
      const cy = Math.floor(c.y);

      // Wick
      ctx.fillStyle = '#222';
      ctx.fillRect(cx - 1, cy - c.height/2 - 6, 2, 6);

      // Body
      ctx.fillStyle = '#22aa44';
      ctx.fillRect(cx - 5, cy - c.height/2, 10, c.height);

      // Highlight
      ctx.fillStyle = '#33cc55';
      ctx.fillRect(cx - 5, cy - c.height/2, 3, c.height);

      // Glow effect
      ctx.fillStyle = 'rgba(50, 255, 100, 0.3)';
      ctx.beginPath();
      ctx.arc(cx, cy, 15, 0, Math.PI * 2);
      ctx.fill();
    }

    // Draw dark moody ocean
    function drawOcean() {
      // Sky gradient (dark and moody)
      const skyGrad = ctx.createLinearGradient(0, 0, 0, 250);
      skyGrad.addColorStop(0, '#050510');
      skyGrad.addColorStop(0.5, '#0a0a1a');
      skyGrad.addColorStop(1, '#151530');
      ctx.fillStyle = skyGrad;
      ctx.fillRect(0, 0, 400, 250);

      // Stars
      stars.forEach(star => {
        star.twinkle += 0.02;
        const alpha = 0.3 + Math.sin(star.twinkle) * 0.3;
        ctx.fillStyle = `rgba(150, 150, 200, ${alpha})`;
        ctx.fillRect(star.x, star.y, star.size, star.size);
      });

      // Moon
      ctx.fillStyle = '#3a3a5a';
      ctx.beginPath();
      ctx.arc(350, 60, 25, 0, Math.PI * 2);
      ctx.fill();
      ctx.fillStyle = '#2a2a4a';
      ctx.beginPath();
      ctx.arc(340, 55, 22, 0, Math.PI * 2);
      ctx.fill();

      // Ocean layers
      for (let layer = 0; layer < 8; layer++) {
        const yBase = 220 + layer * 35;
        const darkness = 0.15 + layer * 0.08;

        ctx.fillStyle = `rgba(10, 20, ${50 - layer * 5}, ${darkness})`;
        ctx.beginPath();
        ctx.moveTo(0, yBase);

        for (let x = 0; x <= 400; x += 10) {
          const wave = Math.sin((x + waveOffset * (50 - layer * 5)) * 0.02 + layer) * (8 - layer * 0.5);
          ctx.lineTo(x, yBase + wave);
        }

        ctx.lineTo(400, 500);
        ctx.lineTo(0, 500);
        ctx.closePath();
        ctx.fill();
      }

      // Wave highlights
      ctx.strokeStyle = 'rgba(80, 100, 150, 0.15)';
      ctx.lineWidth = 1;
      for (let i = 0; i < 5; i++) {
        const yBase = 260 + i * 50;
        ctx.beginPath();
        for (let x = 0; x <= 400; x += 5) {
          const wave = Math.sin((x + waveOffset * 30) * 0.03 + i * 2) * 5;
          if (x === 0) ctx.moveTo(x, yBase + wave);
          else ctx.lineTo(x, yBase + wave);
        }
        ctx.stroke();
      }

      // Fog at bottom
      const fogGrad = ctx.createLinearGradient(0, 450, 0, 500);
      fogGrad.addColorStop(0, 'rgba(20, 25, 40, 0)');
      fogGrad.addColorStop(1, 'rgba(20, 25, 40, 0.8)');
      ctx.fillStyle = fogGrad;
      ctx.fillRect(0, 450, 400, 50);
    }

    // Spawn candles
    function spawnCandle() {
      const isGreen = Math.random() < 0.15; // 15% green candles

      if (isGreen) {
        greenCandles.push({
          x: Math.random() * 360 + 20,
          y: -30,
          height: 20 + Math.random() * 10,
          speed: 1.5 + Math.random() * gameSpeed
        });
      } else {
        candles.push({
          x: Math.random() * 360 + 20,
          y: -40,
          height: 25 + Math.random() * 30,
          speed: 2 + Math.random() * gameSpeed * 1.5
        });
      }
    }

    // Collision detection
    function checkCollision(c, isGreen = false) {
      const hitboxPadding = isGreen ? 10 : 5;
      return (
        boat.x - 12 < c.x + 6 &&
        boat.x + 12 > c.x - 6 &&
        boat.y - 15 < c.y + c.height/2 &&
        boat.y + 20 > c.y - c.height/2 - hitboxPadding
      );
    }

    // Particle effects
    let particles = [];

    function createSplash(x, y, color) {
      for (let i = 0; i < 8; i++) {
        particles.push({
          x, y,
          vx: (Math.random() - 0.5) * 4,
          vy: -Math.random() * 3 - 1,
          life: 30,
          color
        });
      }
    }

    function updateParticles() {
      particles = particles.filter(p => {
        p.x += p.vx;
        p.y += p.vy;
        p.vy += 0.15;
        p.life--;
        return p.life > 0;
      });
    }

    function drawParticles() {
      particles.forEach(p => {
        ctx.fillStyle = p.color;
        ctx.globalAlpha = p.life / 30;
        ctx.fillRect(p.x - 2, p.y - 2, 4, 4);
      });
      ctx.globalAlpha = 1;
    }

    // Game loop
    function update() {
      if (!gameRunning) return;

      // Update wave animation
      waveOffset += 0.5;

      // Boat movement
      if (keys.left) boat.speed -= boat.accel;
      if (keys.right) boat.speed += boat.accel;
      boat.speed *= boat.friction;
      boat.speed = Math.max(-boat.maxSpeed, Math.min(boat.maxSpeed, boat.speed));
      boat.x += boat.speed;

      // Keep boat in bounds
      boat.x = Math.max(20, Math.min(380, boat.x));

      // Boat bob on waves
      boat.y = 400 + Math.sin(waveOffset * 0.1) * 3;

      // Update candles
      candles.forEach(c => c.y += c.speed);
      greenCandles.forEach(c => c.y += c.speed);

      // Remove off-screen candles
      candles = candles.filter(c => c.y < 550);
      greenCandles = greenCandles.filter(c => c.y < 550);

      // Check red candle collisions
      for (const c of candles) {
        if (checkCollision(c)) {
          gameOver();
          return;
        }
      }

      // Check green candle collisions
      greenCandles = greenCandles.filter(c => {
        if (checkCollision(c, true)) {
          score += 50;
          createSplash(c.x, c.y, '#44ff66');
          playSound('collect');
          return false;
        }
        return true;
      });

      // Spawn new candles
      if (Math.random() < 0.02 + gameSpeed * 0.01) {
        spawnCandle();
      }

      // Increase difficulty
      score++;
      gameSpeed = 1 + Math.floor(score / 500) * 0.3;

      // Update particles
      updateParticles();

      // Update UI
      document.getElementById('score').textContent = `SCORE: ${score}`;
    }

    function draw() {
      // Clear
      ctx.fillStyle = '#050510';
      ctx.fillRect(0, 0, 400, 500);

      // Draw ocean and sky
      drawOcean();

      // Draw green candles
      greenCandles.forEach(drawGreenCandle);

      // Draw red candles
      candles.forEach(drawRedCandle);

      // Draw boat
      drawBoat();

      // Draw particles
      drawParticles();
    }

    function gameLoop() {
      update();
      draw();
      requestAnimationFrame(gameLoop);
    }

    function startGame() {
      document.getElementById('startScreen').classList.add('hidden');
      document.getElementById('gameOver').classList.remove('active');

      // Reset game state
      boat.x = 200;
      boat.speed = 0;
      candles = [];
      greenCandles = [];
      particles = [];
      score = 0;
      gameSpeed = 1;
      gameRunning = true;

      document.getElementById('highScore').textContent = `BEST: ${highScore}`;
      playSound('start');
    }

    function gameOver() {
      gameRunning = false;
      createSplash(boat.x, boat.y, '#ff4444');
      playSound('crash');

      // Check high score
      const newHigh = score > highScore;
      if (newHigh) {
        highScore = score;
        localStorage.setItem('candleSailorHigh', highScore);
      }

      setTimeout(() => {
        document.getElementById('finalScore').textContent = score;
        document.getElementById('newHighScore').textContent = newHigh ? 'NEW HIGH SCORE!' : `BEST: ${highScore}`;
        document.getElementById('gameOver').classList.add('active');
      }, 500);
    }

    // Audio
    const audioCtx = new (window.AudioContext || window.webkitAudioContext)();

    function playSound(type) {
      const osc = audioCtx.createOscillator();
      const gain = audioCtx.createGain();
      osc.connect(gain);
      gain.connect(audioCtx.destination);

      if (type === 'collect') {
        osc.frequency.setValueAtTime(600, audioCtx.currentTime);
        osc.frequency.exponentialRampToValueAtTime(900, audioCtx.currentTime + 0.1);
        gain.gain.setValueAtTime(0.1, audioCtx.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.15);
        osc.start();
        osc.stop(audioCtx.currentTime + 0.15);
      } else if (type === 'crash') {
        osc.type = 'sawtooth';
        osc.frequency.setValueAtTime(200, audioCtx.currentTime);
        osc.frequency.exponentialRampToValueAtTime(50, audioCtx.currentTime + 0.3);
        gain.gain.setValueAtTime(0.2, audioCtx.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.3);
        osc.start();
        osc.stop(audioCtx.currentTime + 0.3);
      } else if (type === 'start') {
        osc.frequency.setValueAtTime(300, audioCtx.currentTime);
        osc.frequency.exponentialRampToValueAtTime(500, audioCtx.currentTime + 0.1);
        gain.gain.setValueAtTime(0.08, audioCtx.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.15);
        osc.start();
        osc.stop(audioCtx.currentTime + 0.15);
      }
    }

    // Unlock audio on first interaction
    document.addEventListener('click', () => audioCtx.resume(), { once: true });
    document.addEventListener('touchstart', () => audioCtx.resume(), { once: true });

    // Initialize
    document.getElementById('highScore').textContent = `BEST: ${highScore}`;
    gameLoop();
  </script>
<script src="/sloppy-header/sloppy-bar.js"></script>
<script src="/vibelib-extended.js"></script>
<script>
  // Compatibility Patch for Legacy Apps
  window.addEventListener("load", () => {
    if (window.SloppyKarma && window.VibeLib.Economy) {
      // Redirect old calls to new engine
      window.SloppyKarma.track = window.VibeLib.Economy.track;
    }
  });
</script>
</body>
</html>
