<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Chaos Blocks</title>
    <link rel="icon" href="https://emojicdn.elk.sh/%F0%9F%92%A5">
    <meta property="og:title" content="Chaos Blocks">
    <meta property="og:description" content="Click to spawn explosive neon blocks that bounce, collide, and shatter into pieces">
    <meta property="og:url" content="https://app.sloppy.live/chaos-blocks">
    <meta property="og:image" content="https://emojicdn.elk.sh/%F0%9F%92%A5?style=apple&size=512">
    <link href="https://fonts.googleapis.com/css2?family=Chakra+Petch:wght@400;700&family=Share+Tech+Mono&display=swap" rel="stylesheet">
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            background: #06060c;
            overflow: hidden;
            height: 100vh;
            width: 100vw;
            cursor: crosshair;
            -webkit-tap-highlight-color: transparent;
        }
        canvas { display: block; position: fixed; inset: 0; }

        .hud {
            position: fixed;
            top: 1rem;
            left: 1.2rem;
            z-index: 10;
            pointer-events: none;
        }
        .hud h1 {
            font-family: 'Chakra Petch', sans-serif;
            font-weight: 700;
            font-size: clamp(1.2rem, 3.5vw, 1.8rem);
            color: #ff3355;
            text-shadow: 0 0 20px rgba(255, 51, 85, 0.5);
            letter-spacing: 0.15em;
        }
        .stats {
            font-family: 'Share Tech Mono', monospace;
            font-size: 0.65rem;
            color: #444;
            margin-top: 0.3rem;
            letter-spacing: 0.05em;
        }

        .hint {
            position: fixed;
            bottom: 50%;
            left: 50%;
            transform: translate(-50%, 50%);
            font-family: 'Share Tech Mono', monospace;
            font-size: 0.8rem;
            color: #333;
            z-index: 10;
            pointer-events: none;
            transition: opacity 1s;
        }

        .controls {
            position: fixed;
            bottom: 1rem;
            left: 50%;
            transform: translateX(-50%);
            z-index: 10;
            display: flex;
            gap: 0.4rem;
            opacity: 0.4;
            transition: opacity 0.3s;
        }
        .controls:hover { opacity: 1; }
        .cb {
            background: rgba(255,255,255,0.04);
            border: 1px solid rgba(255,255,255,0.08);
            color: #666;
            font-family: 'Share Tech Mono', monospace;
            font-size: 0.6rem;
            padding: 0.35rem 0.7rem;
            border-radius: 3px;
            cursor: pointer;
            letter-spacing: 0.05em;
            transition: all 0.2s;
        }
        .cb:hover { background: rgba(255,255,255,0.08); color: #ccc; }
        .cb.on { border-color: #ff3355; color: #ff3355; }

        .backlink {
            position: fixed;
            top: 1rem;
            right: 1.2rem;
            color: #333;
            text-decoration: none;
            font-family: 'Share Tech Mono', monospace;
            font-size: 0.6rem;
            z-index: 10;
        }
        .backlink:hover { color: #666; }
    </style>
</head>
<body>
    <canvas id="c"></canvas>

    <div class="hud">
        <h1>CHAOS BLOCKS</h1>
        <div class="stats" id="stats">0 blocks | 0 shards</div>
    </div>

    <div class="hint" id="hint">click anywhere to spawn</div>

    <a href="https://sloppy.live" class="backlink">&larr; sloppy.live</a>

    <div class="controls">
        <button class="cb" onclick="clearAll()">Clear</button>
        <button class="cb on" id="btn-gravity" onclick="toggleGravity()">Gravity</button>
        <button class="cb" id="btn-explosive" onclick="toggleExplosive()">Auto-Explode</button>
        <button class="cb" onclick="spawnRain()">Rain</button>
        <button class="cb" onclick="bigBang()">Big Bang</button>
    </div>

    <script>
    const canvas = document.getElementById('c');
    const ctx = canvas.getContext('2d');

    let W, H;
    function resize() {
        W = canvas.width = window.innerWidth;
        H = canvas.height = window.innerHeight;
    }
    resize();
    window.addEventListener('resize', resize);

    const GRAVITY = 0.35;
    const BOUNCE = 0.7;
    const FRICTION = 0.995;
    const MAX_OBJECTS = 600;

    let gravityOn = true;
    let autoExplode = false;
    let blocks = [];
    let shards = [];
    let sparks = [];
    let screenShake = 0;
    let totalExplosions = 0;

    const NEON_COLORS = [
        '#ff3355', '#ff0088', '#ff6600', '#ffcc00',
        '#00ff88', '#00f5ff', '#3388ff', '#aa44ff',
        '#ff44cc', '#88ff00'
    ];

    function randColor() {
        return NEON_COLORS[Math.floor(Math.random() * NEON_COLORS.length)];
    }

    function hexToRgb(hex) {
        const r = parseInt(hex.slice(1, 3), 16);
        const g = parseInt(hex.slice(3, 5), 16);
        const b = parseInt(hex.slice(5, 7), 16);
        return { r, g, b };
    }

    // --- BLOCK ---
    class Block {
        constructor(x, y, size) {
            this.x = x;
            this.y = y;
            this.size = size || 20 + Math.random() * 40;
            this.vx = (Math.random() - 0.5) * 8;
            this.vy = -3 - Math.random() * 6;
            this.rotation = Math.random() * Math.PI * 2;
            this.rotSpeed = (Math.random() - 0.5) * 0.15;
            this.color = randColor();
            this.hp = Math.ceil(this.size / 15);
            this.age = 0;
            this.flash = 1;
        }

        update() {
            if (gravityOn) this.vy += GRAVITY;
            this.vx *= FRICTION;
            this.vy *= FRICTION;
            this.x += this.vx;
            this.y += this.vy;
            this.rotation += this.rotSpeed;
            this.age++;
            this.flash *= 0.9;

            // Bounce off walls
            const half = this.size / 2;
            if (this.x - half < 0) { this.x = half; this.vx *= -BOUNCE; this.hit(); }
            if (this.x + half > W) { this.x = W - half; this.vx *= -BOUNCE; this.hit(); }
            if (this.y + half > H) { this.y = H - half; this.vy *= -BOUNCE; this.hit(); if (Math.abs(this.vy) < 0.5) this.vy = 0; }
            if (this.y - half < 0) { this.y = half; this.vy *= -BOUNCE; }

            // Auto-explode on high speed impact
            if (autoExplode && this.age > 30) {
                const speed = Math.sqrt(this.vx * this.vx + this.vy * this.vy);
                if (speed > 10) {
                    this.hp = 0;
                }
            }
        }

        hit() {
            this.hp--;
            this.flash = 1;
            const speed = Math.sqrt(this.vx * this.vx + this.vy * this.vy);
            if (speed > 2) {
                for (let i = 0; i < 3; i++) {
                    sparks.push(new Spark(this.x, this.y, this.color));
                }
            }
        }

        draw() {
            ctx.save();
            ctx.translate(this.x, this.y);
            ctx.rotate(this.rotation);

            const half = this.size / 2;

            // Glow
            const rgb = hexToRgb(this.color);
            const glowAlpha = 0.15 + this.flash * 0.3;
            ctx.shadowColor = this.color;
            ctx.shadowBlur = 15 + this.flash * 25;

            // Block body
            ctx.fillStyle = this.color;
            ctx.globalAlpha = 0.8 + this.flash * 0.2;
            ctx.fillRect(-half, -half, this.size, this.size);

            // Inner highlight
            ctx.fillStyle = `rgba(255,255,255,${0.1 + this.flash * 0.3})`;
            ctx.fillRect(-half * 0.6, -half * 0.6, this.size * 0.6, this.size * 0.6);

            // Border
            ctx.strokeStyle = `rgba(255,255,255,${0.3 + this.flash * 0.4})`;
            ctx.lineWidth = 1.5;
            ctx.strokeRect(-half, -half, this.size, this.size);

            ctx.shadowBlur = 0;
            ctx.globalAlpha = 1;
            ctx.restore();
        }

        shatter() {
            const pieces = 3 + Math.floor(this.size / 10);
            const shardSize = this.size / (2 + Math.random());
            screenShake = Math.min(screenShake + 5, 20);
            totalExplosions++;
            playExplosion();

            for (let i = 0; i < pieces; i++) {
                if (shards.length < MAX_OBJECTS) {
                    shards.push(new Shard(
                        this.x + (Math.random() - 0.5) * this.size * 0.5,
                        this.y + (Math.random() - 0.5) * this.size * 0.5,
                        3 + Math.random() * shardSize * 0.4,
                        this.color,
                        this.vx + (Math.random() - 0.5) * 12,
                        this.vy + (Math.random() - 0.5) * 12
                    ));
                }
            }

            // Sparks
            for (let i = 0; i < 12; i++) {
                sparks.push(new Spark(this.x, this.y, this.color));
            }
        }
    }

    // --- SHARD ---
    class Shard {
        constructor(x, y, size, color, vx, vy) {
            this.x = x;
            this.y = y;
            this.size = size;
            this.color = color;
            this.vx = vx;
            this.vy = vy;
            this.rotation = Math.random() * Math.PI * 2;
            this.rotSpeed = (Math.random() - 0.5) * 0.3;
            this.life = 1;
            this.decay = 0.004 + Math.random() * 0.006;
            // Random triangle shape
            this.shape = [];
            for (let i = 0; i < 3; i++) {
                const angle = (Math.PI * 2 / 3) * i + (Math.random() - 0.5) * 0.8;
                const r = this.size * (0.5 + Math.random() * 0.5);
                this.shape.push({ x: Math.cos(angle) * r, y: Math.sin(angle) * r });
            }
        }

        update() {
            if (gravityOn) this.vy += GRAVITY * 0.6;
            this.vx *= 0.99;
            this.vy *= 0.99;
            this.x += this.vx;
            this.y += this.vy;
            this.rotation += this.rotSpeed;
            this.life -= this.decay;

            // Bounce
            if (this.y + this.size > H) {
                this.y = H - this.size;
                this.vy *= -0.5;
                this.vx *= 0.8;
                this.decay *= 1.5;
            }
            if (this.x < -50 || this.x > W + 50) this.life = 0;
        }

        draw() {
            if (this.life <= 0) return;
            ctx.save();
            ctx.translate(this.x, this.y);
            ctx.rotate(this.rotation);
            ctx.globalAlpha = this.life * 0.9;
            ctx.fillStyle = this.color;
            ctx.shadowColor = this.color;
            ctx.shadowBlur = 8 * this.life;

            ctx.beginPath();
            ctx.moveTo(this.shape[0].x, this.shape[0].y);
            for (let i = 1; i < this.shape.length; i++) {
                ctx.lineTo(this.shape[i].x, this.shape[i].y);
            }
            ctx.closePath();
            ctx.fill();

            ctx.shadowBlur = 0;
            ctx.globalAlpha = 1;
            ctx.restore();
        }
    }

    // --- SPARK ---
    class Spark {
        constructor(x, y, color) {
            this.x = x;
            this.y = y;
            this.color = color;
            const angle = Math.random() * Math.PI * 2;
            const speed = 2 + Math.random() * 8;
            this.vx = Math.cos(angle) * speed;
            this.vy = Math.sin(angle) * speed;
            this.life = 1;
            this.decay = 0.02 + Math.random() * 0.04;
            this.size = 1 + Math.random() * 2;
        }

        update() {
            if (gravityOn) this.vy += GRAVITY * 0.3;
            this.x += this.vx;
            this.y += this.vy;
            this.vx *= 0.96;
            this.vy *= 0.96;
            this.life -= this.decay;
        }

        draw() {
            if (this.life <= 0) return;
            ctx.globalAlpha = this.life;
            ctx.fillStyle = this.color;
            ctx.shadowColor = this.color;
            ctx.shadowBlur = 6;
            ctx.beginPath();
            ctx.arc(this.x, this.y, this.size * this.life, 0, Math.PI * 2);
            ctx.fill();
            ctx.shadowBlur = 0;
            ctx.globalAlpha = 1;
        }
    }

    // --- BLOCK-BLOCK COLLISION ---
    function collideBlocks() {
        for (let i = 0; i < blocks.length; i++) {
            for (let j = i + 1; j < blocks.length; j++) {
                const a = blocks[i];
                const b = blocks[j];
                const dx = b.x - a.x;
                const dy = b.y - a.y;
                const dist = Math.sqrt(dx * dx + dy * dy);
                const minDist = (a.size + b.size) * 0.45;

                if (dist < minDist && dist > 0) {
                    // Separate
                    const overlap = minDist - dist;
                    const nx = dx / dist;
                    const ny = dy / dist;
                    a.x -= nx * overlap * 0.5;
                    a.y -= ny * overlap * 0.5;
                    b.x += nx * overlap * 0.5;
                    b.y += ny * overlap * 0.5;

                    // Exchange velocities (simplified elastic)
                    const relVx = a.vx - b.vx;
                    const relVy = a.vy - b.vy;
                    const relDot = relVx * nx + relVy * ny;

                    if (relDot > 0) {
                        const impulse = relDot * 0.8;
                        a.vx -= impulse * nx;
                        a.vy -= impulse * ny;
                        b.vx += impulse * nx;
                        b.vy += impulse * ny;

                        // Damage on hard hit
                        const impactSpeed = Math.abs(relDot);
                        if (impactSpeed > 4) {
                            a.hit();
                            b.hit();
                            screenShake = Math.min(screenShake + impactSpeed * 0.3, 15);
                            for (let s = 0; s < 4; s++) {
                                sparks.push(new Spark((a.x + b.x) / 2, (a.y + b.y) / 2, a.color));
                            }
                        }
                    }
                }
            }
        }
    }

    // --- SPAWN ---
    function spawnBlock(x, y, size) {
        if (blocks.length + shards.length >= MAX_OBJECTS) {
            // Remove oldest shards
            shards.splice(0, 20);
        }
        blocks.push(new Block(x, y, size));
    }

    // --- CONTROLS ---
    window.clearAll = function() {
        blocks = [];
        shards = [];
        sparks = [];
        screenShake = 0;
        totalExplosions = 0;
    };

    window.toggleGravity = function() {
        gravityOn = !gravityOn;
        document.getElementById('btn-gravity').classList.toggle('on', gravityOn);
    };

    window.toggleExplosive = function() {
        autoExplode = !autoExplode;
        document.getElementById('btn-explosive').classList.toggle('on', autoExplode);
    };

    window.spawnRain = function() {
        for (let i = 0; i < 15; i++) {
            setTimeout(() => {
                spawnBlock(
                    50 + Math.random() * (W - 100),
                    -30 - Math.random() * 200,
                    15 + Math.random() * 30
                );
            }, i * 80);
        }
    };

    window.bigBang = function() {
        const cx = W / 2;
        const cy = H / 2;
        screenShake = 20;
        playExplosion();
        for (let i = 0; i < 25; i++) {
            const angle = (Math.PI * 2 / 25) * i;
            const dist = 30 + Math.random() * 50;
            const b = new Block(cx + Math.cos(angle) * 10, cy + Math.sin(angle) * 10, 12 + Math.random() * 25);
            b.vx = Math.cos(angle) * (8 + Math.random() * 8);
            b.vy = Math.sin(angle) * (8 + Math.random() * 8);
            blocks.push(b);
        }
        for (let i = 0; i < 40; i++) {
            sparks.push(new Spark(cx, cy, randColor()));
        }
    };

    // --- INPUT ---
    let hintShown = true;
    function handleClick(x, y) {
        if (hintShown) {
            document.getElementById('hint').style.opacity = '0';
            hintShown = false;
        }

        // Check if clicking on existing block to manually shatter it
        for (let i = blocks.length - 1; i >= 0; i--) {
            const b = blocks[i];
            const dx = x - b.x;
            const dy = y - b.y;
            if (Math.abs(dx) < b.size / 2 && Math.abs(dy) < b.size / 2) {
                b.shatter();
                blocks.splice(i, 1);
                return;
            }
        }

        // Otherwise spawn
        spawnBlock(x, y);
        screenShake = Math.min(screenShake + 2, 8);
    }

    canvas.addEventListener('click', e => handleClick(e.clientX, e.clientY));
    canvas.addEventListener('touchstart', e => {
        e.preventDefault();
        for (let i = 0; i < e.touches.length; i++) {
            handleClick(e.touches[i].clientX, e.touches[i].clientY);
        }
    }, { passive: false });

    // Hold to rapid-fire
    let holdInterval = null;
    let holdPos = { x: 0, y: 0 };

    canvas.addEventListener('mousedown', e => {
        holdPos.x = e.clientX;
        holdPos.y = e.clientY;
        holdInterval = setInterval(() => {
            spawnBlock(holdPos.x + (Math.random() - 0.5) * 40, holdPos.y + (Math.random() - 0.5) * 40, 10 + Math.random() * 20);
        }, 100);
    });
    canvas.addEventListener('mousemove', e => {
        holdPos.x = e.clientX;
        holdPos.y = e.clientY;
    });
    canvas.addEventListener('mouseup', () => { clearInterval(holdInterval); holdInterval = null; });
    canvas.addEventListener('mouseleave', () => { clearInterval(holdInterval); holdInterval = null; });

    // --- AUDIO ---
    let audioCtx = null;
    function getAudio() {
        if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        if (audioCtx.state === 'suspended') audioCtx.resume();
        return audioCtx;
    }

    function playExplosion() {
        try {
            const ctx = getAudio();
            const osc = ctx.createOscillator();
            const gain = ctx.createGain();
            osc.connect(gain);
            gain.connect(ctx.destination);
            osc.type = 'sawtooth';
            osc.frequency.setValueAtTime(200, ctx.currentTime);
            osc.frequency.exponentialRampToValueAtTime(40, ctx.currentTime + 0.15);
            gain.gain.setValueAtTime(0.08, ctx.currentTime);
            gain.gain.exponentialRampToValueAtTime(0.001, ctx.currentTime + 0.2);
            osc.start();
            osc.stop(ctx.currentTime + 0.2);
        } catch (e) {}
    }

    // --- RENDER ---
    let frame = 0;
    function loop() {
        requestAnimationFrame(loop);
        frame++;

        // Screen shake
        ctx.save();
        if (screenShake > 0.5) {
            ctx.translate(
                (Math.random() - 0.5) * screenShake,
                (Math.random() - 0.5) * screenShake
            );
            screenShake *= 0.9;
        }

        // Clear
        ctx.fillStyle = '#06060c';
        ctx.fillRect(-10, -10, W + 20, H + 20);

        // Floor glow
        const floorGrad = ctx.createLinearGradient(0, H - 40, 0, H);
        floorGrad.addColorStop(0, 'transparent');
        floorGrad.addColorStop(1, 'rgba(255, 51, 85, 0.03)');
        ctx.fillStyle = floorGrad;
        ctx.fillRect(0, H - 40, W, 40);

        // Collisions
        if (blocks.length < 80) collideBlocks();

        // Update & draw blocks
        for (let i = blocks.length - 1; i >= 0; i--) {
            blocks[i].update();
            if (blocks[i].hp <= 0) {
                blocks[i].shatter();
                blocks.splice(i, 1);
            } else {
                blocks[i].draw();
            }
        }

        // Update & draw shards
        for (let i = shards.length - 1; i >= 0; i--) {
            shards[i].update();
            if (shards[i].life <= 0) {
                shards.splice(i, 1);
            } else {
                shards[i].draw();
            }
        }

        // Update & draw sparks
        for (let i = sparks.length - 1; i >= 0; i--) {
            sparks[i].update();
            if (sparks[i].life <= 0) {
                sparks.splice(i, 1);
            } else {
                sparks[i].draw();
            }
        }

        ctx.restore();

        // Stats
        if (frame % 15 === 0) {
            document.getElementById('stats').textContent =
                blocks.length + ' blocks | ' + shards.length + ' shards | ' + sparks.length + ' sparks | ' + totalExplosions + ' explosions';
        }
    }

    loop();
    </script>
</body>
</html>