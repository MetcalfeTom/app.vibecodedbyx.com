<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
  <title>Neon Dream Visualizer</title>
  <link rel="icon" href="https://emojicdn.elk.sh/☁️">
  <meta property="og:title" content="Neon Dream Visualizer">
  <meta property="og:description" content="Float through 8-bit neon clouds with your cursor">
  <meta property="og:url" content="https://app.sloppy.live/neon-dream-visualizer">
  <meta property="og:image" content="https://emojicdn.elk.sh/☁️?style=apple&size=512">
  <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    
    body {
      background: #0a0a18;
      overflow: hidden;
      cursor: crosshair;
    }

    canvas {
      display: block;
    }

    .title {
      position: fixed;
      top: 20px;
      left: 50%;
      transform: translateX(-50%);
      font-family: 'Press Start 2P', cursive;
      font-size: 14px;
      color: #f0f;
      text-shadow: 0 0 10px #f0f, 0 0 20px #f0f, 0 0 40px #f0f;
      z-index: 100;
      pointer-events: none;
      opacity: 0.8;
    }

    .hint {
      position: fixed;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      font-family: 'Press Start 2P', cursive;
      font-size: 8px;
      color: #0ff;
      text-shadow: 0 0 10px #0ff;
      z-index: 100;
      pointer-events: none;
      opacity: 0.6;
    }

    .stats {
      position: fixed;
      top: 20px;
      right: 20px;
      font-family: 'Press Start 2P', cursive;
      font-size: 8px;
      color: #0f0;
      text-shadow: 0 0 10px #0f0;
      text-align: right;
      z-index: 100;
      pointer-events: none;
    }

    .backlink {
      position: fixed;
      bottom: 20px;
      left: 20px;
      font-family: 'Press Start 2P', cursive;
      font-size: 6px;
      color: rgba(255,255,255,0.3);
      text-decoration: none;
      z-index: 100;
    }
  </style>
</head>
<body>
  <div class="title">NEON DREAM</div>
  <div class="hint">MOVE MOUSE TO GENERATE CLOUDS</div>
  <div class="stats">
    <div>CLOUDS: <span id="cloud-count">0</span></div>
    <div>PIXELS: <span id="pixel-count">0</span></div>
  </div>
  
  <canvas id="canvas"></canvas>
  
  <a href="https://sloppy.live" class="backlink">SLOPPY.LIVE</a>

  <script>
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');

    let width, height;
    function resize() {
      width = canvas.width = window.innerWidth;
      height = canvas.height = window.innerHeight;
    }
    resize();
    window.addEventListener('resize', resize);

    // Neon colors
    const NEON_COLORS = [
      '#ff00ff', '#00ffff', '#ff0080', '#80ff00',
      '#00ff80', '#8000ff', '#ff8000', '#0080ff',
      '#ff0040', '#40ff00', '#00ff40', '#ff4000'
    ];

    // 8-bit cloud patterns (pixel art)
    const CLOUD_PATTERNS = [
      // Small fluffy
      [
        '  ████  ',
        ' ██████ ',
        '████████',
        ' ██████ '
      ],
      // Medium puffy
      [
        '   ████   ',
        '  ██████  ',
        ' ████████ ',
        '██████████',
        ' ████████ ',
        '  ██████  '
      ],
      // Large cumulus
      [
        '    ████    ',
        '  ████████  ',
        ' ██████████ ',
        '████████████',
        '████████████',
        ' ██████████ ',
        '  ████████  '
      ],
      // Wispy
      [
        '██  ██  ██',
        ' ████████ ',
        '  ██████  '
      ],
      // Chunky
      [
        '████  ████',
        '██████████',
        '██████████',
        '  ██████  '
      ],
      // Tiny
      [
        ' ██ ',
        '████',
        ' ██ '
      ],
      // Long
      [
        '  ██    ██  ',
        ' ████  ████ ',
        '████████████',
        ' ██████████ '
      ]
    ];

    // Cloud class
    class Cloud {
      constructor(x, y, speed) {
        this.x = x;
        this.y = y;
        this.vx = (Math.random() - 0.5) * 2 + speed.x * 0.3;
        this.vy = (Math.random() - 0.5) * 2 + speed.y * 0.3 - 0.5;
        this.pattern = CLOUD_PATTERNS[Math.floor(Math.random() * CLOUD_PATTERNS.length)];
        this.color = NEON_COLORS[Math.floor(Math.random() * NEON_COLORS.length)];
        this.pixelSize = Math.floor(Math.random() * 4) + 3;
        this.alpha = 1;
        this.rotation = (Math.random() - 0.5) * 0.3;
        this.rotationSpeed = (Math.random() - 0.5) * 0.02;
        this.pulsePhase = Math.random() * Math.PI * 2;
        this.pulseSpeed = Math.random() * 2 + 1;
        this.life = 1;
        this.decay = 0.001 + Math.random() * 0.002;
      }

      update(dt) {
        this.x += this.vx;
        this.y += this.vy;
        this.vy -= 0.02; // Float upward
        this.vx *= 0.995; // Drag
        this.vy *= 0.995;
        this.rotation += this.rotationSpeed;
        this.pulsePhase += this.pulseSpeed * dt;
        this.life -= this.decay;
        this.alpha = this.life;
      }

      draw() {
        if (this.alpha <= 0) return;

        ctx.save();
        ctx.translate(this.x, this.y);
        ctx.rotate(this.rotation);
        ctx.globalAlpha = this.alpha;

        const pulse = 1 + Math.sin(this.pulsePhase) * 0.1;
        const size = this.pixelSize * pulse;

        // Glow effect
        ctx.shadowColor = this.color;
        ctx.shadowBlur = 15 + Math.sin(this.pulsePhase) * 5;

        ctx.fillStyle = this.color;

        const patternHeight = this.pattern.length;
        const patternWidth = this.pattern[0].length;
        const offsetX = -patternWidth * size / 2;
        const offsetY = -patternHeight * size / 2;

        for (let row = 0; row < patternHeight; row++) {
          for (let col = 0; col < patternWidth; col++) {
            if (this.pattern[row][col] === '█') {
              ctx.fillRect(
                offsetX + col * size,
                offsetY + row * size,
                size - 1,
                size - 1
              );
            }
          }
        }

        ctx.restore();
      }

      get pixelCount() {
        let count = 0;
        this.pattern.forEach(row => {
          for (let c of row) if (c === '█') count++;
        });
        return count;
      }
    }

    // Stars in background
    class Star {
      constructor() {
        this.reset();
        this.y = Math.random() * height;
      }

      reset() {
        this.x = Math.random() * width;
        this.y = height + 10;
        this.size = Math.random() * 2 + 1;
        this.speed = Math.random() * 0.5 + 0.2;
        this.twinkle = Math.random() * Math.PI * 2;
        this.color = NEON_COLORS[Math.floor(Math.random() * NEON_COLORS.length)];
      }

      update() {
        this.y -= this.speed;
        this.twinkle += 0.1;
        if (this.y < -10) this.reset();
      }

      draw() {
        const alpha = 0.3 + Math.sin(this.twinkle) * 0.2;
        ctx.globalAlpha = alpha;
        ctx.fillStyle = this.color;
        ctx.shadowColor = this.color;
        ctx.shadowBlur = 5;
        ctx.fillRect(this.x, this.y, this.size, this.size);
        ctx.globalAlpha = 1;
        ctx.shadowBlur = 0;
      }
    }

    // Particle trail
    class Particle {
      constructor(x, y) {
        this.x = x;
        this.y = y;
        this.size = Math.random() * 3 + 2;
        this.color = NEON_COLORS[Math.floor(Math.random() * NEON_COLORS.length)];
        this.life = 1;
        this.decay = 0.02 + Math.random() * 0.03;
        this.vx = (Math.random() - 0.5) * 2;
        this.vy = (Math.random() - 0.5) * 2;
      }

      update() {
        this.x += this.vx;
        this.y += this.vy;
        this.life -= this.decay;
      }

      draw() {
        if (this.life <= 0) return;
        ctx.globalAlpha = this.life;
        ctx.fillStyle = this.color;
        ctx.shadowColor = this.color;
        ctx.shadowBlur = 8;
        ctx.fillRect(this.x, this.y, this.size, this.size);
        ctx.globalAlpha = 1;
        ctx.shadowBlur = 0;
      }
    }

    // Game state
    let clouds = [];
    let stars = [];
    let particles = [];
    let mouseX = width / 2;
    let mouseY = height / 2;
    let lastMouseX = mouseX;
    let lastMouseY = mouseY;
    let lastCloudTime = 0;
    let totalPixels = 0;

    // Initialize stars
    for (let i = 0; i < 100; i++) {
      stars.push(new Star());
    }

    // Mouse/touch tracking
    function handleMove(x, y) {
      lastMouseX = mouseX;
      lastMouseY = mouseY;
      mouseX = x;
      mouseY = y;

      // Spawn particles along path
      const dx = mouseX - lastMouseX;
      const dy = mouseY - lastMouseY;
      const dist = Math.sqrt(dx * dx + dy * dy);
      
      if (dist > 5) {
        for (let i = 0; i < Math.min(dist / 10, 5); i++) {
          particles.push(new Particle(
            lastMouseX + dx * (i / 5) + (Math.random() - 0.5) * 10,
            lastMouseY + dy * (i / 5) + (Math.random() - 0.5) * 10
          ));
        }
      }

      // Spawn cloud based on movement speed
      const now = Date.now();
      const speed = { x: dx, y: dy };
      const spawnRate = Math.max(50, 200 - dist * 2);

      if (now - lastCloudTime > spawnRate && dist > 3) {
        clouds.push(new Cloud(mouseX, mouseY, speed));
        lastCloudTime = now;
      }
    }

    canvas.addEventListener('mousemove', e => handleMove(e.clientX, e.clientY));
    canvas.addEventListener('touchmove', e => {
      e.preventDefault();
      handleMove(e.touches[0].clientX, e.touches[0].clientY);
    });

    // Click to spawn big cloud
    canvas.addEventListener('click', e => {
      for (let i = 0; i < 5; i++) {
        const offsetX = (Math.random() - 0.5) * 100;
        const offsetY = (Math.random() - 0.5) * 100;
        clouds.push(new Cloud(e.clientX + offsetX, e.clientY + offsetY, { x: 0, y: -2 }));
      }
    });

    // Animation loop
    let lastTime = 0;
    function animate(timestamp) {
      const dt = (timestamp - lastTime) / 1000;
      lastTime = timestamp;

      // Clear with fade effect
      ctx.fillStyle = 'rgba(10, 10, 24, 0.1)';
      ctx.fillRect(0, 0, width, height);

      // Update and draw stars
      stars.forEach(star => {
        star.update();
        star.draw();
      });

      // Update and draw particles
      particles = particles.filter(p => p.life > 0);
      particles.forEach(p => {
        p.update();
        p.draw();
      });

      // Update and draw clouds
      clouds = clouds.filter(c => c.life > 0);
      totalPixels = 0;
      clouds.forEach(cloud => {
        cloud.update(dt);
        cloud.draw();
        totalPixels += cloud.pixelCount;
      });

      // Update stats
      document.getElementById('cloud-count').textContent = clouds.length;
      document.getElementById('pixel-count').textContent = totalPixels;

      // Draw cursor glow
      ctx.beginPath();
      ctx.arc(mouseX, mouseY, 5, 0, Math.PI * 2);
      ctx.fillStyle = '#fff';
      ctx.shadowColor = '#fff';
      ctx.shadowBlur = 20;
      ctx.fill();
      ctx.shadowBlur = 0;

      requestAnimationFrame(animate);
    }

    animate(0);

    // Auto-spawn ambient clouds
    setInterval(() => {
      if (clouds.length < 20) {
        const x = Math.random() * width;
        const y = height + 50;
        clouds.push(new Cloud(x, y, { x: 0, y: -1 }));
      }
    }, 2000);
  </script>
<script src="/sloppy-header/sloppy-bar.js"></script>
<script src="/vibelib-extended.js"></script>
<script>
  // Compatibility Patch for Legacy Apps
  window.addEventListener("load", () => {
    if (window.SloppyKarma && window.VibeLib.Economy) {
      // Redirect old calls to new engine
      window.SloppyKarma.track = window.VibeLib.Economy.track;
    }
  });
</script>
</body>
</html>
