<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Quaternion Orbit Visualizer</title>
  <link rel="icon" href="https://emojicdn.elk.sh/üåÄ">
  <meta property="og:title" content="Quaternion Orbit Visualizer">
  <meta property="og:description" content="3D quaternion rotations with neon orbital trails">
  <meta property="og:url" content="https://app.sloppy.live/quaternion-orbits">
  <meta property="og:image" content="https://emojicdn.elk.sh/üåÄ?style=apple&size=512">
  <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700&family=JetBrains+Mono&display=swap" rel="stylesheet">
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }

    body {
      font-family: 'JetBrains Mono', monospace;
      background: #000;
      color: #fff;
      overflow: hidden;
    }

    #canvas-container {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
    }

    .ui-panel {
      position: fixed;
      top: 20px;
      left: 20px;
      background: rgba(0, 0, 0, 0.8);
      border: 1px solid rgba(0, 255, 255, 0.3);
      border-radius: 12px;
      padding: 20px;
      min-width: 280px;
      backdrop-filter: blur(10px);
      z-index: 100;
    }

    .title {
      font-family: 'Orbitron', sans-serif;
      font-size: 1.1rem;
      color: #0ff;
      text-shadow: 0 0 10px #0ff;
      margin-bottom: 15px;
      display: flex;
      align-items: center;
      gap: 10px;
    }

    .quaternion-display {
      background: rgba(0, 255, 255, 0.1);
      border-radius: 8px;
      padding: 12px;
      margin-bottom: 15px;
      font-size: 0.8rem;
    }

    .quat-label {
      color: #888;
      font-size: 0.7rem;
      margin-bottom: 5px;
    }

    .quat-values {
      display: grid;
      grid-template-columns: repeat(4, 1fr);
      gap: 8px;
    }

    .quat-component {
      text-align: center;
    }

    .quat-component .label {
      color: #0ff;
      font-size: 0.7rem;
    }

    .quat-component .value {
      font-family: 'Orbitron', sans-serif;
      font-size: 0.9rem;
      color: #fff;
    }

    .control-group {
      margin-bottom: 15px;
    }

    .control-label {
      display: flex;
      justify-content: space-between;
      font-size: 0.75rem;
      color: #888;
      margin-bottom: 5px;
    }

    .control-value {
      color: #0ff;
    }

    .slider {
      width: 100%;
      -webkit-appearance: none;
      height: 4px;
      background: #333;
      border-radius: 2px;
      outline: none;
    }

    .slider::-webkit-slider-thumb {
      -webkit-appearance: none;
      width: 16px;
      height: 16px;
      background: #0ff;
      border-radius: 50%;
      cursor: pointer;
      box-shadow: 0 0 10px #0ff;
    }

    .axis-controls {
      display: grid;
      grid-template-columns: repeat(3, 1fr);
      gap: 8px;
      margin-bottom: 15px;
    }

    .axis-btn {
      background: rgba(255, 255, 255, 0.1);
      border: 1px solid rgba(255, 255, 255, 0.2);
      border-radius: 6px;
      padding: 8px;
      color: #fff;
      font-family: inherit;
      font-size: 0.75rem;
      cursor: pointer;
      transition: all 0.2s;
    }

    .axis-btn:hover {
      background: rgba(0, 255, 255, 0.2);
      border-color: #0ff;
    }

    .axis-btn.active {
      background: rgba(0, 255, 255, 0.3);
      border-color: #0ff;
      box-shadow: 0 0 10px rgba(0, 255, 255, 0.3);
    }

    .axis-btn.x { color: #ff4444; }
    .axis-btn.y { color: #44ff44; }
    .axis-btn.z { color: #4444ff; }

    .preset-buttons {
      display: grid;
      grid-template-columns: repeat(2, 1fr);
      gap: 8px;
    }

    .preset-btn {
      background: linear-gradient(135deg, rgba(0, 255, 255, 0.2), rgba(255, 0, 255, 0.2));
      border: 1px solid rgba(255, 255, 255, 0.2);
      border-radius: 6px;
      padding: 10px;
      color: #fff;
      font-family: 'Orbitron', sans-serif;
      font-size: 0.7rem;
      cursor: pointer;
      transition: all 0.2s;
    }

    .preset-btn:hover {
      transform: scale(1.05);
      box-shadow: 0 0 15px rgba(0, 255, 255, 0.3);
    }

    .stats {
      position: fixed;
      bottom: 20px;
      left: 20px;
      font-size: 0.7rem;
      color: #666;
    }

    .back-link {
      position: fixed;
      top: 20px;
      right: 20px;
      color: #444;
      text-decoration: none;
      font-size: 0.75rem;
      z-index: 100;
    }

    .back-link:hover { color: #0ff; }

    .formula {
      background: rgba(255, 0, 255, 0.1);
      border-radius: 8px;
      padding: 10px;
      margin-top: 15px;
      font-size: 0.7rem;
      color: #f0f;
      text-align: center;
    }

    /* Ternary state indicator */
    .ternary-indicator {
      background: rgba(255, 0, 0, 0.2);
      border: 1px solid rgba(255, 0, 0, 0.5);
      border-radius: 8px;
      padding: 8px;
      margin-top: 10px;
      font-size: 0.7rem;
      text-align: center;
      display: none;
    }

    .ternary-indicator.active {
      display: block;
      animation: ternary-pulse 0.2s ease-in-out infinite alternate;
    }

    .ternary-indicator .state {
      color: #ff0;
      font-family: 'Orbitron', sans-serif;
      font-weight: bold;
    }

    @keyframes ternary-pulse {
      0% { background: rgba(255, 0, 0, 0.2); border-color: rgba(255, 0, 0, 0.5); }
      100% { background: rgba(255, 255, 0, 0.3); border-color: rgba(255, 255, 0, 0.7); }
    }

    /* Glitch overlay */
    .glitch-overlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
      z-index: 50;
      opacity: 0;
      transition: opacity 0.1s;
    }

    .glitch-overlay.active {
      opacity: 1;
    }

    .glitch-line {
      position: absolute;
      left: 0;
      width: 100%;
      height: 2px;
      background: rgba(255, 0, 255, 0.8);
      box-shadow: 0 0 10px #f0f, 0 0 20px #0ff;
    }

    .glitch-block {
      position: absolute;
      background: rgba(0, 255, 255, 0.1);
      border: 1px solid rgba(255, 0, 255, 0.3);
    }

    /* Screen shake */
    @keyframes shake {
      0%, 100% { transform: translate(0, 0); }
      10% { transform: translate(-5px, -3px); }
      20% { transform: translate(5px, 3px); }
      30% { transform: translate(-3px, 5px); }
      40% { transform: translate(3px, -5px); }
      50% { transform: translate(-5px, 3px); }
      60% { transform: translate(5px, -3px); }
      70% { transform: translate(-3px, -5px); }
      80% { transform: translate(3px, 5px); }
      90% { transform: translate(-5px, -3px); }
    }

    #canvas-container.glitching {
      animation: shake 0.15s ease-in-out;
    }

    /* Chromatic aberration effect */
    #canvas-container.glitching canvas {
      filter: url(#chromatic);
    }

    @media (max-width: 600px) {
      .ui-panel {
        top: 10px;
        left: 10px;
        right: 10px;
        min-width: auto;
      }
    }
  </style>
</head>
<body>
  <div id="canvas-container"></div>

  <div class="ui-panel">
    <div class="title">üåÄ QUATERNION ORBITS</div>

    <div class="quaternion-display">
      <div class="quat-label">Current Quaternion q = w + xi + yj + zk</div>
      <div class="quat-values">
        <div class="quat-component">
          <div class="label">w</div>
          <div class="value" id="q-w">1.00</div>
        </div>
        <div class="quat-component">
          <div class="label">x</div>
          <div class="value" id="q-x">0.00</div>
        </div>
        <div class="quat-component">
          <div class="label">y</div>
          <div class="value" id="q-y">0.00</div>
        </div>
        <div class="quat-component">
          <div class="label">z</div>
          <div class="value" id="q-z">0.00</div>
        </div>
      </div>
    </div>

    <div class="control-group">
      <div class="control-label">
        <span>Rotation Speed</span>
        <span class="control-value" id="speed-val">1.0x</span>
      </div>
      <input type="range" class="slider" id="speed" min="0.1" max="3" step="0.1" value="1">
    </div>

    <div class="control-group">
      <div class="control-label">
        <span>Trail Length</span>
        <span class="control-value" id="trail-val">200</span>
      </div>
      <input type="range" class="slider" id="trail" min="50" max="500" step="10" value="200">
    </div>

    <div class="control-group">
      <div class="control-label">
        <span>Orbit Count</span>
        <span class="control-value" id="orbit-val">3</span>
      </div>
      <input type="range" class="slider" id="orbits" min="1" max="8" step="1" value="3">
    </div>

    <div class="control-label"><span>Rotation Axes</span></div>
    <div class="axis-controls">
      <button class="axis-btn x active" data-axis="x">X Axis</button>
      <button class="axis-btn y active" data-axis="y">Y Axis</button>
      <button class="axis-btn z" data-axis="z">Z Axis</button>
    </div>

    <div class="control-label"><span>Presets</span></div>
    <div class="preset-buttons">
      <button class="preset-btn" onclick="setPreset('gimbal')">Gimbal Lock</button>
      <button class="preset-btn" onclick="setPreset('slerp')">SLERP Demo</button>
      <button class="preset-btn" onclick="setPreset('chaos')">Chaotic</button>
      <button class="preset-btn" onclick="setPreset('sync')">Synchronized</button>
    </div>

    <div class="formula">
      q' = q‚ÇÅ √ó q‚ÇÇ (Hamilton Product)
    </div>

    <div class="ternary-indicator" id="ternary-indicator">
      ‚ö†Ô∏è TERNARY STATE: <span class="state" id="ternary-state">UNKNOWN</span>
    </div>
  </div>

  <!-- Glitch overlay -->
  <div class="glitch-overlay" id="glitch-overlay"></div>

  <!-- SVG filter for chromatic aberration -->
  <svg style="position:absolute;width:0;height:0;">
    <defs>
      <filter id="chromatic">
        <feColorMatrix type="matrix" values="1 0 0 0 0  0 0 0 0 0  0 0 0 0 0  0 0 0 1 0" result="red"/>
        <feOffset in="red" dx="3" dy="0" result="red-shifted"/>
        <feColorMatrix type="matrix" values="0 0 0 0 0  0 1 0 0 0  0 0 0 0 0  0 0 0 1 0" result="green"/>
        <feColorMatrix type="matrix" values="0 0 0 0 0  0 0 0 0 0  0 0 1 0 0  0 0 0 1 0" result="blue"/>
        <feOffset in="blue" dx="-3" dy="0" result="blue-shifted"/>
        <feBlend mode="screen" in="red-shifted" in2="green"/>
        <feBlend mode="screen" in2="blue-shifted"/>
      </filter>
    </defs>
  </svg>

  <div class="stats">
    <div>FPS: <span id="fps">60</span></div>
    <div>Drag to rotate camera</div>
  </div>

  <a href="https://sloppy.live" class="back-link">‚Üê sloppy.live</a>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script>
    // Scene setup
    const container = document.getElementById('canvas-container');
    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.set(0, 5, 12);
    camera.lookAt(0, 0, 0);

    const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    container.appendChild(renderer.domElement);

    // Colors for orbits
    const orbitColors = [
      0x00ffff, // cyan
      0xff00ff, // magenta
      0xffff00, // yellow
      0x00ff88, // green
      0xff8800, // orange
      0x8800ff, // purple
      0xff0088, // pink
      0x0088ff  // blue
    ];

    // Orbit class
    class QuaternionOrbit {
      constructor(index, total) {
        this.index = index;
        this.color = orbitColors[index % orbitColors.length];

        // Create orbiting sphere
        const geometry = new THREE.SphereGeometry(0.15, 16, 16);
        const material = new THREE.MeshBasicMaterial({
          color: this.color,
          transparent: true,
          opacity: 1
        });
        this.mesh = new THREE.Mesh(geometry, material);

        // Add glow
        const glowGeometry = new THREE.SphereGeometry(0.25, 16, 16);
        const glowMaterial = new THREE.MeshBasicMaterial({
          color: this.color,
          transparent: true,
          opacity: 0.3
        });
        this.glow = new THREE.Mesh(glowGeometry, glowMaterial);
        this.mesh.add(this.glow);

        scene.add(this.mesh);

        // Trail with vertex colors for w-based opacity
        this.trailLength = 200;
        this.trailPositions = [];
        this.trailWValues = []; // Store w component for each position
        this.trailGeometry = new THREE.BufferGeometry();

        // Use shader material for per-vertex opacity based on w
        this.trailMaterial = new THREE.ShaderMaterial({
          uniforms: {
            color: { value: new THREE.Color(this.color) }
          },
          vertexShader: `
            attribute float wValue;
            varying float vOpacity;
            void main() {
              vOpacity = abs(wValue) * 0.8 + 0.2;
              gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
            }
          `,
          fragmentShader: `
            uniform vec3 color;
            varying float vOpacity;
            void main() {
              gl_FragColor = vec4(color, vOpacity);
            }
          `,
          transparent: true,
          blending: THREE.AdditiveBlending
        });

        this.trail = new THREE.Line(this.trailGeometry, this.trailMaterial);
        scene.add(this.trail);

        // Initial quaternion and position
        this.quaternion = new THREE.Quaternion();
        this.radius = 3 + index * 0.5;
        this.baseAngle = (index / total) * Math.PI * 2;
        this.phase = index * 0.5;

        // Rotation rates
        this.rotX = 0.01;
        this.rotY = 0.015;
        this.rotZ = 0;
      }

      update(time, speed, axes) {
        // Create rotation quaternions for each axis
        const qx = new THREE.Quaternion();
        const qy = new THREE.Quaternion();
        const qz = new THREE.Quaternion();

        if (axes.x) qx.setFromAxisAngle(new THREE.Vector3(1, 0, 0), time * this.rotX * speed + this.phase);
        if (axes.y) qy.setFromAxisAngle(new THREE.Vector3(0, 1, 0), time * this.rotY * speed + this.phase);
        if (axes.z) qz.setFromAxisAngle(new THREE.Vector3(0, 0, 1), time * this.rotZ * speed + this.phase);

        // Combine quaternions (Hamilton product)
        this.quaternion.copy(qx).multiply(qy).multiply(qz);

        // Calculate position using quaternion
        const basePos = new THREE.Vector3(this.radius, 0, 0);
        basePos.applyQuaternion(this.quaternion);

        // Add secondary rotation for orbit
        const orbitAngle = time * 0.5 * speed + this.baseAngle;
        const orbitQuat = new THREE.Quaternion().setFromAxisAngle(
          new THREE.Vector3(0, 1, 0),
          orbitAngle
        );
        basePos.applyQuaternion(orbitQuat);

        this.mesh.position.copy(basePos);

        // Update trail with w values
        this.trailPositions.push(basePos.clone());
        this.trailWValues.push(this.quaternion.w);

        if (this.trailPositions.length > this.trailLength) {
          this.trailPositions.shift();
          this.trailWValues.shift();
        }

        // Update trail geometry with positions and w values
        const positions = new Float32Array(this.trailPositions.length * 3);
        const wValues = new Float32Array(this.trailPositions.length);

        this.trailPositions.forEach((pos, i) => {
          positions[i * 3] = pos.x;
          positions[i * 3 + 1] = pos.y;
          positions[i * 3 + 2] = pos.z;
          wValues[i] = this.trailWValues[i];
        });

        this.trailGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
        this.trailGeometry.setAttribute('wValue', new THREE.BufferAttribute(wValues, 1));

        // Update sphere opacity based on w
        const wOpacity = Math.abs(this.quaternion.w) * 0.7 + 0.3;
        this.mesh.material.opacity = wOpacity;
        this.glow.material.opacity = wOpacity * 0.4;

        return this.quaternion;
      }

      setTrailLength(length) {
        this.trailLength = length;
        while (this.trailPositions.length > length) {
          this.trailPositions.shift();
          this.trailWValues.shift();
        }
      }

      setRotation(x, y, z) {
        this.rotX = x;
        this.rotY = y;
        this.rotZ = z;
      }

      dispose() {
        scene.remove(this.mesh);
        scene.remove(this.trail);
        this.trailGeometry.dispose();
        this.trailMaterial.dispose();
      }
    }

    // Central reference axes
    const axesGroup = new THREE.Group();

    // X axis (red)
    const xLine = new THREE.Line(
      new THREE.BufferGeometry().setFromPoints([
        new THREE.Vector3(-6, 0, 0),
        new THREE.Vector3(6, 0, 0)
      ]),
      new THREE.LineBasicMaterial({ color: 0xff4444, opacity: 0.5, transparent: true })
    );
    axesGroup.add(xLine);

    // Y axis (green)
    const yLine = new THREE.Line(
      new THREE.BufferGeometry().setFromPoints([
        new THREE.Vector3(0, -6, 0),
        new THREE.Vector3(0, 6, 0)
      ]),
      new THREE.LineBasicMaterial({ color: 0x44ff44, opacity: 0.5, transparent: true })
    );
    axesGroup.add(yLine);

    // Z axis (blue)
    const zLine = new THREE.Line(
      new THREE.BufferGeometry().setFromPoints([
        new THREE.Vector3(0, 0, -6),
        new THREE.Vector3(0, 0, 6)
      ]),
      new THREE.LineBasicMaterial({ color: 0x4444ff, opacity: 0.5, transparent: true })
    );
    axesGroup.add(zLine);

    scene.add(axesGroup);

    // Central sphere
    const centerGeom = new THREE.SphereGeometry(0.3, 32, 32);
    const centerMat = new THREE.MeshBasicMaterial({
      color: 0xffffff,
      transparent: true,
      opacity: 0.8
    });
    const centerSphere = new THREE.Mesh(centerGeom, centerMat);
    scene.add(centerSphere);

    // Grid
    const gridHelper = new THREE.GridHelper(12, 12, 0x333333, 0x222222);
    gridHelper.position.y = -4;
    scene.add(gridHelper);

    // Orbits
    let orbits = [];
    let orbitCount = 3;

    function createOrbits(count) {
      orbits.forEach(o => o.dispose());
      orbits = [];
      for (let i = 0; i < count; i++) {
        orbits.push(new QuaternionOrbit(i, count));
      }
    }
    createOrbits(orbitCount);

    // Controls
    let speed = 1;
    let trailLength = 200;
    let axes = { x: true, y: true, z: false };

    document.getElementById('speed').addEventListener('input', (e) => {
      speed = parseFloat(e.target.value);
      document.getElementById('speed-val').textContent = speed.toFixed(1) + 'x';
    });

    document.getElementById('trail').addEventListener('input', (e) => {
      trailLength = parseInt(e.target.value);
      document.getElementById('trail-val').textContent = trailLength;
      orbits.forEach(o => o.setTrailLength(trailLength));
    });

    document.getElementById('orbits').addEventListener('input', (e) => {
      orbitCount = parseInt(e.target.value);
      document.getElementById('orbit-val').textContent = orbitCount;
      createOrbits(orbitCount);
    });

    document.querySelectorAll('.axis-btn').forEach(btn => {
      btn.addEventListener('click', () => {
        const axis = btn.dataset.axis;
        axes[axis] = !axes[axis];
        btn.classList.toggle('active');
      });
    });

    // Presets
    function setPreset(preset) {
      switch (preset) {
        case 'gimbal':
          axes = { x: true, y: true, z: false };
          orbits.forEach((o, i) => o.setRotation(0.02, 0.02, 0));
          break;
        case 'slerp':
          axes = { x: true, y: true, z: true };
          orbits.forEach((o, i) => o.setRotation(0.01, 0.01, 0.01));
          break;
        case 'chaos':
          axes = { x: true, y: true, z: true };
          orbits.forEach((o, i) => o.setRotation(
            0.005 + Math.random() * 0.02,
            0.005 + Math.random() * 0.02,
            0.005 + Math.random() * 0.02
          ));
          break;
        case 'sync':
          axes = { x: true, y: false, z: true };
          orbits.forEach(o => o.setRotation(0.015, 0, 0.015));
          break;
      }

      // Update button states
      document.querySelectorAll('.axis-btn').forEach(btn => {
        btn.classList.toggle('active', axes[btn.dataset.axis]);
      });
    }

    // Camera controls
    let isDragging = false;
    let previousMousePosition = { x: 0, y: 0 };
    let cameraAngleX = 0;
    let cameraAngleY = 0.4;
    let cameraDistance = 12;

    container.addEventListener('mousedown', (e) => {
      isDragging = true;
      previousMousePosition = { x: e.clientX, y: e.clientY };
    });

    container.addEventListener('mousemove', (e) => {
      if (!isDragging) return;

      const deltaX = e.clientX - previousMousePosition.x;
      const deltaY = e.clientY - previousMousePosition.y;

      cameraAngleX += deltaX * 0.005;
      cameraAngleY = Math.max(-1, Math.min(1, cameraAngleY + deltaY * 0.005));

      previousMousePosition = { x: e.clientX, y: e.clientY };
    });

    container.addEventListener('mouseup', () => isDragging = false);
    container.addEventListener('mouseleave', () => isDragging = false);

    container.addEventListener('wheel', (e) => {
      cameraDistance = Math.max(5, Math.min(30, cameraDistance + e.deltaY * 0.01));
    });

    // Touch support
    container.addEventListener('touchstart', (e) => {
      isDragging = true;
      previousMousePosition = { x: e.touches[0].clientX, y: e.touches[0].clientY };
    });

    container.addEventListener('touchmove', (e) => {
      if (!isDragging) return;
      const deltaX = e.touches[0].clientX - previousMousePosition.x;
      const deltaY = e.touches[0].clientY - previousMousePosition.y;
      cameraAngleX += deltaX * 0.005;
      cameraAngleY = Math.max(-1, Math.min(1, cameraAngleY + deltaY * 0.005));
      previousMousePosition = { x: e.touches[0].clientX, y: e.touches[0].clientY };
    });

    container.addEventListener('touchend', () => isDragging = false);

    // Glitch effect state
    const glitchOverlay = document.getElementById('glitch-overlay');
    const ternaryIndicator = document.getElementById('ternary-indicator');
    const ternaryState = document.getElementById('ternary-state');
    let isGlitching = false;
    let glitchIntensity = 0;
    let lastGlitchTime = 0;

    // Ternary state thresholds
    const TERNARY_THRESHOLD = 0.15; // When |w| is below this, enter ternary state
    const ternaryStates = ['NULL', 'UNDEFINED', 'NaN', 'VOID', 'LIMINAL', '???', 'ERROR', 'UNKNOWN'];

    function createGlitchElements() {
      glitchOverlay.innerHTML = '';

      // Create scan lines
      for (let i = 0; i < 5; i++) {
        const line = document.createElement('div');
        line.className = 'glitch-line';
        line.style.top = (Math.random() * 100) + '%';
        line.style.opacity = Math.random() * 0.8 + 0.2;
        line.style.height = (Math.random() * 3 + 1) + 'px';
        glitchOverlay.appendChild(line);
      }

      // Create glitch blocks
      for (let i = 0; i < 8; i++) {
        const block = document.createElement('div');
        block.className = 'glitch-block';
        block.style.left = (Math.random() * 100) + '%';
        block.style.top = (Math.random() * 100) + '%';
        block.style.width = (Math.random() * 200 + 50) + 'px';
        block.style.height = (Math.random() * 30 + 10) + 'px';
        block.style.transform = `skewX(${Math.random() * 20 - 10}deg)`;
        glitchOverlay.appendChild(block);
      }
    }

    function triggerGlitch(intensity) {
      if (Date.now() - lastGlitchTime < 100) return;
      lastGlitchTime = Date.now();

      isGlitching = true;
      glitchIntensity = intensity;

      container.classList.add('glitching');
      glitchOverlay.classList.add('active');
      createGlitchElements();

      // Random ternary state
      ternaryState.textContent = ternaryStates[Math.floor(Math.random() * ternaryStates.length)];
      ternaryIndicator.classList.add('active');

      // End glitch after short duration
      setTimeout(() => {
        container.classList.remove('glitching');
        glitchOverlay.classList.remove('active');
        isGlitching = false;
      }, 100 + intensity * 150);
    }

    // Animation
    let lastTime = performance.now();
    let frameCount = 0;
    let fps = 60;
    let inTernaryState = false;
    let ternaryEnterTime = 0;

    function animate(time) {
      requestAnimationFrame(animate);

      // FPS counter
      frameCount++;
      if (time - lastTime >= 1000) {
        fps = frameCount;
        document.getElementById('fps').textContent = fps;
        frameCount = 0;
        lastTime = time;
      }

      // Update camera
      camera.position.x = Math.sin(cameraAngleX) * Math.cos(cameraAngleY) * cameraDistance;
      camera.position.y = Math.sin(cameraAngleY) * cameraDistance;
      camera.position.z = Math.cos(cameraAngleX) * Math.cos(cameraAngleY) * cameraDistance;
      camera.lookAt(0, 0, 0);

      // Update orbits
      let displayQuat = null;
      let minW = 1;
      orbits.forEach((orbit, i) => {
        const q = orbit.update(time * 0.001, speed, axes);
        if (i === 0) displayQuat = q;
        minW = Math.min(minW, Math.abs(q.w));
      });

      // Update quaternion display
      if (displayQuat) {
        document.getElementById('q-w').textContent = displayQuat.w.toFixed(2);
        document.getElementById('q-x').textContent = displayQuat.x.toFixed(2);
        document.getElementById('q-y').textContent = displayQuat.y.toFixed(2);
        document.getElementById('q-z').textContent = displayQuat.z.toFixed(2);

        // Style w based on ternary proximity
        const wEl = document.getElementById('q-w');
        if (Math.abs(displayQuat.w) < TERNARY_THRESHOLD) {
          wEl.style.color = '#ff0';
          wEl.style.textShadow = '0 0 10px #ff0';
        } else {
          wEl.style.color = '#fff';
          wEl.style.textShadow = 'none';
        }
      }

      // Check for ternary state (when w approaches 0 - the undefined rotation zone)
      if (minW < TERNARY_THRESHOLD) {
        if (!inTernaryState) {
          inTernaryState = true;
          ternaryEnterTime = time;
          triggerGlitch(1 - minW / TERNARY_THRESHOLD);
        } else if (Math.random() < 0.1) {
          // Random glitches while in ternary state
          triggerGlitch((1 - minW / TERNARY_THRESHOLD) * 0.5);
        }
      } else {
        if (inTernaryState) {
          inTernaryState = false;
          ternaryIndicator.classList.remove('active');
        }
      }

      // Pulse center sphere - more erratic in ternary state
      if (inTernaryState) {
        const glitchScale = 1 + Math.sin(time * 0.01) * 0.3 + (Math.random() - 0.5) * 0.2;
        centerSphere.scale.setScalar(glitchScale);
        centerSphere.material.color.setHex(Math.random() > 0.5 ? 0xff00ff : 0x00ffff);
      } else {
        centerSphere.scale.setScalar(1 + Math.sin(time * 0.003) * 0.1);
        centerSphere.material.color.setHex(0xffffff);
      }

      renderer.render(scene, camera);
    }

    // Handle resize
    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });

    animate(0);
  </script>
<script src="/sloppy-header/sloppy-bar.js"></script>
</body>
</html>
