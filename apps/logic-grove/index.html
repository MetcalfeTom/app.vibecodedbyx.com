<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>The Logic Grove - Bioluminescent Terrarium</title>
    <link rel="icon" href="https://emojicdn.elk.sh/üåø">
    <meta name="description" content="A digital terrarium where your messages bloom into glowing fractal plants">
    <meta property="og:title" content="The Logic Grove">
    <meta property="og:description" content="Plant your words and watch them grow into bioluminescent fractals">
    <meta property="og:image" content="https://sloppy.live/logic-grove/og-image.png">
    <meta property="og:url" content="https://sloppy.live/logic-grove">
    <link href="https://fonts.googleapis.com/css2?family=Cormorant+Garamond:wght@300;400;600&family=JetBrains+Mono:wght@300&display=swap" rel="stylesheet">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        :root {
            --glow-cyan: #00ffd5;
            --glow-magenta: #ff00aa;
            --glow-violet: #8844ff;
            --glow-lime: #aaff00;
            --glow-orange: #ff6600;
            --deep-dark: #030708;
            --terrarium-bg: #040a0c;
            --glass-edge: rgba(100, 200, 180, 0.1);
        }

        body {
            font-family: 'Cormorant Garamond', serif;
            background: var(--deep-dark);
            color: #ddd;
            min-height: 100vh;
            overflow: hidden;
            display: flex;
            flex-direction: column;
        }

        /* Terrarium container */
        .terrarium {
            flex: 1;
            position: relative;
            background:
                radial-gradient(ellipse at 50% 100%, rgba(0, 60, 40, 0.15) 0%, transparent 60%),
                radial-gradient(ellipse at 30% 80%, rgba(0, 100, 80, 0.08) 0%, transparent 40%),
                radial-gradient(ellipse at 70% 85%, rgba(0, 80, 100, 0.08) 0%, transparent 40%),
                var(--terrarium-bg);
            overflow: hidden;
        }

        /* Glass dome effect */
        .terrarium::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background:
                linear-gradient(180deg, rgba(255,255,255,0.02) 0%, transparent 30%),
                radial-gradient(ellipse at 20% 10%, rgba(255,255,255,0.03) 0%, transparent 30%);
            pointer-events: none;
            z-index: 10;
        }

        /* Soil/ground */
        .ground {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            height: 60px;
            background: linear-gradient(180deg,
                rgba(20, 35, 30, 0.9) 0%,
                rgba(15, 25, 20, 1) 50%,
                rgba(10, 18, 14, 1) 100%
            );
            z-index: 5;
        }

        .ground::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 3px;
            background: linear-gradient(90deg,
                transparent 0%,
                rgba(0, 255, 200, 0.1) 20%,
                rgba(0, 255, 200, 0.15) 50%,
                rgba(0, 255, 200, 0.1) 80%,
                transparent 100%
            );
        }

        /* Canvas */
        #groveCanvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }

        /* Header */
        header {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            padding: 20px 30px;
            z-index: 20;
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            pointer-events: none;
        }

        .title {
            font-size: 28px;
            font-weight: 300;
            letter-spacing: 4px;
            color: rgba(0, 255, 213, 0.7);
            text-shadow:
                0 0 20px rgba(0, 255, 213, 0.5),
                0 0 40px rgba(0, 255, 213, 0.3);
            text-transform: uppercase;
        }

        .subtitle {
            font-size: 12px;
            font-weight: 300;
            letter-spacing: 3px;
            color: rgba(255, 255, 255, 0.3);
            margin-top: 5px;
            font-family: 'JetBrains Mono', monospace;
        }

        .plant-count {
            font-family: 'JetBrains Mono', monospace;
            font-size: 11px;
            color: rgba(0, 255, 213, 0.5);
            text-align: right;
        }

        /* Chat input */
        .chat-container {
            position: absolute;
            bottom: 80px;
            left: 50%;
            transform: translateX(-50%);
            width: 90%;
            max-width: 500px;
            z-index: 20;
        }

        .chat-input-wrapper {
            display: flex;
            gap: 10px;
            background: rgba(0, 20, 15, 0.8);
            border: 1px solid rgba(0, 255, 213, 0.2);
            border-radius: 30px;
            padding: 8px 8px 8px 20px;
            backdrop-filter: blur(10px);
            transition: all 0.3s ease;
        }

        .chat-input-wrapper:focus-within {
            border-color: rgba(0, 255, 213, 0.5);
            box-shadow:
                0 0 20px rgba(0, 255, 213, 0.2),
                inset 0 0 20px rgba(0, 255, 213, 0.05);
        }

        #messageInput {
            flex: 1;
            background: transparent;
            border: none;
            color: #fff;
            font-family: 'Cormorant Garamond', serif;
            font-size: 16px;
            outline: none;
        }

        #messageInput::placeholder {
            color: rgba(255, 255, 255, 0.3);
            font-style: italic;
        }

        #plantBtn {
            background: linear-gradient(135deg, rgba(0, 255, 213, 0.3), rgba(0, 180, 150, 0.3));
            border: 1px solid rgba(0, 255, 213, 0.4);
            color: var(--glow-cyan);
            padding: 10px 20px;
            border-radius: 25px;
            font-family: 'JetBrains Mono', monospace;
            font-size: 11px;
            letter-spacing: 2px;
            cursor: pointer;
            transition: all 0.3s ease;
            text-transform: uppercase;
        }

        #plantBtn:hover {
            background: linear-gradient(135deg, rgba(0, 255, 213, 0.5), rgba(0, 180, 150, 0.5));
            box-shadow: 0 0 25px rgba(0, 255, 213, 0.4);
        }

        /* Controls */
        .controls {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 20px;
            z-index: 20;
        }

        .control-btn {
            background: rgba(0, 20, 15, 0.6);
            border: 1px solid rgba(255, 255, 255, 0.1);
            color: rgba(255, 255, 255, 0.5);
            padding: 8px 16px;
            border-radius: 20px;
            font-family: 'JetBrains Mono', monospace;
            font-size: 10px;
            letter-spacing: 1px;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .control-btn:hover {
            border-color: rgba(0, 255, 213, 0.3);
            color: rgba(0, 255, 213, 0.7);
        }

        /* Message preview */
        .preview-text {
            position: absolute;
            bottom: 150px;
            left: 50%;
            transform: translateX(-50%);
            font-family: 'JetBrains Mono', monospace;
            font-size: 10px;
            color: rgba(0, 255, 213, 0.4);
            text-align: center;
            max-width: 80%;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
            opacity: 0;
            transition: opacity 0.3s;
            z-index: 15;
        }

        .preview-text.visible {
            opacity: 1;
        }

        /* Back link */
        .back-link {
            position: fixed;
            bottom: 20px;
            right: 20px;
            font-family: 'JetBrains Mono', monospace;
            font-size: 10px;
            color: rgba(255, 255, 255, 0.2);
            text-decoration: none;
            z-index: 100;
            transition: color 0.3s;
        }

        .back-link:hover {
            color: var(--glow-cyan);
        }

        /* Connection status */
        .connection-status {
            position: absolute;
            top: 20px;
            right: 30px;
            display: flex;
            align-items: center;
            gap: 8px;
            font-family: 'JetBrains Mono', monospace;
            font-size: 9px;
            color: rgba(255, 255, 255, 0.4);
            z-index: 20;
        }

        .status-dot {
            width: 6px;
            height: 6px;
            border-radius: 50%;
            background: #666;
            transition: all 0.3s;
        }

        .status-dot.connected {
            background: var(--glow-cyan);
            box-shadow: 0 0 10px var(--glow-cyan);
        }

        .status-dot.connecting {
            background: var(--glow-orange);
            animation: pulse-status 1s infinite;
        }

        @keyframes pulse-status {
            0%, 100% { opacity: 0.5; }
            50% { opacity: 1; }
        }

        /* Particle overlay */
        .particles {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            pointer-events: none;
            z-index: 8;
        }

        /* Mobile */
        @media (max-width: 600px) {
            header {
                padding: 15px 20px;
            }

            .title {
                font-size: 18px;
                letter-spacing: 2px;
            }

            .subtitle {
                font-size: 9px;
            }

            .chat-container {
                bottom: 70px;
                width: 95%;
            }

            #messageInput {
                font-size: 14px;
            }

            #plantBtn {
                padding: 8px 15px;
                font-size: 10px;
            }

            .controls {
                bottom: 15px;
                gap: 10px;
            }

            .control-btn {
                padding: 6px 12px;
                font-size: 9px;
            }
        }
    </style>
</head>
<body>
    <div class="terrarium">
        <canvas id="groveCanvas"></canvas>
        <div class="ground"></div>
        <div class="particles" id="particles"></div>

        <header>
            <div>
                <div class="title">The Logic Grove</div>
                <div class="subtitle">bioluminescent terrarium</div>
            </div>
            <div class="plant-count" id="plantCount">connecting...</div>
        </header>

        <div class="connection-status">
            <div class="status-dot connecting" id="statusDot"></div>
            <span id="statusText">connecting</span>
        </div>

        <div class="preview-text" id="previewText"></div>

        <div class="chat-container">
            <div class="chat-input-wrapper">
                <input type="text" id="messageInput" placeholder="Plant your words..." maxlength="100">
                <button id="plantBtn">Grow</button>
            </div>
        </div>

        <div class="controls">
            <button class="control-btn" id="clearBtn">Clear Grove</button>
            <button class="control-btn" id="randomBtn">Random Seed</button>
        </div>
    </div>

    <a href="https://sloppy.live" class="back-link">‚Üê sloppy.live</a>

    <script type="module">
        import supabase, { supabaseSession } from '../../supabase-config.js';

        // Canvas setup
        const canvas = document.getElementById('groveCanvas');
        const ctx = canvas.getContext('2d');
        let plants = [];
        let particles = [];
        let animationId;
        let currentUser = null;
        let realtimeChannel = null;

        // Bioluminescent color palette
        const GLOW_COLORS = [
            { h: 165, s: 100, l: 50, name: 'cyan' },
            { h: 320, s: 100, l: 50, name: 'magenta' },
            { h: 260, s: 100, l: 65, name: 'violet' },
            { h: 75, s: 100, l: 50, name: 'lime' },
            { h: 30, s: 100, l: 50, name: 'orange' },
            { h: 180, s: 100, l: 45, name: 'teal' },
            { h: 280, s: 80, l: 60, name: 'purple' },
            { h: 120, s: 100, l: 45, name: 'green' }
        ];

        // Update connection status UI
        function setConnectionStatus(status, text) {
            const dot = document.getElementById('statusDot');
            const label = document.getElementById('statusText');
            dot.className = 'status-dot ' + status;
            label.textContent = text;
        }

        // Initialize canvas
        function initCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        }

        // Seed random from string (deterministic)
        function seedRandom(str) {
            let hash = 0;
            for (let i = 0; i < str.length; i++) {
                hash = ((hash << 5) - hash) + str.charCodeAt(i);
                hash = hash & hash;
            }
            return function() {
                hash = Math.sin(hash) * 10000;
                return hash - Math.floor(hash);
            };
        }

        // Get color from message
        function getColorFromMessage(msg, rand) {
            const charSum = msg.split('').reduce((sum, c) => sum + c.charCodeAt(0), 0);
            const baseColor = GLOW_COLORS[charSum % GLOW_COLORS.length];
            const hueShift = (rand() - 0.5) * 30;
            return {
                h: (baseColor.h + hueShift + 360) % 360,
                s: baseColor.s - rand() * 20,
                l: baseColor.l + (rand() - 0.5) * 15
            };
        }

        // Create fractal plant from message + position (deterministic)
        function createPlant(message, xPos) {
            // Use message + xPos for deterministic seeding so all clients see same plant
            const rand = seedRandom(message + xPos);
            const color = getColorFromMessage(message, rand);

            const complexity = Math.min(8, Math.max(4, Math.floor(message.length / 8) + 4));
            const maxBranches = Math.min(5, Math.max(2, Math.floor(message.length / 15) + 2));
            const baseHeight = Math.min(250, Math.max(80, message.length * 3 + 50));
            const swayAmount = 0.3 + rand() * 0.4;

            const groundY = canvas.height - 60;
            // Scale x position to current canvas width
            const plantX = (xPos / 10000) * (canvas.width - 100) + 50;

            return {
                message: message,
                x: plantX,
                xNormalized: xPos,
                y: groundY,
                color: color,
                complexity: complexity,
                maxBranches: maxBranches,
                baseHeight: baseHeight,
                swayAmount: swayAmount,
                swayOffset: rand() * Math.PI * 2,
                growthProgress: 0,
                rand: rand,
                branches: generateBranches(complexity, maxBranches, baseHeight, rand),
                glowIntensity: 0.5 + rand() * 0.5,
                pulseOffset: rand() * Math.PI * 2
            };
        }

        // Create plant from DB record
        function createPlantFromDb(record, instant = false) {
            const plant = createPlant(record.message, record.x_position);
            if (instant) {
                plant.growthProgress = 1; // Already grown for existing plants
            }
            return plant;
        }

        // Generate branch structure
        function generateBranches(depth, maxBranches, height, rand) {
            const branches = [];

            function addBranch(startAngle, length, level) {
                if (level > depth || length < 5) return;

                const angleVariation = (rand() - 0.5) * 0.6;
                const angle = startAngle + angleVariation;
                const branchLength = length * (0.6 + rand() * 0.3);

                branches.push({
                    angle: angle,
                    length: branchLength,
                    level: level,
                    thickness: Math.max(1, (depth - level + 1) * 1.5),
                    hasLeaf: level > depth - 2 && rand() > 0.3
                });

                const numChildren = level < depth - 1 ? Math.floor(rand() * maxBranches) + 1 : 0;
                for (let i = 0; i < numChildren; i++) {
                    const childAngle = angle + (rand() - 0.5) * 1.2;
                    addBranch(childAngle, branchLength * 0.7, level + 1);
                }
            }

            addBranch(-Math.PI / 2, height, 0);

            const sideBranches = Math.floor(rand() * 3) + 2;
            for (let i = 0; i < sideBranches; i++) {
                const sideAngle = -Math.PI / 2 + (rand() - 0.5) * 0.8;
                const startHeight = height * (0.3 + rand() * 0.5);
                addBranch(sideAngle, startHeight * 0.6, 1);
            }

            return branches;
        }

        // Draw a single plant
        function drawPlant(plant, time) {
            const { x, y, color, branches, growthProgress, swayAmount, swayOffset, glowIntensity, pulseOffset } = plant;

            const sway = Math.sin(time * 0.001 + swayOffset) * swayAmount;
            const pulse = 0.7 + Math.sin(time * 0.002 + pulseOffset) * 0.3;
            const currentGlow = glowIntensity * pulse;

            const hsl = `hsl(${color.h}, ${color.s}%, ${color.l}%)`;
            const glowHsl = `hsla(${color.h}, ${color.s}%, ${color.l + 20}%, ${currentGlow})`;

            ctx.save();
            ctx.translate(x, y);

            let currentX = 0;
            let currentY = 0;

            branches.forEach((branch, i) => {
                if (i / branches.length > growthProgress) return;

                const branchProgress = Math.min(1, (growthProgress * branches.length - i));
                if (branchProgress <= 0) return;

                const swayedAngle = branch.angle + sway * (branch.level * 0.1 + 0.1);
                const length = branch.length * branchProgress;

                const endX = currentX + Math.cos(swayedAngle) * length;
                const endY = currentY + Math.sin(swayedAngle) * length;

                ctx.shadowColor = glowHsl;
                ctx.shadowBlur = 15 + currentGlow * 10;

                ctx.beginPath();
                ctx.moveTo(currentX, currentY);
                ctx.lineTo(endX, endY);
                ctx.strokeStyle = hsl;
                ctx.lineWidth = branch.thickness * branchProgress;
                ctx.lineCap = 'round';
                ctx.stroke();

                if (branch.hasLeaf && branchProgress > 0.8) {
                    ctx.beginPath();
                    ctx.arc(endX, endY, 2 + currentGlow * 2, 0, Math.PI * 2);
                    ctx.fillStyle = `hsla(${color.h}, ${color.s}%, ${color.l + 30}%, ${currentGlow})`;
                    ctx.fill();
                }

                if (branch.level === 0) {
                    currentX = endX;
                    currentY = endY;
                }
            });

            ctx.restore();

            if (Math.random() < 0.02 * currentGlow && growthProgress > 0.5) {
                emitParticle(x, y - plant.baseHeight * 0.5, color);
            }
        }

        // Particle system
        function emitParticle(x, y, color) {
            particles.push({
                x: x + (Math.random() - 0.5) * 50,
                y: y + (Math.random() - 0.5) * 50,
                vx: (Math.random() - 0.5) * 0.5,
                vy: -Math.random() * 0.5 - 0.2,
                life: 1,
                decay: 0.005 + Math.random() * 0.01,
                size: 1 + Math.random() * 2,
                color: color
            });
        }

        function updateParticles() {
            particles = particles.filter(p => p.life > 0);

            particles.forEach(p => {
                p.x += p.vx;
                p.y += p.vy;
                p.vy -= 0.01;
                p.life -= p.decay;

                const alpha = p.life * 0.6;
                ctx.beginPath();
                ctx.arc(p.x, p.y, p.size * p.life, 0, Math.PI * 2);
                ctx.fillStyle = `hsla(${p.color.h}, ${p.color.s}%, ${p.color.l + 20}%, ${alpha})`;
                ctx.shadowColor = `hsla(${p.color.h}, ${p.color.s}%, ${p.color.l}%, ${alpha})`;
                ctx.shadowBlur = 10;
                ctx.fill();
            });
        }

        // Main animation loop
        function animate(time) {
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            plants.forEach(plant => {
                if (plant.growthProgress < 1) {
                    plant.growthProgress = Math.min(1, plant.growthProgress + 0.008);
                }
                drawPlant(plant, time);
            });

            updateParticles();
            animationId = requestAnimationFrame(animate);
        }

        // Plant a message (insert to DB, realtime will handle visual)
        async function plantMessage(message) {
            if (!message.trim() || !currentUser) return;

            const cleanMessage = message.trim().slice(0, 100);
            const xPosition = Math.floor(Math.random() * 10000); // Normalized position

            try {
                const { error } = await supabase
                    .from('logic_grove_plants')
                    .insert({
                        message: cleanMessage,
                        x_position: xPosition,
                        user_id: currentUser.id
                    });

                if (error) throw error;

                // Clear input
                document.getElementById('messageInput').value = '';
                document.getElementById('previewText').classList.remove('visible');
            } catch (err) {
                console.error('Failed to plant:', err);
            }
        }

        // Update plant count display
        function updatePlantCount() {
            const count = plants.length;
            document.getElementById('plantCount').textContent =
                count === 1 ? '1 plant' : `${count} plants`;
        }

        // Clear local view (doesn't delete from DB)
        function clearLocalView() {
            plants = [];
            particles = [];
            updatePlantCount();
        }

        // Load existing plants from DB
        async function loadExistingPlants() {
            try {
                const { data, error } = await supabase
                    .from('logic_grove_plants')
                    .select('*')
                    .order('created_at', { ascending: true })
                    .limit(100); // Limit for performance

                if (error) throw error;

                // Create plants from DB records (fully grown)
                data.forEach(record => {
                    const plant = createPlantFromDb(record, true);
                    plants.push(plant);
                });

                updatePlantCount();
            } catch (err) {
                console.error('Failed to load plants:', err);
            }
        }

        // Subscribe to real-time plant inserts
        function subscribeToRealtime() {
            realtimeChannel = supabase
                .channel('logic_grove_realtime')
                .on('postgres_changes', {
                    event: 'INSERT',
                    schema: 'public',
                    table: 'logic_grove_plants'
                }, (payload) => {
                    // New plant from any user - grow it!
                    const plant = createPlantFromDb(payload.new, false);
                    plants.push(plant);
                    updatePlantCount();
                })
                .subscribe((status, err) => {
                    console.log('Realtime status:', status, err);
                    if (status === 'SUBSCRIBED') {
                        setConnectionStatus('connected', 'live');
                    } else if (status === 'CHANNEL_ERROR' || status === 'TIMED_OUT') {
                        console.error('Realtime error:', err);
                        setConnectionStatus('', 'no sync');
                    } else if (status === 'CLOSED') {
                        setConnectionStatus('', 'closed');
                    }
                });
        }

        // Add random plant
        async function addRandomPlant() {
            const phrases = [
                'digital nature blooms',
                'light finds a way',
                'code becomes life',
                'fractals dream in color',
                'silicon garden grows',
                'electrons dance together',
                'binary photosynthesis',
                'recursive beauty',
                'algorithmic flowers',
                'neon chlorophyll'
            ];
            const phrase = phrases[Math.floor(Math.random() * phrases.length)];
            await plantMessage(phrase);
        }

        // Initialize app
        async function init() {
            setConnectionStatus('connecting', 'connecting');
            initCanvas();

            // Start animation immediately for smooth UX
            animate(0);

            try {
                // Get or create session
                const { user } = await supabaseSession();
                currentUser = user;
                console.log('Auth ready, user:', user.id);

                // Load existing plants
                await loadExistingPlants();
                console.log('Loaded', plants.length, 'plants');

                // Show ready status while realtime connects
                setConnectionStatus('connected', 'ready');

                // Subscribe to real-time updates
                subscribeToRealtime();

            } catch (err) {
                console.error('Init failed:', err);
                setConnectionStatus('', 'offline');
            }
        }

        // Event listeners
        document.getElementById('plantBtn').addEventListener('click', () => {
            plantMessage(document.getElementById('messageInput').value);
        });

        document.getElementById('messageInput').addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
                plantMessage(document.getElementById('messageInput').value);
            }
        });

        document.getElementById('messageInput').addEventListener('input', (e) => {
            const preview = document.getElementById('previewText');
            if (e.target.value.trim()) {
                preview.textContent = `"${e.target.value}" will bloom...`;
                preview.classList.add('visible');
            } else {
                preview.classList.remove('visible');
            }
        });

        document.getElementById('clearBtn').addEventListener('click', clearLocalView);
        document.getElementById('randomBtn').addEventListener('click', addRandomPlant);

        window.addEventListener('resize', () => {
            initCanvas();
            // Recalculate plant positions on resize
            plants.forEach(p => {
                p.x = (p.xNormalized / 10000) * (canvas.width - 100) + 50;
                p.y = canvas.height - 60;
            });
        });

        // Start
        init();
    </script>
</body>
</html>
