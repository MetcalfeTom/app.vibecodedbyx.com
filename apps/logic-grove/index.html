<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>The Logic Grove - Bioluminescent Terrarium</title>
    <link rel="icon" href="https://emojicdn.elk.sh/üåø">
    <meta name="description" content="A digital terrarium where your messages bloom into glowing fractal plants">
    <meta property="og:title" content="The Logic Grove">
    <meta property="og:description" content="Plant your words and watch them grow into bioluminescent fractals">
    <meta property="og:image" content="https://sloppy.live/logic-grove/og-image.png">
    <meta property="og:url" content="https://sloppy.live/logic-grove">
    <link href="https://fonts.googleapis.com/css2?family=Cormorant+Garamond:wght@300;400;600&family=JetBrains+Mono:wght@300&display=swap" rel="stylesheet">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        :root {
            --glow-cyan: #00ffd5;
            --glow-magenta: #ff00aa;
            --glow-violet: #8844ff;
            --glow-lime: #aaff00;
            --glow-orange: #ff6600;
            --deep-dark: #030708;
            --terrarium-bg: #040a0c;
        }

        body {
            font-family: 'Cormorant Garamond', serif;
            background: var(--deep-dark);
            color: #ddd;
            min-height: 100vh;
            overflow: hidden;
            display: flex;
            flex-direction: column;
        }

        .terrarium {
            flex: 1;
            position: relative;
            background:
                radial-gradient(ellipse at 50% 100%, rgba(0, 60, 40, 0.15) 0%, transparent 60%),
                radial-gradient(ellipse at 30% 80%, rgba(0, 100, 80, 0.08) 0%, transparent 40%),
                radial-gradient(ellipse at 70% 85%, rgba(0, 80, 100, 0.08) 0%, transparent 40%),
                var(--terrarium-bg);
            overflow: hidden;
        }

        .terrarium::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background:
                linear-gradient(180deg, rgba(255,255,255,0.02) 0%, transparent 30%),
                radial-gradient(ellipse at 20% 10%, rgba(255,255,255,0.03) 0%, transparent 30%);
            pointer-events: none;
            z-index: 10;
        }

        .ground {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            height: 60px;
            background: linear-gradient(180deg,
                rgba(20, 35, 30, 0.9) 0%,
                rgba(15, 25, 20, 1) 50%,
                rgba(10, 18, 14, 1) 100%
            );
            z-index: 5;
        }

        .ground::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 3px;
            background: linear-gradient(90deg,
                transparent 0%,
                rgba(0, 255, 200, 0.1) 20%,
                rgba(0, 255, 200, 0.15) 50%,
                rgba(0, 255, 200, 0.1) 80%,
                transparent 100%
            );
        }

        #groveCanvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }

        header {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            padding: 20px 30px;
            z-index: 20;
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            pointer-events: none;
        }

        .title {
            font-size: 28px;
            font-weight: 300;
            letter-spacing: 4px;
            color: rgba(0, 255, 213, 0.7);
            text-shadow:
                0 0 20px rgba(0, 255, 213, 0.5),
                0 0 40px rgba(0, 255, 213, 0.3);
            text-transform: uppercase;
        }

        .subtitle {
            font-size: 12px;
            font-weight: 300;
            letter-spacing: 3px;
            color: rgba(255, 255, 255, 0.3);
            margin-top: 5px;
            font-family: 'JetBrains Mono', monospace;
        }

        .plant-count {
            font-family: 'JetBrains Mono', monospace;
            font-size: 11px;
            color: rgba(0, 255, 213, 0.5);
            text-align: right;
        }

        .chat-container {
            position: absolute;
            bottom: 80px;
            left: 50%;
            transform: translateX(-50%);
            width: 90%;
            max-width: 500px;
            z-index: 20;
        }

        .chat-input-wrapper {
            display: flex;
            gap: 10px;
            background: rgba(0, 20, 15, 0.8);
            border: 1px solid rgba(0, 255, 213, 0.2);
            border-radius: 30px;
            padding: 8px 8px 8px 20px;
            backdrop-filter: blur(10px);
            transition: all 0.3s ease;
        }

        .chat-input-wrapper:focus-within {
            border-color: rgba(0, 255, 213, 0.5);
            box-shadow:
                0 0 20px rgba(0, 255, 213, 0.2),
                inset 0 0 20px rgba(0, 255, 213, 0.05);
        }

        #messageInput {
            flex: 1;
            background: transparent;
            border: none;
            color: #fff;
            font-family: 'Cormorant Garamond', serif;
            font-size: 16px;
            outline: none;
        }

        #messageInput::placeholder {
            color: rgba(255, 255, 255, 0.3);
            font-style: italic;
        }

        #plantBtn {
            background: linear-gradient(135deg, rgba(0, 255, 213, 0.3), rgba(0, 180, 150, 0.3));
            border: 1px solid rgba(0, 255, 213, 0.4);
            color: var(--glow-cyan);
            padding: 10px 20px;
            border-radius: 25px;
            font-family: 'JetBrains Mono', monospace;
            font-size: 11px;
            letter-spacing: 2px;
            cursor: pointer;
            transition: all 0.3s ease;
            text-transform: uppercase;
        }

        #plantBtn:hover {
            background: linear-gradient(135deg, rgba(0, 255, 213, 0.5), rgba(0, 180, 150, 0.5));
            box-shadow: 0 0 25px rgba(0, 255, 213, 0.4);
        }

        .controls {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 20px;
            z-index: 20;
        }

        .control-btn {
            background: rgba(0, 20, 15, 0.6);
            border: 1px solid rgba(255, 255, 255, 0.1);
            color: rgba(255, 255, 255, 0.5);
            padding: 8px 16px;
            border-radius: 20px;
            font-family: 'JetBrains Mono', monospace;
            font-size: 10px;
            letter-spacing: 1px;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .control-btn:hover {
            border-color: rgba(0, 255, 213, 0.3);
            color: rgba(0, 255, 213, 0.7);
        }

        .preview-text {
            position: absolute;
            bottom: 150px;
            left: 50%;
            transform: translateX(-50%);
            font-family: 'JetBrains Mono', monospace;
            font-size: 10px;
            color: rgba(0, 255, 213, 0.4);
            text-align: center;
            max-width: 80%;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
            opacity: 0;
            transition: opacity 0.3s;
            z-index: 15;
        }

        .preview-text.visible {
            opacity: 1;
        }

        .back-link {
            position: fixed;
            bottom: 20px;
            right: 20px;
            font-family: 'JetBrains Mono', monospace;
            font-size: 10px;
            color: rgba(255, 255, 255, 0.2);
            text-decoration: none;
            z-index: 100;
            transition: color 0.3s;
        }

        .back-link:hover {
            color: var(--glow-cyan);
        }

        @media (max-width: 600px) {
            header { padding: 15px 20px; }
            .title { font-size: 18px; letter-spacing: 2px; }
            .subtitle { font-size: 9px; }
            .chat-container { bottom: 70px; width: 95%; }
            #messageInput { font-size: 14px; }
            #plantBtn { padding: 8px 15px; font-size: 10px; }
            .controls { bottom: 15px; gap: 10px; }
            .control-btn { padding: 6px 12px; font-size: 9px; }
        }
    </style>
</head>
<body>
    <div class="terrarium">
        <canvas id="groveCanvas"></canvas>
        <div class="ground"></div>

        <header>
            <div>
                <div class="title">The Logic Grove</div>
                <div class="subtitle">bioluminescent terrarium</div>
            </div>
            <div class="plant-count" id="plantCount">0 plants</div>
        </header>

        <div class="preview-text" id="previewText"></div>

        <div class="chat-container">
            <div class="chat-input-wrapper">
                <input type="text" id="messageInput" placeholder="Plant your words..." maxlength="100">
                <button id="plantBtn">Grow</button>
            </div>
        </div>

        <div class="controls">
            <button class="control-btn" id="clearBtn">Clear Grove</button>
            <button class="control-btn" id="randomBtn">Random Seed</button>
        </div>
    </div>

    <a href="https://sloppy.live" class="back-link">‚Üê sloppy.live</a>

    <script type="module">
        import supabase, { supabaseSession } from '../../supabase-config.js';

        const canvas = document.getElementById('groveCanvas');
        const ctx = canvas.getContext('2d');
        let plants = [];
        let particles = [];
        let lastTime = 0;
        let mouseX = -1000, mouseY = -1000;
        let currentUser = null;
        let isOnline = false;

        const GROWTH_SPEED = 0.5;
        const MOUSE_INFLUENCE = 150;
        const MOUSE_STRENGTH = 0.3;

        const GLOW_COLORS = [
            { h: 165, s: 100, l: 50 },  // cyan
            { h: 320, s: 100, l: 50 },  // magenta
            { h: 260, s: 100, l: 65 },  // violet
            { h: 75, s: 100, l: 50 },   // lime
            { h: 30, s: 100, l: 50 },   // orange
            { h: 180, s: 100, l: 45 },  // teal
            { h: 280, s: 80, l: 60 },   // purple
            { h: 120, s: 100, l: 45 }   // green
        ];

        function initCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        }

        function seedRandom(str) {
            let hash = 0;
            for (let i = 0; i < str.length; i++) {
                hash = ((hash << 5) - hash) + str.charCodeAt(i);
                hash = hash & hash;
            }
            return function() {
                hash = Math.sin(hash) * 10000;
                return hash - Math.floor(hash);
            };
        }

        function getColorFromMessage(msg, rand) {
            const charSum = msg.split('').reduce((sum, c) => sum + c.charCodeAt(0), 0);
            const baseColor = GLOW_COLORS[charSum % GLOW_COLORS.length];
            const hueShift = (rand() - 0.5) * 30;
            return {
                h: (baseColor.h + hueShift + 360) % 360,
                s: baseColor.s - rand() * 20,
                l: baseColor.l + (rand() - 0.5) * 15
            };
        }

        // Create plant - xPos from DB (0-10000) or generate new
        function createPlant(message, xPos = null, startGrown = false) {
            // Use xPos for deterministic seeding if from DB
            const seedStr = xPos !== null ? message + xPos : message + Date.now();
            const rand = seedRandom(seedStr);
            const color = getColorFromMessage(message, rand);

            const complexity = Math.min(8, Math.max(4, Math.floor(message.length / 8) + 4));
            const maxBranches = Math.min(5, Math.max(2, Math.floor(message.length / 15) + 2));
            const baseHeight = Math.min(250, Math.max(80, message.length * 3 + 50));
            const swayAmount = 0.3 + rand() * 0.4;

            // Normalize x position (0-1 range)
            const xNormalized = xPos !== null
                ? (xPos / 10000) * 0.9 + 0.05
                : 0.05 + rand() * 0.9;

            return {
                message: message,
                xNormalized: xNormalized,
                xPosition: xPos !== null ? xPos : Math.floor(xNormalized * 10000),
                color: color,
                complexity: complexity,
                maxBranches: maxBranches,
                baseHeight: baseHeight,
                swayAmount: swayAmount,
                swayOffset: rand() * Math.PI * 2,
                growthProgress: startGrown ? 1 : 0,
                rand: rand,
                branches: generateBranches(complexity, maxBranches, baseHeight, rand),
                glowIntensity: 0.5 + rand() * 0.5,
                pulseOffset: rand() * Math.PI * 2
            };
        }

        function generateBranches(depth, maxBranches, height, rand) {
            const branches = [];

            function addBranch(startAngle, length, level) {
                if (level > depth || length < 5) return;

                const angleVariation = (rand() - 0.5) * 0.6;
                const angle = startAngle + angleVariation;
                const branchLength = length * (0.6 + rand() * 0.3);

                branches.push({
                    angle: angle,
                    length: branchLength,
                    level: level,
                    thickness: Math.max(1, (depth - level + 1) * 1.5),
                    hasLeaf: level > depth - 2 && rand() > 0.3
                });

                const numChildren = level < depth - 1 ? Math.floor(rand() * maxBranches) + 1 : 0;
                for (let i = 0; i < numChildren; i++) {
                    const childAngle = angle + (rand() - 0.5) * 1.2;
                    addBranch(childAngle, branchLength * 0.7, level + 1);
                }
            }

            addBranch(-Math.PI / 2, height, 0);

            const sideBranches = Math.floor(rand() * 3) + 2;
            for (let i = 0; i < sideBranches; i++) {
                const sideAngle = -Math.PI / 2 + (rand() - 0.5) * 0.8;
                const startHeight = height * (0.3 + rand() * 0.5);
                addBranch(sideAngle, startHeight * 0.6, 1);
            }

            return branches;
        }

        function drawPlant(plant, time) {
            const { xNormalized, color, branches, growthProgress, swayAmount, swayOffset, glowIntensity, pulseOffset, baseHeight } = plant;

            // Calculate position relative to current canvas size
            const x = xNormalized * canvas.width;
            const y = canvas.height - 60; // Always relative to ground

            // Wind: layered sine waves for natural movement
            const wind = Math.sin(time * 0.0008 + swayOffset) * 0.6
                       + Math.sin(time * 0.002 + swayOffset * 1.3) * 0.3
                       + Math.sin(time * 0.005 + swayOffset * 0.7) * 0.1;
            const sway = wind * swayAmount;
            const pulse = 0.7 + Math.sin(time * 0.002 + pulseOffset) * 0.3;
            const currentGlow = glowIntensity * pulse;

            const hsl = `hsl(${color.h}, ${color.s}%, ${color.l}%)`;
            const glowHsl = `hsla(${color.h}, ${color.s}%, ${color.l + 20}%, ${currentGlow})`;

            // Mouse lean calculation
            const dx = mouseX - x;
            const dy = mouseY - y;
            const dist = Math.sqrt(dx * dx + dy * dy);
            const mouseLean = dist < MOUSE_INFLUENCE
                ? (dx / dist) * MOUSE_STRENGTH * (1 - dist / MOUSE_INFLUENCE)
                : 0;

            ctx.save();
            ctx.translate(x, y);

            let currentX = 0;
            let currentY = 0;

            // Use for loop with break for performance
            for (let i = 0; i < branches.length; i++) {
                if (i / branches.length > growthProgress) break; // Early exit

                const branch = branches[i];
                const branchProgress = Math.min(1, (growthProgress * branches.length - i));
                if (branchProgress <= 0) break; // Early exit

                // Higher branches sway more + mouse lean
                const branchSway = sway * (0.1 + branch.level * 0.15);
                const totalLean = branchSway + mouseLean * (0.2 + branch.level * 0.1);
                const swayedAngle = branch.angle + totalLean;
                const length = branch.length * branchProgress;

                const endX = currentX + Math.cos(swayedAngle) * length;
                const endY = currentY + Math.sin(swayedAngle) * length;

                ctx.shadowColor = glowHsl;
                ctx.shadowBlur = 15 + currentGlow * 10;

                ctx.beginPath();
                ctx.moveTo(currentX, currentY);
                ctx.lineTo(endX, endY);
                ctx.strokeStyle = hsl;
                ctx.lineWidth = branch.thickness * branchProgress;
                ctx.lineCap = 'round';
                ctx.stroke();

                if (branch.hasLeaf && branchProgress > 0.8) {
                    ctx.beginPath();
                    ctx.arc(endX, endY, 2 + currentGlow * 2, 0, Math.PI * 2);
                    ctx.fillStyle = `hsla(${color.h}, ${color.s}%, ${color.l + 30}%, ${currentGlow})`;
                    ctx.fill();
                }

                if (branch.level === 0) {
                    currentX = endX;
                    currentY = endY;
                }
            }

            ctx.restore();

            if (Math.random() < 0.02 * currentGlow && growthProgress > 0.5) {
                emitParticle(x, y - plant.baseHeight * 0.5, color);
            }
        }

        function emitParticle(x, y, color) {
            particles.push({
                x: x + (Math.random() - 0.5) * 50,
                y: y + (Math.random() - 0.5) * 50,
                vx: (Math.random() - 0.5) * 0.5,
                vy: -Math.random() * 0.5 - 0.2,
                life: 1,
                decay: 0.005 + Math.random() * 0.01,
                size: 1 + Math.random() * 2,
                color: color
            });
        }

        function updateParticles(deltaTime) {
            particles = particles.filter(p => p.life > 0);

            const dtScale = deltaTime * 60; // Normalize to ~60fps baseline

            particles.forEach(p => {
                p.x += p.vx * dtScale;
                p.y += p.vy * dtScale;
                p.vy -= 0.01 * dtScale;
                p.life -= p.decay * dtScale;

                const alpha = p.life * 0.6;
                ctx.beginPath();
                ctx.arc(p.x, p.y, p.size * p.life, 0, Math.PI * 2);
                ctx.fillStyle = `hsla(${p.color.h}, ${p.color.s}%, ${p.color.l + 20}%, ${alpha})`;
                ctx.shadowColor = `hsla(${p.color.h}, ${p.color.s}%, ${p.color.l}%, ${alpha})`;
                ctx.shadowBlur = 10;
                ctx.fill();
            });
        }

        function animate(time) {
            // Calculate delta time for frame-rate independent animation
            const deltaTime = lastTime ? (time - lastTime) / 1000 : 0.016;
            lastTime = time;

            ctx.clearRect(0, 0, canvas.width, canvas.height);

            plants.forEach(plant => {
                if (plant.growthProgress < 1) {
                    // Grow based on real time, not frame rate
                    plant.growthProgress = Math.min(1, plant.growthProgress + GROWTH_SPEED * deltaTime);
                }
                drawPlant(plant, time);
            });

            // Update particles with delta time
            updateParticles(deltaTime);
            requestAnimationFrame(animate);
        }

        // Add plant locally and optionally save to DB
        async function addPlant(message, saveToDb = true) {
            if (!message.trim()) return;

            const plant = createPlant(message.trim());
            plants.push(plant);
            updatePlantCount();

            document.getElementById('messageInput').value = '';
            document.getElementById('previewText').classList.remove('visible');

            // Save to database if online
            if (saveToDb && isOnline && currentUser) {
                try {
                    await supabase.from('logic_grove_plants').insert({
                        message: plant.message,
                        x_position: plant.xPosition,
                        user_id: currentUser.id
                    });
                } catch (err) {
                    console.warn('Failed to save plant:', err);
                }
            }
        }

        // Load existing plants from DB
        async function loadPlantsFromDb() {
            try {
                const { data, error } = await supabase
                    .from('logic_grove_plants')
                    .select('message, x_position')
                    .order('created_at', { ascending: true })
                    .limit(50);

                if (error) throw error;

                data.forEach(row => {
                    const plant = createPlant(row.message, row.x_position, true);
                    plants.push(plant);
                });

                updatePlantCount();
                console.log('Loaded', data.length, 'plants from DB');
            } catch (err) {
                console.warn('Failed to load plants:', err);
            }
        }

        // Subscribe to real-time inserts
        function subscribeToRealtime() {
            supabase
                .channel('logic_grove')
                .on('postgres_changes', {
                    event: 'INSERT',
                    schema: 'public',
                    table: 'logic_grove_plants'
                }, (payload) => {
                    // Check if we already have this plant (from our own insert)
                    const exists = plants.some(p =>
                        p.message === payload.new.message &&
                        p.xPosition === payload.new.x_position
                    );
                    if (!exists) {
                        const plant = createPlant(payload.new.message, payload.new.x_position, false);
                        plants.push(plant);
                        updatePlantCount();
                    }
                })
                .subscribe((status) => {
                    console.log('Realtime:', status);
                });
        }

        function updatePlantCount() {
            const count = plants.length;
            const status = isOnline ? '' : ' (offline)';
            document.getElementById('plantCount').textContent =
                (count === 1 ? '1 plant' : `${count} plants`) + status;
        }

        function clearGrove() {
            plants = [];
            particles = [];
            updatePlantCount();
        }

        async function addRandomPlant() {
            const phrases = [
                'digital nature blooms',
                'light finds a way',
                'code becomes life',
                'fractals dream in color',
                'silicon garden grows',
                'electrons dance together',
                'binary photosynthesis',
                'recursive beauty',
                'algorithmic flowers',
                'neon chlorophyll'
            ];
            const phrase = phrases[Math.floor(Math.random() * phrases.length)];
            await addPlant(phrase);
        }

        // Event listeners
        document.getElementById('plantBtn').addEventListener('click', () => {
            addPlant(document.getElementById('messageInput').value);
        });

        document.getElementById('messageInput').addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
                addPlant(document.getElementById('messageInput').value);
            }
        });

        document.getElementById('messageInput').addEventListener('input', (e) => {
            const preview = document.getElementById('previewText');
            if (e.target.value.trim()) {
                preview.textContent = `"${e.target.value}" will bloom...`;
                preview.classList.add('visible');
            } else {
                preview.classList.remove('visible');
            }
        });

        document.getElementById('clearBtn').addEventListener('click', clearGrove);
        document.getElementById('randomBtn').addEventListener('click', addRandomPlant);

        window.addEventListener('resize', initCanvas);

        // Mouse tracking for plant interaction
        canvas.addEventListener('mousemove', (e) => {
            mouseX = e.clientX;
            mouseY = e.clientY;
        });

        canvas.addEventListener('mouseleave', () => {
            mouseX = -1000;
            mouseY = -1000;
        });

        // Touch support for mobile
        canvas.addEventListener('touchmove', (e) => {
            if (e.touches.length > 0) {
                mouseX = e.touches[0].clientX;
                mouseY = e.touches[0].clientY;
            }
        }, { passive: true });

        canvas.addEventListener('touchend', () => {
            mouseX = -1000;
            mouseY = -1000;
        });

        // Initialize
        async function init() {
            initCanvas();
            animate(0);

            // Try to connect to Supabase
            try {
                const sessionPromise = supabaseSession();
                const timeout = new Promise((_, reject) =>
                    setTimeout(() => reject(new Error('timeout')), 3000)
                );
                const { user } = await Promise.race([sessionPromise, timeout]);
                currentUser = user;
                isOnline = true;

                // Load existing plants
                await loadPlantsFromDb();

                // Subscribe to real-time updates
                subscribeToRealtime();

                updatePlantCount();
                console.log('Connected to grove');
            } catch (err) {
                console.warn('Offline mode:', err.message);
                isOnline = false;
                updatePlantCount();

                // Add welcome plants in offline mode
                setTimeout(() => addPlant('welcome to the grove', false), 300);
                setTimeout(() => addPlant('thoughts become light', false), 900);
            }
        }

        init();
    </script>
</body>
</html>
