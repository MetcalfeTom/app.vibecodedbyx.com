<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
  <title>Neon Crash - 2D Platformer</title>
  <link rel="icon" href="https://emojicdn.elk.sh/ðŸ’¥">
  <meta name="description" content="Jump over crates, avoid nitro boxes in this neon platformer!">
  <meta property="og:title" content="Neon Crash - 2D Platformer">
  <meta property="og:description" content="Jump over crates, avoid nitro boxes in this neon platformer!">
  <meta property="og:url" content="https://sloppy.live/neon-crash">
  <meta property="og:image" content="https://emojicdn.elk.sh/ðŸ’¥?style=twitter">
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&family=Orbitron:wght@700;900&display=swap" rel="stylesheet">
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      background: #0a0a0f;
      min-height: 100vh;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      font-family: 'Press Start 2P', monospace;
      overflow: hidden;
    }

    .game-container {
      position: relative;
      width: 100%;
      max-width: 800px;
    }

    #gameCanvas {
      display: block;
      width: 100%;
      height: auto;
      border: 3px solid #ff00ff;
      box-shadow:
        0 0 20px #ff00ff,
        0 0 40px #ff00ff44,
        inset 0 0 60px rgba(255, 0, 255, 0.1);
      background: linear-gradient(180deg, #0a0a1a 0%, #1a0a2a 100%);
    }

    .hud {
      display: flex;
      justify-content: space-between;
      padding: 10px 20px;
      color: #0ff;
      font-size: 12px;
      text-shadow: 0 0 10px #0ff;
      max-width: 800px;
      width: 100%;
    }

    .lives {
      color: #ff0066;
      text-shadow: 0 0 10px #ff0066;
    }

    .title {
      font-family: 'Orbitron', sans-serif;
      font-size: 28px;
      font-weight: 900;
      color: #ff6600;
      text-shadow:
        0 0 10px #ff6600,
        0 0 20px #ff6600,
        0 0 40px #ff330088;
      margin-bottom: 10px;
      letter-spacing: 4px;
    }

    .start-screen, .game-over-screen {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      background: rgba(10, 10, 20, 0.95);
      z-index: 10;
    }

    .start-screen h1 {
      font-family: 'Orbitron', sans-serif;
      font-size: 36px;
      color: #ff6600;
      text-shadow: 0 0 20px #ff6600, 0 0 40px #ff3300;
      margin-bottom: 20px;
    }

    .start-screen p, .game-over-screen p {
      color: #0ff;
      font-size: 10px;
      margin: 10px;
      text-shadow: 0 0 10px #0ff;
    }

    .game-over-screen h1 {
      font-family: 'Orbitron', sans-serif;
      font-size: 32px;
      color: #ff0044;
      text-shadow: 0 0 20px #ff0044;
      margin-bottom: 10px;
    }

    .final-score {
      font-size: 18px;
      color: #ffff00;
      text-shadow: 0 0 15px #ffff00;
      margin: 15px 0;
    }

    .btn {
      margin-top: 20px;
      padding: 15px 30px;
      font-family: 'Press Start 2P', monospace;
      font-size: 14px;
      background: transparent;
      color: #0f0;
      border: 3px solid #0f0;
      cursor: pointer;
      text-shadow: 0 0 10px #0f0;
      box-shadow: 0 0 20px #0f044;
      transition: all 0.2s;
    }

    .btn:hover {
      background: #0f0;
      color: #000;
      box-shadow: 0 0 30px #0f0;
    }

    .controls-hint {
      position: fixed;
      bottom: 10px;
      left: 50%;
      transform: translateX(-50%);
      color: #666;
      font-size: 8px;
      text-align: center;
    }

    .mobile-controls {
      display: none;
      position: fixed;
      bottom: 20px;
      width: 100%;
      max-width: 800px;
      justify-content: space-between;
      padding: 0 20px;
    }

    .mobile-btn {
      width: 70px;
      height: 70px;
      border-radius: 50%;
      border: 3px solid #0ff;
      background: rgba(0, 255, 255, 0.1);
      color: #0ff;
      font-size: 24px;
      display: flex;
      align-items: center;
      justify-content: center;
      user-select: none;
      -webkit-user-select: none;
      touch-action: manipulation;
    }

    .mobile-btn:active {
      background: rgba(0, 255, 255, 0.4);
      box-shadow: 0 0 20px #0ff;
    }

    .jump-btn {
      border-color: #0f0;
      color: #0f0;
      background: rgba(0, 255, 0, 0.1);
    }

    .jump-btn:active {
      background: rgba(0, 255, 0, 0.4);
      box-shadow: 0 0 20px #0f0;
    }

    @media (max-width: 600px) {
      .title { font-size: 20px; }
      .hud { font-size: 10px; }
      .start-screen h1 { font-size: 24px; }
      .start-screen p { font-size: 8px; }
      .mobile-controls { display: flex; }
      .controls-hint { display: none; }
    }

    .backlink {
      position: fixed;
      bottom: 30px;
      color: #444;
      font-size: 8px;
      text-decoration: none;
    }

    .backlink:hover {
      color: #0ff;
    }

    .hidden { display: none !important; }
  </style>
</head>
<body>
  <div class="title">NEON CRASH</div>

  <div class="hud">
    <span class="score">SCORE: <span id="score">0</span></span>
    <span class="lives">LIVES: <span id="lives">3</span></span>
  </div>

  <div class="game-container">
    <canvas id="gameCanvas" width="800" height="400"></canvas>

    <div class="start-screen" id="startScreen">
      <h1>NEON CRASH</h1>
      <p>JUMP OVER CRATES FOR POINTS</p>
      <p style="color: #ff0044;">AVOID NITRO BOXES!</p>
      <p style="color: #ff6600; margin-top: 20px;">ARROWS/WASD TO MOVE</p>
      <p style="color: #0f0;">SPACE/UP TO JUMP</p>
      <button class="btn" id="startBtn">START GAME</button>
    </div>

    <div class="game-over-screen hidden" id="gameOverScreen">
      <h1>GAME OVER</h1>
      <p class="final-score">SCORE: <span id="finalScore">0</span></p>
      <p id="highScoreMsg" style="color: #ff6600;"></p>
      <button class="btn" id="restartBtn">PLAY AGAIN</button>
    </div>
  </div>

  <div class="mobile-controls" id="mobileControls">
    <div style="display: flex; gap: 10px;">
      <button class="mobile-btn" id="leftBtn">â—€</button>
      <button class="mobile-btn" id="rightBtn">â–¶</button>
    </div>
    <button class="mobile-btn jump-btn" id="jumpBtn">â–²</button>
  </div>

  <div class="controls-hint">ARROWS/WASD to move â€¢ SPACE to jump</div>
  <a href="https://sloppy.live" class="backlink">sloppy.live</a>

  <script>
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');

    // Game state
    let gameRunning = false;
    let score = 0;
    let lives = 3;
    let highScore = localStorage.getItem('neonCrashHighScore') || 0;
    let gameSpeed = 5;
    let frameCount = 0;

    // Player
    const player = {
      x: 100,
      y: 300,
      width: 40,
      height: 50,
      velocityY: 0,
      velocityX: 0,
      jumping: false,
      grounded: false,
      color: '#0ff',
      glowColor: '#0ff'
    };

    // Physics
    const gravity = 0.8;
    const jumpForce = -15;
    const moveSpeed = 6;
    const friction = 0.85;

    // Ground
    const groundY = 350;

    // Obstacles
    let obstacles = [];
    let platforms = [];

    // Controls
    const keys = {
      left: false,
      right: false,
      jump: false
    };

    // Initialize game
    function init() {
      obstacles = [];
      platforms = [];
      player.x = 100;
      player.y = 300;
      player.velocityX = 0;
      player.velocityY = 0;
      player.grounded = false;
      score = 0;
      lives = 3;
      gameSpeed = 5;
      frameCount = 0;
      updateHUD();

      // Generate initial obstacles
      for (let i = 0; i < 5; i++) {
        generateObstacle(400 + i * 250);
      }
    }

    function generateObstacle(x) {
      const rand = Math.random();

      if (rand < 0.4) {
        // Regular crate
        obstacles.push({
          x: x,
          y: groundY - 40,
          width: 40,
          height: 40,
          type: 'crate',
          scored: false
        });
      } else if (rand < 0.65) {
        // Nitro box
        obstacles.push({
          x: x,
          y: groundY - 40,
          width: 40,
          height: 40,
          type: 'nitro',
          pulsePhase: Math.random() * Math.PI * 2
        });
      } else if (rand < 0.85) {
        // Stack of crates
        const height = Math.floor(Math.random() * 2) + 2;
        for (let i = 0; i < height; i++) {
          obstacles.push({
            x: x,
            y: groundY - 40 - (i * 40),
            width: 40,
            height: 40,
            type: 'crate',
            scored: false
          });
        }
      } else {
        // Platform with crate on top
        platforms.push({
          x: x,
          y: groundY - 100,
          width: 120,
          height: 20
        });
        obstacles.push({
          x: x + 40,
          y: groundY - 140,
          width: 40,
          height: 40,
          type: 'crate',
          scored: false
        });
      }
    }

    function update() {
      if (!gameRunning) return;

      frameCount++;

      // Increase difficulty
      if (frameCount % 500 === 0) {
        gameSpeed = Math.min(gameSpeed + 0.5, 12);
      }

      // Player horizontal movement
      if (keys.left) {
        player.velocityX = -moveSpeed;
      } else if (keys.right) {
        player.velocityX = moveSpeed;
      } else {
        player.velocityX *= friction;
      }

      // Jump
      if (keys.jump && player.grounded) {
        player.velocityY = jumpForce;
        player.grounded = false;
        player.jumping = true;
      }

      // Apply gravity
      player.velocityY += gravity;

      // Update position
      player.x += player.velocityX;
      player.y += player.velocityY;

      // Keep player in bounds
      if (player.x < 20) player.x = 20;
      if (player.x > canvas.width - player.width - 20) {
        player.x = canvas.width - player.width - 20;
      }

      // Ground collision
      if (player.y >= groundY - player.height) {
        player.y = groundY - player.height;
        player.velocityY = 0;
        player.grounded = true;
        player.jumping = false;
      }

      // Platform collision
      player.grounded = player.y >= groundY - player.height;

      for (const plat of platforms) {
        if (player.velocityY > 0 &&
            player.x + player.width > plat.x &&
            player.x < plat.x + plat.width &&
            player.y + player.height >= plat.y &&
            player.y + player.height <= plat.y + plat.height + 10) {
          player.y = plat.y - player.height;
          player.velocityY = 0;
          player.grounded = true;
          player.jumping = false;
        }
      }

      // Move obstacles
      for (const obs of obstacles) {
        obs.x -= gameSpeed;

        // Check collision
        if (checkCollision(player, obs)) {
          if (obs.type === 'nitro') {
            triggerExplosion(obs.x, obs.y);
            loseLife();
          }
        }

        // Score for passing crates
        if (obs.type === 'crate' && !obs.scored && obs.x + obs.width < player.x) {
          obs.scored = true;
          score += 10;
          updateHUD();
        }
      }

      // Move platforms
      for (const plat of platforms) {
        plat.x -= gameSpeed;
      }

      // Remove off-screen obstacles
      obstacles = obstacles.filter(o => o.x > -50);
      platforms = platforms.filter(p => p.x > -150);

      // Generate new obstacles
      const lastObs = obstacles[obstacles.length - 1];
      const lastPlat = platforms[platforms.length - 1];
      const rightMost = Math.max(
        lastObs ? lastObs.x : 0,
        lastPlat ? lastPlat.x : 0
      );

      if (rightMost < canvas.width + 200) {
        generateObstacle(rightMost + 200 + Math.random() * 150);
      }
    }

    function checkCollision(a, b) {
      const padding = 5;
      return a.x + padding < b.x + b.width - padding &&
             a.x + a.width - padding > b.x + padding &&
             a.y + padding < b.y + b.height - padding &&
             a.y + a.height - padding > b.y + padding;
    }

    let explosions = [];

    function triggerExplosion(x, y) {
      explosions.push({
        x: x + 20,
        y: y + 20,
        radius: 10,
        maxRadius: 80,
        alpha: 1
      });
    }

    function loseLife() {
      lives--;
      updateHUD();

      if (lives <= 0) {
        gameOver();
      } else {
        // Brief invincibility and reset position
        player.x = 100;
        player.y = groundY - player.height;
        player.velocityX = 0;
        player.velocityY = 0;
      }
    }

    function gameOver() {
      gameRunning = false;

      if (score > highScore) {
        highScore = score;
        localStorage.setItem('neonCrashHighScore', highScore);
        document.getElementById('highScoreMsg').textContent = 'NEW HIGH SCORE!';
      } else {
        document.getElementById('highScoreMsg').textContent = `HIGH SCORE: ${highScore}`;
      }

      document.getElementById('finalScore').textContent = score;
      document.getElementById('gameOverScreen').classList.remove('hidden');
    }

    function updateHUD() {
      document.getElementById('score').textContent = score;
      document.getElementById('lives').textContent = lives;
    }

    function draw() {
      // Clear
      ctx.fillStyle = '#0a0a1a';
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      // Draw starfield background
      ctx.fillStyle = '#ffffff22';
      for (let i = 0; i < 50; i++) {
        const starX = (i * 73 + frameCount * 0.5) % canvas.width;
        const starY = (i * 37) % (groundY - 50);
        ctx.fillRect(starX, starY, 2, 2);
      }

      // Draw ground
      ctx.fillStyle = '#1a0a2a';
      ctx.fillRect(0, groundY, canvas.width, canvas.height - groundY);

      // Ground line with glow
      ctx.strokeStyle = '#ff00ff';
      ctx.lineWidth = 3;
      ctx.shadowColor = '#ff00ff';
      ctx.shadowBlur = 20;
      ctx.beginPath();
      ctx.moveTo(0, groundY);
      ctx.lineTo(canvas.width, groundY);
      ctx.stroke();
      ctx.shadowBlur = 0;

      // Draw platforms
      for (const plat of platforms) {
        ctx.fillStyle = '#330066';
        ctx.fillRect(plat.x, plat.y, plat.width, plat.height);

        ctx.strokeStyle = '#9900ff';
        ctx.lineWidth = 2;
        ctx.shadowColor = '#9900ff';
        ctx.shadowBlur = 10;
        ctx.strokeRect(plat.x, plat.y, plat.width, plat.height);
        ctx.shadowBlur = 0;
      }

      // Draw obstacles
      for (const obs of obstacles) {
        if (obs.type === 'crate') {
          // Regular crate - orange/gold
          ctx.fillStyle = '#331a00';
          ctx.fillRect(obs.x, obs.y, obs.width, obs.height);

          ctx.strokeStyle = '#ff9900';
          ctx.lineWidth = 3;
          ctx.shadowColor = '#ff9900';
          ctx.shadowBlur = 15;
          ctx.strokeRect(obs.x, obs.y, obs.width, obs.height);

          // Crate pattern
          ctx.beginPath();
          ctx.moveTo(obs.x, obs.y);
          ctx.lineTo(obs.x + obs.width, obs.y + obs.height);
          ctx.moveTo(obs.x + obs.width, obs.y);
          ctx.lineTo(obs.x, obs.y + obs.height);
          ctx.strokeStyle = '#ff990066';
          ctx.lineWidth = 2;
          ctx.stroke();
          ctx.shadowBlur = 0;

        } else if (obs.type === 'nitro') {
          // Nitro box - red with pulse
          obs.pulsePhase += 0.15;
          const pulse = Math.sin(obs.pulsePhase) * 0.3 + 0.7;

          ctx.fillStyle = `rgba(50, 0, 0, ${pulse})`;
          ctx.fillRect(obs.x, obs.y, obs.width, obs.height);

          ctx.strokeStyle = '#ff0044';
          ctx.lineWidth = 3;
          ctx.shadowColor = '#ff0044';
          ctx.shadowBlur = 20 * pulse;
          ctx.strokeRect(obs.x, obs.y, obs.width, obs.height);

          // NITRO text
          ctx.fillStyle = '#ff0044';
          ctx.font = 'bold 10px Arial';
          ctx.textAlign = 'center';
          ctx.shadowBlur = 10;
          ctx.fillText('NITRO', obs.x + obs.width/2, obs.y + obs.height/2 + 4);
          ctx.shadowBlur = 0;
        }
      }

      // Draw explosions
      for (let i = explosions.length - 1; i >= 0; i--) {
        const exp = explosions[i];
        exp.radius += 5;
        exp.alpha -= 0.05;

        if (exp.alpha <= 0) {
          explosions.splice(i, 1);
          continue;
        }

        const gradient = ctx.createRadialGradient(
          exp.x, exp.y, 0,
          exp.x, exp.y, exp.radius
        );
        gradient.addColorStop(0, `rgba(255, 255, 0, ${exp.alpha})`);
        gradient.addColorStop(0.5, `rgba(255, 100, 0, ${exp.alpha * 0.7})`);
        gradient.addColorStop(1, `rgba(255, 0, 0, 0)`);

        ctx.fillStyle = gradient;
        ctx.beginPath();
        ctx.arc(exp.x, exp.y, exp.radius, 0, Math.PI * 2);
        ctx.fill();
      }

      // Draw player
      ctx.fillStyle = player.jumping ? '#00ffaa' : '#0ff';
      ctx.shadowColor = player.jumping ? '#00ffaa' : '#0ff';
      ctx.shadowBlur = 20;

      // Body
      ctx.fillRect(player.x + 10, player.y + 15, 20, 35);

      // Head
      ctx.beginPath();
      ctx.arc(player.x + 20, player.y + 10, 12, 0, Math.PI * 2);
      ctx.fill();

      // Eyes
      ctx.fillStyle = '#000';
      ctx.shadowBlur = 0;
      ctx.fillRect(player.x + 14, player.y + 6, 4, 4);
      ctx.fillRect(player.x + 22, player.y + 6, 4, 4);

      // Legs (animated)
      ctx.fillStyle = player.jumping ? '#00ffaa' : '#0ff';
      ctx.shadowColor = player.jumping ? '#00ffaa' : '#0ff';
      ctx.shadowBlur = 10;

      if (player.jumping) {
        // Tucked legs while jumping
        ctx.fillRect(player.x + 8, player.y + 40, 10, 10);
        ctx.fillRect(player.x + 22, player.y + 40, 10, 10);
      } else {
        // Running animation
        const legOffset = Math.sin(frameCount * 0.3) * 5;
        ctx.fillRect(player.x + 10, player.y + 45, 8, 8);
        ctx.fillRect(player.x + 22, player.y + 45, 8, 8);
      }

      ctx.shadowBlur = 0;

      // Draw distance marker
      ctx.fillStyle = '#666';
      ctx.font = '10px "Press Start 2P"';
      ctx.textAlign = 'right';
      ctx.fillText(`${Math.floor(frameCount / 10)}m`, canvas.width - 10, 20);
    }

    function gameLoop() {
      update();
      draw();
      requestAnimationFrame(gameLoop);
    }

    // Controls
    document.addEventListener('keydown', (e) => {
      if (e.code === 'ArrowLeft' || e.code === 'KeyA') keys.left = true;
      if (e.code === 'ArrowRight' || e.code === 'KeyD') keys.right = true;
      if (e.code === 'Space' || e.code === 'ArrowUp' || e.code === 'KeyW') {
        keys.jump = true;
        e.preventDefault();
      }
    });

    document.addEventListener('keyup', (e) => {
      if (e.code === 'ArrowLeft' || e.code === 'KeyA') keys.left = false;
      if (e.code === 'ArrowRight' || e.code === 'KeyD') keys.right = false;
      if (e.code === 'Space' || e.code === 'ArrowUp' || e.code === 'KeyW') keys.jump = false;
    });

    // Mobile controls
    const leftBtn = document.getElementById('leftBtn');
    const rightBtn = document.getElementById('rightBtn');
    const jumpBtn = document.getElementById('jumpBtn');

    leftBtn.addEventListener('touchstart', (e) => { e.preventDefault(); keys.left = true; });
    leftBtn.addEventListener('touchend', () => keys.left = false);
    rightBtn.addEventListener('touchstart', (e) => { e.preventDefault(); keys.right = true; });
    rightBtn.addEventListener('touchend', () => keys.right = false);
    jumpBtn.addEventListener('touchstart', (e) => { e.preventDefault(); keys.jump = true; });
    jumpBtn.addEventListener('touchend', () => keys.jump = false);

    // Start/Restart buttons
    document.getElementById('startBtn').addEventListener('click', () => {
      document.getElementById('startScreen').classList.add('hidden');
      init();
      gameRunning = true;
    });

    document.getElementById('restartBtn').addEventListener('click', () => {
      document.getElementById('gameOverScreen').classList.add('hidden');
      init();
      gameRunning = true;
    });

    // Start game loop
    gameLoop();
  </script>
<script src="/sloppy-header/sloppy-bar.js"></script>
</body>
</html>
