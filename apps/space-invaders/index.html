<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SPACE_INVADERS.SYS</title>
    <meta name="description" content="Defend against the alien invasion! Classic Space Invaders with terminal ASCII aesthetic." />
    <meta property="og:title" content="SPACE_INVADERS.SYS - ASCII Terminal Shooter">
    <meta property="og:description" content="Defend against the alien invasion! Classic Space Invaders with terminal ASCII aesthetic.">
    <meta property="og:type" content="website" />
    <meta property="og:image" content="https://app.sloppy.live/space-invaders/og-image.png">
    <meta property="og:url" content="https://app.sloppy.live/space-invaders" />
    <meta name="twitter:card" content="summary_large_image" />
    <meta name="twitter:title" content="SPACE_INVADERS.SYS - ASCII Terminal Shooter" />
    <meta name="twitter:description" content="Defend against the alien invasion! Classic Space Invaders with terminal ASCII aesthetic." />
    <meta name="twitter:image" content="https://app.sloppy.live/space-invaders/og-image.png" />
    <link rel="icon" href="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 64 64'%3E%3Ctext x='8' y='52' font-size='48'%3E%F0%9F%9A%80%3C/text%3E%3C/svg%3E" />
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Share+Tech+Mono&display=swap');

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background: #000;
            color: #00ff00;
            font-family: 'Share Tech Mono', monospace;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            flex-direction: column;
            padding: 20px;
            position: relative;
        }

        body::before {
            content: '';
            position: fixed;
            inset: 0;
            background: repeating-linear-gradient(
                0deg,
                rgba(0, 255, 0, 0.02) 0px,
                rgba(0, 255, 0, 0.02) 1px,
                transparent 1px,
                transparent 3px
            );
            pointer-events: none;
            z-index: 9999;
        }

        body::after {
            content: '';
            position: fixed;
            inset: 0;
            background: radial-gradient(ellipse at center, transparent 40%, rgba(0,0,0,0.6) 100%);
            pointer-events: none;
        }

        .terminal-container {
            background: linear-gradient(180deg, #0d0d0d, #050505);
            border: 2px solid #00ff00;
            padding: 25px;
            box-shadow: 0 0 60px rgba(0, 255, 0, 0.25), inset 0 0 100px rgba(0, 255, 0, 0.03);
            max-width: 700px;
            width: 100%;
            border-radius: 4px;
            position: relative;
        }

        .header {
            text-align: center;
            margin-bottom: 20px;
            border-bottom: 1px solid #00ff00;
            padding-bottom: 10px;
        }

        h1 {
            font-size: 26px;
            text-shadow: 0 0 30px #00ff00, 0 0 60px rgba(0,255,0,0.4);
            margin-bottom: 5px;
            letter-spacing: 3px;
            animation: terminal-flicker 4s ease-in-out infinite;
        }

        @keyframes terminal-flicker {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.95; }
            52% { opacity: 1; }
            54% { opacity: 0.97; }
        }

        .system-status {
            font-size: 12px;
            opacity: 0.7;
            animation: pulse 2s infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 0.7; }
            50% { opacity: 1; }
        }

        .stats {
            display: flex;
            justify-content: space-between;
            margin: 15px 0;
            padding: 10px;
            background: #000;
            border: 1px solid #00ff00;
        }

        .stat {
            text-align: center;
            flex: 1;
        }

        .stat-label {
            font-size: 12px;
            opacity: 0.7;
        }

        .stat-value {
            font-size: 20px;
            font-weight: bold;
            text-shadow: 0 0 10px #00ff00;
        }

        canvas {
            border: 2px solid #00ff00;
            background: #000;
            display: block;
            margin: 0 auto;
            box-shadow: 0 0 30px rgba(0, 255, 0, 0.2);
            image-rendering: pixelated;
        }

        .controls {
            border: 1px solid #00ff00;
            padding: 15px;
            margin: 20px 0;
            background: #000;
            text-align: center;
        }

        .control-item {
            font-size: 12px;
            margin: 5px 0;
            opacity: 0.8;
        }

        .control-key {
            color: #00ff00;
            font-weight: bold;
            background: #0a0a0a;
            padding: 2px 8px;
            border: 1px solid #00ff00;
            display: inline-block;
        }

        .wave-indicator {
            text-align: center;
            margin: 10px 0;
            font-size: 14px;
            color: #ffff00;
            text-shadow: 0 0 10px #ffff00;
            min-height: 20px;
        }

        .game-message {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: #000;
            border: 3px solid #00ff00;
            padding: 30px;
            text-align: center;
            display: none;
            z-index: 1000;
            box-shadow: 0 0 50px rgba(0, 255, 0, 0.5);
        }

        .game-message.show {
            display: block;
        }

        .game-message h2 {
            font-size: 28px;
            margin-bottom: 15px;
            text-shadow: 0 0 20px #00ff00;
        }

        .game-message p {
            font-size: 16px;
            margin: 10px 0;
            opacity: 0.9;
        }

        .play-btn {
            background: linear-gradient(180deg, #00ff00, #00cc00);
            color: #000;
            border: none;
            padding: 14px 35px;
            font-family: inherit;
            font-size: 16px;
            font-weight: bold;
            cursor: pointer;
            margin-top: 20px;
            text-transform: uppercase;
            transition: all 0.3s cubic-bezier(.4,0,.2,1);
            box-shadow: 0 0 20px rgba(0,255,0,0.4);
            letter-spacing: 2px;
        }

        .play-btn:hover {
            background: linear-gradient(180deg, #00ff00, #00dd00);
            box-shadow: 0 0 40px rgba(0,255,0,0.6), 0 4px 15px rgba(0,0,0,0.3);
            transform: translateY(-2px);
        }

        .play-btn:active {
            transform: translateY(0);
            box-shadow: 0 0 15px rgba(0,255,0,0.4);
        }

        .backlink {
            text-align: center;
            font-size: 12px;
            margin-top: 15px;
        }

        .backlink a {
            color: #00ff00;
            opacity: 0.7;
            text-decoration: none;
        }

        .backlink a:hover {
            opacity: 1;
            text-shadow: 0 0 5px #00ff00;
        }

        .leaderboard {
            border: 1px solid #00ff00;
            padding: 15px;
            margin: 20px 0 0;
            background: #000;
        }
        .leaderboard h3 {
            margin-bottom: 10px;
            font-size: 14px;
            letter-spacing: 1px;
        }
        .leaderboard ol {
            margin-left: 20px;
        }
        .leaderboard li {
            margin: 4px 0;
            font-size: 13px;
        }
        .score-form {
            margin-top: 10px;
        }
        .score-form input {
            font-family: inherit;
            background: #000;
            color: #00ff00;
            border: 1px solid #00ff00;
            padding: 6px 8px;
            width: 220px;
            margin-right: 8px;
        }
        .score-form button {
            background: #00ff00;
            color: #000;
            border: none;
            padding: 7px 12px;
            font-family: inherit;
            cursor: pointer;
            font-weight: bold;
        }
        .score-status {
            font-size: 12px;
            margin-top: 8px;
            min-height: 16px;
        }

        @media (max-width: 600px) {
            h1 {
                font-size: 20px;
            }

            .stats {
                font-size: 12px;
            }

            canvas {
                max-width: 100%;
                height: auto;
            }
        }
    </style>
</head>
<body>
    <div class="terminal-container">
        <div class="header">
            <h1>&gt; SPACE_INVADERS.SYS</h1>
            <div class="system-status">DEFENSE.PROTOCOL.ACTIVE</div>
        </div>

        <div class="stats">
            <div class="stat">
                <div class="stat-label">SCORE</div>
                <div class="stat-value" id="score">0</div>
            </div>
            <div class="stat">
                <div class="stat-label">WAVE</div>
                <div class="stat-value" id="wave">1</div>
            </div>
            <div class="stat">
                <div class="stat-label">LIVES</div>
                <div class="stat-value" id="lives">3</div>
            </div>
            <div class="stat">
                <div class="stat-label">HIGH</div>
                <div class="stat-value" id="highScore">0</div>
            </div>
        </div>

        <canvas id="gameCanvas" width="600" height="400"></canvas>

        <div class="wave-indicator" id="waveIndicator"></div>

        <div class="controls">
            <div class="control-item"><span class="control-key">‚Üê ‚Üí</span> or <span class="control-key">A D</span> MOVE SHIP</div>
            <div class="control-item"><span class="control-key">SPACE</span> FIRE LASER</div>
            <div class="control-item"><span class="control-key">P</span> PAUSE</div>
            <div class="control-item">TOUCH/DRAG on mobile</div>
        </div>

        <div class="leaderboard">
            <h3>&gt; LEADERBOARD</h3>
            <ol id="leaderboardList"></ol>
        </div>

        <div class="backlink">
            <a href="http://sloppy.live" target="_blank">&gt; sloppy.live</a> | <a href="https://app.sloppy.live/overview" style="color:#4ecdc4;text-decoration:none">üé® View All Apps</a>
        </div>
    </div>
    <div id="errorBox" style="display:none; position:fixed; left:10px; bottom:10px; max-width:90vw; max-height:35vh; overflow:auto; background:#000; border:1px solid #ff4444; color:#ff6666; padding:8px; font-family:monospace; font-size:12px; z-index:2000;">
        <div style="color:#ffaaaa; margin-bottom:6px;">Errors / Logs</div>
        <pre id="errorLog" style="white-space:pre-wrap"></pre>
    </div>

    <div class="game-message" id="gameMessage">
        <h2 id="messageTitle">SPACE_INVADERS.SYS</h2>
        <p id="messageText">ALIEN THREAT DETECTED</p>
        <p id="messageScore"></p>
        <button class="play-btn" id="playBtn">DEPLOY</button>
        <div id="scoreForm" class="score-form" style="display:none;">
            <input type="text" id="playerName" maxlength="20" placeholder="CALLSIGN"/>
            <button id="saveScoreBtn">LOG SCORE</button>
            <div id="saveStatus" class="score-status"></div>
        </div>
    </div>

    <script type="module">
        const errorBox = document.getElementById('errorBox');
        const errorLog = document.getElementById('errorLog');
        function logError(msg) {
            try {
                if (!errorBox || !errorLog) return;
                errorBox.style.display = 'block';
                const line = `[${new Date().toLocaleTimeString()}] ${msg}`;
                errorLog.textContent += (errorLog.textContent ? '\n' : '') + line;
            } catch {}
        }
        window.addEventListener('error', (e) => {
            logError(e?.message || 'Unknown script error');
        });
        window.addEventListener('unhandledrejection', (e) => {
            logError(e?.reason?.message || String(e?.reason || 'Unhandled rejection'));
        });

        let supabase = null;
        let currentUser = null;
        try {
            // Dynamic import to avoid hard failure if the file isn't served as a module
            const mod = await import('../../supabase-config.js');
            const sess = await mod.supabaseSession();
            supabase = sess.client;
            currentUser = sess.user;
        } catch (e) {
            console.error('Supabase session error:', e);
            logError(`Supabase unavailable ‚Äî continuing without cloud: ${e?.message || e}`);
        }

        const canvas = document.getElementById('gameCanvas');
        if (!canvas) {
            logError('Canvas element not found');
            throw new Error('Canvas not found');
        }
        const ctx = canvas.getContext('2d');
        if (!ctx) {
            logError('2D context not available');
            throw new Error('2D context not available');
        }

        let gameRunning = false;
        let paused = false;
        let score = 0;
        let wave = 1;
        let lives = 3;
        let highScore = localStorage.getItem('spaceInvadersHighScore') || 0;

        const player = {
            x: canvas.width / 2 - 20,
            y: canvas.height - 60,
            width: 40,
            height: 30,
            speed: 5
        };

        const invaderRows = 5;
        const invaderCols = 11;
        let invaders = [];
        let invaderDirection = 1;
        let invaderSpeed = 0.5;
        let invaderDropDistance = 20;

        let bullets = [];
        let invaderBullets = [];
        let lastShot = 0;
        let shotCooldown = 250;

        const keys = {};

        const invaderTypes = [
            { char: '‚ñº', points: 10 },
            { char: '‚óÜ', points: 20 },
            { char: '‚ñ≤', points: 30 }
        ];

        const barriers = [];
        const barrierWidth = 60;
        const barrierHeight = 40;

        function initInvaders() {
            invaders = [];
            for (let row = 0; row < invaderRows; row++) {
                for (let col = 0; col < invaderCols; col++) {
                    const type = row < 2 ? 2 : row < 4 ? 1 : 0;
                    invaders.push({
                        x: col * 45 + 50,
                        y: row * 35 + 50,
                        width: 30,
                        height: 20,
                        type: type,
                        alive: true,
                        animFrame: 0
                    });
                }
            }
        }

        function initBarriers() {
            barriers.length = 0;
            const barrierCount = 4;
            const spacing = canvas.width / (barrierCount + 1);

            for (let i = 0; i < barrierCount; i++) {
                barriers.push({
                    x: spacing * (i + 1) - barrierWidth / 2,
                    y: canvas.height - 120,
                    width: barrierWidth,
                    height: barrierHeight,
                    hits: Array(barrierWidth).fill(null).map(() => Array(barrierHeight).fill(true))
                });
            }
        }

        function updateHighScore() {
            if (score > highScore) {
                highScore = score;
                localStorage.setItem('spaceInvadersHighScore', highScore);
                document.getElementById('highScore').textContent = highScore;
            }
        }

        function startGame() {
            score = 0;
            wave = 1;
            lives = 3;
            gameRunning = true;
            invaderSpeed = 0.5;
            initInvaders();
            initBarriers();
            bullets = [];
            invaderBullets = [];
            player.x = canvas.width / 2 - 20;
            updateDisplay();
            document.getElementById('gameMessage').classList.remove('show');
            document.getElementById('highScore').textContent = highScore;
        }

        function nextWave() {
            wave++;
            invaderSpeed = 0.5 + (wave - 1) * 0.2;
            initInvaders();
            bullets = [];
            invaderBullets = [];
            updateDisplay();
            showWaveMessage();
        }

        function showWaveMessage() {
            document.getElementById('waveIndicator').textContent = `WAVE ${wave} INCOMING`;
            setTimeout(() => {
                document.getElementById('waveIndicator').textContent = '';
            }, 2000);
        }

        async function gameOver() {
            gameRunning = false;
            updateHighScore();
            document.getElementById('messageTitle').textContent = 'INVASION COMPLETE';
            document.getElementById('messageText').textContent = lives > 0 ? 'EARTH DEFENDED' : 'EARTH FALLEN';
            document.getElementById('messageScore').textContent = 'FINAL SCORE: ' + score;
            document.getElementById('gameMessage').classList.add('show');

            // Show score submission UI
            const scoreForm = document.getElementById('scoreForm');
            if (scoreForm) scoreForm.style.display = 'block';
            const playerNameEl = document.getElementById('playerName');
            if (playerNameEl && !playerNameEl.value) {
                playerNameEl.value = 'PILOT-' + Math.floor(Math.random()*1000).toString().padStart(3, '0');
            }
            // Attempt to pre-save best effort if name provided and supabase ready
            // Wait for user click to confirm save
        }

        function updateDisplay() {
            document.getElementById('score').textContent = score;
            document.getElementById('wave').textContent = wave;
            document.getElementById('lives').textContent = lives;
        }

        function shoot() {
            const now = Date.now();
            if (now - lastShot > shotCooldown) {
                bullets.push({
                    x: player.x + player.width / 2 - 2,
                    y: player.y,
                    width: 4,
                    height: 10,
                    speed: 8
                });
                lastShot = now;
            }
        }

        function invaderShoot() {
            const aliveInvaders = invaders.filter(i => i.alive);
            if (aliveInvaders.length > 0 && Math.random() < 0.002 * wave) {
                const shooter = aliveInvaders[Math.floor(Math.random() * aliveInvaders.length)];
                invaderBullets.push({
                    x: shooter.x + shooter.width / 2 - 2,
                    y: shooter.y + shooter.height,
                    width: 4,
                    height: 8,
                    speed: 3
                });
            }
        }

        function drawPlayer() {
            ctx.fillStyle = '#00ff00';
            ctx.fillRect(player.x, player.y, player.width, 5);
            ctx.fillRect(player.x + 5, player.y - 5, player.width - 10, 5);
            ctx.fillRect(player.x + 15, player.y - 10, 10, 5);
            ctx.fillRect(player.x + 18, player.y - 15, 4, 5);
        }

        function drawInvaders() {
            ctx.font = '20px Share Tech Mono';
            invaders.forEach(invader => {
                if (invader.alive) {
                    ctx.fillStyle = '#00ff00';
                    ctx.fillText(
                        invaderTypes[invader.type].char,
                        invader.x + 5,
                        invader.y + 15
                    );
                }
            });
        }

        function drawBarriers() {
            ctx.fillStyle = '#00ff00';
            barriers.forEach(barrier => {
                for (let x = 0; x < barrier.width; x += 2) {
                    for (let y = 0; y < barrier.height; y += 2) {
                        if (barrier.hits[x] && barrier.hits[x][y]) {
                            ctx.fillRect(barrier.x + x, barrier.y + y, 2, 2);
                        }
                    }
                }
            });
        }

        function damageBarrier(barrier, impactX, impactY) {
            const relX = Math.floor(impactX - barrier.x);
            const relY = Math.floor(impactY - barrier.y);
            const radius = 8;

            for (let x = Math.max(0, relX - radius); x < Math.min(barrier.width, relX + radius); x++) {
                for (let y = Math.max(0, relY - radius); y < Math.min(barrier.height, relY + radius); y++) {
                    const dist = Math.sqrt(Math.pow(x - relX, 2) + Math.pow(y - relY, 2));
                    if (dist < radius && barrier.hits[x]) {
                        barrier.hits[x][y] = false;
                    }
                }
            }
        }

        function drawBullets() {
            ctx.fillStyle = '#00ff00';
            bullets.forEach(bullet => {
                ctx.fillRect(bullet.x, bullet.y, bullet.width, bullet.height);
            });

            ctx.fillStyle = '#ff0000';
            invaderBullets.forEach(bullet => {
                ctx.fillRect(bullet.x, bullet.y, bullet.width, bullet.height);
            });
        }

        function checkCollisions() {
            bullets = bullets.filter(bullet => {
                let hit = false;

                invaders.forEach(invader => {
                    if (invader.alive &&
                        bullet.x < invader.x + invader.width &&
                        bullet.x + bullet.width > invader.x &&
                        bullet.y < invader.y + invader.height &&
                        bullet.y + bullet.height > invader.y) {

                        invader.alive = false;
                        score += invaderTypes[invader.type].points;
                        updateDisplay();
                        hit = true;
                    }
                });

                barriers.forEach(barrier => {
                    if (bullet.x < barrier.x + barrier.width &&
                        bullet.x + bullet.width > barrier.x &&
                        bullet.y < barrier.y + barrier.height &&
                        bullet.y + bullet.height > barrier.y) {

                        damageBarrier(barrier, bullet.x + bullet.width/2, bullet.y);
                        hit = true;
                    }
                });

                return !hit && bullet.y > 0;
            });

            invaderBullets = invaderBullets.filter(bullet => {
                let hit = false;

                if (bullet.x < player.x + player.width &&
                    bullet.x + bullet.width > player.x &&
                    bullet.y < player.y + player.height &&
                    bullet.y + bullet.height > player.y) {

                    lives--;
                    updateDisplay();
                    hit = true;

                    if (lives <= 0) {
                        gameOver();
                    }
                }

                barriers.forEach(barrier => {
                    if (bullet.x < barrier.x + barrier.width &&
                        bullet.x + bullet.width > barrier.x &&
                        bullet.y < barrier.y + barrier.height &&
                        bullet.y + bullet.height > barrier.y) {

                        damageBarrier(barrier, bullet.x + bullet.width/2, bullet.y);
                        hit = true;
                    }
                });

                return !hit && bullet.y < canvas.height;
            });

            invaders.forEach(invader => {
                if (invader.alive && invader.y + invader.height >= player.y) {
                    gameOver();
                }
            });
        }

        function update() {
            if (!gameRunning || paused) return;

            if (keys['ArrowLeft'] || keys['a'] || keys['A']) {
                player.x = Math.max(0, player.x - player.speed);
            }
            if (keys['ArrowRight'] || keys['d'] || keys['D']) {
                player.x = Math.min(canvas.width - player.width, player.x + player.speed);
            }
            if (keys[' '] || keys['Spacebar'] || keys['Space']) {
                shoot();
            }

            let shouldDrop = false;
            invaders.forEach(invader => {
                if (invader.alive) {
                    invader.x += invaderDirection * invaderSpeed;

                    if (invader.x <= 0 || invader.x + invader.width >= canvas.width) {
                        shouldDrop = true;
                    }

                    invader.animFrame = (invader.animFrame + 0.02) % 1;
                }
            });

            if (shouldDrop) {
                invaderDirection *= -1;
                invaders.forEach(invader => {
                    invader.y += invaderDropDistance;
                });
            }

            bullets.forEach(bullet => {
                bullet.y -= bullet.speed;
            });

            invaderBullets.forEach(bullet => {
                bullet.y += bullet.speed;
            });

            invaderShoot();
            checkCollisions();

            const aliveInvaders = invaders.filter(i => i.alive);
            if (aliveInvaders.length === 0) {
                nextWave();
            }
        }

        function draw() {
            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            drawPlayer();
            drawInvaders();
            drawBarriers();
            drawBullets();

            ctx.strokeStyle = '#00ff00';
            ctx.lineWidth = 2;
            ctx.strokeRect(0, 0, canvas.width, canvas.height);
        }

        function gameLoop() {
            update();
            draw();
            requestAnimationFrame(gameLoop);
        }

        document.addEventListener('keydown', (e) => {
            keys[e.key] = true;

            if (e.key === 'p' || e.key === 'P') {
                if (gameRunning) {
                    paused = !paused;
                }
            }
        });

        document.addEventListener('keyup', (e) => {
            keys[e.key] = false;
        });

        let touchX = null;
        let touchFiring = false;

        canvas.addEventListener('touchstart', (e) => {
            touchX = e.touches[0].clientX;
            touchFiring = true;
        });

        canvas.addEventListener('touchmove', (e) => {
            if (touchX !== null) {
                const deltaX = e.touches[0].clientX - touchX;
                player.x = Math.max(0, Math.min(canvas.width - player.width, player.x + deltaX));
                touchX = e.touches[0].clientX;
            }
        });

        canvas.addEventListener('touchend', () => {
            touchX = null;
            touchFiring = false;
        });

        setInterval(() => {
            if (touchFiring && gameRunning && !paused) {
                shoot();
            }
        }, shotCooldown);

        // Leaderboard helpers
        async function loadLeaderboard() {
            const list = document.getElementById('leaderboardList');
            if (!list) return;
            list.innerHTML = '<li>Loading...</li>';
            try {
                const { data, error } = await supabase
                    .from('space_invaders_scores')
                    .select('player_name, score, wave, created_at')
                    .order('score', { ascending: false })
                    .limit(10);
                if (error) throw error;
                list.innerHTML = '';
                (data || []).forEach((row, i) => {
                    const li = document.createElement('li');
                    const name = row.player_name || 'ANON';
                    li.textContent = `${i+1}. ${name} ‚Äî ${row.score} pts (W${row.wave||1})`;
                    list.appendChild(li);
                });
                if (!data || data.length === 0) {
                    list.innerHTML = '<li>No scores yet. Be the first!</li>';
                }
            } catch (e) {
                console.error(e);
                list.innerHTML = '<li>Failed to load leaderboard.</li>';
            }
        }

        async function saveScore() {
            const status = document.getElementById('saveStatus');
            const name = (document.getElementById('playerName')?.value || 'ANON').toString().trim().slice(0,20) || 'ANON';
            if (!supabase || !currentUser?.id) {
                if (status) status.textContent = 'Auth not ready. Try again.';
                return;
            }
            if (status) status.textContent = 'Saving...';
            try {
                const { error } = await supabase
                    .from('space_invaders_scores')
                    .insert({
                        player_name: name,
                        score: Number(score) || 0,
                        wave: Number(wave) || 1,
                        user_id: currentUser.id
                    });
                if (error) throw error;
                if (status) status.textContent = 'Saved!';
                loadLeaderboard();
            } catch (e) {
                console.error(e);
                if (status) status.textContent = 'Save failed.';
            }
        }

        // Wire UI events
        document.getElementById('playBtn')?.addEventListener('click', () => startGame());
        document.getElementById('saveScoreBtn')?.addEventListener('click', (e) => {
            e.preventDefault();
            saveScore();
        });

        document.getElementById('gameMessage').classList.add('show');
        updateDisplay();
        gameLoop();
        if (supabase) loadLeaderboard();
    </script>
<script src="/sloppy-header/sloppy-bar.js"></script>
<script src="/vibelib-extended.js"></script>
<script>
  // Compatibility Patch for Legacy Apps
  window.addEventListener("load", () => {
    if (window.SloppyKarma && window.VibeLib.Economy) {
      // Redirect old calls to new engine
      window.SloppyKarma.track = window.VibeLib.Economy.track;
    }
  });
</script>
</body>
</html>
