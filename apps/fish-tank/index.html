<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
  <title>Neon Fish Tank</title>
  <link rel="icon" href="https://emojicdn.elk.sh/üê†">
  <meta name="description" content="Watch glowing neon fish swim through a peaceful digital aquarium">
  <meta property="og:title" content="Neon Fish Tank">
  <meta property="og:description" content="Watch glowing neon fish swim through a peaceful digital aquarium">
  <meta property="og:image" content="https://emojicdn.elk.sh/üê†?style=google">
  <meta property="og:url" content="https://sloppy.live/fish-tank">
  <style>
    @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700&display=swap');

    * { margin: 0; padding: 0; box-sizing: border-box; }

    body {
      min-height: 100vh;
      background: linear-gradient(180deg, #0a1628 0%, #051020 50%, #030812 100%);
      font-family: 'Orbitron', sans-serif;
      overflow: hidden;
      cursor: pointer;
    }

    .back-link {
      position: fixed;
      top: 10px;
      left: 10px;
      color: rgba(255,255,255,0.3);
      text-decoration: none;
      font-size: 0.7rem;
      z-index: 100;
    }

    .header {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      padding: 15px;
      text-align: center;
      background: linear-gradient(180deg, rgba(5,16,32,0.9) 0%, transparent 100%);
      z-index: 50;
      pointer-events: none;
    }

    .title {
      font-size: 1.2rem;
      font-weight: 400;
      letter-spacing: 8px;
      color: #0ff;
      text-shadow: 0 0 20px #0ff, 0 0 40px #0ff;
    }

    canvas {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
    }

    .controls {
      position: fixed;
      bottom: 15px;
      left: 50%;
      transform: translateX(-50%);
      display: flex;
      gap: 8px;
      z-index: 100;
    }

    .ctrl-btn {
      padding: 8px 16px;
      background: rgba(0,255,255,0.1);
      border: 1px solid rgba(0,255,255,0.3);
      border-radius: 20px;
      color: #0ff;
      font-family: 'Orbitron', sans-serif;
      font-size: 0.65rem;
      letter-spacing: 2px;
      cursor: pointer;
      transition: all 0.3s;
    }

    .ctrl-btn:hover {
      background: rgba(0,255,255,0.2);
      box-shadow: 0 0 20px rgba(0,255,255,0.4);
    }

    .fish-count {
      position: fixed;
      bottom: 60px;
      left: 50%;
      transform: translateX(-50%);
      color: rgba(255,255,255,0.3);
      font-size: 0.55rem;
      letter-spacing: 3px;
    }

    .instructions {
      position: fixed;
      bottom: 80px;
      left: 50%;
      transform: translateX(-50%);
      color: rgba(255,255,255,0.2);
      font-size: 0.5rem;
      letter-spacing: 2px;
      opacity: 1;
      transition: opacity 2s;
    }

    .instructions.hidden { opacity: 0; }
  </style>
</head>
<body>
  <a href="https://sloppy.live" class="back-link">‚Üê exit</a>

  <div class="header">
    <div class="title">FISH TANK</div>
  </div>

  <canvas id="tank"></canvas>

  <div class="instructions" id="instructions">TAP TO ADD FISH</div>
  <div class="fish-count" id="fishCount">FISH: 0</div>

  <div class="controls">
    <button class="ctrl-btn" onclick="addRandomFish()">+ FISH</button>
    <button class="ctrl-btn" onclick="toggleBubbles()">BUBBLES</button>
    <button class="ctrl-btn" onclick="clearTank()">CLEAR</button>
  </div>

  <script>
    const canvas = document.getElementById('tank');
    const ctx = canvas.getContext('2d');

    let fish = [];
    let bubbles = [];
    let plants = [];
    let bubblesEnabled = true;
    let interacted = false;

    const neonColors = [
      { body: '#0ff', glow: '#0ff' },      // Cyan
      { body: '#f0f', glow: '#f0f' },      // Magenta
      { body: '#0f0', glow: '#0f0' },      // Green
      { body: '#fc0', glow: '#fc0' },      // Gold
      { body: '#f55', glow: '#f55' },      // Red
      { body: '#5ff', glow: '#5ff' },      // Light cyan
      { body: '#f5f', glow: '#f5f' },      // Pink
      { body: '#5f5', glow: '#5f5' },      // Light green
      { body: '#fa0', glow: '#fa0' },      // Orange
      { body: '#55f', glow: '#55f' },      // Blue
    ];

    function resize() {
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
      initPlants();
    }
    window.addEventListener('resize', resize);

    function initPlants() {
      plants = [];
      const count = Math.floor(canvas.width / 80);
      for (let i = 0; i < count; i++) {
        plants.push({
          x: 40 + i * 80 + Math.random() * 40 - 20,
          segments: 5 + Math.floor(Math.random() * 4),
          height: 80 + Math.random() * 60,
          width: 8 + Math.random() * 6,
          color: Math.random() > 0.5 ? '#0f8' : '#0a6',
          phase: Math.random() * Math.PI * 2,
          speed: 0.5 + Math.random() * 0.5
        });
      }
    }

    class Fish {
      constructor(x, y) {
        this.x = x || Math.random() * canvas.width;
        this.y = y || 100 + Math.random() * (canvas.height - 250);
        this.size = 15 + Math.random() * 20;
        this.speed = 0.8 + Math.random() * 1.5;
        this.direction = Math.random() > 0.5 ? 1 : -1;
        this.vx = this.speed * this.direction;
        this.vy = (Math.random() - 0.5) * 0.5;
        this.targetY = this.y;
        this.wobble = 0;
        this.wobbleSpeed = 0.1 + Math.random() * 0.1;
        this.tailPhase = Math.random() * Math.PI * 2;
        const colorSet = neonColors[Math.floor(Math.random() * neonColors.length)];
        this.color = colorSet.body;
        this.glow = colorSet.glow;
        this.glowIntensity = 0.5 + Math.random() * 0.5;
      }

      update() {
        // Movement
        this.x += this.vx;
        this.wobble += this.wobbleSpeed;
        this.tailPhase += 0.2;

        // Vertical drift
        if (Math.random() < 0.01) {
          this.targetY = 100 + Math.random() * (canvas.height - 250);
        }
        this.vy += (this.targetY - this.y) * 0.001;
        this.vy *= 0.98;
        this.y += this.vy;

        // Bounds and turning
        if (this.x < -50) {
          this.x = -50;
          this.direction = 1;
          this.vx = this.speed;
        }
        if (this.x > canvas.width + 50) {
          this.x = canvas.width + 50;
          this.direction = -1;
          this.vx = -this.speed;
        }

        // Random speed changes
        if (Math.random() < 0.005) {
          this.speed = 0.8 + Math.random() * 1.5;
          this.vx = this.speed * this.direction;
        }
      }

      draw() {
        ctx.save();
        ctx.translate(this.x, this.y);
        ctx.scale(this.direction, 1);

        const wobbleY = Math.sin(this.wobble) * 2;
        ctx.translate(0, wobbleY);

        // Glow
        ctx.shadowBlur = 20 * this.glowIntensity;
        ctx.shadowColor = this.glow;

        // Body
        ctx.fillStyle = this.color;
        ctx.beginPath();
        ctx.ellipse(0, 0, this.size, this.size * 0.5, 0, 0, Math.PI * 2);
        ctx.fill();

        // Tail
        const tailWag = Math.sin(this.tailPhase) * 0.3;
        ctx.beginPath();
        ctx.moveTo(-this.size * 0.7, 0);
        ctx.quadraticCurveTo(
          -this.size * 1.2, -this.size * 0.6 + tailWag * this.size,
          -this.size * 1.5, -this.size * 0.4 + tailWag * this.size
        );
        ctx.lineTo(-this.size * 1.5, this.size * 0.4 + tailWag * this.size);
        ctx.quadraticCurveTo(
          -this.size * 1.2, this.size * 0.6 + tailWag * this.size,
          -this.size * 0.7, 0
        );
        ctx.fill();

        // Dorsal fin
        ctx.beginPath();
        ctx.moveTo(-this.size * 0.2, -this.size * 0.4);
        ctx.quadraticCurveTo(0, -this.size * 0.9, this.size * 0.3, -this.size * 0.45);
        ctx.lineTo(-this.size * 0.2, -this.size * 0.4);
        ctx.fill();

        // Eye
        ctx.shadowBlur = 0;
        ctx.fillStyle = '#000';
        ctx.beginPath();
        ctx.arc(this.size * 0.5, -this.size * 0.1, this.size * 0.15, 0, Math.PI * 2);
        ctx.fill();
        ctx.fillStyle = '#fff';
        ctx.beginPath();
        ctx.arc(this.size * 0.53, -this.size * 0.13, this.size * 0.06, 0, Math.PI * 2);
        ctx.fill();

        ctx.restore();
      }
    }

    class Bubble {
      constructor(x, y) {
        this.x = x || Math.random() * canvas.width;
        this.y = y || canvas.height + 10;
        this.size = 3 + Math.random() * 8;
        this.speed = 0.5 + Math.random() * 1.5;
        this.wobble = Math.random() * Math.PI * 2;
        this.wobbleSpeed = 0.02 + Math.random() * 0.03;
        this.opacity = 0.3 + Math.random() * 0.4;
      }

      update() {
        this.y -= this.speed;
        this.wobble += this.wobbleSpeed;
        this.x += Math.sin(this.wobble) * 0.5;

        // Pop at surface
        if (this.y < 50) {
          this.opacity -= 0.02;
        }

        return this.opacity > 0;
      }

      draw() {
        ctx.save();
        ctx.globalAlpha = this.opacity;

        // Glow
        ctx.shadowBlur = 10;
        ctx.shadowColor = '#0ff';

        // Bubble
        ctx.strokeStyle = '#0ff';
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
        ctx.stroke();

        // Highlight
        ctx.fillStyle = 'rgba(0,255,255,0.5)';
        ctx.beginPath();
        ctx.arc(this.x - this.size * 0.3, this.y - this.size * 0.3, this.size * 0.25, 0, Math.PI * 2);
        ctx.fill();

        ctx.restore();
      }
    }

    function drawPlants(time) {
      plants.forEach(plant => {
        const baseX = plant.x;
        const baseY = canvas.height - 20;

        ctx.strokeStyle = plant.color;
        ctx.lineWidth = plant.width;
        ctx.lineCap = 'round';
        ctx.shadowBlur = 15;
        ctx.shadowColor = plant.color;

        const segHeight = plant.height / plant.segments;

        for (let i = 0; i < plant.segments; i++) {
          const t = i / plant.segments;
          const sway = Math.sin(time * 0.001 * plant.speed + plant.phase + t * 2) * (20 * t);

          const y1 = baseY - i * segHeight;
          const y2 = baseY - (i + 1) * segHeight;
          const x1 = baseX + Math.sin(time * 0.001 * plant.speed + plant.phase + (i - 1) * 0.5) * (15 * (i / plant.segments));
          const x2 = baseX + sway;

          ctx.globalAlpha = 0.6 + t * 0.4;
          ctx.beginPath();
          ctx.moveTo(x1, y1);
          ctx.quadraticCurveTo(x1 + sway * 0.5, (y1 + y2) / 2, x2, y2);
          ctx.stroke();
        }
      });
      ctx.globalAlpha = 1;
      ctx.shadowBlur = 0;
    }

    function drawSandAndRocks() {
      // Sand gradient
      const sandGrad = ctx.createLinearGradient(0, canvas.height - 60, 0, canvas.height);
      sandGrad.addColorStop(0, '#1a1a0a');
      sandGrad.addColorStop(1, '#0d0d05');
      ctx.fillStyle = sandGrad;
      ctx.fillRect(0, canvas.height - 60, canvas.width, 60);

      // Sand texture
      ctx.fillStyle = 'rgba(255,255,200,0.03)';
      for (let i = 0; i < 200; i++) {
        ctx.fillRect(
          Math.random() * canvas.width,
          canvas.height - 55 + Math.random() * 50,
          2, 2
        );
      }

      // Rocks
      const rocks = [
        { x: canvas.width * 0.15, size: 25 },
        { x: canvas.width * 0.4, size: 18 },
        { x: canvas.width * 0.7, size: 30 },
        { x: canvas.width * 0.9, size: 20 },
      ];

      rocks.forEach(rock => {
        ctx.fillStyle = '#1a1a1a';
        ctx.shadowBlur = 5;
        ctx.shadowColor = '#000';
        ctx.beginPath();
        ctx.ellipse(rock.x, canvas.height - 35, rock.size, rock.size * 0.6, 0, 0, Math.PI * 2);
        ctx.fill();
        ctx.shadowBlur = 0;
      });
    }

    function drawWaterSurface(time) {
      ctx.save();
      ctx.globalAlpha = 0.15;

      for (let i = 0; i < 3; i++) {
        const y = 40 + i * 8;
        ctx.strokeStyle = '#0ff';
        ctx.lineWidth = 2 - i * 0.5;
        ctx.beginPath();

        for (let x = 0; x < canvas.width; x += 5) {
          const wave = Math.sin(x * 0.02 + time * 0.002 + i) * 3;
          if (x === 0) {
            ctx.moveTo(x, y + wave);
          } else {
            ctx.lineTo(x, y + wave);
          }
        }
        ctx.stroke();
      }

      ctx.restore();
    }

    function spawnBubble() {
      if (bubblesEnabled && Math.random() < 0.1) {
        bubbles.push(new Bubble());
      }
    }

    function addRandomFish() {
      if (fish.length < 50) {
        fish.push(new Fish());
        updateFishCount();
      }
    }

    function addFishAt(x, y) {
      if (fish.length < 50) {
        fish.push(new Fish(x, y));
        updateFishCount();

        // Add bubbles at click
        for (let i = 0; i < 5; i++) {
          bubbles.push(new Bubble(x + (Math.random() - 0.5) * 30, y));
        }
      }
    }

    function toggleBubbles() {
      bubblesEnabled = !bubblesEnabled;
    }

    function clearTank() {
      fish = [];
      updateFishCount();
    }

    function updateFishCount() {
      document.getElementById('fishCount').textContent = `FISH: ${fish.length}`;
    }

    // Click to add fish
    canvas.addEventListener('click', (e) => {
      if (!interacted) {
        interacted = true;
        document.getElementById('instructions').classList.add('hidden');
      }
      addFishAt(e.clientX, e.clientY);
    });

    canvas.addEventListener('touchstart', (e) => {
      e.preventDefault();
      if (!interacted) {
        interacted = true;
        document.getElementById('instructions').classList.add('hidden');
      }
      const t = e.touches[0];
      addFishAt(t.clientX, t.clientY);
    }, { passive: false });

    function animate(time) {
      // Clear with slight fade for trails
      ctx.fillStyle = 'rgba(5,16,32,0.3)';
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      // Background gradient
      const bgGrad = ctx.createLinearGradient(0, 0, 0, canvas.height);
      bgGrad.addColorStop(0, 'rgba(10,22,40,0.5)');
      bgGrad.addColorStop(0.5, 'rgba(5,16,32,0.5)');
      bgGrad.addColorStop(1, 'rgba(3,8,18,0.5)');
      ctx.fillStyle = bgGrad;
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      // Water surface
      drawWaterSurface(time);

      // Sand and rocks
      drawSandAndRocks();

      // Plants
      drawPlants(time);

      // Update and draw bubbles
      spawnBubble();
      bubbles = bubbles.filter(b => b.update());
      bubbles.forEach(b => b.draw());

      // Update and draw fish
      fish.forEach(f => {
        f.update();
        f.draw();
      });

      requestAnimationFrame(animate);
    }

    // Initialize
    resize();

    // Start with some fish
    for (let i = 0; i < 5; i++) {
      fish.push(new Fish());
    }
    updateFishCount();

    // Start animation
    animate(0);
  </script>
<script src="/sloppy-header/sloppy-bar.js"></script>
</body>
</html>
