<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
  <title>Cloud Jumper - Cozy Heights</title>
  <link rel="icon" href="https://emojicdn.elk.sh/☁️">
  <meta property="og:title" content="Cloud Jumper">
  <meta property="og:description" content="A cozy journey through pastel skies">
  <meta property="og:url" content="https://app.sloppy.live/cloud-jumper">
  <meta property="og:image" content="https://emojicdn.elk.sh/☁️?style=apple&size=512">
  <link href="https://fonts.googleapis.com/css2?family=Nunito:wght@400;600;700&display=swap" rel="stylesheet">
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }

    :root {
      --sky-top: #e8f4fc;
      --sky-bottom: #fef6f0;
      --cloud: #ffffff;
      --cloud-shadow: #e8e4e0;
      --text: #6b7280;
      --text-dark: #4b5563;
      --accent: #f0b4b4;
      --lavender: #d4c4e8;
      --mint: #c8e6d4;
      --peach: #f5d5c8;
      --sky-blue: #c4dae8;
    }

    body {
      font-family: 'Nunito', sans-serif;
      overflow: hidden;
      touch-action: none;
    }

    canvas {
      display: block;
    }

    .ui {
      position: fixed;
      top: 20px;
      left: 50%;
      transform: translateX(-50%);
      text-align: center;
      z-index: 100;
      pointer-events: none;
    }

    .score {
      font-size: 2.5rem;
      font-weight: 700;
      color: var(--text-dark);
      opacity: 0.8;
    }

    .score-label {
      font-size: 0.8rem;
      color: var(--text);
      letter-spacing: 2px;
      text-transform: uppercase;
    }

    .best {
      position: fixed;
      top: 20px;
      right: 20px;
      font-size: 0.85rem;
      color: var(--text);
      z-index: 100;
      pointer-events: none;
    }

    .start-screen {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      text-align: center;
      z-index: 200;
      background: rgba(255, 255, 255, 0.9);
      padding: 40px 50px;
      border-radius: 24px;
      box-shadow: 0 10px 40px rgba(0, 0, 0, 0.08);
    }

    .start-screen h1 {
      font-size: 2.2rem;
      font-weight: 700;
      color: var(--text-dark);
      margin-bottom: 8px;
    }

    .start-screen .emoji {
      font-size: 3rem;
      margin-bottom: 16px;
    }

    .start-screen p {
      color: var(--text);
      margin-bottom: 24px;
      font-size: 1rem;
    }

    .btn {
      background: var(--accent);
      color: white;
      border: none;
      padding: 14px 36px;
      border-radius: 30px;
      font-family: 'Nunito', sans-serif;
      font-size: 1.1rem;
      font-weight: 600;
      cursor: pointer;
      transition: transform 0.2s, box-shadow 0.2s;
    }

    .btn:hover {
      transform: translateY(-2px);
      box-shadow: 0 6px 20px rgba(240, 180, 180, 0.4);
    }

    .instructions {
      margin-top: 24px;
      font-size: 0.85rem;
      color: var(--text);
      line-height: 1.8;
    }

    .game-over {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      text-align: center;
      z-index: 200;
      background: rgba(255, 255, 255, 0.95);
      padding: 40px 50px;
      border-radius: 24px;
      box-shadow: 0 10px 40px rgba(0, 0, 0, 0.1);
      display: none;
    }

    .game-over h2 {
      font-size: 1.8rem;
      color: var(--text-dark);
      margin-bottom: 8px;
    }

    .game-over .final-score {
      font-size: 3rem;
      font-weight: 700;
      color: var(--accent);
      margin: 16px 0;
    }

    .game-over .message {
      color: var(--text);
      margin-bottom: 24px;
    }

    .new-best {
      color: var(--lavender);
      font-weight: 600;
      margin-bottom: 16px;
    }

    .backlink {
      position: fixed;
      bottom: 15px;
      right: 20px;
      color: var(--text);
      opacity: 0.5;
      font-size: 0.7rem;
      text-decoration: none;
      z-index: 100;
    }

    .backlink:hover {
      opacity: 0.8;
    }

    .controls-hint {
      position: fixed;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      color: var(--text);
      opacity: 0.5;
      font-size: 0.8rem;
      z-index: 100;
      pointer-events: none;
    }
  </style>
</head>
<body>
  <canvas id="game"></canvas>

  <div class="ui">
    <div class="score-label">Height</div>
    <div class="score" id="score">0</div>
  </div>

  <div class="best" id="best"></div>

  <div class="start-screen" id="start-screen">
    <div class="emoji">☁️</div>
    <h1>Cloud Jumper</h1>
    <p>A cozy journey through pastel skies</p>
    <button class="btn" id="start-btn">Start Jumping</button>
    <div class="instructions">
      ← → or tap sides to move<br>
      Jump on clouds to go higher
    </div>
  </div>

  <div class="game-over" id="game-over">
    <h2>You drifted away</h2>
    <div class="final-score" id="final-score">0</div>
    <div class="new-best" id="new-best" style="display: none;">New best! ✨</div>
    <p class="message">meters into the sky</p>
    <button class="btn" id="restart-btn">Try Again</button>
  </div>

  <div class="controls-hint" id="controls-hint"></div>

  <a href="https://sloppy.live" class="backlink">sloppy.live</a>

  <script>
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');

    let W, H;
    function resize() {
      W = canvas.width = window.innerWidth;
      H = canvas.height = window.innerHeight;
    }
    resize();
    window.addEventListener('resize', resize);

    // Game state
    let gameRunning = false;
    let score = 0;
    let bestScore = parseInt(localStorage.getItem('cloudJumperBest') || '0');
    let cameraY = 0;
    let highestY = 0;

    // Player
    let player = {
      x: 0,
      y: 0,
      vx: 0,
      vy: 0,
      width: 30,
      height: 40,
      onGround: false
    };

    // Clouds
    let clouds = [];
    const CLOUD_COUNT = 12;
    const CLOUD_GAP = 80;

    // Decorative elements
    let stars = [];
    let birds = [];

    // Colors
    const cloudColors = ['#ffffff', '#fef6f0', '#f0f4f8', '#fdf2f8'];
    const starColors = ['#fcd5ce', '#d8e2dc', '#ffe5d9', '#e8e8e4'];

    // Input
    let keys = { left: false, right: false };
    let touchX = null;

    // Initialize clouds
    function initClouds() {
      clouds = [];
      for (let i = 0; i < CLOUD_COUNT; i++) {
        clouds.push(createCloud(H - 100 - i * CLOUD_GAP));
      }
      // Starting platform
      clouds[0].x = W / 2;
      clouds[0].width = 120;
    }

    function createCloud(y) {
      return {
        x: Math.random() * (W - 100) + 50,
        y: y,
        width: 60 + Math.random() * 50,
        height: 20,
        color: cloudColors[Math.floor(Math.random() * cloudColors.length)],
        bobPhase: Math.random() * Math.PI * 2,
        bobSpeed: 0.5 + Math.random() * 0.5
      };
    }

    // Initialize decorations
    function initDecorations() {
      stars = [];
      for (let i = 0; i < 30; i++) {
        stars.push({
          x: Math.random() * W,
          y: Math.random() * H * 3,
          size: 2 + Math.random() * 4,
          color: starColors[Math.floor(Math.random() * starColors.length)],
          twinkle: Math.random() * Math.PI * 2
        });
      }

      birds = [];
      for (let i = 0; i < 5; i++) {
        birds.push({
          x: Math.random() * W,
          y: Math.random() * H * 2,
          speed: 0.5 + Math.random() * 1,
          size: 8 + Math.random() * 6,
          phase: Math.random() * Math.PI * 2
        });
      }
    }

    // Reset game
    function resetGame() {
      player.x = W / 2;
      player.y = H - 150;
      player.vx = 0;
      player.vy = 0;
      cameraY = 0;
      highestY = player.y;
      score = 0;
      initClouds();
      initDecorations();
      updateScore();
    }

    // Start game
    function startGame() {
      resetGame();
      gameRunning = true;
      document.getElementById('start-screen').style.display = 'none';
      document.getElementById('game-over').style.display = 'none';
      document.getElementById('controls-hint').textContent = window.innerWidth < 600 ? 'Tap left or right to move' : '← → Arrow keys to move';
    }

    // Game over
    function gameOver() {
      gameRunning = false;

      const isNewBest = score > bestScore;
      if (isNewBest) {
        bestScore = score;
        localStorage.setItem('cloudJumperBest', bestScore.toString());
      }

      document.getElementById('final-score').textContent = score;
      document.getElementById('new-best').style.display = isNewBest ? 'block' : 'none';
      document.getElementById('game-over').style.display = 'block';
      updateBest();
    }

    // Update score display
    function updateScore() {
      document.getElementById('score').textContent = score;
    }

    function updateBest() {
      if (bestScore > 0) {
        document.getElementById('best').textContent = `Best: ${bestScore}m`;
      }
    }

    // Input handlers
    document.addEventListener('keydown', e => {
      if (e.key === 'ArrowLeft' || e.key === 'a') keys.left = true;
      if (e.key === 'ArrowRight' || e.key === 'd') keys.right = true;
    });

    document.addEventListener('keyup', e => {
      if (e.key === 'ArrowLeft' || e.key === 'a') keys.left = false;
      if (e.key === 'ArrowRight' || e.key === 'd') keys.right = false;
    });

    canvas.addEventListener('touchstart', e => {
      e.preventDefault();
      touchX = e.touches[0].clientX;
    });

    canvas.addEventListener('touchmove', e => {
      e.preventDefault();
      touchX = e.touches[0].clientX;
    });

    canvas.addEventListener('touchend', () => {
      touchX = null;
    });

    // Button handlers
    document.getElementById('start-btn').addEventListener('click', startGame);
    document.getElementById('restart-btn').addEventListener('click', startGame);

    // Update physics
    function update(dt) {
      if (!gameRunning) return;

      // Input
      let moveX = 0;
      if (keys.left) moveX = -1;
      if (keys.right) moveX = 1;

      if (touchX !== null) {
        if (touchX < W / 2) moveX = -1;
        else moveX = 1;
      }

      // Horizontal movement
      player.vx += moveX * 1500 * dt;
      player.vx *= 0.9; // Friction

      // Gravity
      player.vy += 800 * dt;

      // Move player
      player.x += player.vx * dt;
      player.y += player.vy * dt;

      // Wrap horizontally
      if (player.x < -player.width / 2) player.x = W + player.width / 2;
      if (player.x > W + player.width / 2) player.x = -player.width / 2;

      // Cloud collision (only when falling)
      if (player.vy > 0) {
        clouds.forEach(cloud => {
          const cloudY = cloud.y + Math.sin(cloud.bobPhase) * 3;

          if (player.x + player.width / 2 > cloud.x - cloud.width / 2 &&
              player.x - player.width / 2 < cloud.x + cloud.width / 2 &&
              player.y + player.height > cloudY &&
              player.y + player.height < cloudY + cloud.height + player.vy * dt) {

            player.y = cloudY - player.height;
            player.vy = -450; // Jump!
          }
        });
      }

      // Update camera
      const targetCameraY = Math.min(cameraY, player.y - H * 0.4);
      cameraY += (targetCameraY - cameraY) * 0.1;

      // Track highest point
      if (player.y < highestY) {
        highestY = player.y;
        score = Math.floor((H - 150 - highestY) / 10);
        updateScore();
      }

      // Generate new clouds above
      const highestCloud = Math.min(...clouds.map(c => c.y));
      if (highestCloud > cameraY - H) {
        clouds.push(createCloud(highestCloud - CLOUD_GAP));
      }

      // Remove clouds below screen
      clouds = clouds.filter(c => c.y < cameraY + H + 100);

      // Update cloud bob
      clouds.forEach(cloud => {
        cloud.bobPhase += cloud.bobSpeed * dt;
      });

      // Update decorations
      stars.forEach(star => {
        star.twinkle += dt * 2;
        if (star.y > cameraY + H + 50) {
          star.y = cameraY - 50;
          star.x = Math.random() * W;
        }
      });

      birds.forEach(bird => {
        bird.x += bird.speed * 60 * dt;
        bird.phase += dt * 5;
        if (bird.x > W + 50) {
          bird.x = -50;
          bird.y = cameraY + Math.random() * H;
        }
      });

      // Check game over (fell too far)
      if (player.y > cameraY + H + 100) {
        gameOver();
      }
    }

    // Draw cloud
    function drawCloud(cloud) {
      const y = cloud.y - cameraY + Math.sin(cloud.bobPhase) * 3;
      const x = cloud.x;
      const w = cloud.width;
      const h = cloud.height;

      ctx.fillStyle = cloud.color;

      // Cloud shape (multiple circles)
      ctx.beginPath();
      ctx.ellipse(x, y + h * 0.3, w * 0.5, h, 0, 0, Math.PI * 2);
      ctx.fill();

      ctx.beginPath();
      ctx.ellipse(x - w * 0.25, y + h * 0.5, w * 0.3, h * 0.8, 0, 0, Math.PI * 2);
      ctx.fill();

      ctx.beginPath();
      ctx.ellipse(x + w * 0.25, y + h * 0.5, w * 0.3, h * 0.8, 0, 0, Math.PI * 2);
      ctx.fill();

      // Subtle shadow
      ctx.fillStyle = 'rgba(0, 0, 0, 0.03)';
      ctx.beginPath();
      ctx.ellipse(x, y + h * 0.8, w * 0.45, h * 0.5, 0, 0, Math.PI);
      ctx.fill();
    }

    // Draw player (cute blob character)
    function drawPlayer() {
      const x = player.x;
      const y = player.y - cameraY;

      ctx.save();

      // Body
      ctx.fillStyle = '#f0b4b4';
      ctx.beginPath();
      ctx.ellipse(x, y + player.height * 0.6, player.width * 0.5, player.height * 0.5, 0, 0, Math.PI * 2);
      ctx.fill();

      // Face
      ctx.fillStyle = '#fef6f0';
      ctx.beginPath();
      ctx.ellipse(x, y + player.height * 0.4, player.width * 0.35, player.height * 0.35, 0, 0, Math.PI * 2);
      ctx.fill();

      // Eyes
      ctx.fillStyle = '#4b5563';
      ctx.beginPath();
      ctx.arc(x - 6, y + player.height * 0.35, 3, 0, Math.PI * 2);
      ctx.arc(x + 6, y + player.height * 0.35, 3, 0, Math.PI * 2);
      ctx.fill();

      // Cheeks
      ctx.fillStyle = '#fcd5ce';
      ctx.beginPath();
      ctx.ellipse(x - 12, y + player.height * 0.5, 4, 3, 0, 0, Math.PI * 2);
      ctx.ellipse(x + 12, y + player.height * 0.5, 4, 3, 0, 0, Math.PI * 2);
      ctx.fill();

      // Smile
      ctx.strokeStyle = '#4b5563';
      ctx.lineWidth = 1.5;
      ctx.beginPath();
      ctx.arc(x, y + player.height * 0.45, 5, 0.1 * Math.PI, 0.9 * Math.PI);
      ctx.stroke();

      ctx.restore();
    }

    // Draw star
    function drawStar(star) {
      const y = star.y - cameraY;
      const alpha = 0.3 + Math.sin(star.twinkle) * 0.2;

      ctx.fillStyle = star.color;
      ctx.globalAlpha = alpha;
      ctx.beginPath();
      ctx.arc(star.x, y, star.size, 0, Math.PI * 2);
      ctx.fill();
      ctx.globalAlpha = 1;
    }

    // Draw bird
    function drawBird(bird) {
      const y = bird.y - cameraY;
      const wingY = Math.sin(bird.phase) * 4;

      ctx.strokeStyle = '#d4c4e8';
      ctx.lineWidth = 2;
      ctx.lineCap = 'round';

      ctx.beginPath();
      ctx.moveTo(bird.x - bird.size, y + wingY);
      ctx.quadraticCurveTo(bird.x, y - bird.size * 0.3, bird.x + bird.size, y + wingY);
      ctx.stroke();
    }

    // Draw background
    function drawBackground() {
      // Sky gradient that changes with height
      const progress = Math.min(1, -cameraY / 3000);

      const gradient = ctx.createLinearGradient(0, 0, 0, H);
      gradient.addColorStop(0, lerpColor('#e8f4fc', '#d4c4e8', progress));
      gradient.addColorStop(1, lerpColor('#fef6f0', '#ffe5d9', progress));

      ctx.fillStyle = gradient;
      ctx.fillRect(0, 0, W, H);
    }

    // Color lerp helper
    function lerpColor(color1, color2, t) {
      const c1 = hexToRgb(color1);
      const c2 = hexToRgb(color2);
      const r = Math.round(c1.r + (c2.r - c1.r) * t);
      const g = Math.round(c1.g + (c2.g - c1.g) * t);
      const b = Math.round(c1.b + (c2.b - c1.b) * t);
      return `rgb(${r}, ${g}, ${b})`;
    }

    function hexToRgb(hex) {
      const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
      return {
        r: parseInt(result[1], 16),
        g: parseInt(result[2], 16),
        b: parseInt(result[3], 16)
      };
    }

    // Main draw
    function draw() {
      drawBackground();

      // Draw decorations
      stars.forEach(drawStar);
      birds.forEach(drawBird);

      // Draw clouds
      clouds.forEach(drawCloud);

      // Draw player
      if (gameRunning) {
        drawPlayer();
      }
    }

    // Animation loop
    let lastTime = 0;
    function animate(timestamp) {
      requestAnimationFrame(animate);

      const dt = Math.min((timestamp - lastTime) / 1000, 0.1);
      lastTime = timestamp;

      update(dt);
      draw();
    }

    // Initialize
    updateBest();
    initDecorations();
    animate(0);
  </script>
<script src="/sloppy-header/sloppy-bar.js"></script>
<script src="/vibelib-extended.js"></script>
<script>
  // Compatibility Patch for Legacy Apps
  window.addEventListener("load", () => {
    if (window.SloppyKarma && window.VibeLib.Economy) {
      // Redirect old calls to new engine
      window.SloppyKarma.track = window.VibeLib.Economy.track;
    }
  });
</script>
</body>
</html>
