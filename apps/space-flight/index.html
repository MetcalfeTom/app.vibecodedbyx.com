<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SpaceCraft</title>
    <link rel="icon" href="https://emojicdn.elk.sh/⛏️" type="image/png">

    <!-- Open Graph Meta Tags -->
    <meta property="og:title" content="SpaceCraft">
    <meta property="og:description" content="Dark starfield flight with Minecraft-like asteroids and blocky alien crafts.">
    <meta property="og:url" content="https://app.vibecodedbyx.com/space-flight">
    <meta property="og:image" content="https://app.vibecodedbyx.com/space-flight/preview.png">

    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            overflow: hidden;
            background: #000;
        }

        #gameCanvas {
            display: block;
            width: 100vw;
            height: 100vh;
        }

        #ui {
            position: fixed;
            top: 20px;
            left: 20px;
            color: #fff;
            font-size: 16px;
            text-shadow: 0 0 10px rgba(0, 255, 255, 0.8);
            z-index: 100;
            pointer-events: none;
        }
        /* Toggle + boost sit under stream link (top-right) */
        #modeToggle {
            margin-top: 10px;
            font-size: 12px;
            color: #001a1a;
            background: #00ffff;
            border: none;
            border-radius: 6px;
            padding: 6px 10px;
            cursor: pointer;
        }
        #modeToggle:hover { filter: brightness(0.9); }

        #controls {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            color: #fff;
            text-align: center;
            font-size: 14px;
            background: rgba(0, 0, 0, 0.6);
            padding: 15px 25px;
            border-radius: 10px;
            backdrop-filter: blur(10px);
            z-index: 100;
            display: none; /* hidden on desktop, shown on mobile */
        }

        #backlink {
            position: fixed;
            top: 20px;
            right: 20px;
            z-index: 100;
            display: flex;
            flex-direction: column;
            align-items: flex-end;
            gap: 8px;
        }

        #backlink a {
            color: #00ffff;
            text-decoration: none;
            font-size: 14px;
            background: rgba(0, 0, 0, 0.6);
            padding: 10px 20px;
            border-radius: 5px;
            backdrop-filter: blur(10px);
            transition: all 0.3s;
        }

        #backlink a:hover {
            background: rgba(0, 255, 255, 0.2);
            transform: scale(1.05);
        }

        .mobile-controls {
            position: fixed;
            bottom: 20px;
            display: none;
            z-index: 100;
        }

        /* Diamond layout container (mobile) */
        .diamond-controls {
            left: 50%;
            transform: translateX(-50%);
            display: none; /* enabled via media query */
            grid-template-columns: 58px 58px 58px 58px; /* tighter columns for closer controls */
            grid-template-rows: 64px 64px 64px;
            grid-template-areas:
                ". up . ."
                "left . right boost"
                ". down . .";
            gap: 4px;
        }

        /* Place buttons into grid areas */
        #btn-up { grid-area: up; }
        #btn-left { grid-area: left; }
        #btn-right { grid-area: right; }
        #btn-down { grid-area: down; }
        #btn-boost { grid-area: boost; }

        .mobile-controls button {
            width: 54px;
            height: 54px;
            border-radius: 50%;
            background: rgba(0, 255, 255, 0.3);
            border: 2px solid #00ffff;
            color: #fff;
            font-size: 24px;
            margin: 2px;
            backdrop-filter: blur(10px);
            touch-action: manipulation;
        }

        .mobile-controls button:active {
            background: rgba(0, 255, 255, 0.6);
        }

        /* Subtle boost meter under toggle */
        #boostMeter {
            width: 180px;
            height: 8px;
            border-radius: 8px;
            background: rgba(0, 255, 255, 0.12);
            overflow: hidden;
            box-shadow: 0 0 10px rgba(0,255,255,0.2) inset;
        }
        #boostFill {
            height: 100%;
            width: 100%;
            background: linear-gradient(90deg, #00ffff, #00b3b3);
            transition: width 0.15s ease-out, background-color 0.2s ease-out;
        }

        /* Health meter (top-left under speed) */
        #healthMeter {
            width: 220px;
            height: 10px;
            border-radius: 10px;
            background: rgba(255, 255, 255, 0.08);
            margin-top: 8px;
            overflow: hidden;
            pointer-events: none;
        }
        #healthFill {
            height: 100%;
            width: 100%;
            background: linear-gradient(90deg, #22ff55, #118833);
            transition: width 0.12s ease-out, background-color 0.2s ease-out;
        }

        /* Death overlay */
        #deathOverlay {
            position: fixed;
            inset: 0;
            background: rgba(255, 0, 0, 0.2);
            display: none;
            align-items: center;
            justify-content: center;
            color: #fff;
            font-size: 28px;
            text-shadow: 0 0 20px rgba(255,0,0,0.9);
            z-index: 200;
        }
        #deathOverlay .inner {
            background: rgba(0,0,0,0.5);
            padding: 20px 28px;
            border: 1px solid rgba(255,0,0,0.5);
            border-radius: 10px;
        }

        /* left/right containers removed in favor of diamond layout */

        @media (max-width: 768px) {
            .diamond-controls { display: grid; }
            #controls { display: block; }
        }
    </style>
</head>
<body>
    <div id="ui">
        <div>⛏️ SpaceCraft</div>
        <div id="speed">Speed: 0</div>
        <!-- old text boost removed in favor of subtle bar -->
        <div id="healthMeter" aria-label="Hull integrity"><div id="healthFill" style="width: 100%"></div></div>
    </div>

    <div id="backlink">
        <a href="https://www.vibecodedbyx.com">← Back to Stream</a>
        <button id="modeToggle" title="Toggle Arcade/Physics">Mode: Arcade</button>
        <div id="boostMeter" aria-label="Boost fuel"><div id="boostFill" style="width: 100%"></div></div>
    </div>

    <div id="controls">
        <strong>Controls:</strong> W/S or ↑/↓ to pitch • A/D or ←/→ to yaw • Space to boost • Auto-accelerates forward
    </div>

    <div class="mobile-controls diamond-controls" id="diamond-controls">
        <button id="btn-up">↑</button>
        <button id="btn-left">←</button>
        <button id="btn-boost">⚡</button>
        <button id="btn-right">→</button>
        <button id="btn-down">↓</button>
    </div>

    <div id="deathOverlay"><div class="inner">Ship Destroyed — Tap or press R to respawn</div></div>

    <script type="importmap">
    {
        "imports": {
            "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
            "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
        }
    }
    </script>

    <script type="module">
        // v4.3 - Removed world rotation, only ship rotates with camera following
        import * as THREE from 'three';

        // Scene setup
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 10000);
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        document.body.appendChild(renderer.domElement);

        // Space sky + subtle fog
        scene.background = new THREE.Color(0x000000);
        scene.fog = new THREE.FogExp2(0x000022, 0.0005);

        // Spaceship (Minecraft-style blocky)
        const shipGroup = new THREE.Group();
        const blockMatCyan = new THREE.MeshPhongMaterial({ color: 0x00e6ff, emissive: 0x006688, flatShading: true });
        const blockMatMag = new THREE.MeshPhongMaterial({ color: 0xff33ff, emissive: 0x660066, flatShading: true });
        const blockMatDark = new THREE.MeshPhongMaterial({ color: 0x223344, emissive: 0x111111, flatShading: true });

        // Hull made of stacked boxes
        const hull = new THREE.Group();
        const hullSegments = [
            { w: 1.2, h: 0.7, d: 1.2, z: -0.4, mat: blockMatCyan },
            { w: 1.0, h: 0.7, d: 1.2, z: -1.6, mat: blockMatCyan },
            { w: 0.8, h: 0.7, d: 1.2, z: -2.6, mat: blockMatCyan }
        ];
        for (const seg of hullSegments) {
            const m = new THREE.Mesh(new THREE.BoxGeometry(seg.w, seg.h, seg.d), seg.mat);
            m.position.set(0, 0, seg.z);
            hull.add(m);
        }
        // Canopy block
        const canopy = new THREE.Mesh(new THREE.BoxGeometry(0.8, 0.4, 0.7), new THREE.MeshPhongMaterial({ color: 0x88ffff, emissive: 0x224444, transparent: true, opacity: 0.9 }));
        canopy.position.set(0, 0.4, -1.0);
        hull.add(canopy);
        // Tail block
        const tail = new THREE.Mesh(new THREE.BoxGeometry(0.8, 0.6, 0.6), blockMatDark);
        tail.position.set(0, 0, 0.7);
        hull.add(tail);
        shipGroup.add(hull);

        // Blocky wings
        const wingL = new THREE.Mesh(new THREE.BoxGeometry(1.2, 0.15, 0.7), blockMatMag);
        wingL.position.set(-1.0, 0, -0.3);
        const wingR = wingL.clone();
        wingR.position.x *= -1;
        shipGroup.add(wingL);
        shipGroup.add(wingR);

        // Engine glow (boxy)
        const engineGeometry = new THREE.BoxGeometry(0.5, 0.5, 0.5);
        const engineMaterial = new THREE.MeshBasicMaterial({ color: 0xff6600, transparent: true, opacity: 0.7 });
        const engine = new THREE.Mesh(engineGeometry, engineMaterial);
        engine.position.z = 1.2;
        shipGroup.add(engine);

        scene.add(shipGroup);
        shipGroup.position.set(0, 0, 0);

        // Camera offset from ship
        camera.position.set(0, 3, 8);
        camera.lookAt(shipGroup.position);

        // Lighting
        const ambientLight = new THREE.AmbientLight(0x404040, 0.45); // slightly higher ambient for subtler shadowing
        scene.add(ambientLight);

        // Sun-like directional light to bring out faces
        const sunLight = new THREE.DirectionalLight(0xfff4e5, 1.2);
        sunLight.position.set(300, 500, 200);
        scene.add(sunLight);

        const pointLight = new THREE.PointLight(0xffffff, 0.9, 120);
        pointLight.position.set(10, 10, 10);
        scene.add(pointLight);

        const shipLight = new THREE.PointLight(0x00ffff, 0.6, 20);
        shipGroup.add(shipLight);

        // Create world group - contains all objects that move relative to ship
        const worldGroup = new THREE.Group();
        scene.add(worldGroup);

        // ===== Starfield tiles (wrap + reseed for infinite feel) =====
        const STAR_TILE = 2000;
        const STAR_GRID = 3; // 3x3x3
        const starTiles = [];
        function createStarTile(count = 700) {
            const geom = new THREE.BufferGeometry();
            const positions = new Float32Array(count * 3);
            const colors = new Float32Array(count * 3);
            // Attach attributes before any updates
            geom.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
            geom.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
            const color = new THREE.Color();
            function fillRandom() {
                for (let i = 0; i < count; i++) {
                    positions[i*3 + 0] = (Math.random() - 0.5) * STAR_TILE;
                    positions[i*3 + 1] = (Math.random() - 0.5) * STAR_TILE;
                    positions[i*3 + 2] = (Math.random() - 0.5) * STAR_TILE;
                    color.setHSL(0.55 + Math.random() * 0.2, 0.25, 0.85 + Math.random()*0.1);
                    colors[i*3 + 0] = color.r;
                    colors[i*3 + 1] = color.g;
                    colors[i*3 + 2] = color.b;
                }
                const posAttr = geom.getAttribute('position');
                const colAttr = geom.getAttribute('color');
                if (posAttr) posAttr.needsUpdate = true;
                if (colAttr) colAttr.needsUpdate = true;
            }
            // Seed initial positions/colors
            fillRandom();
            const mat = new THREE.PointsMaterial({ size: 0.7, vertexColors: true, transparent: true, opacity: 0.9, blending: THREE.AdditiveBlending, depthWrite: false, sizeAttenuation: true });
            const pts = new THREE.Points(geom, mat);
            pts.userData.reseed = fillRandom;
            return pts;
        }
        for (let ix = -1; ix <= 1; ix++) {
            for (let iy = -1; iy <= 1; iy++) {
                for (let iz = -1; iz <= 1; iz++) {
                    const tile = createStarTile(650);
                    tile.position.set(ix * STAR_TILE, iy * STAR_TILE, iz * STAR_TILE);
                    worldGroup.add(tile);
                    starTiles.push(tile);
                }
            }
        }

        // ===== Very distant hue points anchored to camera (no parallax) =====
        const FAR_COUNT = 1600;
        const farGeom = new THREE.BufferGeometry();
        const farPos = new Float32Array(FAR_COUNT * 3);
        const farCol = new Float32Array(FAR_COUNT * 3);
        const farColor = new THREE.Color();
        for (let i = 0; i < FAR_COUNT; i++) {
            farPos[i*3 + 0] = (Math.random() - 0.5) * 1600;
            farPos[i*3 + 1] = (Math.random() - 0.5) * 1600;
            farPos[i*3 + 2] = (Math.random() - 0.5) * 1600;
            farColor.setHSL(0.5 + Math.random()*0.3, 0.5, 0.6);
            farCol[i*3 + 0] = farColor.r;
            farCol[i*3 + 1] = farColor.g;
            farCol[i*3 + 2] = farColor.b;
        }
        farGeom.setAttribute('position', new THREE.Float32BufferAttribute(farPos, 3));
        farGeom.setAttribute('color', new THREE.Float32BufferAttribute(farCol, 3));
        const farMat = new THREE.PointsMaterial({ size: 1.2, vertexColors: true, transparent: true, opacity: 0.55, blending: THREE.AdditiveBlending, depthWrite: false, sizeAttenuation: false });
        const farHues = new THREE.Points(farGeom, farMat);
        camera.add(farHues);

        // ===== Very big, very fuzzy background stars (sprites) =====
        function makeFuzzyTexture(size = 128) {
            const canvas = document.createElement('canvas');
            canvas.width = canvas.height = size;
            const ctx = canvas.getContext('2d');
            const g = ctx.createRadialGradient(size/2, size/2, 0, size/2, size/2, size/2);
            g.addColorStop(0, 'rgba(255,255,255,0.9)');
            g.addColorStop(0.3, 'rgba(200,255,255,0.6)');
            g.addColorStop(1, 'rgba(0,0,0,0)');
            ctx.fillStyle = g;
            ctx.fillRect(0,0,size,size);
            const tex = new THREE.CanvasTexture(canvas);
            tex.minFilter = THREE.LinearFilter;
            tex.magFilter = THREE.LinearFilter;
            tex.generateMipmaps = false;
            return tex;
        }
        const fuzzyTex = makeFuzzyTexture(128);
        const fuzzySky = new THREE.Group();
        camera.add(fuzzySky);
        const FUZZY_COUNT = 14;
        for (let i = 0; i < FUZZY_COUNT; i++) {
            const mat = new THREE.SpriteMaterial({ map: fuzzyTex, color: 0xffffff, transparent: true, blending: THREE.AdditiveBlending, depthWrite: false, opacity: 0.4 + Math.random()*0.35 });
            const spr = new THREE.Sprite(mat);
            const s = 600 + Math.random() * 1200; // very big
            spr.scale.set(s, s, 1);
            spr.position.set((Math.random()-0.5) * 2200, (Math.random()-0.5) * 1200, -2500 - Math.random()*1000);
            spr.userData.phase = Math.random() * Math.PI * 2;
            spr.userData.speed = 0.002 + Math.random() * 0.004;
            spr.userData.baseOpacity = mat.opacity;
            fuzzySky.add(spr);
        }

        // ===== Sparse twinkling spark tiles (variable density) =====
        const SPARK_TILE = STAR_TILE;
        const SPARK_GRID = STAR_GRID;
        const sparkTiles = [];
        const sparkBaseCount = 100; // not too dense
        const SPARK_NEAR_FADE_START = 220; // start boosting visibility when closer than this
        const SPARK_NEAR_FADE_END = 520;   // fully subtle beyond this distance
        function hash01(ix, iy, iz) {
            const h = ((ix * 73856093) ^ (iy * 19349663) ^ (iz * 83492791)) >>> 0;
            return (h % 1000) / 1000;
        }
        function tileDensity(ix, iy, iz) {
            // Vary density by area; keep within 0.3–1.0
            return 0.3 + 0.7 * hash01(ix, iy, iz);
        }
        function createSparkTile(ix, iy, iz) {
            const density = tileDensity(ix, iy, iz);
            const count = Math.floor(40 + sparkBaseCount * density);
            const geom = new THREE.BufferGeometry();
            const positions = new Float32Array(count * 3);
            const colors = new Float32Array(count * 3);
            const phases = new Float32Array(count);
            const speeds = new Float32Array(count);
            // base positions for local drift
            const basePos = new Float32Array(count * 3);
            const driftDir = new Float32Array(count * 3);
            const driftAmp = new Float32Array(count);
            geom.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
            geom.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
            const mat = new THREE.PointsMaterial({ size: 0.9, vertexColors: true, transparent: true, opacity: 0.9, blending: THREE.AdditiveBlending, depthWrite: false, sizeAttenuation: true });
            const pts = new THREE.Points(geom, mat);
            // internal buffers for animation
            const baseColors = new Float32Array(count * 3);
            function reseed(nx = ix, ny = iy, nz = iz) {
                // update grid index
                pts.userData.grid = { ix: nx, iy: ny, iz: nz };
                const dens = tileDensity(nx, ny, nz);
                // reuse existing count; fill new random positions and base colors
                for (let i = 0; i < count; i++) {
                    const j = i*3;
                    const bx = (Math.random() - 0.5) * SPARK_TILE;
                    const by = (Math.random() - 0.5) * SPARK_TILE;
                    const bz = (Math.random() - 0.5) * SPARK_TILE;
                    basePos[j + 0] = bx;
                    basePos[j + 1] = by;
                    basePos[j + 2] = bz;
                    positions[j + 0] = bx;
                    positions[j + 1] = by;
                    positions[j + 2] = bz;
                    // slightly brighter in denser tiles
                    const hue = 0.55 + Math.random() * 0.2;
                    const sat = 0.35 + dens * 0.2;
                    const light = 0.75 + Math.random() * 0.18;
                    const c = new THREE.Color().setHSL(hue, sat, light);
                    baseColors[j + 0] = c.r;
                    baseColors[j + 1] = c.g;
                    baseColors[j + 2] = c.b;
                    // initialize animated color with base
                    colors[j + 0] = baseColors[j + 0];
                    colors[j + 1] = baseColors[j + 1];
                    colors[j + 2] = baseColors[j + 2];
                    // twinkle params
                    phases[i] = Math.random() * Math.PI * 2;
                    speeds[i] = 0.008 + Math.random() * 0.02;
                    // drift params: small random direction and amplitude scaled by density
                    let dx = (Math.random()*2 - 1);
                    let dy = (Math.random()*2 - 1);
                    let dz = (Math.random()*2 - 1);
                    const len = Math.hypot(dx, dy, dz) || 1;
                    dx /= len; dy /= len; dz /= len;
                    driftDir[j + 0] = dx;
                    driftDir[j + 1] = dy;
                    driftDir[j + 2] = dz;
                    driftAmp[i] = (6 + Math.random() * 12) * (0.6 + dens*0.4);
                }
                geom.getAttribute('position').needsUpdate = true;
                geom.getAttribute('color').needsUpdate = true;
            }
            pts.userData = { baseColors, phases, speeds, basePos, driftDir, driftAmp, reseed, grid: { ix, iy, iz } };
            reseed(ix, iy, iz);
            return pts;
        }
        for (let ix = -1; ix <= 1; ix++) {
            for (let iy = -1; iy <= 1; iy++) {
                for (let iz = -1; iz <= 1; iz++) {
                    const tile = createSparkTile(ix, iy, iz);
                    tile.position.set(ix * SPARK_TILE, iy * SPARK_TILE, iz * SPARK_TILE);
                    worldGroup.add(tile);
                    sparkTiles.push(tile);
                }
            }
        }

        // ===== Nebula strings (Minecraft-like cube chains) =====
        // Area-varying density helper (reuse hash01 from sparks)
        const REGION_TILE = 4000;
        const ENABLE_NEBULAS = false; // show only stars in the background
        function regionDensityAt(x, z) {
            const ix = Math.floor(x / REGION_TILE);
            const iz = Math.floor(z / REGION_TILE);
            const d = 0.25 + 0.75 * (typeof hash01 === 'function' ? hash01(ix, 0, iz) : Math.random());
            return d;
        }
        const NEBULA_SPAN = 20000; // larger wrap span so far nebulas don't wrap too soon
        const NEBULA_YSPAN = 3000;
        const nebulaStrings = [];
        function createCubeStringCloud() {
            const group = new THREE.Group();
            const segments = 12 + Math.floor(Math.random() * 7); // 12-18
            const spacing = 80 + Math.random() * 80; // 80-160
            // Random oriented direction for the string
            const dir = new THREE.Vector3(Math.random()-0.5, (Math.random()-0.5)*0.3, Math.random()-0.5).normalize();
            const baseColor = new THREE.Color().setHSL(0.55 + Math.random()*0.15, 0.7, 0.6); // cyan/blue/purple-ish
            for (let i = 0; i < segments; i++) {
                const center = dir.clone().multiplyScalar(i * spacing);
                const cubesThis = 5 + Math.floor(Math.random() * 6); // 5-10, denser
                for (let j = 0; j < cubesThis; j++) {
                    const size = 16 + Math.random() * 20; // 16-36
                    const geo = new THREE.BoxGeometry(size, size, size);
                    const colorJitter = baseColor.clone().offsetHSL((Math.random()-0.5)*0.05, 0, (Math.random()-0.5)*0.05);
                    const mat = new THREE.MeshBasicMaterial({
                        color: colorJitter,
                        transparent: true,
                        opacity: 0.10 + Math.random()*0.08,
                        depthWrite: false,
                        blending: THREE.AdditiveBlending,
                        fog: false
                    });
                    const cube = new THREE.Mesh(geo, mat);
                    cube.material.userData = cube.material.userData || {};
                    cube.material.userData.baseOpacity = cube.material.opacity;
                    cube.position.copy(center).add(new THREE.Vector3(
                        (Math.random()-0.5)*80,
                        (Math.random()-0.5)*80,
                        (Math.random()-0.5)*80
                    ));
                    group.add(cube);
                }
            }
            // gentle drift for the whole string
            group.userData.drift = new THREE.Vector3(
                (Math.random()-0.5) * 0.02,
                (Math.random()-0.5) * 0.01,
                (Math.random()-0.5) * 0.02
            );
            // subtle far hint sprite
            const hintMat = new THREE.SpriteMaterial({ map: fuzzyTex, color: baseColor, transparent: true, blending: THREE.AdditiveBlending, depthWrite: false, opacity: 0.18, fog: false });
            const hint = new THREE.Sprite(hintMat);
            hint.scale.set(7000, 7000, 1);
            hint.userData.baseOpacity = hintMat.opacity;
            group.add(hint);
            group.userData.hint = hint;
            return group;
        }

        // Place strings further away in a wide shell (disabled when ENABLE_NEBULAS=false)
        if (ENABLE_NEBULAS) {
            const TARGET_NEB = 6; // fewer but denser
            let made = 0, tries = 0;
            while (made < TARGET_NEB && tries < TARGET_NEB * 12) {
                tries++;
                const cloud = createCubeStringCloud();
                const angle = Math.random() * Math.PI * 2;
                const dist = 8000 + Math.random() * 8000; // 8k-16k away
                const x = Math.cos(angle) * dist;
                const z = Math.sin(angle) * dist;
                const dens = regionDensityAt(x, z);
                if (Math.random() > dens * 0.7) continue; // keep sparse
                cloud.position.set(x, (Math.random() - 0.5) * NEBULA_YSPAN, z);
                const s = 3.0 + Math.random() * 3.5 + dens * 2.0;
                cloud.scale.setScalar(s);
                nebulaStrings.push(cloud);
                worldGroup.add(cloud);
                made++;
            }
        }

        // ===== Minecraft-like voxel asteroids =====
        const voxelAsteroids = [];
        function createVoxelAsteroid(size = 4, cubes = 12) {
            const group = new THREE.Group();
            const cubeSize = size * 0.5;
            const geo = new THREE.BoxGeometry(cubeSize, cubeSize, cubeSize);
            // Use one material per asteroid for uniform color; matte with slightly higher emissive to reduce side contrast
            const mat = new THREE.MeshLambertMaterial({ color: 0x7a7a7a, emissive: 0x1b1b1b, flatShading: true, transparent: true, opacity: 1 });
            for (let i = 0; i < cubes; i++) {
                const cube = new THREE.Mesh(geo, mat);
                cube.position.set(
                    (Math.random() - 0.5) * size * 2,
                    (Math.random() - 0.5) * size * 2,
                    (Math.random() - 0.5) * size * 2
                );
                group.add(cube);
            }
            return group;
        }

        const ASTEROID_SPAN = 7000; // wrapping span for asteroids/UFOs
        const ASTEROID_YSPAN = 1600;
        {
            const TARGET_AST = 30; // even rarer asteroids
            let made = 0, tries = 0;
            while (made < TARGET_AST && tries < TARGET_AST * 10) {
                tries++;
                const a = createVoxelAsteroid(12 + Math.random() * 16, 20 + Math.floor(Math.random() * 20));
                const angle = Math.random() * Math.PI * 2;
                const dist = 4000 + Math.random() * 6000; // 4k-10k
                const x = Math.cos(angle) * dist;
                const z = Math.sin(angle) * dist;
                const y = (Math.random() - 0.5) * ASTEROID_YSPAN;
                const dens = regionDensityAt(x, z);
                if (Math.random() > dens * 0.75) continue; // sparser in low-density areas
                a.position.set(x, y, z);
                const scale = 2.2 + Math.random() * 2.6;
                a.scale.setScalar(scale);
                a.userData.spin = new THREE.Vector3(Math.random() * 0.003, Math.random() * 0.003, Math.random() * 0.003);
                worldGroup.add(a);
                voxelAsteroids.push(a);
                made++;
            }
        }

        // ===== Blocky alien objects (UFO-like) =====
        const aliens = [];
        function createBlockyUFO() {
            const group = new THREE.Group();
            const baseGeo = new THREE.BoxGeometry(1.2, 0.3, 1.2);
            const baseMat = new THREE.MeshPhongMaterial({ color: 0x666666, emissive: 0x1a1a1a, flatShading: true });
            // build a 3x3 plate
            for (let x = -1; x <= 1; x++) {
                for (let z = -1; z <= 1; z++) {
                    const tile = new THREE.Mesh(baseGeo, baseMat);
                    tile.position.set(x * 1.25, 0, z * 1.25);
                    group.add(tile);
                }
            }
            // dome
            const dome = new THREE.Mesh(new THREE.BoxGeometry(1, 0.8, 1), new THREE.MeshPhongMaterial({ color: 0x22ff88, emissive: 0x116633 }));
            dome.position.set(0, 0.7, 0);
            group.add(dome);
            // feet
            for (let i = 0; i < 4; i++) {
                const foot = new THREE.Mesh(new THREE.BoxGeometry(0.4, 0.4, 0.4), new THREE.MeshPhongMaterial({ color: 0x555555 }));
                const angle = (i / 4) * Math.PI * 2;
                foot.position.set(Math.cos(angle) * 1.8, -0.4, Math.sin(angle) * 1.8);
                group.add(foot);
            }
            return group;
        }

        for (let i = 0; i < 35; i++) {
            const ufo = createBlockyUFO();
            const angleU = Math.random() * Math.PI * 2;
            const distU = 1500 + Math.random() * 3200;
            const yU = (Math.random() - 0.5) * ASTEROID_YSPAN;
            ufo.position.set(
                Math.cos(angleU) * distU,
                yU,
                Math.sin(angleU) * distU
            );
            ufo.userData.bobPhase = Math.random() * Math.PI * 2;
            ufo.userData.baseY = ufo.position.y;
            worldGroup.add(ufo);
            aliens.push(ufo);
        }

        // ===== Big solid voxel bodies (contiguous cubes) =====
        const bigSolids = [];
        function createVoxelSolid(radius = 60, step = 12, baseColor = new THREE.Color(0x6f6f6f)) {
            const g = new THREE.Group();
            const high = new THREE.Group();
            const low = new THREE.Group();
            // Unique color per solid; same on all faces; low emissive so light direction is visible; small specular for edge highlight
            const matHigh = new THREE.MeshPhongMaterial({ color: baseColor, emissive: baseColor.clone().multiplyScalar(0.03), flatShading: true, specular: 0x222222, shininess: 14, transparent: true, opacity: 0 });
            const matLow  = new THREE.MeshPhongMaterial({ color: baseColor, emissive: baseColor.clone().multiplyScalar(0.01), flatShading: true, specular: 0x222222, shininess: 12, transparent: true, opacity: 1 });

            // Irregular shell using simple trigs as noise
            const shellMin2 = (radius - step) * (radius - step);
            const shellMax2 = (radius + step) * (radius + step);
            const freqX = 0.11, freqY = 0.13, freqZ = 0.095;
            const amp = step * 7.0; // stronger irregularity -> less spherical
            const keepChance = 0.5; // reduce cube count more to form holes
            const highSet = new Set();
            const lowSet  = new Set();
            const key = (x,y,z) => `${x},${y},${z}`;

            // High detail: irregular shell of cubes (denser)
            for (let x = -radius; x <= radius; x += step) {
                for (let y = -radius; y <= radius; y += step) {
                    for (let z = -radius; z <= radius; z += step) {
                        const r2 = x*x + y*y + z*z;
                        if (r2 >= shellMin2 && r2 <= shellMax2) {
                            const jitter = Math.sin(x*freqX) + Math.sin(y*freqY) + Math.sin(z*freqZ);
                            const effR = radius + jitter * amp;
                            if (r2 <= effR*effR && Math.random() < keepChance) {
                                const cube = new THREE.Mesh(new THREE.BoxGeometry(step, step, step), matHigh);
                                cube.position.set(x, y, z);
                                high.add(cube);
                                highSet.add(key(x,y,z));
                            }
                        }
                    }
                }
            }

            // Low detail: sparser irregular shell (bigger cubes)
            const loStep = step * 4;
            const shellMin2L = (radius - loStep) * (radius - loStep);
            const shellMax2L = (radius + loStep) * (radius + loStep);
            for (let x = -radius; x <= radius; x += loStep) {
                for (let y = -radius; y <= radius; y += loStep) {
                    for (let z = -radius; z <= radius; z += loStep) {
                        const r2 = x*x + y*y + z*z;
                        if (r2 >= shellMin2L && r2 <= shellMax2L) {
                            const jitter = Math.sin(x*freqX) + Math.sin(y*freqY) + Math.sin(z*freqZ);
                            const effR = radius + jitter * amp;
                            if (r2 <= effR*effR) {
                                const cube = new THREE.Mesh(new THREE.BoxGeometry(loStep, loStep, loStep), matLow);
                                cube.position.set(x, y, z);
                                low.add(cube);
                                lowSet.add(key(x,y,z));
                            }
                        }
                    }
                }
            }

            high.visible = false; // keep low-res always
            low.visible = true;
            g.add(low);
            g.add(high);
            g.userData.high = high;
            g.userData.low = low;
            g.userData.matHigh = matHigh;
            g.userData.matLow = matLow;
            g.userData.cubeSetHigh = highSet;
            g.userData.cubeSetLow = lowSet;
            g.userData.stepHigh = step;
            g.userData.stepLow = step * 4;
            g.userData.collisionRadius = radius + step * 2.5;
            g.userData.radius = radius;
            return g;
        }

        for (let i = 0; i < 3; i++) {
            const R = 240 + Math.random()*160; // bigger solids 240-400
            const hue = 0.5 + Math.random()*0.4; // cyan→purple range
            const base = new THREE.Color().setHSL(hue, 0.55, 0.5);
            const solid = createVoxelSolid(R, 16, base);
            const ang = Math.random()*Math.PI*2;
            const dist = 2200 + Math.random()*3800;
            const yy = (Math.random()-0.5) * ASTEROID_YSPAN;
            solid.position.set(Math.cos(ang)*dist, yy, Math.sin(ang)*dist);
            worldGroup.add(solid);
            bigSolids.push(solid);
        }

        // ===== Strange occasional anomalies =====
        const anomalies = [];
        function createAnomaly() {
            const type = Math.floor(Math.random() * 5);
            let obj;
            if (type === 0) {
                // Monolith (boxy OK)
                obj = new THREE.Mesh(new THREE.BoxGeometry(4, 24, 4), new THREE.MeshPhongMaterial({ color: 0x111111, emissive: 0x3344ff, flatShading: true }));
            } else if (type === 1) {
                // Square ring: build a ring from boxes around a square path
                const g = new THREE.Group();
                const side = 18, thickness = 1.2, step = 1.8;
                const mat = new THREE.MeshPhongMaterial({ color: 0x8833ff, emissive: 0x4422aa, flatShading: true });
                for (let t = -side; t <= side; t += step) {
                    // top and bottom
                    g.add(new THREE.Mesh(new THREE.BoxGeometry(thickness, thickness, thickness), mat)).position.set(t, 0, -side);
                    g.add(new THREE.Mesh(new THREE.BoxGeometry(thickness, thickness, thickness), mat)).position.set(t, 0, side);
                    // left and right
                    g.add(new THREE.Mesh(new THREE.BoxGeometry(thickness, thickness, thickness), mat)).position.set(-side, 0, t);
                    g.add(new THREE.Mesh(new THREE.BoxGeometry(thickness, thickness, thickness), mat)).position.set(side, 0, t);
                }
                obj = g;
            } else if (type === 2) {
                // Step pyramid from boxes
                const g = new THREE.Group();
                const levels = 6;
                const base = 16;
                const mat = new THREE.MeshPhongMaterial({ color: 0xff2288, emissive: 0x661133, flatShading: true });
                for (let i = 0; i < levels; i++) {
                    const size = base - i*2;
                    for (let x = -size/2; x < size/2; x += 1) {
                        for (let z = -size/2; z < size/2; z += 1) {
                            const cube = new THREE.Mesh(new THREE.BoxGeometry(1, 1, 1), mat);
                            cube.position.set(x, i, z);
                            g.add(cube);
                        }
                    }
                }
                obj = g;
            } else if (type === 3) {
                // Twisted cube ribbon path (approx torus-knot-like)
                const g = new THREE.Group();
                const mat = new THREE.MeshPhongMaterial({ color: 0x00ffcc, emissive: 0x008877, flatShading: true });
                const turns = 3;
                for (let t = 0; t < Math.PI * 2 * turns; t += 0.2) {
                    const r = 12 + Math.sin(t*2)*2;
                    const x = Math.cos(t) * r;
                    const z = Math.sin(t) * r;
                    const y = Math.sin(t*1.5) * 4;
                    const cube = new THREE.Mesh(new THREE.BoxGeometry(1.2, 1.2, 1.2), mat);
                    cube.position.set(x, y, z);
                    g.add(cube);
                }
                obj = g;
            } else {
                // Cube cluster instead of orbs
                const g = new THREE.Group();
                const count = 6 + Math.floor(Math.random()*5);
                const mat = new THREE.MeshPhongMaterial({ color: 0x88ffee, emissive: 0x226666, transparent: true, opacity: 0.85, flatShading: true });
                for (let i = 0; i < count; i++) {
                    const s = 1 + Math.random()*2;
                    const m = new THREE.Mesh(new THREE.BoxGeometry(s, s, s), mat);
                    m.position.set((Math.random()-0.5)*12, (Math.random()-0.5)*12, (Math.random()-0.5)*12);
                    g.add(m);
                }
                obj = g;
            }
            const group = new THREE.Group();
            group.add(obj);
            // Add a faint glow light
            const glow = new THREE.PointLight(0x66ffee, 0.6, 60);
            group.add(glow);
            group.userData.spin = new THREE.Vector3(Math.random()*0.01, Math.random()*0.02+0.005, Math.random()*0.01);
            group.userData.bobPhase = Math.random()*Math.PI*2;
            return group;
        }

        for (let i = 0; i < 12; i++) {
            const anomaly = createAnomaly();
            const ang = Math.random() * Math.PI * 2;
            const dist = 2200 + Math.random() * 3800; // 2.2km - 6km
            const yy = (Math.random()-0.5) * ASTEROID_YSPAN;
            anomaly.position.set(Math.cos(ang)*dist, yy, Math.sin(ang)*dist);
            worldGroup.add(anomaly);
            anomalies.push(anomaly);
        }

        // Movement variables - SPACE PHYSICS: ship is reference frame
        const keys = {};
        const maxCruisingSpeed = 1.5; // slower baseline
        const maxBoostSpeed = 7.0; // slower top speed
        const acceleration = 0.0012; // gentler accel
        const boostAcceleration = 0.012; // gentler boost accel
        const maxPhysicsSpeed = 10.0; // slower cap for realistic mode
        const minTurnSpeed = 0.003; // Much slower start
        const maxTurnSpeed = 0.025; // Lower max rotation speed
        const turnAcceleration = 0.0003; // Slower acceleration = more rotational inertia
        const turnDeceleration = 0.0005; // Gradual slowdown when not turning
        const turnSlowdown = 0.985; // More aggressive speed reduction during turns

        // Rotation speed tracking
        let currentTurnSpeed = 0;

        // Boost fuel system
        let boostFuel = 100;
        const maxBoostFuel = 100;
        const boostDrainRate = 0.5; // Fuel per frame when boosting
        const boostRechargeRate = 0.15; // Fuel per frame when not boosting

        // Camera inertia
        const cameraLerpBase = 0.06; // base lag
        const cameraLerpMin = 0.025;
        const cameraLerpMax = 0.09;

        // Speed/velocity
        let currentSpeed = 0;
        const velocity = new THREE.Vector3();
        let physicsMode = false; // false = Arcade (current), true = Physics (inertial)
        let lastSpeedScalar = 0;
        const shipRadius = 1.2; // approximate radius for collision
        let shipHealth = 100;
        let isDead = false;

        // Mode toggle helpers
        const modeBtn = document.getElementById('modeToggle');
        function updateModeUI() {
            modeBtn.textContent = `Mode: ${physicsMode ? 'Physics' : 'Arcade'}`;
        }
        function setMode(next) {
            if (next === physicsMode) return;
            physicsMode = next;
            // Translate scalar speed to vector and back on mode switches
            const fwd = new THREE.Vector3(0, 0, -1).applyQuaternion(shipGroup.quaternion);
            if (physicsMode) {
                velocity.copy(fwd.multiplyScalar(currentSpeed));
            } else {
                currentSpeed = velocity.length();
                velocity.set(0, 0, 0);
            }
            updateModeUI();
        }
        updateModeUI();
        modeBtn.addEventListener('click', () => setMode(!physicsMode));

        // Input handling
        window.addEventListener('keydown', (e) => {
            keys[e.key.toLowerCase()] = true;
        });

        window.addEventListener('keyup', (e) => {
            keys[e.key.toLowerCase()] = false;
        });

        // Mobile controls
        const setupMobileButton = (btnId, key) => {
            const btn = document.getElementById(btnId);
            btn.addEventListener('touchstart', (e) => {
                e.preventDefault();
                keys[key] = true;
            });
            btn.addEventListener('touchend', (e) => {
                e.preventDefault();
                keys[key] = false;
            });
        };

        setupMobileButton('btn-left', 'a');
        setupMobileButton('btn-right', 'd');
        // Invert up/down for mobile controls
        setupMobileButton('btn-up', 's');
        setupMobileButton('btn-down', 'w');
        setupMobileButton('btn-boost', ' ');

        // Mouse movement for camera tilt
        let mouseX = 0;
        let mouseY = 0;

        window.addEventListener('mousemove', (e) => {
            mouseX = (e.clientX / window.innerWidth) * 2 - 1;
            mouseY = (e.clientY / window.innerHeight) * 2 - 1;
        });

        // Handle window resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        // Animation loop - SPACE PHYSICS: relative rotations
        function animate() {
            requestAnimationFrame(animate);

            if (isDead) {
                renderer.render(scene, camera);
                return;
            }

            // ===== ROTATION: Apply rotations in ship's local space =====
            // Track if we're turning for speed slowdown
            const isTurning = keys['a'] || keys['arrowleft'] || keys['d'] || keys['arrowright'] ||
                              keys['w'] || keys['arrowup'] || keys['s'] || keys['arrowdown'];

            // Accelerate turn speed when turning, gradually decelerate when not
            if (isTurning) {
                if (currentTurnSpeed < minTurnSpeed) {
                    currentTurnSpeed = minTurnSpeed;
                } else if (currentTurnSpeed < maxTurnSpeed) {
                    currentTurnSpeed = Math.min(currentTurnSpeed + turnAcceleration, maxTurnSpeed);
                }
            } else {
                // Gradual deceleration for rotational inertia
                currentTurnSpeed = Math.max(0, currentTurnSpeed - turnDeceleration);
            }

            // Rotate around local axes (correct for intuitive flight controls)
            if (keys['a'] || keys['arrowleft']) {
                // Yaw left around local Y axis
                shipGroup.rotateOnAxis(new THREE.Vector3(0, 1, 0), currentTurnSpeed);
            }
            if (keys['d'] || keys['arrowright']) {
                // Yaw right around local Y axis
                shipGroup.rotateOnAxis(new THREE.Vector3(0, 1, 0), -currentTurnSpeed);
            }
            if (keys['w'] || keys['arrowup']) {
                // Pitch up around local X axis
                shipGroup.rotateOnAxis(new THREE.Vector3(1, 0, 0), -currentTurnSpeed);
            }
            if (keys['s'] || keys['arrowdown']) {
                // Pitch down around local X axis
                shipGroup.rotateOnAxis(new THREE.Vector3(1, 0, 0), currentTurnSpeed);
            }

            // Get ship's orientation for camera and movement
            const shipUp = new THREE.Vector3(0, 1, 0).applyQuaternion(shipGroup.quaternion);

            // ===== MOVEMENT: Move world instead of ship (ship stays at origin, rotates in place) =====
            // Ship rotates, camera follows. World translates backwards relative to ship's forward.
            // No world rotation - the appearance of rotation comes from camera following ship.
            const forward = new THREE.Vector3(0, 0, -1);
            forward.applyQuaternion(shipGroup.quaternion);

            // Boost fuel management
            const isBoosting = keys[' '] && boostFuel > 0;
            if (isBoosting) {
                boostFuel = Math.max(0, boostFuel - boostDrainRate);
            } else {
                boostFuel = Math.min(maxBoostFuel, boostFuel + boostRechargeRate);
            }

            // Remember previous world position for solid collision resolution
            const lastWorldPos = worldGroup.position.clone();

            if (physicsMode) {
                // Inertial physics: rotation doesn't change velocity. Boost applies thrust along facing.
                if (isBoosting) {
                    const thrust = forward.clone().multiplyScalar(boostAcceleration);
                    velocity.add(thrust);
                }
                // Clamp max speed for stability
                const vLen = velocity.length();
                if (vLen > maxPhysicsSpeed) {
                    velocity.setLength(maxPhysicsSpeed);
                }
                // Move world opposite to velocity
                worldGroup.position.add(velocity.clone().multiplyScalar(-1));
            } else {
                // Arcade mode: gradual auto-accel + boost, turning slows
                const maxSpeed = isBoosting ? maxBoostSpeed : maxCruisingSpeed;
                const currentAcceleration = isBoosting ? boostAcceleration : acceleration;

                if (currentSpeed < maxSpeed) {
                    currentSpeed = Math.min(currentSpeed + currentAcceleration, maxSpeed);
                } else if (currentSpeed > maxSpeed) {
                    currentSpeed = Math.max(currentSpeed - acceleration, maxSpeed);
                }

                if (isTurning) {
                    currentSpeed *= turnSlowdown;
                }

                worldGroup.position.add(forward.multiplyScalar(-currentSpeed));
            }

            // ===== COLLISIONS with big solids (per-cube, allows flying into holes) =====
            let collided = false;
            for (const solid of bigSolids) {
                const centerX = solid.position.x + worldGroup.position.x;
                const centerY = solid.position.y + worldGroup.position.y;
                const centerZ = solid.position.z + worldGroup.position.z;
                const d = Math.sqrt(centerX*centerX + centerY*centerY + centerZ*centerZ);
                if (d > (solid.userData.collisionRadius + shipRadius + 40)) continue; // skip far solids
                // point of ship in solid's local space
                const pLocal = new THREE.Vector3(-centerX, -centerY, -centerZ);

                const testSet = (set, step) => {
                    if (!set || !step) return false;
                    const bx = Math.round(pLocal.x / step) * step;
                    const by = Math.round(pLocal.y / step) * step;
                    const bz = Math.round(pLocal.z / step) * step;
                    const half = step / 2;
                    for (let dx = -1; dx <= 1; dx++) {
                        for (let dy = -1; dy <= 1; dy++) {
                            for (let dz = -1; dz <= 1; dz++) {
                                const cx = bx + dx * step;
                                const cy = by + dy * step;
                                const cz = bz + dz * step;
                                const key = `${cx},${cy},${cz}`;
                                if (set.has(key)) {
                                    const ax = Math.abs(pLocal.x - cx);
                                    const ay = Math.abs(pLocal.y - cy);
                                    const az = Math.abs(pLocal.z - cz);
                                    if (ax <= half + shipRadius && ay <= half + shipRadius && az <= half + shipRadius) {
                                        return true;
                                    }
                                }
                            }
                        }
                    }
                    return false;
                };

                if (testSet(solid.userData.cubeSetHigh, solid.userData.stepHigh) || testSet(solid.userData.cubeSetLow, solid.userData.stepLow)) {
                    collided = true;
                    break;
                }
            }
            if (collided) {
                // revert position to prevent penetration
                worldGroup.position.copy(lastWorldPos);
                // apply damage based on speed
                const speedScalar = physicsMode ? velocity.length() : currentSpeed;
                const impact = Math.max(0.6, Math.min(3.0, speedScalar * 1.2 + (isBoosting ? 0.8 : 0)));
                shipHealth = Math.max(0, shipHealth - impact);
                // slow down
                if (physicsMode) {
                    velocity.multiplyScalar(0.3);
                } else {
                    currentSpeed *= 0.4;
                }
                // show quick engine flare down
                engine.material.opacity = 0.3;
                if (shipHealth <= 0) {
                    isDead = true;
                    const overlay = document.getElementById('deathOverlay');
                    if (overlay) overlay.style.display = 'flex';
                }
            }

            // ===== CAMERA: Smooth follow with inertia =====
            // Calculate target camera position in ship's local space
            const localCameraOffset = new THREE.Vector3(0, 3, 8);
            const worldCameraOffset = localCameraOffset.clone().applyQuaternion(shipGroup.quaternion);
            const targetCameraPosition = shipGroup.position.clone().add(worldCameraOffset);

            // Smoothly interpolate camera position toward target (creates lag/inertia)
            const speedScalarNow = physicsMode ? velocity.length() : currentSpeed;
            const accelMag = Math.max(0, speedScalarNow - lastSpeedScalar);
            const camLerp = Math.max(
                cameraLerpMin,
                Math.min(cameraLerpMax, cameraLerpBase - accelMag * 0.05)
            );
            camera.position.lerp(targetCameraPosition, camLerp);

            // Smoothly interpolate camera's up vector
            const targetUp = shipUp.clone();
            camera.up.lerp(targetUp, camLerp);

            camera.lookAt(shipGroup.position);
            lastSpeedScalar = speedScalarNow;

            // ===== VISUALS: Engine glow =====
            const engineGlow = isBoosting ? 0.5 : 0;
            engine.material.opacity = 0.5 + Math.sin(Date.now() * 0.01) * 0.3 + engineGlow;
            engine.scale.setScalar(1 + engineGlow);

            // Animate voxel asteroids (slow spin) + wrap for infinite field
            for (const a of voxelAsteroids) {
                a.rotation.x += a.userData.spin.x;
                a.rotation.y += a.userData.spin.y;
                a.rotation.z += a.userData.spin.z;
                const wx = a.position.x + worldGroup.position.x;
                const wy = a.position.y + worldGroup.position.y;
                const wz = a.position.z + worldGroup.position.z;
                if (wx >  ASTEROID_SPAN / 2) a.position.x -= ASTEROID_SPAN; else if (wx < -ASTEROID_SPAN / 2) a.position.x += ASTEROID_SPAN;
                if (wz >  ASTEROID_SPAN / 2) a.position.z -= ASTEROID_SPAN; else if (wz < -ASTEROID_SPAN / 2) a.position.z += ASTEROID_SPAN;
                if (wy >  ASTEROID_YSPAN / 2) a.position.y -= ASTEROID_YSPAN; else if (wy < -ASTEROID_YSPAN / 2) a.position.y += ASTEROID_YSPAN;
                // subtle distance fade so they can be seen from afar without clutter
                if (a.children && a.children.length) {
                    const d = Math.sqrt(wx*wx + wy*wy + wz*wz);
                    const near = 9000; const blend = 6000;
                    const t = Math.max(0, Math.min(1, (near - d) / blend));
                    const mat = a.children[0].material; // shared within group
                    if (mat && mat.transparent !== undefined) {
                        mat.transparent = true;
                        mat.opacity = 0.12 + 0.88 * t;
                    }
                }
            }

            // Animate aliens (gentle bob + slow yaw) + wrap
            for (const ufo of aliens) {
                ufo.userData.bobPhase += 0.03;
                ufo.position.y = ufo.userData.baseY + Math.sin(ufo.userData.bobPhase) * 1.2;
                ufo.rotation.y += 0.01;
                const wx = ufo.position.x + worldGroup.position.x;
                const wy = ufo.position.y + worldGroup.position.y;
                const wz = ufo.position.z + worldGroup.position.z;
                if (wx >  ASTEROID_SPAN / 2) ufo.position.x -= ASTEROID_SPAN; else if (wx < -ASTEROID_SPAN / 2) ufo.position.x += ASTEROID_SPAN;
                if (wz >  ASTEROID_SPAN / 2) ufo.position.z -= ASTEROID_SPAN; else if (wz < -ASTEROID_SPAN / 2) ufo.position.z += ASTEROID_SPAN;
                if (wy >  ASTEROID_YSPAN / 2) ufo.position.y -= ASTEROID_YSPAN; else if (wy < -ASTEROID_YSPAN / 2) ufo.position.y += ASTEROID_YSPAN;
            }

            // Wrap and reseed star tiles to maintain infinite field
            for (const tile of starTiles) {
                let reseeded = false;
                const dx = tile.position.x + worldGroup.position.x;
                const dy = tile.position.y + worldGroup.position.y;
                const dz = tile.position.z + worldGroup.position.z;
                if (dx > STAR_TILE * 1.5) { tile.position.x -= STAR_TILE * STAR_GRID; reseeded = true; }
                else if (dx < -STAR_TILE * 1.5) { tile.position.x += STAR_TILE * STAR_GRID; reseeded = true; }
                if (dy > STAR_TILE * 1.5) { tile.position.y -= STAR_TILE * STAR_GRID; reseeded = true; }
                else if (dy < -STAR_TILE * 1.5) { tile.position.y += STAR_TILE * STAR_GRID; reseeded = true; }
                if (dz > STAR_TILE * 1.5) { tile.position.z -= STAR_TILE * STAR_GRID; reseeded = true; }
                else if (dz < -STAR_TILE * 1.5) { tile.position.z += STAR_TILE * STAR_GRID; reseeded = true; }
                if (reseeded && tile.userData.reseed) tile.userData.reseed();
            }

            // Wrap + reseed spark tiles, and animate twinkle
            for (const tile of sparkTiles) {
                let reseeded = false;
                const dx = tile.position.x + worldGroup.position.x;
                const dy = tile.position.y + worldGroup.position.y;
                const dz = tile.position.z + worldGroup.position.z;
                if (dx > SPARK_TILE * 1.5) { tile.position.x -= SPARK_TILE * SPARK_GRID; reseeded = true; }
                else if (dx < -SPARK_TILE * 1.5) { tile.position.x += SPARK_TILE * SPARK_GRID; reseeded = true; }
                if (dy > SPARK_TILE * 1.5) { tile.position.y -= SPARK_TILE * SPARK_GRID; reseeded = true; }
                else if (dy < -SPARK_TILE * 1.5) { tile.position.y += SPARK_TILE * SPARK_GRID; reseeded = true; }
                if (dz > SPARK_TILE * 1.5) { tile.position.z -= SPARK_TILE * SPARK_GRID; reseeded = true; }
                else if (dz < -SPARK_TILE * 1.5) { tile.position.z += SPARK_TILE * SPARK_GRID; reseeded = true; }

                if (reseeded && tile.userData && tile.userData.reseed) {
                    const gi = Math.round(tile.position.x / SPARK_TILE);
                    const gj = Math.round(tile.position.y / SPARK_TILE);
                    const gk = Math.round(tile.position.z / SPARK_TILE);
                    tile.userData.reseed(gi, gj, gk);
                }

                // Twinkle animation: modulate RGB by sinus factor
                const geom = tile.geometry;
                const col = geom.getAttribute('color');
                const pos = geom.getAttribute('position');
                const base = tile.userData.baseColors;
                const phases = tile.userData.phases;
                const speeds = tile.userData.speeds;
                const basePos = tile.userData.basePos;
                const driftDir = tile.userData.driftDir;
                const driftAmp = tile.userData.driftAmp;
                if (col && base && phases && speeds && pos && basePos && driftDir && driftAmp) {
                    for (let i = 0; i < phases.length; i++) {
                        phases[i] += speeds[i];
                        const j = i * 3;
                        const s = Math.sin(phases[i] * 1.6);
                        // twinkle color
                        let f = 0.65 + 0.35 * s;
                        // drift position
                        const off = s * driftAmp[i];
                        pos.array[j + 0] = basePos[j + 0] + driftDir[j + 0] * off;
                        pos.array[j + 1] = basePos[j + 1] + driftDir[j + 1] * off;
                        pos.array[j + 2] = basePos[j + 2] + driftDir[j + 2] * off;
                        // distance fade to make particles pop only when near the ship (origin)
                        const wx = tile.position.x + worldGroup.position.x + pos.array[j + 0];
                        const wy = tile.position.y + worldGroup.position.y + pos.array[j + 1];
                        const wz = tile.position.z + worldGroup.position.z + pos.array[j + 2];
                        const d = Math.sqrt(wx*wx + wy*wy + wz*wz);
                        let near = 0;
                        if (d <= SPARK_NEAR_FADE_START) near = 1;
                        else if (d >= SPARK_NEAR_FADE_END) near = 0;
                        else near = 1 - ((d - SPARK_NEAR_FADE_START) / (SPARK_NEAR_FADE_END - SPARK_NEAR_FADE_START));
                        // soften curve and keep a tiny base visibility far away
                        const nf = 0.08 + 0.92 * (near * near);
                        const vis = f * nf;
                        col.array[j + 0] = base[j + 0] * vis;
                        col.array[j + 1] = base[j + 1] * vis;
                        col.array[j + 2] = base[j + 2] * vis;
                    }
                    col.needsUpdate = true;
                    pos.needsUpdate = true;
                }
            }

            // Big solids: always show low-res; no high-res crossfade
            for (const solid of bigSolids) {
                const matHigh = solid.userData.matHigh;
                const matLow = solid.userData.matLow;
                if (matHigh) { matHigh.opacity = 0; }
                if (matLow) { matLow.opacity = 1; }
                if (solid.userData.high) solid.userData.high.visible = false;
                if (solid.userData.low) solid.userData.low.visible = true;
            }

            // Animate anomalies (spin, bob) + wrap
            for (const an of anomalies) {
                an.children[0].rotation.x += an.userData.spin.x;
                an.children[0].rotation.y += an.userData.spin.y;
                an.children[0].rotation.z += an.userData.spin.z;
                an.userData.bobPhase += 0.01;
                an.position.y += Math.sin(an.userData.bobPhase) * 0.05;
                const wx = an.position.x + worldGroup.position.x;
                const wy = an.position.y + worldGroup.position.y;
                const wz = an.position.z + worldGroup.position.z;
                if (wx >  ASTEROID_SPAN / 2) an.position.x -= ASTEROID_SPAN; else if (wx < -ASTEROID_SPAN / 2) an.position.x += ASTEROID_SPAN;
                if (wz >  ASTEROID_SPAN / 2) an.position.z -= ASTEROID_SPAN; else if (wz < -ASTEROID_SPAN / 2) an.position.z += ASTEROID_SPAN;
                if (wy >  ASTEROID_YSPAN / 2) an.position.y -= ASTEROID_YSPAN; else if (wy < -ASTEROID_YSPAN / 2) an.position.y += ASTEROID_YSPAN;
            }

            // Animate and wrap nebula strings for an infinite feel + crossfade far hints
            for (const cloud of nebulaStrings) {
                cloud.position.add(cloud.userData.drift);
                const wx = cloud.position.x + worldGroup.position.x;
                const wy = cloud.position.y + worldGroup.position.y;
                const wz = cloud.position.z + worldGroup.position.z;
                if (wx >  NEBULA_SPAN / 2) cloud.position.x -= NEBULA_SPAN; else if (wx < -NEBULA_SPAN / 2) cloud.position.x += NEBULA_SPAN;
                if (wz >  NEBULA_SPAN / 2) cloud.position.z -= NEBULA_SPAN; else if (wz < -NEBULA_SPAN / 2) cloud.position.z += NEBULA_SPAN;
                if (wy >  NEBULA_YSPAN / 2) cloud.position.y -= NEBULA_YSPAN; else if (wy < -NEBULA_YSPAN / 2) cloud.position.y += NEBULA_YSPAN;
                // crossfade cubes vs. far hint sprite
                const d = Math.sqrt(wx*wx + wy*wy + wz*wz);
                const near = 13000; const blend = 9000;
                const t = Math.max(0, Math.min(1, (near - d) / blend)); // 0 far -> 1 near
                const hint = cloud.userData.hint;
                if (hint && hint.material) {
                    hint.material.opacity = (hint.userData.baseOpacity || 0.08) * (1 - t);
                }
                for (const child of cloud.children) {
                    if (child.isSprite) continue;
                    if (child.material && child.material.userData && child.material.userData.baseOpacity !== undefined) {
                        child.material.opacity = child.material.userData.baseOpacity * t;
                    }
                }
            }

            // Subtle pulse for fuzzy background stars
            for (const spr of fuzzySky.children) {
                spr.userData.phase += spr.userData.speed;
                const f = 0.75 + 0.25 * Math.sin(spr.userData.phase);
                spr.material.opacity = spr.userData.baseOpacity * f;
            }

            // Update UI
            const speedScalar = physicsMode ? velocity.length() : currentSpeed;
            const speedDisplay = Math.round(speedScalar * 50);
            document.getElementById('speed').textContent = `Speed: ${speedDisplay} ${isBoosting ? '⚡' : ''}`;

            const boostPercent = Math.round(boostFuel);
            const boostFill = document.getElementById('boostFill');
            if (boostFill) {
                boostFill.style.width = `${boostPercent}%`;
                // Color shift: red (<20), amber (<50), cyan otherwise
                const color = boostFuel < 20 ? '#ff4444' : (boostFuel < 50 ? '#ffaa00' : '#00ffff');
                boostFill.style.background = `linear-gradient(90deg, ${color}, ${color === '#00ffff' ? '#00b3b3' : color})`;
            }

            // Update health UI
            const healthFill = document.getElementById('healthFill');
            if (healthFill) {
                healthFill.style.width = `${shipHealth}%`;
                const hcolor = shipHealth < 25 ? '#ff3333' : (shipHealth < 60 ? '#ffaa00' : '#22ff55');
                healthFill.style.background = `linear-gradient(90deg, ${hcolor}, ${hcolor})`;
            }

            // Render
            renderer.render(scene, camera);
        }

        animate();

        // Respawn handler
        const deathOverlay = document.getElementById('deathOverlay');
        function respawn() {
            if (!isDead) return;
            isDead = false;
            shipHealth = 100;
            currentSpeed = 0;
            velocity.set(0,0,0);
            worldGroup.position.set(0,0,0);
            if (deathOverlay) deathOverlay.style.display = 'none';
        }
        window.addEventListener('keydown', (e) => {
            if (e.key.toLowerCase() === 'r') respawn();
        });
        window.addEventListener('pointerdown', () => respawn());
    </script>
</body>
</html>
