<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SpaceCraft</title>
    <link rel="icon" href="https://emojicdn.elk.sh/⛏️" type="image/png">

    <!-- Open Graph Meta Tags -->
    <meta property="og:title" content="SpaceCraft">
    <meta property="og:description" content="Fly your craft over an endless voxel world — Minecraft vibes, fast and smooth.">
    <meta property="og:url" content="https://app.vibecodedbyx.com/space-flight">
    <meta property="og:image" content="https://app.vibecodedbyx.com/space-flight/preview.png">

    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            overflow: hidden;
            background: #87ceeb;
        }

        #gameCanvas {
            display: block;
            width: 100vw;
            height: 100vh;
        }

        #ui {
            position: fixed;
            top: 20px;
            left: 20px;
            color: #fff;
            font-size: 16px;
            text-shadow: 0 0 10px rgba(0, 255, 255, 0.8);
            z-index: 100;
            pointer-events: none;
        }

        #controls {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            color: #fff;
            text-align: center;
            font-size: 14px;
            background: rgba(0, 0, 0, 0.6);
            padding: 15px 25px;
            border-radius: 10px;
            backdrop-filter: blur(10px);
            z-index: 100;
        }

        #backlink {
            position: fixed;
            top: 20px;
            right: 20px;
            z-index: 100;
        }

        #backlink a {
            color: #00ffff;
            text-decoration: none;
            font-size: 14px;
            background: rgba(0, 0, 0, 0.6);
            padding: 10px 20px;
            border-radius: 5px;
            backdrop-filter: blur(10px);
            transition: all 0.3s;
        }

        #backlink a:hover {
            background: rgba(0, 255, 255, 0.2);
            transform: scale(1.05);
        }

        .mobile-controls {
            position: fixed;
            bottom: 20px;
            display: none;
            z-index: 100;
        }

        .mobile-controls button {
            width: 60px;
            height: 60px;
            border-radius: 50%;
            background: rgba(0, 255, 255, 0.3);
            border: 2px solid #00ffff;
            color: #fff;
            font-size: 24px;
            margin: 5px;
            backdrop-filter: blur(10px);
            touch-action: manipulation;
        }

        .mobile-controls button:active {
            background: rgba(0, 255, 255, 0.6);
        }

        #left-controls {
            left: 20px;
        }

        #right-controls {
            right: 20px;
        }

        @media (max-width: 768px) {
            .mobile-controls {
                display: flex;
                gap: 10px;
            }
            #controls {
                display: none;
            }
        }
    </style>
</head>
<body>
    <div id="ui">
        <div>⛏️ SpaceCraft</div>
        <div id="speed">Speed: 0</div>
    </div>

    <div id="backlink">
        <a href="https://www.vibecodedbyx.com">← Back to Stream</a>
    </div>

    <div id="controls">
        <strong>Controls:</strong> W/S or ↑/↓ to pitch • A/D or ←/→ to yaw • Space to boost • Auto-accelerates forward
    </div>

    <div class="mobile-controls" id="left-controls">
        <button id="btn-left">←</button>
        <button id="btn-right">→</button>
    </div>

    <div class="mobile-controls" id="right-controls">
        <button id="btn-up">↑</button>
        <button id="btn-down">↓</button>
        <button id="btn-boost">⚡</button>
    </div>

    <script type="importmap">
    {
        "imports": {
            "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
            "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
        }
    }
    </script>

    <script type="module">
        // v4.3 - Removed world rotation, only ship rotates with camera following
        import * as THREE from 'three';

        // Scene setup
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 10000);
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        document.body.appendChild(renderer.domElement);

        // Daytime sky + light fog
        scene.background = new THREE.Color(0x87ceeb);
        scene.fog = new THREE.FogExp2(0x9fd3ff, 0.0008);

        // Spaceship
        const shipGroup = new THREE.Group();

        // Main body
        const bodyGeometry = new THREE.ConeGeometry(0.5, 2, 4);
        const bodyMaterial = new THREE.MeshPhongMaterial({
            color: 0x00ffff,
            emissive: 0x0088ff,
            shininess: 100
        });
        const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
        body.rotation.x = Math.PI / 2;
        shipGroup.add(body);

        // Wings
        const wingGeometry = new THREE.BoxGeometry(2, 0.1, 0.8);
        const wingMaterial = new THREE.MeshPhongMaterial({
            color: 0xff00ff,
            emissive: 0x880088
        });
        const wings = new THREE.Mesh(wingGeometry, wingMaterial);
        wings.position.z = 0.3;
        shipGroup.add(wings);

        // Engine glow
        const engineGeometry = new THREE.SphereGeometry(0.3, 16, 16);
        const engineMaterial = new THREE.MeshBasicMaterial({
            color: 0xff6600,
            transparent: true,
            opacity: 0.8
        });
        const engine = new THREE.Mesh(engineGeometry, engineMaterial);
        engine.position.z = 1.2;
        shipGroup.add(engine);

        scene.add(shipGroup);
        shipGroup.position.set(0, 0, 0);

        // Camera offset from ship
        camera.position.set(0, 3, 8);
        camera.lookAt(shipGroup.position);

        // Lighting
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
        scene.add(ambientLight);

        const sunLight = new THREE.DirectionalLight(0xffffff, 1.0);
        sunLight.position.set(50, 100, 20);
        scene.add(sunLight);

        const shipLight = new THREE.PointLight(0x00ffff, 1, 20);
        shipGroup.add(shipLight);

        // Create world group - contains all objects that move relative to ship
        const worldGroup = new THREE.Group();
        scene.add(worldGroup);

        // ===== Voxel terrain (Minecraft-like) =====
        const CHUNK_SIZE = 64;   // tiles per side
        const TILE_SIZE = 2;     // world units per tile
        const HALF = CHUNK_SIZE / 2;
        const SEA_LEVEL = 6;
        const CHUNK_SPAN = CHUNK_SIZE * TILE_SIZE;

        // Simple deterministic 2D height function (fast, no deps)
        function heightAt(ix, iz) {
            const s1 = Math.sin(ix * 0.18) + Math.cos(iz * 0.16);
            const s2 = Math.sin((ix + iz) * 0.09) * 0.7;
            const s3 = Math.cos((ix - iz) * 0.11) * 0.5;
            const n = (s1 + s2 + s3) / (1 + 0.7 + 0.5); // ~[-1,1]
            return Math.floor(SEA_LEVEL + 2 + n * 6);
        }

        // Build one chunk instanced mesh
        function createChunk() {
            const chunkGroup = new THREE.Group();

            const boxGeo = new THREE.BoxGeometry(TILE_SIZE, TILE_SIZE, TILE_SIZE);
            const boxMat = new THREE.MeshLambertMaterial({ vertexColors: true });
            const instanceCount = CHUNK_SIZE * CHUNK_SIZE;
            const inst = new THREE.InstancedMesh(boxGeo, boxMat, instanceCount);
            inst.instanceMatrix.setUsage(THREE.DynamicDrawUsage);

            const dummy = new THREE.Object3D();
            const color = new THREE.Color();
            let i = 0;
            for (let gz = 0; gz < CHUNK_SIZE; gz++) {
                for (let gx = 0; gx < CHUNK_SIZE; gx++) {
                    const ix = gx - HALF;
                    const iz = gz - HALF;
                    const h = heightAt(ix, iz);

                    const x = ix * TILE_SIZE;
                    const z = iz * TILE_SIZE;
                    const y = h * TILE_SIZE;

                    dummy.position.set(x, y, z);
                    dummy.rotation.set(0, 0, 0);
                    dummy.updateMatrix();
                    inst.setMatrixAt(i, dummy.matrix);

                    // Simple biome-ish coloring
                    if (h <= SEA_LEVEL) {
                        color.setHex(0xC2B280); // sand near water
                    } else if (h < SEA_LEVEL + 2) {
                        color.setHex(0x7ec850); // light grass
                    } else if (h < SEA_LEVEL + 5) {
                        color.setHex(0x3cb043); // grass
                    } else {
                        color.setHex(0x6b8e23); // darker highlands
                    }
                    // vary slightly for texture
                    color.offsetHSL(0, 0, (Math.sin((ix + iz) * 0.37) * 0.04));
                    inst.setColorAt(i, color);
                    i++;
                }
            }
            inst.instanceMatrix.needsUpdate = true;
            inst.instanceColor.needsUpdate = true;
            chunkGroup.add(inst);

            // Water plane
            const waterGeo = new THREE.PlaneGeometry(CHUNK_SPAN, CHUNK_SPAN, 1, 1);
            const waterMat = new THREE.MeshPhongMaterial({ color: 0x1e90ff, transparent: true, opacity: 0.55, side: THREE.DoubleSide });
            const water = new THREE.Mesh(waterGeo, waterMat);
            water.rotation.x = -Math.PI / 2;
            water.position.y = SEA_LEVEL * TILE_SIZE + 0.1;
            chunkGroup.add(water);

            return chunkGroup;
        }

        // Create 3x3 tiled chunks to fake infinite terrain
        const tileGroup = new THREE.Group();
        const offsets = [-CHUNK_SPAN, 0, CHUNK_SPAN];
        offsets.forEach(dx => {
            offsets.forEach(dz => {
                const chunk = createChunk();
                chunk.position.set(dx, 0, dz);
                tileGroup.add(chunk);
            });
        });
        worldGroup.add(tileGroup);

        // Movement variables - SPACE PHYSICS: ship is reference frame
        const keys = {};
        const baseSpeed = 0.5;
        const boostSpeed = 1.0;
        const turnSpeed = 0.025;

        // Input handling
        window.addEventListener('keydown', (e) => {
            keys[e.key.toLowerCase()] = true;
        });

        window.addEventListener('keyup', (e) => {
            keys[e.key.toLowerCase()] = false;
        });

        // Mobile controls
        const setupMobileButton = (btnId, key) => {
            const btn = document.getElementById(btnId);
            btn.addEventListener('touchstart', (e) => {
                e.preventDefault();
                keys[key] = true;
            });
            btn.addEventListener('touchend', (e) => {
                e.preventDefault();
                keys[key] = false;
            });
        };

        setupMobileButton('btn-left', 'a');
        setupMobileButton('btn-right', 'd');
        setupMobileButton('btn-up', 'w');
        setupMobileButton('btn-down', 's');
        setupMobileButton('btn-boost', ' ');

        // Mouse movement for camera tilt
        let mouseX = 0;
        let mouseY = 0;

        window.addEventListener('mousemove', (e) => {
            mouseX = (e.clientX / window.innerWidth) * 2 - 1;
            mouseY = (e.clientY / window.innerHeight) * 2 - 1;
        });

        // Handle window resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        // Animation loop - SPACE PHYSICS: relative rotations
        function animate() {
            requestAnimationFrame(animate);

            // ===== ROTATION: Apply rotations in ship's local space =====
            // Rotate around local axes (correct for intuitive flight controls)
            if (keys['a'] || keys['arrowleft']) {
                // Yaw left around local Y axis
                shipGroup.rotateOnAxis(new THREE.Vector3(0, 1, 0), turnSpeed);
            }
            if (keys['d'] || keys['arrowright']) {
                // Yaw right around local Y axis
                shipGroup.rotateOnAxis(new THREE.Vector3(0, 1, 0), -turnSpeed);
            }
            if (keys['w'] || keys['arrowup']) {
                // Pitch up around local X axis
                shipGroup.rotateOnAxis(new THREE.Vector3(1, 0, 0), -turnSpeed);
            }
            if (keys['s'] || keys['arrowdown']) {
                // Pitch down around local X axis
                shipGroup.rotateOnAxis(new THREE.Vector3(1, 0, 0), turnSpeed);
            }

            // Get ship's orientation for camera and movement
            const shipUp = new THREE.Vector3(0, 1, 0).applyQuaternion(shipGroup.quaternion);

            // ===== MOVEMENT: Move world instead of ship (ship stays at origin, rotates in place) =====
            // Ship rotates, camera follows. World translates backwards relative to ship's forward.
            // No world rotation - the appearance of rotation comes from camera following ship.
            const forward = new THREE.Vector3(0, 0, -1);
            forward.applyQuaternion(shipGroup.quaternion);

            const speed = keys[' '] ? boostSpeed : baseSpeed;
            // Move world in opposite direction to ship's forward
            worldGroup.position.add(forward.multiplyScalar(-speed));

            // Wrap world position to keep the tiled chunk centered
            worldGroup.position.x = ((worldGroup.position.x + CHUNK_SPAN / 2) % CHUNK_SPAN) - CHUNK_SPAN / 2;
            worldGroup.position.z = ((worldGroup.position.z + CHUNK_SPAN / 2) % CHUNK_SPAN) - CHUNK_SPAN / 2;

            // ===== CAMERA: Fixed position in ship's local space (no inertia) =====
            // Camera is at (0, 3, 8) in ship's local coordinates: 3 up, 8 back
            const localCameraOffset = new THREE.Vector3(0, 3, 8);
            const worldCameraOffset = localCameraOffset.clone().applyQuaternion(shipGroup.quaternion);

            camera.position.copy(shipGroup.position).add(worldCameraOffset);

            // Set camera's up vector to match ship's local up (reuse shipUp from rotation)
            camera.up.copy(shipUp);

            camera.lookAt(shipGroup.position);

            // ===== VISUALS: Engine glow =====
            const engineGlow = keys[' '] ? 0.5 : 0;
            engine.material.opacity = 0.5 + Math.sin(Date.now() * 0.01) * 0.3 + engineGlow;
            engine.scale.setScalar(1 + engineGlow);

            // No orbital bodies in voxel world; keep scene static besides world translation

            // Update UI
            const speedDisplay = Math.round((keys[' '] ? boostSpeed : baseSpeed) * 50);
            document.getElementById('speed').textContent = `Speed: ${speedDisplay} ${keys[' '] ? '⚡' : ''}`;

            // Render
            renderer.render(scene, camera);
        }

        animate();
    </script>
</body>
</html>
