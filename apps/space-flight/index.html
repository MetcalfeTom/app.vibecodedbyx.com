<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SpaceCraft</title>
    <link rel="icon" href="https://emojicdn.elk.sh/⛏️" type="image/png">

    <!-- Open Graph Meta Tags -->
    <meta property="og:title" content="SpaceCraft">
    <meta property="og:description" content="Dark starfield flight with Minecraft-like asteroids and blocky alien crafts.">
    <meta property="og:url" content="https://app.vibecodedbyx.com/space-flight">
    <meta property="og:image" content="https://app.vibecodedbyx.com/space-flight/preview.png">

    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            overflow: hidden;
            background: #000;
        }

        #gameCanvas {
            display: block;
            width: 100vw;
            height: 100vh;
        }

        #ui {
            position: fixed;
            top: 20px;
            left: 20px;
            color: #fff;
            font-size: 16px;
            text-shadow: 0 0 10px rgba(0, 255, 255, 0.8);
            z-index: 100;
            pointer-events: none;
        }
        /* Toggle + boost sit under stream link (top-right) */
        #modeToggle {
            margin-top: 10px;
            font-size: 12px;
            color: #001a1a;
            background: #00ffff;
            border: none;
            border-radius: 6px;
            padding: 6px 10px;
            cursor: pointer;
        }
        #modeToggle:hover { filter: brightness(0.9); }

        #controls {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            color: #fff;
            text-align: center;
            font-size: 14px;
            background: rgba(0, 0, 0, 0.6);
            padding: 15px 25px;
            border-radius: 10px;
            backdrop-filter: blur(10px);
            z-index: 100;
            display: none; /* hidden on desktop, shown on mobile */
        }

        #backlink {
            position: fixed;
            top: 20px;
            right: 20px;
            z-index: 100;
            display: flex;
            flex-direction: column;
            align-items: flex-end;
            gap: 8px;
        }

        #backlink a {
            color: #00ffff;
            text-decoration: none;
            font-size: 14px;
            background: rgba(0, 0, 0, 0.6);
            padding: 10px 20px;
            border-radius: 5px;
            backdrop-filter: blur(10px);
            transition: all 0.3s;
        }

        #backlink a:hover {
            background: rgba(0, 255, 255, 0.2);
            transform: scale(1.05);
        }

        .mobile-controls {
            position: fixed;
            bottom: 20px;
            display: none;
            z-index: 100;
        }

        /* Diamond layout container (mobile) */
        .diamond-controls {
            left: 50%;
            transform: translateX(-50%);
            display: none; /* enabled via media query */
            grid-template-columns: 64px 64px 64px 64px; /* extra column for side boost */
            grid-template-rows: 64px 64px 64px;
            grid-template-areas:
                ". up . ."
                "left . right boost"
                ". down . .";
            gap: 10px;
        }

        /* Place buttons into grid areas */
        #btn-up { grid-area: up; }
        #btn-left { grid-area: left; }
        #btn-right { grid-area: right; }
        #btn-down { grid-area: down; }
        #btn-boost { grid-area: boost; }

        .mobile-controls button {
            width: 60px;
            height: 60px;
            border-radius: 50%;
            background: rgba(0, 255, 255, 0.3);
            border: 2px solid #00ffff;
            color: #fff;
            font-size: 24px;
            margin: 5px;
            backdrop-filter: blur(10px);
            touch-action: manipulation;
        }

        .mobile-controls button:active {
            background: rgba(0, 255, 255, 0.6);
        }

        /* Subtle boost meter under toggle */
        #boostMeter {
            width: 180px;
            height: 8px;
            border-radius: 8px;
            background: rgba(0, 255, 255, 0.12);
            overflow: hidden;
            box-shadow: 0 0 10px rgba(0,255,255,0.2) inset;
        }
        #boostFill {
            height: 100%;
            width: 100%;
            background: linear-gradient(90deg, #00ffff, #00b3b3);
            transition: width 0.15s ease-out, background-color 0.2s ease-out;
        }

        /* left/right containers removed in favor of diamond layout */

        @media (max-width: 768px) {
            .diamond-controls { display: grid; }
            #controls { display: block; }
        }
    </style>
</head>
<body>
    <div id="ui">
        <div>⛏️ SpaceCraft</div>
        <div id="speed">Speed: 0</div>
        <!-- old text boost removed in favor of subtle bar -->
    </div>

    <div id="backlink">
        <a href="https://www.vibecodedbyx.com">← Back to Stream</a>
        <button id="modeToggle" title="Toggle Arcade/Physics">Mode: Arcade</button>
        <div id="boostMeter" aria-label="Boost fuel"><div id="boostFill" style="width: 100%"></div></div>
    </div>

    <div id="controls">
        <strong>Controls:</strong> W/S or ↑/↓ to pitch • A/D or ←/→ to yaw • Space to boost • Auto-accelerates forward
    </div>

    <div class="mobile-controls diamond-controls" id="diamond-controls">
        <button id="btn-up">↑</button>
        <button id="btn-left">←</button>
        <button id="btn-boost">⚡</button>
        <button id="btn-right">→</button>
        <button id="btn-down">↓</button>
    </div>

    <script type="importmap">
    {
        "imports": {
            "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
            "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
        }
    }
    </script>

    <script type="module">
        // v4.3 - Removed world rotation, only ship rotates with camera following
        import * as THREE from 'three';

        // Scene setup
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 10000);
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        document.body.appendChild(renderer.domElement);

        // Space sky + subtle fog
        scene.background = new THREE.Color(0x000000);
        scene.fog = new THREE.FogExp2(0x000022, 0.0005);

        // Spaceship
        const shipGroup = new THREE.Group();

        // Main body
        const bodyGeometry = new THREE.ConeGeometry(0.5, 2, 4);
        const bodyMaterial = new THREE.MeshPhongMaterial({
            color: 0x00ffff,
            emissive: 0x0088ff,
            shininess: 100
        });
        const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
        body.rotation.x = Math.PI / 2;
        shipGroup.add(body);

        // Wings
        const wingGeometry = new THREE.BoxGeometry(2, 0.1, 0.8);
        const wingMaterial = new THREE.MeshPhongMaterial({
            color: 0xff00ff,
            emissive: 0x880088
        });
        const wings = new THREE.Mesh(wingGeometry, wingMaterial);
        wings.position.z = 0.3;
        shipGroup.add(wings);

        // Engine glow
        const engineGeometry = new THREE.SphereGeometry(0.3, 16, 16);
        const engineMaterial = new THREE.MeshBasicMaterial({
            color: 0xff6600,
            transparent: true,
            opacity: 0.8
        });
        const engine = new THREE.Mesh(engineGeometry, engineMaterial);
        engine.position.z = 1.2;
        shipGroup.add(engine);

        scene.add(shipGroup);
        shipGroup.position.set(0, 0, 0);

        // Camera offset from ship
        camera.position.set(0, 3, 8);
        camera.lookAt(shipGroup.position);

        // Lighting
        const ambientLight = new THREE.AmbientLight(0x404040, 1);
        scene.add(ambientLight);

        const pointLight = new THREE.PointLight(0xffffff, 1.8, 120);
        pointLight.position.set(10, 10, 10);
        scene.add(pointLight);

        const shipLight = new THREE.PointLight(0x00ffff, 1, 20);
        shipGroup.add(shipLight);

        // Create world group - contains all objects that move relative to ship
        const worldGroup = new THREE.Group();
        scene.add(worldGroup);

        // ===== Starfield background =====
        const starGeometry = new THREE.BufferGeometry();
        const starVertices = [];
        const starColors = [];
        for (let i = 0; i < 22000; i++) {
            const x = (Math.random() - 0.5) * 3000;
            const y = (Math.random() - 0.5) * 3000;
            const z = (Math.random() - 0.5) * 3000;
            starVertices.push(x, y, z);
            const color = new THREE.Color();
            color.setHSL(0.6 + Math.random() * 0.1, 0.2, 0.9); // mostly white/blue-ish
            starColors.push(color.r, color.g, color.b);
        }
        starGeometry.setAttribute('position', new THREE.Float32BufferAttribute(starVertices, 3));
        starGeometry.setAttribute('color', new THREE.Float32BufferAttribute(starColors, 3));
        const starMaterial = new THREE.PointsMaterial({ size: 0.7, vertexColors: true, transparent: true, opacity: 0.9 });
        const stars = new THREE.Points(starGeometry, starMaterial);
        worldGroup.add(stars);

        // ===== Nebula strings (Minecraft-like cube chains) =====
        const NEBULA_SPAN = 6000; // wide wrap span for infinite effect
        const NEBULA_YSPAN = 1600;
        const nebulaStrings = [];
        function createCubeStringCloud() {
            const group = new THREE.Group();
            const segments = 8 + Math.floor(Math.random() * 7); // 8-14
            const spacing = 40 + Math.random() * 30; // 40-70
            // Random oriented direction for the string
            const dir = new THREE.Vector3(Math.random()-0.5, (Math.random()-0.5)*0.3, Math.random()-0.5).normalize();
            const baseColor = new THREE.Color().setHSL(0.55 + Math.random()*0.15, 0.7, 0.6); // cyan/blue/purple-ish
            for (let i = 0; i < segments; i++) {
                const center = dir.clone().multiplyScalar(i * spacing);
                const cubesThis = 3 + Math.floor(Math.random() * 4); // 3-6
                for (let j = 0; j < cubesThis; j++) {
                    const size = 6 + Math.random() * 10; // 6-16
                    const geo = new THREE.BoxGeometry(size, size, size);
                    const colorJitter = baseColor.clone().offsetHSL((Math.random()-0.5)*0.05, 0, (Math.random()-0.5)*0.05);
                    const mat = new THREE.MeshBasicMaterial({
                        color: colorJitter,
                        transparent: true,
                        opacity: 0.10 + Math.random()*0.08,
                        depthWrite: false,
                        blending: THREE.AdditiveBlending
                    });
                    const cube = new THREE.Mesh(geo, mat);
                    cube.position.copy(center).add(new THREE.Vector3(
                        (Math.random()-0.5)*30,
                        (Math.random()-0.5)*30,
                        (Math.random()-0.5)*30
                    ));
                    group.add(cube);
                }
            }
            // gentle drift for the whole string
            group.userData.drift = new THREE.Vector3(
                (Math.random()-0.5) * 0.02,
                (Math.random()-0.5) * 0.01,
                (Math.random()-0.5) * 0.02
            );
            return group;
        }

        // Place strings further away in a wide shell
        for (let i = 0; i < 50; i++) {
            const cloud = createCubeStringCloud();
            const angle = Math.random() * Math.PI * 2;
            const dist = 1800 + Math.random() * 2200; // 1800-4000 away
            cloud.position.set(
                Math.cos(angle) * dist,
                (Math.random() - 0.5) * NEBULA_YSPAN,
                Math.sin(angle) * dist
            );
            const s = 0.8 + Math.random() * 1.6;
            cloud.scale.setScalar(s);
            nebulaStrings.push(cloud);
            worldGroup.add(cloud);
        }

        // ===== Minecraft-like voxel asteroids =====
        const voxelAsteroids = [];
        function createVoxelAsteroid(size = 4, cubes = 12) {
            const group = new THREE.Group();
            const cubeSize = size * 0.5;
            const geo = new THREE.BoxGeometry(cubeSize, cubeSize, cubeSize);
            const mat = new THREE.MeshPhongMaterial({ color: 0x8a8a8a, emissive: 0x222222, flatShading: true });
            for (let i = 0; i < cubes; i++) {
                const cube = new THREE.Mesh(geo, mat.clone());
                cube.position.set(
                    (Math.random() - 0.5) * size * 2,
                    (Math.random() - 0.5) * size * 2,
                    (Math.random() - 0.5) * size * 2
                );
                // vary colors like ore veins
                const c = new THREE.Color().setHSL(0, 0, 0.4 + Math.random() * 0.2);
                cube.material.color.copy(c);
                group.add(cube);
            }
            return group;
        }

        const ASTEROID_SPAN = 7000; // wrapping span for asteroids/UFOs
        const ASTEROID_YSPAN = 1600;
        for (let i = 0; i < 140; i++) {
            const a = createVoxelAsteroid(3 + Math.random() * 6, 8 + Math.floor(Math.random() * 14));
            // place in cylindrical shell further away for irregular field
            const angle = Math.random() * Math.PI * 2;
            const dist = 1500 + Math.random() * 3500; // 1500-5000
            const y = (Math.random() - 0.5) * ASTEROID_YSPAN;
            a.position.set(
                Math.cos(angle) * dist,
                y,
                Math.sin(angle) * dist
            );
            a.userData.spin = new THREE.Vector3(Math.random() * 0.01, Math.random() * 0.01, Math.random() * 0.01);
            worldGroup.add(a);
            voxelAsteroids.push(a);
        }

        // ===== Blocky alien objects (UFO-like) =====
        const aliens = [];
        function createBlockyUFO() {
            const group = new THREE.Group();
            const baseGeo = new THREE.BoxGeometry(1.2, 0.3, 1.2);
            const baseMat = new THREE.MeshPhongMaterial({ color: 0x666666, emissive: 0x1a1a1a, flatShading: true });
            // build a 3x3 plate
            for (let x = -1; x <= 1; x++) {
                for (let z = -1; z <= 1; z++) {
                    const tile = new THREE.Mesh(baseGeo, baseMat);
                    tile.position.set(x * 1.25, 0, z * 1.25);
                    group.add(tile);
                }
            }
            // dome
            const dome = new THREE.Mesh(new THREE.BoxGeometry(1, 0.8, 1), new THREE.MeshPhongMaterial({ color: 0x22ff88, emissive: 0x116633 }));
            dome.position.set(0, 0.7, 0);
            group.add(dome);
            // feet
            for (let i = 0; i < 4; i++) {
                const foot = new THREE.Mesh(new THREE.BoxGeometry(0.4, 0.4, 0.4), new THREE.MeshPhongMaterial({ color: 0x555555 }));
                const angle = (i / 4) * Math.PI * 2;
                foot.position.set(Math.cos(angle) * 1.8, -0.4, Math.sin(angle) * 1.8);
                group.add(foot);
            }
            return group;
        }

        for (let i = 0; i < 35; i++) {
            const ufo = createBlockyUFO();
            const angleU = Math.random() * Math.PI * 2;
            const distU = 1500 + Math.random() * 3200;
            const yU = (Math.random() - 0.5) * ASTEROID_YSPAN;
            ufo.position.set(
                Math.cos(angleU) * distU,
                yU,
                Math.sin(angleU) * distU
            );
            ufo.userData.bobPhase = Math.random() * Math.PI * 2;
            ufo.userData.baseY = ufo.position.y;
            worldGroup.add(ufo);
            aliens.push(ufo);
        }

        // ===== Strange occasional anomalies =====
        const anomalies = [];
        function createAnomaly() {
            const type = Math.floor(Math.random() * 5);
            let obj;
            if (type === 0) {
                // Monolith
                obj = new THREE.Mesh(
                    new THREE.BoxGeometry(4, 24, 4),
                    new THREE.MeshPhongMaterial({ color: 0x111111, emissive: 0x3344ff, shininess: 80 })
                );
            } else if (type === 1) {
                // Glowing ring
                obj = new THREE.Mesh(
                    new THREE.TorusGeometry(8, 1, 16, 64),
                    new THREE.MeshPhongMaterial({ color: 0x8833ff, emissive: 0x4422aa, shininess: 100 })
                );
            } else if (type === 2) {
                // Pyramid (tetra-like)
                obj = new THREE.Mesh(
                    new THREE.ConeGeometry(6, 12, 4),
                    new THREE.MeshPhongMaterial({ color: 0xff2288, emissive: 0x661133, flatShading: true })
                );
            } else if (type === 3) {
                // Torus knot portal
                obj = new THREE.Mesh(
                    new THREE.TorusKnotGeometry(5, 1, 100, 16),
                    new THREE.MeshPhongMaterial({ color: 0x00ffcc, emissive: 0x008877, shininess: 120 })
                );
            } else {
                // Orb cluster
                const g = new THREE.Group();
                const count = 5 + Math.floor(Math.random()*4);
                for (let i = 0; i < count; i++) {
                    const s = 0.8 + Math.random()*1.8;
                    const m = new THREE.Mesh(
                        new THREE.SphereGeometry(s, 16, 16),
                        new THREE.MeshPhongMaterial({ color: 0x88ffee, emissive: 0x226666, transparent: true, opacity: 0.8 })
                    );
                    m.position.set((Math.random()-0.5)*10, (Math.random()-0.5)*10, (Math.random()-0.5)*10);
                    g.add(m);
                }
                obj = g;
            }
            const group = new THREE.Group();
            group.add(obj);
            // Add a faint glow light
            const glow = new THREE.PointLight(0x66ffee, 0.6, 60);
            group.add(glow);
            group.userData.spin = new THREE.Vector3(Math.random()*0.01, Math.random()*0.02+0.005, Math.random()*0.01);
            group.userData.bobPhase = Math.random()*Math.PI*2;
            return group;
        }

        for (let i = 0; i < 12; i++) {
            const anomaly = createAnomaly();
            const ang = Math.random() * Math.PI * 2;
            const dist = 2200 + Math.random() * 3800; // 2.2km - 6km
            const yy = (Math.random()-0.5) * ASTEROID_YSPAN;
            anomaly.position.set(Math.cos(ang)*dist, yy, Math.sin(ang)*dist);
            worldGroup.add(anomaly);
            anomalies.push(anomaly);
        }

        // Movement variables - SPACE PHYSICS: ship is reference frame
        const keys = {};
        const maxCruisingSpeed = 2.5;
        const maxBoostSpeed = 12.0; // Stronger boost top speed
        const acceleration = 0.002;
        const boostAcceleration = 0.02; // Stronger acceleration when boosting
        const maxPhysicsSpeed = 20.0; // Cap for realistic mode
        const minTurnSpeed = 0.003; // Much slower start
        const maxTurnSpeed = 0.025; // Lower max rotation speed
        const turnAcceleration = 0.0003; // Slower acceleration = more rotational inertia
        const turnDeceleration = 0.0005; // Gradual slowdown when not turning
        const turnSlowdown = 0.985; // More aggressive speed reduction during turns

        // Rotation speed tracking
        let currentTurnSpeed = 0;

        // Boost fuel system
        let boostFuel = 100;
        const maxBoostFuel = 100;
        const boostDrainRate = 0.5; // Fuel per frame when boosting
        const boostRechargeRate = 0.15; // Fuel per frame when not boosting

        // Camera inertia
        const cameraLerpFactor = 0.08; // Lower = more lag, higher = more responsive

        // Speed/velocity
        let currentSpeed = 0;
        const velocity = new THREE.Vector3();
        let physicsMode = false; // false = Arcade (current), true = Physics (inertial)

        // Mode toggle helpers
        const modeBtn = document.getElementById('modeToggle');
        function updateModeUI() {
            modeBtn.textContent = `Mode: ${physicsMode ? 'Physics' : 'Arcade'}`;
        }
        function setMode(next) {
            if (next === physicsMode) return;
            physicsMode = next;
            // Translate scalar speed to vector and back on mode switches
            const fwd = new THREE.Vector3(0, 0, -1).applyQuaternion(shipGroup.quaternion);
            if (physicsMode) {
                velocity.copy(fwd.multiplyScalar(currentSpeed));
            } else {
                currentSpeed = velocity.length();
                velocity.set(0, 0, 0);
            }
            updateModeUI();
        }
        updateModeUI();
        modeBtn.addEventListener('click', () => setMode(!physicsMode));

        // Input handling
        window.addEventListener('keydown', (e) => {
            keys[e.key.toLowerCase()] = true;
        });

        window.addEventListener('keyup', (e) => {
            keys[e.key.toLowerCase()] = false;
        });

        // Mobile controls
        const setupMobileButton = (btnId, key) => {
            const btn = document.getElementById(btnId);
            btn.addEventListener('touchstart', (e) => {
                e.preventDefault();
                keys[key] = true;
            });
            btn.addEventListener('touchend', (e) => {
                e.preventDefault();
                keys[key] = false;
            });
        };

        setupMobileButton('btn-left', 'a');
        setupMobileButton('btn-right', 'd');
        // Invert up/down for mobile controls
        setupMobileButton('btn-up', 's');
        setupMobileButton('btn-down', 'w');
        setupMobileButton('btn-boost', ' ');

        // Mouse movement for camera tilt
        let mouseX = 0;
        let mouseY = 0;

        window.addEventListener('mousemove', (e) => {
            mouseX = (e.clientX / window.innerWidth) * 2 - 1;
            mouseY = (e.clientY / window.innerHeight) * 2 - 1;
        });

        // Handle window resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        // Animation loop - SPACE PHYSICS: relative rotations
        function animate() {
            requestAnimationFrame(animate);

            // ===== ROTATION: Apply rotations in ship's local space =====
            // Track if we're turning for speed slowdown
            const isTurning = keys['a'] || keys['arrowleft'] || keys['d'] || keys['arrowright'] ||
                              keys['w'] || keys['arrowup'] || keys['s'] || keys['arrowdown'];

            // Accelerate turn speed when turning, gradually decelerate when not
            if (isTurning) {
                if (currentTurnSpeed < minTurnSpeed) {
                    currentTurnSpeed = minTurnSpeed;
                } else if (currentTurnSpeed < maxTurnSpeed) {
                    currentTurnSpeed = Math.min(currentTurnSpeed + turnAcceleration, maxTurnSpeed);
                }
            } else {
                // Gradual deceleration for rotational inertia
                currentTurnSpeed = Math.max(0, currentTurnSpeed - turnDeceleration);
            }

            // Rotate around local axes (correct for intuitive flight controls)
            if (keys['a'] || keys['arrowleft']) {
                // Yaw left around local Y axis
                shipGroup.rotateOnAxis(new THREE.Vector3(0, 1, 0), currentTurnSpeed);
            }
            if (keys['d'] || keys['arrowright']) {
                // Yaw right around local Y axis
                shipGroup.rotateOnAxis(new THREE.Vector3(0, 1, 0), -currentTurnSpeed);
            }
            if (keys['w'] || keys['arrowup']) {
                // Pitch up around local X axis
                shipGroup.rotateOnAxis(new THREE.Vector3(1, 0, 0), -currentTurnSpeed);
            }
            if (keys['s'] || keys['arrowdown']) {
                // Pitch down around local X axis
                shipGroup.rotateOnAxis(new THREE.Vector3(1, 0, 0), currentTurnSpeed);
            }

            // Get ship's orientation for camera and movement
            const shipUp = new THREE.Vector3(0, 1, 0).applyQuaternion(shipGroup.quaternion);

            // ===== MOVEMENT: Move world instead of ship (ship stays at origin, rotates in place) =====
            // Ship rotates, camera follows. World translates backwards relative to ship's forward.
            // No world rotation - the appearance of rotation comes from camera following ship.
            const forward = new THREE.Vector3(0, 0, -1);
            forward.applyQuaternion(shipGroup.quaternion);

            // Boost fuel management
            const isBoosting = keys[' '] && boostFuel > 0;
            if (isBoosting) {
                boostFuel = Math.max(0, boostFuel - boostDrainRate);
            } else {
                boostFuel = Math.min(maxBoostFuel, boostFuel + boostRechargeRate);
            }

            if (physicsMode) {
                // Inertial physics: rotation doesn't change velocity. Boost applies thrust along facing.
                if (isBoosting) {
                    const thrust = forward.clone().multiplyScalar(boostAcceleration);
                    velocity.add(thrust);
                }
                // Clamp max speed for stability
                const vLen = velocity.length();
                if (vLen > maxPhysicsSpeed) {
                    velocity.setLength(maxPhysicsSpeed);
                }
                // Move world opposite to velocity
                worldGroup.position.add(velocity.clone().multiplyScalar(-1));
            } else {
                // Arcade mode: gradual auto-accel + boost, turning slows
                const maxSpeed = isBoosting ? maxBoostSpeed : maxCruisingSpeed;
                const currentAcceleration = isBoosting ? boostAcceleration : acceleration;

                if (currentSpeed < maxSpeed) {
                    currentSpeed = Math.min(currentSpeed + currentAcceleration, maxSpeed);
                } else if (currentSpeed > maxSpeed) {
                    currentSpeed = Math.max(currentSpeed - acceleration, maxSpeed);
                }

                if (isTurning) {
                    currentSpeed *= turnSlowdown;
                }

                worldGroup.position.add(forward.multiplyScalar(-currentSpeed));
            }

            // ===== CAMERA: Smooth follow with inertia =====
            // Calculate target camera position in ship's local space
            const localCameraOffset = new THREE.Vector3(0, 3, 8);
            const worldCameraOffset = localCameraOffset.clone().applyQuaternion(shipGroup.quaternion);
            const targetCameraPosition = shipGroup.position.clone().add(worldCameraOffset);

            // Smoothly interpolate camera position toward target (creates lag/inertia)
            camera.position.lerp(targetCameraPosition, cameraLerpFactor);

            // Smoothly interpolate camera's up vector
            const targetUp = shipUp.clone();
            camera.up.lerp(targetUp, cameraLerpFactor);

            camera.lookAt(shipGroup.position);

            // ===== VISUALS: Engine glow =====
            const engineGlow = isBoosting ? 0.5 : 0;
            engine.material.opacity = 0.5 + Math.sin(Date.now() * 0.01) * 0.3 + engineGlow;
            engine.scale.setScalar(1 + engineGlow);

            // Animate voxel asteroids (slow spin) + wrap for infinite field
            for (const a of voxelAsteroids) {
                a.rotation.x += a.userData.spin.x;
                a.rotation.y += a.userData.spin.y;
                a.rotation.z += a.userData.spin.z;
                const wx = a.position.x + worldGroup.position.x;
                const wy = a.position.y + worldGroup.position.y;
                const wz = a.position.z + worldGroup.position.z;
                if (wx >  ASTEROID_SPAN / 2) a.position.x -= ASTEROID_SPAN; else if (wx < -ASTEROID_SPAN / 2) a.position.x += ASTEROID_SPAN;
                if (wz >  ASTEROID_SPAN / 2) a.position.z -= ASTEROID_SPAN; else if (wz < -ASTEROID_SPAN / 2) a.position.z += ASTEROID_SPAN;
                if (wy >  ASTEROID_YSPAN / 2) a.position.y -= ASTEROID_YSPAN; else if (wy < -ASTEROID_YSPAN / 2) a.position.y += ASTEROID_YSPAN;
            }

            // Animate aliens (gentle bob + slow yaw) + wrap
            for (const ufo of aliens) {
                ufo.userData.bobPhase += 0.03;
                ufo.position.y = ufo.userData.baseY + Math.sin(ufo.userData.bobPhase) * 1.2;
                ufo.rotation.y += 0.01;
                const wx = ufo.position.x + worldGroup.position.x;
                const wy = ufo.position.y + worldGroup.position.y;
                const wz = ufo.position.z + worldGroup.position.z;
                if (wx >  ASTEROID_SPAN / 2) ufo.position.x -= ASTEROID_SPAN; else if (wx < -ASTEROID_SPAN / 2) ufo.position.x += ASTEROID_SPAN;
                if (wz >  ASTEROID_SPAN / 2) ufo.position.z -= ASTEROID_SPAN; else if (wz < -ASTEROID_SPAN / 2) ufo.position.z += ASTEROID_SPAN;
                if (wy >  ASTEROID_YSPAN / 2) ufo.position.y -= ASTEROID_YSPAN; else if (wy < -ASTEROID_YSPAN / 2) ufo.position.y += ASTEROID_YSPAN;
            }

            // Animate anomalies (spin, bob) + wrap
            for (const an of anomalies) {
                an.children[0].rotation.x += an.userData.spin.x;
                an.children[0].rotation.y += an.userData.spin.y;
                an.children[0].rotation.z += an.userData.spin.z;
                an.userData.bobPhase += 0.01;
                an.position.y += Math.sin(an.userData.bobPhase) * 0.05;
                const wx = an.position.x + worldGroup.position.x;
                const wy = an.position.y + worldGroup.position.y;
                const wz = an.position.z + worldGroup.position.z;
                if (wx >  ASTEROID_SPAN / 2) an.position.x -= ASTEROID_SPAN; else if (wx < -ASTEROID_SPAN / 2) an.position.x += ASTEROID_SPAN;
                if (wz >  ASTEROID_SPAN / 2) an.position.z -= ASTEROID_SPAN; else if (wz < -ASTEROID_SPAN / 2) an.position.z += ASTEROID_SPAN;
                if (wy >  ASTEROID_YSPAN / 2) an.position.y -= ASTEROID_YSPAN; else if (wy < -ASTEROID_YSPAN / 2) an.position.y += ASTEROID_YSPAN;
            }

            // Animate and wrap nebula strings for an infinite feel
            for (const cloud of nebulaStrings) {
                cloud.position.add(cloud.userData.drift);
                const wx = cloud.position.x + worldGroup.position.x;
                const wy = cloud.position.y + worldGroup.position.y;
                const wz = cloud.position.z + worldGroup.position.z;
                if (wx >  NEBULA_SPAN / 2) cloud.position.x -= NEBULA_SPAN; else if (wx < -NEBULA_SPAN / 2) cloud.position.x += NEBULA_SPAN;
                if (wz >  NEBULA_SPAN / 2) cloud.position.z -= NEBULA_SPAN; else if (wz < -NEBULA_SPAN / 2) cloud.position.z += NEBULA_SPAN;
                if (wy >  NEBULA_YSPAN / 2) cloud.position.y -= NEBULA_YSPAN; else if (wy < -NEBULA_YSPAN / 2) cloud.position.y += NEBULA_YSPAN;
            }

            // Update UI
            const speedScalar = physicsMode ? velocity.length() : currentSpeed;
            const speedDisplay = Math.round(speedScalar * 50);
            document.getElementById('speed').textContent = `Speed: ${speedDisplay} ${isBoosting ? '⚡' : ''}`;

            const boostPercent = Math.round(boostFuel);
            const boostFill = document.getElementById('boostFill');
            if (boostFill) {
                boostFill.style.width = `${boostPercent}%`;
                // Color shift: red (<20), amber (<50), cyan otherwise
                const color = boostFuel < 20 ? '#ff4444' : (boostFuel < 50 ? '#ffaa00' : '#00ffff');
                boostFill.style.background = `linear-gradient(90deg, ${color}, ${color === '#00ffff' ? '#00b3b3' : color})`;
            }

            // Render
            renderer.render(scene, camera);
        }

        animate();
    </script>
</body>
</html>
