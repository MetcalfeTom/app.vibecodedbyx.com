<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Space Flight - Fly Through the Galaxy</title>
    <link rel="icon" href="https://emojicdn.elk.sh/üöÄ" type="image/png">

    <!-- Open Graph Meta Tags -->
    <meta property="og:title" content="Space Flight - Fly Through the Galaxy">
    <meta property="og:description" content="Pilot your spaceship through a stunning 3D galaxy. Explore beautiful space with planets, stars, and nebulae!">
    <meta property="og:url" content="https://app.vibecodedbyx.com/space-flight">
    <meta property="og:image" content="https://app.vibecodedbyx.com/space-flight/preview.png">

    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            overflow: hidden;
            background: #000;
        }

        #gameCanvas {
            display: block;
            width: 100vw;
            height: 100vh;
        }

        #ui {
            position: fixed;
            top: 20px;
            left: 20px;
            color: #fff;
            font-size: 16px;
            text-shadow: 0 0 10px rgba(0, 255, 255, 0.8);
            z-index: 100;
            pointer-events: none;
        }

        #controls {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            color: #fff;
            text-align: center;
            font-size: 14px;
            background: rgba(0, 0, 0, 0.6);
            padding: 15px 25px;
            border-radius: 10px;
            backdrop-filter: blur(10px);
            z-index: 100;
        }

        #backlink {
            position: fixed;
            top: 20px;
            right: 20px;
            z-index: 100;
        }

        #backlink a {
            color: #00ffff;
            text-decoration: none;
            font-size: 14px;
            background: rgba(0, 0, 0, 0.6);
            padding: 10px 20px;
            border-radius: 5px;
            backdrop-filter: blur(10px);
            transition: all 0.3s;
        }

        #backlink a:hover {
            background: rgba(0, 255, 255, 0.2);
            transform: scale(1.05);
        }

        .mobile-controls {
            position: fixed;
            bottom: 20px;
            display: none;
            z-index: 100;
        }

        .mobile-controls button {
            width: 60px;
            height: 60px;
            border-radius: 50%;
            background: rgba(0, 255, 255, 0.3);
            border: 2px solid #00ffff;
            color: #fff;
            font-size: 24px;
            margin: 5px;
            backdrop-filter: blur(10px);
            touch-action: manipulation;
        }

        .mobile-controls button:active {
            background: rgba(0, 255, 255, 0.6);
        }

        #left-controls {
            left: 20px;
        }

        #right-controls {
            right: 20px;
        }

        @media (max-width: 768px) {
            .mobile-controls {
                display: flex;
                gap: 10px;
            }
            #controls {
                display: none;
            }
        }
    </style>
</head>
<body>
    <div id="ui">
        <div>üöÄ Space Flight</div>
        <div id="speed">Speed: 0</div>
    </div>

    <div id="backlink">
        <a href="https://www.vibecodedbyx.com">‚Üê Back to Stream</a>
    </div>

    <div id="controls">
        <strong>Controls:</strong> W/S or ‚Üë/‚Üì to pitch up/down ‚Ä¢ A/D or ‚Üê/‚Üí to turn left/right ‚Ä¢ Space to boost ‚Ä¢ Auto-accelerates forward
    </div>

    <div class="mobile-controls" id="left-controls">
        <button id="btn-left">‚Üê</button>
        <button id="btn-right">‚Üí</button>
    </div>

    <div class="mobile-controls" id="right-controls">
        <button id="btn-up">‚Üë</button>
        <button id="btn-down">‚Üì</button>
        <button id="btn-boost">‚ö°</button>
    </div>

    <script type="importmap">
    {
        "imports": {
            "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
            "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
        }
    }
    </script>

    <script type="module">
        // v1.8 - Airplane physics: always fly in ship orientation
        import * as THREE from 'three';

        // Scene setup
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 10000);
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        document.body.appendChild(renderer.domElement);

        // Fog for depth
        scene.fog = new THREE.FogExp2(0x000033, 0.0003);

        // Spaceship
        const shipGroup = new THREE.Group();

        // Main body
        const bodyGeometry = new THREE.ConeGeometry(0.5, 2, 4);
        const bodyMaterial = new THREE.MeshPhongMaterial({
            color: 0x00ffff,
            emissive: 0x0088ff,
            shininess: 100
        });
        const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
        body.rotation.x = Math.PI / 2;
        shipGroup.add(body);

        // Wings
        const wingGeometry = new THREE.BoxGeometry(2, 0.1, 0.8);
        const wingMaterial = new THREE.MeshPhongMaterial({
            color: 0xff00ff,
            emissive: 0x880088
        });
        const wings = new THREE.Mesh(wingGeometry, wingMaterial);
        wings.position.z = 0.3;
        shipGroup.add(wings);

        // Engine glow
        const engineGeometry = new THREE.SphereGeometry(0.3, 16, 16);
        const engineMaterial = new THREE.MeshBasicMaterial({
            color: 0xff6600,
            transparent: true,
            opacity: 0.8
        });
        const engine = new THREE.Mesh(engineGeometry, engineMaterial);
        engine.position.z = 1.2;
        shipGroup.add(engine);

        scene.add(shipGroup);
        shipGroup.position.set(0, 0, 0);

        // Camera offset from ship
        camera.position.set(0, 3, 8);
        camera.lookAt(shipGroup.position);

        // Lighting
        const ambientLight = new THREE.AmbientLight(0x404040, 1);
        scene.add(ambientLight);

        const pointLight = new THREE.PointLight(0xffffff, 2, 100);
        pointLight.position.set(10, 10, 10);
        scene.add(pointLight);

        const shipLight = new THREE.PointLight(0x00ffff, 1, 20);
        shipGroup.add(shipLight);

        // Create starfield
        const starGeometry = new THREE.BufferGeometry();
        const starVertices = [];
        const starColors = [];

        for (let i = 0; i < 10000; i++) {
            const x = (Math.random() - 0.5) * 2000;
            const y = (Math.random() - 0.5) * 2000;
            const z = (Math.random() - 0.5) * 2000;
            starVertices.push(x, y, z);

            // Random star colors
            const color = new THREE.Color();
            color.setHSL(Math.random(), 0.5, 0.8);
            starColors.push(color.r, color.g, color.b);
        }

        starGeometry.setAttribute('position', new THREE.Float32BufferAttribute(starVertices, 3));
        starGeometry.setAttribute('color', new THREE.Float32BufferAttribute(starColors, 3));

        const starMaterial = new THREE.PointsMaterial({
            size: 0.7,
            vertexColors: true,
            transparent: true,
            opacity: 0.8
        });

        const stars = new THREE.Points(starGeometry, starMaterial);
        scene.add(stars);

        // Create planets
        const planets = [];
        const planetData = [
            { radius: 8, color: 0xff4444, distance: 100, speed: 0.001 },
            { radius: 6, color: 0x4444ff, distance: 150, speed: 0.0015 },
            { radius: 10, color: 0x44ff44, distance: 200, speed: 0.0008 },
            { radius: 5, color: 0xffff44, distance: 120, speed: 0.0012 },
            { radius: 7, color: 0xff44ff, distance: 180, speed: 0.001 }
        ];

        planetData.forEach((data, i) => {
            const planetGeometry = new THREE.SphereGeometry(data.radius, 32, 32);
            const planetMaterial = new THREE.MeshPhongMaterial({
                color: data.color,
                emissive: data.color,
                emissiveIntensity: 0.2,
                shininess: 30
            });
            const planet = new THREE.Mesh(planetGeometry, planetMaterial);

            const angle = (i / planetData.length) * Math.PI * 2;
            planet.position.x = Math.cos(angle) * data.distance;
            planet.position.z = Math.sin(angle) * data.distance;
            planet.position.y = (Math.random() - 0.5) * 50;

            planet.userData = {
                angle: angle,
                distance: data.distance,
                speed: data.speed
            };

            scene.add(planet);
            planets.push(planet);

            // Add planet glow
            const glowGeometry = new THREE.SphereGeometry(data.radius * 1.2, 32, 32);
            const glowMaterial = new THREE.MeshBasicMaterial({
                color: data.color,
                transparent: true,
                opacity: 0.2,
                side: THREE.BackSide
            });
            const glow = new THREE.Mesh(glowGeometry, glowMaterial);
            planet.add(glow);
        });

        // Add nebula clouds
        const cloudGeometry = new THREE.SphereGeometry(30, 16, 16);
        const cloudMaterial = new THREE.MeshBasicMaterial({
            color: 0xff00ff,
            transparent: true,
            opacity: 0.1,
            side: THREE.BackSide
        });

        for (let i = 0; i < 20; i++) {
            const cloud = new THREE.Mesh(cloudGeometry, cloudMaterial.clone());
            cloud.position.set(
                (Math.random() - 0.5) * 500,
                (Math.random() - 0.5) * 500,
                (Math.random() - 0.5) * 500
            );
            cloud.material.color.setHSL(Math.random(), 0.8, 0.5);
            scene.add(cloud);
        }

        // Add colorful asteroids
        const asteroidColors = [0xff00ff, 0x00ffff, 0xffff00, 0xff0000, 0x00ff00, 0xff6600, 0x0088ff];
        for (let i = 0; i < 100; i++) {
            const size = Math.random() * 2 + 0.5;
            const asteroidGeometry = new THREE.DodecahedronGeometry(size, 0);
            const asteroidMaterial = new THREE.MeshPhongMaterial({
                color: asteroidColors[Math.floor(Math.random() * asteroidColors.length)],
                emissive: asteroidColors[Math.floor(Math.random() * asteroidColors.length)],
                emissiveIntensity: 0.3,
                flatShading: true
            });
            const asteroid = new THREE.Mesh(asteroidGeometry, asteroidMaterial);
            asteroid.position.set(
                (Math.random() - 0.5) * 600,
                (Math.random() - 0.5) * 200,
                (Math.random() - 0.5) * 600
            );
            asteroid.rotation.set(
                Math.random() * Math.PI,
                Math.random() * Math.PI,
                Math.random() * Math.PI
            );
            scene.add(asteroid);
        }

        // Add colorful waypoint markers
        const waypointColors = [0xff00ff, 0x00ffff, 0xffff00, 0xff6600];
        for (let i = 0; i < 12; i++) {
            const waypointGeometry = new THREE.OctahedronGeometry(3, 0);
            const waypointMaterial = new THREE.MeshBasicMaterial({
                color: waypointColors[i % waypointColors.length],
                transparent: true,
                opacity: 0.6,
                wireframe: true
            });
            const waypoint = new THREE.Mesh(waypointGeometry, waypointMaterial);

            const angle = (i / 12) * Math.PI * 2;
            const distance = 80 + (i % 3) * 40;
            waypoint.position.set(
                Math.cos(angle) * distance,
                (Math.random() - 0.5) * 40,
                Math.sin(angle) * distance
            );

            scene.add(waypoint);
        }

        // Movement variables
        const keys = {};
        let shipRotation = 0;
        let shipPitch = 0;
        let speed = 0; // Current speed (scalar)
        const maxSpeed = 1.8;
        const autoAcceleration = 0.012;  // Gradual acceleration when flying straight
        const boostAcceleration = 0.035; // More acceleration with boost
        const rotationSpeed = 0.03;
        const pitchSpeed = 0.02;
        const turnDeceleration = 0.97;   // Slowly slows down when turning
        const speedDamping = 0.99;       // Gradual slowdown when no input
        const maxPitch = Math.PI / 3; // Limit pitch to 60 degrees up/down

        // Input handling
        window.addEventListener('keydown', (e) => {
            keys[e.key.toLowerCase()] = true;
        });

        window.addEventListener('keyup', (e) => {
            keys[e.key.toLowerCase()] = false;
        });

        // Mobile controls
        const setupMobileButton = (btnId, key) => {
            const btn = document.getElementById(btnId);
            btn.addEventListener('touchstart', (e) => {
                e.preventDefault();
                keys[key] = true;
            });
            btn.addEventListener('touchend', (e) => {
                e.preventDefault();
                keys[key] = false;
            });
        };

        setupMobileButton('btn-left', 'a');
        setupMobileButton('btn-right', 'd');
        setupMobileButton('btn-up', 'w');
        setupMobileButton('btn-down', 's');
        setupMobileButton('btn-boost', ' ');

        // Mouse movement for camera tilt
        let mouseX = 0;
        let mouseY = 0;

        window.addEventListener('mousemove', (e) => {
            mouseX = (e.clientX / window.innerWidth) * 2 - 1;
            mouseY = (e.clientY / window.innerHeight) * 2 - 1;
        });

        // Handle window resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        // Animation loop
        function animate() {
            requestAnimationFrame(animate);

            // Process rotation input (yaw - left/right)
            let isTurning = false;
            if (keys['a'] || keys['arrowleft']) {
                shipRotation += rotationSpeed;
                isTurning = true;
            }
            if (keys['d'] || keys['arrowright']) {
                shipRotation -= rotationSpeed;
                isTurning = true;
            }

            // Process pitch input (up/down rotation)
            if (keys['w'] || keys['arrowup']) {
                shipPitch = Math.min(shipPitch + pitchSpeed, maxPitch);
                isTurning = true;
            }
            if (keys['s'] || keys['arrowdown']) {
                shipPitch = Math.max(shipPitch - pitchSpeed, -maxPitch);
                isTurning = true;
            }

            // Apply rotation to ship FIRST (yaw and pitch)
            shipGroup.rotation.y = shipRotation;
            shipGroup.rotation.x = -shipPitch;
            shipGroup.rotation.z = 0;

            // Get the ship's forward direction vector (where the tip points)
            const forwardDirection = new THREE.Vector3(0, 0, -1);
            forwardDirection.applyQuaternion(shipGroup.quaternion);

            // Update speed based on controls
            let accelAmount = autoAcceleration;

            // Space boosts acceleration
            if (keys[' ']) {
                accelAmount += boostAcceleration;
            }

            // Always accelerate
            speed += accelAmount;

            // Turning slowly reduces speed
            if (isTurning) {
                speed *= turnDeceleration;
            }

            // Apply speed damping
            speed *= speedDamping;

            // Clamp speed to max
            speed = Math.min(speed, maxSpeed);

            // Calculate velocity: always in forward direction, magnitude = speed
            const velocity = forwardDirection.multiplyScalar(speed);

            // Move ship
            shipGroup.position.add(velocity);

            // Pulse engine glow (brighter when space is pressed)
            const engineBoost = keys[' '] ? 0.5 : 0;
            engine.material.opacity = 0.5 + Math.sin(Date.now() * 0.01) * 0.3 + engineBoost;
            engine.scale.setScalar(1 + engineBoost);

            // Animate planets
            planets.forEach(planet => {
                planet.userData.angle += planet.userData.speed;
                planet.position.x = Math.cos(planet.userData.angle) * planet.userData.distance;
                planet.position.z = Math.sin(planet.userData.angle) * planet.userData.distance;
                planet.rotation.y += 0.001;
            });

            // Camera follows ship with offset that rotates with ship (behind and above)
            // Account for both yaw (shipRotation) and pitch (shipPitch)
            const cameraOffset = new THREE.Vector3(
                -Math.sin(shipRotation) * Math.cos(shipPitch) * 8,
                3 - Math.sin(shipPitch) * 5,
                -Math.cos(shipRotation) * Math.cos(shipPitch) * 8
            );
            const cameraPosition = shipGroup.position.clone().add(cameraOffset);
            camera.position.lerp(cameraPosition, 0.1);

            camera.lookAt(shipGroup.position);

            // Update UI
            const speedDisplay = Math.round(speed * 50);
            document.getElementById('speed').textContent = `Speed: ${speedDisplay} ${keys[' '] ? '‚ö°' : ''}`;

            // Render
            renderer.render(scene, camera);
        }

        animate();
    </script>
</body>
</html>
