<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SpaceCraft</title>
    <link rel="icon" href="https://emojicdn.elk.sh/⛏️" type="image/png">

    <!-- Open Graph Meta Tags -->
    <meta property="og:title" content="SpaceCraft">
    <meta property="og:description" content="Dark starfield flight with Minecraft-like asteroids and blocky alien crafts.">
    <meta property="og:url" content="https://app.vibecodedbyx.com/space-flight">
    <meta property="og:image" content="https://app.vibecodedbyx.com/space-flight/preview.png">

    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            overflow: hidden;
            background: #000;
        }

        #gameCanvas {
            display: block;
            width: 100vw;
            height: 100vh;
        }

        #ui {
            position: fixed;
            top: 20px;
            left: 20px;
            color: #fff;
            font-size: 16px;
            text-shadow: 0 0 10px rgba(0, 255, 255, 0.8);
            z-index: 100;
            pointer-events: none;
        }

        #controls {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            color: #fff;
            text-align: center;
            font-size: 14px;
            background: rgba(0, 0, 0, 0.6);
            padding: 15px 25px;
            border-radius: 10px;
            backdrop-filter: blur(10px);
            z-index: 100;
        }

        #backlink {
            position: fixed;
            top: 20px;
            right: 20px;
            z-index: 100;
        }

        #backlink a {
            color: #00ffff;
            text-decoration: none;
            font-size: 14px;
            background: rgba(0, 0, 0, 0.6);
            padding: 10px 20px;
            border-radius: 5px;
            backdrop-filter: blur(10px);
            transition: all 0.3s;
        }

        #backlink a:hover {
            background: rgba(0, 255, 255, 0.2);
            transform: scale(1.05);
        }

        .mobile-controls {
            position: fixed;
            bottom: 20px;
            display: none;
            z-index: 100;
        }

        .mobile-controls button {
            width: 60px;
            height: 60px;
            border-radius: 50%;
            background: rgba(0, 255, 255, 0.3);
            border: 2px solid #00ffff;
            color: #fff;
            font-size: 24px;
            margin: 5px;
            backdrop-filter: blur(10px);
            touch-action: manipulation;
        }

        .mobile-controls button:active {
            background: rgba(0, 255, 255, 0.6);
        }

        #left-controls {
            left: 20px;
        }

        #right-controls {
            right: 20px;
        }

        @media (max-width: 768px) {
            .mobile-controls {
                display: flex;
                gap: 10px;
            }
            #controls {
                display: none;
            }
        }
    </style>
</head>
<body>
    <div id="ui">
        <div>⛏️ SpaceCraft</div>
        <div id="speed">Speed: 0</div>
        <div id="boost">Boost: 100%</div>
    </div>

    <div id="backlink">
        <a href="https://www.vibecodedbyx.com">← Back to Stream</a>
    </div>

    <div id="controls">
        <strong>Controls:</strong> W/S or ↑/↓ to pitch • A/D or ←/→ to yaw • Space to boost • Auto-accelerates forward
    </div>

    <div class="mobile-controls" id="left-controls">
        <button id="btn-left">←</button>
        <button id="btn-right">→</button>
    </div>

    <div class="mobile-controls" id="right-controls">
        <button id="btn-up">↑</button>
        <button id="btn-down">↓</button>
        <button id="btn-boost">⚡</button>
    </div>

    <script type="importmap">
    {
        "imports": {
            "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
            "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
        }
    }
    </script>

    <script type="module">
        // v4.3 - Removed world rotation, only ship rotates with camera following
        import * as THREE from 'three';

        // Scene setup
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 10000);
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        document.body.appendChild(renderer.domElement);

        // Space sky + subtle fog
        scene.background = new THREE.Color(0x000000);
        scene.fog = new THREE.FogExp2(0x000022, 0.0005);

        // Spaceship
        const shipGroup = new THREE.Group();

        // Main body
        const bodyGeometry = new THREE.ConeGeometry(0.5, 2, 4);
        const bodyMaterial = new THREE.MeshPhongMaterial({
            color: 0x00ffff,
            emissive: 0x0088ff,
            shininess: 100
        });
        const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
        body.rotation.x = Math.PI / 2;
        shipGroup.add(body);

        // Wings
        const wingGeometry = new THREE.BoxGeometry(2, 0.1, 0.8);
        const wingMaterial = new THREE.MeshPhongMaterial({
            color: 0xff00ff,
            emissive: 0x880088
        });
        const wings = new THREE.Mesh(wingGeometry, wingMaterial);
        wings.position.z = 0.3;
        shipGroup.add(wings);

        // Engine glow
        const engineGeometry = new THREE.SphereGeometry(0.3, 16, 16);
        const engineMaterial = new THREE.MeshBasicMaterial({
            color: 0xff6600,
            transparent: true,
            opacity: 0.8
        });
        const engine = new THREE.Mesh(engineGeometry, engineMaterial);
        engine.position.z = 1.2;
        shipGroup.add(engine);

        scene.add(shipGroup);
        shipGroup.position.set(0, 0, 0);

        // Camera offset from ship
        camera.position.set(0, 3, 8);
        camera.lookAt(shipGroup.position);

        // Lighting
        const ambientLight = new THREE.AmbientLight(0x404040, 1);
        scene.add(ambientLight);

        const pointLight = new THREE.PointLight(0xffffff, 1.8, 120);
        pointLight.position.set(10, 10, 10);
        scene.add(pointLight);

        const shipLight = new THREE.PointLight(0x00ffff, 1, 20);
        shipGroup.add(shipLight);

        // Create world group - contains all objects that move relative to ship
        const worldGroup = new THREE.Group();
        scene.add(worldGroup);

        // ===== Starfield background =====
        const starGeometry = new THREE.BufferGeometry();
        const starVertices = [];
        const starColors = [];
        for (let i = 0; i < 12000; i++) {
            const x = (Math.random() - 0.5) * 3000;
            const y = (Math.random() - 0.5) * 3000;
            const z = (Math.random() - 0.5) * 3000;
            starVertices.push(x, y, z);
            const color = new THREE.Color();
            color.setHSL(0.6 + Math.random() * 0.1, 0.2, 0.9); // mostly white/blue-ish
            starColors.push(color.r, color.g, color.b);
        }
        starGeometry.setAttribute('position', new THREE.Float32BufferAttribute(starVertices, 3));
        starGeometry.setAttribute('color', new THREE.Float32BufferAttribute(starColors, 3));
        const starMaterial = new THREE.PointsMaterial({ size: 0.7, vertexColors: true, transparent: true, opacity: 0.9 });
        const stars = new THREE.Points(starGeometry, starMaterial);
        worldGroup.add(stars);

        // ===== Infinite Nebula band (scattered colorful clouds) =====
        const NEBULA_SPAN = 2000; // wrap span for infinite effect
        const nebulaClouds = [];
        {
            const cloudGeo = new THREE.SphereGeometry(30, 16, 16);
            for (let i = 0; i < 160; i++) {
                const mat = new THREE.MeshBasicMaterial({
                    color: new THREE.Color().setHSL(Math.random(), 0.8, 0.6),
                    transparent: true,
                    opacity: 0.12,
                    depthWrite: false,
                    blending: THREE.AdditiveBlending,
                    side: THREE.BackSide
                });
                const cloud = new THREE.Mesh(cloudGeo, mat);
                const angle = Math.random() * Math.PI * 2;
                const dist = 700 + Math.random() * 900; // ring-ish distance from origin
                cloud.position.set(
                    Math.cos(angle) * dist,
                    (Math.random() - 0.5) * 600,
                    Math.sin(angle) * dist
                );
                const s = 1.5 + Math.random() * 4;
                cloud.scale.setScalar(s);
                cloud.userData.drift = new THREE.Vector3(
                    (Math.random() - 0.5) * 0.02,
                    (Math.random() - 0.5) * 0.01,
                    (Math.random() - 0.5) * 0.02
                );
                nebulaClouds.push(cloud);
                worldGroup.add(cloud);
            }
        }

        // ===== Minecraft-like voxel asteroids =====
        const voxelAsteroids = [];
        function createVoxelAsteroid(size = 4, cubes = 12) {
            const group = new THREE.Group();
            const cubeSize = size * 0.5;
            const geo = new THREE.BoxGeometry(cubeSize, cubeSize, cubeSize);
            const mat = new THREE.MeshPhongMaterial({ color: 0x8a8a8a, emissive: 0x222222, flatShading: true });
            for (let i = 0; i < cubes; i++) {
                const cube = new THREE.Mesh(geo, mat.clone());
                cube.position.set(
                    (Math.random() - 0.5) * size * 2,
                    (Math.random() - 0.5) * size * 2,
                    (Math.random() - 0.5) * size * 2
                );
                // vary colors like ore veins
                const c = new THREE.Color().setHSL(0, 0, 0.4 + Math.random() * 0.2);
                cube.material.color.copy(c);
                group.add(cube);
            }
            return group;
        }

        for (let i = 0; i < 80; i++) {
            const a = createVoxelAsteroid(3 + Math.random() * 4, 8 + Math.floor(Math.random() * 10));
            a.position.set(
                (Math.random() - 0.5) * 1200,
                (Math.random() - 0.5) * 400,
                (Math.random() - 0.5) * 1200
            );
            a.userData.spin = new THREE.Vector3(Math.random() * 0.01, Math.random() * 0.01, Math.random() * 0.01);
            worldGroup.add(a);
            voxelAsteroids.push(a);
        }

        // ===== Blocky alien objects (UFO-like) =====
        const aliens = [];
        function createBlockyUFO() {
            const group = new THREE.Group();
            const baseGeo = new THREE.BoxGeometry(1.2, 0.3, 1.2);
            const baseMat = new THREE.MeshPhongMaterial({ color: 0x666666, emissive: 0x1a1a1a, flatShading: true });
            // build a 3x3 plate
            for (let x = -1; x <= 1; x++) {
                for (let z = -1; z <= 1; z++) {
                    const tile = new THREE.Mesh(baseGeo, baseMat);
                    tile.position.set(x * 1.25, 0, z * 1.25);
                    group.add(tile);
                }
            }
            // dome
            const dome = new THREE.Mesh(new THREE.BoxGeometry(1, 0.8, 1), new THREE.MeshPhongMaterial({ color: 0x22ff88, emissive: 0x116633 }));
            dome.position.set(0, 0.7, 0);
            group.add(dome);
            // feet
            for (let i = 0; i < 4; i++) {
                const foot = new THREE.Mesh(new THREE.BoxGeometry(0.4, 0.4, 0.4), new THREE.MeshPhongMaterial({ color: 0x555555 }));
                const angle = (i / 4) * Math.PI * 2;
                foot.position.set(Math.cos(angle) * 1.8, -0.4, Math.sin(angle) * 1.8);
                group.add(foot);
            }
            return group;
        }

        for (let i = 0; i < 20; i++) {
            const ufo = createBlockyUFO();
            ufo.position.set(
                (Math.random() - 0.5) * 1000,
                (Math.random() - 0.5) * 400,
                (Math.random() - 0.5) * 1000
            );
            ufo.userData.bobPhase = Math.random() * Math.PI * 2;
            ufo.userData.baseY = ufo.position.y;
            worldGroup.add(ufo);
            aliens.push(ufo);
        }

        // Movement variables - SPACE PHYSICS: ship is reference frame
        const keys = {};
        const maxCruisingSpeed = 2.5;
        const maxBoostSpeed = 6.0;
        const acceleration = 0.002;
        const minTurnSpeed = 0.003; // Much slower start
        const maxTurnSpeed = 0.025; // Lower max rotation speed
        const turnAcceleration = 0.0003; // Slower acceleration = more rotational inertia
        const turnDeceleration = 0.0005; // Gradual slowdown when not turning
        const turnSlowdown = 0.985; // More aggressive speed reduction during turns

        // Rotation speed tracking
        let currentTurnSpeed = 0;

        // Boost fuel system
        let boostFuel = 100;
        const maxBoostFuel = 100;
        const boostDrainRate = 0.5; // Fuel per frame when boosting
        const boostRechargeRate = 0.15; // Fuel per frame when not boosting

        // Camera inertia
        const cameraLerpFactor = 0.08; // Lower = more lag, higher = more responsive

        // Speed inertia
        let currentSpeed = 0;

        // Input handling
        window.addEventListener('keydown', (e) => {
            keys[e.key.toLowerCase()] = true;
        });

        window.addEventListener('keyup', (e) => {
            keys[e.key.toLowerCase()] = false;
        });

        // Mobile controls
        const setupMobileButton = (btnId, key) => {
            const btn = document.getElementById(btnId);
            btn.addEventListener('touchstart', (e) => {
                e.preventDefault();
                keys[key] = true;
            });
            btn.addEventListener('touchend', (e) => {
                e.preventDefault();
                keys[key] = false;
            });
        };

        setupMobileButton('btn-left', 'a');
        setupMobileButton('btn-right', 'd');
        setupMobileButton('btn-up', 'w');
        setupMobileButton('btn-down', 's');
        setupMobileButton('btn-boost', ' ');

        // Mouse movement for camera tilt
        let mouseX = 0;
        let mouseY = 0;

        window.addEventListener('mousemove', (e) => {
            mouseX = (e.clientX / window.innerWidth) * 2 - 1;
            mouseY = (e.clientY / window.innerHeight) * 2 - 1;
        });

        // Handle window resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        // Animation loop - SPACE PHYSICS: relative rotations
        function animate() {
            requestAnimationFrame(animate);

            // ===== ROTATION: Apply rotations in ship's local space =====
            // Track if we're turning for speed slowdown
            const isTurning = keys['a'] || keys['arrowleft'] || keys['d'] || keys['arrowright'] ||
                              keys['w'] || keys['arrowup'] || keys['s'] || keys['arrowdown'];

            // Accelerate turn speed when turning, gradually decelerate when not
            if (isTurning) {
                if (currentTurnSpeed < minTurnSpeed) {
                    currentTurnSpeed = minTurnSpeed;
                } else if (currentTurnSpeed < maxTurnSpeed) {
                    currentTurnSpeed = Math.min(currentTurnSpeed + turnAcceleration, maxTurnSpeed);
                }
            } else {
                // Gradual deceleration for rotational inertia
                currentTurnSpeed = Math.max(0, currentTurnSpeed - turnDeceleration);
            }

            // Rotate around local axes (correct for intuitive flight controls)
            if (keys['a'] || keys['arrowleft']) {
                // Yaw left around local Y axis
                shipGroup.rotateOnAxis(new THREE.Vector3(0, 1, 0), currentTurnSpeed);
            }
            if (keys['d'] || keys['arrowright']) {
                // Yaw right around local Y axis
                shipGroup.rotateOnAxis(new THREE.Vector3(0, 1, 0), -currentTurnSpeed);
            }
            if (keys['w'] || keys['arrowup']) {
                // Pitch up around local X axis
                shipGroup.rotateOnAxis(new THREE.Vector3(1, 0, 0), -currentTurnSpeed);
            }
            if (keys['s'] || keys['arrowdown']) {
                // Pitch down around local X axis
                shipGroup.rotateOnAxis(new THREE.Vector3(1, 0, 0), currentTurnSpeed);
            }

            // Get ship's orientation for camera and movement
            const shipUp = new THREE.Vector3(0, 1, 0).applyQuaternion(shipGroup.quaternion);

            // ===== MOVEMENT: Move world instead of ship (ship stays at origin, rotates in place) =====
            // Ship rotates, camera follows. World translates backwards relative to ship's forward.
            // No world rotation - the appearance of rotation comes from camera following ship.
            const forward = new THREE.Vector3(0, 0, -1);
            forward.applyQuaternion(shipGroup.quaternion);

            // Boost fuel management
            const isBoosting = keys[' '] && boostFuel > 0;
            if (isBoosting) {
                boostFuel = Math.max(0, boostFuel - boostDrainRate);
            } else {
                boostFuel = Math.min(maxBoostFuel, boostFuel + boostRechargeRate);
            }

            // Gradual acceleration with max speed
            const maxSpeed = isBoosting ? maxBoostSpeed : maxCruisingSpeed;

            // Accelerate up to max speed
            if (currentSpeed < maxSpeed) {
                currentSpeed = Math.min(currentSpeed + acceleration, maxSpeed);
            } else if (currentSpeed > maxSpeed) {
                // Decelerate if we were boosting and released
                currentSpeed = Math.max(currentSpeed - acceleration, maxSpeed);
            }

            // Turning slows you down
            if (isTurning) {
                currentSpeed *= turnSlowdown;
            }

            // Move world in opposite direction to ship's forward
            worldGroup.position.add(forward.multiplyScalar(-currentSpeed));

            // ===== CAMERA: Smooth follow with inertia =====
            // Calculate target camera position in ship's local space
            const localCameraOffset = new THREE.Vector3(0, 3, 8);
            const worldCameraOffset = localCameraOffset.clone().applyQuaternion(shipGroup.quaternion);
            const targetCameraPosition = shipGroup.position.clone().add(worldCameraOffset);

            // Smoothly interpolate camera position toward target (creates lag/inertia)
            camera.position.lerp(targetCameraPosition, cameraLerpFactor);

            // Smoothly interpolate camera's up vector
            const targetUp = shipUp.clone();
            camera.up.lerp(targetUp, cameraLerpFactor);

            camera.lookAt(shipGroup.position);

            // ===== VISUALS: Engine glow =====
            const engineGlow = isBoosting ? 0.5 : 0;
            engine.material.opacity = 0.5 + Math.sin(Date.now() * 0.01) * 0.3 + engineGlow;
            engine.scale.setScalar(1 + engineGlow);

            // Animate voxel asteroids (slow spin)
            for (const a of voxelAsteroids) {
                a.rotation.x += a.userData.spin.x;
                a.rotation.y += a.userData.spin.y;
                a.rotation.z += a.userData.spin.z;
            }

            // Animate aliens (gentle bob + slow yaw)
            for (const ufo of aliens) {
                ufo.userData.bobPhase += 0.03;
                ufo.position.y = ufo.userData.baseY + Math.sin(ufo.userData.bobPhase) * 1.2;
                ufo.rotation.y += 0.01;
            }

            // Animate and wrap nebula clouds for an infinite feel
            for (const cloud of nebulaClouds) {
                cloud.position.add(cloud.userData.drift);
                const wx = cloud.position.x + worldGroup.position.x;
                const wy = cloud.position.y + worldGroup.position.y;
                const wz = cloud.position.z + worldGroup.position.z;
                if (wx >  NEBULA_SPAN / 2) cloud.position.x -= NEBULA_SPAN; else if (wx < -NEBULA_SPAN / 2) cloud.position.x += NEBULA_SPAN;
                if (wz >  NEBULA_SPAN / 2) cloud.position.z -= NEBULA_SPAN; else if (wz < -NEBULA_SPAN / 2) cloud.position.z += NEBULA_SPAN;
                // keep Y within a band, but gently wrap
                const YSPAN = 800;
                if (wy >  YSPAN / 2) cloud.position.y -= YSPAN; else if (wy < -YSPAN / 2) cloud.position.y += YSPAN;
            }

            // Update UI
            const speedDisplay = Math.round(currentSpeed * 50);
            document.getElementById('speed').textContent = `Speed: ${speedDisplay} ${isBoosting ? '⚡' : ''}`;

            const boostPercent = Math.round(boostFuel);
            const boostColor = boostFuel < 20 ? '#ff0000' : (boostFuel < 50 ? '#ffaa00' : '#00ffff');
            document.getElementById('boost').textContent = `Boost: ${boostPercent}%`;
            document.getElementById('boost').style.color = boostColor;

            // Render
            renderer.render(scene, camera);
        }

        animate();
    </script>
</body>
</html>
