<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
  <title>Neon Racer - Purple Smoke Drift</title>
  <link rel="icon" href="https://emojicdn.elk.sh/ðŸŽï¸">
  <meta property="og:title" content="Neon Racer">
  <meta property="og:description" content="Top-down drifting with purple tire smoke">
  <meta property="og:url" content="https://app.sloppy.live/neon-racer">
  <meta property="og:image" content="https://emojicdn.elk.sh/ðŸŽï¸?style=apple&size=512">
  <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&display=swap" rel="stylesheet">
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }

    body {
      background: #0a0a12;
      overflow: hidden;
      font-family: 'Orbitron', sans-serif;
      min-height: 100vh;
      touch-action: none;
    }

    canvas { display: block; }

    .ui {
      position: fixed;
      top: 20px;
      left: 20px;
      z-index: 100;
      color: #fff;
    }

    .score {
      font-size: 1.5rem;
      font-weight: 700;
      color: #ff00ff;
      text-shadow: 0 0 20px #ff00ff, 0 0 40px #ff00ff;
    }

    .drift-meter {
      margin-top: 10px;
      width: 200px;
      height: 20px;
      background: rgba(0, 0, 0, 0.5);
      border: 2px solid #ff00ff;
      border-radius: 10px;
      overflow: hidden;
    }

    .drift-fill {
      height: 100%;
      width: 0%;
      background: linear-gradient(90deg, #ff00ff, #00ffff);
      box-shadow: 0 0 20px #ff00ff;
      transition: width 0.1s;
    }

    .drift-label {
      font-size: 0.7rem;
      color: #00ffff;
      margin-top: 5px;
      text-shadow: 0 0 10px #00ffff;
    }

    .combo {
      font-size: 2rem;
      font-weight: 900;
      color: #ffff00;
      text-shadow: 0 0 30px #ffff00;
      opacity: 0;
      transition: opacity 0.3s;
      margin-top: 10px;
    }

    .combo.active { opacity: 1; }

    .touch-controls {
      position: fixed;
      bottom: 30px;
      z-index: 100;
      display: none;
    }

    .touch-left { left: 20px; }
    .touch-right { right: 20px; }

    .touch-btn {
      width: 70px;
      height: 70px;
      background: rgba(255, 0, 255, 0.2);
      border: 3px solid rgba(255, 0, 255, 0.5);
      border-radius: 50%;
      color: #ff00ff;
      font-size: 1.8rem;
      display: flex;
      align-items: center;
      justify-content: center;
      user-select: none;
      -webkit-user-select: none;
      margin: 5px;
    }

    .touch-btn.active {
      background: rgba(255, 0, 255, 0.5);
      box-shadow: 0 0 30px #ff00ff;
    }

    .steer-row { display: flex; }

    .instructions {
      position: fixed;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      color: rgba(255, 255, 255, 0.4);
      font-size: 0.65rem;
      text-align: center;
      z-index: 100;
    }

    .backlink {
      position: fixed;
      top: 20px;
      right: 20px;
      color: rgba(255, 255, 255, 0.3);
      font-size: 0.7rem;
      text-decoration: none;
      z-index: 100;
    }

    .backlink:hover { color: #ff00ff; }

    @media (max-width: 800px) {
      .touch-controls { display: flex; flex-direction: column; align-items: center; }
      .instructions { display: none; }
    }

    @media (max-width: 500px) {
      .score { font-size: 1.1rem; }
      .drift-meter { width: 140px; height: 15px; }
      .touch-btn { width: 55px; height: 55px; font-size: 1.4rem; }
    }
  </style>
</head>
<body>
  <canvas id="game"></canvas>

  <div class="ui">
    <div class="score">SCORE: <span id="score">0</span></div>
    <div class="drift-meter">
      <div class="drift-fill" id="drift-fill"></div>
    </div>
    <div class="drift-label">DRIFT POWER</div>
    <div class="combo" id="combo">COMBO x1</div>
  </div>

  <div class="touch-controls touch-left">
    <div class="steer-row">
      <div class="touch-btn" id="touch-left">â—€</div>
      <div class="touch-btn" id="touch-right">â–¶</div>
    </div>
  </div>

  <div class="touch-controls touch-right">
    <div class="touch-btn" id="touch-gas">â–²</div>
    <div class="touch-btn" id="touch-brake" style="margin-top: 5px;">â–¼</div>
  </div>

  <div class="instructions">Arrow Keys / WASD to drive â€¢ Hold turn while accelerating to DRIFT</div>

  <a href="https://sloppy.live" class="backlink">sloppy.live</a>

  <script>
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');

    let W, H;
    function resize() {
      W = canvas.width = window.innerWidth;
      H = canvas.height = window.innerHeight;
    }
    resize();
    window.addEventListener('resize', resize);

    // Game state
    let score = 0;
    let driftPower = 0;
    let combo = 1;
    let driftTime = 0;
    let time = 0;

    // Car
    const car = {
      x: 0,
      y: 0,
      angle: 0,
      velocity: 0,
      angularVel: 0,
      driftAngle: 0,
      isDrifting: false,
      width: 50,
      height: 25
    };

    // Input
    const input = { up: false, down: false, left: false, right: false };

    // Particles
    let smokeParticles = [];
    let trackMarks = [];

    // Track
    const trackWidth = 150;
    const trackRx = 600;
    const trackRy = 350;

    // Initialize
    function init() {
      car.x = 0;
      car.y = -250;
      car.angle = Math.PI / 2;
      car.velocity = 0;
      car.angularVel = 0;
      car.driftAngle = 0;
    }

    // Spawn smoke
    function spawnSmoke(x, y, vx, vy) {
      smokeParticles.push({
        x, y,
        vx: vx + (Math.random() - 0.5) * 30,
        vy: vy + (Math.random() - 0.5) * 30,
        size: 10 + Math.random() * 15,
        alpha: 0.9,
        hue: 270 + (Math.random() - 0.5) * 30,
        life: 1
      });
    }

    // Spawn track mark
    function spawnTrackMark(x, y, angle) {
      trackMarks.push({ x, y, angle, alpha: 0.5, width: car.width * 0.8 });
      if (trackMarks.length > 400) trackMarks.shift();
    }

    // Check track collision
    function isOnTrack(x, y) {
      const normX = x / trackRx;
      const normY = y / trackRy;
      const dist = Math.sqrt(normX * normX + normY * normY);
      const innerDist = (trackRx - trackWidth) / trackRx;
      const outerDist = (trackRx + trackWidth) / trackRx;
      return dist > innerDist && dist < outerDist;
    }

    // Update
    function update(dt) {
      time += dt;

      const acceleration = 450;
      const friction = 0.985;
      const turnSpeed = 3.5;
      const driftFriction = 0.975;
      const maxSpeed = 550;
      const driftThreshold = 180;

      // Acceleration
      if (input.up) car.velocity += acceleration * dt;
      if (input.down) car.velocity -= acceleration * 0.5 * dt;

      car.velocity = Math.max(-maxSpeed * 0.3, Math.min(maxSpeed, car.velocity));

      // Steering
      const speedFactor = Math.abs(car.velocity) / maxSpeed;
      const steerAmount = turnSpeed * dt * Math.min(1, speedFactor + 0.3);

      if (input.left) car.angularVel -= steerAmount;
      if (input.right) car.angularVel += steerAmount;

      car.angle += car.angularVel;
      car.angularVel *= 0.85;

      // Drift detection
      const speed = Math.abs(car.velocity);
      const isTurning = input.left || input.right;
      const wasDrifting = car.isDrifting;

      if (speed > driftThreshold && isTurning && input.up) {
        car.isDrifting = true;
        const driftDir = input.left ? -1 : 1;
        car.driftAngle += driftDir * dt * 2.5;
        car.driftAngle = Math.max(-0.9, Math.min(0.9, car.driftAngle));

        driftTime += dt;
        driftPower = Math.min(100, driftPower + dt * 35);

        if (driftTime > 0.3) {
          score += Math.floor(speed * 0.15 * combo * dt);
          updateUI();
        }

        // Purple smoke!
        if (Math.random() < 0.6) {
          const rearX = car.x - Math.cos(car.angle) * car.height;
          const rearY = car.y - Math.sin(car.angle) * car.height;
          const perpX = Math.cos(car.angle + Math.PI / 2);
          const perpY = Math.sin(car.angle + Math.PI / 2);
          const smokeVx = -Math.cos(car.angle) * speed * 0.15;
          const smokeVy = -Math.sin(car.angle) * speed * 0.15;

          spawnSmoke(rearX + perpX * car.width * 0.35, rearY + perpY * car.width * 0.35, smokeVx, smokeVy);
          spawnSmoke(rearX - perpX * car.width * 0.35, rearY - perpY * car.width * 0.35, smokeVx, smokeVy);
          spawnTrackMark(rearX, rearY, car.angle + car.driftAngle);
        }

        car.velocity *= driftFriction;
      } else {
        car.isDrifting = false;
        car.driftAngle *= 0.92;

        if (wasDrifting && driftTime > 0.8) {
          combo++;
          score += Math.floor(driftPower * combo * 12);
          showCombo();
          updateUI();
        }

        if (!isTurning) {
          driftTime = 0;
          driftPower *= 0.92;
        }

        car.velocity *= friction;
      }

      // Move car
      const moveAngle = car.angle + car.driftAngle * 0.4;
      car.x += Math.cos(moveAngle) * car.velocity * dt;
      car.y += Math.sin(moveAngle) * car.velocity * dt;

      // Track boundary
      if (!isOnTrack(car.x, car.y)) {
        car.velocity *= 0.7;
        combo = 1;
        driftPower = 0;

        // Push back onto track
        const normX = car.x / trackRx;
        const normY = car.y / trackRy;
        const dist = Math.sqrt(normX * normX + normY * normY);
        const targetDist = 1;
        const pushFactor = 0.1;
        car.x -= (normX / dist - normX / targetDist) * trackRx * pushFactor;
        car.y -= (normY / dist - normY / targetDist) * trackRy * pushFactor;
      }

      // Update smoke
      smokeParticles.forEach(p => {
        p.x += p.vx * dt;
        p.y += p.vy * dt;
        p.vx *= 0.96;
        p.vy *= 0.96;
        p.size += dt * 25;
        p.alpha -= dt * 1.2;
        p.life -= dt;
      });
      smokeParticles = smokeParticles.filter(p => p.life > 0 && p.alpha > 0);

      // Fade track marks
      trackMarks.forEach(m => m.alpha -= dt * 0.08);
      trackMarks = trackMarks.filter(m => m.alpha > 0);

      document.getElementById('drift-fill').style.width = driftPower + '%';
    }

    function updateUI() {
      document.getElementById('score').textContent = Math.floor(score);
    }

    function showCombo() {
      const el = document.getElementById('combo');
      el.textContent = `COMBO x${combo}`;
      el.classList.add('active');
      setTimeout(() => el.classList.remove('active'), 1200);
    }

    // Camera
    const camera = { x: 0, y: 0, zoom: 0.7 };

    // Draw
    function draw() {
      ctx.fillStyle = '#0a0a12';
      ctx.fillRect(0, 0, W, H);

      // Smooth camera
      camera.x += (car.x - camera.x) * 0.08;
      camera.y += (car.y - camera.y) * 0.08;

      ctx.save();
      ctx.translate(W / 2, H / 2);
      ctx.scale(camera.zoom, camera.zoom);
      ctx.translate(-camera.x, -camera.y);

      // Grid
      ctx.strokeStyle = 'rgba(255, 0, 255, 0.08)';
      ctx.lineWidth = 1;
      const gridSize = 100;
      const range = 1200;
      for (let x = -range; x <= range; x += gridSize) {
        ctx.beginPath();
        ctx.moveTo(x, -range);
        ctx.lineTo(x, range);
        ctx.stroke();
      }
      for (let y = -range; y <= range; y += gridSize) {
        ctx.beginPath();
        ctx.moveTo(-range, y);
        ctx.lineTo(range, y);
        ctx.stroke();
      }

      // Track surface
      ctx.fillStyle = 'rgba(30, 30, 40, 0.8)';
      ctx.beginPath();
      for (let a = 0; a <= Math.PI * 2 + 0.1; a += 0.02) {
        const x = Math.cos(a) * (trackRx + trackWidth);
        const y = Math.sin(a) * (trackRy + trackWidth * 0.6);
        if (a === 0) ctx.moveTo(x, y);
        else ctx.lineTo(x, y);
      }
      ctx.fill();

      ctx.fillStyle = '#0a0a12';
      ctx.beginPath();
      for (let a = 0; a <= Math.PI * 2 + 0.1; a += 0.02) {
        const x = Math.cos(a) * (trackRx - trackWidth);
        const y = Math.sin(a) * (trackRy - trackWidth * 0.6);
        if (a === 0) ctx.moveTo(x, y);
        else ctx.lineTo(x, y);
      }
      ctx.fill();

      // Track lines
      ctx.strokeStyle = '#ff00ff';
      ctx.lineWidth = 5;
      ctx.shadowBlur = 25;
      ctx.shadowColor = '#ff00ff';
      ctx.beginPath();
      for (let a = 0; a <= Math.PI * 2 + 0.1; a += 0.03) {
        const x = Math.cos(a) * (trackRx - trackWidth);
        const y = Math.sin(a) * (trackRy - trackWidth * 0.6);
        if (a === 0) ctx.moveTo(x, y);
        else ctx.lineTo(x, y);
      }
      ctx.stroke();

      ctx.strokeStyle = '#00ffff';
      ctx.shadowColor = '#00ffff';
      ctx.beginPath();
      for (let a = 0; a <= Math.PI * 2 + 0.1; a += 0.03) {
        const x = Math.cos(a) * (trackRx + trackWidth);
        const y = Math.sin(a) * (trackRy + trackWidth * 0.6);
        if (a === 0) ctx.moveTo(x, y);
        else ctx.lineTo(x, y);
      }
      ctx.stroke();

      ctx.shadowBlur = 0;

      // Track marks
      trackMarks.forEach(m => {
        ctx.save();
        ctx.translate(m.x, m.y);
        ctx.rotate(m.angle);
        ctx.fillStyle = `rgba(40, 40, 50, ${m.alpha})`;
        ctx.fillRect(-8, -m.width / 2, 25, 10);
        ctx.fillRect(-8, m.width / 2 - 10, 25, 10);
        ctx.restore();
      });

      // Purple smoke!
      smokeParticles.forEach(p => {
        ctx.fillStyle = `hsla(${p.hue}, 100%, 60%, ${p.alpha})`;
        ctx.shadowBlur = 20;
        ctx.shadowColor = `hsla(${p.hue}, 100%, 50%, ${p.alpha})`;
        ctx.beginPath();
        ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
        ctx.fill();
      });
      ctx.shadowBlur = 0;

      // Car
      ctx.save();
      ctx.translate(car.x, car.y);
      ctx.rotate(car.angle + car.driftAngle * 0.35);

      // Car glow
      ctx.shadowBlur = 35;
      ctx.shadowColor = car.isDrifting ? '#ff00ff' : '#00ffff';

      // Car body
      ctx.fillStyle = car.isDrifting ? '#ff00ff' : '#00ffff';
      ctx.beginPath();
      ctx.moveTo(car.height * 1.1, 0);
      ctx.lineTo(car.height * 0.3, -car.width / 2);
      ctx.lineTo(-car.height * 0.6, -car.width / 2);
      ctx.lineTo(-car.height * 0.75, -car.width * 0.35);
      ctx.lineTo(-car.height * 0.75, car.width * 0.35);
      ctx.lineTo(-car.height * 0.6, car.width / 2);
      ctx.lineTo(car.height * 0.3, car.width / 2);
      ctx.closePath();
      ctx.fill();

      ctx.shadowBlur = 0;

      // Windshield
      ctx.fillStyle = 'rgba(0, 0, 0, 0.6)';
      ctx.beginPath();
      ctx.moveTo(car.height * 0.4, 0);
      ctx.lineTo(car.height * 0.1, -car.width * 0.3);
      ctx.lineTo(-car.height * 0.2, -car.width * 0.3);
      ctx.lineTo(-car.height * 0.2, car.width * 0.3);
      ctx.lineTo(car.height * 0.1, car.width * 0.3);
      ctx.closePath();
      ctx.fill();

      // Headlights
      ctx.fillStyle = '#ffff00';
      ctx.shadowBlur = 15;
      ctx.shadowColor = '#ffff00';
      ctx.beginPath();
      ctx.arc(car.height * 0.9, -car.width * 0.28, 5, 0, Math.PI * 2);
      ctx.fill();
      ctx.beginPath();
      ctx.arc(car.height * 0.9, car.width * 0.28, 5, 0, Math.PI * 2);
      ctx.fill();

      // Taillights
      ctx.fillStyle = '#ff0000';
      ctx.shadowColor = '#ff0000';
      ctx.beginPath();
      ctx.arc(-car.height * 0.65, -car.width * 0.38, 4, 0, Math.PI * 2);
      ctx.fill();
      ctx.beginPath();
      ctx.arc(-car.height * 0.65, car.width * 0.38, 4, 0, Math.PI * 2);
      ctx.fill();

      ctx.restore();
      ctx.restore();

      // Drift text
      if (car.isDrifting) {
        ctx.fillStyle = '#ff00ff';
        ctx.font = 'bold 28px Orbitron';
        ctx.textAlign = 'center';
        ctx.shadowBlur = 25;
        ctx.shadowColor = '#ff00ff';
        ctx.fillText('DRIFTING!', W / 2, 85);
        ctx.shadowBlur = 0;
      }
    }

    // Keyboard
    document.addEventListener('keydown', e => {
      if (e.key === 'ArrowUp' || e.key === 'w' || e.key === 'W') input.up = true;
      if (e.key === 'ArrowDown' || e.key === 's' || e.key === 'S') input.down = true;
      if (e.key === 'ArrowLeft' || e.key === 'a' || e.key === 'A') input.left = true;
      if (e.key === 'ArrowRight' || e.key === 'd' || e.key === 'D') input.right = true;
      e.preventDefault();
    });

    document.addEventListener('keyup', e => {
      if (e.key === 'ArrowUp' || e.key === 'w' || e.key === 'W') input.up = false;
      if (e.key === 'ArrowDown' || e.key === 's' || e.key === 'S') input.down = false;
      if (e.key === 'ArrowLeft' || e.key === 'a' || e.key === 'A') input.left = false;
      if (e.key === 'ArrowRight' || e.key === 'd' || e.key === 'D') input.right = false;
    });

    // Touch
    function setupTouch(id, key) {
      const btn = document.getElementById(id);
      if (!btn) return;
      const on = () => { input[key] = true; btn.classList.add('active'); };
      const off = () => { input[key] = false; btn.classList.remove('active'); };
      btn.addEventListener('mousedown', on);
      btn.addEventListener('mouseup', off);
      btn.addEventListener('mouseleave', off);
      btn.addEventListener('touchstart', e => { e.preventDefault(); on(); });
      btn.addEventListener('touchend', e => { e.preventDefault(); off(); });
    }

    setupTouch('touch-gas', 'up');
    setupTouch('touch-brake', 'down');
    setupTouch('touch-left', 'left');
    setupTouch('touch-right', 'right');

    // Game loop
    let lastTime = 0;
    function gameLoop(ts) {
      const dt = Math.min((ts - lastTime) / 1000, 0.05);
      lastTime = ts;
      update(dt);
      draw();
      requestAnimationFrame(gameLoop);
    }

    init();
    requestAnimationFrame(gameLoop);
  </script>
<script src="/sloppy-header/sloppy-bar.js"></script>
<script src="/vibelib-extended.js"></script>
<script>
  // Compatibility Patch for Legacy Apps
  window.addEventListener("load", () => {
    if (window.SloppyKarma && window.VibeLib.Economy) {
      // Redirect old calls to new engine
      window.SloppyKarma.track = window.VibeLib.Economy.track;
    }
  });
</script>
</body>
</html>
