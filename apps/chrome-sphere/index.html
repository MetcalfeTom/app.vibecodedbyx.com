<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Chrome Sphere</title>
    <link rel="icon" href="https://emojicdn.elk.sh/ðŸ”®">

    <meta property="og:title" content="Chrome Sphere">
    <meta property="og:description" content="A spinning chrome sphere reflecting neon signals">
    <meta property="og:url" content="https://sloppy.live/chrome-sphere">
    <meta property="og:image" content="https://image.pollinations.ai/prompt/chrome%20metallic%20sphere%20reflecting%20neon%20text%20CONNECTION%20STABLE%20dark%20background%20cyberpunk?width=1200&height=630&nologo=true&referrer=sloppy.live">

    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            overflow: hidden;
            background: #0a0a0f;
            font-family: 'Courier New', monospace;
        }

        #canvas-container {
            width: 100vw;
            height: 100vh;
        }

        .backlink {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            color: #00ff88;
            text-decoration: none;
            font-size: 0.8rem;
            opacity: 0.5;
            transition: opacity 0.3s;
            z-index: 10;
        }

        .backlink:hover {
            opacity: 1;
            text-shadow: 0 0 10px #00ff88;
        }
    </style>
</head>
<body>
    <div id="canvas-container"></div>
    <a href="https://sloppy.live" class="backlink">sloppy.live</a>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // Scene setup
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: true });

        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        renderer.toneMapping = THREE.ACESFilmicToneMapping;
        renderer.toneMappingExposure = 1.2;
        document.getElementById('canvas-container').appendChild(renderer.domElement);

        // Create environment with neon text
        const cubeRenderTarget = new THREE.WebGLCubeRenderTarget(512, {
            format: THREE.RGBAFormat,
            generateMipmaps: true,
            minFilter: THREE.LinearMipmapLinearFilter
        });
        const cubeCamera = new THREE.CubeCamera(0.1, 100, cubeRenderTarget);

        // Create neon text panels around the sphere
        function createNeonText() {
            const canvas = document.createElement('canvas');
            canvas.width = 1024;
            canvas.height = 256;
            const ctx = canvas.getContext('2d');

            // Dark background
            ctx.fillStyle = '#0a0a0f';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Neon glow effect
            ctx.shadowColor = '#00ff88';
            ctx.shadowBlur = 40;
            ctx.shadowOffsetX = 0;
            ctx.shadowOffsetY = 0;

            // Text settings
            ctx.font = 'bold 72px "Courier New", monospace';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';

            // Draw multiple layers for glow
            for (let i = 0; i < 5; i++) {
                ctx.shadowBlur = 40 - i * 5;
                ctx.fillStyle = i === 4 ? '#ffffff' : '#00ff88';
                ctx.fillText('CONNECTION STABLE', canvas.width / 2, canvas.height / 2);
            }

            return canvas;
        }

        // Create floating text panels
        const textGroup = new THREE.Group();
        const textCanvas = createNeonText();
        const textTexture = new THREE.CanvasTexture(textCanvas);

        const panelGeometry = new THREE.PlaneGeometry(12, 3);
        const panelMaterial = new THREE.MeshBasicMaterial({
            map: textTexture,
            transparent: true,
            side: THREE.DoubleSide
        });

        // Position text panels around the scene
        const positions = [
            { pos: [0, 0, -15], rot: [0, 0, 0] },
            { pos: [0, 0, 15], rot: [0, Math.PI, 0] },
            { pos: [-15, 0, 0], rot: [0, Math.PI / 2, 0] },
            { pos: [15, 0, 0], rot: [0, -Math.PI / 2, 0] },
            { pos: [0, 12, 0], rot: [Math.PI / 2, 0, 0] },
            { pos: [0, -12, 0], rot: [-Math.PI / 2, 0, 0] }
        ];

        positions.forEach(({ pos, rot }) => {
            const panel = new THREE.Mesh(panelGeometry, panelMaterial);
            panel.position.set(...pos);
            panel.rotation.set(...rot);
            textGroup.add(panel);
        });

        scene.add(textGroup);

        // Chrome sphere with environment reflection
        const sphereGeometry = new THREE.SphereGeometry(2, 128, 128);
        const chromeMaterial = new THREE.MeshStandardMaterial({
            metalness: 1.0,
            roughness: 0.0,
            envMap: cubeRenderTarget.texture,
            envMapIntensity: 1.5
        });

        const sphere = new THREE.Mesh(sphereGeometry, chromeMaterial);
        scene.add(sphere);

        // Add subtle ambient light
        const ambientLight = new THREE.AmbientLight(0x222222);
        scene.add(ambientLight);

        // Add point lights with neon colors
        const lights = [
            { color: 0x00ff88, pos: [10, 5, 10] },
            { color: 0x00ff88, pos: [-10, -5, -10] },
            { color: 0x00ffcc, pos: [0, 10, 0] },
            { color: 0x88ff00, pos: [0, -10, 0] }
        ];

        lights.forEach(({ color, pos }) => {
            const light = new THREE.PointLight(color, 2, 50);
            light.position.set(...pos);
            scene.add(light);
        });

        // Add glow particles
        const particleCount = 200;
        const particleGeometry = new THREE.BufferGeometry();
        const particlePositions = new Float32Array(particleCount * 3);

        for (let i = 0; i < particleCount * 3; i += 3) {
            const theta = Math.random() * Math.PI * 2;
            const phi = Math.random() * Math.PI;
            const r = 8 + Math.random() * 4;
            particlePositions[i] = r * Math.sin(phi) * Math.cos(theta);
            particlePositions[i + 1] = r * Math.sin(phi) * Math.sin(theta);
            particlePositions[i + 2] = r * Math.cos(phi);
        }

        particleGeometry.setAttribute('position', new THREE.BufferAttribute(particlePositions, 3));

        const particleMaterial = new THREE.PointsMaterial({
            color: 0x00ff88,
            size: 0.05,
            transparent: true,
            opacity: 0.6
        });

        const particles = new THREE.Points(particleGeometry, particleMaterial);
        scene.add(particles);

        camera.position.z = 7;

        // Mouse interaction
        let mouseX = 0;
        let mouseY = 0;

        document.addEventListener('mousemove', (e) => {
            mouseX = (e.clientX / window.innerWidth - 0.5) * 2;
            mouseY = (e.clientY / window.innerHeight - 0.5) * 2;
        });

        // Animation
        function animate() {
            requestAnimationFrame(animate);

            const time = Date.now() * 0.001;

            // Rotate sphere
            sphere.rotation.y += 0.008;
            sphere.rotation.x = Math.sin(time * 0.5) * 0.2;

            // Rotate text group slowly in opposite direction
            textGroup.rotation.y -= 0.002;
            textGroup.rotation.x = Math.sin(time * 0.3) * 0.1;

            // Rotate particles
            particles.rotation.y += 0.001;
            particles.rotation.x += 0.0005;

            // Mouse influence on camera
            camera.position.x += (mouseX * 2 - camera.position.x) * 0.02;
            camera.position.y += (-mouseY * 2 - camera.position.y) * 0.02;
            camera.lookAt(0, 0, 0);

            // Update cube camera for reflections
            sphere.visible = false;
            cubeCamera.position.copy(sphere.position);
            cubeCamera.update(renderer, scene);
            sphere.visible = true;

            // Pulsing text glow
            const pulse = 0.8 + Math.sin(time * 3) * 0.2;
            panelMaterial.opacity = pulse;

            renderer.render(scene, camera);
        }

        // Handle resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        animate();

        console.log('ðŸ”® Chrome Sphere online - CONNECTION STABLE');
    </script>
<script src="/sloppy-header/sloppy-bar.js"></script>
</body>
</html>
