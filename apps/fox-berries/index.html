<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Treasure Platter for Scallywags</title>
  <link rel="icon" href="https://emojicdn.elk.sh/üè¥‚Äç‚ò†Ô∏è">
  <meta property="og:title" content="Treasure Platter for Scallywags">
  <meta property="og:description" content="Add treasure to the platter and watch pirates claim their share!">
  <meta property="og:url" content="https://app.sloppy.live/fox-berries">
  <meta property="og:image" content="https://emojicdn.elk.sh/üí∞?style=apple&size=512">
  <link href="https://fonts.googleapis.com/css2?family=Pirata+One&family=IM+Fell+English+SC&display=swap" rel="stylesheet">
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      min-height: 100vh;
      background: linear-gradient(180deg, #0d1a2a 0%, #1a2d4a 100%);
      font-family: 'IM Fell English SC', serif;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      overflow: hidden;
    }
    .scene {
      position: relative;
      width: 100vw;
      height: 100vh;
    }
    canvas {
      display: block;
      width: 100%;
      height: 100%;
    }
    .title {
      position: absolute;
      top: 20px;
      left: 50%;
      transform: translateX(-50%);
      font-family: 'Pirata One', cursive;
      font-size: 1.6rem;
      color: #d4a84b;
      text-shadow: 2px 2px 4px rgba(0,0,0,0.8), 0 0 20px rgba(212,168,75,0.3);
      text-align: center;
      pointer-events: none;
    }
    .treasure-count {
      position: absolute;
      top: 60px;
      left: 50%;
      transform: translateX(-50%);
      font-family: 'Pirata One', cursive;
      font-size: 1rem;
      color: #ffd700;
      text-shadow: 0 0 10px rgba(255,215,0,0.5);
      pointer-events: none;
    }
    .instructions {
      position: absolute;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      font-size: 0.8rem;
      color: rgba(212,168,75,0.5);
      text-align: center;
    }
    .back-link {
      position: fixed;
      bottom: 5px;
      right: 10px;
      color: #d4a84b;
      text-decoration: none;
      font-size: 0.7rem;
      opacity: 0.5;
    }
  </style>
</head>
<body>
  <div class="scene">
    <canvas id="canvas"></canvas>
    <div class="title">‚ò†Ô∏è Treasure Platter for Scallywags ü™ô</div>
    <div class="treasure-count" id="count">Doubloons: 0</div>
    <div class="instructions">Click to add treasure ‚Ä¢ Pirates will come to claim it!</div>
  </div>
  <a href="https://sloppy.live" class="back-link">sloppy.live</a>

<script>
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');

let treasures = [];
let pirates = [];
let particles = [];
let frameCount = 0;

const TREASURE_TYPES = [
  { color: '#ffd700', highlight: '#fff8dc', name: 'doubloon' },
  { color: '#c0c0c0', highlight: '#e8e8e8', name: 'silver' },
  { color: '#e63946', highlight: '#ff6b6b', name: 'ruby' },
  { color: '#2a9d8f', highlight: '#4ecdc4', name: 'emerald' }
];

const platter = {
  x: 0, y: 0,
  width: 320, height: 90
};

function resize() {
  canvas.width = window.innerWidth;
  canvas.height = window.innerHeight;
  platter.x = canvas.width / 2;
  platter.y = canvas.height / 2 + 50;
}

function addTreasure(x, y) {
  const type = TREASURE_TYPES[Math.floor(Math.random() * TREASURE_TYPES.length)];
  const onPlatter = Math.abs(x - platter.x) < platter.width/2 && Math.abs(y - platter.y) < platter.height;

  treasures.push({
    x: onPlatter ? x : platter.x + (Math.random() - 0.5) * platter.width * 0.8,
    y: onPlatter ? y : platter.y + (Math.random() - 0.5) * 30,
    size: 14 + Math.random() * 8,
    type,
    wobble: Math.random() * Math.PI * 2,
    scale: 0,
    shine: Math.random() * Math.PI * 2
  });

  // Maybe attract a pirate
  if (treasures.length > 3 && pirates.length < 3 && Math.random() < 0.3) {
    spawnPirate();
  }

  updateCount();
}

function spawnPirate() {
  const side = Math.random() < 0.5 ? -1 : 1;
  pirates.push({
    x: side < 0 ? -100 : canvas.width + 100,
    y: platter.y + 40,
    targetX: platter.x + (Math.random() - 0.5) * 100,
    direction: side,
    state: 'approaching',
    grabTimer: 0,
    legWalk: 0,
    hatType: Math.floor(Math.random() * 3),
    hasEyepatch: Math.random() > 0.5,
    hasPegleg: Math.random() > 0.7
  });
}

function spawnParticle(x, y, color) {
  for (let i = 0; i < 6; i++) {
    particles.push({
      x, y,
      vx: (Math.random() - 0.5) * 5,
      vy: -Math.random() * 4 - 1,
      size: 3 + Math.random() * 4,
      color,
      alpha: 1
    });
  }
}

function updateTreasures() {
  for (const t of treasures) {
    t.wobble += 0.03;
    t.shine += 0.08;
    t.scale = Math.min(1, t.scale + 0.1);
  }
}

function updatePirates() {
  for (let i = pirates.length - 1; i >= 0; i--) {
    const pirate = pirates[i];
    pirate.legWalk += 0.2;

    if (pirate.state === 'approaching') {
      const dx = pirate.targetX - pirate.x;
      pirate.x += dx * 0.02;
      pirate.direction = dx > 0 ? 1 : -1;

      if (Math.abs(dx) < 50) {
        pirate.state = 'grabbing';
        pirate.grabTimer = 80 + Math.random() * 60;
      }
    } else if (pirate.state === 'grabbing') {
      pirate.grabTimer--;

      // Grab treasure
      if (pirate.grabTimer % 40 === 0 && treasures.length > 0) {
        const closest = treasures.reduce((a, b) =>
          Math.abs(a.x - pirate.x) < Math.abs(b.x - pirate.x) ? a : b
        );
        spawnParticle(closest.x, closest.y, closest.type.color);
        treasures = treasures.filter(t => t !== closest);
        updateCount();
      }

      if (pirate.grabTimer <= 0 || treasures.length === 0) {
        pirate.state = 'leaving';
        pirate.targetX = pirate.direction < 0 ? -120 : canvas.width + 120;
      }
    } else if (pirate.state === 'leaving') {
      pirate.x += pirate.direction * 2.5;
      if (pirate.x < -120 || pirate.x > canvas.width + 120) {
        pirates.splice(i, 1);
      }
    }
  }
}

function updateParticles() {
  for (let i = particles.length - 1; i >= 0; i--) {
    const p = particles[i];
    p.x += p.vx;
    p.y += p.vy;
    p.vy += 0.15;
    p.alpha -= 0.025;
    if (p.alpha <= 0) particles.splice(i, 1);
  }
}

function drawPlatter() {
  ctx.save();
  ctx.translate(platter.x, platter.y);

  // Platter shadow
  ctx.fillStyle = 'rgba(0,0,0,0.3)';
  ctx.beginPath();
  ctx.ellipse(5, 15, platter.width/2, platter.height/2, 0, 0, Math.PI * 2);
  ctx.fill();

  // Wooden platter
  const platterGrad = ctx.createRadialGradient(0, 0, 0, 0, 0, platter.width/2);
  platterGrad.addColorStop(0, '#8b6914');
  platterGrad.addColorStop(0.7, '#5c3a1e');
  platterGrad.addColorStop(1, '#3a2a1a');
  ctx.fillStyle = platterGrad;
  ctx.beginPath();
  ctx.ellipse(0, 0, platter.width/2, platter.height/2, 0, 0, Math.PI * 2);
  ctx.fill();

  // Wood grain rings
  ctx.strokeStyle = 'rgba(58, 42, 26, 0.4)';
  ctx.lineWidth = 2;
  for (let r = 30; r < platter.width/2 - 20; r += 25) {
    ctx.beginPath();
    ctx.ellipse(0, 0, r, r * 0.55, 0, 0, Math.PI * 2);
    ctx.stroke();
  }

  // Platter rim (metal band)
  ctx.strokeStyle = '#d4a84b';
  ctx.lineWidth = 5;
  ctx.beginPath();
  ctx.ellipse(0, 0, platter.width/2, platter.height/2, 0, 0, Math.PI * 2);
  ctx.stroke();

  // Skull decoration
  ctx.fillStyle = '#d4a84b';
  ctx.font = '24px serif';
  ctx.textAlign = 'center';
  ctx.fillText('‚ò†', 0, 5);

  ctx.restore();
}

function drawTreasure(t) {
  ctx.save();
  ctx.translate(t.x, t.y);
  ctx.scale(t.scale, t.scale);

  const wobbleX = Math.sin(t.wobble) * 2;
  ctx.translate(wobbleX, 0);

  if (t.type.name === 'doubloon' || t.type.name === 'silver') {
    // Coin
    const coinGrad = ctx.createRadialGradient(-t.size * 0.2, -t.size * 0.2, 0, 0, 0, t.size);
    coinGrad.addColorStop(0, t.type.highlight);
    coinGrad.addColorStop(0.5, t.type.color);
    coinGrad.addColorStop(1, t.type.name === 'doubloon' ? '#b8860b' : '#808080');
    ctx.fillStyle = coinGrad;
    ctx.beginPath();
    ctx.arc(0, 0, t.size, 0, Math.PI * 2);
    ctx.fill();

    // Skull emblem
    ctx.fillStyle = t.type.name === 'doubloon' ? '#8b6914' : '#555';
    ctx.font = `${t.size}px serif`;
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText('‚ò†', 0, 1);

    // Shine
    ctx.globalAlpha = 0.3 + Math.sin(t.shine) * 0.2;
    ctx.fillStyle = '#fff';
    ctx.beginPath();
    ctx.arc(-t.size * 0.3, -t.size * 0.3, t.size * 0.25, 0, Math.PI * 2);
    ctx.fill();
    ctx.globalAlpha = 1;
  } else {
    // Gem
    ctx.fillStyle = t.type.color;
    ctx.beginPath();
    ctx.moveTo(0, -t.size);
    ctx.lineTo(t.size * 0.8, 0);
    ctx.lineTo(0, t.size * 0.7);
    ctx.lineTo(-t.size * 0.8, 0);
    ctx.closePath();
    ctx.fill();

    // Gem facets
    ctx.fillStyle = t.type.highlight;
    ctx.beginPath();
    ctx.moveTo(0, -t.size);
    ctx.lineTo(t.size * 0.3, -t.size * 0.3);
    ctx.lineTo(0, 0);
    ctx.lineTo(-t.size * 0.3, -t.size * 0.3);
    ctx.closePath();
    ctx.fill();

    // Sparkle
    ctx.globalAlpha = 0.5 + Math.sin(t.shine) * 0.3;
    ctx.fillStyle = '#fff';
    ctx.beginPath();
    ctx.arc(-t.size * 0.2, -t.size * 0.5, 3, 0, Math.PI * 2);
    ctx.fill();
    ctx.globalAlpha = 1;
  }

  ctx.restore();
}

function drawPirate(pirate) {
  ctx.save();
  ctx.translate(pirate.x, pirate.y);
  ctx.scale(pirate.direction, 1);

  const walkBounce = pirate.state === 'leaving' || pirate.state === 'approaching'
    ? Math.sin(pirate.legWalk) * 3 : 0;

  // Body (coat)
  ctx.fillStyle = '#8b0000';
  ctx.beginPath();
  ctx.ellipse(0, walkBounce, 30, 35, 0, 0, Math.PI * 2);
  ctx.fill();

  // Coat details
  ctx.strokeStyle = '#d4a84b';
  ctx.lineWidth = 2;
  ctx.beginPath();
  ctx.moveTo(0, -20 + walkBounce);
  ctx.lineTo(0, 20 + walkBounce);
  ctx.stroke();

  // Belt
  ctx.fillStyle = '#3a2a1a';
  ctx.fillRect(-25, 5 + walkBounce, 50, 10);
  ctx.fillStyle = '#d4a84b';
  ctx.beginPath();
  ctx.arc(0, 10 + walkBounce, 6, 0, Math.PI * 2);
  ctx.fill();

  // Head
  ctx.fillStyle = '#deb887';
  ctx.beginPath();
  ctx.arc(0, -45 + walkBounce, 22, 0, Math.PI * 2);
  ctx.fill();

  // Beard
  ctx.fillStyle = '#2a1a0a';
  ctx.beginPath();
  ctx.moveTo(-15, -35 + walkBounce);
  ctx.quadraticCurveTo(-20, -15 + walkBounce, -10, -5 + walkBounce);
  ctx.lineTo(10, -5 + walkBounce);
  ctx.quadraticCurveTo(20, -15 + walkBounce, 15, -35 + walkBounce);
  ctx.closePath();
  ctx.fill();

  // Eyes
  ctx.fillStyle = '#1a1a1a';
  const eyeSquint = pirate.state === 'grabbing' ? 2 : 4;
  ctx.beginPath();
  ctx.ellipse(-8, -50 + walkBounce, 3, eyeSquint, 0, 0, Math.PI * 2);
  ctx.fill();

  if (!pirate.hasEyepatch) {
    ctx.beginPath();
    ctx.ellipse(8, -50 + walkBounce, 3, eyeSquint, 0, 0, Math.PI * 2);
    ctx.fill();
  } else {
    // Eyepatch
    ctx.fillStyle = '#1a1a1a';
    ctx.beginPath();
    ctx.arc(8, -50 + walkBounce, 8, 0, Math.PI * 2);
    ctx.fill();
    ctx.strokeStyle = '#1a1a1a';
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(15, -50 + walkBounce);
    ctx.lineTo(20, -60 + walkBounce);
    ctx.stroke();
  }

  // Hat
  ctx.fillStyle = '#1a1a1a';
  if (pirate.hatType === 0) {
    // Tricorn
    ctx.beginPath();
    ctx.moveTo(-30, -60 + walkBounce);
    ctx.lineTo(0, -85 + walkBounce);
    ctx.lineTo(30, -60 + walkBounce);
    ctx.quadraticCurveTo(0, -55 + walkBounce, -30, -60 + walkBounce);
    ctx.fill();
    // Skull on hat
    ctx.fillStyle = '#f5f5dc';
    ctx.font = '12px serif';
    ctx.fillText('‚ò†', 0, -68 + walkBounce);
  } else if (pirate.hatType === 1) {
    // Bandana
    ctx.fillStyle = '#8b0000';
    ctx.beginPath();
    ctx.arc(0, -65 + walkBounce, 25, Math.PI, 0);
    ctx.fill();
    ctx.fillStyle = '#1a1a1a';
    ctx.fillRect(-25, -68 + walkBounce, 50, 5);
  } else {
    // Captain's hat
    ctx.beginPath();
    ctx.ellipse(0, -68 + walkBounce, 28, 12, 0, 0, Math.PI * 2);
    ctx.fill();
    ctx.fillRect(-20, -90 + walkBounce, 40, 25);
    ctx.fillStyle = '#d4a84b';
    ctx.font = '14px serif';
    ctx.fillText('‚ò†', 0, -75 + walkBounce);
  }

  // Arms
  ctx.fillStyle = '#8b0000';
  const armSwing = Math.sin(pirate.legWalk) * 10;
  ctx.save();
  ctx.translate(25, -10 + walkBounce);
  ctx.rotate(0.3 + armSwing * 0.02);
  ctx.fillRect(0, 0, 12, 35);
  // Hook or hand
  ctx.fillStyle = pirate.hasEyepatch ? '#d4a84b' : '#deb887';
  ctx.beginPath();
  ctx.arc(6, 38, 6, 0, Math.PI * 2);
  ctx.fill();
  ctx.restore();

  ctx.save();
  ctx.translate(-25, -10 + walkBounce);
  ctx.rotate(-0.3 - armSwing * 0.02);
  ctx.fillRect(-12, 0, 12, 35);
  ctx.fillStyle = '#deb887';
  ctx.beginPath();
  ctx.arc(-6, 38, 6, 0, Math.PI * 2);
  ctx.fill();
  ctx.restore();

  // Legs
  const legSwing = Math.sin(pirate.legWalk);
  ctx.fillStyle = '#2a1a0a';
  ctx.save();
  ctx.translate(-10, 30 + walkBounce);
  ctx.rotate(legSwing * 0.2);
  ctx.fillRect(-5, 0, 10, 30);
  // Boot or pegleg
  if (!pirate.hasPegleg) {
    ctx.fillStyle = '#1a1a1a';
    ctx.fillRect(-7, 28, 14, 10);
  } else {
    ctx.fillStyle = '#8b6914';
    ctx.fillRect(-3, 25, 6, 18);
  }
  ctx.restore();

  ctx.fillStyle = '#2a1a0a';
  ctx.save();
  ctx.translate(10, 30 + walkBounce);
  ctx.rotate(-legSwing * 0.2);
  ctx.fillRect(-5, 0, 10, 30);
  ctx.fillStyle = '#1a1a1a';
  ctx.fillRect(-7, 28, 14, 10);
  ctx.restore();

  ctx.restore();
}

function drawParticles() {
  for (const p of particles) {
    ctx.globalAlpha = p.alpha;
    ctx.fillStyle = p.color;
    ctx.shadowColor = p.color;
    ctx.shadowBlur = 8;
    ctx.beginPath();
    ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
    ctx.fill();
  }
  ctx.globalAlpha = 1;
  ctx.shadowBlur = 0;
}

function drawBackground() {
  // Ship deck floor
  const deckGrad = ctx.createLinearGradient(0, canvas.height * 0.5, 0, canvas.height);
  deckGrad.addColorStop(0, '#5c3a1e');
  deckGrad.addColorStop(1, '#3a2a1a');
  ctx.fillStyle = deckGrad;
  ctx.fillRect(0, canvas.height * 0.5, canvas.width, canvas.height * 0.5);

  // Deck planks
  ctx.strokeStyle = '#2a1a0a';
  ctx.lineWidth = 2;
  for (let x = 0; x < canvas.width; x += 80) {
    ctx.beginPath();
    ctx.moveTo(x, canvas.height * 0.5);
    ctx.lineTo(x, canvas.height);
    ctx.stroke();
  }

  // Ropes on deck
  ctx.strokeStyle = '#8b6914';
  ctx.lineWidth = 4;
  for (let i = 0; i < 3; i++) {
    const x = 100 + i * 300;
    const y = canvas.height * 0.55 + i * 60;
    ctx.beginPath();
    ctx.moveTo(x, y);
    ctx.quadraticCurveTo(x + 50, y + 20 + Math.sin(frameCount * 0.02 + i) * 5, x + 100, y - 10);
    ctx.stroke();
  }

  // Stars in sky
  ctx.fillStyle = '#fff';
  for (let i = 0; i < 40; i++) {
    const x = (i * 97) % canvas.width;
    const y = (i * 53) % (canvas.height * 0.45);
    const alpha = 0.3 + Math.sin(frameCount * 0.05 + i) * 0.2;
    ctx.globalAlpha = alpha;
    ctx.beginPath();
    ctx.arc(x, y, 1.5, 0, Math.PI * 2);
    ctx.fill();
  }
  ctx.globalAlpha = 1;

  // Moon
  ctx.fillStyle = '#f5f5dc';
  ctx.shadowColor = '#f5f5dc';
  ctx.shadowBlur = 30;
  ctx.beginPath();
  ctx.arc(canvas.width - 100, 80, 35, 0, Math.PI * 2);
  ctx.fill();
  ctx.shadowBlur = 0;

  // Lantern glows
  ctx.fillStyle = '#ffaa00';
  for (let i = 0; i < 4; i++) {
    const x = 80 + i * 200;
    const y = canvas.height * 0.52;
    const flicker = 0.4 + Math.sin(frameCount * 0.15 + i * 2) * 0.2;
    ctx.globalAlpha = flicker;
    ctx.shadowColor = '#ffaa00';
    ctx.shadowBlur = 20;
    ctx.beginPath();
    ctx.arc(x, y, 8, 0, Math.PI * 2);
    ctx.fill();
  }
  ctx.globalAlpha = 1;
  ctx.shadowBlur = 0;
}

function render() {
  ctx.clearRect(0, 0, canvas.width, canvas.height);

  drawBackground();
  drawPlatter();

  // Sort treasures by y for depth
  treasures.sort((a, b) => a.y - b.y);
  for (const t of treasures) drawTreasure(t);

  drawParticles();

  // Sort pirates by y for depth
  pirates.sort((a, b) => a.y - b.y);
  for (const pirate of pirates) drawPirate(pirate);
}

function updateCount() {
  document.getElementById('count').textContent = `Doubloons: ${treasures.length}`;
}

function gameLoop() {
  frameCount++;
  updateTreasures();
  updatePirates();
  updateParticles();
  render();
  requestAnimationFrame(gameLoop);
}

canvas.addEventListener('click', e => {
  const rect = canvas.getBoundingClientRect();
  const x = e.clientX - rect.left;
  const y = e.clientY - rect.top;
  addTreasure(x, y);
});

canvas.addEventListener('touchstart', e => {
  e.preventDefault();
  const touch = e.touches[0];
  const rect = canvas.getBoundingClientRect();
  addTreasure(touch.clientX - rect.left, touch.clientY - rect.top);
});

window.addEventListener('resize', resize);

// Init with some treasure
resize();
for (let i = 0; i < 8; i++) {
  setTimeout(() => {
    addTreasure(
      platter.x + (Math.random() - 0.5) * platter.width * 0.7,
      platter.y + (Math.random() - 0.5) * 20
    );
  }, i * 100);
}
gameLoop();
</script>
<script src="/apps/sloppy-header/sloppy-bar.js"></script>
<script src="/vibelib-extended.js"></script>
<script>
  // Compatibility Patch for Legacy Apps
  window.addEventListener("load", () => {
    if (window.SloppyKarma && window.VibeLib.Economy) {
      // Redirect old calls to new engine
      window.SloppyKarma.track = window.VibeLib.Economy.track;
    }
  });
</script>
</body>
</html>
