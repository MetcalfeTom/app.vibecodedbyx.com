<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>TSP Genetic Algorithm</title>
  <link rel="icon" href="https://emojicdn.elk.sh/ðŸ§¬">
  <meta property="og:title" content="TSP Genetic Algorithm">
  <meta property="og:description" content="Watch evolution find the shortest path through neon cities">
  <meta property="og:url" content="https://sloppy.live/tsp-genetic">
  <meta property="og:image" content="https://emojicdn.elk.sh/ðŸ§¬?style=apple&size=512">
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700&family=Share+Tech+Mono&display=swap" rel="stylesheet">
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }

    body {
      min-height: 100vh;
      background: #0a0a0f;
      font-family: 'Share Tech Mono', monospace;
      color: #e0e0e0;
      overflow: hidden;
    }

    .header {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      padding: 0.8rem 1.5rem;
      background: linear-gradient(to bottom, rgba(10, 10, 15, 0.95), rgba(10, 10, 15, 0.7));
      display: flex;
      justify-content: space-between;
      align-items: center;
      flex-wrap: wrap;
      gap: 0.8rem;
      z-index: 100;
    }

    h1 {
      font-family: 'Orbitron', sans-serif;
      font-size: 1.1rem;
      font-weight: 700;
      color: #0ff;
      text-shadow: 0 0 10px #0ff, 0 0 30px #0ff;
      letter-spacing: 2px;
    }

    .stats {
      font-size: 0.7rem;
      color: #888;
      display: flex;
      gap: 1.2rem;
      flex-wrap: wrap;
    }

    .stat-value { color: #0f0; text-shadow: 0 0 5px #0f0; }
    .stat-best { color: #ff0; text-shadow: 0 0 5px #ff0; }

    .controls {
      display: flex;
      gap: 0.4rem;
      flex-wrap: wrap;
      align-items: center;
    }

    .btn {
      font-family: 'Share Tech Mono', monospace;
      font-size: 0.7rem;
      padding: 0.4rem 0.8rem;
      background: rgba(0, 255, 255, 0.1);
      border: 1px solid #0ff;
      color: #0ff;
      cursor: pointer;
      transition: all 0.2s;
      text-transform: uppercase;
      letter-spacing: 1px;
    }

    .btn:hover {
      background: rgba(0, 255, 255, 0.3);
      box-shadow: 0 0 15px rgba(0, 255, 255, 0.5);
    }

    .btn.active {
      background: #0ff;
      color: #0a0a0f;
    }

    .btn.reset {
      border-color: #f0f;
      color: #f0f;
    }

    .btn.reset:hover {
      background: rgba(255, 0, 255, 0.3);
      box-shadow: 0 0 15px rgba(255, 0, 255, 0.5);
    }

    .slider-group {
      display: flex;
      align-items: center;
      gap: 0.3rem;
      font-size: 0.65rem;
      color: #888;
    }

    input[type="range"] {
      width: 50px;
      accent-color: #0ff;
    }

    canvas {
      display: block;
      cursor: crosshair;
    }

    .info {
      position: fixed;
      bottom: 0.8rem;
      left: 50%;
      transform: translateX(-50%);
      font-size: 0.6rem;
      color: #444;
      text-align: center;
    }

    .info a { color: #555; text-decoration: none; }

    .legend {
      position: fixed;
      bottom: 2.5rem;
      left: 1rem;
      font-size: 0.6rem;
      color: #666;
    }

    .legend-item {
      display: flex;
      align-items: center;
      gap: 0.4rem;
      margin-bottom: 0.3rem;
    }

    .legend-color {
      width: 20px;
      height: 3px;
      border-radius: 2px;
    }

    .fitness-graph {
      position: fixed;
      bottom: 2.5rem;
      right: 1rem;
      width: 150px;
      height: 60px;
      background: rgba(0, 0, 0, 0.5);
      border: 1px solid #333;
      border-radius: 4px;
    }

    .graph-label {
      position: absolute;
      top: -1.2rem;
      left: 0;
      font-size: 0.55rem;
      color: #666;
    }
  </style>
</head>
<body>
  <div class="header">
    <h1>ðŸ§¬ TSP GENETIC</h1>
    <div class="stats">
      <span>Gen: <span class="stat-value" id="generation">0</span></span>
      <span>Pop: <span class="stat-value" id="population">0</span></span>
      <span>Cities: <span class="stat-value" id="cityCount">0</span></span>
      <span>Best: <span class="stat-best" id="bestDist">--</span></span>
      <span>Current: <span class="stat-value" id="currDist">--</span></span>
    </div>
    <div class="controls">
      <button class="btn" id="stepBtn">Step</button>
      <button class="btn" id="runBtn">Evolve</button>
      <div class="slider-group">
        <label>Pop:</label>
        <input type="range" id="popSlider" min="20" max="200" value="100">
      </div>
      <div class="slider-group">
        <label>Mut:</label>
        <input type="range" id="mutSlider" min="1" max="50" value="15">
      </div>
      <button class="btn" id="randomBtn">Random</button>
      <button class="btn reset" id="resetBtn">Clear</button>
    </div>
  </div>

  <canvas id="canvas"></canvas>

  <div class="legend">
    <div class="legend-item">
      <div class="legend-color" style="background: linear-gradient(90deg, #0f0, #ff0);"></div>
      <span>Best route</span>
    </div>
    <div class="legend-item">
      <div class="legend-color" style="background: rgba(0, 255, 255, 0.3);"></div>
      <span>Current route</span>
    </div>
  </div>

  <div class="fitness-graph">
    <div class="graph-label">Fitness History</div>
    <canvas id="graphCanvas"></canvas>
  </div>

  <div class="info">
    Click to add cities â€¢ Genetic algorithm finds shortest tour<br>
    <a href="https://sloppy.live">sloppy.live</a>
  </div>

  <script>
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    const graphCanvas = document.getElementById('graphCanvas');
    const graphCtx = graphCanvas.getContext('2d');

    let width, height;
    let cities = [];
    let population = [];
    let bestEver = null;
    let bestEverDist = Infinity;
    let generation = 0;
    let running = false;
    let fitnessHistory = [];

    // UI elements
    const generationEl = document.getElementById('generation');
    const populationEl = document.getElementById('population');
    const cityCountEl = document.getElementById('cityCount');
    const bestDistEl = document.getElementById('bestDist');
    const currDistEl = document.getElementById('currDist');

    function resize() {
      width = canvas.width = window.innerWidth;
      height = canvas.height = window.innerHeight;
      graphCanvas.width = 150;
      graphCanvas.height = 60;
    }

    // Calculate total distance of a route
    function calcDistance(route) {
      let dist = 0;
      for (let i = 0; i < route.length; i++) {
        const a = cities[route[i]];
        const b = cities[route[(i + 1) % route.length]];
        dist += Math.hypot(b.x - a.x, b.y - a.y);
      }
      return dist;
    }

    // Create random route
    function randomRoute() {
      const route = cities.map((_, i) => i);
      // Fisher-Yates shuffle
      for (let i = route.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [route[i], route[j]] = [route[j], route[i]];
      }
      return route;
    }

    // Initialize population
    function initPopulation() {
      const popSize = parseInt(document.getElementById('popSlider').value);
      population = [];
      for (let i = 0; i < popSize; i++) {
        population.push(randomRoute());
      }
      generation = 0;
      bestEver = null;
      bestEverDist = Infinity;
      fitnessHistory = [];
      updateStats();
    }

    // Tournament selection
    function tournamentSelect(tournamentSize = 5) {
      let best = null;
      let bestFitness = Infinity;

      for (let i = 0; i < tournamentSize; i++) {
        const idx = Math.floor(Math.random() * population.length);
        const dist = calcDistance(population[idx]);
        if (dist < bestFitness) {
          bestFitness = dist;
          best = population[idx];
        }
      }

      return best.slice();
    }

    // Order crossover (OX)
    function crossover(parent1, parent2) {
      const size = parent1.length;
      const start = Math.floor(Math.random() * size);
      const end = start + Math.floor(Math.random() * (size - start));

      const child = new Array(size).fill(-1);

      // Copy segment from parent1
      for (let i = start; i <= end; i++) {
        child[i] = parent1[i];
      }

      // Fill rest from parent2
      let childIdx = (end + 1) % size;
      for (let i = 0; i < size; i++) {
        const parent2Idx = (end + 1 + i) % size;
        const city = parent2[parent2Idx];
        if (!child.includes(city)) {
          child[childIdx] = city;
          childIdx = (childIdx + 1) % size;
        }
      }

      return child;
    }

    // Mutation - swap two cities
    function mutate(route) {
      const mutationRate = parseInt(document.getElementById('mutSlider').value) / 100;

      if (Math.random() < mutationRate) {
        const i = Math.floor(Math.random() * route.length);
        const j = Math.floor(Math.random() * route.length);
        [route[i], route[j]] = [route[j], route[i]];
      }

      // 2-opt improvement occasionally
      if (Math.random() < mutationRate * 0.5) {
        const i = Math.floor(Math.random() * route.length);
        const j = Math.floor(Math.random() * route.length);
        if (i < j) {
          // Reverse segment
          const segment = route.slice(i, j + 1).reverse();
          route.splice(i, j - i + 1, ...segment);
        }
      }

      return route;
    }

    // Evolve one generation
    function evolve() {
      if (cities.length < 3) return;

      const popSize = population.length;
      const newPop = [];

      // Elitism - keep best
      let bestIdx = 0;
      let bestDist = Infinity;
      for (let i = 0; i < population.length; i++) {
        const dist = calcDistance(population[i]);
        if (dist < bestDist) {
          bestDist = dist;
          bestIdx = i;
        }
      }
      newPop.push(population[bestIdx].slice());

      // Update best ever
      if (bestDist < bestEverDist) {
        bestEverDist = bestDist;
        bestEver = population[bestIdx].slice();
      }

      // Create new population
      while (newPop.length < popSize) {
        const parent1 = tournamentSelect();
        const parent2 = tournamentSelect();
        let child = crossover(parent1, parent2);
        child = mutate(child);
        newPop.push(child);
      }

      population = newPop;
      generation++;

      // Record fitness
      fitnessHistory.push(bestDist);
      if (fitnessHistory.length > 100) {
        fitnessHistory.shift();
      }

      updateStats();
    }

    function updateStats() {
      generationEl.textContent = generation;
      populationEl.textContent = population.length;
      cityCountEl.textContent = cities.length;

      if (bestEver) {
        bestDistEl.textContent = Math.round(bestEverDist);
      }

      if (population.length > 0) {
        const currBest = Math.min(...population.map(calcDistance));
        currDistEl.textContent = Math.round(currBest);
      }
    }

    function draw() {
      // Clear with fade
      ctx.fillStyle = 'rgba(10, 10, 15, 0.3)';
      ctx.fillRect(0, 0, width, height);

      // Draw grid
      ctx.strokeStyle = 'rgba(0, 255, 255, 0.03)';
      ctx.lineWidth = 1;
      const gridSize = 50;
      for (let x = 0; x < width; x += gridSize) {
        ctx.beginPath();
        ctx.moveTo(x, 0);
        ctx.lineTo(x, height);
        ctx.stroke();
      }
      for (let y = 0; y < height; y += gridSize) {
        ctx.beginPath();
        ctx.moveTo(0, y);
        ctx.lineTo(width, y);
        ctx.stroke();
      }

      if (cities.length === 0) return;

      // Draw current best route from population (faint)
      if (population.length > 0) {
        let bestRoute = population[0];
        let bestDist = calcDistance(population[0]);
        for (const route of population) {
          const dist = calcDistance(route);
          if (dist < bestDist) {
            bestDist = dist;
            bestRoute = route;
          }
        }

        ctx.strokeStyle = 'rgba(0, 255, 255, 0.2)';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(cities[bestRoute[0]].x, cities[bestRoute[0]].y);
        for (let i = 1; i <= bestRoute.length; i++) {
          const city = cities[bestRoute[i % bestRoute.length]];
          ctx.lineTo(city.x, city.y);
        }
        ctx.stroke();
      }

      // Draw best ever route (bright)
      if (bestEver) {
        // Glow effect
        ctx.shadowColor = '#0f0';
        ctx.shadowBlur = 15;

        const gradient = ctx.createLinearGradient(0, 0, width, height);
        gradient.addColorStop(0, '#0f0');
        gradient.addColorStop(0.5, '#ff0');
        gradient.addColorStop(1, '#0f0');

        ctx.strokeStyle = gradient;
        ctx.lineWidth = 3;
        ctx.beginPath();
        ctx.moveTo(cities[bestEver[0]].x, cities[bestEver[0]].y);
        for (let i = 1; i <= bestEver.length; i++) {
          const city = cities[bestEver[i % bestEver.length]];
          ctx.lineTo(city.x, city.y);
        }
        ctx.stroke();

        ctx.shadowBlur = 0;
      }

      // Draw cities
      for (let i = 0; i < cities.length; i++) {
        const city = cities[i];

        // Outer glow
        const glowGradient = ctx.createRadialGradient(city.x, city.y, 0, city.x, city.y, 20);
        glowGradient.addColorStop(0, 'rgba(255, 0, 255, 0.8)');
        glowGradient.addColorStop(0.5, 'rgba(255, 0, 255, 0.2)');
        glowGradient.addColorStop(1, 'transparent');
        ctx.fillStyle = glowGradient;
        ctx.beginPath();
        ctx.arc(city.x, city.y, 20, 0, Math.PI * 2);
        ctx.fill();

        // City dot
        ctx.fillStyle = '#f0f';
        ctx.shadowColor = '#f0f';
        ctx.shadowBlur = 10;
        ctx.beginPath();
        ctx.arc(city.x, city.y, 6, 0, Math.PI * 2);
        ctx.fill();
        ctx.shadowBlur = 0;

        // City number
        ctx.fillStyle = '#fff';
        ctx.font = '10px Share Tech Mono';
        ctx.textAlign = 'center';
        ctx.fillText(i + 1, city.x, city.y - 12);
      }

      // Draw fitness graph
      drawGraph();
    }

    function drawGraph() {
      graphCtx.fillStyle = 'rgba(0, 0, 0, 0.8)';
      graphCtx.fillRect(0, 0, 150, 60);

      if (fitnessHistory.length < 2) return;

      const max = Math.max(...fitnessHistory);
      const min = Math.min(...fitnessHistory);
      const range = max - min || 1;

      graphCtx.strokeStyle = '#0f0';
      graphCtx.lineWidth = 1;
      graphCtx.beginPath();

      for (let i = 0; i < fitnessHistory.length; i++) {
        const x = (i / (fitnessHistory.length - 1)) * 148 + 1;
        const y = 58 - ((fitnessHistory[i] - min) / range) * 54;

        if (i === 0) {
          graphCtx.moveTo(x, y);
        } else {
          graphCtx.lineTo(x, y);
        }
      }
      graphCtx.stroke();
    }

    function animate() {
      if (running && cities.length >= 3) {
        // Run multiple generations per frame for speed
        for (let i = 0; i < 5; i++) {
          evolve();
        }
      }
      draw();
      requestAnimationFrame(animate);
    }

    // Add random cities
    function addRandomCities(count = 20) {
      const padding = 100;
      for (let i = 0; i < count; i++) {
        cities.push({
          x: padding + Math.random() * (width - padding * 2),
          y: padding + Math.random() * (height - padding * 2)
        });
      }
      initPopulation();
    }

    // Event handlers
    canvas.addEventListener('click', (e) => {
      const rect = canvas.getBoundingClientRect();
      cities.push({
        x: e.clientX - rect.left,
        y: e.clientY - rect.top
      });
      if (cities.length >= 3) {
        initPopulation();
      }
      updateStats();
    });

    document.getElementById('stepBtn').addEventListener('click', () => {
      if (cities.length >= 3) {
        if (population.length === 0) initPopulation();
        evolve();
      }
    });

    document.getElementById('runBtn').addEventListener('click', function() {
      if (cities.length >= 3) {
        if (population.length === 0) initPopulation();
        running = !running;
        this.textContent = running ? 'Pause' : 'Evolve';
        this.classList.toggle('active', running);
      }
    });

    document.getElementById('randomBtn').addEventListener('click', () => {
      cities = [];
      running = false;
      document.getElementById('runBtn').textContent = 'Evolve';
      document.getElementById('runBtn').classList.remove('active');
      addRandomCities(25);
    });

    document.getElementById('resetBtn').addEventListener('click', () => {
      cities = [];
      population = [];
      bestEver = null;
      bestEverDist = Infinity;
      generation = 0;
      fitnessHistory = [];
      running = false;
      document.getElementById('runBtn').textContent = 'Evolve';
      document.getElementById('runBtn').classList.remove('active');
      updateStats();
    });

    document.getElementById('popSlider').addEventListener('input', () => {
      if (cities.length >= 3) {
        initPopulation();
      }
    });

    window.addEventListener('resize', resize);

    // Initialize
    resize();
    addRandomCities(20);
    animate();
  </script>
<script src="/sloppy-header/sloppy-bar.js"></script>
</body>
</html>
