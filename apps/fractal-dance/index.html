<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Fractal Dance</title>
  <link rel="icon" href="https://emojicdn.elk.sh/ðŸŒ€">
  <meta property="og:title" content="Fractal Dance">
  <meta property="og:description" content="Neon fractals that dance to your emotes!">
  <meta property="og:url" content="https://sloppy.live/fractal-dance">
  <meta property="og:image" content="https://sloppy.live/fractal-dance/og-image.png">
  <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&display=swap" rel="stylesheet">
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      background: #000;
      min-height: 100vh;
      display: flex;
      flex-direction: column;
      font-family: 'Orbitron', monospace;
      overflow: hidden;
    }

    .header {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      padding: 15px 20px;
      background: linear-gradient(180deg, rgba(0,0,0,0.9), transparent);
      z-index: 100;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

    h1 {
      font-size: 1.3rem;
      font-weight: 900;
      background: linear-gradient(90deg, #ff00ff, #00ffff, #ffff00, #ff00ff);
      background-size: 300% 100%;
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
      animation: rainbow 3s linear infinite;
    }

    @keyframes rainbow {
      0% { background-position: 0% 50%; }
      100% { background-position: 300% 50%; }
    }

    .chaos-meter {
      display: flex;
      align-items: center;
      gap: 10px;
      font-size: 0.7rem;
      color: #888;
    }

    .meter-bar {
      width: 100px;
      height: 8px;
      background: #222;
      border-radius: 4px;
      overflow: hidden;
    }

    .meter-fill {
      height: 100%;
      background: linear-gradient(90deg, #00ff00, #ffff00, #ff0000);
      transition: width 0.3s;
    }

    canvas {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
    }

    .emote-panel {
      position: fixed;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      z-index: 100;
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 15px;
    }

    .emote-grid {
      display: flex;
      gap: 8px;
      flex-wrap: wrap;
      justify-content: center;
      max-width: 400px;
    }

    .emote-btn {
      width: 50px;
      height: 50px;
      background: rgba(20, 20, 30, 0.8);
      border: 2px solid #333;
      border-radius: 10px;
      font-size: 1.8rem;
      cursor: pointer;
      transition: all 0.2s;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .emote-btn:hover {
      transform: scale(1.15);
      border-color: #ff00ff;
      box-shadow: 0 0 20px rgba(255, 0, 255, 0.5);
    }

    .emote-btn:active {
      transform: scale(0.95);
    }

    .emote-btn.active {
      animation: emote-pulse 0.3s ease-out;
    }

    @keyframes emote-pulse {
      0% { transform: scale(1); }
      50% { transform: scale(1.3); }
      100% { transform: scale(1); }
    }

    .feed {
      display: flex;
      gap: 5px;
      height: 40px;
      align-items: center;
      overflow: hidden;
    }

    .feed-emote {
      font-size: 1.5rem;
      animation: feed-float 2s ease-out forwards;
      opacity: 0;
    }

    @keyframes feed-float {
      0% { opacity: 1; transform: translateY(0) scale(1); }
      100% { opacity: 0; transform: translateY(-30px) scale(0.5); }
    }

    .info {
      position: fixed;
      bottom: 140px;
      left: 50%;
      transform: translateX(-50%);
      color: #444;
      font-size: 0.65rem;
      text-align: center;
    }

    .effect-name {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      font-size: 2rem;
      font-weight: 900;
      color: #fff;
      text-shadow: 0 0 20px currentColor;
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.3s;
    }

    .effect-name.show {
      animation: effect-flash 1s ease-out;
    }

    @keyframes effect-flash {
      0% { opacity: 1; transform: translate(-50%, -50%) scale(1); }
      100% { opacity: 0; transform: translate(-50%, -50%) scale(1.5); }
    }

    .back-link {
      position: fixed;
      bottom: 5px;
      right: 10px;
      color: #333;
      text-decoration: none;
      font-size: 0.6rem;
      z-index: 100;
    }

    .back-link:hover {
      color: #ff00ff;
    }
  </style>
</head>
<body>
  <div class="header">
    <h1>FRACTAL DANCE</h1>
    <div class="chaos-meter">
      <span>CHAOS</span>
      <div class="meter-bar"><div class="meter-fill" id="chaosMeter" style="width:30%"></div></div>
    </div>
  </div>

  <canvas id="fractal"></canvas>

  <div class="effect-name" id="effectName"></div>

  <div class="info">Tap emotes to warp the fractal!</div>

  <div class="emote-panel">
    <div class="feed" id="feed"></div>
    <div class="emote-grid" id="emoteGrid">
      <!-- Generated by JS -->
    </div>
  </div>

  <a href="https://sloppy.live" class="back-link">sloppy.live</a>

  <script>
    const canvas = document.getElementById('fractal');
    const ctx = canvas.getContext('2d');
    const effectNameEl = document.getElementById('effectName');
    const feedEl = document.getElementById('feed');
    const chaosMeterEl = document.getElementById('chaosMeter');

    // Emote effects
    const emotes = [
      { emoji: 'ðŸ”¥', name: 'FIRE', color: '#ff4400', cMod: [0.1, 0.05], zoom: 0.8, chaos: 20 },
      { emoji: 'ðŸ’œ', name: 'LOVE', color: '#ff00ff', cMod: [-0.05, 0.1], zoom: 1.2, chaos: 10 },
      { emoji: 'ðŸŒŠ', name: 'WAVE', color: '#00aaff', cMod: [0.02, -0.08], zoom: 1.0, chaos: 15 },
      { emoji: 'âš¡', name: 'SHOCK', color: '#ffff00', cMod: [0.15, 0.15], zoom: 0.6, chaos: 30 },
      { emoji: 'ðŸŽ‰', name: 'PARTY', color: '#ff00aa', cMod: [-0.1, 0.1], zoom: 1.5, chaos: 25 },
      { emoji: 'ðŸ˜‚', name: 'CHAOS', color: '#00ff00', cMod: [0.08, -0.12], zoom: 0.9, chaos: 35 },
      { emoji: 'ðŸŒ€', name: 'SPIRAL', color: '#00ffff', cMod: [-0.02, 0.02], zoom: 2.0, chaos: 5 },
      { emoji: 'ðŸ’€', name: 'DOOM', color: '#880088', cMod: [0.2, 0.0], zoom: 0.5, chaos: 40 },
      { emoji: 'âœ¨', name: 'SPARKLE', color: '#ffffff', cMod: [0.0, 0.08], zoom: 1.3, chaos: 8 },
      { emoji: 'ðŸš€', name: 'ZOOM', color: '#ff8800', cMod: [0.05, 0.05], zoom: 0.4, chaos: 20 },
      { emoji: 'ðŸ‘€', name: 'WARP', color: '#88ff00', cMod: [-0.08, -0.08], zoom: 1.1, chaos: 18 },
      { emoji: 'ðŸŒˆ', name: 'RAINBOW', color: '#ff00ff', cMod: [0.0, 0.0], zoom: 1.0, chaos: 12, rainbow: true }
    ];

    // Fractal state
    let width, height;
    let imageData;
    let time = 0;
    let cReal = -0.7;
    let cImag = 0.27;
    let targetCReal = cReal;
    let targetCImag = cImag;
    let zoom = 1.0;
    let targetZoom = zoom;
    let rotation = 0;
    let chaos = 30;
    let hueShift = 0;
    let rainbowMode = false;

    // Setup canvas
    function resize() {
      width = window.innerWidth;
      height = window.innerHeight;
      canvas.width = Math.floor(width / 2);
      canvas.height = Math.floor(height / 2);
      imageData = ctx.createImageData(canvas.width, canvas.height);
    }

    resize();
    window.addEventListener('resize', resize);

    // Create emote buttons
    const emoteGrid = document.getElementById('emoteGrid');
    emotes.forEach((emote, i) => {
      const btn = document.createElement('button');
      btn.className = 'emote-btn';
      btn.textContent = emote.emoji;
      btn.addEventListener('click', () => triggerEmote(emote, btn));
      emoteGrid.appendChild(btn);
    });

    function triggerEmote(emote, btn) {
      // Visual feedback
      btn.classList.remove('active');
      void btn.offsetWidth;
      btn.classList.add('active');

      // Add to feed
      const feedEmote = document.createElement('span');
      feedEmote.className = 'feed-emote';
      feedEmote.textContent = emote.emoji;
      feedEl.appendChild(feedEmote);
      setTimeout(() => feedEmote.remove(), 2000);

      // Limit feed size
      while (feedEl.children.length > 8) {
        feedEl.removeChild(feedEl.firstChild);
      }

      // Show effect name
      effectNameEl.textContent = emote.name;
      effectNameEl.style.color = emote.color;
      effectNameEl.classList.remove('show');
      void effectNameEl.offsetWidth;
      effectNameEl.classList.add('show');

      // Apply effect
      targetCReal += emote.cMod[0] * (Math.random() * 0.5 + 0.75);
      targetCImag += emote.cMod[1] * (Math.random() * 0.5 + 0.75);
      targetZoom *= emote.zoom;

      // Keep in interesting range
      targetCReal = Math.max(-1.5, Math.min(1.5, targetCReal));
      targetCImag = Math.max(-1.5, Math.min(1.5, targetCImag));
      targetZoom = Math.max(0.3, Math.min(3.0, targetZoom));

      // Update chaos
      chaos = Math.min(100, chaos + emote.chaos * 0.5);

      // Rainbow mode
      if (emote.rainbow) {
        rainbowMode = !rainbowMode;
      }

      // Color shift
      hueShift += 30;
    }

    // Fractal rendering
    function renderFractal() {
      const data = imageData.data;
      const w = canvas.width;
      const h = canvas.height;
      const maxIter = 80 + Math.floor(chaos * 0.5);

      const scale = 3.5 / (zoom * Math.min(w, h));
      const cos = Math.cos(rotation);
      const sin = Math.sin(rotation);

      for (let py = 0; py < h; py++) {
        for (let px = 0; px < w; px++) {
          // Map pixel to complex plane with rotation
          let x0 = (px - w / 2) * scale;
          let y0 = (py - h / 2) * scale;

          // Apply rotation
          const rx = x0 * cos - y0 * sin;
          const ry = x0 * sin + y0 * cos;

          // Julia set iteration
          let x = rx;
          let y = ry;
          let iter = 0;

          while (x * x + y * y < 4 && iter < maxIter) {
            const xtemp = x * x - y * y + cReal;
            y = 2 * x * y + cImag;
            x = xtemp;
            iter++;
          }

          // Color mapping
          const idx = (py * w + px) * 4;

          if (iter === maxIter) {
            data[idx] = 0;
            data[idx + 1] = 0;
            data[idx + 2] = 0;
          } else {
            const t = iter / maxIter;
            const hue = rainbowMode
              ? (t * 360 + time * 50 + hueShift) % 360
              : (t * 180 + hueShift) % 360;

            const [r, g, b] = hslToRgb(hue / 360, 1, 0.5 + t * 0.3);

            data[idx] = r;
            data[idx + 1] = g;
            data[idx + 2] = b;
          }
          data[idx + 3] = 255;
        }
      }

      ctx.putImageData(imageData, 0, 0);
    }

    function hslToRgb(h, s, l) {
      let r, g, b;

      if (s === 0) {
        r = g = b = l;
      } else {
        const hue2rgb = (p, q, t) => {
          if (t < 0) t += 1;
          if (t > 1) t -= 1;
          if (t < 1/6) return p + (q - p) * 6 * t;
          if (t < 1/2) return q;
          if (t < 2/3) return p + (q - p) * (2/3 - t) * 6;
          return p;
        };

        const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
        const p = 2 * l - q;
        r = hue2rgb(p, q, h + 1/3);
        g = hue2rgb(p, q, h);
        b = hue2rgb(p, q, h - 1/3);
      }

      return [Math.round(r * 255), Math.round(g * 255), Math.round(b * 255)];
    }

    // Animation loop
    function animate() {
      time += 0.016;

      // Smooth interpolation
      cReal += (targetCReal - cReal) * 0.05;
      cImag += (targetCImag - cImag) * 0.05;
      zoom += (targetZoom - zoom) * 0.03;

      // Auto animation
      const autoSpeed = 0.002 + chaos * 0.00005;
      targetCReal += Math.sin(time * 0.7) * autoSpeed;
      targetCImag += Math.cos(time * 0.5) * autoSpeed;

      // Rotation
      rotation += 0.003 + chaos * 0.0001;

      // Decay chaos
      chaos = Math.max(10, chaos - 0.1);
      chaosMeterEl.style.width = chaos + '%';

      // Hue drift
      if (!rainbowMode) {
        hueShift += 0.2;
      }

      renderFractal();
      requestAnimationFrame(animate);
    }

    // Random emote trigger
    setInterval(() => {
      if (Math.random() < 0.1) {
        const randomEmote = emotes[Math.floor(Math.random() * emotes.length)];
        const btn = emoteGrid.children[emotes.indexOf(randomEmote)];
        // Just add visual chaos without button animation
        targetCReal += (Math.random() - 0.5) * 0.02;
        targetCImag += (Math.random() - 0.5) * 0.02;
      }
    }, 3000);

    animate();
  </script>
</body>
</html>
