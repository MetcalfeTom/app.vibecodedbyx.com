<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Mesh Curvature Analyzer</title>
  <link rel="icon" href="https://emojicdn.elk.sh/üìê">
  <meta property="og:title" content="Mesh Curvature Analyzer">
  <meta property="og:description" content="Visualize Gaussian curvature and geodesic distances on 3D meshes">
  <meta property="og:url" content="https://sloppy.live/mesh-curvature">
  <meta property="og:image" content="https://emojicdn.elk.sh/üìê?style=apple&size=512">
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link href="https://fonts.googleapis.com/css2?family=IBM+Plex+Mono:wght@400;600&family=Space+Grotesk:wght@500;700&display=swap" rel="stylesheet">
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }

    body {
      min-height: 100vh;
      background: #0d0d12;
      font-family: 'IBM Plex Mono', monospace;
      color: #c8c8d0;
      overflow: hidden;
    }

    .header {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      padding: 0.8rem 1.2rem;
      background: linear-gradient(to bottom, rgba(13, 13, 18, 0.98), rgba(13, 13, 18, 0.85));
      display: flex;
      justify-content: space-between;
      align-items: center;
      flex-wrap: wrap;
      gap: 0.8rem;
      z-index: 100;
      border-bottom: 1px solid #2a2a35;
    }

    h1 {
      font-family: 'Space Grotesk', sans-serif;
      font-size: 1rem;
      font-weight: 700;
      color: #fff;
      display: flex;
      align-items: center;
      gap: 0.5rem;
    }

    h1 span { color: #00d4aa; }

    .controls {
      display: flex;
      gap: 0.5rem;
      flex-wrap: wrap;
      align-items: center;
    }

    .control-group {
      display: flex;
      align-items: center;
      gap: 0.3rem;
      background: rgba(255, 255, 255, 0.03);
      padding: 0.3rem 0.5rem;
      border-radius: 4px;
      border: 1px solid #2a2a35;
    }

    .control-group label {
      font-size: 0.6rem;
      color: #666;
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }

    select, button {
      font-family: 'IBM Plex Mono', monospace;
      font-size: 0.7rem;
      padding: 0.35rem 0.6rem;
      background: #1a1a22;
      border: 1px solid #3a3a45;
      color: #c8c8d0;
      border-radius: 3px;
      cursor: pointer;
      transition: all 0.15s;
    }

    select:hover, button:hover {
      background: #252530;
      border-color: #00d4aa;
    }

    button.active {
      background: #00d4aa;
      color: #0d0d12;
      border-color: #00d4aa;
    }

    .stats {
      position: fixed;
      top: 4rem;
      left: 1rem;
      background: rgba(13, 13, 18, 0.9);
      padding: 0.8rem;
      border-radius: 4px;
      border: 1px solid #2a2a35;
      font-size: 0.65rem;
      z-index: 100;
      min-width: 180px;
    }

    .stats h3 {
      font-family: 'Space Grotesk', sans-serif;
      font-size: 0.7rem;
      color: #00d4aa;
      margin-bottom: 0.5rem;
    }

    .stat-row {
      display: flex;
      justify-content: space-between;
      margin-bottom: 0.3rem;
    }

    .stat-label { color: #666; }
    .stat-value { color: #fff; }
    .stat-positive { color: #00d4aa; }
    .stat-negative { color: #ff6b6b; }

    .lut-preview {
      position: fixed;
      bottom: 3rem;
      left: 50%;
      transform: translateX(-50%);
      display: flex;
      flex-direction: column;
      align-items: center;
      z-index: 100;
    }

    .lut-bar {
      width: 300px;
      height: 20px;
      border-radius: 3px;
      border: 1px solid #3a3a45;
    }

    .lut-labels {
      display: flex;
      justify-content: space-between;
      width: 300px;
      font-size: 0.55rem;
      color: #666;
      margin-top: 0.3rem;
    }

    .lut-title {
      font-size: 0.6rem;
      color: #888;
      margin-bottom: 0.3rem;
    }

    .click-hint {
      position: fixed;
      top: 4rem;
      right: 1rem;
      background: rgba(13, 13, 18, 0.9);
      padding: 0.6rem 0.8rem;
      border-radius: 4px;
      border: 1px solid #2a2a35;
      font-size: 0.6rem;
      color: #666;
      z-index: 100;
    }

    .click-hint strong { color: #00d4aa; }

    .info {
      position: fixed;
      bottom: 0.8rem;
      left: 50%;
      transform: translateX(-50%);
      font-size: 0.55rem;
      color: #444;
    }

    .info a { color: #555; text-decoration: none; }

    canvas { display: block; cursor: grab; }
    canvas:active { cursor: grabbing; }
  </style>
</head>
<body>
  <div class="header">
    <h1>üìê Mesh <span>Curvature</span> Analyzer</h1>
    <div class="controls">
      <div class="control-group">
        <label>Mesh:</label>
        <select id="meshSelect">
          <option value="sphere">Sphere</option>
          <option value="torus">Torus</option>
          <option value="saddle">Saddle</option>
          <option value="bumpy">Bumpy Sphere</option>
          <option value="klein">Klein Bottle</option>
        </select>
      </div>
      <div class="control-group">
        <label>Mode:</label>
        <button id="gaussianBtn" class="active">Gaussian K</button>
        <button id="geodesicBtn">Geodesic</button>
      </div>
      <div class="control-group">
        <label>LUT:</label>
        <select id="lutSelect">
          <option value="viridis">Viridis</option>
          <option value="plasma">Plasma</option>
          <option value="coolwarm">Coolwarm</option>
          <option value="spectral">Spectral</option>
          <option value="turbo">Turbo</option>
        </select>
      </div>
      <div class="control-group">
        <label>Res:</label>
        <select id="resSelect">
          <option value="32">32</option>
          <option value="48" selected>48</option>
          <option value="64">64</option>
        </select>
      </div>
    </div>
  </div>

  <div class="stats">
    <h3>Curvature Stats</h3>
    <div class="stat-row">
      <span class="stat-label">Vertices:</span>
      <span class="stat-value" id="vertCount">0</span>
    </div>
    <div class="stat-row">
      <span class="stat-label">K min:</span>
      <span class="stat-value stat-negative" id="kMin">0</span>
    </div>
    <div class="stat-row">
      <span class="stat-label">K max:</span>
      <span class="stat-value stat-positive" id="kMax">0</span>
    </div>
    <div class="stat-row">
      <span class="stat-label">K mean:</span>
      <span class="stat-value" id="kMean">0</span>
    </div>
    <div class="stat-row">
      <span class="stat-label">‚à´K dA:</span>
      <span class="stat-value" id="kTotal">0</span>
    </div>
  </div>

  <div class="click-hint">
    <strong>Click vertex</strong> for geodesic source<br>
    Drag to rotate ‚Ä¢ Scroll to zoom
  </div>

  <div class="lut-preview">
    <div class="lut-title">Color Map: <span id="lutName">Viridis</span></div>
    <canvas id="lutBar" class="lut-bar" width="300" height="20"></canvas>
    <div class="lut-labels">
      <span id="lutMin">-1.0</span>
      <span id="lutMid">0.0</span>
      <span id="lutMax">1.0</span>
    </div>
  </div>

  <div class="info">
    Jack's geometric madness ‚Ä¢ <a href="https://sloppy.live">sloppy.live</a>
  </div>

  <script type="importmap">
    {
      "imports": {
        "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
        "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
      }
    }
  </script>

  <script type="module">
    import * as THREE from 'three';
    import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

    // LUT definitions
    const LUTs = {
      viridis: [
        [0.267, 0.004, 0.329], [0.282, 0.140, 0.458], [0.253, 0.265, 0.530],
        [0.206, 0.372, 0.553], [0.163, 0.471, 0.558], [0.127, 0.566, 0.550],
        [0.134, 0.658, 0.517], [0.267, 0.749, 0.440], [0.478, 0.821, 0.318],
        [0.741, 0.873, 0.150], [0.993, 0.906, 0.144]
      ],
      plasma: [
        [0.050, 0.030, 0.528], [0.294, 0.012, 0.615], [0.492, 0.012, 0.658],
        [0.658, 0.138, 0.618], [0.797, 0.280, 0.470], [0.898, 0.397, 0.318],
        [0.957, 0.514, 0.185], [0.976, 0.640, 0.086], [0.950, 0.774, 0.087],
        [0.883, 0.910, 0.208], [0.940, 0.975, 0.131]
      ],
      coolwarm: [
        [0.230, 0.299, 0.754], [0.371, 0.450, 0.850], [0.529, 0.600, 0.920],
        [0.680, 0.740, 0.960], [0.830, 0.870, 0.970], [0.950, 0.950, 0.950],
        [0.970, 0.850, 0.820], [0.960, 0.720, 0.660], [0.920, 0.570, 0.500],
        [0.850, 0.400, 0.350], [0.750, 0.230, 0.230]
      ],
      spectral: [
        [0.620, 0.004, 0.259], [0.835, 0.243, 0.310], [0.957, 0.427, 0.263],
        [0.992, 0.682, 0.380], [0.996, 0.878, 0.545], [1.000, 1.000, 0.749],
        [0.902, 0.961, 0.596], [0.671, 0.867, 0.643], [0.400, 0.761, 0.647],
        [0.196, 0.533, 0.741], [0.369, 0.310, 0.635]
      ],
      turbo: [
        [0.190, 0.072, 0.232], [0.254, 0.265, 0.530], [0.137, 0.513, 0.729],
        [0.117, 0.710, 0.688], [0.290, 0.852, 0.497], [0.565, 0.931, 0.290],
        [0.815, 0.940, 0.173], [0.974, 0.852, 0.152], [0.995, 0.653, 0.153],
        [0.940, 0.413, 0.137], [0.795, 0.178, 0.129]
      ]
    };

    let currentLUT = 'viridis';
    let mode = 'gaussian'; // 'gaussian' or 'geodesic'
    let geodesicSource = null;

    // Scene setup
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x0d0d12);

    const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.set(3, 2, 3);

    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    document.body.appendChild(renderer.domElement);

    const controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;
    controls.dampingFactor = 0.05;

    // Lights
    const ambientLight = new THREE.AmbientLight(0xffffff, 0.4);
    scene.add(ambientLight);

    const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
    dirLight.position.set(5, 5, 5);
    scene.add(dirLight);

    // Mesh data
    let mesh = null;
    let wireframe = null;
    let vertices = [];
    let faces = [];
    let neighbors = [];
    let curvatures = [];
    let geodesicDists = [];

    // Sample LUT color
    function sampleLUT(t, lutName = currentLUT) {
      const lut = LUTs[lutName];
      t = Math.max(0, Math.min(1, t));
      const idx = t * (lut.length - 1);
      const i = Math.floor(idx);
      const f = idx - i;

      if (i >= lut.length - 1) return lut[lut.length - 1];

      return [
        lut[i][0] + f * (lut[i + 1][0] - lut[i][0]),
        lut[i][1] + f * (lut[i + 1][1] - lut[i][1]),
        lut[i][2] + f * (lut[i + 1][2] - lut[i][2])
      ];
    }

    // Draw LUT bar
    function drawLUTBar() {
      const canvas = document.getElementById('lutBar');
      const ctx = canvas.getContext('2d');

      for (let x = 0; x < 300; x++) {
        const t = x / 299;
        const [r, g, b] = sampleLUT(t);
        ctx.fillStyle = `rgb(${r * 255}, ${g * 255}, ${b * 255})`;
        ctx.fillRect(x, 0, 1, 20);
      }

      document.getElementById('lutName').textContent = currentLUT.charAt(0).toUpperCase() + currentLUT.slice(1);
    }

    // Generate mesh geometries
    function generateSphere(res) {
      const geo = new THREE.SphereGeometry(1, res, res);
      return geo;
    }

    function generateTorus(res) {
      const geo = new THREE.TorusGeometry(1, 0.4, res, res);
      return geo;
    }

    function generateSaddle(res) {
      const geo = new THREE.PlaneGeometry(2, 2, res, res);
      const pos = geo.attributes.position;

      for (let i = 0; i < pos.count; i++) {
        const x = pos.getX(i);
        const y = pos.getY(i);
        pos.setZ(i, x * x - y * y);
      }

      geo.computeVertexNormals();
      return geo;
    }

    function generateBumpy(res) {
      const geo = new THREE.SphereGeometry(1, res, res);
      const pos = geo.attributes.position;

      for (let i = 0; i < pos.count; i++) {
        const x = pos.getX(i);
        const y = pos.getY(i);
        const z = pos.getZ(i);

        const bump = 0.15 * Math.sin(8 * x) * Math.sin(8 * y) * Math.sin(8 * z);
        const len = Math.sqrt(x * x + y * y + z * z);
        const scale = (1 + bump) / len;

        pos.setX(i, x * scale);
        pos.setY(i, y * scale);
        pos.setZ(i, z * scale);
      }

      geo.computeVertexNormals();
      return geo;
    }

    function generateKlein(res) {
      const geo = new THREE.BufferGeometry();
      const positions = [];
      const indices = [];

      for (let i = 0; i <= res; i++) {
        for (let j = 0; j <= res; j++) {
          const u = (i / res) * Math.PI * 2;
          const v = (j / res) * Math.PI * 2;

          let x, y, z;

          if (u < Math.PI) {
            x = 3 * Math.cos(u) * (1 + Math.sin(u)) + 2 * (1 - Math.cos(u) / 2) * Math.cos(u) * Math.cos(v);
            z = -8 * Math.sin(u) - 2 * (1 - Math.cos(u) / 2) * Math.sin(u) * Math.cos(v);
          } else {
            x = 3 * Math.cos(u) * (1 + Math.sin(u)) + 2 * (1 - Math.cos(u) / 2) * Math.cos(v + Math.PI);
            z = -8 * Math.sin(u);
          }
          y = -2 * (1 - Math.cos(u) / 2) * Math.sin(v);

          positions.push(x * 0.15, y * 0.15, z * 0.15);
        }
      }

      for (let i = 0; i < res; i++) {
        for (let j = 0; j < res; j++) {
          const a = i * (res + 1) + j;
          const b = a + 1;
          const c = a + res + 1;
          const d = c + 1;

          indices.push(a, b, c);
          indices.push(b, d, c);
        }
      }

      geo.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
      geo.setIndex(indices);
      geo.computeVertexNormals();

      return geo;
    }

    // Extract mesh data
    function extractMeshData(geometry) {
      const pos = geometry.attributes.position;
      const index = geometry.index;

      vertices = [];
      faces = [];
      neighbors = [];

      // Get unique vertices (merge duplicates)
      const vertexMap = new Map();
      const epsilon = 0.0001;

      function getVertexKey(x, y, z) {
        return `${Math.round(x / epsilon)},${Math.round(y / epsilon)},${Math.round(z / epsilon)}`;
      }

      const indexMap = []; // Maps original index to merged index

      for (let i = 0; i < pos.count; i++) {
        const x = pos.getX(i);
        const y = pos.getY(i);
        const z = pos.getZ(i);
        const key = getVertexKey(x, y, z);

        if (!vertexMap.has(key)) {
          vertexMap.set(key, vertices.length);
          vertices.push(new THREE.Vector3(x, y, z));
          neighbors.push(new Set());
        }
        indexMap[i] = vertexMap.get(key);
      }

      // Extract faces
      if (index) {
        for (let i = 0; i < index.count; i += 3) {
          const a = indexMap[index.getX(i)];
          const b = indexMap[index.getX(i + 1)];
          const c = indexMap[index.getX(i + 2)];

          if (a !== b && b !== c && a !== c) {
            faces.push([a, b, c]);
            neighbors[a].add(b); neighbors[a].add(c);
            neighbors[b].add(a); neighbors[b].add(c);
            neighbors[c].add(a); neighbors[c].add(b);
          }
        }
      }
    }

    // Calculate Gaussian curvature using angle deficit
    function calculateGaussianCurvature() {
      curvatures = new Array(vertices.length).fill(0);
      const areas = new Array(vertices.length).fill(0);

      for (const face of faces) {
        const [i, j, k] = face;
        const p0 = vertices[i];
        const p1 = vertices[j];
        const p2 = vertices[k];

        // Calculate face area
        const v1 = new THREE.Vector3().subVectors(p1, p0);
        const v2 = new THREE.Vector3().subVectors(p2, p0);
        const faceArea = v1.cross(v2).length() / 2;
        const vertexArea = faceArea / 3;

        // Calculate angles at each vertex
        const angles = [];
        const pts = [p0, p1, p2];

        for (let n = 0; n < 3; n++) {
          const curr = pts[n];
          const prev = pts[(n + 2) % 3];
          const next = pts[(n + 1) % 3];

          const e1 = new THREE.Vector3().subVectors(prev, curr).normalize();
          const e2 = new THREE.Vector3().subVectors(next, curr).normalize();

          angles.push(Math.acos(Math.max(-1, Math.min(1, e1.dot(e2)))));
        }

        curvatures[i] += angles[0];
        curvatures[j] += angles[1];
        curvatures[k] += angles[2];

        areas[i] += vertexArea;
        areas[j] += vertexArea;
        areas[k] += vertexArea;
      }

      // Convert angle sum to Gaussian curvature
      for (let i = 0; i < vertices.length; i++) {
        if (areas[i] > 0.0001) {
          curvatures[i] = (2 * Math.PI - curvatures[i]) / areas[i];
        } else {
          curvatures[i] = 0;
        }
      }

      updateStats();
    }

    // Calculate geodesic distances using Dijkstra
    function calculateGeodesicDistances(sourceIdx) {
      geodesicDists = new Array(vertices.length).fill(Infinity);
      geodesicDists[sourceIdx] = 0;

      const visited = new Set();
      const pq = [[0, sourceIdx]]; // [distance, vertex]

      while (pq.length > 0) {
        // Find minimum
        pq.sort((a, b) => a[0] - b[0]);
        const [dist, u] = pq.shift();

        if (visited.has(u)) continue;
        visited.add(u);

        for (const v of neighbors[u]) {
          const edgeDist = vertices[u].distanceTo(vertices[v]);
          const newDist = dist + edgeDist;

          if (newDist < geodesicDists[v]) {
            geodesicDists[v] = newDist;
            pq.push([newDist, v]);
          }
        }
      }
    }

    // Update mesh colors
    function updateMeshColors() {
      if (!mesh) return;

      const geometry = mesh.geometry;
      const pos = geometry.attributes.position;
      const colors = new Float32Array(pos.count * 3);

      let values, minVal, maxVal;

      if (mode === 'gaussian') {
        values = curvatures;
        // Symmetric range for curvature
        const absMax = Math.max(
          Math.abs(Math.min(...curvatures)),
          Math.abs(Math.max(...curvatures))
        );
        minVal = -absMax;
        maxVal = absMax;

        document.getElementById('lutMin').textContent = minVal.toFixed(2);
        document.getElementById('lutMid').textContent = '0.00';
        document.getElementById('lutMax').textContent = maxVal.toFixed(2);
      } else {
        values = geodesicDists;
        minVal = 0;
        maxVal = Math.max(...geodesicDists.filter(d => d < Infinity));

        document.getElementById('lutMin').textContent = '0.00';
        document.getElementById('lutMid').textContent = (maxVal / 2).toFixed(2);
        document.getElementById('lutMax').textContent = maxVal.toFixed(2);
      }

      const range = maxVal - minVal || 1;

      // Get index mapping
      const index = geometry.index;
      const epsilon = 0.0001;

      for (let i = 0; i < pos.count; i++) {
        const x = pos.getX(i);
        const y = pos.getY(i);
        const z = pos.getZ(i);

        // Find matching vertex
        let vertIdx = 0;
        let minDist = Infinity;
        for (let j = 0; j < vertices.length; j++) {
          const d = vertices[j].distanceToSquared(new THREE.Vector3(x, y, z));
          if (d < minDist) {
            minDist = d;
            vertIdx = j;
          }
        }

        let val = values[vertIdx];
        if (!isFinite(val)) val = maxVal;

        const t = (val - minVal) / range;
        const [r, g, b] = sampleLUT(t);

        colors[i * 3] = r;
        colors[i * 3 + 1] = g;
        colors[i * 3 + 2] = b;
      }

      geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
      mesh.material.vertexColors = true;
      mesh.material.needsUpdate = true;
    }

    // Update stats display
    function updateStats() {
      document.getElementById('vertCount').textContent = vertices.length;

      const validK = curvatures.filter(k => isFinite(k));
      const kMin = Math.min(...validK);
      const kMax = Math.max(...validK);
      const kMean = validK.reduce((a, b) => a + b, 0) / validK.length;

      // Gauss-Bonnet: ‚à´K dA = 2œÄœá
      let totalK = 0;
      for (const face of faces) {
        const [i, j, k] = face;
        const p0 = vertices[i];
        const p1 = vertices[j];
        const p2 = vertices[k];
        const v1 = new THREE.Vector3().subVectors(p1, p0);
        const v2 = new THREE.Vector3().subVectors(p2, p0);
        const area = v1.cross(v2).length() / 2;
        totalK += (curvatures[i] + curvatures[j] + curvatures[k]) / 3 * area;
      }

      document.getElementById('kMin').textContent = kMin.toFixed(3);
      document.getElementById('kMax').textContent = kMax.toFixed(3);
      document.getElementById('kMean').textContent = kMean.toFixed(3);
      document.getElementById('kTotal').textContent = (totalK / Math.PI).toFixed(2) + 'œÄ';
    }

    // Create mesh
    function createMesh(type) {
      if (mesh) {
        scene.remove(mesh);
        scene.remove(wireframe);
      }

      const res = parseInt(document.getElementById('resSelect').value);
      let geometry;

      switch (type) {
        case 'sphere': geometry = generateSphere(res); break;
        case 'torus': geometry = generateTorus(res); break;
        case 'saddle': geometry = generateSaddle(res); break;
        case 'bumpy': geometry = generateBumpy(res); break;
        case 'klein': geometry = generateKlein(res); break;
        default: geometry = generateSphere(res);
      }

      extractMeshData(geometry);
      calculateGaussianCurvature();

      // Set initial geodesic source
      geodesicSource = 0;
      calculateGeodesicDistances(geodesicSource);

      const material = new THREE.MeshPhongMaterial({
        vertexColors: true,
        side: THREE.DoubleSide,
        shininess: 30
      });

      mesh = new THREE.Mesh(geometry, material);
      scene.add(mesh);

      // Add wireframe
      const wireMat = new THREE.LineBasicMaterial({ color: 0x000000, opacity: 0.15, transparent: true });
      const wireGeo = new THREE.WireframeGeometry(geometry);
      wireframe = new THREE.LineSegments(wireGeo, wireMat);
      scene.add(wireframe);

      updateMeshColors();
    }

    // Raycasting for vertex selection
    const raycaster = new THREE.Raycaster();
    const mouse = new THREE.Vector2();

    renderer.domElement.addEventListener('click', (event) => {
      if (mode !== 'geodesic') return;

      mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
      mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

      raycaster.setFromCamera(mouse, camera);

      if (mesh) {
        const intersects = raycaster.intersectObject(mesh);

        if (intersects.length > 0) {
          const point = intersects[0].point;

          // Find nearest vertex
          let nearestIdx = 0;
          let minDist = Infinity;

          for (let i = 0; i < vertices.length; i++) {
            const d = vertices[i].distanceToSquared(point);
            if (d < minDist) {
              minDist = d;
              nearestIdx = i;
            }
          }

          geodesicSource = nearestIdx;
          calculateGeodesicDistances(geodesicSource);
          updateMeshColors();
        }
      }
    });

    // Event listeners
    document.getElementById('meshSelect').addEventListener('change', (e) => {
      createMesh(e.target.value);
    });

    document.getElementById('lutSelect').addEventListener('change', (e) => {
      currentLUT = e.target.value;
      drawLUTBar();
      updateMeshColors();
    });

    document.getElementById('resSelect').addEventListener('change', () => {
      createMesh(document.getElementById('meshSelect').value);
    });

    document.getElementById('gaussianBtn').addEventListener('click', function() {
      mode = 'gaussian';
      this.classList.add('active');
      document.getElementById('geodesicBtn').classList.remove('active');
      updateMeshColors();
    });

    document.getElementById('geodesicBtn').addEventListener('click', function() {
      mode = 'geodesic';
      this.classList.add('active');
      document.getElementById('gaussianBtn').classList.remove('active');
      updateMeshColors();
    });

    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });

    // Animation loop
    function animate() {
      requestAnimationFrame(animate);
      controls.update();
      renderer.render(scene, camera);
    }

    // Initialize
    drawLUTBar();
    createMesh('sphere');
    animate();
  </script>
</body>
</html>
