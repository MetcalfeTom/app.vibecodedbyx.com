<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Gravity Vortex - Neon Physics Game</title>
  <link rel="icon" href="https://emojicdn.elk.sh/ðŸŒ€">
  <meta name="description" content="Launch glowing orbs into black holes in this neon physics game.">
  <meta property="og:title" content="Gravity Vortex - Neon Physics Game">
  <meta property="og:description" content="Launch glowing orbs into black holes in this neon physics game.">
  <meta property="og:url" content="https://app.sloppy.live/gravity-vortex">
  <meta property="og:image" content="https://emojicdn.elk.sh/ðŸŒ€?style=twitter">
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&display=swap" rel="stylesheet">
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      background: #000;
      overflow: hidden;
      font-family: 'Orbitron', sans-serif;
      cursor: crosshair;
    }

    canvas {
      display: block;
    }

    .ui {
      position: fixed;
      top: 20px;
      left: 20px;
      z-index: 10;
      color: #0ff;
      text-shadow: 0 0 10px #0ff, 0 0 20px #0ff;
    }

    .score {
      font-size: 32px;
      font-weight: 900;
      letter-spacing: 3px;
    }

    .orbs-left {
      font-size: 14px;
      margin-top: 8px;
      color: #f0f;
      text-shadow: 0 0 10px #f0f;
    }

    .combo {
      font-size: 18px;
      margin-top: 5px;
      color: #ff0;
      text-shadow: 0 0 10px #ff0;
      opacity: 0;
      transition: opacity 0.3s;
    }

    .combo.visible {
      opacity: 1;
    }

    .instructions {
      position: fixed;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      color: #666;
      font-size: 12px;
      text-align: center;
      transition: opacity 0.5s;
    }

    .instructions.hidden {
      opacity: 0;
    }

    .game-over {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      text-align: center;
      color: #fff;
      z-index: 100;
      display: none;
    }

    .game-over.visible {
      display: block;
    }

    .game-over h1 {
      font-size: 48px;
      color: #f0f;
      text-shadow: 0 0 20px #f0f, 0 0 40px #f0f;
      margin-bottom: 20px;
    }

    .game-over .final-score {
      font-size: 24px;
      color: #0ff;
      text-shadow: 0 0 15px #0ff;
      margin-bottom: 30px;
    }

    .restart-btn {
      padding: 15px 40px;
      font-family: 'Orbitron', sans-serif;
      font-size: 18px;
      font-weight: 700;
      background: transparent;
      border: 2px solid #0ff;
      color: #0ff;
      cursor: pointer;
      text-shadow: 0 0 10px #0ff;
      box-shadow: 0 0 20px #0ff33, inset 0 0 20px #0ff22;
      transition: all 0.3s;
    }

    .restart-btn:hover {
      background: #0ff22;
      box-shadow: 0 0 30px #0ff, inset 0 0 30px #0ff44;
    }

    .level-up {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      font-size: 64px;
      font-weight: 900;
      color: #0f0;
      text-shadow: 0 0 30px #0f0, 0 0 60px #0f0;
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.5s;
    }

    .level-up.visible {
      opacity: 1;
    }

    .backlink {
      position: fixed;
      bottom: 10px;
      right: 15px;
      color: #333;
      font-size: 11px;
      text-decoration: none;
      z-index: 10;
    }

    .backlink:hover {
      color: #0ff;
    }
  </style>
</head>
<body>
  <div class="ui">
    <div class="score">0</div>
    <div class="orbs-left">ORBS: 10</div>
    <div class="combo">COMBO x2!</div>
  </div>

  <div class="instructions">Click and drag to launch orbs into black holes</div>

  <div class="game-over">
    <h1>GAME OVER</h1>
    <div class="final-score">SCORE: 0</div>
    <button class="restart-btn">PLAY AGAIN</button>
  </div>

  <div class="level-up">LEVEL UP!</div>

  <canvas id="canvas"></canvas>
  <a href="https://sloppy.live" class="backlink">sloppy.live</a>

  <script>
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');

    // Resize canvas
    function resize() {
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
    }
    resize();
    window.addEventListener('resize', resize);

    // Game state
    let score = 0;
    let orbsLeft = 10;
    let combo = 0;
    let comboTimer = null;
    let level = 1;
    let gameOver = false;
    let hasInteracted = false;

    // Physics constants
    const G = 800; // Gravitational constant
    const ORB_RADIUS = 8;
    const TRAIL_LENGTH = 20;

    // Colors
    const orbColors = ['#0ff', '#f0f', '#ff0', '#0f0', '#f70', '#70f'];

    // Game objects
    let orbs = [];
    let blackHoles = [];
    let particles = [];

    // Aiming state
    let isAiming = false;
    let aimStart = { x: 0, y: 0 };
    let aimEnd = { x: 0, y: 0 };

    // Initialize black holes
    function initBlackHoles() {
      blackHoles = [];
      const count = Math.min(2 + Math.floor(level / 2), 5);

      for (let i = 0; i < count; i++) {
        const margin = 150;
        blackHoles.push({
          x: margin + Math.random() * (canvas.width - margin * 2),
          y: margin + Math.random() * (canvas.height - margin * 2),
          radius: 30 + Math.random() * 20,
          mass: 500 + Math.random() * 500 + level * 100,
          rotation: Math.random() * Math.PI * 2,
          points: 100 * (i + 1)
        });
      }
    }

    // Create orb
    function createOrb(x, y, vx, vy) {
      return {
        x, y, vx, vy,
        radius: ORB_RADIUS,
        color: orbColors[Math.floor(Math.random() * orbColors.length)],
        trail: [],
        alive: true,
        age: 0
      };
    }

    // Create particle explosion
    function createExplosion(x, y, color, count = 20) {
      for (let i = 0; i < count; i++) {
        const angle = (Math.PI * 2 * i) / count + Math.random() * 0.5;
        const speed = 2 + Math.random() * 4;
        particles.push({
          x, y,
          vx: Math.cos(angle) * speed,
          vy: Math.sin(angle) * speed,
          radius: 2 + Math.random() * 3,
          color,
          life: 1,
          decay: 0.02 + Math.random() * 0.02
        });
      }
    }

    // Update physics
    function update(dt) {
      if (gameOver) return;

      // Update orbs
      orbs.forEach(orb => {
        if (!orb.alive) return;

        // Apply gravity from each black hole
        blackHoles.forEach(bh => {
          const dx = bh.x - orb.x;
          const dy = bh.y - orb.y;
          const dist = Math.sqrt(dx * dx + dy * dy);

          // Check if captured
          if (dist < bh.radius) {
            orb.alive = false;
            createExplosion(orb.x, orb.y, orb.color, 30);
            addScore(bh.points);
            return;
          }

          // Apply gravitational force
          const force = (G * bh.mass) / (dist * dist);
          const ax = (dx / dist) * force;
          const ay = (dy / dist) * force;

          orb.vx += ax * dt;
          orb.vy += ay * dt;
        });

        // Update position
        orb.x += orb.vx * dt;
        orb.y += orb.vy * dt;

        // Update trail
        orb.trail.unshift({ x: orb.x, y: orb.y });
        if (orb.trail.length > TRAIL_LENGTH) {
          orb.trail.pop();
        }

        // Check bounds
        orb.age++;
        if (orb.age > 60 && (orb.x < -50 || orb.x > canvas.width + 50 ||
            orb.y < -50 || orb.y > canvas.height + 50)) {
          orb.alive = false;
          resetCombo();
        }
      });

      // Remove dead orbs
      orbs = orbs.filter(o => o.alive);

      // Update particles
      particles.forEach(p => {
        p.x += p.vx;
        p.y += p.vy;
        p.life -= p.decay;
        p.vx *= 0.98;
        p.vy *= 0.98;
      });
      particles = particles.filter(p => p.life > 0);

      // Rotate black holes
      blackHoles.forEach(bh => {
        bh.rotation += 0.02;
      });

      // Check game over
      if (orbsLeft <= 0 && orbs.length === 0) {
        endGame();
      }
    }

    // Add score with combo
    function addScore(points) {
      combo++;
      const multiplier = Math.min(combo, 5);
      score += points * multiplier;

      updateUI();

      // Show combo
      if (combo > 1) {
        const comboEl = document.querySelector('.combo');
        comboEl.textContent = `COMBO x${multiplier}!`;
        comboEl.classList.add('visible');
      }

      // Reset combo timer
      clearTimeout(comboTimer);
      comboTimer = setTimeout(resetCombo, 2000);

      // Level up check
      if (score >= level * 1000) {
        levelUp();
      }
    }

    function resetCombo() {
      combo = 0;
      document.querySelector('.combo').classList.remove('visible');
    }

    function levelUp() {
      level++;
      orbsLeft += 5;

      const levelEl = document.querySelector('.level-up');
      levelEl.textContent = `LEVEL ${level}!`;
      levelEl.classList.add('visible');

      setTimeout(() => {
        levelEl.classList.remove('visible');
        initBlackHoles();
      }, 1500);

      updateUI();
    }

    function endGame() {
      gameOver = true;
      document.querySelector('.final-score').textContent = `SCORE: ${score}`;
      document.querySelector('.game-over').classList.add('visible');
    }

    function restartGame() {
      score = 0;
      orbsLeft = 10;
      combo = 0;
      level = 1;
      gameOver = false;
      orbs = [];
      particles = [];

      document.querySelector('.game-over').classList.remove('visible');
      initBlackHoles();
      updateUI();
    }

    function updateUI() {
      document.querySelector('.score').textContent = score;
      document.querySelector('.orbs-left').textContent = `ORBS: ${orbsLeft}`;
    }

    // Draw functions
    function drawBlackHole(bh) {
      // Outer glow
      const gradient = ctx.createRadialGradient(bh.x, bh.y, 0, bh.x, bh.y, bh.radius * 3);
      gradient.addColorStop(0, 'rgba(128, 0, 255, 0.3)');
      gradient.addColorStop(0.5, 'rgba(64, 0, 128, 0.1)');
      gradient.addColorStop(1, 'transparent');

      ctx.fillStyle = gradient;
      ctx.beginPath();
      ctx.arc(bh.x, bh.y, bh.radius * 3, 0, Math.PI * 2);
      ctx.fill();

      // Accretion disk
      ctx.save();
      ctx.translate(bh.x, bh.y);
      ctx.rotate(bh.rotation);

      for (let i = 0; i < 3; i++) {
        ctx.strokeStyle = `hsla(${280 + i * 20}, 100%, 60%, ${0.5 - i * 0.15})`;
        ctx.lineWidth = 3 - i;
        ctx.beginPath();
        ctx.ellipse(0, 0, bh.radius * (1.5 + i * 0.3), bh.radius * (0.4 + i * 0.1), 0, 0, Math.PI * 2);
        ctx.stroke();
      }

      ctx.restore();

      // Event horizon
      const holeGradient = ctx.createRadialGradient(bh.x, bh.y, 0, bh.x, bh.y, bh.radius);
      holeGradient.addColorStop(0, '#000');
      holeGradient.addColorStop(0.7, '#000');
      holeGradient.addColorStop(1, 'rgba(128, 0, 255, 0.8)');

      ctx.fillStyle = holeGradient;
      ctx.beginPath();
      ctx.arc(bh.x, bh.y, bh.radius, 0, Math.PI * 2);
      ctx.fill();

      // Point value
      ctx.fillStyle = '#fff';
      ctx.font = '12px Orbitron';
      ctx.textAlign = 'center';
      ctx.fillText(`+${bh.points}`, bh.x, bh.y + bh.radius + 20);
    }

    function drawOrb(orb) {
      // Draw trail
      orb.trail.forEach((pos, i) => {
        const alpha = 1 - i / TRAIL_LENGTH;
        const radius = orb.radius * (1 - i / TRAIL_LENGTH * 0.5);

        ctx.fillStyle = orb.color + Math.floor(alpha * 99).toString(16).padStart(2, '0');
        ctx.beginPath();
        ctx.arc(pos.x, pos.y, radius, 0, Math.PI * 2);
        ctx.fill();
      });

      // Glow
      const glowGradient = ctx.createRadialGradient(orb.x, orb.y, 0, orb.x, orb.y, orb.radius * 3);
      glowGradient.addColorStop(0, orb.color + '88');
      glowGradient.addColorStop(1, 'transparent');

      ctx.fillStyle = glowGradient;
      ctx.beginPath();
      ctx.arc(orb.x, orb.y, orb.radius * 3, 0, Math.PI * 2);
      ctx.fill();

      // Core
      ctx.fillStyle = orb.color;
      ctx.shadowColor = orb.color;
      ctx.shadowBlur = 15;
      ctx.beginPath();
      ctx.arc(orb.x, orb.y, orb.radius, 0, Math.PI * 2);
      ctx.fill();
      ctx.shadowBlur = 0;

      // Inner highlight
      ctx.fillStyle = '#fff';
      ctx.beginPath();
      ctx.arc(orb.x - orb.radius * 0.3, orb.y - orb.radius * 0.3, orb.radius * 0.3, 0, Math.PI * 2);
      ctx.fill();
    }

    function drawParticle(p) {
      ctx.fillStyle = p.color + Math.floor(p.life * 255).toString(16).padStart(2, '0');
      ctx.beginPath();
      ctx.arc(p.x, p.y, p.radius * p.life, 0, Math.PI * 2);
      ctx.fill();
    }

    function drawAimLine() {
      if (!isAiming) return;

      const dx = aimStart.x - aimEnd.x;
      const dy = aimStart.y - aimEnd.y;
      const power = Math.min(Math.sqrt(dx * dx + dy * dy), 200);

      // Draw line
      ctx.strokeStyle = '#0ff44';
      ctx.lineWidth = 2;
      ctx.setLineDash([10, 10]);
      ctx.beginPath();
      ctx.moveTo(aimStart.x, aimStart.y);
      ctx.lineTo(aimStart.x + dx, aimStart.y + dy);
      ctx.stroke();
      ctx.setLineDash([]);

      // Draw power indicator
      ctx.fillStyle = '#0ff';
      ctx.font = '14px Orbitron';
      ctx.textAlign = 'center';
      ctx.fillText(`POWER: ${Math.floor(power / 2)}%`, aimStart.x, aimStart.y - 20);

      // Draw predicted trajectory
      if (power > 10) {
        const vx = dx * 3;
        const vy = dy * 3;
        let px = aimStart.x;
        let py = aimStart.y;
        let pvx = vx;
        let pvy = vy;

        ctx.strokeStyle = '#0ff22';
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.moveTo(px, py);

        for (let i = 0; i < 50; i++) {
          // Apply gravity
          blackHoles.forEach(bh => {
            const ddx = bh.x - px;
            const ddy = bh.y - py;
            const dist = Math.sqrt(ddx * ddx + ddy * ddy);
            if (dist > bh.radius) {
              const force = (G * bh.mass) / (dist * dist);
              pvx += (ddx / dist) * force * 0.016;
              pvy += (ddy / dist) * force * 0.016;
            }
          });

          px += pvx * 0.016;
          py += pvy * 0.016;
          ctx.lineTo(px, py);
        }
        ctx.stroke();
      }
    }

    function drawBackground() {
      // Gradient background
      const bgGradient = ctx.createRadialGradient(
        canvas.width / 2, canvas.height / 2, 0,
        canvas.width / 2, canvas.height / 2, canvas.width
      );
      bgGradient.addColorStop(0, '#0a0a15');
      bgGradient.addColorStop(1, '#000');
      ctx.fillStyle = bgGradient;
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      // Stars
      ctx.fillStyle = '#ffffff22';
      for (let i = 0; i < 100; i++) {
        const x = (i * 137.5) % canvas.width;
        const y = (i * 221.3) % canvas.height;
        const size = (i % 3) + 1;
        ctx.beginPath();
        ctx.arc(x, y, size * 0.5, 0, Math.PI * 2);
        ctx.fill();
      }

      // Grid lines
      ctx.strokeStyle = '#ffffff08';
      ctx.lineWidth = 1;
      const gridSize = 80;

      for (let x = 0; x < canvas.width; x += gridSize) {
        ctx.beginPath();
        ctx.moveTo(x, 0);
        ctx.lineTo(x, canvas.height);
        ctx.stroke();
      }

      for (let y = 0; y < canvas.height; y += gridSize) {
        ctx.beginPath();
        ctx.moveTo(0, y);
        ctx.lineTo(canvas.width, y);
        ctx.stroke();
      }
    }

    // Main draw function
    function draw() {
      drawBackground();

      blackHoles.forEach(drawBlackHole);
      particles.forEach(drawParticle);
      orbs.forEach(drawOrb);
      drawAimLine();
    }

    // Game loop
    let lastTime = 0;
    function gameLoop(time) {
      const dt = Math.min((time - lastTime) / 1000, 0.1);
      lastTime = time;

      update(dt);
      draw();

      requestAnimationFrame(gameLoop);
    }

    // Input handling
    canvas.addEventListener('mousedown', (e) => {
      if (gameOver || orbsLeft <= 0) return;
      isAiming = true;
      aimStart = { x: e.clientX, y: e.clientY };
      aimEnd = { x: e.clientX, y: e.clientY };

      if (!hasInteracted) {
        hasInteracted = true;
        document.querySelector('.instructions').classList.add('hidden');
      }
    });

    canvas.addEventListener('mousemove', (e) => {
      if (isAiming) {
        aimEnd = { x: e.clientX, y: e.clientY };
      }
    });

    canvas.addEventListener('mouseup', (e) => {
      if (!isAiming) return;
      isAiming = false;

      const dx = aimStart.x - aimEnd.x;
      const dy = aimStart.y - aimEnd.y;
      const power = Math.min(Math.sqrt(dx * dx + dy * dy), 200);

      if (power > 10) {
        const vx = dx * 3;
        const vy = dy * 3;
        orbs.push(createOrb(aimStart.x, aimStart.y, vx, vy));
        orbsLeft--;
        updateUI();
      }
    });

    // Touch support
    canvas.addEventListener('touchstart', (e) => {
      e.preventDefault();
      const touch = e.touches[0];
      if (gameOver || orbsLeft <= 0) return;
      isAiming = true;
      aimStart = { x: touch.clientX, y: touch.clientY };
      aimEnd = { x: touch.clientX, y: touch.clientY };

      if (!hasInteracted) {
        hasInteracted = true;
        document.querySelector('.instructions').classList.add('hidden');
      }
    });

    canvas.addEventListener('touchmove', (e) => {
      e.preventDefault();
      if (isAiming) {
        const touch = e.touches[0];
        aimEnd = { x: touch.clientX, y: touch.clientY };
      }
    });

    canvas.addEventListener('touchend', (e) => {
      e.preventDefault();
      if (!isAiming) return;
      isAiming = false;

      const dx = aimStart.x - aimEnd.x;
      const dy = aimStart.y - aimEnd.y;
      const power = Math.min(Math.sqrt(dx * dx + dy * dy), 200);

      if (power > 10) {
        const vx = dx * 3;
        const vy = dy * 3;
        orbs.push(createOrb(aimStart.x, aimStart.y, vx, vy));
        orbsLeft--;
        updateUI();
      }
    });

    // Restart button
    document.querySelector('.restart-btn').addEventListener('click', restartGame);

    // Initialize
    initBlackHoles();
    updateUI();
    requestAnimationFrame(gameLoop);
  </script>
<script src="/sloppy-header/sloppy-bar.js"></script>
<script src="/vibelib-extended.js"></script>
<script>
  // Compatibility Patch for Legacy Apps
  window.addEventListener("load", () => {
    if (window.SloppyKarma && window.VibeLib.Economy) {
      // Redirect old calls to new engine
      window.SloppyKarma.track = window.VibeLib.Economy.track;
    }
  });
</script>
</body>
</html>
