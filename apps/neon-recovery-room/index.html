<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Neon Recovery Room</title>
  <meta name="description" content="Relax with soothing ambient waves and healing particles">
  <meta property="og:title" content="Neon Recovery Room">
  <meta property="og:description" content="A calming space with ambient waves and floating healing particles">
  <meta property="og:url" content="https://app.sloppy.live/neon-recovery-room/">
  <meta property="og:image" content="https://app.sloppy.live/neon-recovery-room/og-image.png">
  <link rel="icon" href="https://emojicdn.elk.sh/ðŸŒŠ">
  <link href="https://fonts.googleapis.com/css2?family=Quicksand:wght@300;400;500&display=swap" rel="stylesheet">
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      background: linear-gradient(180deg, #0a0a1a 0%, #0f1a2a 50%, #0a1520 100%);
      min-height: 100vh;
      overflow: hidden;
      font-family: 'Quicksand', sans-serif;
      color: #fff;
    }

    #canvas {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
    }

    .ui-overlay {
      position: fixed;
      z-index: 100;
      pointer-events: none;
    }

    .header {
      top: 2rem;
      left: 50%;
      transform: translateX(-50%);
      text-align: center;
      opacity: 0.8;
      transition: opacity 0.5s;
    }

    .header.hidden {
      opacity: 0;
    }

    .header h1 {
      font-size: 1.8rem;
      font-weight: 300;
      letter-spacing: 0.3em;
      color: #7fdbff;
      text-shadow: 0 0 30px rgba(127, 219, 255, 0.5);
    }

    .header p {
      font-size: 0.9rem;
      color: #a0d0e0;
      margin-top: 0.5rem;
      font-weight: 300;
      letter-spacing: 0.1em;
    }

    .start-screen {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(10, 10, 26, 0.95);
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      z-index: 200;
      transition: opacity 1s;
    }

    .start-screen.hidden {
      opacity: 0;
      pointer-events: none;
    }

    .start-screen h1 {
      font-size: 2.5rem;
      font-weight: 300;
      letter-spacing: 0.3em;
      color: #7fdbff;
      text-shadow: 0 0 40px rgba(127, 219, 255, 0.6);
      margin-bottom: 1rem;
    }

    .start-screen p {
      color: #80a0b0;
      font-size: 1rem;
      margin-bottom: 2rem;
      font-weight: 300;
    }

    .start-btn {
      font-family: 'Quicksand', sans-serif;
      font-size: 1.1rem;
      font-weight: 400;
      padding: 1rem 3rem;
      background: transparent;
      border: 1px solid rgba(127, 219, 255, 0.4);
      border-radius: 50px;
      color: #7fdbff;
      cursor: pointer;
      transition: all 0.5s;
      letter-spacing: 0.2em;
    }

    .start-btn:hover {
      background: rgba(127, 219, 255, 0.1);
      border-color: rgba(127, 219, 255, 0.8);
      box-shadow: 0 0 30px rgba(127, 219, 255, 0.3);
    }

    .controls {
      bottom: 2rem;
      left: 50%;
      transform: translateX(-50%);
      display: flex;
      gap: 1rem;
      pointer-events: auto;
      opacity: 0.6;
      transition: opacity 0.3s;
    }

    .controls:hover {
      opacity: 1;
    }

    .ctrl-btn {
      font-family: 'Quicksand', sans-serif;
      font-size: 0.8rem;
      padding: 0.6rem 1.2rem;
      background: rgba(0, 0, 0, 0.3);
      border: 1px solid rgba(127, 219, 255, 0.3);
      border-radius: 20px;
      color: #7fdbff;
      cursor: pointer;
      transition: all 0.3s;
    }

    .ctrl-btn:hover {
      background: rgba(127, 219, 255, 0.1);
      border-color: rgba(127, 219, 255, 0.6);
    }

    .ctrl-btn.active {
      background: rgba(127, 219, 255, 0.2);
      border-color: #7fdbff;
    }

    .breath-guide {
      position: fixed;
      bottom: 6rem;
      left: 50%;
      transform: translateX(-50%);
      text-align: center;
      opacity: 0;
      transition: opacity 0.5s;
      z-index: 100;
    }

    .breath-guide.visible {
      opacity: 0.8;
    }

    .breath-circle {
      width: 80px;
      height: 80px;
      border: 2px solid rgba(100, 255, 200, 0.5);
      border-radius: 50%;
      margin: 0 auto 1rem;
      animation: breathe 8s ease-in-out infinite;
    }

    .breath-text {
      font-size: 1rem;
      color: #64ffc8;
      letter-spacing: 0.2em;
      animation: breatheText 8s ease-in-out infinite;
    }

    @keyframes breathe {
      0%, 100% { transform: scale(0.6); opacity: 0.4; }
      50% { transform: scale(1.2); opacity: 1; }
    }

    @keyframes breatheText {
      0%, 45% { content: 'INHALE'; }
      50%, 95% { content: 'EXHALE'; }
    }

    .affirmation {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      font-size: 1.5rem;
      font-weight: 300;
      color: rgba(180, 140, 255, 0.8);
      text-shadow: 0 0 30px rgba(180, 140, 255, 0.5);
      opacity: 0;
      transition: opacity 2s;
      text-align: center;
      max-width: 80%;
      letter-spacing: 0.1em;
      z-index: 50;
    }

    .affirmation.visible {
      opacity: 1;
    }

    .backlink {
      position: fixed;
      bottom: 0.5rem;
      right: 0.5rem;
      font-size: 0.7rem;
      z-index: 100;
      opacity: 0.4;
    }

    .backlink a {
      color: #7fdbff;
      text-decoration: none;
    }

    /* HIGH-VOLTAGE REVIVE SHOCK BUTTON */
    .shock-btn {
      position: fixed;
      top: 2rem;
      right: 2rem;
      width: 100px;
      height: 100px;
      border-radius: 50%;
      background: radial-gradient(circle at 30% 30%, #ffff00, #ffaa00, #ff6600);
      border: 4px solid #ffff00;
      color: #000;
      font-family: 'Quicksand', sans-serif;
      font-size: 0.7rem;
      font-weight: 700;
      cursor: pointer;
      z-index: 150;
      box-shadow:
        0 0 20px rgba(255, 255, 0, 0.6),
        0 0 40px rgba(255, 170, 0, 0.4),
        0 0 60px rgba(255, 100, 0, 0.2),
        inset 0 -3px 15px rgba(0, 0, 0, 0.3);
      transition: transform 0.1s, box-shadow 0.1s;
      animation: shockPulse 1.5s ease-in-out infinite;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      gap: 0.2rem;
      text-shadow: 0 0 5px rgba(255, 255, 0, 0.8);
      opacity: 0;
      pointer-events: none;
    }

    .shock-btn.visible {
      opacity: 1;
      pointer-events: auto;
    }

    .shock-btn:hover {
      transform: scale(1.1);
      box-shadow:
        0 0 30px rgba(255, 255, 0, 0.8),
        0 0 60px rgba(255, 170, 0, 0.6),
        0 0 90px rgba(255, 100, 0, 0.4),
        inset 0 -3px 15px rgba(0, 0, 0, 0.3);
    }

    .shock-btn:active {
      transform: scale(0.95);
    }

    .shock-btn .shock-icon {
      font-size: 2rem;
    }

    .shock-btn .shock-text {
      font-size: 0.6rem;
      letter-spacing: 0.1em;
    }

    @keyframes shockPulse {
      0%, 100% {
        box-shadow: 0 0 20px rgba(255, 255, 0, 0.6), 0 0 40px rgba(255, 170, 0, 0.4), 0 0 60px rgba(255, 100, 0, 0.2), inset 0 -3px 15px rgba(0, 0, 0, 0.3);
      }
      50% {
        box-shadow: 0 0 30px rgba(255, 255, 0, 0.9), 0 0 60px rgba(255, 170, 0, 0.7), 0 0 90px rgba(255, 100, 0, 0.4), inset 0 -3px 15px rgba(0, 0, 0, 0.3);
      }
    }

    .shock-flash {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
      z-index: 300;
      background: rgba(255, 255, 0, 0.9);
      animation: shockFlash 0.3s ease-out forwards;
    }

    @keyframes shockFlash {
      0% { opacity: 1; background: rgba(255, 255, 255, 1); }
      20% { background: rgba(255, 255, 0, 0.8); }
      40% { background: rgba(255, 255, 255, 0.9); }
      60% { background: rgba(255, 200, 0, 0.5); }
      100% { opacity: 0; }
    }

    @keyframes screenShake {
      0%, 100% { transform: translate(0, 0); }
      10% { transform: translate(-10px, -5px); }
      20% { transform: translate(10px, 5px); }
      30% { transform: translate(-8px, 8px); }
      40% { transform: translate(8px, -8px); }
      50% { transform: translate(-5px, 5px); }
      60% { transform: translate(5px, -5px); }
      70% { transform: translate(-3px, 3px); }
      80% { transform: translate(3px, -3px); }
      90% { transform: translate(-1px, 1px); }
    }

    body.shocked {
      animation: screenShake 0.5s ease-out;
    }

    .revive-text {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      font-size: 4rem;
      font-weight: 700;
      color: #ffff00;
      text-shadow:
        0 0 20px #ffff00,
        0 0 40px #ffaa00,
        0 0 60px #ff6600;
      z-index: 400;
      opacity: 0;
      pointer-events: none;
      letter-spacing: 0.2em;
    }

    .revive-text.visible {
      animation: reviveTextAnim 1s ease-out forwards;
    }

    @keyframes reviveTextAnim {
      0% { opacity: 0; transform: translate(-50%, -50%) scale(0.5); }
      20% { opacity: 1; transform: translate(-50%, -50%) scale(1.2); }
      40% { transform: translate(-50%, -50%) scale(1); }
      100% { opacity: 0; transform: translate(-50%, -50%) scale(1.5); }
    }

    @media (max-width: 600px) {
      .header h1 {
        font-size: 1.2rem;
        letter-spacing: 0.2em;
      }

      .start-screen h1 {
        font-size: 1.5rem;
      }

      .controls {
        flex-wrap: wrap;
        justify-content: center;
        max-width: 90%;
      }

      .breath-circle {
        width: 60px;
        height: 60px;
      }

      .shock-btn {
        width: 70px;
        height: 70px;
        top: 1rem;
        right: 1rem;
      }

      .shock-btn .shock-icon {
        font-size: 1.5rem;
      }

      .shock-btn .shock-text {
        font-size: 0.5rem;
      }

      .revive-text {
        font-size: 2.5rem;
      }
    }
  </style>
</head>
<body>
  <canvas id="canvas"></canvas>

  <div class="start-screen" id="startScreen">
    <h1>RECOVERY ROOM</h1>
    <p>a space for healing</p>
    <button class="start-btn" id="startBtn">ENTER</button>
  </div>

  <div class="ui-overlay header" id="header">
    <h1>RECOVERY ROOM</h1>
    <p>breathe and heal</p>
  </div>

  <div class="affirmation" id="affirmation"></div>

  <div class="breath-guide" id="breathGuide">
    <div class="breath-circle"></div>
    <div class="breath-text" id="breathText">INHALE</div>
  </div>

  <div class="ui-overlay controls" id="controls">
    <button class="ctrl-btn active" data-mode="waves">Waves</button>
    <button class="ctrl-btn" data-mode="breath">Breathe</button>
    <button class="ctrl-btn" data-mode="focus">Focus</button>
    <button class="ctrl-btn" data-sound="toggle">Sound</button>
  </div>

  <div class="backlink"><a href="https://sloppy.live">sloppy.live</a></div>

  <!-- HIGH-VOLTAGE REVIVE SHOCK -->
  <button class="shock-btn" id="shockBtn">
    <span class="shock-icon">âš¡</span>
    <span class="shock-text">REVIVE SHOCK</span>
  </button>
  <div class="revive-text" id="reviveText">REVIVED!</div>

  <script>
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');

    function resize() {
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
    }
    resize();
    window.addEventListener('resize', resize);

    // Audio context for ambient sounds
    let audioCtx = null;
    let soundEnabled = false;
    let oscillators = [];
    let gainNodes = [];

    // Particles
    let particles = [];
    const maxParticles = 60;

    // Waves
    let waveOffset = 0;
    const waveColors = [
      { r: 100, g: 200, b: 255, a: 0.15 },
      { r: 127, g: 219, b: 255, a: 0.1 },
      { r: 100, g: 255, b: 200, a: 0.08 },
      { r: 180, g: 140, b: 255, a: 0.06 }
    ];

    // Mode
    let currentMode = 'waves';
    let breathPhase = 0;
    let focusPoint = { x: 0, y: 0 };
    let started = false;

    // Affirmations
    const affirmations = [
      "You are healing",
      "Peace flows through you",
      "This moment is yours",
      "You are enough",
      "Let go of what weighs you down",
      "You are safe here",
      "Breathe in calm, breathe out tension",
      "Your strength is returning",
      "Rest is productive",
      "You deserve this peace"
    ];
    let currentAffirmation = '';
    let affirmationTimer = 0;

    // Electric bolt particles
    let electricBolts = [];

    // Healing particle
    class Particle {
      constructor() {
        this.reset();
      }

      reset() {
        this.x = Math.random() * canvas.width;
        this.y = canvas.height + 20;
        this.size = 2 + Math.random() * 4;
        this.speedY = -0.3 - Math.random() * 0.5;
        this.speedX = (Math.random() - 0.5) * 0.3;
        this.wobble = Math.random() * Math.PI * 2;
        this.wobbleSpeed = 0.02 + Math.random() * 0.02;
        this.opacity = 0.3 + Math.random() * 0.5;
        this.hue = 160 + Math.random() * 60; // Cyan to green range
        this.pulse = Math.random() * Math.PI * 2;
      }

      update() {
        this.wobble += this.wobbleSpeed;
        this.pulse += 0.05;
        this.x += this.speedX + Math.sin(this.wobble) * 0.3;
        this.y += this.speedY;

        // Focus mode attraction
        if (currentMode === 'focus') {
          const dx = focusPoint.x - this.x;
          const dy = focusPoint.y - this.y;
          const dist = Math.sqrt(dx * dx + dy * dy);
          if (dist > 50) {
            this.x += dx * 0.002;
            this.y += dy * 0.002;
          }
        }

        if (this.y < -20) {
          this.reset();
        }
      }

      draw() {
        const pulseSize = this.size + Math.sin(this.pulse) * 1;

        ctx.save();
        ctx.globalAlpha = this.opacity * (0.7 + Math.sin(this.pulse) * 0.3);

        // Outer glow
        const gradient = ctx.createRadialGradient(
          this.x, this.y, 0,
          this.x, this.y, pulseSize * 3
        );
        gradient.addColorStop(0, `hsla(${this.hue}, 80%, 70%, 0.8)`);
        gradient.addColorStop(0.5, `hsla(${this.hue}, 80%, 60%, 0.2)`);
        gradient.addColorStop(1, `hsla(${this.hue}, 80%, 50%, 0)`);

        ctx.fillStyle = gradient;
        ctx.beginPath();
        ctx.arc(this.x, this.y, pulseSize * 3, 0, Math.PI * 2);
        ctx.fill();

        // Core
        ctx.fillStyle = `hsla(${this.hue}, 80%, 80%, 1)`;
        ctx.beginPath();
        ctx.arc(this.x, this.y, pulseSize * 0.5, 0, Math.PI * 2);
        ctx.fill();

        ctx.restore();
      }
    }

    // Electric bolt for shock effect
    class ElectricBolt {
      constructor(startX, startY, endX, endY) {
        this.startX = startX;
        this.startY = startY;
        this.endX = endX;
        this.endY = endY;
        this.life = 1;
        this.segments = [];
        this.generateBolt();
      }

      generateBolt() {
        this.segments = [];
        let x = this.startX;
        let y = this.startY;
        const dx = this.endX - this.startX;
        const dy = this.endY - this.startY;
        const steps = 10;

        for (let i = 0; i <= steps; i++) {
          const progress = i / steps;
          const targetX = this.startX + dx * progress;
          const targetY = this.startY + dy * progress;
          const offsetX = (Math.random() - 0.5) * 50 * (1 - progress);
          const offsetY = (Math.random() - 0.5) * 50 * (1 - progress);

          this.segments.push({
            x: targetX + offsetX,
            y: targetY + offsetY
          });
        }
      }

      update() {
        this.life -= 0.05;
        if (Math.random() < 0.3) {
          this.generateBolt();
        }
      }

      draw() {
        ctx.save();
        ctx.globalAlpha = this.life;
        ctx.strokeStyle = '#ffff00';
        ctx.lineWidth = 3;
        ctx.shadowColor = '#ffff00';
        ctx.shadowBlur = 20;

        ctx.beginPath();
        ctx.moveTo(this.segments[0].x, this.segments[0].y);
        for (let i = 1; i < this.segments.length; i++) {
          ctx.lineTo(this.segments[i].x, this.segments[i].y);
        }
        ctx.stroke();

        // Brighter core
        ctx.strokeStyle = '#ffffff';
        ctx.lineWidth = 1;
        ctx.stroke();

        ctx.restore();
      }
    }

    // REVIVE SHOCK FUNCTION
    function fireReviveShock() {
      // Flash effect
      const flash = document.createElement('div');
      flash.className = 'shock-flash';
      document.body.appendChild(flash);
      setTimeout(() => flash.remove(), 300);

      // Screen shake
      document.body.classList.add('shocked');
      setTimeout(() => document.body.classList.remove('shocked'), 500);

      // Show REVIVED text
      const reviveText = document.getElementById('reviveText');
      reviveText.classList.add('visible');
      setTimeout(() => reviveText.classList.remove('visible'), 1000);

      // Spawn electric bolts from center
      const cx = canvas.width / 2;
      const cy = canvas.height / 2;
      for (let i = 0; i < 8; i++) {
        const angle = (i / 8) * Math.PI * 2;
        const endX = cx + Math.cos(angle) * 300;
        const endY = cy + Math.sin(angle) * 300;
        electricBolts.push(new ElectricBolt(cx, cy, endX, endY));
      }

      // Burst of energized particles
      for (let i = 0; i < 30; i++) {
        const p = new Particle();
        p.x = cx + (Math.random() - 0.5) * 100;
        p.y = cy + (Math.random() - 0.5) * 100;
        p.speedX = (Math.random() - 0.5) * 5;
        p.speedY = (Math.random() - 0.5) * 5;
        p.hue = 50 + Math.random() * 20; // Yellow/orange
        p.opacity = 1;
        particles.push(p);
      }

      // Shock sound if audio enabled
      if (audioCtx) {
        const osc = audioCtx.createOscillator();
        const gain = audioCtx.createGain();
        osc.type = 'sawtooth';
        osc.frequency.value = 150;
        osc.frequency.exponentialRampToValueAtTime(50, audioCtx.currentTime + 0.2);
        gain.gain.value = 0.3;
        gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.3);
        osc.connect(gain);
        gain.connect(audioCtx.destination);
        osc.start();
        osc.stop(audioCtx.currentTime + 0.3);
      }

      // Keep particle count reasonable
      while (particles.length > maxParticles * 2) {
        particles.shift();
      }
    }

    // Initialize particles
    function initParticles() {
      particles = [];
      for (let i = 0; i < maxParticles; i++) {
        const p = new Particle();
        p.y = Math.random() * canvas.height;
        particles.push(p);
      }
    }

    // Draw ambient waves
    function drawWaves() {
      waveOffset += 0.005;

      for (let w = 0; w < waveColors.length; w++) {
        const wave = waveColors[w];
        const yBase = canvas.height * (0.5 + w * 0.12);
        const amplitude = 30 + w * 15;
        const frequency = 0.003 - w * 0.0005;
        const speed = waveOffset * (1 + w * 0.3);

        ctx.beginPath();
        ctx.moveTo(0, canvas.height);

        for (let x = 0; x <= canvas.width; x += 5) {
          const y = yBase +
            Math.sin(x * frequency + speed) * amplitude +
            Math.sin(x * frequency * 2 + speed * 1.5) * amplitude * 0.5;
          ctx.lineTo(x, y);
        }

        ctx.lineTo(canvas.width, canvas.height);
        ctx.closePath();

        ctx.fillStyle = `rgba(${wave.r}, ${wave.g}, ${wave.b}, ${wave.a})`;
        ctx.fill();
      }
    }

    // Draw breath visualization
    function drawBreathCircle() {
      breathPhase += 0.008;
      const scale = 0.5 + Math.sin(breathPhase) * 0.5;
      const baseRadius = Math.min(canvas.width, canvas.height) * 0.15;
      const radius = baseRadius * scale;

      const cx = canvas.width / 2;
      const cy = canvas.height / 2;

      // Outer rings
      for (let i = 3; i > 0; i--) {
        ctx.beginPath();
        ctx.arc(cx, cy, radius + i * 20, 0, Math.PI * 2);
        ctx.strokeStyle = `rgba(100, 255, 200, ${0.1 / i})`;
        ctx.lineWidth = 2;
        ctx.stroke();
      }

      // Main circle
      const gradient = ctx.createRadialGradient(cx, cy, 0, cx, cy, radius);
      gradient.addColorStop(0, 'rgba(100, 255, 200, 0.3)');
      gradient.addColorStop(0.7, 'rgba(100, 255, 200, 0.1)');
      gradient.addColorStop(1, 'rgba(100, 255, 200, 0)');

      ctx.fillStyle = gradient;
      ctx.beginPath();
      ctx.arc(cx, cy, radius, 0, Math.PI * 2);
      ctx.fill();

      ctx.strokeStyle = 'rgba(100, 255, 200, 0.5)';
      ctx.lineWidth = 2;
      ctx.stroke();

      // Update breath text
      const breathText = document.getElementById('breathText');
      if (Math.sin(breathPhase) > 0) {
        breathText.textContent = 'INHALE';
      } else {
        breathText.textContent = 'EXHALE';
      }
    }

    // Draw focus point
    function drawFocusPoint() {
      focusPoint.x = canvas.width / 2;
      focusPoint.y = canvas.height / 2;

      const time = Date.now() * 0.001;

      // Pulsing core
      const pulseSize = 10 + Math.sin(time * 2) * 3;

      const gradient = ctx.createRadialGradient(
        focusPoint.x, focusPoint.y, 0,
        focusPoint.x, focusPoint.y, pulseSize * 5
      );
      gradient.addColorStop(0, 'rgba(180, 140, 255, 0.8)');
      gradient.addColorStop(0.3, 'rgba(180, 140, 255, 0.3)');
      gradient.addColorStop(1, 'rgba(180, 140, 255, 0)');

      ctx.fillStyle = gradient;
      ctx.beginPath();
      ctx.arc(focusPoint.x, focusPoint.y, pulseSize * 5, 0, Math.PI * 2);
      ctx.fill();

      // Rotating rings
      ctx.save();
      ctx.translate(focusPoint.x, focusPoint.y);
      ctx.rotate(time * 0.5);

      for (let i = 0; i < 3; i++) {
        ctx.rotate(Math.PI / 3);
        ctx.strokeStyle = `rgba(180, 140, 255, ${0.3 - i * 0.1})`;
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.arc(0, 0, 40 + i * 20, 0, Math.PI * 0.8);
        ctx.stroke();
      }

      ctx.restore();
    }

    // Show affirmation
    function showAffirmation() {
      if (affirmationTimer <= 0 && Math.random() < 0.002) {
        currentAffirmation = affirmations[Math.floor(Math.random() * affirmations.length)];
        document.getElementById('affirmation').textContent = currentAffirmation;
        document.getElementById('affirmation').classList.add('visible');
        affirmationTimer = 400;
      }

      if (affirmationTimer > 0) {
        affirmationTimer--;
        if (affirmationTimer === 100) {
          document.getElementById('affirmation').classList.remove('visible');
        }
      }
    }

    // Initialize ambient audio
    function initAudio() {
      if (audioCtx) return;

      audioCtx = new (window.AudioContext || window.webkitAudioContext)();

      // Create multiple oscillators for rich ambient sound
      const frequencies = [55, 82.5, 110, 165]; // Low, soothing frequencies

      frequencies.forEach((freq, i) => {
        const osc = audioCtx.createOscillator();
        const gain = audioCtx.createGain();
        const filter = audioCtx.createBiquadFilter();

        osc.type = 'sine';
        osc.frequency.value = freq;

        filter.type = 'lowpass';
        filter.frequency.value = 200;
        filter.Q.value = 1;

        gain.gain.value = 0;

        osc.connect(filter);
        filter.connect(gain);
        gain.connect(audioCtx.destination);

        osc.start();
        oscillators.push(osc);
        gainNodes.push(gain);
      });

      // Add noise for wave texture
      const noiseGain = audioCtx.createGain();
      const noiseFilter = audioCtx.createBiquadFilter();

      const bufferSize = 2 * audioCtx.sampleRate;
      const noiseBuffer = audioCtx.createBuffer(1, bufferSize, audioCtx.sampleRate);
      const output = noiseBuffer.getChannelData(0);

      for (let i = 0; i < bufferSize; i++) {
        output[i] = Math.random() * 2 - 1;
      }

      const noise = audioCtx.createBufferSource();
      noise.buffer = noiseBuffer;
      noise.loop = true;

      noiseFilter.type = 'lowpass';
      noiseFilter.frequency.value = 100;

      noiseGain.gain.value = 0;

      noise.connect(noiseFilter);
      noiseFilter.connect(noiseGain);
      noiseGain.connect(audioCtx.destination);

      noise.start();
      gainNodes.push(noiseGain);
    }

    // Toggle sound
    function toggleSound() {
      if (!audioCtx) {
        initAudio();
      }

      soundEnabled = !soundEnabled;

      const targetVolume = soundEnabled ? [0.08, 0.06, 0.04, 0.03, 0.02] : [0, 0, 0, 0, 0];

      gainNodes.forEach((gain, i) => {
        gain.gain.linearRampToValueAtTime(
          targetVolume[i] || 0,
          audioCtx.currentTime + 1
        );
      });

      document.querySelector('[data-sound="toggle"]').classList.toggle('active', soundEnabled);
    }

    // Main draw loop
    function draw() {
      // Clear with fade effect
      ctx.fillStyle = 'rgba(10, 15, 25, 0.1)';
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      // Draw waves
      if (currentMode === 'waves' || currentMode === 'breath') {
        drawWaves();
      }

      // Draw mode-specific elements
      if (currentMode === 'breath') {
        drawBreathCircle();
      } else if (currentMode === 'focus') {
        drawFocusPoint();
      }

      // Update and draw particles
      particles.forEach(p => {
        p.update();
        p.draw();
      });

      // Update and draw electric bolts
      for (let i = electricBolts.length - 1; i >= 0; i--) {
        electricBolts[i].update();
        electricBolts[i].draw();
        if (electricBolts[i].life <= 0) {
          electricBolts.splice(i, 1);
        }
      }

      // Show random affirmations
      showAffirmation();

      requestAnimationFrame(draw);
    }

    // Start experience
    function start() {
      if (started) return;
      started = true;

      document.getElementById('startScreen').classList.add('hidden');
      initParticles();

      // Show shock button
      document.getElementById('shockBtn').classList.add('visible');

      // Fade header after a moment
      setTimeout(() => {
        document.getElementById('header').classList.add('hidden');
      }, 5000);

      draw();
    }

    // Event listeners
    document.getElementById('startBtn').addEventListener('click', start);

    document.querySelectorAll('.ctrl-btn[data-mode]').forEach(btn => {
      btn.addEventListener('click', () => {
        document.querySelectorAll('.ctrl-btn[data-mode]').forEach(b => b.classList.remove('active'));
        btn.classList.add('active');
        currentMode = btn.dataset.mode;

        // Show/hide breath guide
        document.getElementById('breathGuide').classList.toggle('visible', currentMode === 'breath');
      });
    });

    document.querySelector('[data-sound="toggle"]').addEventListener('click', toggleSound);

    // REVIVE SHOCK button
    document.getElementById('shockBtn').addEventListener('click', fireReviveShock);

    // Touch to interact
    canvas.addEventListener('click', (e) => {
      if (!started) return;

      // Spawn extra particles at click
      for (let i = 0; i < 5; i++) {
        const p = new Particle();
        p.x = e.clientX + (Math.random() - 0.5) * 50;
        p.y = e.clientY + (Math.random() - 0.5) * 50;
        p.speedY = -0.5 - Math.random() * 0.5;
        particles.push(p);

        // Keep particle count reasonable
        if (particles.length > maxParticles * 1.5) {
          particles.shift();
        }
      }
    });
  </script>
<script src="/sloppy-header/sloppy-bar.js"></script>
</body>
</html>
