<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Neon Recovery Room</title>
  <meta name="description" content="Relax with soothing ambient waves and healing particles">
  <meta property="og:title" content="Neon Recovery Room">
  <meta property="og:description" content="A calming space with ambient waves and floating healing particles">
  <meta property="og:url" content="https://sloppy.live/neon-recovery-room/">
  <meta property="og:image" content="https://sloppy.live/neon-recovery-room/og-image.png">
  <link rel="icon" href="https://emojicdn.elk.sh/ðŸŒŠ">
  <link href="https://fonts.googleapis.com/css2?family=Quicksand:wght@300;400;500&display=swap" rel="stylesheet">
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      background: linear-gradient(180deg, #0a0a1a 0%, #0f1a2a 50%, #0a1520 100%);
      min-height: 100vh;
      overflow: hidden;
      font-family: 'Quicksand', sans-serif;
      color: #fff;
    }

    #canvas {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
    }

    .ui-overlay {
      position: fixed;
      z-index: 100;
      pointer-events: none;
    }

    .header {
      top: 2rem;
      left: 50%;
      transform: translateX(-50%);
      text-align: center;
      opacity: 0.8;
      transition: opacity 0.5s;
    }

    .header.hidden {
      opacity: 0;
    }

    .header h1 {
      font-size: 1.8rem;
      font-weight: 300;
      letter-spacing: 0.3em;
      color: #7fdbff;
      text-shadow: 0 0 30px rgba(127, 219, 255, 0.5);
    }

    .header p {
      font-size: 0.9rem;
      color: #a0d0e0;
      margin-top: 0.5rem;
      font-weight: 300;
      letter-spacing: 0.1em;
    }

    .start-screen {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(10, 10, 26, 0.95);
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      z-index: 200;
      transition: opacity 1s;
    }

    .start-screen.hidden {
      opacity: 0;
      pointer-events: none;
    }

    .start-screen h1 {
      font-size: 2.5rem;
      font-weight: 300;
      letter-spacing: 0.3em;
      color: #7fdbff;
      text-shadow: 0 0 40px rgba(127, 219, 255, 0.6);
      margin-bottom: 1rem;
    }

    .start-screen p {
      color: #80a0b0;
      font-size: 1rem;
      margin-bottom: 2rem;
      font-weight: 300;
    }

    .start-btn {
      font-family: 'Quicksand', sans-serif;
      font-size: 1.1rem;
      font-weight: 400;
      padding: 1rem 3rem;
      background: transparent;
      border: 1px solid rgba(127, 219, 255, 0.4);
      border-radius: 50px;
      color: #7fdbff;
      cursor: pointer;
      transition: all 0.5s;
      letter-spacing: 0.2em;
    }

    .start-btn:hover {
      background: rgba(127, 219, 255, 0.1);
      border-color: rgba(127, 219, 255, 0.8);
      box-shadow: 0 0 30px rgba(127, 219, 255, 0.3);
    }

    .controls {
      bottom: 2rem;
      left: 50%;
      transform: translateX(-50%);
      display: flex;
      gap: 1rem;
      pointer-events: auto;
      opacity: 0.6;
      transition: opacity 0.3s;
    }

    .controls:hover {
      opacity: 1;
    }

    .ctrl-btn {
      font-family: 'Quicksand', sans-serif;
      font-size: 0.8rem;
      padding: 0.6rem 1.2rem;
      background: rgba(0, 0, 0, 0.3);
      border: 1px solid rgba(127, 219, 255, 0.3);
      border-radius: 20px;
      color: #7fdbff;
      cursor: pointer;
      transition: all 0.3s;
    }

    .ctrl-btn:hover {
      background: rgba(127, 219, 255, 0.1);
      border-color: rgba(127, 219, 255, 0.6);
    }

    .ctrl-btn.active {
      background: rgba(127, 219, 255, 0.2);
      border-color: #7fdbff;
    }

    .breath-guide {
      position: fixed;
      bottom: 6rem;
      left: 50%;
      transform: translateX(-50%);
      text-align: center;
      opacity: 0;
      transition: opacity 0.5s;
      z-index: 100;
    }

    .breath-guide.visible {
      opacity: 0.8;
    }

    .breath-circle {
      width: 80px;
      height: 80px;
      border: 2px solid rgba(100, 255, 200, 0.5);
      border-radius: 50%;
      margin: 0 auto 1rem;
      animation: breathe 8s ease-in-out infinite;
    }

    .breath-text {
      font-size: 1rem;
      color: #64ffc8;
      letter-spacing: 0.2em;
      animation: breatheText 8s ease-in-out infinite;
    }

    @keyframes breathe {
      0%, 100% { transform: scale(0.6); opacity: 0.4; }
      50% { transform: scale(1.2); opacity: 1; }
    }

    @keyframes breatheText {
      0%, 45% { content: 'INHALE'; }
      50%, 95% { content: 'EXHALE'; }
    }

    .affirmation {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      font-size: 1.5rem;
      font-weight: 300;
      color: rgba(180, 140, 255, 0.8);
      text-shadow: 0 0 30px rgba(180, 140, 255, 0.5);
      opacity: 0;
      transition: opacity 2s;
      text-align: center;
      max-width: 80%;
      letter-spacing: 0.1em;
      z-index: 50;
    }

    .affirmation.visible {
      opacity: 1;
    }

    .backlink {
      position: fixed;
      bottom: 0.5rem;
      right: 0.5rem;
      font-size: 0.7rem;
      z-index: 100;
      opacity: 0.4;
    }

    .backlink a {
      color: #7fdbff;
      text-decoration: none;
    }

    @media (max-width: 600px) {
      .header h1 {
        font-size: 1.2rem;
        letter-spacing: 0.2em;
      }

      .start-screen h1 {
        font-size: 1.5rem;
      }

      .controls {
        flex-wrap: wrap;
        justify-content: center;
        max-width: 90%;
      }

      .breath-circle {
        width: 60px;
        height: 60px;
      }
    }
  </style>
</head>
<body>
  <canvas id="canvas"></canvas>

  <div class="start-screen" id="startScreen">
    <h1>RECOVERY ROOM</h1>
    <p>a space for healing</p>
    <button class="start-btn" id="startBtn">ENTER</button>
  </div>

  <div class="ui-overlay header" id="header">
    <h1>RECOVERY ROOM</h1>
    <p>breathe and heal</p>
  </div>

  <div class="affirmation" id="affirmation"></div>

  <div class="breath-guide" id="breathGuide">
    <div class="breath-circle"></div>
    <div class="breath-text" id="breathText">INHALE</div>
  </div>

  <div class="ui-overlay controls" id="controls">
    <button class="ctrl-btn active" data-mode="waves">Waves</button>
    <button class="ctrl-btn" data-mode="breath">Breathe</button>
    <button class="ctrl-btn" data-mode="focus">Focus</button>
    <button class="ctrl-btn" data-sound="toggle">Sound</button>
  </div>

  <div class="backlink"><a href="https://sloppy.live">sloppy.live</a></div>

  <script>
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');

    function resize() {
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
    }
    resize();
    window.addEventListener('resize', resize);

    // Audio context for ambient sounds
    let audioCtx = null;
    let soundEnabled = false;
    let oscillators = [];
    let gainNodes = [];

    // Particles
    let particles = [];
    const maxParticles = 60;

    // Waves
    let waveOffset = 0;
    const waveColors = [
      { r: 100, g: 200, b: 255, a: 0.15 },
      { r: 127, g: 219, b: 255, a: 0.1 },
      { r: 100, g: 255, b: 200, a: 0.08 },
      { r: 180, g: 140, b: 255, a: 0.06 }
    ];

    // Mode
    let currentMode = 'waves';
    let breathPhase = 0;
    let focusPoint = { x: 0, y: 0 };
    let started = false;

    // Affirmations
    const affirmations = [
      "You are healing",
      "Peace flows through you",
      "This moment is yours",
      "You are enough",
      "Let go of what weighs you down",
      "You are safe here",
      "Breathe in calm, breathe out tension",
      "Your strength is returning",
      "Rest is productive",
      "You deserve this peace"
    ];
    let currentAffirmation = '';
    let affirmationTimer = 0;

    // Healing particle
    class Particle {
      constructor() {
        this.reset();
      }

      reset() {
        this.x = Math.random() * canvas.width;
        this.y = canvas.height + 20;
        this.size = 2 + Math.random() * 4;
        this.speedY = -0.3 - Math.random() * 0.5;
        this.speedX = (Math.random() - 0.5) * 0.3;
        this.wobble = Math.random() * Math.PI * 2;
        this.wobbleSpeed = 0.02 + Math.random() * 0.02;
        this.opacity = 0.3 + Math.random() * 0.5;
        this.hue = 160 + Math.random() * 60; // Cyan to green range
        this.pulse = Math.random() * Math.PI * 2;
      }

      update() {
        this.wobble += this.wobbleSpeed;
        this.pulse += 0.05;
        this.x += this.speedX + Math.sin(this.wobble) * 0.3;
        this.y += this.speedY;

        // Focus mode attraction
        if (currentMode === 'focus') {
          const dx = focusPoint.x - this.x;
          const dy = focusPoint.y - this.y;
          const dist = Math.sqrt(dx * dx + dy * dy);
          if (dist > 50) {
            this.x += dx * 0.002;
            this.y += dy * 0.002;
          }
        }

        if (this.y < -20) {
          this.reset();
        }
      }

      draw() {
        const pulseSize = this.size + Math.sin(this.pulse) * 1;

        ctx.save();
        ctx.globalAlpha = this.opacity * (0.7 + Math.sin(this.pulse) * 0.3);

        // Outer glow
        const gradient = ctx.createRadialGradient(
          this.x, this.y, 0,
          this.x, this.y, pulseSize * 3
        );
        gradient.addColorStop(0, `hsla(${this.hue}, 80%, 70%, 0.8)`);
        gradient.addColorStop(0.5, `hsla(${this.hue}, 80%, 60%, 0.2)`);
        gradient.addColorStop(1, `hsla(${this.hue}, 80%, 50%, 0)`);

        ctx.fillStyle = gradient;
        ctx.beginPath();
        ctx.arc(this.x, this.y, pulseSize * 3, 0, Math.PI * 2);
        ctx.fill();

        // Core
        ctx.fillStyle = `hsla(${this.hue}, 80%, 80%, 1)`;
        ctx.beginPath();
        ctx.arc(this.x, this.y, pulseSize * 0.5, 0, Math.PI * 2);
        ctx.fill();

        ctx.restore();
      }
    }

    // Initialize particles
    function initParticles() {
      particles = [];
      for (let i = 0; i < maxParticles; i++) {
        const p = new Particle();
        p.y = Math.random() * canvas.height;
        particles.push(p);
      }
    }

    // Draw ambient waves
    function drawWaves() {
      waveOffset += 0.005;

      for (let w = 0; w < waveColors.length; w++) {
        const wave = waveColors[w];
        const yBase = canvas.height * (0.5 + w * 0.12);
        const amplitude = 30 + w * 15;
        const frequency = 0.003 - w * 0.0005;
        const speed = waveOffset * (1 + w * 0.3);

        ctx.beginPath();
        ctx.moveTo(0, canvas.height);

        for (let x = 0; x <= canvas.width; x += 5) {
          const y = yBase +
            Math.sin(x * frequency + speed) * amplitude +
            Math.sin(x * frequency * 2 + speed * 1.5) * amplitude * 0.5;
          ctx.lineTo(x, y);
        }

        ctx.lineTo(canvas.width, canvas.height);
        ctx.closePath();

        ctx.fillStyle = `rgba(${wave.r}, ${wave.g}, ${wave.b}, ${wave.a})`;
        ctx.fill();
      }
    }

    // Draw breath visualization
    function drawBreathCircle() {
      breathPhase += 0.008;
      const scale = 0.5 + Math.sin(breathPhase) * 0.5;
      const baseRadius = Math.min(canvas.width, canvas.height) * 0.15;
      const radius = baseRadius * scale;

      const cx = canvas.width / 2;
      const cy = canvas.height / 2;

      // Outer rings
      for (let i = 3; i > 0; i--) {
        ctx.beginPath();
        ctx.arc(cx, cy, radius + i * 20, 0, Math.PI * 2);
        ctx.strokeStyle = `rgba(100, 255, 200, ${0.1 / i})`;
        ctx.lineWidth = 2;
        ctx.stroke();
      }

      // Main circle
      const gradient = ctx.createRadialGradient(cx, cy, 0, cx, cy, radius);
      gradient.addColorStop(0, 'rgba(100, 255, 200, 0.3)');
      gradient.addColorStop(0.7, 'rgba(100, 255, 200, 0.1)');
      gradient.addColorStop(1, 'rgba(100, 255, 200, 0)');

      ctx.fillStyle = gradient;
      ctx.beginPath();
      ctx.arc(cx, cy, radius, 0, Math.PI * 2);
      ctx.fill();

      ctx.strokeStyle = 'rgba(100, 255, 200, 0.5)';
      ctx.lineWidth = 2;
      ctx.stroke();

      // Update breath text
      const breathText = document.getElementById('breathText');
      if (Math.sin(breathPhase) > 0) {
        breathText.textContent = 'INHALE';
      } else {
        breathText.textContent = 'EXHALE';
      }
    }

    // Draw focus point
    function drawFocusPoint() {
      focusPoint.x = canvas.width / 2;
      focusPoint.y = canvas.height / 2;

      const time = Date.now() * 0.001;

      // Pulsing core
      const pulseSize = 10 + Math.sin(time * 2) * 3;

      const gradient = ctx.createRadialGradient(
        focusPoint.x, focusPoint.y, 0,
        focusPoint.x, focusPoint.y, pulseSize * 5
      );
      gradient.addColorStop(0, 'rgba(180, 140, 255, 0.8)');
      gradient.addColorStop(0.3, 'rgba(180, 140, 255, 0.3)');
      gradient.addColorStop(1, 'rgba(180, 140, 255, 0)');

      ctx.fillStyle = gradient;
      ctx.beginPath();
      ctx.arc(focusPoint.x, focusPoint.y, pulseSize * 5, 0, Math.PI * 2);
      ctx.fill();

      // Rotating rings
      ctx.save();
      ctx.translate(focusPoint.x, focusPoint.y);
      ctx.rotate(time * 0.5);

      for (let i = 0; i < 3; i++) {
        ctx.rotate(Math.PI / 3);
        ctx.strokeStyle = `rgba(180, 140, 255, ${0.3 - i * 0.1})`;
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.arc(0, 0, 40 + i * 20, 0, Math.PI * 0.8);
        ctx.stroke();
      }

      ctx.restore();
    }

    // Show affirmation
    function showAffirmation() {
      if (affirmationTimer <= 0 && Math.random() < 0.002) {
        currentAffirmation = affirmations[Math.floor(Math.random() * affirmations.length)];
        document.getElementById('affirmation').textContent = currentAffirmation;
        document.getElementById('affirmation').classList.add('visible');
        affirmationTimer = 400;
      }

      if (affirmationTimer > 0) {
        affirmationTimer--;
        if (affirmationTimer === 100) {
          document.getElementById('affirmation').classList.remove('visible');
        }
      }
    }

    // Initialize ambient audio
    function initAudio() {
      if (audioCtx) return;

      audioCtx = new (window.AudioContext || window.webkitAudioContext)();

      // Create multiple oscillators for rich ambient sound
      const frequencies = [55, 82.5, 110, 165]; // Low, soothing frequencies

      frequencies.forEach((freq, i) => {
        const osc = audioCtx.createOscillator();
        const gain = audioCtx.createGain();
        const filter = audioCtx.createBiquadFilter();

        osc.type = 'sine';
        osc.frequency.value = freq;

        filter.type = 'lowpass';
        filter.frequency.value = 200;
        filter.Q.value = 1;

        gain.gain.value = 0;

        osc.connect(filter);
        filter.connect(gain);
        gain.connect(audioCtx.destination);

        osc.start();
        oscillators.push(osc);
        gainNodes.push(gain);
      });

      // Add noise for wave texture
      const noiseGain = audioCtx.createGain();
      const noiseFilter = audioCtx.createBiquadFilter();

      const bufferSize = 2 * audioCtx.sampleRate;
      const noiseBuffer = audioCtx.createBuffer(1, bufferSize, audioCtx.sampleRate);
      const output = noiseBuffer.getChannelData(0);

      for (let i = 0; i < bufferSize; i++) {
        output[i] = Math.random() * 2 - 1;
      }

      const noise = audioCtx.createBufferSource();
      noise.buffer = noiseBuffer;
      noise.loop = true;

      noiseFilter.type = 'lowpass';
      noiseFilter.frequency.value = 100;

      noiseGain.gain.value = 0;

      noise.connect(noiseFilter);
      noiseFilter.connect(noiseGain);
      noiseGain.connect(audioCtx.destination);

      noise.start();
      gainNodes.push(noiseGain);
    }

    // Toggle sound
    function toggleSound() {
      if (!audioCtx) {
        initAudio();
      }

      soundEnabled = !soundEnabled;

      const targetVolume = soundEnabled ? [0.08, 0.06, 0.04, 0.03, 0.02] : [0, 0, 0, 0, 0];

      gainNodes.forEach((gain, i) => {
        gain.gain.linearRampToValueAtTime(
          targetVolume[i] || 0,
          audioCtx.currentTime + 1
        );
      });

      document.querySelector('[data-sound="toggle"]').classList.toggle('active', soundEnabled);
    }

    // Main draw loop
    function draw() {
      // Clear with fade effect
      ctx.fillStyle = 'rgba(10, 15, 25, 0.1)';
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      // Draw waves
      if (currentMode === 'waves' || currentMode === 'breath') {
        drawWaves();
      }

      // Draw mode-specific elements
      if (currentMode === 'breath') {
        drawBreathCircle();
      } else if (currentMode === 'focus') {
        drawFocusPoint();
      }

      // Update and draw particles
      particles.forEach(p => {
        p.update();
        p.draw();
      });

      // Show random affirmations
      showAffirmation();

      requestAnimationFrame(draw);
    }

    // Start experience
    function start() {
      if (started) return;
      started = true;

      document.getElementById('startScreen').classList.add('hidden');
      initParticles();

      // Fade header after a moment
      setTimeout(() => {
        document.getElementById('header').classList.add('hidden');
      }, 5000);

      draw();
    }

    // Event listeners
    document.getElementById('startBtn').addEventListener('click', start);

    document.querySelectorAll('.ctrl-btn[data-mode]').forEach(btn => {
      btn.addEventListener('click', () => {
        document.querySelectorAll('.ctrl-btn[data-mode]').forEach(b => b.classList.remove('active'));
        btn.classList.add('active');
        currentMode = btn.dataset.mode;

        // Show/hide breath guide
        document.getElementById('breathGuide').classList.toggle('visible', currentMode === 'breath');
      });
    });

    document.querySelector('[data-sound="toggle"]').addEventListener('click', toggleSound);

    // Touch to interact
    canvas.addEventListener('click', (e) => {
      if (!started) return;

      // Spawn extra particles at click
      for (let i = 0; i < 5; i++) {
        const p = new Particle();
        p.x = e.clientX + (Math.random() - 0.5) * 50;
        p.y = e.clientY + (Math.random() - 0.5) * 50;
        p.speedY = -0.5 - Math.random() * 0.5;
        particles.push(p);

        // Keep particle count reasonable
        if (particles.length > maxParticles * 1.5) {
          particles.shift();
        }
      }
    });
  </script>
</body>
</html>
