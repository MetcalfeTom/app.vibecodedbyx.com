<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
  <title>Neon Slice - Shape Ninja</title>
  <link rel="icon" href="https://emojicdn.elk.sh/‚öîÔ∏è">
  <meta property="og:title" content="Neon Slice">
  <meta property="og:description" content="Slice glowing shapes in this fast-paced neon game">
  <meta property="og:url" content="https://sloppy.live/neon-slice">
  <meta property="og:image" content="https://emojicdn.elk.sh/‚öîÔ∏è?style=apple&size=512">
  <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&display=swap" rel="stylesheet">
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      background: #050510;
      overflow: hidden;
      font-family: 'Orbitron', sans-serif;
      touch-action: none;
    }
    canvas { display: block; cursor: crosshair; }

    .ui {
      position: fixed;
      top: 20px;
      left: 20px;
      z-index: 100;
      pointer-events: none;
    }

    .score {
      font-size: 2.5rem;
      font-weight: 900;
      color: #00ffff;
      text-shadow: 0 0 30px #00ffff;
    }

    .combo {
      font-size: 1.2rem;
      color: #ff00ff;
      text-shadow: 0 0 20px #ff00ff;
      opacity: 0;
      transition: opacity 0.2s;
    }

    .combo.active {
      opacity: 1;
      animation: comboPulse 0.3s ease-out;
    }

    @keyframes comboPulse {
      0% { transform: scale(1.5); }
      100% { transform: scale(1); }
    }

    .lives {
      position: fixed;
      top: 20px;
      right: 20px;
      font-size: 2rem;
      z-index: 100;
      pointer-events: none;
    }

    .game-over {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      text-align: center;
      z-index: 200;
      display: none;
    }

    .game-over h1 {
      font-size: 3rem;
      color: #ff0066;
      text-shadow: 0 0 40px #ff0066;
      margin-bottom: 20px;
    }

    .game-over .final-score {
      font-size: 2rem;
      color: #00ffff;
      text-shadow: 0 0 30px #00ffff;
      margin-bottom: 30px;
    }

    .btn {
      padding: 15px 40px;
      background: linear-gradient(135deg, #ff00ff, #ff0088);
      border: none;
      border-radius: 10px;
      color: #fff;
      font-family: 'Orbitron', sans-serif;
      font-size: 1.2rem;
      font-weight: 700;
      cursor: pointer;
      box-shadow: 0 0 30px rgba(255, 0, 255, 0.5);
      transition: all 0.2s;
    }

    .btn:hover {
      transform: scale(1.1);
      box-shadow: 0 0 50px rgba(255, 0, 255, 0.8);
    }

    .start-screen {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      text-align: center;
      z-index: 200;
    }

    .start-screen h1 {
      font-size: 3.5rem;
      color: #00ffff;
      text-shadow: 0 0 50px #00ffff;
      margin-bottom: 10px;
      letter-spacing: 8px;
    }

    .start-screen p {
      color: rgba(255, 0, 255, 0.8);
      margin-bottom: 40px;
      font-size: 1rem;
    }

    .instructions {
      color: rgba(255, 255, 255, 0.5);
      font-size: 0.8rem;
      margin-top: 30px;
      line-height: 1.8;
    }

    .backlink {
      position: fixed;
      bottom: 10px;
      right: 15px;
      color: rgba(255,255,255,0.3);
      font-size: 0.6rem;
      text-decoration: none;
      z-index: 100;
    }
    .backlink:hover { color: #00ffff; }

    .best-score {
      position: fixed;
      top: 80px;
      left: 20px;
      font-size: 0.8rem;
      color: rgba(255, 255, 0, 0.7);
      z-index: 100;
      pointer-events: none;
    }
  </style>
</head>
<body>
  <canvas id="game"></canvas>

  <div class="ui">
    <div class="score" id="score">0</div>
    <div class="combo" id="combo">COMBO x2</div>
  </div>

  <div class="best-score" id="best-score"></div>
  <div class="lives" id="lives">‚ù§Ô∏è‚ù§Ô∏è‚ù§Ô∏è</div>

  <div class="start-screen" id="start-screen">
    <h1>NEON SLICE</h1>
    <p>Slice glowing shapes ‚Ä¢ Avoid bombs</p>
    <button class="btn" id="start-btn">START GAME</button>
    <div class="instructions">
      Swipe or drag to slice shapes<br>
      Don't let shapes fall!<br>
      Avoid the ‚ö´ bombs!
    </div>
  </div>

  <div class="game-over" id="game-over">
    <h1>GAME OVER</h1>
    <div class="final-score">Score: <span id="final-score">0</span></div>
    <button class="btn" id="restart-btn">PLAY AGAIN</button>
  </div>

  <a href="https://sloppy.live" class="backlink">sloppy.live</a>

  <script>
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');

    let W, H;
    function resize() {
      W = canvas.width = window.innerWidth;
      H = canvas.height = window.innerHeight;
    }
    resize();
    window.addEventListener('resize', resize);

    // Game state
    let gameRunning = false;
    let score = 0;
    let lives = 3;
    let combo = 0;
    let comboTimer = 0;
    let bestScore = parseInt(localStorage.getItem('neonSliceBest') || '0');
    let difficulty = 1;
    let time = 0;

    // Objects
    let shapes = [];
    let sliceTrail = [];
    let particles = [];
    let scorePopups = [];

    // Slice state
    let isSlicing = false;
    let lastX = 0, lastY = 0;

    // Shape types
    const shapeTypes = [
      { type: 'circle', color: '#00ffff', points: 10 },
      { type: 'square', color: '#ff00ff', points: 15 },
      { type: 'triangle', color: '#ffff00', points: 20 },
      { type: 'diamond', color: '#00ff66', points: 25 },
      { type: 'star', color: '#ff6600', points: 30 },
      { type: 'hexagon', color: '#ff0088', points: 35 }
    ];

    // Create shape
    function createShape() {
      const isBomb = Math.random() < 0.1 + difficulty * 0.02;

      if (isBomb) {
        return {
          x: Math.random() * (W - 100) + 50,
          y: H + 50,
          vx: (Math.random() - 0.5) * 4,
          vy: -12 - Math.random() * 6 - difficulty * 2,
          size: 35 + Math.random() * 15,
          rotation: 0,
          rotSpeed: (Math.random() - 0.5) * 0.1,
          type: 'bomb',
          color: '#333',
          glowColor: '#ff0000',
          sliced: false
        };
      }

      const shapeType = shapeTypes[Math.floor(Math.random() * shapeTypes.length)];

      return {
        x: Math.random() * (W - 100) + 50,
        y: H + 50,
        vx: (Math.random() - 0.5) * 6,
        vy: -14 - Math.random() * 8 - difficulty * 2,
        size: 30 + Math.random() * 25,
        rotation: 0,
        rotSpeed: (Math.random() - 0.5) * 0.15,
        type: shapeType.type,
        color: shapeType.color,
        glowColor: shapeType.color,
        points: shapeType.points,
        sliced: false
      };
    }

    // Create particles
    function createParticles(x, y, color, count) {
      for (let i = 0; i < count; i++) {
        const angle = Math.random() * Math.PI * 2;
        const speed = 3 + Math.random() * 8;
        particles.push({
          x, y,
          vx: Math.cos(angle) * speed,
          vy: Math.sin(angle) * speed,
          size: 3 + Math.random() * 6,
          color,
          life: 1
        });
      }
    }

    // Create score popup
    function createScorePopup(x, y, points, isCombo) {
      scorePopups.push({
        x, y,
        text: '+' + points,
        color: isCombo ? '#ff00ff' : '#00ffff',
        life: 1,
        scale: isCombo ? 1.5 : 1
      });
    }

    // Draw shape
    function drawShape(shape) {
      ctx.save();
      ctx.translate(shape.x, shape.y);
      ctx.rotate(shape.rotation);

      ctx.shadowBlur = 25;
      ctx.shadowColor = shape.glowColor;
      ctx.fillStyle = shape.color;
      ctx.strokeStyle = shape.glowColor;
      ctx.lineWidth = 3;

      const s = shape.size;

      switch (shape.type) {
        case 'circle':
          ctx.beginPath();
          ctx.arc(0, 0, s, 0, Math.PI * 2);
          ctx.fill();
          ctx.stroke();
          break;

        case 'square':
          ctx.beginPath();
          ctx.rect(-s, -s, s * 2, s * 2);
          ctx.fill();
          ctx.stroke();
          break;

        case 'triangle':
          ctx.beginPath();
          ctx.moveTo(0, -s);
          ctx.lineTo(s, s);
          ctx.lineTo(-s, s);
          ctx.closePath();
          ctx.fill();
          ctx.stroke();
          break;

        case 'diamond':
          ctx.beginPath();
          ctx.moveTo(0, -s);
          ctx.lineTo(s, 0);
          ctx.lineTo(0, s);
          ctx.lineTo(-s, 0);
          ctx.closePath();
          ctx.fill();
          ctx.stroke();
          break;

        case 'star':
          ctx.beginPath();
          for (let i = 0; i < 5; i++) {
            const angle = (i * 4 * Math.PI / 5) - Math.PI / 2;
            const x = Math.cos(angle) * s;
            const y = Math.sin(angle) * s;
            if (i === 0) ctx.moveTo(x, y);
            else ctx.lineTo(x, y);
          }
          ctx.closePath();
          ctx.fill();
          ctx.stroke();
          break;

        case 'hexagon':
          ctx.beginPath();
          for (let i = 0; i < 6; i++) {
            const angle = (i * Math.PI / 3) - Math.PI / 2;
            const x = Math.cos(angle) * s;
            const y = Math.sin(angle) * s;
            if (i === 0) ctx.moveTo(x, y);
            else ctx.lineTo(x, y);
          }
          ctx.closePath();
          ctx.fill();
          ctx.stroke();
          break;

        case 'bomb':
          // Bomb body
          ctx.fillStyle = '#222';
          ctx.beginPath();
          ctx.arc(0, 0, s, 0, Math.PI * 2);
          ctx.fill();

          // Skull face
          ctx.fillStyle = '#ff0000';
          ctx.shadowColor = '#ff0000';
          ctx.font = `${s}px sans-serif`;
          ctx.textAlign = 'center';
          ctx.textBaseline = 'middle';
          ctx.fillText('üíÄ', 0, 0);

          // Fuse
          ctx.strokeStyle = '#ff6600';
          ctx.lineWidth = 3;
          ctx.beginPath();
          ctx.moveTo(0, -s);
          ctx.quadraticCurveTo(s * 0.5, -s * 1.3, 0, -s * 1.5);
          ctx.stroke();

          // Spark
          ctx.fillStyle = '#ffff00';
          ctx.shadowColor = '#ffff00';
          ctx.beginPath();
          ctx.arc(0, -s * 1.5, 5 + Math.sin(time * 20) * 3, 0, Math.PI * 2);
          ctx.fill();
          break;
      }

      ctx.restore();
    }

    // Check line-circle intersection for slicing
    function lineIntersectsShape(x1, y1, x2, y2, shape) {
      const dx = shape.x - x1;
      const dy = shape.y - y1;
      const len = Math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2);
      if (len === 0) return false;

      const dot = (dx * (x2 - x1) + dy * (y2 - y1)) / len;
      const closestX = x1 + (dot / len) * (x2 - x1);
      const closestY = y1 + (dot / len) * (y2 - y1);

      const distToShape = Math.sqrt((closestX - shape.x) ** 2 + (closestY - shape.y) ** 2);

      return distToShape < shape.size * 1.2;
    }

    // Handle slicing
    function handleSlice(x, y) {
      if (!isSlicing) return;

      // Add to trail
      sliceTrail.push({ x, y, life: 1 });

      // Check for shape hits
      const sliceSpeed = Math.sqrt((x - lastX) ** 2 + (y - lastY) ** 2);

      if (sliceSpeed > 5) { // Only slice if moving fast enough
        shapes.forEach(shape => {
          if (!shape.sliced && lineIntersectsShape(lastX, lastY, x, y, shape)) {
            shape.sliced = true;

            if (shape.type === 'bomb') {
              // Hit a bomb - lose a life!
              lives--;
              updateLives();
              createParticles(shape.x, shape.y, '#ff0000', 30);
              combo = 0;
              updateCombo();

              if (lives <= 0) {
                gameOver();
              }
            } else {
              // Score!
              combo++;
              comboTimer = 60;

              const multiplier = Math.min(combo, 5);
              const points = shape.points * multiplier;
              score += points;

              updateScore();
              updateCombo();

              createParticles(shape.x, shape.y, shape.color, 20);
              createScorePopup(shape.x, shape.y, points, combo > 1);
            }
          }
        });
      }

      lastX = x;
      lastY = y;
    }

    // Input handlers
    canvas.addEventListener('mousedown', e => {
      isSlicing = true;
      lastX = e.clientX;
      lastY = e.clientY;
    });

    canvas.addEventListener('mousemove', e => {
      if (gameRunning) handleSlice(e.clientX, e.clientY);
    });

    canvas.addEventListener('mouseup', () => {
      isSlicing = false;
    });

    canvas.addEventListener('mouseleave', () => {
      isSlicing = false;
    });

    // Touch support
    canvas.addEventListener('touchstart', e => {
      e.preventDefault();
      isSlicing = true;
      lastX = e.touches[0].clientX;
      lastY = e.touches[0].clientY;
    });

    canvas.addEventListener('touchmove', e => {
      e.preventDefault();
      if (gameRunning) handleSlice(e.touches[0].clientX, e.touches[0].clientY);
    });

    canvas.addEventListener('touchend', () => {
      isSlicing = false;
    });

    // UI updates
    function updateScore() {
      document.getElementById('score').textContent = score;
    }

    function updateLives() {
      document.getElementById('lives').textContent = '‚ù§Ô∏è'.repeat(lives) + 'üñ§'.repeat(3 - lives);
    }

    function updateCombo() {
      const comboEl = document.getElementById('combo');
      if (combo > 1) {
        comboEl.textContent = `COMBO x${combo}`;
        comboEl.classList.add('active');
      } else {
        comboEl.classList.remove('active');
      }
    }

    function updateBestScore() {
      if (bestScore > 0) {
        document.getElementById('best-score').textContent = `BEST: ${bestScore}`;
      }
    }

    // Game over
    function gameOver() {
      gameRunning = false;

      if (score > bestScore) {
        bestScore = score;
        localStorage.setItem('neonSliceBest', bestScore.toString());
      }

      document.getElementById('final-score').textContent = score;
      document.getElementById('game-over').style.display = 'block';
      updateBestScore();
    }

    // Start game
    function startGame() {
      gameRunning = true;
      score = 0;
      lives = 3;
      combo = 0;
      comboTimer = 0;
      difficulty = 1;
      time = 0;
      shapes = [];
      particles = [];
      scorePopups = [];
      sliceTrail = [];

      updateScore();
      updateLives();
      updateCombo();

      document.getElementById('start-screen').style.display = 'none';
      document.getElementById('game-over').style.display = 'none';
    }

    // Button handlers
    document.getElementById('start-btn').addEventListener('click', startGame);
    document.getElementById('restart-btn').addEventListener('click', startGame);

    // Update
    function update(dt) {
      if (!gameRunning) return;

      time += dt;

      // Increase difficulty over time
      difficulty = 1 + Math.floor(time / 30) * 0.3;

      // Spawn shapes
      const spawnRate = 0.02 + difficulty * 0.01;
      if (Math.random() < spawnRate) {
        shapes.push(createShape());
      }

      // Update shapes
      shapes.forEach(shape => {
        shape.x += shape.vx;
        shape.vy += 0.3; // Gravity
        shape.y += shape.vy;
        shape.rotation += shape.rotSpeed;
      });

      // Remove fallen shapes (lose life if not sliced and not bomb)
      shapes = shapes.filter(shape => {
        if (shape.y > H + 100) {
          if (!shape.sliced && shape.type !== 'bomb') {
            lives--;
            updateLives();
            combo = 0;
            updateCombo();

            if (lives <= 0) {
              gameOver();
            }
          }
          return false;
        }
        return !shape.sliced || shape.y < H;
      });

      // Update particles
      particles.forEach(p => {
        p.x += p.vx;
        p.y += p.vy;
        p.vy += 0.2;
        p.life -= dt * 2;
      });
      particles = particles.filter(p => p.life > 0);

      // Update slice trail
      sliceTrail.forEach(t => {
        t.life -= dt * 5;
      });
      sliceTrail = sliceTrail.filter(t => t.life > 0);

      // Update score popups
      scorePopups.forEach(p => {
        p.y -= 2;
        p.life -= dt * 1.5;
      });
      scorePopups = scorePopups.filter(p => p.life > 0);

      // Update combo timer
      if (comboTimer > 0) {
        comboTimer--;
        if (comboTimer === 0) {
          combo = 0;
          updateCombo();
        }
      }
    }

    // Draw
    function draw() {
      // Clear
      ctx.fillStyle = '#050510';
      ctx.fillRect(0, 0, W, H);

      // Background grid
      ctx.strokeStyle = 'rgba(0, 255, 255, 0.03)';
      ctx.lineWidth = 1;
      for (let x = 0; x < W; x += 50) {
        ctx.beginPath();
        ctx.moveTo(x, 0);
        ctx.lineTo(x, H);
        ctx.stroke();
      }
      for (let y = 0; y < H; y += 50) {
        ctx.beginPath();
        ctx.moveTo(0, y);
        ctx.lineTo(W, y);
        ctx.stroke();
      }

      // Draw slice trail
      if (sliceTrail.length > 1) {
        ctx.save();
        ctx.lineCap = 'round';
        ctx.lineJoin = 'round';

        for (let i = 1; i < sliceTrail.length; i++) {
          const t1 = sliceTrail[i - 1];
          const t2 = sliceTrail[i];

          ctx.strokeStyle = `rgba(255, 255, 255, ${t2.life})`;
          ctx.shadowBlur = 20;
          ctx.shadowColor = '#ffffff';
          ctx.lineWidth = 4 * t2.life;

          ctx.beginPath();
          ctx.moveTo(t1.x, t1.y);
          ctx.lineTo(t2.x, t2.y);
          ctx.stroke();
        }
        ctx.restore();
      }

      // Draw shapes
      shapes.filter(s => !s.sliced).forEach(drawShape);

      // Draw particles
      particles.forEach(p => {
        ctx.save();
        ctx.globalAlpha = p.life;
        ctx.shadowBlur = 15;
        ctx.shadowColor = p.color;
        ctx.fillStyle = p.color;
        ctx.beginPath();
        ctx.arc(p.x, p.y, p.size * p.life, 0, Math.PI * 2);
        ctx.fill();
        ctx.restore();
      });

      // Draw score popups
      scorePopups.forEach(p => {
        ctx.save();
        ctx.globalAlpha = p.life;
        ctx.font = `${24 * p.scale}px Orbitron`;
        ctx.fillStyle = p.color;
        ctx.shadowBlur = 20;
        ctx.shadowColor = p.color;
        ctx.textAlign = 'center';
        ctx.fillText(p.text, p.x, p.y);
        ctx.restore();
      });
    }

    // Animation loop
    let lastTime = 0;
    function animate(timestamp) {
      requestAnimationFrame(animate);

      const dt = Math.min((timestamp - lastTime) / 1000, 0.1);
      lastTime = timestamp;

      update(dt);
      draw();
    }

    updateBestScore();
    animate(0);
  </script>
</body>
</html>
