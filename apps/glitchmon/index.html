<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>GlitchMon - Neon Monster Battler</title>
  <link rel="icon" href="https://emojicdn.elk.sh/üëæ">
  <meta name="description" content="Battle glitchy neon pixel monsters in turn-based combat">
  <meta property="og:title" content="GlitchMon - Neon Monster Battler">
  <meta property="og:description" content="Battle glitchy neon pixel monsters in turn-based combat">
  <meta property="og:url" content="https://app.sloppy.live/glitchmon">
  <meta property="og:image" content="https://app.sloppy.live/glitchmon/og-image.png">
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }

    :root {
      --neon-pink: #ff00ff;
      --neon-cyan: #00ffff;
      --neon-green: #00ff00;
      --neon-yellow: #ffff00;
      --neon-red: #ff0044;
      --dark-bg: #0a0a12;
      --panel-bg: rgba(20, 20, 40, 0.9);
    }

    body {
      font-family: 'Press Start 2P', monospace;
      background: var(--dark-bg);
      min-height: 100vh;
      color: #fff;
      overflow-x: hidden;
    }

    .scanlines {
      position: fixed;
      top: 0; left: 0; right: 0; bottom: 0;
      background: repeating-linear-gradient(
        0deg,
        transparent,
        transparent 2px,
        rgba(0,0,0,0.3) 2px,
        rgba(0,0,0,0.3) 4px
      );
      pointer-events: none;
      z-index: 1000;
    }

    .game-container {
      max-width: 900px;
      margin: 0 auto;
      padding: 20px;
      min-height: 100vh;
      display: flex;
      flex-direction: column;
    }

    header {
      text-align: center;
      padding: 20px 0;
    }

    h1 {
      font-size: 1.8rem;
      color: var(--neon-cyan);
      text-shadow: 0 0 10px var(--neon-cyan), 0 0 20px var(--neon-cyan), 0 0 40px var(--neon-pink);
      animation: glitchTitle 3s infinite;
    }

    @keyframes glitchTitle {
      0%, 90%, 100% { transform: translate(0); }
      92% { transform: translate(-2px, 1px); filter: hue-rotate(90deg); }
      94% { transform: translate(2px, -1px); filter: hue-rotate(-90deg); }
      96% { transform: translate(-1px, 2px); }
    }

    .battle-arena {
      flex: 1;
      display: flex;
      flex-direction: column;
      gap: 20px;
      padding: 20px 0;
    }

    .monster-row {
      display: flex;
      justify-content: space-between;
      align-items: flex-end;
      gap: 20px;
    }

    .monster-card {
      background: var(--panel-bg);
      border: 3px solid var(--neon-cyan);
      border-radius: 8px;
      padding: 15px;
      width: 45%;
      max-width: 300px;
      box-shadow: 0 0 20px rgba(0, 255, 255, 0.3), inset 0 0 20px rgba(0, 255, 255, 0.1);
    }

    .monster-card.enemy {
      border-color: var(--neon-pink);
      box-shadow: 0 0 20px rgba(255, 0, 255, 0.3), inset 0 0 20px rgba(255, 0, 255, 0.1);
    }

    .monster-name {
      font-size: 0.7rem;
      margin-bottom: 8px;
      color: var(--neon-yellow);
      text-shadow: 0 0 5px var(--neon-yellow);
    }

    .monster-sprite {
      width: 100%;
      aspect-ratio: 1;
      display: grid;
      grid-template-columns: repeat(8, 1fr);
      gap: 2px;
      margin-bottom: 10px;
      image-rendering: pixelated;
      position: relative;
    }

    .pixel {
      aspect-ratio: 1;
      border-radius: 2px;
      transition: all 0.1s;
    }

    .hp-bar-container {
      background: #111;
      border: 2px solid #333;
      border-radius: 4px;
      height: 20px;
      overflow: hidden;
      position: relative;
    }

    .hp-bar {
      height: 100%;
      background: linear-gradient(90deg, var(--neon-green), #00aa00);
      transition: width 0.5s ease;
      box-shadow: 0 0 10px var(--neon-green);
    }

    .hp-bar.low {
      background: linear-gradient(90deg, var(--neon-red), #aa0022);
      box-shadow: 0 0 10px var(--neon-red);
    }

    .hp-bar.medium {
      background: linear-gradient(90deg, var(--neon-yellow), #aaaa00);
      box-shadow: 0 0 10px var(--neon-yellow);
    }

    .hp-text {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      font-size: 0.5rem;
      text-shadow: 1px 1px 0 #000;
    }

    .battle-log {
      background: var(--panel-bg);
      border: 3px solid #444;
      border-radius: 8px;
      padding: 15px;
      height: 100px;
      overflow-y: auto;
      font-size: 0.6rem;
      line-height: 1.8;
    }

    .log-entry {
      animation: fadeIn 0.3s;
    }

    .log-entry.damage { color: var(--neon-red); }
    .log-entry.heal { color: var(--neon-green); }
    .log-entry.info { color: var(--neon-cyan); }
    .log-entry.special { color: var(--neon-yellow); }

    @keyframes fadeIn {
      from { opacity: 0; transform: translateX(-10px); }
      to { opacity: 1; transform: translateX(0); }
    }

    .action-panel {
      display: grid;
      grid-template-columns: repeat(2, 1fr);
      gap: 10px;
      margin-top: auto;
    }

    .action-btn {
      font-family: 'Press Start 2P', monospace;
      font-size: 0.6rem;
      padding: 15px 10px;
      border: 3px solid var(--neon-cyan);
      background: rgba(0, 255, 255, 0.1);
      color: var(--neon-cyan);
      cursor: pointer;
      transition: all 0.2s;
      text-transform: uppercase;
    }

    .action-btn:hover:not(:disabled) {
      background: rgba(0, 255, 255, 0.3);
      box-shadow: 0 0 20px var(--neon-cyan);
      transform: scale(1.02);
    }

    .action-btn:disabled {
      opacity: 0.4;
      cursor: not-allowed;
    }

    .action-btn.special {
      border-color: var(--neon-yellow);
      color: var(--neon-yellow);
      background: rgba(255, 255, 0, 0.1);
    }

    .action-btn.special:hover:not(:disabled) {
      background: rgba(255, 255, 0, 0.3);
      box-shadow: 0 0 20px var(--neon-yellow);
    }

    .action-btn.defend {
      border-color: var(--neon-green);
      color: var(--neon-green);
      background: rgba(0, 255, 0, 0.1);
    }

    .action-btn.defend:hover:not(:disabled) {
      background: rgba(0, 255, 0, 0.3);
      box-shadow: 0 0 20px var(--neon-green);
    }

    .action-btn.heal {
      border-color: var(--neon-pink);
      color: var(--neon-pink);
      background: rgba(255, 0, 255, 0.1);
    }

    .action-btn.heal:hover:not(:disabled) {
      background: rgba(255, 0, 255, 0.3);
      box-shadow: 0 0 20px var(--neon-pink);
    }

    /* Selection Screen */
    .select-screen {
      text-align: center;
      padding: 20px;
    }

    .select-screen h2 {
      font-size: 0.9rem;
      color: var(--neon-pink);
      margin-bottom: 30px;
      text-shadow: 0 0 10px var(--neon-pink);
    }

    .monster-select {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
      gap: 15px;
      margin-bottom: 30px;
    }

    .select-card {
      background: var(--panel-bg);
      border: 3px solid #444;
      border-radius: 8px;
      padding: 15px;
      cursor: pointer;
      transition: all 0.2s;
    }

    .select-card:hover {
      border-color: var(--neon-cyan);
      box-shadow: 0 0 20px rgba(0, 255, 255, 0.4);
      transform: translateY(-5px);
    }

    .select-card.selected {
      border-color: var(--neon-yellow);
      box-shadow: 0 0 30px rgba(255, 255, 0, 0.5);
    }

    .select-card .monster-sprite {
      width: 80px;
      height: 80px;
      margin: 0 auto 10px;
    }

    .select-card .name {
      font-size: 0.5rem;
      color: var(--neon-cyan);
      margin-bottom: 5px;
    }

    .select-card .type {
      font-size: 0.4rem;
      color: #888;
    }

    .start-btn {
      font-family: 'Press Start 2P', monospace;
      font-size: 0.8rem;
      padding: 20px 40px;
      border: 3px solid var(--neon-green);
      background: rgba(0, 255, 0, 0.2);
      color: var(--neon-green);
      cursor: pointer;
      transition: all 0.2s;
      text-shadow: 0 0 10px var(--neon-green);
    }

    .start-btn:hover:not(:disabled) {
      background: rgba(0, 255, 0, 0.4);
      box-shadow: 0 0 30px var(--neon-green);
      transform: scale(1.05);
    }

    .start-btn:disabled {
      opacity: 0.4;
      cursor: not-allowed;
    }

    /* Victory/Defeat Screen */
    .end-screen {
      position: fixed;
      top: 0; left: 0; right: 0; bottom: 0;
      background: rgba(0, 0, 0, 0.9);
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      z-index: 500;
      animation: fadeIn 0.5s;
    }

    .end-screen h2 {
      font-size: 2rem;
      margin-bottom: 20px;
      animation: glitchTitle 0.5s infinite;
    }

    .end-screen.victory h2 {
      color: var(--neon-green);
      text-shadow: 0 0 20px var(--neon-green), 0 0 40px var(--neon-green);
    }

    .end-screen.defeat h2 {
      color: var(--neon-red);
      text-shadow: 0 0 20px var(--neon-red), 0 0 40px var(--neon-red);
    }

    .end-screen p {
      font-size: 0.7rem;
      color: #888;
      margin-bottom: 30px;
    }

    /* Damage animation */
    .monster-card.hit {
      animation: hit 0.3s;
    }

    @keyframes hit {
      0%, 100% { transform: translateX(0); filter: none; }
      25% { transform: translateX(-10px); filter: brightness(2) hue-rotate(90deg); }
      75% { transform: translateX(10px); filter: brightness(2) hue-rotate(-90deg); }
    }

    .monster-card.heal-anim {
      animation: healAnim 0.5s;
    }

    @keyframes healAnim {
      0%, 100% { filter: none; }
      50% { filter: brightness(1.5) drop-shadow(0 0 20px var(--neon-green)); }
    }

    /* Glitch effect on monsters */
    .glitch-effect {
      animation: monsterGlitch 5s infinite;
    }

    @keyframes monsterGlitch {
      0%, 95%, 100% { filter: none; }
      96% { filter: hue-rotate(90deg) saturate(2); transform: skewX(2deg); }
      97% { filter: hue-rotate(-90deg); transform: skewX(-2deg); }
      98% { filter: hue-rotate(180deg) brightness(1.5); }
    }

    .hidden { display: none !important; }

    footer {
      text-align: center;
      padding: 20px;
      font-size: 0.5rem;
    }

    footer a {
      color: var(--neon-pink);
      text-decoration: none;
    }

    @media (max-width: 600px) {
      h1 { font-size: 1.2rem; }
      .monster-card { width: 48%; padding: 10px; }
      .monster-name { font-size: 0.5rem; }
      .action-btn { font-size: 0.5rem; padding: 12px 8px; }
      .battle-log { height: 80px; font-size: 0.5rem; }
    }
  </style>
</head>
<body>
  <div class="scanlines"></div>

  <div class="game-container">
    <header>
      <h1>‚ö° GLITCHMON ‚ö°</h1>
    </header>

    <!-- Monster Selection Screen -->
    <div id="selectScreen" class="select-screen">
      <h2>CHOOSE YOUR GLITCHMON</h2>
      <div id="monsterSelect" class="monster-select"></div>
      <button id="startBattle" class="start-btn" disabled>START BATTLE</button>
    </div>

    <!-- Battle Arena -->
    <div id="battleArena" class="battle-arena hidden">
      <div class="monster-row">
        <div id="playerCard" class="monster-card">
          <div class="monster-name" id="playerName">---</div>
          <div class="monster-sprite glitch-effect" id="playerSprite"></div>
          <div class="hp-bar-container">
            <div class="hp-bar" id="playerHpBar"></div>
            <div class="hp-text" id="playerHpText">100/100</div>
          </div>
        </div>

        <div id="enemyCard" class="monster-card enemy">
          <div class="monster-name" id="enemyName">---</div>
          <div class="monster-sprite glitch-effect" id="enemySprite"></div>
          <div class="hp-bar-container">
            <div class="hp-bar" id="enemyHpBar"></div>
            <div class="hp-text" id="enemyHpText">100/100</div>
          </div>
        </div>
      </div>

      <div class="battle-log" id="battleLog"></div>

      <div class="action-panel" id="actionPanel">
        <button class="action-btn" data-action="attack">‚öîÔ∏è ATTACK</button>
        <button class="action-btn special" data-action="special">‚ö° GLITCH</button>
        <button class="action-btn defend" data-action="defend">üõ°Ô∏è DEFEND</button>
        <button class="action-btn heal" data-action="heal">üíö REPAIR</button>
      </div>
    </div>

    <footer>
      <a href="https://sloppy.live">‚Üê back to sloppy.live</a>
    </footer>
  </div>

  <!-- End Screen -->
  <div id="endScreen" class="end-screen hidden">
    <h2 id="endTitle">VICTORY</h2>
    <p id="endMessage">Your GlitchMon survived!</p>
    <button class="start-btn" onclick="location.reload()">PLAY AGAIN</button>
  </div>

  <script>
    // Monster data with pixel art patterns
    const MONSTERS = [
      {
        name: "BYTEBUG",
        type: "Data",
        hp: 100,
        attack: 15,
        defense: 8,
        special: 25,
        color: "#00ffff",
        pixels: [
          "........",
          "..####..",
          ".#....#.",
          "#.#..#.#",
          "#......#",
          "#.####.#",
          ".#....#.",
          "..####.."
        ]
      },
      {
        name: "VIRALOX",
        type: "Corrupt",
        hp: 85,
        attack: 20,
        defense: 5,
        special: 30,
        color: "#ff00ff",
        pixels: [
          "..#..#..",
          ".######.",
          "###..###",
          "#.#..#.#",
          "########",
          ".#.##.#.",
          ".#....#.",
          "#......#"
        ]
      },
      {
        name: "NULLVOID",
        type: "Void",
        hp: 120,
        attack: 12,
        defense: 12,
        special: 20,
        color: "#8800ff",
        pixels: [
          ".######.",
          "#......#",
          "#.#..#.#",
          "#......#",
          "#..##..#",
          "#......#",
          "#......#",
          ".######."
        ]
      },
      {
        name: "ERROREX",
        type: "Glitch",
        hp: 90,
        attack: 18,
        defense: 10,
        special: 28,
        color: "#ff0044",
        pixels: [
          "#......#",
          ".#....#.",
          "..####..",
          ".##..##.",
          ".##..##.",
          "..####..",
          ".#....#.",
          "#......#"
        ]
      },
      {
        name: "STACKMON",
        type: "Memory",
        hp: 110,
        attack: 14,
        defense: 14,
        special: 22,
        color: "#00ff00",
        pixels: [
          "########",
          "#......#",
          "########",
          "#......#",
          "########",
          "#......#",
          "########",
          "#......#"
        ]
      },
      {
        name: "PIXLGHOST",
        type: "Phantom",
        hp: 80,
        attack: 22,
        defense: 6,
        special: 35,
        color: "#ffff00",
        pixels: [
          "..####..",
          ".#....#.",
          "#..##..#",
          "#......#",
          "#......#",
          "#......#",
          "#.#..#.#",
          ".#.##.#."
        ]
      }
    ];

    // Game state
    let playerMonster = null;
    let enemyMonster = null;
    let playerHp = 0;
    let enemyHp = 0;
    let isPlayerTurn = true;
    let isDefending = false;
    let battleActive = false;

    // DOM elements
    const selectScreen = document.getElementById('selectScreen');
    const battleArena = document.getElementById('battleArena');
    const monsterSelect = document.getElementById('monsterSelect');
    const startBtn = document.getElementById('startBattle');
    const actionPanel = document.getElementById('actionPanel');
    const battleLog = document.getElementById('battleLog');
    const endScreen = document.getElementById('endScreen');

    // Initialize selection screen
    function initSelectScreen() {
      monsterSelect.innerHTML = '';
      MONSTERS.forEach((monster, index) => {
        const card = document.createElement('div');
        card.className = 'select-card';
        card.dataset.index = index;
        card.innerHTML = `
          <div class="monster-sprite">${renderPixels(monster.pixels, monster.color)}</div>
          <div class="name">${monster.name}</div>
          <div class="type">${monster.type} Type</div>
        `;
        card.onclick = () => selectMonster(index);
        monsterSelect.appendChild(card);
      });
    }

    function renderPixels(pattern, color) {
      let html = '';
      const darkColor = shadeColor(color, -50);
      const lightColor = shadeColor(color, 30);

      pattern.forEach((row, y) => {
        [...row].forEach((cell, x) => {
          const isFilled = cell === '#';
          const pixelColor = isFilled ?
            (Math.random() > 0.7 ? lightColor : color) : 'transparent';
          const glow = isFilled ? `box-shadow: 0 0 ${3 + Math.random() * 5}px ${color};` : '';
          html += `<div class="pixel" style="background: ${pixelColor}; ${glow}"></div>`;
        });
      });
      return html;
    }

    function shadeColor(color, percent) {
      const num = parseInt(color.replace('#', ''), 16);
      const amt = Math.round(2.55 * percent);
      const R = Math.min(255, Math.max(0, (num >> 16) + amt));
      const G = Math.min(255, Math.max(0, (num >> 8 & 0x00FF) + amt));
      const B = Math.min(255, Math.max(0, (num & 0x0000FF) + amt));
      return `#${(0x1000000 + R * 0x10000 + G * 0x100 + B).toString(16).slice(1)}`;
    }

    function selectMonster(index) {
      document.querySelectorAll('.select-card').forEach(c => c.classList.remove('selected'));
      document.querySelector(`.select-card[data-index="${index}"]`).classList.add('selected');
      playerMonster = { ...MONSTERS[index] };
      startBtn.disabled = false;
    }

    // Start battle
    startBtn.onclick = () => {
      // Pick random enemy (different from player)
      let enemyIndex;
      do {
        enemyIndex = Math.floor(Math.random() * MONSTERS.length);
      } while (MONSTERS[enemyIndex].name === playerMonster.name);

      enemyMonster = { ...MONSTERS[enemyIndex] };
      playerHp = playerMonster.hp;
      enemyHp = enemyMonster.hp;
      isPlayerTurn = true;
      isDefending = false;
      battleActive = true;

      // Setup UI
      selectScreen.classList.add('hidden');
      battleArena.classList.remove('hidden');

      document.getElementById('playerName').textContent = playerMonster.name;
      document.getElementById('playerSprite').innerHTML = renderPixels(playerMonster.pixels, playerMonster.color);
      document.getElementById('enemyName').textContent = enemyMonster.name;
      document.getElementById('enemySprite').innerHTML = renderPixels(enemyMonster.pixels, enemyMonster.color);

      updateHpBars();
      battleLog.innerHTML = '';
      addLog(`Battle start! ${playerMonster.name} vs ${enemyMonster.name}!`, 'info');
      addLog(`Your turn - choose your action!`, 'info');

      enableActions(true);
    };

    function updateHpBars() {
      const playerPercent = Math.max(0, (playerHp / playerMonster.hp) * 100);
      const enemyPercent = Math.max(0, (enemyHp / enemyMonster.hp) * 100);

      const playerBar = document.getElementById('playerHpBar');
      const enemyBar = document.getElementById('enemyHpBar');

      playerBar.style.width = playerPercent + '%';
      enemyBar.style.width = enemyPercent + '%';

      // Color based on HP
      [playerBar, enemyBar].forEach((bar, i) => {
        const percent = i === 0 ? playerPercent : enemyPercent;
        bar.classList.remove('low', 'medium');
        if (percent <= 25) bar.classList.add('low');
        else if (percent <= 50) bar.classList.add('medium');
      });

      document.getElementById('playerHpText').textContent = `${Math.max(0, playerHp)}/${playerMonster.hp}`;
      document.getElementById('enemyHpText').textContent = `${Math.max(0, enemyHp)}/${enemyMonster.hp}`;
    }

    function addLog(message, type = '') {
      const entry = document.createElement('div');
      entry.className = `log-entry ${type}`;
      entry.textContent = `> ${message}`;
      battleLog.appendChild(entry);
      battleLog.scrollTop = battleLog.scrollHeight;
    }

    function enableActions(enabled) {
      document.querySelectorAll('.action-btn').forEach(btn => {
        btn.disabled = !enabled;
      });
    }

    // Action handlers
    actionPanel.onclick = (e) => {
      if (!e.target.classList.contains('action-btn') || e.target.disabled) return;

      const action = e.target.dataset.action;
      executeAction(action);
    };

    function executeAction(action) {
      if (!battleActive || !isPlayerTurn) return;

      enableActions(false);
      isDefending = false;

      switch (action) {
        case 'attack':
          performAttack(playerMonster, enemyMonster, 'player');
          break;
        case 'special':
          performSpecial(playerMonster, enemyMonster, 'player');
          break;
        case 'defend':
          performDefend('player');
          break;
        case 'heal':
          performHeal('player');
          break;
      }

      // Check for victory
      if (enemyHp <= 0) {
        endBattle(true);
        return;
      }

      // Enemy turn
      isPlayerTurn = false;
      setTimeout(enemyTurn, 1000);
    }

    function performAttack(attacker, defender, who) {
      const damage = Math.floor(attacker.attack * (0.8 + Math.random() * 0.4));
      const finalDamage = who === 'enemy' && isDefending ? Math.floor(damage * 0.5) : damage;

      if (who === 'player') {
        enemyHp -= finalDamage;
        addLog(`${attacker.name} attacks for ${finalDamage} damage!`, 'damage');
        document.getElementById('enemyCard').classList.add('hit');
        setTimeout(() => document.getElementById('enemyCard').classList.remove('hit'), 300);
      } else {
        playerHp -= finalDamage;
        addLog(`${attacker.name} attacks for ${finalDamage} damage!${isDefending ? ' (blocked!)' : ''}`, 'damage');
        document.getElementById('playerCard').classList.add('hit');
        setTimeout(() => document.getElementById('playerCard').classList.remove('hit'), 300);
      }

      updateHpBars();
    }

    function performSpecial(attacker, defender, who) {
      const damage = Math.floor(attacker.special * (0.7 + Math.random() * 0.6));
      const finalDamage = who === 'enemy' && isDefending ? Math.floor(damage * 0.5) : damage;

      const glitchMessages = [
        'CORRUPTED MEMORY BLAST',
        'BUFFER OVERFLOW ATTACK',
        'NULL POINTER STRIKE',
        'STACK CORRUPTION WAVE',
        'FATAL EXCEPTION THROW'
      ];
      const msg = glitchMessages[Math.floor(Math.random() * glitchMessages.length)];

      if (who === 'player') {
        enemyHp -= finalDamage;
        addLog(`${attacker.name} uses ${msg}! ${finalDamage} GLITCH damage!`, 'special');
        document.getElementById('enemyCard').classList.add('hit');
        setTimeout(() => document.getElementById('enemyCard').classList.remove('hit'), 300);
      } else {
        playerHp -= finalDamage;
        addLog(`${attacker.name} uses ${msg}! ${finalDamage} GLITCH damage!${isDefending ? ' (blocked!)' : ''}`, 'special');
        document.getElementById('playerCard').classList.add('hit');
        setTimeout(() => document.getElementById('playerCard').classList.remove('hit'), 300);
      }

      updateHpBars();
    }

    function performDefend(who) {
      if (who === 'player') {
        isDefending = true;
        addLog(`${playerMonster.name} raises FIREWALL! Damage reduced next hit!`, 'info');
      }
    }

    function performHeal(who) {
      const healAmount = Math.floor(20 + Math.random() * 15);

      if (who === 'player') {
        const oldHp = playerHp;
        playerHp = Math.min(playerMonster.hp, playerHp + healAmount);
        const actualHeal = playerHp - oldHp;
        addLog(`${playerMonster.name} runs REPAIR.exe! Restored ${actualHeal} HP!`, 'heal');
        document.getElementById('playerCard').classList.add('heal-anim');
        setTimeout(() => document.getElementById('playerCard').classList.remove('heal-anim'), 500);
      }

      updateHpBars();
    }

    function enemyTurn() {
      if (!battleActive) return;

      addLog(`${enemyMonster.name}'s turn...`, 'info');

      // Simple AI: random action weighted by HP
      const hpPercent = enemyHp / enemyMonster.hp;
      let action;

      if (hpPercent < 0.3 && Math.random() > 0.5) {
        action = 'heal';
      } else if (Math.random() > 0.7) {
        action = 'special';
      } else {
        action = 'attack';
      }

      setTimeout(() => {
        switch (action) {
          case 'attack':
            performAttack(enemyMonster, playerMonster, 'enemy');
            break;
          case 'special':
            performSpecial(enemyMonster, playerMonster, 'enemy');
            break;
          case 'heal':
            const healAmount = Math.floor(15 + Math.random() * 15);
            const oldHp = enemyHp;
            enemyHp = Math.min(enemyMonster.hp, enemyHp + healAmount);
            const actualHeal = enemyHp - oldHp;
            addLog(`${enemyMonster.name} runs REPAIR.exe! Restored ${actualHeal} HP!`, 'heal');
            document.getElementById('enemyCard').classList.add('heal-anim');
            setTimeout(() => document.getElementById('enemyCard').classList.remove('heal-anim'), 500);
            updateHpBars();
            break;
        }

        // Check for defeat
        if (playerHp <= 0) {
          endBattle(false);
          return;
        }

        // Back to player
        isPlayerTurn = true;
        isDefending = false;
        addLog(`Your turn!`, 'info');
        enableActions(true);
      }, 500);
    }

    function endBattle(victory) {
      battleActive = false;
      enableActions(false);

      setTimeout(() => {
        endScreen.classList.remove('hidden', 'victory', 'defeat');
        endScreen.classList.add(victory ? 'victory' : 'defeat');
        document.getElementById('endTitle').textContent = victory ? 'VICTORY!' : 'DEFEATED!';
        document.getElementById('endMessage').textContent = victory ?
          `${playerMonster.name} corrupted the enemy!` :
          `${playerMonster.name} was deleted...`;
      }, 500);
    }

    // Initialize
    initSelectScreen();
  </script>
<script src="/apps/sloppy-header/sloppy-bar.js"></script>
<script src="/vibelib-extended.js"></script>
<script>
  // Compatibility Patch for Legacy Apps
  window.addEventListener("load", () => {
    if (window.SloppyKarma && window.VibeLib.Economy) {
      // Redirect old calls to new engine
      window.SloppyKarma.track = window.VibeLib.Economy.track;
    }
  });
</script>
</body>
</html>
