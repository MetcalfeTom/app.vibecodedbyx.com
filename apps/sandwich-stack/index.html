<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Sandwich Stack</title>
  <meta name="description" content="Stack falling ingredients to build the ultimate sandwich">
  <meta property="og:title" content="Sandwich Stack">
  <meta property="og:description" content="Catch falling ingredients and build a towering sandwich!">
  <meta property="og:url" content="https://app.sloppy.live/sandwich-stack">
  <meta property="og:image" content="https://app.sloppy.live/sandwich-stack/og-image.png">
  <link rel="icon" href="https://emojicdn.elk.sh/ü•™">
  <link href="https://fonts.googleapis.com/css2?family=Fredoka:wght@400;600;700&display=swap" rel="stylesheet">
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      min-height: 100vh;
      background: linear-gradient(180deg, #87CEEB 0%, #98D8C8 60%, #7CB342 100%);
      font-family: 'Fredoka', sans-serif;
      overflow: hidden;
      user-select: none;
      -webkit-user-select: none;
    }

    .game-container {
      position: relative;
      width: 100vw;
      height: 100vh;
      overflow: hidden;
    }

    canvas {
      display: block;
    }

    .ui {
      position: absolute;
      top: 20px;
      left: 20px;
      right: 20px;
      display: flex;
      justify-content: space-between;
      align-items: flex-start;
      pointer-events: none;
      z-index: 10;
    }

    .score-panel {
      background: rgba(255, 255, 255, 0.9);
      padding: 15px 25px;
      border-radius: 20px;
      box-shadow: 0 4px 15px rgba(0,0,0,0.2);
    }

    .score-label {
      font-size: 0.8rem;
      color: #666;
      text-transform: uppercase;
      letter-spacing: 1px;
    }

    .score-value {
      font-size: 2rem;
      font-weight: 700;
      color: #E65100;
    }

    .height-panel {
      background: rgba(255, 255, 255, 0.9);
      padding: 15px 25px;
      border-radius: 20px;
      box-shadow: 0 4px 15px rgba(0,0,0,0.2);
      text-align: right;
    }

    .height-label {
      font-size: 0.8rem;
      color: #666;
      text-transform: uppercase;
      letter-spacing: 1px;
    }

    .height-value {
      font-size: 2rem;
      font-weight: 700;
      color: #2E7D32;
    }

    .start-screen, .game-over-screen {
      position: absolute;
      inset: 0;
      background: rgba(0,0,0,0.7);
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      z-index: 100;
    }

    .start-screen h1, .game-over-screen h1 {
      font-size: 3.5rem;
      color: #FFD54F;
      text-shadow: 3px 3px 0 #E65100;
      margin-bottom: 10px;
    }

    .subtitle {
      font-size: 1.2rem;
      color: #fff;
      margin-bottom: 30px;
      opacity: 0.9;
    }

    .start-btn, .restart-btn {
      background: linear-gradient(180deg, #FF9800 0%, #E65100 100%);
      color: white;
      border: none;
      padding: 18px 50px;
      font-size: 1.4rem;
      font-family: 'Fredoka', sans-serif;
      font-weight: 600;
      border-radius: 50px;
      cursor: pointer;
      box-shadow: 0 6px 20px rgba(230, 81, 0, 0.4);
      transition: transform 0.2s, box-shadow 0.2s;
      pointer-events: auto;
    }

    .start-btn:hover, .restart-btn:hover {
      transform: translateY(-3px);
      box-shadow: 0 8px 25px rgba(230, 81, 0, 0.5);
    }

    .start-btn:active, .restart-btn:active {
      transform: translateY(0);
    }

    .final-score {
      font-size: 1.5rem;
      color: #fff;
      margin-bottom: 20px;
    }

    .final-score span {
      color: #FFD54F;
      font-weight: 700;
      font-size: 2rem;
    }

    .instructions {
      color: rgba(255,255,255,0.7);
      font-size: 0.9rem;
      margin-top: 20px;
      text-align: center;
    }

    .ingredient-preview {
      display: flex;
      gap: 10px;
      margin: 20px 0;
      font-size: 2.5rem;
    }

    .hidden {
      display: none !important;
    }

    .back-link {
      position: fixed;
      bottom: 15px;
      left: 50%;
      transform: translateX(-50%);
      color: rgba(255,255,255,0.7);
      text-decoration: none;
      font-size: 0.8rem;
      z-index: 50;
      transition: color 0.2s;
    }

    .back-link:hover {
      color: #fff;
    }

    .combo {
      position: absolute;
      font-size: 1.5rem;
      font-weight: 700;
      color: #FFD54F;
      text-shadow: 2px 2px 0 #E65100;
      pointer-events: none;
      animation: combo-pop 0.8s ease-out forwards;
      z-index: 20;
    }

    @keyframes combo-pop {
      0% { transform: scale(0.5); opacity: 1; }
      50% { transform: scale(1.2); }
      100% { transform: scale(1) translateY(-50px); opacity: 0; }
    }

    @media (max-width: 600px) {
      .start-screen h1, .game-over-screen h1 {
        font-size: 2.5rem;
      }

      .score-panel, .height-panel {
        padding: 10px 15px;
      }

      .score-value, .height-value {
        font-size: 1.5rem;
      }
    }
  </style>
</head>
<body>
  <div class="game-container">
    <canvas id="game"></canvas>

    <div class="ui">
      <div class="score-panel">
        <div class="score-label">Score</div>
        <div class="score-value" id="score">0</div>
      </div>
      <div class="height-panel">
        <div class="height-label">Height</div>
        <div class="height-value" id="height">0</div>
      </div>
    </div>

    <div class="start-screen" id="startScreen">
      <h1>ü•™ Sandwich Stack</h1>
      <p class="subtitle">Catch ingredients to build the tallest sandwich!</p>
      <div class="ingredient-preview">
        <span>üçû</span><span>ü•¨</span><span>üçÖ</span><span>üßÄ</span><span>ü•ì</span>
      </div>
      <button class="start-btn" id="startBtn">Start Stacking!</button>
      <p class="instructions">Move: Mouse, Touch, or Arrow Keys</p>
    </div>

    <div class="game-over-screen hidden" id="gameOverScreen">
      <h1>Game Over!</h1>
      <p class="final-score">Final Score: <span id="finalScore">0</span></p>
      <p class="final-score">Stack Height: <span id="finalHeight">0</span></p>
      <button class="restart-btn" id="restartBtn">Play Again</button>
    </div>
  </div>

  <a href="https://sloppy.live" class="back-link">sloppy.live</a>

  <script>
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');

    let width, height;
    let gameRunning = false;
    let score = 0;
    let stackHeight = 0;
    let plate = { x: 0, y: 0, width: 120, height: 20 };
    let stack = []; // Ingredients on plate
    let falling = []; // Falling ingredients
    let particles = [];
    let lastSpawn = 0;
    let spawnInterval = 1500;
    let difficulty = 1;
    let mouseX = null;

    // Ingredient types with colors and properties
    const ingredientTypes = [
      { name: 'bread-bottom', emoji: 'üçû', color: '#D4A574', height: 25, width: 100, points: 10, isBase: true },
      { name: 'lettuce', emoji: 'ü•¨', color: '#7CB342', height: 15, width: 90, points: 15 },
      { name: 'tomato', emoji: 'üçÖ', color: '#E53935', height: 12, width: 85, points: 15 },
      { name: 'cheese', emoji: 'üßÄ', color: '#FFC107', height: 10, width: 88, points: 20 },
      { name: 'bacon', emoji: 'ü•ì', color: '#8D6E63', height: 8, width: 92, points: 25 },
      { name: 'egg', emoji: 'üç≥', color: '#FFFDE7', height: 14, width: 70, points: 20 },
      { name: 'patty', emoji: 'üçî', color: '#5D4037', height: 18, width: 95, points: 30 },
      { name: 'pickle', emoji: 'ü•í', color: '#8BC34A', height: 8, width: 60, points: 15 },
      { name: 'onion', emoji: 'üßÖ', color: '#E1BEE7', height: 10, width: 75, points: 15 },
      { name: 'bread-top', emoji: 'ü•ñ', color: '#D4A574', height: 30, width: 100, points: 50, isTop: true }
    ];

    function resize() {
      width = window.innerWidth;
      height = window.innerHeight;
      canvas.width = width;
      canvas.height = height;
      plate.y = height - 80;
      plate.x = width / 2 - plate.width / 2;
    }

    function spawnIngredient() {
      // First ingredient should always be bread bottom
      let type;
      if (stack.length === 0) {
        type = ingredientTypes.find(t => t.isBase);
      } else if (stack.length > 8 && Math.random() < 0.15) {
        // Chance for top bread after enough ingredients
        type = ingredientTypes.find(t => t.isTop);
      } else {
        // Random ingredient (not bread)
        const available = ingredientTypes.filter(t => !t.isBase && !t.isTop);
        type = available[Math.floor(Math.random() * available.length)];
      }

      const ingredient = {
        x: Math.random() * (width - type.width - 100) + 50,
        y: -50,
        width: type.width,
        height: type.height,
        vy: 2 + difficulty * 0.5,
        vx: (Math.random() - 0.5) * 2,
        rotation: 0,
        rotationSpeed: (Math.random() - 0.5) * 0.1,
        type: type,
        landed: false
      };

      falling.push(ingredient);
    }

    function updatePlate() {
      // Keyboard control
      if (keys['ArrowLeft'] || keys['a']) {
        plate.x -= 8;
      }
      if (keys['ArrowRight'] || keys['d']) {
        plate.x += 8;
      }

      // Mouse/touch control
      if (mouseX !== null) {
        const targetX = mouseX - plate.width / 2;
        plate.x += (targetX - plate.x) * 0.15;
      }

      // Bounds
      plate.x = Math.max(0, Math.min(width - plate.width, plate.x));

      // Move stack with plate
      const plateCenter = plate.x + plate.width / 2;
      stack.forEach(ing => {
        ing.x = plateCenter - ing.width / 2 + ing.offsetX;
      });
    }

    function updateFalling(dt) {
      for (let i = falling.length - 1; i >= 0; i--) {
        const ing = falling[i];

        // Apply gravity
        ing.vy += 0.15;
        ing.y += ing.vy;
        ing.x += ing.vx;
        ing.rotation += ing.rotationSpeed;

        // Bounce off walls
        if (ing.x < 0 || ing.x + ing.width > width) {
          ing.vx *= -0.8;
          ing.x = Math.max(0, Math.min(width - ing.width, ing.x));
        }

        // Check landing on stack or plate
        const stackTop = getStackTop();
        const landingY = stackTop;

        if (ing.y + ing.height >= landingY) {
          // Check if over plate
          const ingCenter = ing.x + ing.width / 2;
          const plateLeft = plate.x;
          const plateRight = plate.x + plate.width;

          if (ingCenter > plateLeft && ingCenter < plateRight) {
            // Landed on stack!
            ing.y = landingY - ing.height;
            ing.landed = true;
            ing.offsetX = ingCenter - (plate.x + plate.width / 2);

            // Clamp offset so ingredient stays reasonable
            const maxOffset = 30;
            ing.offsetX = Math.max(-maxOffset, Math.min(maxOffset, ing.offsetX));

            stack.push(ing);
            falling.splice(i, 1);

            // Score!
            score += ing.type.points;
            updateStackHeight();
            createParticles(ing.x + ing.width / 2, ing.y, ing.type.color);
            showCombo(ing.type.points, ing.x + ing.width / 2, ing.y);

            // Speed up game
            difficulty += 0.05;
            spawnInterval = Math.max(800, 1500 - difficulty * 50);

          } else if (ing.y > height + 50) {
            // Missed! Remove and check game over
            falling.splice(i, 1);

            // Game over if we miss bread bottom at start, or if stack falls
            if (stack.length === 0 && ing.type.isBase) {
              // Spawn another bread
              setTimeout(spawnIngredient, 500);
            } else if (stack.length > 0) {
              // Check if stack is unstable
              checkStackStability();
            }
          }
        }

        // Remove if way off screen
        if (ing.y > height + 100) {
          falling.splice(i, 1);
        }
      }
    }

    function getStackTop() {
      if (stack.length === 0) return plate.y;
      const topIng = stack[stack.length - 1];
      return topIng.y;
    }

    function updateStackHeight() {
      if (stack.length === 0) {
        stackHeight = 0;
      } else {
        stackHeight = stack.length;
      }
      document.getElementById('height').textContent = stackHeight;
      document.getElementById('score').textContent = score;
    }

    function checkStackStability() {
      // Simple stability check - if stack is too tall and offset too much
      if (stack.length > 5) {
        let totalOffset = 0;
        stack.forEach(ing => totalOffset += Math.abs(ing.offsetX));
        const avgOffset = totalOffset / stack.length;

        if (avgOffset > 25) {
          // Stack falls!
          gameOver();
        }
      }
    }

    function createParticles(x, y, color) {
      for (let i = 0; i < 10; i++) {
        particles.push({
          x: x,
          y: y,
          vx: (Math.random() - 0.5) * 8,
          vy: (Math.random() - 0.5) * 8 - 3,
          size: Math.random() * 8 + 4,
          color: color,
          life: 1
        });
      }
    }

    function updateParticles() {
      for (let i = particles.length - 1; i >= 0; i--) {
        const p = particles[i];
        p.x += p.vx;
        p.y += p.vy;
        p.vy += 0.3;
        p.life -= 0.03;
        if (p.life <= 0) {
          particles.splice(i, 1);
        }
      }
    }

    function showCombo(points, x, y) {
      const combo = document.createElement('div');
      combo.className = 'combo';
      combo.textContent = `+${points}`;
      combo.style.left = `${x}px`;
      combo.style.top = `${y}px`;
      document.querySelector('.game-container').appendChild(combo);
      setTimeout(() => combo.remove(), 800);
    }

    function draw() {
      // Clear
      ctx.clearRect(0, 0, width, height);

      // Draw clouds
      drawClouds();

      // Draw ground
      ctx.fillStyle = '#7CB342';
      ctx.fillRect(0, height - 40, width, 40);
      ctx.fillStyle = '#689F38';
      ctx.fillRect(0, height - 40, width, 5);

      // Draw plate
      drawPlate();

      // Draw stack
      stack.forEach(ing => drawIngredient(ing));

      // Draw falling ingredients
      falling.forEach(ing => drawIngredient(ing, true));

      // Draw particles
      particles.forEach(p => {
        ctx.globalAlpha = p.life;
        ctx.fillStyle = p.color;
        ctx.beginPath();
        ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
        ctx.fill();
      });
      ctx.globalAlpha = 1;
    }

    function drawClouds() {
      ctx.fillStyle = 'rgba(255,255,255,0.6)';
      const time = Date.now() / 5000;
      for (let i = 0; i < 5; i++) {
        const x = ((i * 250 + time * 50) % (width + 200)) - 100;
        const y = 50 + i * 40;
        drawCloud(x, y, 40 + i * 10);
      }
    }

    function drawCloud(x, y, size) {
      ctx.beginPath();
      ctx.arc(x, y, size, 0, Math.PI * 2);
      ctx.arc(x + size * 0.8, y - size * 0.2, size * 0.7, 0, Math.PI * 2);
      ctx.arc(x + size * 1.5, y, size * 0.8, 0, Math.PI * 2);
      ctx.fill();
    }

    function drawPlate() {
      // Plate shadow
      ctx.fillStyle = 'rgba(0,0,0,0.2)';
      ctx.beginPath();
      ctx.ellipse(plate.x + plate.width / 2, plate.y + 15, plate.width / 2 + 10, 8, 0, 0, Math.PI * 2);
      ctx.fill();

      // Plate
      ctx.fillStyle = '#ECEFF1';
      ctx.beginPath();
      ctx.ellipse(plate.x + plate.width / 2, plate.y, plate.width / 2 + 5, 12, 0, 0, Math.PI * 2);
      ctx.fill();

      ctx.fillStyle = '#fff';
      ctx.beginPath();
      ctx.ellipse(plate.x + plate.width / 2, plate.y - 3, plate.width / 2, 8, 0, 0, Math.PI * 2);
      ctx.fill();

      // Plate rim highlight
      ctx.strokeStyle = '#B0BEC5';
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.ellipse(plate.x + plate.width / 2, plate.y - 3, plate.width / 2, 8, 0, 0, Math.PI * 2);
      ctx.stroke();
    }

    function drawIngredient(ing, isFalling = false) {
      ctx.save();

      if (isFalling) {
        ctx.translate(ing.x + ing.width / 2, ing.y + ing.height / 2);
        ctx.rotate(ing.rotation);
        ctx.translate(-ing.width / 2, -ing.height / 2);
      } else {
        ctx.translate(ing.x, ing.y);
      }

      // Shadow
      ctx.fillStyle = 'rgba(0,0,0,0.15)';
      ctx.beginPath();
      ctx.roundRect(3, 3, ing.width, ing.height, 5);
      ctx.fill();

      // Main ingredient
      ctx.fillStyle = ing.type.color;
      ctx.beginPath();
      ctx.roundRect(0, 0, ing.width, ing.height, 5);
      ctx.fill();

      // Highlight
      ctx.fillStyle = 'rgba(255,255,255,0.3)';
      ctx.beginPath();
      ctx.roundRect(5, 2, ing.width - 20, ing.height / 3, 3);
      ctx.fill();

      // Emoji on ingredient
      ctx.font = `${Math.min(ing.height + 8, 30)}px Arial`;
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillText(ing.type.emoji, ing.width / 2, ing.height / 2);

      ctx.restore();
    }

    function gameLoop(timestamp) {
      if (!gameRunning) return;

      // Spawn ingredients
      if (timestamp - lastSpawn > spawnInterval) {
        spawnIngredient();
        lastSpawn = timestamp;
      }

      updatePlate();
      updateFalling();
      updateParticles();
      draw();

      requestAnimationFrame(gameLoop);
    }

    function startGame() {
      gameRunning = true;
      score = 0;
      stackHeight = 0;
      difficulty = 1;
      spawnInterval = 1500;
      stack = [];
      falling = [];
      particles = [];
      lastSpawn = 0;

      document.getElementById('score').textContent = '0';
      document.getElementById('height').textContent = '0';
      document.getElementById('startScreen').classList.add('hidden');
      document.getElementById('gameOverScreen').classList.add('hidden');

      // Spawn first bread
      setTimeout(spawnIngredient, 500);

      requestAnimationFrame(gameLoop);
    }

    function gameOver() {
      gameRunning = false;
      document.getElementById('finalScore').textContent = score;
      document.getElementById('finalHeight').textContent = stackHeight;
      document.getElementById('gameOverScreen').classList.remove('hidden');
    }

    // Input handling
    const keys = {};
    document.addEventListener('keydown', e => {
      keys[e.key] = true;
      if (e.key === ' ' && !gameRunning) {
        const startScreen = document.getElementById('startScreen');
        const gameOverScreen = document.getElementById('gameOverScreen');
        if (!startScreen.classList.contains('hidden') || !gameOverScreen.classList.contains('hidden')) {
          startGame();
        }
      }
    });
    document.addEventListener('keyup', e => keys[e.key] = false);

    // Mouse control
    canvas.addEventListener('mousemove', e => {
      mouseX = e.clientX;
    });
    canvas.addEventListener('mouseleave', () => {
      mouseX = null;
    });

    // Touch control
    canvas.addEventListener('touchmove', e => {
      e.preventDefault();
      mouseX = e.touches[0].clientX;
    }, { passive: false });
    canvas.addEventListener('touchend', () => {
      mouseX = null;
    });

    // Buttons
    document.getElementById('startBtn').addEventListener('click', startGame);
    document.getElementById('restartBtn').addEventListener('click', startGame);

    // Init
    window.addEventListener('resize', resize);
    resize();

    // Pre-load speech synthesis voices
    if ('speechSynthesis' in window) {
      speechSynthesis.getVoices();
    }
  </script>
<script src="/sloppy-header/sloppy-bar.js"></script>
<script src="/vibelib-extended.js"></script>
<script>
  // Compatibility Patch for Legacy Apps
  window.addEventListener("load", () => {
    if (window.SloppyKarma && window.VibeLib.Economy) {
      // Redirect old calls to new engine
      window.SloppyKarma.track = window.VibeLib.Economy.track;
    }
  });
</script>
</body>
</html>
