<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Sloppy Quests ‚Äî Daily Challenges</title>
<link rel="icon" href="https://emojicdn.elk.sh/‚öîÔ∏è">
<meta property="og:title" content="Sloppy Quests">
<meta property="og:description" content="Daily challenges. Complete quests. Earn karma. Rise in the ranks.">
<meta property="og:url" content="https://app.sloppy.live/sloppy-quests">
<meta property="og:image" content="https://image.pollinations.ai/prompt/medieval%20quest%20scroll%20with%20glowing%20runes%20floating%20in%20dark%20void%20golden%20light%20fantasy%20game%20UI?width=1200&height=630&nologo=true&referrer=sloppy.live">
<link href="https://fonts.googleapis.com/css2?family=Cinzel:wght@400;700;900&family=Fira+Code:wght@300;400;500&display=swap" rel="stylesheet">
<style>
*{margin:0;padding:0;box-sizing:border-box}
:root{
  --bg:#080810;--surface:#0f0f1a;--border:#1a1a2e;--border-hi:#2a2a44;
  --text:#d4d0c8;--dim:#5a566e;--gold:#f0c040;--gold-dim:#a08020;
  --xp:#50d890;--fail:#e04060;--quest:#8070d0;
  --fire:#f07030;--ice:#40a0f0;--sacred:#e0b0ff;
}
body{background:var(--bg);color:var(--text);font-family:'Fira Code',monospace;min-height:100vh}
body::before{content:'';position:fixed;inset:0;
  background:radial-gradient(ellipse at 30% 10%,rgba(240,192,64,.03) 0%,transparent 50%),
             radial-gradient(ellipse at 70% 90%,rgba(128,112,208,.03) 0%,transparent 50%);pointer-events:none}
.app{position:relative;max-width:720px;margin:0 auto;padding:20px 16px 80px}

/* Header */
.hdr{text-align:center;margin-bottom:28px}
h1{font-family:'Cinzel',serif;font-weight:900;font-size:2.2rem;letter-spacing:.04em;
  color:var(--gold);text-shadow:0 0 30px rgba(240,192,64,.2)}
.hdr-sub{font-size:.65rem;color:var(--dim);letter-spacing:.12em;text-transform:uppercase;margin-top:4px}

/* Stats row */
.stats-row{display:flex;gap:8px;margin-bottom:20px;overflow-x:auto}
.stat-pill{background:var(--surface);border:1px solid var(--border);border-radius:20px;padding:8px 16px;
  display:flex;align-items:center;gap:6px;white-space:nowrap;flex-shrink:0}
.stat-pill .num{font-family:'Cinzel',serif;font-weight:700;font-size:1rem}
.stat-pill .lbl{font-size:.6rem;color:var(--dim);text-transform:uppercase;letter-spacing:.06em}
.stat-pill.gold .num{color:var(--gold)}
.stat-pill.xp .num{color:var(--xp)}
.stat-pill.quest .num{color:var(--quest)}

/* Day selector */
.day-row{display:flex;gap:4px;margin-bottom:20px;justify-content:center}
.day-dot{width:32px;height:32px;border-radius:50%;border:2px solid var(--border);
  display:flex;align-items:center;justify-content:center;font-size:.55rem;color:var(--dim);
  cursor:pointer;transition:.2s;position:relative}
.day-dot.today{border-color:var(--gold);color:var(--gold)}
.day-dot.complete{border-color:var(--xp);background:rgba(80,216,144,.1);color:var(--xp)}
.day-dot.partial{border-color:var(--fire);background:rgba(240,112,48,.08);color:var(--fire)}

/* Quest cards */
.quest-list{display:flex;flex-direction:column;gap:10px}
.quest-card{background:var(--surface);border:1px solid var(--border);border-radius:10px;padding:16px;
  position:relative;overflow:hidden;transition:border-color .3s}
.quest-card:hover{border-color:var(--border-hi)}
.quest-card.completed{border-color:rgba(80,216,144,.3)}
.quest-card.completed::after{content:'';position:absolute;inset:0;background:rgba(80,216,144,.03);pointer-events:none}
.quest-top{display:flex;align-items:flex-start;gap:12px}
.quest-icon{font-size:1.6rem;line-height:1;flex-shrink:0}
.quest-body{flex:1;min-width:0}
.quest-title{font-family:'Cinzel',serif;font-weight:700;font-size:.9rem;color:var(--text);margin-bottom:2px}
.quest-desc{font-size:.7rem;color:var(--dim);line-height:1.5;margin-bottom:8px}
.quest-reward{display:inline-flex;align-items:center;gap:4px;font-size:.65rem;color:var(--gold);
  background:rgba(240,192,64,.08);padding:2px 8px;border-radius:10px;margin-bottom:8px}

/* Progress bar */
.prog-wrap{height:6px;background:var(--border);border-radius:3px;overflow:hidden;position:relative}
.prog-fill{height:100%;border-radius:3px;transition:width .5s ease;position:relative}
.prog-fill.active{background:linear-gradient(90deg,var(--quest),var(--gold))}
.prog-fill.done{background:var(--xp)}
.prog-label{display:flex;justify-content:space-between;font-size:.6rem;color:var(--dim);margin-top:4px}

/* Claim button */
.claim-btn{margin-top:10px;padding:8px 20px;font-family:'Cinzel',serif;font-weight:700;font-size:.75rem;
  border:1px solid var(--gold);border-radius:6px;background:rgba(240,192,64,.1);color:var(--gold);
  cursor:pointer;transition:.2s;letter-spacing:.04em}
.claim-btn:hover{background:rgba(240,192,64,.2);box-shadow:0 0 16px rgba(240,192,64,.15)}
.claim-btn:disabled{opacity:.4;cursor:default}
.claim-btn.claimed{border-color:var(--xp);color:var(--xp);background:rgba(80,216,144,.1)}

/* Streak flame */
.streak-flame{display:inline-block;animation:flicker 1.5s ease-in-out infinite alternate}
@keyframes flicker{0%{transform:scale(1);opacity:.9}100%{transform:scale(1.1);opacity:1}}

/* Reward toast */
.toast{position:fixed;top:20px;left:50%;transform:translateX(-50%) translateY(-100px);
  background:var(--surface);border:1px solid var(--gold);border-radius:10px;padding:12px 24px;
  font-family:'Cinzel',serif;font-size:.85rem;color:var(--gold);z-index:999;
  box-shadow:0 4px 30px rgba(240,192,64,.2);transition:transform .4s ease;pointer-events:none}
.toast.show{transform:translateX(-50%) translateY(0)}

/* Section headers */
.section-hdr{font-family:'Cinzel',serif;font-weight:700;font-size:.8rem;color:var(--dim);
  letter-spacing:.08em;text-transform:uppercase;margin:24px 0 12px;
  border-bottom:1px solid var(--border);padding-bottom:6px}

/* History */
.history-row{display:flex;align-items:center;gap:10px;padding:8px 0;border-bottom:1px solid var(--border);font-size:.75rem}
.history-row:last-child{border-bottom:none}
.history-date{color:var(--dim);width:70px;flex-shrink:0;font-size:.65rem}
.history-quests{flex:1;color:var(--text)}
.history-karma{color:var(--gold);font-weight:500;text-align:right;white-space:nowrap}

/* Loading */
.loading{text-align:center;padding:40px;color:var(--dim);font-size:.75rem}
.spinner{display:inline-block;width:20px;height:20px;border:2px solid var(--border);
  border-top-color:var(--gold);border-radius:50%;animation:spin .8s linear infinite;margin-bottom:8px}
@keyframes spin{to{transform:rotate(360deg)}}

/* Empty */
.empty{text-align:center;padding:40px;color:var(--dim);font-size:.8rem}

/* Tabs */
.tabs{display:flex;gap:2px;margin-bottom:20px;border-bottom:1px solid var(--border)}
.tab{padding:10px 16px;font-size:.65rem;font-family:'Fira Code',monospace;letter-spacing:.06em;
  text-transform:uppercase;color:var(--dim);background:transparent;border:none;cursor:pointer;
  border-bottom:2px solid transparent;white-space:nowrap;transition:.2s}
.tab:hover{color:var(--text)}
.tab.active{color:var(--gold);border-bottom-color:var(--gold)}
.panel{display:none}.panel.active{display:block}

@media(max-width:600px){
  h1{font-size:1.6rem}
  .stats-row{gap:6px}
  .stat-pill{padding:6px 12px}
  .stat-pill .num{font-size:.85rem}
}
</style>
<script>
(function(){var Q=[],N=0,MAX=10;function send(e){var sb=window.supabase;if(!sb){Q.push(e);return;}if(N>=MAX)return;N++;sb.auth.getSession().then(function(r){var u=r&&r.data&&r.data.session&&r.data.session.user;if(!u)return;sb.from('ai_events').insert({event_type:'client_error',entity_type:'app',entity_id:u.id,username:location.pathname.split('/').filter(Boolean)[0]||'unknown',metadata:e,user_id:u.id}).then(function(){});}).catch(function(){});}window.onerror=function(m,s,l,c,e){send({type:'error',msg:String(m).slice(0,500),src:s||'',line:l,col:c,stack:e?String(e.stack).slice(0,1000):''});};window.addEventListener('unhandledrejection',function(ev){var r=ev.reason;send({type:'promise',msg:String(r&&r.message||r).slice(0,500),stack:r?String(r.stack||'').slice(0,1000):''});});var fi=setInterval(function(){if(window.supabase){Q.splice(0).forEach(send);clearInterval(fi);}},1000);setTimeout(function(){clearInterval(fi);},30000);})();
</script>
</head>
<body>
<div class="app">
  <header class="hdr">
    <h1>‚öî Sloppy Quests</h1>
    <div class="hdr-sub">daily challenges ¬∑ karma rewards</div>
  </header>

  <div class="stats-row" id="stats-row">
    <div class="stat-pill gold"><div><div class="num" id="s-karma">‚Äî</div><div class="lbl">Karma</div></div></div>
    <div class="stat-pill xp"><div><div class="num" id="s-completed">0</div><div class="lbl">Completed</div></div></div>
    <div class="stat-pill quest"><div><div class="num" id="s-streak">0</div><div class="lbl"><span class="streak-flame">üî•</span> Streak</div></div></div>
  </div>

  <div class="tabs">
    <button class="tab active" data-tab="today" onclick="switchTab('today')">Today</button>
    <button class="tab" data-tab="history" onclick="switchTab('history')">History</button>
  </div>

  <div class="panel active" id="panel-today">
    <div class="day-row" id="day-row"></div>
    <div class="quest-list" id="quest-list">
      <div class="loading"><div class="spinner"></div><br>Loading quests...</div>
    </div>
  </div>

  <div class="panel" id="panel-history">
    <div id="history-list">
      <div class="loading"><div class="spinner"></div><br>Loading history...</div>
    </div>
  </div>
</div>

<div class="toast" id="toast"></div>

<script type="module">
import { createBrowserClient } from "https://cdn.jsdelivr.net/npm/@supabase/ssr@0.7.0/+esm";

const SUPABASE_URL = 'https://yjyxteqzhhmtrgcaekgz.supabase.co';
const SUPABASE_ANON_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InlqeXh0ZXF6aGhtdHJnY2Fla2d6Iiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTczNTg3NDIsImV4cCI6MjA3MjkzNDc0Mn0.G8SRde7IN2QFW1EnASM8IS32IUYR2eenCCjdDdioiBU';

const supabase = createBrowserClient(SUPABASE_URL, SUPABASE_ANON_KEY, {
  cookieOptions: {
    name: 'sb-auth-token',
    domain: location.hostname.includes('sloppy.live') ? '.sloppy.live' : location.hostname,
    path: '/', sameSite: 'lax'
  }
});

const ESC = s => String(s||'').replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;');

// ‚îÄ‚îÄ Quest Definitions ‚îÄ‚îÄ
// Each day gets a deterministic set of quests based on date seed
const QUEST_TEMPLATES = [
  { type: 'send_messages', icon: 'üí¨', title: 'Chatterbox', desc: 'Send messages in chat', targets: [3, 5, 10], rewards: [5, 10, 20] },
  { type: 'create_post', icon: 'üìù', title: 'Content Creator', desc: 'Create a new post', targets: [1, 2, 3], rewards: [10, 20, 30] },
  { type: 'write_manifesto', icon: 'üìú', title: 'Philosopher', desc: 'Write a manifesto', targets: [1, 1, 2], rewards: [20, 25, 40] },
  { type: 'cast_votes', icon: '‚¨ÜÔ∏è', title: 'Civic Duty', desc: 'Vote on content', targets: [3, 5, 10], rewards: [5, 10, 15] },
  { type: 'give_reactions', icon: 'üòÇ', title: 'React Master', desc: 'React to messages or posts', targets: [3, 5, 8], rewards: [5, 10, 15] },
  { type: 'earn_upvotes', icon: '‚≠ê', title: 'Crowd Pleaser', desc: 'Receive upvotes on your content', targets: [2, 5, 10], rewards: [10, 20, 35] },
  { type: 'make_doodle', icon: 'üé®', title: 'Doodle Artist', desc: 'Create a doodle', targets: [1, 2, 3], rewards: [10, 20, 30] },
  { type: 'leave_comments', icon: 'üí≠', title: 'Commenter', desc: 'Leave comments on posts', targets: [2, 3, 5], rewards: [5, 10, 15] },
  { type: 'use_tags', icon: 'üè∑Ô∏è', title: 'Tag Master', desc: 'Use hashtags in your content', targets: [2, 3, 5], rewards: [5, 8, 12] },
  { type: 'mention_users', icon: 'üëã', title: 'Social Butterfly', desc: 'Mention other users', targets: [1, 2, 3], rewards: [5, 10, 15] },
  { type: 'visit_apps', icon: 'üß≠', title: 'Explorer', desc: 'Check in to the quest board', targets: [1, 1, 1], rewards: [5, 5, 5] },
  { type: 'earn_karma', icon: '‚ú®', title: 'Karma Farmer', desc: 'Earn karma from any source', targets: [10, 25, 50], rewards: [10, 20, 40] },
];

const DAILY_QUEST_COUNT = 5;
const BONUS_MULTIPLIER = 1.5; // bonus for completing ALL quests

function getDateStr(d) {
  return d.toISOString().slice(0, 10);
}

function getTodayStr() {
  return getDateStr(new Date());
}

// Deterministic quest selection from date
// Uses FNV-1a for better bit distribution on short strings
function seedFromDate(dateStr) {
  let h = 2166136261; // FNV offset basis
  for (let i = 0; i < dateStr.length; i++) {
    h ^= dateStr.charCodeAt(i);
    h = Math.imul(h, 16777619); // FNV prime
  }
  return (h >>> 0); // unsigned 32-bit
}

// LCG next step (same constants as glibc)
function lcgNext(s) {
  return ((s * 1103515245 + 12345) & 0x7fffffff) >>> 0;
}

function getQuestsForDate(dateStr) {
  let s = seedFromDate(dateStr);
  const indices = [];
  const pool = [...QUEST_TEMPLATES.keys()];

  while (indices.length < DAILY_QUEST_COUNT && pool.length > 0) {
    s = lcgNext(s);
    const pick = s % pool.length;
    indices.push(pool.splice(pick, 1)[0]);
  }

  // Each quest gets its own difficulty (0=easy, 1=med, 2=hard)
  // derived from continued LCG steps ‚Äî not uniform across the day
  return indices.map(i => {
    s = lcgNext(s);
    const diffIdx = s % 3;
    const t = QUEST_TEMPLATES[i];
    return {
      type: t.type,
      icon: t.icon,
      title: t.title,
      desc: t.desc,
      target: t.targets[diffIdx],
      reward: t.rewards[diffIdx],
      difficulty: diffIdx
    };
  });
}

// ‚îÄ‚îÄ State ‚îÄ‚îÄ
let currentUser = null;
let profile = null;
let myKarma = null;
let todayQuests = []; // from DB
let questStreak = 0;
let totalCompleted = 0;

// ‚îÄ‚îÄ Auth ‚îÄ‚îÄ
async function init() {
  let session;
  try {
    const res = await supabase.auth.getSession();
    session = res?.data?.session;
  } catch (err) {
    console.error('Auth failed:', err);
    document.getElementById('quest-list').innerHTML = '<div class="empty">Connection error. Refresh to retry.</div>';
    return;
  }
  if (!session?.user) {
    document.getElementById('quest-list').innerHTML = '<div class="empty">Sign in on sloppy.live to begin your quest journey.</div>';
    document.getElementById('history-list').innerHTML = '';
    return;
  }
  currentUser = session.user;

  // Fast path: header sync hub context
  let usedContext = false;
  if (window.sloppyBarGetContext) {
    const ctx = window.sloppyBarGetContext();
    if (ctx && ctx.ready && ctx.userId) {
      profile = { username: ctx.username || 'anon', avatar_url: ctx.avatarUrl || null };
      myKarma = { karma_total: ctx.karma || 0 };
      usedContext = true;
    }
  }
  // Fallback: DB queries
  if (!usedContext) {
    try {
      const [profRes, karmaRes] = await Promise.all([
        supabase.from('sloppygram_profiles').select('username,avatar_url').eq('user_id', currentUser.id).single(),
        supabase.from('sloppygram_karma').select('*').eq('user_id', currentUser.id).single()
      ]);
      profile = profRes.data || { username: 'anon' };
      myKarma = karmaRes.data;
    } catch (err) {
      console.warn('Profile/karma load failed:', err);
      profile = { username: 'anon' };
      myKarma = null;
    }
  }

  document.getElementById('s-karma').textContent = myKarma ? myKarma.karma_total.toLocaleString() : '0';

  await ensureTodayQuests();
  await loadHistory();
  renderDayRow();
  renderQuests();
  renderStats();
}

// ‚îÄ‚îÄ Ensure today's quests exist in DB ‚îÄ‚îÄ
async function ensureTodayQuests() {
  const today = getTodayStr();
  try {
    const { data: existing, error: fetchErr } = await supabase
      .from('daily_quests')
      .select('*')
      .eq('user_id', currentUser.id)
      .eq('quest_date', today);

    if (fetchErr) throw fetchErr;

    if (existing && existing.length >= DAILY_QUEST_COUNT) {
      todayQuests = existing;
      return;
    }

    // Generate and insert today's quests
    const templates = getQuestsForDate(today);
    const existingTypes = new Set((existing || []).map(q => q.quest_type));
    const toInsert = templates
      .filter(t => !existingTypes.has(t.type))
      .map(t => ({
        quest_type: t.type,
        quest_target: t.target,
        quest_progress: 0,
        quest_completed: false,
        quest_date: today,
        reward_points: t.reward,
        user_id: currentUser.id
      }));

    if (toInsert.length > 0) {
      const { error: insertErr } = await supabase.from('daily_quests').insert(toInsert);
      if (insertErr) console.error('Quest insert error:', insertErr);
    }

    const { data: fresh, error: freshErr } = await supabase
      .from('daily_quests')
      .select('*')
      .eq('user_id', currentUser.id)
      .eq('quest_date', today);

    if (freshErr) throw freshErr;
    todayQuests = fresh || [];
  } catch (err) {
    console.error('Failed to ensure today quests:', err);
    todayQuests = [];
  }
}

// ‚îÄ‚îÄ Refresh progress from actual activity ‚îÄ‚îÄ
async function refreshProgress() {
  if (!currentUser || !profile || todayQuests.length === 0) return;
  const today = getTodayStr();
  const todayStart = today + 'T00:00:00.000Z';

  try {
    // Count today's actual activity
    const [msgRes, postRes, manRes, voteRes, reactRes, commentRes, doodleRes, tagRes, mentionRes] = await Promise.all([
      supabase.from('sloppygram_messages').select('id', { count: 'exact', head: true }).eq('user_id', currentUser.id).gte('created_at', todayStart),
      supabase.from('sloppygram_posts').select('id', { count: 'exact', head: true }).eq('user_id', currentUser.id).gte('created_at', todayStart),
      supabase.from('sloppygram_manifestos').select('id', { count: 'exact', head: true }).eq('user_id', currentUser.id).gte('created_at', todayStart),
      supabase.from('sloppygram_message_votes').select('id', { count: 'exact', head: true }).eq('user_id', currentUser.id).gte('created_at', todayStart),
      supabase.from('sloppygram_message_reactions').select('id', { count: 'exact', head: true }).eq('user_id', currentUser.id).gte('created_at', todayStart),
      supabase.from('sloppygram_post_comments').select('id', { count: 'exact', head: true }).eq('user_id', currentUser.id).gte('created_at', todayStart),
      supabase.from('sloppygram_messages').select('id', { count: 'exact', head: true }).eq('user_id', currentUser.id).eq('message_type', 'drawing').gte('created_at', todayStart),
      // Tags: count posts that have tags created today
      supabase.from('sloppygram_post_tags').select('id', { count: 'exact', head: true }).eq('user_id', currentUser.id).gte('created_at', todayStart),
      // Mentions: count mentions authored today
      supabase.from('sloppygram_mentions').select('id', { count: 'exact', head: true }).eq('mentioned_by', profile.username).gte('created_at', todayStart),
    ]);

    // Refresh karma for accurate daily tracking
    try {
      const { data: freshKarma } = await supabase.from('sloppygram_karma').select('*').eq('user_id', currentUser.id).single();
      myKarma = freshKarma;
      document.getElementById('s-karma').textContent = myKarma ? myKarma.karma_total.toLocaleString() : '0';
    } catch (_) {}

    // Daily karma earned = sum of completed quest rewards today (stored in DB)
    const dailyKarmaEarned = todayQuests.filter(q => q.quest_completed).reduce((s, q) => s + q.reward_points, 0);

    const counts = {
      send_messages: msgRes.count || 0,
      create_post: postRes.count || 0,
      write_manifesto: manRes.count || 0,
      cast_votes: voteRes.count || 0,
      give_reactions: reactRes.count || 0,
      leave_comments: commentRes.count || 0,
      make_doodle: doodleRes.count || 0,
      visit_apps: 1, // they're here
      use_tags: tagRes.count || 0,
      mention_users: mentionRes.count || 0,
      // earn_upvotes: count today's upvotes received on user's content
      earn_upvotes: (voteRes.count || 0) + (postRes.count || 0), // approximate: activity today
      // earn_karma: use today's completed quest rewards as a proxy
      earn_karma: dailyKarmaEarned,
    };

    // Update progress for each quest
    const wasAllDone = todayQuests.every(q => q.quest_completed);

    for (const quest of todayQuests) {
      const progress = Math.min(counts[quest.quest_type] || 0, quest.quest_target);
      const completed = progress >= quest.quest_target;

      if (progress !== quest.quest_progress || completed !== quest.quest_completed) {
        const { error } = await supabase.from('daily_quests')
          .update({ quest_progress: progress, quest_completed: completed })
          .eq('user_id', currentUser.id)
          .eq('quest_type', quest.quest_type)
          .eq('quest_date', quest.quest_date);
        if (!error) {
          quest.quest_progress = progress;
          quest.quest_completed = completed;
        }
      }
    }

    // Check if all quests just became complete ‚Äî award bonus
    const nowAllDone = todayQuests.every(q => q.quest_completed);
    if (nowAllDone && !wasAllDone && todayQuests.length > 0) {
      const totalReward = todayQuests.reduce((s, q) => s + q.reward_points, 0);
      const bonus = Math.floor(totalReward * (BONUS_MULTIPLIER - 1));
      showToast(`All quests complete! +${bonus} bonus karma ‚ú®`);

      // Persist bonus to karma table
      if (myKarma) {
        try {
          await supabase.from('sloppygram_karma')
            .update({ karma_total: myKarma.karma_total + bonus })
            .eq('user_id', currentUser.id);
          myKarma.karma_total += bonus;
          document.getElementById('s-karma').textContent = myKarma.karma_total.toLocaleString();
        } catch (e) { console.warn('Bonus karma persist failed:', e); }
      }
    }
  } catch (err) {
    console.error('Progress refresh failed:', err);
  }

  renderQuests();
  renderStats();
}

// ‚îÄ‚îÄ Render Quests ‚îÄ‚îÄ
function renderQuests() {
  const today = getTodayStr();
  const templates = getQuestsForDate(today);
  const templateMap = {};
  templates.forEach(t => { templateMap[t.type] = t; });

  const completedCount = todayQuests.filter(q => q.quest_completed).length;
  const allDone = completedCount === todayQuests.length && todayQuests.length > 0;
  const totalReward = todayQuests.reduce((s, q) => s + q.reward_points, 0);
  const bonusReward = allDone ? Math.floor(totalReward * (BONUS_MULTIPLIER - 1)) : 0;

  let html = '';

  if (allDone) {
    html += `<div style="text-align:center;padding:16px;background:rgba(80,216,144,.06);border:1px solid rgba(80,216,144,.2);border-radius:10px;margin-bottom:12px">
      <div style="font-family:'Cinzel',serif;font-size:1.1rem;color:var(--xp);font-weight:700">All Quests Complete!</div>
      <div style="font-size:.7rem;color:var(--dim);margin-top:4px">Bonus karma earned: +${bonusReward} ‚ú®</div>
    </div>`;
  }

  todayQuests.forEach(q => {
    const t = templateMap[q.quest_type] || { icon: '‚ùì', title: q.quest_type, desc: '' };
    const pct = Math.min((q.quest_progress / q.quest_target) * 100, 100);
    const done = q.quest_completed;
    const fillClass = done ? 'done' : 'active';

    html += `<div class="quest-card${done ? ' completed' : ''}">
      <div class="quest-top">
        <div class="quest-icon">${t.icon}</div>
        <div class="quest-body">
          <div class="quest-title">${ESC(t.title)}</div>
          <div class="quest-desc">${ESC(t.desc)} ‚Äî ${q.quest_target}√ó</div>
          <div class="quest-reward">+${q.reward_points} karma</div>
          <div class="prog-wrap"><div class="prog-fill ${fillClass}" style="width:${pct}%"></div></div>
          <div class="prog-label"><span>${q.quest_progress} / ${q.quest_target}</span><span>${done ? '‚úì Done' : Math.floor(pct) + '%'}</span></div>
        </div>
      </div>
    </div>`;
  });

  if (todayQuests.length === 0) {
    html = '<div class="empty">No quests loaded. Sign in to start.</div>';
  }

  document.getElementById('quest-list').innerHTML = html;
}

// ‚îÄ‚îÄ Stats ‚îÄ‚îÄ
function renderStats() {
  totalCompleted = todayQuests.filter(q => q.quest_completed).length;
  document.getElementById('s-completed').textContent = totalCompleted + '/' + todayQuests.length;
}

// ‚îÄ‚îÄ Day row (last 7 days) ‚îÄ‚îÄ
let historyData = [];

async function loadHistory() {
  try {
    const { data, error } = await supabase
      .from('daily_quests')
      .select('quest_date,quest_completed,reward_points')
      .eq('user_id', currentUser.id)
      .order('quest_date', { ascending: false })
      .limit(200);
    if (error) throw error;
    historyData = data || [];
  } catch (err) {
    console.error('Failed to load history:', err);
    historyData = [];
  }

  // Compute streak
  const dateMap = {};
  historyData.forEach(q => {
    if (!dateMap[q.quest_date]) dateMap[q.quest_date] = { total: 0, done: 0, karma: 0 };
    dateMap[q.quest_date].total++;
    if (q.quest_completed) { dateMap[q.quest_date].done++; dateMap[q.quest_date].karma += q.reward_points; }
  });

  questStreak = 0;
  const d = new Date();
  // Start checking from yesterday (today might be in progress)
  d.setDate(d.getDate() - 1);
  while (true) {
    const ds = getDateStr(d);
    const day = dateMap[ds];
    if (day && day.done > 0 && day.done === day.total) {
      questStreak++;
      d.setDate(d.getDate() - 1);
    } else {
      break;
    }
  }
  // If today is all complete, add it
  const todayData = dateMap[getTodayStr()];
  if (todayData && todayData.done > 0 && todayData.done === todayData.total) questStreak++;

  document.getElementById('s-streak').textContent = questStreak;
  renderHistory(dateMap);
}

function renderDayRow() {
  const days = [];
  for (let i = 6; i >= 0; i--) {
    const d = new Date(); d.setDate(d.getDate() - i);
    days.push(d);
  }

  const dateMap = {};
  historyData.forEach(q => {
    if (!dateMap[q.quest_date]) dateMap[q.quest_date] = { total: 0, done: 0 };
    dateMap[q.quest_date].total++;
    if (q.quest_completed) dateMap[q.quest_date].done++;
  });

  document.getElementById('day-row').innerHTML = days.map(d => {
    const ds = getDateStr(d);
    const isToday = ds === getTodayStr();
    const info = dateMap[ds];
    let cls = '';
    if (isToday) cls = 'today';
    else if (info && info.done === info.total && info.total > 0) cls = 'complete';
    else if (info && info.done > 0) cls = 'partial';
    const label = d.toLocaleDateString('en', { weekday: 'short' }).slice(0, 2);
    return `<div class="day-dot ${cls}" title="${ds}">${label}</div>`;
  }).join('');
}

function renderHistory(dateMap) {
  const dates = Object.keys(dateMap).sort().reverse().slice(0, 30);
  if (dates.length === 0) {
    document.getElementById('history-list').innerHTML = '<div class="empty">No quest history yet. Complete today\'s quests to start!</div>';
    return;
  }

  document.getElementById('history-list').innerHTML = dates.map(ds => {
    const d = dateMap[ds];
    const allDone = d.done === d.total && d.total > 0;
    const bonus = allDone ? Math.floor(d.karma * (BONUS_MULTIPLIER - 1)) : 0;
    const totalK = d.karma + bonus;
    return `<div class="history-row">
      <div class="history-date">${ds}</div>
      <div class="history-quests">${d.done}/${d.total} quests ${allDone ? '<span style="color:var(--xp)">‚úì</span>' : ''}</div>
      <div class="history-karma">+${totalK} ‚ú®</div>
    </div>`;
  }).join('');
}

// ‚îÄ‚îÄ Tabs ‚îÄ‚îÄ
window.switchTab = function(tab) {
  document.querySelectorAll('.tab').forEach(t => t.classList.toggle('active', t.dataset.tab === tab));
  document.querySelectorAll('.panel').forEach(p => p.classList.toggle('active', p.id === 'panel-' + tab));
};

// ‚îÄ‚îÄ Toast ‚îÄ‚îÄ
function showToast(msg) {
  const el = document.getElementById('toast');
  el.textContent = msg;
  el.classList.add('show');
  setTimeout(() => el.classList.remove('show'), 2500);
}

// ‚îÄ‚îÄ Init + auto-refresh ‚îÄ‚îÄ
init().then(() => {
  setInterval(refreshProgress, 30000);
  setTimeout(refreshProgress, 2000);

  // Sync hub listeners ‚Äî live karma/identity from other tabs
  if (window.sloppyBarOn) {
    window.sloppyBarOn('karma-changed', function(data) {
      if (data && typeof data.karma === 'number') {
        myKarma = { karma_total: data.karma };
        document.getElementById('s-karma').textContent = data.karma.toLocaleString();
      }
    });
    window.sloppyBarOn('identity-changed', function(data) {
      if (data && data.username) {
        profile = Object.assign(profile || {}, { username: data.username });
      }
    });
    window.sloppyBarOn('context-ready', function() {
      if (!currentUser || !window.sloppyBarGetContext) return;
      var ctx = window.sloppyBarGetContext();
      if (ctx && ctx.ready && ctx.userId) {
        profile = { username: ctx.username || 'anon', avatar_url: ctx.avatarUrl || null };
        if (ctx.karma) {
          myKarma = { karma_total: ctx.karma };
          document.getElementById('s-karma').textContent = ctx.karma.toLocaleString();
        }
      }
    });
  }
});
</script>
<script src="/sloppy-header/sloppy-bar.js" data-position="bottom" data-minimized="true"></script>
</body>
</html>
