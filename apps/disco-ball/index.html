<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Disco Ball - Bass Pulse</title>
  <link rel="icon" href="https://emojicdn.elk.sh/ðŸª©">
  <meta property="og:title" content="Disco Ball">
  <meta property="og:description" content="Ray-traced disco ball pulsing to the bass">
  <meta property="og:url" content="https://app.sloppy.live/disco-ball">
  <meta property="og:image" content="https://emojicdn.elk.sh/ðŸª©?style=apple&size=512">
  <link href="https://fonts.googleapis.com/css2?family=Outfit:wght@300;600;900&display=swap" rel="stylesheet">
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      background: #000;
      overflow: hidden;
      font-family: 'Outfit', sans-serif;
    }
    canvas { display: block; }

    .title {
      position: fixed;
      top: 30px;
      left: 50%;
      transform: translateX(-50%);
      font-size: 2.5rem;
      font-weight: 900;
      color: #fff;
      text-shadow: 0 0 30px #ff00ff, 0 0 60px #ff00ff, 0 0 90px #00ffff;
      letter-spacing: 15px;
      z-index: 100;
      pointer-events: none;
      opacity: 0.8;
    }

    .beat-indicator {
      position: fixed;
      bottom: 40px;
      left: 50%;
      transform: translateX(-50%);
      display: flex;
      gap: 8px;
      z-index: 100;
    }

    .beat-bar {
      width: 8px;
      height: 60px;
      background: linear-gradient(to top, #ff00ff, #00ffff);
      border-radius: 4px;
      transform-origin: bottom;
      box-shadow: 0 0 15px #ff00ff;
    }

    .bpm {
      position: fixed;
      bottom: 110px;
      left: 50%;
      transform: translateX(-50%);
      font-size: 1rem;
      color: #ff00ff;
      text-shadow: 0 0 20px #ff00ff;
      z-index: 100;
    }

    .backlink {
      position: fixed;
      bottom: 15px;
      right: 20px;
      color: rgba(255,255,255,0.3);
      font-size: 0.7rem;
      text-decoration: none;
      z-index: 100;
    }
    .backlink:hover { color: #ff00ff; }

    .floor-glow {
      position: fixed;
      bottom: 0;
      left: 0;
      right: 0;
      height: 200px;
      background: linear-gradient(to top, rgba(255, 0, 255, 0.1), transparent);
      pointer-events: none;
      z-index: 50;
    }
  </style>
</head>
<body>
  <div class="title">DISCO</div>
  <div class="floor-glow"></div>

  <div class="bpm"><span id="bpm">128</span> BPM</div>
  <div class="beat-indicator" id="beat-bars"></div>

  <a href="https://sloppy.live" class="backlink">sloppy.live</a>

  <script type="importmap">
    {
      "imports": {
        "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
        "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
      }
    }
  </script>

  <script type="module">
    import * as THREE from 'three';
    import { RGBELoader } from 'three/addons/loaders/RGBELoader.js';

    // Scene
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x000008);

    // Camera
    const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 100);
    camera.position.set(0, 2, 8);
    camera.lookAt(0, 0, 0);

    // Renderer
    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    renderer.toneMapping = THREE.ACESFilmicToneMapping;
    renderer.toneMappingExposure = 1.5;
    document.body.appendChild(renderer.domElement);

    // Resize
    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });

    // Create disco ball
    const discoBall = new THREE.Group();
    scene.add(discoBall);

    // Main sphere (base)
    const sphereGeom = new THREE.SphereGeometry(1.8, 64, 64);
    const sphereMat = new THREE.MeshStandardMaterial({
      color: 0x111111,
      metalness: 0.9,
      roughness: 0.1
    });
    const sphere = new THREE.Mesh(sphereGeom, sphereMat);
    discoBall.add(sphere);

    // Mirror tiles
    const tiles = [];
    const tileRows = 20;
    const tileCols = 40;

    for (let row = 0; row < tileRows; row++) {
      const phi = (row / tileRows) * Math.PI;
      const rowTiles = Math.floor(Math.sin(phi) * tileCols) || 1;

      for (let col = 0; col < rowTiles; col++) {
        const theta = (col / rowTiles) * Math.PI * 2;

        const tileGeom = new THREE.PlaneGeometry(0.18, 0.12);
        const tileMat = new THREE.MeshStandardMaterial({
          color: 0xffffff,
          metalness: 1,
          roughness: 0.05,
          envMapIntensity: 2
        });

        const tile = new THREE.Mesh(tileGeom, tileMat);

        // Position on sphere
        const r = 1.82;
        tile.position.set(
          r * Math.sin(phi) * Math.cos(theta),
          r * Math.cos(phi),
          r * Math.sin(phi) * Math.sin(theta)
        );

        // Orient outward
        tile.lookAt(tile.position.clone().multiplyScalar(2));

        // Store original position for pulsing
        tile.userData.basePos = tile.position.clone();
        tile.userData.phase = Math.random() * Math.PI * 2;
        tile.userData.row = row;
        tile.userData.col = col;

        discoBall.add(tile);
        tiles.push(tile);
      }
    }

    // Hanging wire
    const wireGeom = new THREE.CylinderGeometry(0.02, 0.02, 4, 8);
    const wireMat = new THREE.MeshStandardMaterial({ color: 0x333333, metalness: 0.8 });
    const wire = new THREE.Mesh(wireGeom, wireMat);
    wire.position.y = 3.8;
    discoBall.add(wire);

    // Cap
    const capGeom = new THREE.CylinderGeometry(0.15, 0.1, 0.1, 16);
    const cap = new THREE.Mesh(capGeom, wireMat);
    cap.position.y = 1.85;
    discoBall.add(cap);

    // Environment map for reflections (procedural)
    const cubeRenderTarget = new THREE.WebGLCubeRenderTarget(256);
    const cubeCamera = new THREE.CubeCamera(0.1, 100, cubeRenderTarget);
    scene.add(cubeCamera);

    // Create colorful environment
    const envScene = new THREE.Scene();

    // Colored lights in environment
    const envColors = [0xff00ff, 0x00ffff, 0xffff00, 0x00ff00, 0xff6600, 0x0066ff];
    envColors.forEach((color, i) => {
      const angle = (i / envColors.length) * Math.PI * 2;
      const light = new THREE.PointLight(color, 50, 30);
      light.position.set(Math.cos(angle) * 15, 5, Math.sin(angle) * 15);
      envScene.add(light);

      // Visible light sphere
      const lightSphere = new THREE.Mesh(
        new THREE.SphereGeometry(0.5),
        new THREE.MeshBasicMaterial({ color })
      );
      lightSphere.position.copy(light.position);
      envScene.add(lightSphere);
    });

    // Update env map
    function updateEnvMap() {
      sphere.visible = false;
      tiles.forEach(t => t.visible = false);
      cubeCamera.position.copy(discoBall.position);
      cubeCamera.update(renderer, envScene);
      sphere.visible = true;
      tiles.forEach(t => t.visible = true);

      tiles.forEach(tile => {
        tile.material.envMap = cubeRenderTarget.texture;
      });
    }

    // Main scene lights
    const ambientLight = new THREE.AmbientLight(0x111122, 0.3);
    scene.add(ambientLight);

    // Spotlight from above
    const spotlight = new THREE.SpotLight(0xffffff, 3);
    spotlight.position.set(0, 10, 0);
    spotlight.angle = 0.5;
    spotlight.penumbra = 0.5;
    spotlight.castShadow = true;
    scene.add(spotlight);

    // Colored point lights that pulse
    const pulseLights = [];
    const lightColors = [0xff00ff, 0x00ffff, 0xffff00, 0x00ff00, 0xff6600];

    lightColors.forEach((color, i) => {
      const angle = (i / lightColors.length) * Math.PI * 2;
      const light = new THREE.PointLight(color, 2, 15);
      light.position.set(Math.cos(angle) * 6, 2, Math.sin(angle) * 6);
      scene.add(light);
      pulseLights.push({ light, baseIntensity: 2, angle });

      // Light beam (cone)
      const beamGeom = new THREE.ConeGeometry(0.3, 8, 16, 1, true);
      const beamMat = new THREE.MeshBasicMaterial({
        color,
        transparent: true,
        opacity: 0.1,
        side: THREE.DoubleSide
      });
      const beam = new THREE.Mesh(beamGeom, beamMat);
      beam.position.copy(light.position);
      beam.lookAt(0, 0, 0);
      beam.rotateX(Math.PI / 2);
      scene.add(beam);
      light.userData.beam = beam;
    });

    // Floor
    const floorGeom = new THREE.PlaneGeometry(50, 50);
    const floorMat = new THREE.MeshStandardMaterial({
      color: 0x050508,
      metalness: 0.8,
      roughness: 0.2
    });
    const floor = new THREE.Mesh(floorGeom, floorMat);
    floor.rotation.x = -Math.PI / 2;
    floor.position.y = -4;
    floor.receiveShadow = true;
    scene.add(floor);

    // Reflection spots on floor
    const spotlightSpots = [];
    for (let i = 0; i < 50; i++) {
      const spotGeom = new THREE.CircleGeometry(0.2 + Math.random() * 0.3, 16);
      const spotMat = new THREE.MeshBasicMaterial({
        color: lightColors[i % lightColors.length],
        transparent: true,
        opacity: 0.3
      });
      const spot = new THREE.Mesh(spotGeom, spotMat);
      spot.rotation.x = -Math.PI / 2;
      spot.position.set(
        (Math.random() - 0.5) * 20,
        -3.99,
        (Math.random() - 0.5) * 20
      );
      spot.userData.baseX = spot.position.x;
      spot.userData.baseZ = spot.position.z;
      spot.userData.phase = Math.random() * Math.PI * 2;
      scene.add(spot);
      spotlightSpots.push(spot);
    }

    // Beat visualization bars
    const numBars = 16;
    const barsContainer = document.getElementById('beat-bars');
    for (let i = 0; i < numBars; i++) {
      const bar = document.createElement('div');
      bar.className = 'beat-bar';
      barsContainer.appendChild(bar);
    }
    const bars = document.querySelectorAll('.beat-bar');

    // Simulated bass/beat
    const BPM = 128;
    const beatInterval = 60 / BPM;
    let time = 0;
    let bassLevel = 0;
    let lastBeat = 0;
    let beatPulse = 0;

    // Frequency simulation
    function simulateBass(t) {
      // Main beat
      const beatPhase = (t % beatInterval) / beatInterval;
      const kick = Math.exp(-beatPhase * 10) * 0.8;

      // Sub bass wobble
      const subBass = Math.sin(t * Math.PI * 2) * 0.3 + 0.3;

      // Hi-hat pattern
      const hiHat = Math.exp(-((t * 4) % 1) * 15) * 0.2;

      return kick + subBass * 0.5 + hiHat * 0.3;
    }

    // Get frequency bands (simulated)
    function getFrequencyBands(t) {
      const bands = [];
      for (let i = 0; i < numBars; i++) {
        const freq = (i + 1) / numBars;
        const phase = t * (2 + i * 0.5) + i * 0.3;
        let value = Math.sin(phase) * 0.5 + 0.5;

        // Bass frequencies pulse more on beat
        if (i < 4) {
          value = value * 0.5 + simulateBass(t) * (1 - i * 0.15);
        }

        bands.push(Math.max(0.1, Math.min(1, value)));
      }
      return bands;
    }

    // Animation
    let lastTime = 0;
    updateEnvMap();

    function animate(timestamp) {
      requestAnimationFrame(animate);

      const dt = (timestamp - lastTime) / 1000;
      lastTime = timestamp;
      time += dt;

      // Simulated bass
      bassLevel = simulateBass(time);

      // Beat detection
      const currentBeat = Math.floor(time / beatInterval);
      if (currentBeat > lastBeat) {
        beatPulse = 1;
        lastBeat = currentBeat;
      }
      beatPulse *= 0.9;

      // Rotate disco ball
      discoBall.rotation.y += dt * 0.5;

      // Pulse tiles on bass
      tiles.forEach((tile, i) => {
        const pulse = 1 + bassLevel * 0.15 * Math.sin(tile.userData.phase + time * 5);
        tile.position.copy(tile.userData.basePos).multiplyScalar(pulse);

        // Color shift on beat
        const hue = (time * 0.1 + tile.userData.row * 0.05) % 1;
        tile.material.emissive.setHSL(hue, 1, bassLevel * 0.2);
        tile.material.emissiveIntensity = bassLevel * 0.5;
      });

      // Pulse main sphere
      const sphereScale = 1 + beatPulse * 0.05;
      sphere.scale.set(sphereScale, sphereScale, sphereScale);

      // Pulse lights
      pulseLights.forEach((pl, i) => {
        const phase = time * 2 + i * 0.5;
        pl.light.intensity = pl.baseIntensity + bassLevel * 3 * Math.abs(Math.sin(phase));

        // Move lights
        const newAngle = pl.angle + time * 0.3;
        pl.light.position.x = Math.cos(newAngle) * 6;
        pl.light.position.z = Math.sin(newAngle) * 6;
        pl.light.position.y = 2 + Math.sin(time * 2 + i) * 1;

        // Update beam
        if (pl.light.userData.beam) {
          pl.light.userData.beam.position.copy(pl.light.position);
          pl.light.userData.beam.lookAt(0, 0, 0);
          pl.light.userData.beam.rotateX(Math.PI / 2);
          pl.light.userData.beam.material.opacity = 0.05 + bassLevel * 0.15;
        }
      });

      // Move reflection spots
      spotlightSpots.forEach(spot => {
        spot.position.x = spot.userData.baseX + Math.sin(time + spot.userData.phase) * 2;
        spot.position.z = spot.userData.baseZ + Math.cos(time * 0.7 + spot.userData.phase) * 2;
        spot.material.opacity = 0.2 + bassLevel * 0.4;
        spot.scale.setScalar(0.8 + bassLevel * 0.5);
      });

      // Camera sway
      camera.position.x = Math.sin(time * 0.2) * 1.5;
      camera.position.z = 8 + Math.sin(time * 0.15) * 1;
      camera.lookAt(0, 0, 0);

      // Update beat bars
      const bands = getFrequencyBands(time);
      bars.forEach((bar, i) => {
        bar.style.transform = `scaleY(${bands[i]})`;
        bar.style.opacity = 0.5 + bands[i] * 0.5;
      });

      // Floor glow pulse
      document.querySelector('.floor-glow').style.opacity = 0.3 + bassLevel * 0.7;

      renderer.render(scene, camera);
    }

    animate(0);
  </script>
<script src="/apps/sloppy-header/sloppy-bar.js"></script>
<script src="/vibelib-extended.js"></script>
<script>
  // Compatibility Patch for Legacy Apps
  window.addEventListener("load", () => {
    if (window.SloppyKarma && window.VibeLib.Economy) {
      // Redirect old calls to new engine
      window.SloppyKarma.track = window.VibeLib.Economy.track;
    }
  });
</script>
</body>
</html>
