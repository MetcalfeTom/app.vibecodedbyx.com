<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
  <title>Ornament Toss - Decorate the Tree!</title>
  <link rel="icon" href="https://emojicdn.elk.sh/ðŸŽ„">

  <meta property="og:title" content="Ornament Toss">
  <meta property="og:description" content="Throw snowballs at a wobbly Christmas tree to decorate it!">
  <meta property="og:url" content="https://sloppy.live/ornament-toss">
  <meta property="og:image" content="https://sloppy.live/ornament-toss/og-image.png">

  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link href="https://fonts.googleapis.com/css2?family=Fredoka:wght@400;600&display=swap" rel="stylesheet">

  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    :root {
      --snow-white: #f0f8ff;
      --night-sky: #0a1628;
      --tree-green: #1a5c2e;
      --tree-dark: #0d3318;
      --gold: #ffd700;
      --red: #e63946;
      --blue: #4cc9f0;
      --purple: #9d4edd;
      --silver: #c0c0c0;
    }

    body {
      font-family: 'Fredoka', sans-serif;
      background: var(--night-sky);
      overflow: hidden;
      touch-action: none;
      user-select: none;
    }

    #game-container {
      position: fixed;
      inset: 0;
      background: linear-gradient(180deg, #0a1628 0%, #1a2a4a 50%, #2a3a5a 100%);
    }

    canvas {
      display: block;
    }

    .snowflake {
      position: fixed;
      color: white;
      opacity: 0.7;
      pointer-events: none;
      animation: fall linear infinite;
      font-size: 10px;
    }

    @keyframes fall {
      to {
        transform: translateY(100vh) rotate(360deg);
      }
    }

    #ui {
      position: fixed;
      top: 20px;
      left: 50%;
      transform: translateX(-50%);
      text-align: center;
      color: var(--snow-white);
      z-index: 10;
      pointer-events: none;
    }

    #score {
      font-size: 2rem;
      font-weight: 600;
      text-shadow: 0 2px 10px rgba(0,0,0,0.5);
    }

    #instructions {
      font-size: 0.9rem;
      opacity: 0.8;
      margin-top: 5px;
      transition: opacity 0.5s;
    }

    #instructions.hidden {
      opacity: 0;
    }

    .star {
      position: fixed;
      width: 2px;
      height: 2px;
      background: white;
      border-radius: 50%;
      animation: twinkle 2s ease-in-out infinite;
    }

    @keyframes twinkle {
      0%, 100% { opacity: 0.3; }
      50% { opacity: 1; }
    }

    #back-link {
      position: fixed;
      bottom: 15px;
      left: 50%;
      transform: translateX(-50%);
      color: rgba(255,255,255,0.5);
      text-decoration: none;
      font-size: 0.8rem;
      z-index: 10;
      transition: color 0.3s;
    }

    #back-link:hover {
      color: rgba(255,255,255,0.8);
    }

    #reset-btn {
      position: fixed;
      bottom: 15px;
      right: 20px;
      background: rgba(255,255,255,0.1);
      border: 1px solid rgba(255,255,255,0.3);
      color: white;
      padding: 8px 16px;
      border-radius: 20px;
      font-family: inherit;
      font-size: 0.85rem;
      cursor: pointer;
      z-index: 10;
      transition: all 0.3s;
    }

    #reset-btn:hover {
      background: rgba(255,255,255,0.2);
    }
  </style>
</head>
<body>
  <div id="game-container">
    <canvas id="canvas"></canvas>
  </div>

  <div id="ui">
    <div id="score">ðŸŽ„ Ornaments: <span id="ornament-count">0</span></div>
    <div id="instructions">Click & drag to throw snowballs!</div>
  </div>

  <a id="back-link" href="https://sloppy.live">sloppy.live</a>
  <button id="reset-btn">ðŸ”„ New Tree</button>

  <script>
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    const ornamentCountEl = document.getElementById('ornament-count');
    const instructionsEl = document.getElementById('instructions');

    let W, H;
    let tree = { x: 0, y: 0, angle: 0, angularVel: 0 };
    let ornaments = [];
    let snowballs = [];
    let particles = [];
    let isDragging = false;
    let dragStart = { x: 0, y: 0 };
    let dragEnd = { x: 0, y: 0 };
    let throwCount = 0;
    let screenShake = { x: 0, y: 0, intensity: 0 };
    let goldenStar = null;
    let goldenStarTimer = 0;
    let starsCollected = 0;

    const ORNAMENT_COLORS = ['#e63946', '#ffd700', '#4cc9f0', '#9d4edd', '#c0c0c0', '#ff6b6b', '#48cae4', '#f72585'];
    const RAINBOW_COLORS = ['#ff0000', '#ff7700', '#ffdd00', '#00ff00', '#0099ff', '#6600ff', '#ff00ff'];

    function resize() {
      W = canvas.width = window.innerWidth;
      H = canvas.height = window.innerHeight;
      tree.x = W / 2;
      tree.y = H * 0.85;
    }

    function createStars() {
      for (let i = 0; i < 50; i++) {
        const star = document.createElement('div');
        star.className = 'star';
        star.style.left = Math.random() * 100 + '%';
        star.style.top = Math.random() * 40 + '%';
        star.style.animationDelay = Math.random() * 2 + 's';
        document.getElementById('game-container').appendChild(star);
      }
    }

    function createSnowflakes() {
      for (let i = 0; i < 30; i++) {
        const flake = document.createElement('div');
        flake.className = 'snowflake';
        flake.textContent = 'â„';
        flake.style.left = Math.random() * 100 + '%';
        flake.style.animationDuration = (5 + Math.random() * 10) + 's';
        flake.style.animationDelay = Math.random() * 10 + 's';
        flake.style.fontSize = (8 + Math.random() * 12) + 'px';
        document.getElementById('game-container').appendChild(flake);
      }
    }

    // Tree shape points (triangle layers)
    function getTreePoints() {
      const baseY = tree.y;
      const layers = [
        { width: 180, height: 120, y: baseY - 100 },
        { width: 140, height: 100, y: baseY - 180 },
        { width: 100, height: 80, y: baseY - 250 },
        { width: 60, height: 60, y: baseY - 310 }
      ];
      return layers;
    }

    function drawTree() {
      ctx.save();
      ctx.translate(tree.x, tree.y);
      ctx.rotate(tree.angle);
      ctx.translate(-tree.x, -tree.y);

      // Trunk
      ctx.fillStyle = '#5c3d2e';
      ctx.fillRect(tree.x - 20, tree.y - 40, 40, 60);

      // Tree layers
      const layers = getTreePoints();
      layers.forEach((layer, i) => {
        const gradient = ctx.createLinearGradient(
          tree.x - layer.width/2, layer.y,
          tree.x + layer.width/2, layer.y
        );
        gradient.addColorStop(0, '#0d3318');
        gradient.addColorStop(0.5, '#1a5c2e');
        gradient.addColorStop(1, '#0d3318');

        ctx.fillStyle = gradient;
        ctx.beginPath();
        ctx.moveTo(tree.x, layer.y - layer.height);
        ctx.lineTo(tree.x + layer.width/2, layer.y);
        ctx.lineTo(tree.x - layer.width/2, layer.y);
        ctx.closePath();
        ctx.fill();

        // Snow on edges
        ctx.strokeStyle = 'rgba(255,255,255,0.4)';
        ctx.lineWidth = 3;
        ctx.beginPath();
        ctx.moveTo(tree.x, layer.y - layer.height);
        ctx.lineTo(tree.x + layer.width/2 - 10, layer.y - 5);
        ctx.stroke();
      });

      // Star on top
      drawStar(tree.x, tree.y - 350, 25, 5, 0.5);

      // Draw ornaments
      ornaments.forEach(orn => {
        const worldX = tree.x + orn.localX;
        const worldY = orn.localY;

        // String
        ctx.strokeStyle = '#333';
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.moveTo(worldX, worldY - 12);
        ctx.lineTo(worldX, worldY - 18);
        ctx.stroke();

        // Ornament ball
        const gradient = ctx.createRadialGradient(
          worldX - 3, worldY - 5, 0,
          worldX, worldY, 12
        );
        gradient.addColorStop(0, 'white');
        gradient.addColorStop(0.3, orn.color);
        gradient.addColorStop(1, shadeColor(orn.color, -30));

        ctx.fillStyle = gradient;
        ctx.beginPath();
        ctx.arc(worldX, worldY, 12, 0, Math.PI * 2);
        ctx.fill();

        // Shine
        ctx.fillStyle = 'rgba(255,255,255,0.6)';
        ctx.beginPath();
        ctx.arc(worldX - 4, worldY - 4, 3, 0, Math.PI * 2);
        ctx.fill();

        // Cap
        ctx.fillStyle = '#ffd700';
        ctx.fillRect(worldX - 4, worldY - 16, 8, 5);
      });

      ctx.restore();
    }

    function drawStar(cx, cy, outerR, points, innerRatio) {
      const innerR = outerR * innerRatio;
      ctx.fillStyle = '#ffd700';
      ctx.shadowColor = '#ffd700';
      ctx.shadowBlur = 20;
      ctx.beginPath();
      for (let i = 0; i < points * 2; i++) {
        const r = i % 2 === 0 ? outerR : innerR;
        const angle = (Math.PI / points) * i - Math.PI / 2;
        const x = cx + r * Math.cos(angle);
        const y = cy + r * Math.sin(angle);
        if (i === 0) ctx.moveTo(x, y);
        else ctx.lineTo(x, y);
      }
      ctx.closePath();
      ctx.fill();
      ctx.shadowBlur = 0;
    }

    // Golden Star functions
    function spawnGoldenStar() {
      const baseY = tree.y;
      goldenStar = {
        x: tree.x + (Math.random() - 0.5) * 200,
        y: baseY - 150 - Math.random() * 150,
        radius: 30,
        angle: 0,
        bobOffset: Math.random() * Math.PI * 2,
        pulsePhase: 0
      };
    }

    function drawGoldenStar() {
      if (!goldenStar) return;

      const bobY = Math.sin(Date.now() * 0.003 + goldenStar.bobOffset) * 10;
      const pulse = 1 + Math.sin(Date.now() * 0.008) * 0.15;
      const x = goldenStar.x;
      const y = goldenStar.y + bobY;

      // Outer glow
      ctx.save();
      ctx.shadowColor = '#ffd700';
      ctx.shadowBlur = 40;

      // Rainbow rotating glow
      const glowGradient = ctx.createRadialGradient(x, y, 0, x, y, goldenStar.radius * 2);
      const hue = (Date.now() * 0.1) % 360;
      glowGradient.addColorStop(0, `hsla(${hue}, 100%, 70%, 0.8)`);
      glowGradient.addColorStop(0.5, `hsla(${(hue + 60) % 360}, 100%, 60%, 0.3)`);
      glowGradient.addColorStop(1, 'transparent');
      ctx.fillStyle = glowGradient;
      ctx.beginPath();
      ctx.arc(x, y, goldenStar.radius * 2, 0, Math.PI * 2);
      ctx.fill();

      // Star shape
      const outerR = goldenStar.radius * pulse;
      const innerR = outerR * 0.4;
      const points = 5;

      ctx.fillStyle = '#ffd700';
      ctx.strokeStyle = '#fff8dc';
      ctx.lineWidth = 2;
      ctx.beginPath();
      for (let i = 0; i < points * 2; i++) {
        const r = i % 2 === 0 ? outerR : innerR;
        const angle = (Math.PI / points) * i - Math.PI / 2 + Date.now() * 0.001;
        const px = x + r * Math.cos(angle);
        const py = y + r * Math.sin(angle);
        if (i === 0) ctx.moveTo(px, py);
        else ctx.lineTo(px, py);
      }
      ctx.closePath();
      ctx.fill();
      ctx.stroke();

      // Inner sparkle
      ctx.fillStyle = '#ffffff';
      ctx.beginPath();
      ctx.arc(x, y, 8, 0, Math.PI * 2);
      ctx.fill();

      ctx.restore();
    }

    function checkGoldenStarCollision(ball) {
      if (!goldenStar) return false;
      const bobY = Math.sin(Date.now() * 0.003 + goldenStar.bobOffset) * 10;
      const dx = ball.x - goldenStar.x;
      const dy = ball.y - (goldenStar.y + bobY);
      const dist = Math.sqrt(dx * dx + dy * dy);
      return dist < goldenStar.radius + ball.radius;
    }

    function triggerGoldenStarHit() {
      // Massive screen shake
      screenShake.intensity = 30;

      // Rainbow particle explosion
      const x = goldenStar.x;
      const y = goldenStar.y;
      for (let i = 0; i < 100; i++) {
        const angle = (Math.PI * 2 / 100) * i + Math.random() * 0.5;
        const speed = 8 + Math.random() * 15;
        particles.push({
          x: x,
          y: y,
          vx: Math.cos(angle) * speed,
          vy: Math.sin(angle) * speed,
          radius: 4 + Math.random() * 8,
          color: RAINBOW_COLORS[i % RAINBOW_COLORS.length],
          life: 1.5
        });
      }

      // Extra sparkles
      for (let i = 0; i < 50; i++) {
        particles.push({
          x: x + (Math.random() - 0.5) * 100,
          y: y + (Math.random() - 0.5) * 100,
          vx: (Math.random() - 0.5) * 20,
          vy: (Math.random() - 0.5) * 20 - 5,
          radius: 2 + Math.random() * 4,
          color: '#ffffff',
          life: 1.2
        });
      }

      // Big tree shake
      tree.angularVel += (Math.random() - 0.5) * 0.5;

      starsCollected++;
      goldenStar = null;
      goldenStarTimer = 0;
    }

    function updateScreenShake() {
      if (screenShake.intensity > 0) {
        screenShake.x = (Math.random() - 0.5) * screenShake.intensity;
        screenShake.y = (Math.random() - 0.5) * screenShake.intensity;
        screenShake.intensity *= 0.9;
        if (screenShake.intensity < 0.5) {
          screenShake.intensity = 0;
          screenShake.x = 0;
          screenShake.y = 0;
        }
      }
    }

    function updateGoldenStar() {
      if (!goldenStar) {
        goldenStarTimer++;
        // Spawn: ~5% chance every frame after 300 frames (5 seconds)
        if (goldenStarTimer > 300 && Math.random() < 0.05) {
          spawnGoldenStar();
        }
      }
    }

    function shadeColor(color, percent) {
      const num = parseInt(color.replace('#', ''), 16);
      const amt = Math.round(2.55 * percent);
      const R = Math.min(255, Math.max(0, (num >> 16) + amt));
      const G = Math.min(255, Math.max(0, ((num >> 8) & 0x00FF) + amt));
      const B = Math.min(255, Math.max(0, (num & 0x0000FF) + amt));
      return '#' + (0x1000000 + R * 0x10000 + G * 0x100 + B).toString(16).slice(1);
    }

    function drawSnowballs() {
      snowballs.forEach(ball => {
        // Shadow
        ctx.fillStyle = 'rgba(0,0,0,0.2)';
        ctx.beginPath();
        ctx.ellipse(ball.x, ball.y + ball.radius + 5, ball.radius * 0.8, ball.radius * 0.3, 0, 0, Math.PI * 2);
        ctx.fill();

        // Snowball
        const gradient = ctx.createRadialGradient(
          ball.x - ball.radius * 0.3, ball.y - ball.radius * 0.3, 0,
          ball.x, ball.y, ball.radius
        );
        gradient.addColorStop(0, '#ffffff');
        gradient.addColorStop(1, '#d0e8f0');

        ctx.fillStyle = gradient;
        ctx.beginPath();
        ctx.arc(ball.x, ball.y, ball.radius, 0, Math.PI * 2);
        ctx.fill();
      });
    }

    function drawAimLine() {
      if (isDragging) {
        const dx = dragStart.x - dragEnd.x;
        const dy = dragStart.y - dragEnd.y;
        const dist = Math.min(Math.sqrt(dx*dx + dy*dy), 200);

        ctx.strokeStyle = 'rgba(255,255,255,0.5)';
        ctx.lineWidth = 3;
        ctx.setLineDash([10, 10]);
        ctx.beginPath();
        ctx.moveTo(dragStart.x, dragStart.y);
        ctx.lineTo(dragStart.x + dx * 0.5, dragStart.y + dy * 0.5);
        ctx.stroke();
        ctx.setLineDash([]);

        // Power indicator
        const power = dist / 200;
        ctx.fillStyle = `rgba(255, ${255 - power * 200}, ${100 - power * 100}, 0.8)`;
        ctx.beginPath();
        ctx.arc(dragStart.x, dragStart.y, 10 + power * 15, 0, Math.PI * 2);
        ctx.fill();
      }
    }

    function drawParticles() {
      particles.forEach(p => {
        ctx.globalAlpha = p.life;
        ctx.fillStyle = p.color;
        ctx.beginPath();
        ctx.arc(p.x, p.y, p.radius, 0, Math.PI * 2);
        ctx.fill();
      });
      ctx.globalAlpha = 1;
    }

    function drawGround() {
      // Snow ground
      const gradient = ctx.createLinearGradient(0, H - 80, 0, H);
      gradient.addColorStop(0, '#e8f4f8');
      gradient.addColorStop(1, '#c8dce0');
      ctx.fillStyle = gradient;

      ctx.beginPath();
      ctx.moveTo(0, H - 60);
      // Wavy snow
      for (let x = 0; x <= W; x += 50) {
        ctx.lineTo(x, H - 60 + Math.sin(x * 0.02) * 10);
      }
      ctx.lineTo(W, H);
      ctx.lineTo(0, H);
      ctx.closePath();
      ctx.fill();
    }

    function update() {
      // Tree physics (spring)
      const springK = 0.08;
      const damping = 0.92;
      tree.angularVel += -tree.angle * springK;
      tree.angularVel *= damping;
      tree.angle += tree.angularVel;

      // Update screen shake
      updateScreenShake();

      // Update golden star spawning
      updateGoldenStar();

      // Update snowballs
      snowballs.forEach((ball, i) => {
        ball.x += ball.vx;
        ball.y += ball.vy;
        ball.vy += 0.5; // gravity

        // Check collision with golden star first (priority)
        if (checkGoldenStarCollision(ball)) {
          triggerGoldenStarHit();
          snowballs.splice(i, 1);
          return;
        }

        // Check collision with tree
        if (checkTreeCollision(ball)) {
          // Hit! Add ornament
          const hitX = ball.x - tree.x;
          const hitY = ball.y;

          // Apply force to tree
          const force = (ball.vx * 0.01);
          tree.angularVel += force;

          // Add ornament at hit location (adjusted to be on tree)
          const localX = hitX * 0.7; // Bring closer to center
          ornaments.push({
            localX: localX,
            localY: hitY,
            color: ORNAMENT_COLORS[Math.floor(Math.random() * ORNAMENT_COLORS.length)]
          });

          ornamentCountEl.textContent = ornaments.length;

          // Particles
          for (let j = 0; j < 15; j++) {
            particles.push({
              x: ball.x,
              y: ball.y,
              vx: (Math.random() - 0.5) * 8,
              vy: (Math.random() - 0.5) * 8,
              radius: 2 + Math.random() * 4,
              color: '#ffffff',
              life: 1
            });
          }

          snowballs.splice(i, 1);
        }

        // Remove if off screen
        if (ball.y > H + 50 || ball.x < -50 || ball.x > W + 50) {
          snowballs.splice(i, 1);
        }
      });

      // Update particles
      particles.forEach((p, i) => {
        p.x += p.vx;
        p.y += p.vy;
        p.vy += 0.3;
        p.life -= 0.03;
        if (p.life <= 0) particles.splice(i, 1);
      });
    }

    function checkTreeCollision(ball) {
      const layers = getTreePoints();

      for (const layer of layers) {
        // Check if ball is within this layer's triangle
        const topY = layer.y - layer.height;
        const bottomY = layer.y;

        if (ball.y > topY && ball.y < bottomY) {
          // Calculate tree width at this height
          const progress = (ball.y - topY) / layer.height;
          const widthAtHeight = progress * layer.width;
          const leftEdge = tree.x - widthAtHeight / 2;
          const rightEdge = tree.x + widthAtHeight / 2;

          if (ball.x > leftEdge && ball.x < rightEdge) {
            return true;
          }
        }
      }
      return false;
    }

    function draw() {
      ctx.clearRect(0, 0, W, H);

      // Apply screen shake
      ctx.save();
      ctx.translate(screenShake.x, screenShake.y);

      drawGround();
      drawTree();
      drawGoldenStar();
      drawSnowballs();
      drawParticles();
      drawAimLine();

      ctx.restore();
    }

    function gameLoop() {
      update();
      draw();
      requestAnimationFrame(gameLoop);
    }

    // Input handling
    function getPos(e) {
      if (e.touches) {
        return { x: e.touches[0].clientX, y: e.touches[0].clientY };
      }
      return { x: e.clientX, y: e.clientY };
    }

    function onStart(e) {
      e.preventDefault();
      const pos = getPos(e);
      isDragging = true;
      dragStart = { ...pos };
      dragEnd = { ...pos };

      // Hide instructions after first throw
      if (throwCount === 0) {
        instructionsEl.classList.add('hidden');
      }
    }

    function onMove(e) {
      if (!isDragging) return;
      e.preventDefault();
      dragEnd = getPos(e);
    }

    function onEnd(e) {
      if (!isDragging) return;
      isDragging = false;

      const dx = dragStart.x - dragEnd.x;
      const dy = dragStart.y - dragEnd.y;
      const dist = Math.sqrt(dx*dx + dy*dy);

      if (dist > 20) {
        const power = Math.min(dist / 200, 1);
        const speed = 15 + power * 20;
        const angle = Math.atan2(dy, dx);

        snowballs.push({
          x: dragStart.x,
          y: dragStart.y,
          vx: Math.cos(angle) * speed,
          vy: Math.sin(angle) * speed,
          radius: 15
        });

        throwCount++;
      }
    }

    canvas.addEventListener('mousedown', onStart);
    canvas.addEventListener('mousemove', onMove);
    canvas.addEventListener('mouseup', onEnd);
    canvas.addEventListener('mouseleave', onEnd);

    canvas.addEventListener('touchstart', onStart, { passive: false });
    canvas.addEventListener('touchmove', onMove, { passive: false });
    canvas.addEventListener('touchend', onEnd);

    document.getElementById('reset-btn').addEventListener('click', () => {
      ornaments = [];
      snowballs = [];
      particles = [];
      tree.angle = 0;
      tree.angularVel = 0;
      goldenStar = null;
      goldenStarTimer = 0;
      starsCollected = 0;
      screenShake = { x: 0, y: 0, intensity: 0 };
      ornamentCountEl.textContent = '0';
    });

    window.addEventListener('resize', resize);

    // Init
    resize();
    createStars();
    createSnowflakes();
    gameLoop();
  </script>
<script src="/sloppy-header/sloppy-bar.js"></script>
</body>
</html>
