<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Prism Echo - Living Mandalas</title>
  <link rel="icon" href="https://emojicdn.elk.sh/%F0%9F%94%AE">
  <meta property="og:title" content="Prism Echo">
  <meta property="og:description" content="Procedural neon mandalas pulsing with chat energy">
  <meta property="og:url" content="https://sloppy.live/prism-echo">
  <meta property="og:image" content="https://sloppy.live/prism-echo/og-image.png">
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&display=swap" rel="stylesheet">
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }

    body {
      background: #000;
      min-height: 100vh;
      overflow: hidden;
      font-family: 'Orbitron', sans-serif;
    }

    canvas {
      display: block;
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
    }

    .ui-overlay {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      padding: 20px;
      display: flex;
      justify-content: space-between;
      align-items: flex-start;
      pointer-events: none;
      z-index: 10;
    }

    .title-block {
      text-align: left;
    }

    .title {
      font-size: 2rem;
      font-weight: 900;
      letter-spacing: 0.2em;
      background: linear-gradient(90deg, #ff00ff, #00ffff, #ff00ff);
      background-size: 200% auto;
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      animation: gradient-shift 3s linear infinite;
      text-shadow: 0 0 30px rgba(255, 0, 255, 0.5);
    }

    @keyframes gradient-shift {
      0% { background-position: 0% center; }
      100% { background-position: 200% center; }
    }

    .subtitle {
      font-size: 0.7rem;
      letter-spacing: 0.3em;
      color: rgba(255, 255, 255, 0.4);
      margin-top: 5px;
    }

    .stats-block {
      text-align: right;
      background: rgba(0, 0, 0, 0.6);
      padding: 15px 20px;
      border: 1px solid rgba(255, 0, 255, 0.3);
      border-radius: 8px;
      backdrop-filter: blur(10px);
    }

    .stat-row {
      display: flex;
      align-items: center;
      gap: 10px;
      margin-bottom: 8px;
      font-size: 0.75rem;
      color: rgba(255, 255, 255, 0.7);
    }

    .stat-row:last-child { margin-bottom: 0; }

    .stat-label {
      letter-spacing: 0.1em;
      color: rgba(255, 255, 255, 0.4);
    }

    .stat-value {
      font-weight: 700;
      color: #00ffff;
      min-width: 50px;
      text-align: right;
    }

    .stat-value.high { color: #ff00ff; }
    .stat-value.pulse { animation: pulse-glow 0.5s ease-out; }

    @keyframes pulse-glow {
      0% { text-shadow: 0 0 20px currentColor; transform: scale(1.2); }
      100% { text-shadow: none; transform: scale(1); }
    }

    .frequency-bar {
      width: 100px;
      height: 6px;
      background: rgba(255, 255, 255, 0.1);
      border-radius: 3px;
      overflow: hidden;
    }

    .frequency-fill {
      height: 100%;
      background: linear-gradient(90deg, #00ffff, #ff00ff);
      border-radius: 3px;
      transition: width 0.3s ease-out;
    }

    .bottom-ui {
      position: fixed;
      bottom: 20px;
      left: 0;
      right: 0;
      display: flex;
      justify-content: center;
      gap: 15px;
      pointer-events: none;
      z-index: 10;
    }

    .control-btn {
      pointer-events: auto;
      background: rgba(0, 0, 0, 0.6);
      border: 1px solid rgba(255, 0, 255, 0.4);
      color: #fff;
      padding: 10px 20px;
      font-family: 'Orbitron', sans-serif;
      font-size: 0.7rem;
      letter-spacing: 0.15em;
      cursor: pointer;
      border-radius: 4px;
      transition: all 0.2s;
    }

    .control-btn:hover {
      background: rgba(255, 0, 255, 0.2);
      border-color: #ff00ff;
      box-shadow: 0 0 20px rgba(255, 0, 255, 0.3);
    }

    .control-btn.active {
      background: rgba(255, 0, 255, 0.3);
      border-color: #ff00ff;
    }

    .back-link {
      position: fixed;
      bottom: 20px;
      left: 20px;
      color: rgba(255, 255, 255, 0.3);
      text-decoration: none;
      font-size: 0.7rem;
      letter-spacing: 0.1em;
      pointer-events: auto;
      z-index: 10;
      transition: color 0.2s;
    }

    .back-link:hover { color: #00ffff; }

    .echo-indicator {
      position: fixed;
      bottom: 80px;
      right: 20px;
      width: 60px;
      height: 60px;
      border-radius: 50%;
      border: 2px solid rgba(255, 0, 255, 0.3);
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 0.6rem;
      color: rgba(255, 255, 255, 0.5);
      background: rgba(0, 0, 0, 0.4);
      z-index: 10;
    }

    .echo-indicator::before {
      content: '';
      position: absolute;
      width: 100%;
      height: 100%;
      border-radius: 50%;
      border: 2px solid #ff00ff;
      animation: echo-ring 2s ease-out infinite;
      opacity: 0;
    }

    .echo-indicator.active::before {
      opacity: 1;
    }

    @keyframes echo-ring {
      0% { transform: scale(1); opacity: 0.8; }
      100% { transform: scale(2); opacity: 0; }
    }
  </style>
</head>
<body>
  <canvas id="mandalaCanvas"></canvas>

  <div class="ui-overlay">
    <div class="title-block">
      <h1 class="title">PRISM ECHO</h1>
      <p class="subtitle">CHAT-REACTIVE MANDALAS</p>
    </div>
    <div class="stats-block">
      <div class="stat-row">
        <span class="stat-label">FREQUENCY</span>
        <div class="frequency-bar">
          <div class="frequency-fill" id="frequencyFill" style="width: 0%"></div>
        </div>
      </div>
      <div class="stat-row">
        <span class="stat-label">MESSAGES/MIN</span>
        <span class="stat-value" id="msgRate">0</span>
      </div>
      <div class="stat-row">
        <span class="stat-label">SYMMETRY</span>
        <span class="stat-value" id="symmetryVal">8</span>
      </div>
      <div class="stat-row">
        <span class="stat-label">LAYERS</span>
        <span class="stat-value" id="layersVal">5</span>
      </div>
    </div>
  </div>

  <div class="bottom-ui">
    <button class="control-btn" onclick="cycleColorScheme()">COLORS</button>
    <button class="control-btn" onclick="toggleRotation()">ROTATION</button>
    <button class="control-btn" onclick="regenerate()">REGENERATE</button>
  </div>

  <div class="echo-indicator" id="echoIndicator">
    <span>ECHO</span>
  </div>

  <a href="https://sloppy.live" class="back-link">‚Üê SLOPPY.LIVE</a>

  <script type="module">
    import supabase from '/supabase-config.js';

    const canvas = document.getElementById('mandalaCanvas');
    const ctx = canvas.getContext('2d');

    // === STATE ===
    let width, height, centerX, centerY;
    let time = 0;
    let chatFrequency = 0;
    let targetFrequency = 0;
    let messageCount = 0;
    let lastMessageCount = 0;
    let messagesPerMinute = 0;
    let rotating = true;
    let rotationAngle = 0;
    let colorSchemeIndex = 0;

    // Mandala parameters
    let symmetry = 8;
    let layers = 5;
    let seed = Math.random() * 1000;

    const colorSchemes = [
      { name: 'Neon', colors: ['#ff00ff', '#00ffff', '#ff00aa', '#00ffaa', '#aa00ff'] },
      { name: 'Fire', colors: ['#ff0000', '#ff6600', '#ffaa00', '#ff3300', '#ffcc00'] },
      { name: 'Ice', colors: ['#00ffff', '#0088ff', '#00aaff', '#0066ff', '#00ccff'] },
      { name: 'Toxic', colors: ['#00ff00', '#88ff00', '#00ff88', '#aaff00', '#00ffaa'] },
      { name: 'Void', colors: ['#8800ff', '#ff0088', '#0088ff', '#ff8800', '#00ff88'] }
    ];

    // === RESIZE ===
    function resize() {
      width = canvas.width = window.innerWidth;
      height = canvas.height = window.innerHeight;
      centerX = width / 2;
      centerY = height / 2;
    }
    window.addEventListener('resize', resize);
    resize();

    // === PROCEDURAL NOISE ===
    function noise(x, y, z) {
      const p = seed + x * 12.9898 + y * 78.233 + z * 43.758;
      return (Math.sin(p) * 43758.5453) % 1;
    }

    function smoothNoise(x, y, z) {
      const x0 = Math.floor(x), y0 = Math.floor(y), z0 = Math.floor(z);
      const fx = x - x0, fy = y - y0, fz = z - z0;
      const sx = fx * fx * (3 - 2 * fx);
      const sy = fy * fy * (3 - 2 * fy);
      const sz = fz * fz * (3 - 2 * fz);

      let n = 0;
      n += noise(x0, y0, z0) * (1-sx) * (1-sy) * (1-sz);
      n += noise(x0+1, y0, z0) * sx * (1-sy) * (1-sz);
      n += noise(x0, y0+1, z0) * (1-sx) * sy * (1-sz);
      n += noise(x0+1, y0+1, z0) * sx * sy * (1-sz);
      n += noise(x0, y0, z0+1) * (1-sx) * (1-sy) * sz;
      n += noise(x0+1, y0, z0+1) * sx * (1-sy) * sz;
      n += noise(x0, y0+1, z0+1) * (1-sx) * sy * sz;
      n += noise(x0+1, y0+1, z0+1) * sx * sy * sz;
      return n;
    }

    // === MANDALA DRAWING ===
    function drawMandala() {
      const scheme = colorSchemes[colorSchemeIndex];
      const maxRadius = Math.min(width, height) * 0.42;
      const pulseScale = 1 + chatFrequency * 0.15;
      const breathe = Math.sin(time * 0.5) * 0.03 + 1;

      ctx.save();
      ctx.translate(centerX, centerY);
      if (rotating) {
        ctx.rotate(rotationAngle);
      }

      // Draw layers from outside in
      for (let layer = layers; layer >= 1; layer--) {
        const layerRadius = (maxRadius / layers) * layer * pulseScale * breathe;
        const layerComplexity = 3 + layer * 2;
        const layerSymmetry = symmetry + Math.floor(chatFrequency * 4);

        drawMandalaLayer(layerRadius, layerComplexity, layerSymmetry, layer, scheme);
      }

      // Center glow
      const glowRadius = 30 + chatFrequency * 20;
      const gradient = ctx.createRadialGradient(0, 0, 0, 0, 0, glowRadius);
      gradient.addColorStop(0, scheme.colors[0]);
      gradient.addColorStop(0.5, scheme.colors[0] + '44');
      gradient.addColorStop(1, 'transparent');
      ctx.fillStyle = gradient;
      ctx.beginPath();
      ctx.arc(0, 0, glowRadius, 0, Math.PI * 2);
      ctx.fill();

      ctx.restore();
    }

    function drawMandalaLayer(radius, complexity, sym, layerIndex, scheme) {
      const angleStep = (Math.PI * 2) / sym;
      const color = scheme.colors[layerIndex % scheme.colors.length];
      const alpha = 0.3 + chatFrequency * 0.4;

      for (let i = 0; i < sym; i++) {
        ctx.save();
        ctx.rotate(angleStep * i);

        // Petal shape
        const petalLength = radius * (0.8 + smoothNoise(layerIndex, i, time * 0.1) * 0.4);
        const petalWidth = radius * 0.15 * (1 + chatFrequency * 0.5);
        const curveOffset = smoothNoise(i, layerIndex, time * 0.2) * 20;

        ctx.strokeStyle = color;
        ctx.lineWidth = 1 + chatFrequency * 2;
        ctx.shadowColor = color;
        ctx.shadowBlur = 10 + chatFrequency * 20;
        ctx.globalAlpha = alpha;

        // Draw petal
        ctx.beginPath();
        ctx.moveTo(0, 0);
        ctx.quadraticCurveTo(
          petalWidth + curveOffset, petalLength * 0.5,
          0, petalLength
        );
        ctx.quadraticCurveTo(
          -petalWidth - curveOffset, petalLength * 0.5,
          0, 0
        );
        ctx.stroke();

        // Inner details
        if (complexity > 5) {
          const innerRadius = radius * 0.5;
          ctx.beginPath();
          ctx.arc(0, innerRadius, radius * 0.1, 0, Math.PI * 2);
          ctx.stroke();
        }

        // Dots
        for (let d = 1; d <= complexity; d++) {
          const dotDist = (petalLength / complexity) * d;
          const dotSize = 2 + chatFrequency * 3;
          ctx.beginPath();
          ctx.arc(0, dotDist, dotSize, 0, Math.PI * 2);
          ctx.fillStyle = color;
          ctx.fill();
        }

        ctx.restore();
      }

      // Connecting rings
      ctx.strokeStyle = color + '66';
      ctx.lineWidth = 0.5 + chatFrequency;
      ctx.shadowBlur = 5;
      ctx.beginPath();
      ctx.arc(0, 0, radius * 0.7, 0, Math.PI * 2);
      ctx.stroke();
    }

    // === ANIMATION LOOP ===
    function animate() {
      // Clear with fade effect
      ctx.fillStyle = 'rgba(0, 0, 0, 0.1)';
      ctx.fillRect(0, 0, width, height);

      // Smooth frequency interpolation
      chatFrequency += (targetFrequency - chatFrequency) * 0.05;

      // Update rotation
      if (rotating) {
        rotationAngle += 0.002 + chatFrequency * 0.01;
      }

      time += 0.016;

      drawMandala();

      requestAnimationFrame(animate);
    }

    // === CHAT FREQUENCY MONITORING ===
    async function fetchMessageCount() {
      try {
        const fiveMinutesAgo = new Date(Date.now() - 5 * 60 * 1000).toISOString();

        const { count, error } = await supabase
          .from('sloppygram_messages')
          .select('*', { count: 'exact', head: true })
          .gte('created_at', fiveMinutesAgo);

        if (!error && count !== null) {
          const newCount = count;
          const delta = newCount - lastMessageCount;

          if (delta > 0 && lastMessageCount > 0) {
            // New messages detected - pulse!
            triggerEcho(delta);
          }

          lastMessageCount = newCount;
          messageCount = newCount;

          // Calculate messages per minute (over 5 min window)
          messagesPerMinute = Math.round(newCount / 5);

          // Map to frequency (0-1 range)
          targetFrequency = Math.min(1, messagesPerMinute / 20);

          updateStats();
        }
      } catch (err) {
        console.error('[Prism Echo] Fetch error:', err);
      }
    }

    function triggerEcho(count) {
      const indicator = document.getElementById('echoIndicator');
      indicator.classList.add('active');

      // Boost frequency temporarily
      targetFrequency = Math.min(1, targetFrequency + count * 0.1);

      // Increase complexity briefly
      symmetry = Math.min(16, 8 + count);
      setTimeout(() => {
        symmetry = 8;
        indicator.classList.remove('active');
      }, 2000);

      // Pulse the stats
      document.getElementById('msgRate').classList.add('pulse');
      setTimeout(() => document.getElementById('msgRate').classList.remove('pulse'), 500);
    }

    function updateStats() {
      const freqPercent = Math.round(chatFrequency * 100);
      document.getElementById('frequencyFill').style.width = freqPercent + '%';
      document.getElementById('msgRate').textContent = messagesPerMinute;
      document.getElementById('msgRate').className = 'stat-value' + (messagesPerMinute > 10 ? ' high' : '');
      document.getElementById('symmetryVal').textContent = symmetry;
      document.getElementById('layersVal').textContent = layers;
    }

    // === REALTIME SUBSCRIPTION ===
    function subscribeToChat() {
      supabase
        .channel('prism-echo-chat')
        .on('postgres_changes', {
          event: 'INSERT',
          schema: 'public',
          table: 'sloppygram_messages'
        }, (payload) => {
          triggerEcho(1);
          messageCount++;
          messagesPerMinute = Math.min(99, messagesPerMinute + 1);
          updateStats();
        })
        .subscribe();
    }

    // === CONTROLS ===
    window.cycleColorScheme = function() {
      colorSchemeIndex = (colorSchemeIndex + 1) % colorSchemes.length;
    };

    window.toggleRotation = function() {
      rotating = !rotating;
      document.querySelector('.control-btn:nth-child(2)').classList.toggle('active', rotating);
    };

    window.regenerate = function() {
      seed = Math.random() * 1000;
      layers = 3 + Math.floor(Math.random() * 5);
      symmetry = 6 + Math.floor(Math.random() * 10);
      updateStats();
    };

    // === INIT ===
    function init() {
      animate();
      fetchMessageCount();
      subscribeToChat();

      // Poll for message count every 30 seconds
      setInterval(fetchMessageCount, 30000);

      // Set initial rotation button state
      document.querySelector('.control-btn:nth-child(2)').classList.add('active');

      console.log('[Prism Echo] Initialized - watching chat frequency');
    }

    init();
  </script>
</body>
</html>
