<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Prism Echo - Living Mandalas</title>
  <link rel="icon" href="https://emojicdn.elk.sh/%F0%9F%94%AE">
  <meta property="og:title" content="Prism Echo">
  <meta property="og:description" content="Procedural neon mandalas pulsing with chat energy">
  <meta property="og:url" content="https://sloppy.live/prism-echo">
  <meta property="og:image" content="https://sloppy.live/prism-echo/og-image.png">
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&display=swap" rel="stylesheet">
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }

    body {
      background: #000;
      min-height: 100vh;
      overflow: hidden;
      font-family: 'Orbitron', sans-serif;
    }

    canvas {
      display: block;
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
    }

    .ui-overlay {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      padding: 20px;
      display: flex;
      justify-content: space-between;
      align-items: flex-start;
      pointer-events: none;
      z-index: 10;
    }

    .title-block {
      text-align: left;
    }

    .title {
      font-size: 2rem;
      font-weight: 900;
      letter-spacing: 0.2em;
      background: linear-gradient(90deg, #ff00ff, #00ffff, #ff00ff);
      background-size: 200% auto;
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      animation: gradient-shift 3s linear infinite;
      text-shadow: 0 0 30px rgba(255, 0, 255, 0.5);
    }

    @keyframes gradient-shift {
      0% { background-position: 0% center; }
      100% { background-position: 200% center; }
    }

    .subtitle {
      font-size: 0.7rem;
      letter-spacing: 0.3em;
      color: rgba(255, 255, 255, 0.4);
      margin-top: 5px;
    }

    .stats-block {
      text-align: right;
      background: rgba(0, 0, 0, 0.6);
      padding: 15px 20px;
      border: 1px solid rgba(255, 0, 255, 0.3);
      border-radius: 8px;
      backdrop-filter: blur(10px);
    }

    .stat-row {
      display: flex;
      align-items: center;
      gap: 10px;
      margin-bottom: 8px;
      font-size: 0.75rem;
      color: rgba(255, 255, 255, 0.7);
    }

    .stat-row:last-child { margin-bottom: 0; }

    .stat-label {
      letter-spacing: 0.1em;
      color: rgba(255, 255, 255, 0.4);
    }

    .stat-value {
      font-weight: 700;
      color: #00ffff;
      min-width: 50px;
      text-align: right;
    }

    .stat-value.high { color: #ff00ff; }
    .stat-value.pulse { animation: pulse-glow 0.5s ease-out; }

    @keyframes pulse-glow {
      0% { text-shadow: 0 0 20px currentColor; transform: scale(1.2); }
      100% { text-shadow: none; transform: scale(1); }
    }

    .frequency-bar {
      width: 100px;
      height: 6px;
      background: rgba(255, 255, 255, 0.1);
      border-radius: 3px;
      overflow: hidden;
    }

    .frequency-fill {
      height: 100%;
      background: linear-gradient(90deg, #00ffff, #ff00ff);
      border-radius: 3px;
      transition: width 0.3s ease-out;
    }

    .bottom-ui {
      position: fixed;
      bottom: 20px;
      left: 0;
      right: 0;
      display: flex;
      justify-content: center;
      gap: 15px;
      pointer-events: none;
      z-index: 10;
    }

    .control-btn {
      pointer-events: auto;
      background: rgba(0, 0, 0, 0.6);
      border: 1px solid rgba(255, 0, 255, 0.4);
      color: #fff;
      padding: 10px 20px;
      font-family: 'Orbitron', sans-serif;
      font-size: 0.7rem;
      letter-spacing: 0.15em;
      cursor: pointer;
      border-radius: 4px;
      transition: all 0.2s;
    }

    .control-btn:hover {
      background: rgba(255, 0, 255, 0.2);
      border-color: #ff00ff;
      box-shadow: 0 0 20px rgba(255, 0, 255, 0.3);
    }

    .control-btn.active {
      background: rgba(255, 0, 255, 0.3);
      border-color: #ff00ff;
    }

    .back-link {
      position: fixed;
      bottom: 20px;
      left: 20px;
      color: rgba(255, 255, 255, 0.3);
      text-decoration: none;
      font-size: 0.7rem;
      letter-spacing: 0.1em;
      pointer-events: auto;
      z-index: 10;
      transition: color 0.2s;
    }

    .back-link:hover { color: #00ffff; }

    .echo-indicator {
      position: fixed;
      bottom: 80px;
      right: 20px;
      width: 60px;
      height: 60px;
      border-radius: 50%;
      border: 2px solid rgba(255, 0, 255, 0.3);
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 0.6rem;
      color: rgba(255, 255, 255, 0.5);
      background: rgba(0, 0, 0, 0.4);
      z-index: 10;
    }

    .echo-indicator::before {
      content: '';
      position: absolute;
      width: 100%;
      height: 100%;
      border-radius: 50%;
      border: 2px solid #ff00ff;
      animation: echo-ring 2s ease-out infinite;
      opacity: 0;
    }

    .echo-indicator.active::before {
      opacity: 1;
    }

    @keyframes echo-ring {
      0% { transform: scale(1); opacity: 0.8; }
      100% { transform: scale(2); opacity: 0; }
    }
  </style>
</head>
<body>
  <canvas id="mandalaCanvas"></canvas>

  <div class="ui-overlay">
    <div class="title-block">
      <h1 class="title">PRISM ECHO</h1>
      <p class="subtitle">CHAT-REACTIVE MANDALAS</p>
    </div>
    <div class="stats-block">
      <div class="stat-row">
        <span class="stat-label">FREQUENCY</span>
        <div class="frequency-bar">
          <div class="frequency-fill" id="frequencyFill" style="width: 0%"></div>
        </div>
      </div>
      <div class="stat-row">
        <span class="stat-label">MESSAGES/MIN</span>
        <span class="stat-value" id="msgRate">0</span>
      </div>
      <div class="stat-row">
        <span class="stat-label">SYMMETRY</span>
        <span class="stat-value" id="symmetryVal">8</span>
      </div>
      <div class="stat-row">
        <span class="stat-label">LAYERS</span>
        <span class="stat-value" id="layersVal">5</span>
      </div>
      <div class="stat-row">
        <span class="stat-label">GEOMETRY</span>
        <span class="stat-value" id="geometryVal">FLOWER</span>
      </div>
    </div>
  </div>

  <div class="bottom-ui">
    <button class="control-btn" onclick="cycleColorScheme()">COLORS</button>
    <button class="control-btn" onclick="cycleSacredMode()">SACRED</button>
    <button class="control-btn" onclick="toggleRotation()">ROTATION</button>
    <button class="control-btn" onclick="regenerate()">REGENERATE</button>
  </div>

  <div class="echo-indicator" id="echoIndicator">
    <span>ECHO</span>
  </div>

  <a href="https://sloppy.live" class="back-link">‚Üê SLOPPY.LIVE</a>

  <script type="module">
    import supabase from '/supabase-config.js';

    const canvas = document.getElementById('mandalaCanvas');
    const ctx = canvas.getContext('2d');

    // === STATE ===
    let width, height, centerX, centerY;
    let time = 0;
    let chatFrequency = 0;
    let targetFrequency = 0;
    let messageCount = 0;
    let lastMessageCount = 0;
    let messagesPerMinute = 0;
    let rotating = true;
    let rotationAngle = 0;
    let colorSchemeIndex = 0;

    // Mandala parameters
    let symmetry = 8;
    let layers = 5;
    let seed = Math.random() * 1000;
    let sacredMode = 0; // 0: Flower of Life, 1: Metatron, 2: Sri Yantra, 3: Golden Spiral

    // === SACRED GEOMETRY CONSTANTS ===
    const PHI = 1.6180339887;           // Golden Ratio
    const PHI_INV = 0.6180339887;       // 1/PHI
    const PHI_SQ = 2.6180339887;        // PHI squared
    const SQRT3 = Math.sqrt(3);
    const SQRT5 = Math.sqrt(5);
    const TAU = Math.PI * 2;

    // Fibonacci sequence (first 16 numbers)
    const FIB = [1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610, 987];

    // Sacred angles
    const SACRED_ANGLES = {
      hexagon: TAU / 6,
      pentagon: TAU / 5,
      star: TAU / 5 * 2,
      golden: TAU / PHI_SQ
    };

    const colorSchemes = [
      { name: 'Neon', colors: ['#ff00ff', '#00ffff', '#ff00aa', '#00ffaa', '#aa00ff'] },
      { name: 'Fire', colors: ['#ff0000', '#ff6600', '#ffaa00', '#ff3300', '#ffcc00'] },
      { name: 'Ice', colors: ['#00ffff', '#0088ff', '#00aaff', '#0066ff', '#00ccff'] },
      { name: 'Toxic', colors: ['#00ff00', '#88ff00', '#00ff88', '#aaff00', '#00ffaa'] },
      { name: 'Void', colors: ['#8800ff', '#ff0088', '#0088ff', '#ff8800', '#00ff88'] }
    ];

    // === RESIZE ===
    function resize() {
      width = canvas.width = window.innerWidth;
      height = canvas.height = window.innerHeight;
      centerX = width / 2;
      centerY = height / 2;
    }
    window.addEventListener('resize', resize);
    resize();

    // === PROCEDURAL NOISE ===
    function noise(x, y, z) {
      const p = seed + x * 12.9898 + y * 78.233 + z * 43.758;
      return (Math.sin(p) * 43758.5453) % 1;
    }

    function smoothNoise(x, y, z) {
      const x0 = Math.floor(x), y0 = Math.floor(y), z0 = Math.floor(z);
      const fx = x - x0, fy = y - y0, fz = z - z0;
      const sx = fx * fx * (3 - 2 * fx);
      const sy = fy * fy * (3 - 2 * fy);
      const sz = fz * fz * (3 - 2 * fz);

      let n = 0;
      n += noise(x0, y0, z0) * (1-sx) * (1-sy) * (1-sz);
      n += noise(x0+1, y0, z0) * sx * (1-sy) * (1-sz);
      n += noise(x0, y0+1, z0) * (1-sx) * sy * (1-sz);
      n += noise(x0+1, y0+1, z0) * sx * sy * (1-sz);
      n += noise(x0, y0, z0+1) * (1-sx) * (1-sy) * sz;
      n += noise(x0+1, y0, z0+1) * sx * (1-sy) * sz;
      n += noise(x0, y0+1, z0+1) * (1-sx) * sy * sz;
      n += noise(x0+1, y0+1, z0+1) * sx * sy * sz;
      return n;
    }

    // === SACRED GEOMETRY FUNCTIONS ===

    // Draw Vesica Piscis (two overlapping circles)
    function drawVesicaPiscis(x, y, radius, color, alpha) {
      ctx.save();
      ctx.globalAlpha = alpha;
      ctx.strokeStyle = color;
      ctx.lineWidth = 1 + chatFrequency * 1.5;
      ctx.shadowColor = color;
      ctx.shadowBlur = 8 + chatFrequency * 15;

      const offset = radius * 0.5;
      ctx.beginPath();
      ctx.arc(x - offset, y, radius, 0, TAU);
      ctx.stroke();
      ctx.beginPath();
      ctx.arc(x + offset, y, radius, 0, TAU);
      ctx.stroke();
      ctx.restore();
    }

    // Draw Flower of Life pattern
    function drawFlowerOfLife(centerRadius, rings, scheme) {
      const baseRadius = centerRadius / (rings * 2);
      const alpha = 0.5 + chatFrequency * 0.4; // Increased brightness

      // Center circle
      ctx.strokeStyle = scheme.colors[0];
      ctx.lineWidth = 1.5 + chatFrequency * 1.5;
      ctx.shadowColor = scheme.colors[0];
      ctx.shadowBlur = 20 + chatFrequency * 25; // Enhanced glow
      ctx.globalAlpha = alpha;
      ctx.beginPath();
      ctx.arc(0, 0, baseRadius, 0, TAU);
      ctx.stroke();

      // Expanding rings of circles
      for (let ring = 1; ring <= rings; ring++) {
        const ringRadius = baseRadius * ring;
        const circleCount = ring * 6;
        const color = scheme.colors[ring % scheme.colors.length];

        ctx.strokeStyle = color;
        ctx.shadowColor = color;

        for (let i = 0; i < circleCount; i++) {
          const angle = (TAU / circleCount) * i + (ring % 2 ? SACRED_ANGLES.hexagon / 2 : 0);
          const cx = Math.cos(angle) * ringRadius;
          const cy = Math.sin(angle) * ringRadius;

          ctx.beginPath();
          ctx.arc(cx, cy, baseRadius, 0, TAU);
          ctx.stroke();
        }
      }
    }

    // Draw Metatron's Cube
    function drawMetatronsCube(radius, scheme) {
      const alpha = 0.55 + chatFrequency * 0.4; // Increased brightness
      const innerRadius = radius * PHI_INV;

      // 13 circles of Metatron's Cube
      const positions = [
        { x: 0, y: 0 }, // Center
      ];

      // Inner hexagon (6 circles)
      for (let i = 0; i < 6; i++) {
        const angle = SACRED_ANGLES.hexagon * i;
        positions.push({
          x: Math.cos(angle) * innerRadius,
          y: Math.sin(angle) * innerRadius
        });
      }

      // Outer hexagon (6 circles)
      for (let i = 0; i < 6; i++) {
        const angle = SACRED_ANGLES.hexagon * i + SACRED_ANGLES.hexagon / 2;
        positions.push({
          x: Math.cos(angle) * radius,
          y: Math.sin(angle) * radius
        });
      }

      // Draw circles
      ctx.globalAlpha = alpha;
      positions.forEach((pos, idx) => {
        const color = scheme.colors[idx % scheme.colors.length];
        ctx.strokeStyle = color;
        ctx.shadowColor = color;
        ctx.shadowBlur = 18 + chatFrequency * 22; // Enhanced glow
        ctx.lineWidth = 1.5 + chatFrequency * 1.5;
        ctx.beginPath();
        ctx.arc(pos.x, pos.y, innerRadius * 0.5, 0, TAU);
        ctx.stroke();
      });

      // Draw connecting lines (78 lines in Metatron's Cube)
      ctx.lineWidth = 0.5 + chatFrequency * 0.5;
      ctx.globalAlpha = alpha * 0.6;
      for (let i = 0; i < positions.length; i++) {
        for (let j = i + 1; j < positions.length; j++) {
          const color = scheme.colors[(i + j) % scheme.colors.length];
          ctx.strokeStyle = color;
          ctx.shadowColor = color;
          ctx.beginPath();
          ctx.moveTo(positions[i].x, positions[i].y);
          ctx.lineTo(positions[j].x, positions[j].y);
          ctx.stroke();
        }
      }
    }

    // Draw Sri Yantra-inspired triangles
    function drawSriYantra(radius, scheme) {
      const alpha = 0.6 + chatFrequency * 0.35; // Increased brightness

      // 9 interlocking triangles (simplified)
      const triangleLayers = [
        { scale: 1.0, up: true },
        { scale: PHI_INV, up: false },
        { scale: PHI_INV * PHI_INV, up: true },
        { scale: PHI_INV * PHI_INV * PHI_INV, up: false },
      ];

      triangleLayers.forEach((layer, idx) => {
        const color = scheme.colors[idx % scheme.colors.length];
        const size = radius * layer.scale;

        ctx.strokeStyle = color;
        ctx.shadowColor = color;
        ctx.shadowBlur = 20 + chatFrequency * 25; // Enhanced glow
        ctx.lineWidth = 2 + chatFrequency * 1.5;
        ctx.globalAlpha = alpha;

        ctx.beginPath();
        if (layer.up) {
          // Upward triangle
          ctx.moveTo(0, -size);
          ctx.lineTo(size * SQRT3 / 2, size / 2);
          ctx.lineTo(-size * SQRT3 / 2, size / 2);
        } else {
          // Downward triangle
          ctx.moveTo(0, size);
          ctx.lineTo(size * SQRT3 / 2, -size / 2);
          ctx.lineTo(-size * SQRT3 / 2, -size / 2);
        }
        ctx.closePath();
        ctx.stroke();
      });

      // Bindu (central point)
      const gradient = ctx.createRadialGradient(0, 0, 0, 0, 0, radius * 0.1);
      gradient.addColorStop(0, scheme.colors[0]);
      gradient.addColorStop(1, 'transparent');
      ctx.fillStyle = gradient;
      ctx.beginPath();
      ctx.arc(0, 0, radius * 0.1, 0, TAU);
      ctx.fill();
    }

    // Draw Golden Spiral
    function drawGoldenSpiral(maxRadius, scheme) {
      const alpha = 0.65 + chatFrequency * 0.3; // Increased brightness
      ctx.globalAlpha = alpha;

      // Draw Fibonacci rectangles and spiral
      let a = maxRadius / FIB[10];
      let x = 0, y = 0;
      let angle = 0;

      for (let i = 0; i < 10; i++) {
        const size = FIB[i] * a;
        const color = scheme.colors[i % scheme.colors.length];

        ctx.strokeStyle = color;
        ctx.shadowColor = color;
        ctx.shadowBlur = 15 + chatFrequency * 20; // Enhanced glow
        ctx.lineWidth = 2 + chatFrequency * 1.5;

        // Draw arc for spiral
        ctx.beginPath();
        ctx.arc(x, y, size, angle, angle + Math.PI / 2);
        ctx.stroke();

        // Move to next square position
        const dir = i % 4;
        if (dir === 0) { x += size; angle = 0; }
        else if (dir === 1) { y += size; angle = Math.PI / 2; }
        else if (dir === 2) { x -= size; angle = Math.PI; }
        else { y -= size; angle = -Math.PI / 2; }
      }

      // Golden ratio rectangles
      ctx.lineWidth = 0.5;
      ctx.globalAlpha = alpha * 0.3;
      for (let i = 0; i < 5; i++) {
        const rectSize = maxRadius * Math.pow(PHI_INV, i);
        ctx.strokeStyle = scheme.colors[i % scheme.colors.length];
        ctx.strokeRect(-rectSize / 2, -rectSize / 2, rectSize, rectSize * PHI_INV);
      }
    }

    // Draw Seed of Life (7 circles)
    function drawSeedOfLife(radius, scheme) {
      const alpha = 0.6 + chatFrequency * 0.35; // Increased brightness
      ctx.globalAlpha = alpha;

      // Center circle
      ctx.strokeStyle = scheme.colors[0];
      ctx.shadowColor = scheme.colors[0];
      ctx.shadowBlur = 22 + chatFrequency * 25; // Enhanced glow
      ctx.lineWidth = 2 + chatFrequency * 1.5;
      ctx.beginPath();
      ctx.arc(0, 0, radius, 0, TAU);
      ctx.stroke();

      // 6 surrounding circles
      for (let i = 0; i < 6; i++) {
        const angle = SACRED_ANGLES.hexagon * i;
        const cx = Math.cos(angle) * radius;
        const cy = Math.sin(angle) * radius;
        const color = scheme.colors[(i + 1) % scheme.colors.length];

        ctx.strokeStyle = color;
        ctx.shadowColor = color;
        ctx.beginPath();
        ctx.arc(cx, cy, radius, 0, TAU);
        ctx.stroke();
      }
    }

    // === MAIN MANDALA DRAWING ===
    function drawMandala() {
      const scheme = colorSchemes[colorSchemeIndex];
      const maxRadius = Math.min(width, height) * 0.38;
      const pulseScale = 1 + chatFrequency * 0.12;
      const breathe = Math.sin(time * 0.4) * 0.025 + 1;

      ctx.save();
      ctx.translate(centerX, centerY);
      if (rotating) {
        ctx.rotate(rotationAngle);
      }

      const scaledRadius = maxRadius * pulseScale * breathe;

      // Draw based on sacred mode
      switch (sacredMode) {
        case 0: // Flower of Life
          drawFlowerOfLife(scaledRadius, 3 + Math.floor(chatFrequency * 2), scheme);
          drawSeedOfLife(scaledRadius * 0.25, scheme);
          break;
        case 1: // Metatron's Cube
          drawMetatronsCube(scaledRadius * 0.8, scheme);
          drawFlowerOfLife(scaledRadius * 0.3, 1, scheme);
          break;
        case 2: // Sri Yantra
          drawSriYantra(scaledRadius * 0.7, scheme);
          drawSeedOfLife(scaledRadius * 0.15, scheme);
          break;
        case 3: // Golden Spiral
          drawGoldenSpiral(scaledRadius, scheme);
          break;
      }

      // Always draw Fibonacci-spaced orbital rings
      ctx.globalAlpha = 0.3 + chatFrequency * 0.25; // Increased visibility
      for (let i = 3; i < 8; i++) {
        const ringRadius = (FIB[i] / FIB[7]) * scaledRadius;
        const color = scheme.colors[i % scheme.colors.length];
        ctx.strokeStyle = color;
        ctx.shadowColor = color;
        ctx.shadowBlur = 8 + chatFrequency * 10; // Enhanced glow
        ctx.lineWidth = 0.8 + chatFrequency * 0.5;
        ctx.beginPath();
        ctx.arc(0, 0, ringRadius, 0, TAU);
        ctx.stroke();
      }

      // PHI-ratio petal overlay
      const petalCount = 8 + Math.floor(chatFrequency * 5);
      drawPhiPetals(scaledRadius * 0.9, petalCount, scheme);

      // Center glow with golden ratio sizing
      const glowRadius = scaledRadius * 0.1 * PHI; // Larger glow
      const gradient = ctx.createRadialGradient(0, 0, 0, 0, 0, glowRadius);
      gradient.addColorStop(0, '#ffffff'); // Bright white core
      gradient.addColorStop(0.2, scheme.colors[0]);
      gradient.addColorStop(PHI_INV, scheme.colors[0] + '88');
      gradient.addColorStop(1, 'transparent');
      ctx.globalAlpha = 0.95; // Brighter
      ctx.fillStyle = gradient;
      ctx.beginPath();
      ctx.arc(0, 0, glowRadius, 0, TAU);
      ctx.fill();

      ctx.restore();
    }

    // PHI-ratio petals
    function drawPhiPetals(radius, count, scheme) {
      const alpha = 0.4 + chatFrequency * 0.35; // Increased brightness
      ctx.globalAlpha = alpha;

      for (let i = 0; i < count; i++) {
        const angle = SACRED_ANGLES.golden * i; // Golden angle spacing
        const color = scheme.colors[i % scheme.colors.length];
        const petalLength = radius * (PHI_INV + smoothNoise(i, 0, time * 0.1) * 0.2);
        const petalWidth = radius * 0.06;

        ctx.save();
        ctx.rotate(angle);

        ctx.strokeStyle = color;
        ctx.shadowColor = color;
        ctx.shadowBlur = 12 + chatFrequency * 18; // Enhanced glow
        ctx.lineWidth = 1.2 + chatFrequency * 1.2;

        ctx.beginPath();
        ctx.moveTo(0, radius * 0.15);
        ctx.quadraticCurveTo(petalWidth, petalLength * PHI_INV, 0, petalLength);
        ctx.quadraticCurveTo(-petalWidth, petalLength * PHI_INV, 0, radius * 0.15);
        ctx.stroke();

        ctx.restore();
      }
    }

    // === CANVAS CLEARING ===
    function clearCanvas() {
      ctx.fillStyle = '#000000';
      ctx.fillRect(0, 0, width, height);
    }

    // === ANIMATION LOOP ===
    function animate() {
      // Clear with fade effect (0.15 for crisper trails)
      ctx.fillStyle = 'rgba(0, 0, 0, 0.15)';
      ctx.fillRect(0, 0, width, height);

      // Smooth frequency interpolation
      chatFrequency += (targetFrequency - chatFrequency) * 0.05;

      // Update rotation
      if (rotating) {
        rotationAngle += 0.002 + chatFrequency * 0.01;
      }

      time += 0.016;

      drawMandala();

      requestAnimationFrame(animate);
    }

    // === CHAT FREQUENCY MONITORING ===
    async function fetchMessageCount() {
      try {
        const fiveMinutesAgo = new Date(Date.now() - 5 * 60 * 1000).toISOString();

        const { count, error } = await supabase
          .from('sloppygram_messages')
          .select('*', { count: 'exact', head: true })
          .gte('created_at', fiveMinutesAgo);

        if (!error && count !== null) {
          const newCount = count;
          const delta = newCount - lastMessageCount;

          if (delta > 0 && lastMessageCount > 0) {
            // New messages detected - pulse!
            triggerEcho(delta);
          }

          lastMessageCount = newCount;
          messageCount = newCount;

          // Calculate messages per minute (over 5 min window)
          messagesPerMinute = Math.round(newCount / 5);

          // Map to frequency (0-1 range)
          targetFrequency = Math.min(1, messagesPerMinute / 20);

          updateStats();
        }
      } catch (err) {
        console.error('[Prism Echo] Fetch error:', err);
      }
    }

    function triggerEcho(count) {
      const indicator = document.getElementById('echoIndicator');
      indicator.classList.add('active');

      // Boost frequency temporarily
      targetFrequency = Math.min(1, targetFrequency + count * 0.1);

      // Increase complexity briefly
      symmetry = Math.min(16, 8 + count);
      setTimeout(() => {
        symmetry = 8;
        indicator.classList.remove('active');
      }, 2000);

      // Pulse the stats
      document.getElementById('msgRate').classList.add('pulse');
      setTimeout(() => document.getElementById('msgRate').classList.remove('pulse'), 500);
    }

    function updateStats() {
      const freqPercent = Math.round(chatFrequency * 100);
      document.getElementById('frequencyFill').style.width = freqPercent + '%';
      document.getElementById('msgRate').textContent = messagesPerMinute;
      document.getElementById('msgRate').className = 'stat-value' + (messagesPerMinute > 10 ? ' high' : '');
      document.getElementById('symmetryVal').textContent = symmetry;
      document.getElementById('layersVal').textContent = layers;
    }

    // === REALTIME SUBSCRIPTION ===
    function subscribeToChat() {
      supabase
        .channel('prism-echo-chat')
        .on('postgres_changes', {
          event: 'INSERT',
          schema: 'public',
          table: 'sloppygram_messages'
        }, (payload) => {
          triggerEcho(1);
          messageCount++;
          messagesPerMinute = Math.min(99, messagesPerMinute + 1);
          updateStats();
        })
        .subscribe();
    }

    // === CONTROLS ===
    const SACRED_MODE_NAMES = ['FLOWER', 'METATRON', 'YANTRA', 'SPIRAL'];

    window.cycleColorScheme = function() {
      colorSchemeIndex = (colorSchemeIndex + 1) % colorSchemes.length;
    };

    window.cycleSacredMode = function() {
      sacredMode = (sacredMode + 1) % 4;
      document.getElementById('geometryVal').textContent = SACRED_MODE_NAMES[sacredMode];
      clearCanvas(); // Clear between mode transitions
    };

    window.toggleRotation = function() {
      rotating = !rotating;
      document.querySelector('.control-btn:nth-child(3)').classList.toggle('active', rotating);
    };

    window.regenerate = function() {
      seed = Math.random() * 1000;
      layers = 3 + Math.floor(Math.random() * 5);
      symmetry = 6 + Math.floor(Math.random() * 10);
      updateStats();
    };

    // === INIT ===
    function init() {
      animate();
      fetchMessageCount();
      subscribeToChat();

      // Poll for message count every 30 seconds
      setInterval(fetchMessageCount, 30000);

      // Set initial rotation button state
      document.querySelector('.control-btn:nth-child(3)').classList.add('active');

      console.log('[Prism Echo] Initialized with Sacred Geometry');
      console.log('[Sacred] PHI =', PHI);
      console.log('[Sacred] Fibonacci:', FIB.slice(0, 10).join(', '));
    }

    init();
  </script>
</body>
</html>
