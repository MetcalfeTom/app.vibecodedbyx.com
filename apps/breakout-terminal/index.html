<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>BREAKOUT_MATRIX</title>
    <meta property="og:title" content="BREAKOUT_MATRIX - Terminal Brick Breaker">
    <meta property="og:description" content="Classic Breakout with a matrix terminal aesthetic. Break the code blocks!">
    <meta property="og:image" content="og-image.png">
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Share+Tech+Mono&display=swap');

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background: #000;
            color: #00ff00;
            font-family: 'Share Tech Mono', monospace;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            flex-direction: column;
            padding: 20px;
            overflow: hidden;
        }

        .terminal-container {
            background: #0a0a0a;
            border: 2px solid #00ff00;
            padding: 20px;
            box-shadow: 0 0 40px rgba(0, 255, 0, 0.3);
            max-width: 700px;
            width: 100%;
        }

        .header {
            text-align: center;
            margin-bottom: 20px;
            border-bottom: 1px solid #00ff00;
            padding-bottom: 10px;
        }

        h1 {
            font-size: 24px;
            text-shadow: 0 0 20px #00ff00;
            margin-bottom: 5px;
            letter-spacing: 2px;
        }

        .stats {
            display: flex;
            justify-content: space-around;
            margin: 15px 0;
            padding: 10px;
            background: #000;
            border: 1px solid #00ff00;
        }

        .stat {
            text-align: center;
        }

        .stat-label {
            font-size: 12px;
            opacity: 0.7;
        }

        .stat-value {
            font-size: 20px;
            font-weight: bold;
            text-shadow: 0 0 10px #00ff00;
        }

        canvas {
            border: 2px solid #00ff00;
            background: #000;
            display: block;
            margin: 0 auto;
            box-shadow: 0 0 30px rgba(0, 255, 0, 0.2);
        }

        .controls {
            border: 1px solid #00ff00;
            padding: 15px;
            margin: 20px 0;
            background: #000;
            text-align: center;
        }

        .control-item {
            font-size: 12px;
            margin: 5px 0;
            opacity: 0.8;
        }

        .control-key {
            color: #00ff00;
            font-weight: bold;
            background: #0a0a0a;
            padding: 2px 8px;
            border: 1px solid #00ff00;
            display: inline-block;
        }

        .game-message {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: #000;
            border: 3px solid #00ff00;
            padding: 30px;
            text-align: center;
            display: none;
            z-index: 1000;
            box-shadow: 0 0 50px rgba(0, 255, 0, 0.5);
        }

        .game-message.show {
            display: block;
        }

        .game-message h2 {
            font-size: 28px;
            margin-bottom: 15px;
            text-shadow: 0 0 20px #00ff00;
        }

        .game-message p {
            font-size: 16px;
            margin: 10px 0;
            opacity: 0.9;
        }

        .play-btn {
            background: #00ff00;
            color: #000;
            border: none;
            padding: 12px 30px;
            font-family: inherit;
            font-size: 16px;
            font-weight: bold;
            cursor: pointer;
            margin-top: 20px;
            text-transform: uppercase;
            transition: all 0.3s;
        }

        .play-btn:hover {
            background: #00cc00;
            box-shadow: 0 0 20px #00ff00;
        }

        .power-up {
            font-size: 14px;
            color: #ffff00;
            text-shadow: 0 0 10px #ffff00;
            margin-top: 10px;
            min-height: 20px;
        }

        .backlink {
            text-align: center;
            font-size: 12px;
            margin-top: 15px;
        }

        .backlink a {
            color: #00ff00;
            opacity: 0.7;
            text-decoration: none;
        }

        .backlink a:hover {
            opacity: 1;
            text-shadow: 0 0 5px #00ff00;
        }

        @media (max-width: 600px) {
            h1 {
                font-size: 20px;
            }

            .stats {
                font-size: 12px;
            }

            canvas {
                max-width: 100%;
                height: auto;
            }
        }
    </style>
    <script src="supabase-config.js"></script>
</head>
<body>
    <div class="terminal-container">
        <div class="header">
            <h1>&gt; BREAKOUT_MATRIX</h1>
            <div style="font-size: 12px; opacity: 0.7;">BREACH.PROTOCOL.ACTIVE</div>
        </div>

        <div class="stats">
            <div class="stat">
                <div class="stat-label">SCORE</div>
                <div class="stat-value" id="score">0</div>
            </div>
            <div class="stat">
                <div class="stat-label">LEVEL</div>
                <div class="stat-value" id="level">1</div>
            </div>
            <div class="stat">
                <div class="stat-label">LIVES</div>
                <div class="stat-value" id="lives">3</div>
            </div>
            <div class="stat">
                <div class="stat-label">HIGH</div>
                <div class="stat-value" id="highScore">0</div>
            </div>
        </div>

        <!-- Auth Status -->
        <div style="text-align: center; margin: 10px 0; font-size: 12px;">
            <span id="auth">Loading...</span>
            <button id="signin" style="display: none; margin-left: 10px;">Sign In</button>
            <button id="signout" style="display: none; margin-left: 10px;">Sign Out</button>
        </div>

        <!-- Leaderboard -->
        <div style="margin: 15px 0; padding: 10px; background: #000; border: 1px solid #00ff00;">
            <div style="text-align: center; margin-bottom: 10px; font-size: 14px; font-weight: bold;">LEADERBOARD</div>
            <ul id="leaders" style="list-style: none; padding: 0; margin: 0; max-height: 150px; overflow-y: auto;">
                <li style="text-align: center; opacity: 0.7;">Loading...</li>
            </ul>
        </div>

        <canvas id="gameCanvas" width="600" height="400"></canvas>

        <div class="power-up" id="powerUpDisplay"></div>

        <div class="controls">
            <div class="control-item"><span class="control-key">← →</span> or <span class="control-key">A D</span> MOVE PADDLE</div>
            <div class="control-item"><span class="control-key">SPACE</span> START / LAUNCH BALL</div>
            <div class="control-item"><span class="control-key">P</span> PAUSE</div>
            <div class="control-item">TOUCH/DRAG on mobile</div>
        </div>

        <div class="backlink">
            <a href="http://www.vibecodedbyx.com" target="_blank">&gt; vibecodedbyx.com</a>
        </div>
    </div>

    <div class="game-message" id="gameMessage">
        <h2 id="messageTitle">BREAKOUT_MATRIX</h2>
        <p id="messageText">BREACH THE FIREWALL</p>
        <p id="messageScore"></p>
        <button class="play-btn" onclick="startGame()">INITIALIZE</button>
    </div>

    <script type="module">
      import supabase, { supabaseSession } from './supabase-config.js';
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');

        let gameRunning = false;
        let paused = false;
        let score = 0;
        let level = 1;
        let lives = 3;
                let highScore = localStorage.getItem('breakoutHighScore') || 0;
        
                let state = {
                    session: null,
                    user: null,
                    bestMs: null,
                };
        
                const paddle = {
                    x: canvas.width / 2 - 50,
                    y: canvas.height - 30,
                    width: 100,
                    height: 10,
                    speed: 8
                };
        
                const ball = {
                    x: canvas.width / 2,
                    y: canvas.height - 50,
                    radius: 6,
                    speedX: 0,
                    speedY: 0,
                    attached: true
                };
        
                const brickRowCount = 8;
                const brickColumnCount = 10;
                const brickWidth = 50;
                const brickHeight = 20;
                const brickPadding = 5;
                const brickOffsetTop = 60;
                const brickOffsetLeft = 35;
        
                let bricks = [];
                let powerUp = null;
                let paddleExpanded = false;
                let paddleExpandTimer = 0;
        
                const keys = {};
        
                function initBricks() {
                    bricks = [];
                    for (let c = 0; c < brickColumnCount; c++) {
                        bricks[c] = [];
                        for (let r = 0; r < brickRowCount; r++) {
                            const hitPoints = r < 2 ? 3 : r < 4 ? 2 : 1;
                            bricks[c][r] = {
                                x: 0,
                                y: 0,
                                status: hitPoints,
                                maxHits: hitPoints
                            };
                        }
                    }
                }
        
        async function loadBest() {
            if (!state.user) return null;
            const { data, error } = await supabase
                .from('breakout_scores')
                .select('score')
                .eq('user_id', state.user.id)
                .single();
            if (error && error.code !== 'PGRST116') console.error('Best load error:', error.message);
            return data?.score ?? null;
        }

        async function saveBest(score) {
            if (!state.user) return;
            const { data: existingRows, error: readError } = await supabase
                .from('breakout_scores')
                .select('score')
                .eq('user_id', state.user.id)
                .limit(1);

            if (readError && readError.code !== 'PGRST116') {
                console.error('Score read error:', readError.message);
                return;
            }

            const existing = existingRows?.[0];
            const nextBest = existing?.score != null ? Math.max(existing.score, score) : score;

            if (!existing) {
                const { error: insertError } = await supabase
                    .from('breakout_scores')
                    .insert({ user_id: state.user.id, score: nextBest });
                if (insertError) {
                    console.error('Save insert error:', insertError.message);
                    return;
                }
            } else if (nextBest > existing.score) {
                const { error: updateError } = await supabase
                    .from('breakout_scores')
                    .update({ score: nextBest })
                    .eq('user_id', state.user.id);
                if (updateError) {
                    console.error('Save update error:', updateError.message);
                    return;
                }
            }

            state.bestMs = nextBest;
            document.getElementById('highScore').textContent = nextBest;
            refreshLeaders();
        }

        async function refreshLeaders() {
            const { data, error } = await supabase
                .from('breakout_scores')
                .select('score, user_id')
                .order('score', { ascending: false })
                .limit(10);
            if (error) { console.error('Leaders error:', error.message); return; }
            const rows = data || [];
            const ids = rows.map((r) => r.user_id).filter(Boolean);
            const nameLookup = {};

            if (ids.length) {
                const { data: profiles, error: profileError } = await supabase
                    .from('users')
                    .select('user_id, display_name, twitter_handle')
                    .in('user_id', ids);
                if (profileError) {
                    console.error('Leader profile error:', profileError.message);
                } else {
                    for (const profile of profiles) {
                        const displayName = profile.display_name?.trim();
                        const twitter = profile.twitter_handle?.trim();
                        const handle = twitter ? (twitter.startsWith('@') ? twitter : `@${twitter}`) : '';
                        const label = displayName || handle;
                        if (label) nameLookup[profile.user_id] = label;
                    }
                }
            }

            const leadersList = document.getElementById('leaders');
            leadersList.innerHTML = rows
                .map((r, i) => {
                    const fallback = `…${String(r.user_id ?? '').slice(-6)}`;
                    const label = nameLookup[r.user_id] || fallback;
                    return `<li>#${i + 1} <strong>${r.score}</strong> — ${label}</li>`;
                })
                .join('');
        }
        
                function resetBall() {
                    ball.x = paddle.x + paddle.width / 2;
                    ball.y = paddle.y - 10;
                    ball.speedX = 0;
                    ball.speedY = 0;
                    ball.attached = true;
                }
        
                function launchBall() {
                    if (ball.attached) {
                        ball.speedX = (Math.random() - 0.5) * 6;
                        ball.speedY = -6;
                        ball.attached = false;
                    }
                }
        
                function startGame() {
                    score = 0;
                    level = 1;
                    lives = 3;
                    gameRunning = true;
                    initBricks();
                    resetBall();
                    updateDisplay();
                    document.getElementById('gameMessage').classList.remove('show');
                    document.getElementById('highScore').textContent = highScore;
                }
        
                function nextLevel() {
                    level++;
                    initBricks();
                    resetBall();
                    ball.speedX *= 1.1;
                    ball.speedY *= 1.1;
                    updateDisplay();
                    showMessage('LEVEL ' + level, 'FIREWALL UPGRADED', 1500);
                }
        
                function updateHighScore() {
                    if (score > highScore) {
                        highScore = score;
                        localStorage.setItem('breakoutHighScore', highScore);
                        document.getElementById('highScore').textContent = highScore;
                    }
                    // Also save to Supabase if user is logged in
                    if (state.user) {
                        saveBest(score);
                    }
                }

                function gameOver() {
                    gameRunning = false;
                    updateHighScore();
                    document.getElementById('messageTitle').textContent = 'SYSTEM BREACH FAILED';
                    document.getElementById('messageText').textContent = 'ACCESS DENIED';
                    document.getElementById('messageScore').textContent = 'FINAL SCORE: ' + score;
                    document.getElementById('gameMessage').classList.add('show');
                }        
                function showMessage(title, text, duration) {
                    document.getElementById('messageTitle').textContent = title;
                    document.getElementById('messageText').textContent = text;
                    document.getElementById('messageScore').textContent = '';
                    document.getElementById('gameMessage').classList.add('show');
                    if (duration) {
                        setTimeout(() => {
                            document.getElementById('gameMessage').classList.remove('show');
                        }, duration);
                    }
                }
        
                function updateDisplay() {
                    document.getElementById('score').textContent = score;
                    document.getElementById('level').textContent = level;
                    document.getElementById('lives').textContent = lives;
                }
        
                function createPowerUp(x, y) {
                    if (Math.random() < 0.1) {
                        powerUp = {
                            x: x,
                            y: y,
                            width: 20,
                            height: 20,
                            speed: 2,
                            type: Math.random() < 0.5 ? 'expand' : 'multiball'
                        };
                    }
                }
        
                function activatePowerUp(type) {
                    if (type === 'expand') {
                        paddle.width = 150;
                        paddleExpanded = true;
                        paddleExpandTimer = 600;
                        document.getElementById('powerUpDisplay').textContent = 'PADDLE EXPANDED';
                    }
                }
        
                function drawBricks() {
                    for (let c = 0; c < brickColumnCount; c++) {
                        for (let r = 0; r < brickRowCount; r++) {
                            if (!bricks[c] || !bricks[c][r]) continue;
                            if (bricks[c][r].status > 0) {
                                const brickX = c * (brickWidth + brickPadding) + brickOffsetLeft;
                                const brickY = r * (brickHeight + brickPadding) + brickOffsetTop;
                                bricks[c][r].x = brickX;
                                bricks[c][r].y = brickY;
        
                                const opacity = bricks[c][r].status / bricks[c][r].maxHits;
                                ctx.fillStyle = `rgba(0, 255, 0, ${opacity})`;
                                ctx.fillRect(brickX, brickY, brickWidth, brickHeight);
        
                                ctx.strokeStyle = '#00ff00';
                                ctx.strokeRect(brickX, brickY, brickWidth, brickHeight);
        
                                ctx.font = '10px Share Tech Mono';
                                ctx.fillStyle = '#000';
                                ctx.fillText(bricks[c][r].status, brickX + brickWidth/2 - 3, brickY + brickHeight/2 + 3);
                            }
                        }
                    }
                }
        
                function drawPaddle() {
                    ctx.fillStyle = '#00ff00';
                    ctx.fillRect(paddle.x, paddle.y, paddle.width, paddle.height);
                    ctx.strokeStyle = '#00cc00';
                    ctx.strokeRect(paddle.x, paddle.y, paddle.width, paddle.height);
                }
        
                function drawBall() {
                    ctx.fillStyle = '#00ff00';
                    ctx.beginPath();
                    ctx.arc(ball.x, ball.y, ball.radius, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.strokeStyle = '#00ff00';
                    ctx.stroke();
                }
        
                function drawPowerUp() {
                    if (powerUp) {
                        ctx.fillStyle = '#ffff00';
                        ctx.fillRect(powerUp.x, powerUp.y, powerUp.width, powerUp.height);
                        ctx.strokeStyle = '#ffff00';
                        ctx.strokeRect(powerUp.x, powerUp.y, powerUp.width, powerUp.height);
        
                        ctx.font = '12px Share Tech Mono';
                        ctx.fillStyle = '#000';
                        ctx.fillText('P', powerUp.x + 6, powerUp.y + 14);
                    }
                }
        
                function collisionDetection() {
                    for (let c = 0; c < brickColumnCount; c++) {
                        for (let r = 0; r < brickRowCount; r++) {
                            const b = bricks[c][r];
                            if (b.status > 0) {
                                if (ball.x + ball.radius > b.x &&
                                    ball.x - ball.radius < b.x + brickWidth &&
                                    ball.y + ball.radius > b.y &&
                                    ball.y - ball.radius < b.y + brickHeight) {
        
                                    ball.speedY = -ball.speedY;
                                    b.status--;
        
                                    if (b.status === 0) {
                                        score += (b.maxHits * 10);
                                        createPowerUp(b.x + brickWidth/2, b.y + brickHeight/2);
                                    } else {
                                        score += 5;
                                    }
        
                                    updateDisplay();
        
                                    const remainingBricks = bricks.flat().filter(brick => brick.status > 0).length;
                                    if (remainingBricks === 0) {
                                        nextLevel();
                                    }
                                }
                            }
                        }
                    }
                }
        
                function update() {
                    if (!gameRunning || paused) return;
        
                    if (keys['ArrowLeft'] || keys['a'] || keys['A']) {
                        paddle.x = Math.max(0, paddle.x - paddle.speed);
                    }
                    if (keys['ArrowRight'] || keys['d'] || keys['D']) {
                        paddle.x = Math.min(canvas.width - paddle.width, paddle.x + paddle.speed);
                    }
        
                    if (ball.attached) {
                        ball.x = paddle.x + paddle.width / 2;
                        ball.y = paddle.y - 10;
                    } else {
                        ball.x += ball.speedX;
                        ball.y += ball.speedY;
        
                        if (ball.x + ball.radius > canvas.width || ball.x - ball.radius < 0) {
                            ball.speedX = -ball.speedX;
                        }
                        if (ball.y - ball.radius < 0) {
                            ball.speedY = -ball.speedY;
                        }
        
                        if (ball.x > paddle.x &&
                            ball.x < paddle.x + paddle.width &&
                            ball.y + ball.radius > paddle.y &&
                            ball.y - ball.radius < paddle.y + paddle.height) {
        
                            ball.speedY = -Math.abs(ball.speedY);
                            const hitPos = (ball.x - paddle.x) / paddle.width;
                            ball.speedX = 8 * (hitPos - 0.5);
                        }
        
                        if (ball.y > canvas.height) {
                            lives--;
                            updateDisplay();
                            if (lives === 0) {
                                gameOver();
                            } else {
                                resetBall();
                            }
                        }
        
                        collisionDetection();
                    }
        
                    if (powerUp) {
                        powerUp.y += powerUp.speed;
        
                        if (powerUp.x < paddle.x + paddle.width &&
                            powerUp.x + powerUp.width > paddle.x &&
                            powerUp.y < paddle.y + paddle.height &&
                            powerUp.y + powerUp.height > paddle.y) {
        
                            activatePowerUp(powerUp.type);
                            powerUp = null;
                        }
        
                        if (powerUp && powerUp.y > canvas.height) {
                            powerUp = null;
                        }
                    }
        
                    if (paddleExpanded) {
                        paddleExpandTimer--;
                        if (paddleExpandTimer <= 0) {
                            paddle.width = 100;
                            paddleExpanded = false;
                            document.getElementById('powerUpDisplay').textContent = '';
                        }
                    }
                }
        
                function draw() {
                    ctx.fillStyle = '#000';
                    ctx.fillRect(0, 0, canvas.width, canvas.height);
        
                    drawBricks();
                    drawPaddle();
                    drawBall();
                    drawPowerUp();
        
                    ctx.strokeStyle = '#00ff00';
                    ctx.lineWidth = 2;
                    ctx.strokeRect(0, 0, canvas.width, canvas.height);
                }
        
                function gameLoop() {
                    update();
                    draw();
                    requestAnimationFrame(gameLoop);
                }
        
                      async function init() {
                        document.addEventListener('keydown', (e) => {
                            keys[e.key] = true;
                
                            if (e.key === ' ') {
                                if (!gameRunning) {
                                    startGame();
                                } else {
                                    launchBall();
                                }
                            }
                
                            if (e.key === 'p' || e.key === 'P') {
                                if (gameRunning) {
                                    paused = !paused;
                                }
                            }
                        });
                
                        document.addEventListener('keyup', (e) => {
                            keys[e.key] = false;
                        });
                
                        let touchX = null;
                
                        canvas.addEventListener('touchstart', (e) => {
                            touchX = e.touches[0].clientX;
                            if (ball.attached) {
                                launchBall();
                            }
                        });
                
                        canvas.addEventListener('touchmove', (e) => {
                            if (touchX !== null) {
                                const deltaX = e.touches[0].clientX - touchX;
                                paddle.x = Math.max(0, Math.min(canvas.width - paddle.width, paddle.x + deltaX));
                                touchX = e.touches[0].clientX;
                            }
                        });
                
                        canvas.addEventListener('touchend', () => {
                            touchX = null;
                        });
                
                        canvas.addEventListener('mousemove', (e) => {
                            if (gameRunning && !paused) {
                                const rect = canvas.getBoundingClientRect();
                                const mouseX = e.clientX - rect.left;
                                paddle.x = Math.max(0, Math.min(canvas.width - paddle.width, mouseX - paddle.width / 2));
                            }
                        });
                
                        canvas.addEventListener('click', () => {
                            if (gameRunning && ball.attached) {
                                launchBall();
                            }
                        });
                
                        document.getElementById('gameMessage').classList.add('show');
                        // Ensure bricks exist before the first draw to avoid undefined access
                        initBricks();
                        resetBall();
                        updateDisplay();
                        gameLoop();
                
                        try {
                            const { session, user } = await supabaseSession();
                            state.session = session;
                            state.user = user;
                            document.getElementById('auth').textContent = `Signed in: …${String(user.id).slice(-6)}`;
                            document.getElementById('signout').style.display = 'inline-block';
                            document.getElementById('signout').onclick = async ()=>{ await supabase.auth.signOut(); location.reload(); };
                            document.getElementById('signin').style.display = 'none';

                            state.bestMs = await loadBest();
                            if (state.bestMs !== null) {
                                document.getElementById('highScore').textContent = state.bestMs;
                            }
                            refreshLeaders();

                            supabase
                              .channel('breakout_scores')
                              .on('postgres_changes', { event: '*', schema: 'public', table: 'breakout_scores' }, refreshLeaders)
                              .subscribe();
                        } catch (err) {
                            console.error('Auth error:', err);
                            document.getElementById('auth').textContent = 'Auth error - playing offline';
                            document.getElementById('leaders').innerHTML = '<li style="text-align: center; opacity: 0.7;">Offline mode</li>';
                        }
                      }

                      init();
                    </script>          </body>
        </html>
