<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Infinite Abyss</title>
  <link rel="icon" href="https://emojicdn.elk.sh/üï≥Ô∏è">
  <meta property="og:title" content="Infinite Abyss">
  <meta property="og:description" content="Hypnotic fractal animation of endless recursive code">
  <meta property="og:url" content="https://app.sloppy.live/infinite-abyss">
  <meta property="og:image" content="https://emojicdn.elk.sh/üï≥Ô∏è?style=apple&size=512">
  <link href="https://fonts.googleapis.com/css2?family=Fira+Code:wght@400;700&display=swap" rel="stylesheet">
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }

    body {
      background: #000;
      overflow: hidden;
      height: 100vh;
      font-family: 'Fira Code', monospace;
    }

    canvas {
      display: block;
      position: fixed;
      top: 0;
      left: 0;
    }

    .overlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
      background: radial-gradient(ellipse at center, transparent 0%, rgba(0,0,0,0.3) 70%, rgba(0,0,0,0.8) 100%);
    }

    .title {
      position: fixed;
      top: 30px;
      left: 50%;
      transform: translateX(-50%);
      font-size: 2rem;
      font-weight: 700;
      color: rgba(255, 255, 255, 0.1);
      letter-spacing: 15px;
      text-transform: uppercase;
      pointer-events: none;
      animation: title-pulse 4s ease-in-out infinite;
    }

    @keyframes title-pulse {
      0%, 100% { opacity: 0.1; letter-spacing: 15px; }
      50% { opacity: 0.3; letter-spacing: 20px; }
    }

    .controls {
      position: fixed;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      display: flex;
      gap: 15px;
      z-index: 100;
    }

    .control-btn {
      background: rgba(255, 255, 255, 0.05);
      border: 1px solid rgba(255, 255, 255, 0.1);
      color: rgba(255, 255, 255, 0.5);
      padding: 10px 20px;
      border-radius: 25px;
      cursor: pointer;
      font-family: inherit;
      font-size: 0.8rem;
      transition: all 0.3s;
    }

    .control-btn:hover {
      background: rgba(255, 255, 255, 0.1);
      color: rgba(255, 255, 255, 0.8);
      border-color: rgba(255, 255, 255, 0.3);
    }

    .control-btn.active {
      background: rgba(138, 43, 226, 0.3);
      border-color: rgba(138, 43, 226, 0.5);
      color: #fff;
    }

    .depth-indicator {
      position: fixed;
      bottom: 80px;
      left: 50%;
      transform: translateX(-50%);
      font-size: 0.7rem;
      color: rgba(255, 255, 255, 0.2);
      letter-spacing: 3px;
      pointer-events: none;
    }

    .back-link {
      position: fixed;
      top: 20px;
      right: 20px;
      color: rgba(255, 255, 255, 0.2);
      text-decoration: none;
      font-size: 0.75rem;
      z-index: 100;
      transition: color 0.3s;
    }

    .back-link:hover {
      color: rgba(255, 255, 255, 0.5);
    }
  </style>
</head>
<body>
  <canvas id="abyss"></canvas>
  <div class="overlay"></div>
  <div class="title">Infinite Abyss</div>
  <div class="depth-indicator">DEPTH: <span id="depth">0</span> LAYERS</div>

  <div class="controls">
    <button class="control-btn active" onclick="setMode('code')">Code</button>
    <button class="control-btn" onclick="setMode('geometric')">Geometric</button>
    <button class="control-btn" onclick="setMode('matrix')">Matrix</button>
    <button class="control-btn" onclick="toggleSpeed()">Speed: Normal</button>
  </div>

  <a href="https://sloppy.live" class="back-link">‚Üê sloppy.live</a>

  <script>
    const canvas = document.getElementById('abyss');
    const ctx = canvas.getContext('2d');

    let width, height, centerX, centerY;
    let time = 0;
    let depth = 0;
    let mode = 'code';
    let speedMultiplier = 1;

    // Code snippets for the falling code effect
    const codeSnippets = [
      'function recurse(n) {',
      '  if (n <= 0) return;',
      '  recurse(n - 1);',
      '}',
      'while (true) {',
      '  collapse();',
      '}',
      'const infinity = () => infinity();',
      'return this.render(this);',
      'void loop() { loop(); }',
      'fn main() { main() }',
      'def __call__(self):',
      '  return self()',
      'Y = Œªf.(Œªx.f(x x))(Œªx.f(x x))',
      'fix f = f (fix f)',
      'iterate f x = x : iterate f (f x)',
      'ŒºX.X ‚Üí X',
      'let rec loop = loop',
      '‚àÄx: P(x) ‚Üí P(P(x))',
      'goto start;',
      'MOV AX, [loop]',
      'JMP loop',
      'call stack overflow',
      'maximum recursion depth',
      'tail call optimization',
      'trampolining enabled',
      'continuation passing',
      'lazy evaluation',
      'infinite stream',
      'corecursion active',
      'unfold :: (b ‚Üí Maybe (a, b)) ‚Üí b ‚Üí [a]',
      'ana :: Functor f => (a ‚Üí f a) ‚Üí a ‚Üí Fix f'
    ];

    // Layer configuration for the fractal tunnel
    const layers = [];
    const maxLayers = 60;
    const layerSpacing = 50;

    class Layer {
      constructor(z) {
        this.z = z;
        this.rotation = Math.random() * Math.PI * 2;
        this.rotationSpeed = (Math.random() - 0.5) * 0.02;
        this.codeLines = [];
        this.shape = Math.floor(Math.random() * 4); // 0: hex, 1: square, 2: triangle, 3: circle

        // Generate code lines for this layer
        const lineCount = 3 + Math.floor(Math.random() * 5);
        for (let i = 0; i < lineCount; i++) {
          this.codeLines.push({
            text: codeSnippets[Math.floor(Math.random() * codeSnippets.length)],
            angle: (i / lineCount) * Math.PI * 2,
            radius: 0.3 + Math.random() * 0.4
          });
        }
      }

      update(speed) {
        this.z -= speed;
        this.rotation += this.rotationSpeed * speedMultiplier;

        if (this.z < 1) {
          this.z = maxLayers * layerSpacing;
          this.rotation = Math.random() * Math.PI * 2;
          this.shape = Math.floor(Math.random() * 4);
          depth++;
        }
      }

      getScale() {
        return Math.max(0.001, 800 / this.z);
      }

      getAlpha() {
        const scale = this.getScale();
        if (scale > 10) return Math.max(0, 1 - (scale - 10) / 10);
        if (scale < 0.1) return scale * 10;
        return 1;
      }
    }

    // Initialize layers
    function initLayers() {
      layers.length = 0;
      for (let i = 0; i < maxLayers; i++) {
        layers.push(new Layer(i * layerSpacing + 100));
      }
    }

    // Color palette based on depth
    function getColor(z, alpha = 1) {
      const hue = (time * 20 + z * 0.5) % 360;
      const saturation = 70 + Math.sin(z * 0.01) * 30;
      const lightness = 50 + Math.sin(time + z * 0.02) * 20;
      return `hsla(${hue}, ${saturation}%, ${lightness}%, ${alpha})`;
    }

    // Draw geometric shapes
    function drawShape(x, y, size, sides, rotation, color, lineWidth = 1) {
      ctx.beginPath();
      for (let i = 0; i <= sides; i++) {
        const angle = rotation + (i / sides) * Math.PI * 2;
        const px = x + Math.cos(angle) * size;
        const py = y + Math.sin(angle) * size;
        if (i === 0) ctx.moveTo(px, py);
        else ctx.lineTo(px, py);
      }
      ctx.closePath();
      ctx.strokeStyle = color;
      ctx.lineWidth = lineWidth;
      ctx.stroke();
    }

    // Draw fractal recursive pattern inside shape
    function drawFractalPattern(x, y, size, depth, rotation, alpha) {
      if (depth <= 0 || size < 5 || alpha < 0.05) return;

      const color = getColor(depth * 50, alpha * 0.5);
      const sides = 6;

      drawShape(x, y, size, sides, rotation, color, Math.max(0.5, alpha * 2));

      // Draw smaller shapes at vertices (simulated recursion, limited depth)
      if (depth > 1) {
        const childSize = size * 0.4;
        const childCount = Math.min(depth, 4);
        for (let i = 0; i < childCount; i++) {
          const angle = rotation + (i / childCount) * Math.PI * 2;
          const cx = x + Math.cos(angle) * size * 0.6;
          const cy = y + Math.sin(angle) * size * 0.6;
          drawFractalPattern(cx, cy, childSize, depth - 1, rotation + time, alpha * 0.7);
        }
      }
    }

    // Draw code layer
    function drawCodeLayer(layer) {
      const scale = layer.getScale();
      const alpha = layer.getAlpha();
      if (alpha <= 0) return;

      const size = Math.min(width, height) * 0.4 * scale;

      ctx.save();
      ctx.translate(centerX, centerY);
      ctx.rotate(layer.rotation);

      // Draw the geometric frame
      const sides = [6, 4, 3, 0][layer.shape];
      if (sides > 0) {
        const color = getColor(layer.z, alpha * 0.6);
        drawShape(0, 0, size, sides, 0, color, Math.max(0.5, scale * 0.5));

        // Inner recursive shapes
        if (mode === 'geometric' && scale > 0.5) {
          drawFractalPattern(0, 0, size * 0.5, 3, time * 0.5, alpha * 0.3);
        }
      } else {
        // Circle
        ctx.beginPath();
        ctx.arc(0, 0, size, 0, Math.PI * 2);
        ctx.strokeStyle = getColor(layer.z, alpha * 0.6);
        ctx.lineWidth = Math.max(0.5, scale * 0.5);
        ctx.stroke();
      }

      // Draw code lines
      if (mode === 'code' || mode === 'matrix') {
        ctx.font = `${Math.max(8, Math.min(14, scale * 10))}px Fira Code`;
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';

        layer.codeLines.forEach((line, i) => {
          const textAlpha = alpha * (0.5 + Math.sin(time * 2 + i) * 0.3);
          const textColor = mode === 'matrix'
            ? `rgba(0, 255, 65, ${textAlpha})`
            : getColor(layer.z + i * 20, textAlpha);

          ctx.fillStyle = textColor;

          const textRadius = size * line.radius;
          const textAngle = line.angle + time * 0.1;
          const tx = Math.cos(textAngle) * textRadius;
          const ty = Math.sin(textAngle) * textRadius;

          ctx.save();
          ctx.translate(tx, ty);
          ctx.rotate(textAngle + Math.PI / 2);
          ctx.fillText(line.text, 0, 0);
          ctx.restore();
        });
      }

      ctx.restore();
    }

    // Draw connecting lines between layers
    function drawConnections() {
      const sortedLayers = [...layers].sort((a, b) => b.z - a.z);

      for (let i = 0; i < sortedLayers.length - 1; i++) {
        const layer = sortedLayers[i];
        const nextLayer = sortedLayers[i + 1];

        const scale1 = layer.getScale();
        const scale2 = nextLayer.getScale();
        const alpha = Math.min(layer.getAlpha(), nextLayer.getAlpha()) * 0.1;

        if (alpha <= 0.01) continue;

        const size1 = Math.min(width, height) * 0.3 * scale1;
        const size2 = Math.min(width, height) * 0.3 * scale2;

        const points = 6;
        for (let p = 0; p < points; p++) {
          const angle1 = layer.rotation + (p / points) * Math.PI * 2;
          const angle2 = nextLayer.rotation + (p / points) * Math.PI * 2;

          const x1 = centerX + Math.cos(angle1) * size1;
          const y1 = centerY + Math.sin(angle1) * size1;
          const x2 = centerX + Math.cos(angle2) * size2;
          const y2 = centerY + Math.sin(angle2) * size2;

          ctx.beginPath();
          ctx.moveTo(x1, y1);
          ctx.lineTo(x2, y2);
          ctx.strokeStyle = getColor((layer.z + nextLayer.z) / 2, alpha);
          ctx.lineWidth = 0.5;
          ctx.stroke();
        }
      }
    }

    // Draw central vortex
    function drawVortex() {
      const gradient = ctx.createRadialGradient(centerX, centerY, 0, centerX, centerY, 100);
      gradient.addColorStop(0, 'rgba(0, 0, 0, 1)');
      gradient.addColorStop(0.5, 'rgba(20, 0, 40, 0.8)');
      gradient.addColorStop(1, 'rgba(0, 0, 0, 0)');

      ctx.fillStyle = gradient;
      ctx.beginPath();
      ctx.arc(centerX, centerY, 100, 0, Math.PI * 2);
      ctx.fill();

      // Spinning lines in center
      const lineCount = 12;
      for (let i = 0; i < lineCount; i++) {
        const angle = time * 2 + (i / lineCount) * Math.PI * 2;
        const length = 30 + Math.sin(time * 3 + i) * 20;

        ctx.beginPath();
        ctx.moveTo(centerX, centerY);
        ctx.lineTo(
          centerX + Math.cos(angle) * length,
          centerY + Math.sin(angle) * length
        );
        ctx.strokeStyle = `hsla(${(time * 50 + i * 30) % 360}, 80%, 60%, 0.3)`;
        ctx.lineWidth = 1;
        ctx.stroke();
      }
    }

    // Draw particle effects
    const particles = [];
    const maxParticles = 100;

    function updateParticles() {
      // Add new particles
      if (particles.length < maxParticles && Math.random() < 0.3) {
        const angle = Math.random() * Math.PI * 2;
        const dist = 50 + Math.random() * 200;
        particles.push({
          x: centerX + Math.cos(angle) * dist,
          y: centerY + Math.sin(angle) * dist,
          vx: (Math.random() - 0.5) * 2,
          vy: (Math.random() - 0.5) * 2,
          life: 1,
          char: codeSnippets[Math.floor(Math.random() * codeSnippets.length)].charAt(
            Math.floor(Math.random() * 10)
          ) || '0'
        });
      }

      // Update and draw particles
      for (let i = particles.length - 1; i >= 0; i--) {
        const p = particles[i];

        // Pull toward center
        const dx = centerX - p.x;
        const dy = centerY - p.y;
        const dist = Math.sqrt(dx * dx + dy * dy);

        p.vx += (dx / dist) * 0.5 * speedMultiplier;
        p.vy += (dy / dist) * 0.5 * speedMultiplier;
        p.x += p.vx * speedMultiplier;
        p.y += p.vy * speedMultiplier;
        p.life -= 0.01 * speedMultiplier;

        if (p.life <= 0 || dist < 20) {
          particles.splice(i, 1);
          continue;
        }

        const alpha = p.life * 0.5;
        ctx.fillStyle = mode === 'matrix'
          ? `rgba(0, 255, 65, ${alpha})`
          : `hsla(${(time * 50 + i * 10) % 360}, 70%, 60%, ${alpha})`;
        ctx.font = '12px Fira Code';
        ctx.fillText(p.char, p.x, p.y);
      }
    }

    // Main render loop
    function render() {
      // Clear with slight trail effect
      ctx.fillStyle = 'rgba(0, 0, 0, 0.1)';
      ctx.fillRect(0, 0, width, height);

      const speed = 2 * speedMultiplier;

      // Update and sort layers
      layers.forEach(layer => layer.update(speed));
      const sortedLayers = [...layers].sort((a, b) => b.z - a.z);

      // Draw connections first (background)
      drawConnections();

      // Draw layers from back to front
      sortedLayers.forEach(layer => drawCodeLayer(layer));

      // Draw vortex center
      drawVortex();

      // Draw particles
      updateParticles();

      // Update time
      time += 0.016 * speedMultiplier;

      // Update depth display
      document.getElementById('depth').textContent = depth.toLocaleString();

      requestAnimationFrame(render);
    }

    // Resize handler
    function resize() {
      width = canvas.width = window.innerWidth;
      height = canvas.height = window.innerHeight;
      centerX = width / 2;
      centerY = height / 2;
    }

    // Mode switching
    function setMode(newMode) {
      mode = newMode;
      document.querySelectorAll('.control-btn').forEach((btn, i) => {
        btn.classList.toggle('active', i === ['code', 'geometric', 'matrix'].indexOf(newMode));
      });
    }

    // Speed toggle
    function toggleSpeed() {
      const speeds = [0.5, 1, 2, 3];
      const labels = ['Slow', 'Normal', 'Fast', 'Hyperspeed'];
      const currentIndex = speeds.indexOf(speedMultiplier);
      const nextIndex = (currentIndex + 1) % speeds.length;
      speedMultiplier = speeds[nextIndex];
      document.querySelectorAll('.control-btn')[3].textContent = `Speed: ${labels[nextIndex]}`;
    }

    // Initialize
    window.addEventListener('resize', resize);
    resize();
    initLayers();
    render();

    // Keyboard controls
    document.addEventListener('keydown', (e) => {
      if (e.key === '1') setMode('code');
      if (e.key === '2') setMode('geometric');
      if (e.key === '3') setMode('matrix');
      if (e.key === ' ') toggleSpeed();
    });
  </script>
<script src="/sloppy-header/sloppy-bar.js"></script>
<script src="/vibelib-extended.js"></script>
<script>
  // Compatibility Patch for Legacy Apps
  window.addEventListener("load", () => {
    if (window.SloppyKarma && window.VibeLib.Economy) {
      // Redirect old calls to new engine
      window.SloppyKarma.track = window.VibeLib.Economy.track;
    }
  });
</script>
</body>
</html>
