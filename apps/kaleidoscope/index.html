<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
  <title>Neon Kaleidoscope</title>
  <link rel="icon" href="https://emojicdn.elk.sh/üî∫">
  <meta name="description" content="Mesmerizing neon triangle kaleidoscope with rotating geometric layers">
  <meta property="og:title" content="Neon Kaleidoscope">
  <meta property="og:description" content="Mesmerizing neon triangle kaleidoscope with rotating geometric layers">
  <meta property="og:image" content="https://emojicdn.elk.sh/üî∫?style=google">
  <meta property="og:url" content="https://sloppy.live/kaleidoscope">
  <style>
    @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700&display=swap');
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      background: #000;
      min-height: 100vh;
      display: flex;
      align-items: center;
      justify-content: center;
      overflow: hidden;
      font-family: 'Orbitron', sans-serif;
    }
    canvas {
      display: block;
    }
    .back-link {
      position: fixed;
      top: 20px; left: 20px;
      color: rgba(255,255,255,0.4);
      text-decoration: none;
      font-size: 0.8rem;
      z-index: 100;
    }
    .controls {
      position: fixed;
      bottom: 20px;
      display: flex;
      gap: 15px;
      z-index: 100;
    }
    .ctrl-btn {
      padding: 10px 20px;
      background: rgba(255,255,255,0.1);
      border: 1px solid rgba(255,255,255,0.3);
      color: #fff;
      font-family: 'Orbitron', sans-serif;
      font-size: 0.7rem;
      border-radius: 20px;
      cursor: pointer;
      transition: all 0.3s;
    }
    .ctrl-btn:hover {
      background: rgba(255,255,255,0.2);
      box-shadow: 0 0 20px rgba(255,255,255,0.2);
    }
    .title {
      position: fixed;
      top: 20px;
      color: rgba(255,255,255,0.5);
      font-size: 0.9rem;
      letter-spacing: 4px;
      z-index: 100;
    }
  </style>
</head>
<body>
  <a href="https://sloppy.live" class="back-link">‚Üê back</a>
  <div class="title">NEON KALEIDOSCOPE</div>
  <canvas id="canvas"></canvas>
  <div class="controls">
    <button class="ctrl-btn" onclick="changeSymmetry()">SYMMETRY</button>
    <button class="ctrl-btn" onclick="changeSpeed()">SPEED</button>
    <button class="ctrl-btn" onclick="changeColors()">COLORS</button>
    <button class="ctrl-btn" onclick="togglePulse()">PULSE</button>
    <button class="ctrl-btn" id="micBtn" onclick="toggleMic()">üé§ MIC</button>
  </div>

  <script>
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');

    let width, height, centerX, centerY;
    
    function resize() {
      width = canvas.width = window.innerWidth;
      height = canvas.height = window.innerHeight;
      centerX = width / 2;
      centerY = height / 2;
    }
    resize();
    window.addEventListener('resize', resize);

    // Settings
    let symmetry = 6;
    let speedMultiplier = 1;
    let colorScheme = 0;
    let pulseEnabled = true;
    let time = 0;

    const colorSchemes = [
      // Cyan-Magenta-Yellow
      [
        [0, 255, 255],
        [255, 0, 255],
        [255, 255, 0],
        [0, 255, 128],
      ],
      // Fire
      [
        [255, 50, 0],
        [255, 150, 0],
        [255, 255, 0],
        [255, 100, 50],
      ],
      // Ocean
      [
        [0, 100, 255],
        [0, 200, 255],
        [100, 255, 255],
        [0, 150, 200],
      ],
      // Neon Pink
      [
        [255, 0, 128],
        [255, 100, 200],
        [200, 0, 255],
        [255, 50, 150],
      ],
      // Matrix
      [
        [0, 255, 0],
        [50, 255, 100],
        [100, 255, 50],
        [0, 200, 50],
      ],
      // Rainbow
      [
        [255, 0, 0],
        [0, 255, 0],
        [0, 0, 255],
        [255, 255, 0],
      ],
    ];

    // Triangle layer class
    class TriangleLayer {
      constructor(index, total) {
        this.index = index;
        this.baseRadius = 50 + index * 40;
        this.rotationSpeed = (0.005 + index * 0.002) * (index % 2 === 0 ? 1 : -1);
        this.rotation = Math.random() * Math.PI * 2;
        this.triangleCount = 3 + index;
        this.scale = 1;
        this.colorOffset = index * 0.5;
      }

      update() {
        // Volume-boosted rotation
        const volumeRotBoost = 1 + volume * 2;
        this.rotation += this.rotationSpeed * speedMultiplier * volumeRotBoost;

        // Base pulse
        let baseScale = 1;
        if (pulseEnabled) {
          baseScale = 1 + Math.sin(time * 0.02 + this.index * 0.5) * 0.15;
        }

        // Mic volume bounce - outer layers react more
        const micBoost = volume * (0.5 + this.index * 0.1);
        this.scale = baseScale + micBoost;
      }

      draw() {
        const colors = colorSchemes[colorScheme];
        const radius = this.baseRadius * this.scale;
        
        ctx.save();
        ctx.translate(centerX, centerY);
        
        // Draw in each symmetry segment
        for (let s = 0; s < symmetry; s++) {
          ctx.save();
          ctx.rotate((s / symmetry) * Math.PI * 2);
          
          // Draw triangles in this segment
          for (let t = 0; t < this.triangleCount; t++) {
            const angle = this.rotation + (t / this.triangleCount) * Math.PI * 2;
            const colorIndex = (t + Math.floor(time * 0.01 + this.colorOffset)) % colors.length;
            const color = colors[colorIndex];
            
            // Color shifting
            const shift = Math.sin(time * 0.01 + this.index + t) * 0.3;
            const r = Math.min(255, Math.max(0, color[0] + shift * 50));
            const g = Math.min(255, Math.max(0, color[1] + shift * 50));
            const b = Math.min(255, Math.max(0, color[2] + shift * 50));
            
            const x = Math.cos(angle) * radius;
            const y = Math.sin(angle) * radius;
            const size = 20 + this.index * 5 + Math.sin(time * 0.03 + t) * 5;
            
            // Glow - boosted by volume
            ctx.shadowColor = `rgb(${r}, ${g}, ${b})`;
            ctx.shadowBlur = 20 + Math.sin(time * 0.02) * 10 + volume * 30;
            
            // Draw triangle
            ctx.strokeStyle = `rgba(${r}, ${g}, ${b}, 0.8)`;
            ctx.lineWidth = 2;
            ctx.fillStyle = `rgba(${r}, ${g}, ${b}, 0.15)`;
            
            ctx.save();
            ctx.translate(x, y);
            ctx.rotate(angle + time * 0.01 * (this.index % 2 === 0 ? 1 : -1));
            
            ctx.beginPath();
            for (let i = 0; i < 3; i++) {
              const px = Math.cos((i / 3) * Math.PI * 2 - Math.PI / 2) * size;
              const py = Math.sin((i / 3) * Math.PI * 2 - Math.PI / 2) * size;
              if (i === 0) ctx.moveTo(px, py);
              else ctx.lineTo(px, py);
            }
            ctx.closePath();
            ctx.fill();
            ctx.stroke();
            
            ctx.restore();
          }
          
          ctx.restore();
        }
        
        ctx.restore();
      }
    }

    // Create layers
    let layers = [];
    function initLayers() {
      layers = [];
      for (let i = 0; i < 8; i++) {
        layers.push(new TriangleLayer(i, 8));
      }
    }
    initLayers();

    // Center mandala
    function drawCenterMandala() {
      const colors = colorSchemes[colorScheme];
      const pulseScale = pulseEnabled ? 1 + Math.sin(time * 0.03) * 0.2 : 1;
      
      ctx.save();
      ctx.translate(centerX, centerY);
      
      // Inner rotating star
      for (let ring = 0; ring < 3; ring++) {
        const radius = (20 + ring * 15) * pulseScale;
        const points = symmetry;
        const rotation = time * 0.02 * (ring % 2 === 0 ? 1 : -1);
        
        const colorIndex = (ring + Math.floor(time * 0.02)) % colors.length;
        const color = colors[colorIndex];
        
        ctx.strokeStyle = `rgba(${color[0]}, ${color[1]}, ${color[2]}, 0.9)`;
        ctx.shadowColor = `rgb(${color[0]}, ${color[1]}, ${color[2]})`;
        ctx.shadowBlur = 30;
        ctx.lineWidth = 2;
        
        ctx.beginPath();
        for (let i = 0; i <= points * 2; i++) {
          const angle = (i / (points * 2)) * Math.PI * 2 + rotation;
          const r = i % 2 === 0 ? radius : radius * 0.5;
          const x = Math.cos(angle) * r;
          const y = Math.sin(angle) * r;
          if (i === 0) ctx.moveTo(x, y);
          else ctx.lineTo(x, y);
        }
        ctx.closePath();
        ctx.stroke();
      }
      
      // Center dot
      const dotColor = colors[0];
      ctx.fillStyle = `rgb(${dotColor[0]}, ${dotColor[1]}, ${dotColor[2]})`;
      ctx.shadowColor = `rgb(${dotColor[0]}, ${dotColor[1]}, ${dotColor[2]})`;
      ctx.shadowBlur = 40;
      ctx.beginPath();
      ctx.arc(0, 0, 5 * pulseScale, 0, Math.PI * 2);
      ctx.fill();
      
      ctx.restore();
    }

    // Background particles
    const particles = [];
    for (let i = 0; i < 50; i++) {
      particles.push({
        angle: Math.random() * Math.PI * 2,
        radius: Math.random() * Math.min(width, height) * 0.5,
        speed: 0.001 + Math.random() * 0.002,
        size: 1 + Math.random() * 2,
        colorOffset: Math.random() * 4,
      });
    }

    function drawParticles() {
      const colors = colorSchemes[colorScheme];
      
      particles.forEach(p => {
        p.angle += p.speed * speedMultiplier;
        
        const x = centerX + Math.cos(p.angle) * p.radius;
        const y = centerY + Math.sin(p.angle) * p.radius;
        
        const colorIndex = Math.floor(p.colorOffset + time * 0.01) % colors.length;
        const color = colors[colorIndex];
        
        ctx.fillStyle = `rgba(${color[0]}, ${color[1]}, ${color[2]}, 0.5)`;
        ctx.shadowColor = `rgb(${color[0]}, ${color[1]}, ${color[2]})`;
        ctx.shadowBlur = 10;
        ctx.beginPath();
        ctx.arc(x, y, p.size, 0, Math.PI * 2);
        ctx.fill();
      });
    }

    // Animation
    function animate() {
      time++;

      // Get mic volume
      volume = getVolume();

      // Fade trail
      ctx.fillStyle = 'rgba(0, 0, 0, 0.1)';
      ctx.fillRect(0, 0, width, height);

      // Draw particles
      drawParticles();
      
      // Draw layers from outside to inside
      for (let i = layers.length - 1; i >= 0; i--) {
        layers[i].update();
        layers[i].draw();
      }
      
      // Draw center
      drawCenterMandala();
      
      requestAnimationFrame(animate);
    }

    // Controls
    function changeSymmetry() {
      symmetry = symmetry === 6 ? 8 : symmetry === 8 ? 12 : symmetry === 12 ? 4 : 6;
    }

    function changeSpeed() {
      speedMultiplier = speedMultiplier === 1 ? 2 : speedMultiplier === 2 ? 0.5 : 1;
    }

    function changeColors() {
      colorScheme = (colorScheme + 1) % colorSchemes.length;
    }

    function togglePulse() {
      pulseEnabled = !pulseEnabled;
    }

    // Microphone visualizer
    let audioContext = null;
    let analyser = null;
    let microphone = null;
    let micEnabled = false;
    let volume = 0;
    const micBtn = document.getElementById('micBtn');

    async function toggleMic() {
      if (!micEnabled) {
        try {
          audioContext = new (window.AudioContext || window.webkitAudioContext)();
          analyser = audioContext.createAnalyser();
          analyser.fftSize = 256;

          const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
          microphone = audioContext.createMediaStreamSource(stream);
          microphone.connect(analyser);

          micEnabled = true;
          micBtn.style.background = 'rgba(0, 255, 128, 0.3)';
          micBtn.style.borderColor = '#0f8';
          micBtn.textContent = 'üé§ ON';
        } catch (err) {
          console.log('Mic access denied:', err);
          micBtn.textContent = 'üé§ DENIED';
        }
      } else {
        micEnabled = false;
        if (microphone) {
          microphone.disconnect();
          microphone.mediaStream.getTracks().forEach(track => track.stop());
        }
        if (audioContext) {
          audioContext.close();
        }
        volume = 0;
        micBtn.style.background = 'rgba(255,255,255,0.1)';
        micBtn.style.borderColor = 'rgba(255,255,255,0.3)';
        micBtn.textContent = 'üé§ MIC';
      }
    }

    function getVolume() {
      if (!micEnabled || !analyser) return 0;

      const dataArray = new Uint8Array(analyser.frequencyBinCount);
      analyser.getByteFrequencyData(dataArray);

      let sum = 0;
      for (let i = 0; i < dataArray.length; i++) {
        sum += dataArray[i];
      }
      return sum / dataArray.length / 255; // Normalize 0-1
    }

    // Mouse interaction - affects rotation
    let mouseX = centerX, mouseY = centerY;
    document.addEventListener('mousemove', (e) => {
      mouseX = e.clientX;
      mouseY = e.clientY;
      
      // Affect layer rotation based on mouse position
      const dx = (mouseX - centerX) / width;
      const dy = (mouseY - centerY) / height;
      
      layers.forEach((layer, i) => {
        layer.rotationSpeed = (0.005 + i * 0.002 + dx * 0.01) * (i % 2 === 0 ? 1 : -1);
      });
    });

    // Touch support
    document.addEventListener('touchmove', (e) => {
      const touch = e.touches[0];
      mouseX = touch.clientX;
      mouseY = touch.clientY;
      
      const dx = (mouseX - centerX) / width;
      
      layers.forEach((layer, i) => {
        layer.rotationSpeed = (0.005 + i * 0.002 + dx * 0.01) * (i % 2 === 0 ? 1 : -1);
      });
    });

    animate();
  </script>
</body>
</html>
