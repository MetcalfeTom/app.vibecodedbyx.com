<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
  <title>Sploppy - Squishy Physics Sandbox</title>
  <link rel="icon" href="https://emojicdn.elk.sh/ðŸ«§">
  <meta name="description" content="Drag, drop, and squish colorful jelly balls in this physics sandbox.">
  <meta property="og:title" content="Sploppy">
  <meta property="og:description" content="Squishy jelly ball physics sandbox. Drag, drop, squish!">
  <meta property="og:url" content="https://app.sloppy.live/sploppy">
  <meta property="og:image" content="https://app.sloppy.live/sploppy/og-image.png">
  <meta property="og:type" content="website">
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link href="https://fonts.googleapis.com/css2?family=Nunito:wght@600;700;800&display=swap" rel="stylesheet">
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }
    body {
      background: linear-gradient(135deg, #1a1a2e 0%, #16213e 50%, #0f3460 100%);
      font-family: 'Nunito', sans-serif;
      overflow: hidden;
      height: 100vh;
      touch-action: none;
    }
    #canvas {
      display: block;
      cursor: grab;
    }
    #canvas:active {
      cursor: grabbing;
    }
    .ui {
      position: fixed;
      top: 20px;
      left: 20px;
      z-index: 10;
      display: flex;
      flex-direction: column;
      gap: 10px;
    }
    .title {
      font-size: 28px;
      font-weight: 800;
      color: #fff;
      text-shadow: 0 4px 20px rgba(255, 100, 150, 0.5);
      margin-bottom: 5px;
    }
    .controls {
      display: flex;
      gap: 8px;
      flex-wrap: wrap;
    }
    .btn {
      background: rgba(255, 255, 255, 0.15);
      backdrop-filter: blur(10px);
      border: 2px solid rgba(255, 255, 255, 0.2);
      border-radius: 12px;
      padding: 10px 16px;
      color: #fff;
      font-family: 'Nunito', sans-serif;
      font-size: 13px;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.2s;
    }
    .btn:hover {
      background: rgba(255, 255, 255, 0.25);
      transform: scale(1.05);
    }
    .btn:active {
      transform: scale(0.95);
    }
    .color-picker {
      display: flex;
      gap: 6px;
      margin-top: 5px;
    }
    .color-btn {
      width: 32px;
      height: 32px;
      border-radius: 50%;
      border: 3px solid rgba(255, 255, 255, 0.3);
      cursor: pointer;
      transition: all 0.2s;
    }
    .color-btn:hover {
      transform: scale(1.15);
    }
    .color-btn.active {
      border-color: #fff;
      box-shadow: 0 0 15px currentColor;
    }
    .hint {
      position: fixed;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(0, 0, 0, 0.5);
      padding: 10px 20px;
      border-radius: 20px;
      color: rgba(255, 255, 255, 0.7);
      font-size: 13px;
      pointer-events: none;
      transition: opacity 0.5s;
    }
    .hint.hidden {
      opacity: 0;
    }
    .backlink {
      position: fixed;
      bottom: 15px;
      right: 15px;
      color: rgba(255, 255, 255, 0.4);
      font-size: 11px;
      text-decoration: none;
      z-index: 10;
    }
    .backlink:hover {
      color: #fff;
    }
    .stats {
      position: fixed;
      top: 20px;
      right: 20px;
      background: rgba(0, 0, 0, 0.3);
      padding: 10px 15px;
      border-radius: 10px;
      color: rgba(255, 255, 255, 0.7);
      font-size: 12px;
    }
  </style>
</head>
<body>
  <canvas id="canvas"></canvas>

  <div class="ui">
    <div class="title">Sploppy ðŸ«§</div>
    <div class="controls">
      <button class="btn" id="addBtn">+ Add Ball</button>
      <button class="btn" id="clearBtn">Clear All</button>
      <button class="btn" id="gravityBtn">Gravity: ON</button>
    </div>
    <div class="color-picker" id="colorPicker"></div>
  </div>

  <div class="stats" id="stats">Balls: 0</div>
  <div class="hint" id="hint">Click anywhere to spawn jelly balls! Drag to squish them around.</div>
  <a href="https://sloppy.live" class="backlink">sloppy.live</a>

  <script>
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');

    let W, H;
    function resize() {
      W = canvas.width = window.innerWidth;
      H = canvas.height = window.innerHeight;
    }
    resize();
    window.addEventListener('resize', resize);

    // Colors
    const colors = [
      { main: '#ff6b9d', light: '#ff9ec4', dark: '#cc3366' },
      { main: '#7c5cff', light: '#a694ff', dark: '#5533cc' },
      { main: '#00d4aa', light: '#66eecc', dark: '#009977' },
      { main: '#ffb347', light: '#ffcc80', dark: '#cc8800' },
      { main: '#ff5757', light: '#ff8a8a', dark: '#cc2222' },
      { main: '#47d1ff', light: '#8ae3ff', dark: '#0099cc' },
      { main: '#c77dff', light: '#e0b0ff', dark: '#9933ff' },
      { main: '#7fff7f', light: '#b3ffb3', dark: '#33cc33' }
    ];

    let selectedColor = 0;
    let gravity = true;
    let balls = [];
    let dragging = null;
    let mouseX = 0, mouseY = 0;
    let lastMouseX = 0, lastMouseY = 0;

    // Initialize color picker
    const colorPicker = document.getElementById('colorPicker');
    colors.forEach((c, i) => {
      const btn = document.createElement('button');
      btn.className = 'color-btn' + (i === 0 ? ' active' : '');
      btn.style.background = c.main;
      btn.onclick = () => {
        document.querySelectorAll('.color-btn').forEach(b => b.classList.remove('active'));
        btn.classList.add('active');
        selectedColor = i;
      };
      colorPicker.appendChild(btn);
    });

    // Soft body ball class
    class JellyBall {
      constructor(x, y, radius, colorIndex) {
        this.x = x;
        this.y = y;
        this.vx = 0;
        this.vy = 0;
        this.radius = radius;
        this.baseRadius = radius;
        this.colorIndex = colorIndex;
        this.color = colors[colorIndex];

        // Squish properties
        this.squishX = 1;
        this.squishY = 1;
        this.targetSquishX = 1;
        this.targetSquishY = 1;
        this.rotation = 0;
        this.angularVel = 0;

        // Wobble
        this.wobblePhase = Math.random() * Math.PI * 2;
        this.wobbleSpeed = 0.1 + Math.random() * 0.05;
        this.wobbleAmp = 0;

        // Physics
        this.mass = radius * radius * 0.01;
        this.friction = 0.98;
        this.bounciness = 0.7;
        this.squishFactor = 0.4;
      }

      update(dt) {
        // Apply gravity
        if (gravity) {
          this.vy += 0.5;
        }

        // Apply velocity
        this.x += this.vx;
        this.y += this.vy;

        // Friction
        this.vx *= this.friction;
        this.vy *= this.friction;

        // Angular velocity
        this.rotation += this.angularVel;
        this.angularVel *= 0.95;

        // Wobble decay
        this.wobbleAmp *= 0.92;
        this.wobblePhase += this.wobbleSpeed;

        // Squish interpolation
        this.squishX += (this.targetSquishX - this.squishX) * 0.15;
        this.squishY += (this.targetSquishY - this.squishY) * 0.15;
        this.targetSquishX += (1 - this.targetSquishX) * 0.1;
        this.targetSquishY += (1 - this.targetSquishY) * 0.1;

        // Floor collision
        if (this.y + this.radius * this.squishY > H) {
          this.y = H - this.radius * this.squishY;
          const impact = Math.abs(this.vy);
          this.vy *= -this.bounciness;

          // Squish on impact
          if (impact > 2) {
            this.targetSquishY = 1 - Math.min(0.4, impact * 0.02);
            this.targetSquishX = 1 + Math.min(0.3, impact * 0.015);
            this.wobbleAmp = Math.min(0.15, impact * 0.01);
          }

          // Rolling friction
          this.vx *= 0.95;
          this.angularVel = this.vx * 0.02;
        }

        // Ceiling
        if (this.y - this.radius * this.squishY < 0) {
          this.y = this.radius * this.squishY;
          this.vy *= -this.bounciness;
          this.targetSquishY = 0.7;
          this.targetSquishX = 1.2;
        }

        // Walls
        if (this.x + this.radius * this.squishX > W) {
          this.x = W - this.radius * this.squishX;
          const impact = Math.abs(this.vx);
          this.vx *= -this.bounciness;
          if (impact > 2) {
            this.targetSquishX = 1 - Math.min(0.3, impact * 0.02);
            this.targetSquishY = 1 + Math.min(0.2, impact * 0.015);
          }
        }
        if (this.x - this.radius * this.squishX < 0) {
          this.x = this.radius * this.squishX;
          const impact = Math.abs(this.vx);
          this.vx *= -this.bounciness;
          if (impact > 2) {
            this.targetSquishX = 1 - Math.min(0.3, impact * 0.02);
            this.targetSquishY = 1 + Math.min(0.2, impact * 0.015);
          }
        }
      }

      draw() {
        ctx.save();
        ctx.translate(this.x, this.y);
        ctx.rotate(this.rotation);

        const wobble = Math.sin(this.wobblePhase) * this.wobbleAmp;
        const scaleX = this.squishX + wobble;
        const scaleY = this.squishY - wobble;

        ctx.scale(scaleX, scaleY);

        // Shadow
        ctx.beginPath();
        ctx.ellipse(5, 8, this.radius * 0.9, this.radius * 0.3, 0, 0, Math.PI * 2);
        ctx.fillStyle = 'rgba(0, 0, 0, 0.2)';
        ctx.fill();

        // Main body gradient
        const gradient = ctx.createRadialGradient(
          -this.radius * 0.3, -this.radius * 0.3, 0,
          0, 0, this.radius
        );
        gradient.addColorStop(0, this.color.light);
        gradient.addColorStop(0.5, this.color.main);
        gradient.addColorStop(1, this.color.dark);

        ctx.beginPath();
        ctx.arc(0, 0, this.radius, 0, Math.PI * 2);
        ctx.fillStyle = gradient;
        ctx.fill();

        // Glossy highlight
        ctx.beginPath();
        ctx.ellipse(-this.radius * 0.25, -this.radius * 0.35, this.radius * 0.35, this.radius * 0.25, -0.5, 0, Math.PI * 2);
        ctx.fillStyle = 'rgba(255, 255, 255, 0.4)';
        ctx.fill();

        // Small highlight
        ctx.beginPath();
        ctx.arc(-this.radius * 0.15, -this.radius * 0.5, this.radius * 0.12, 0, Math.PI * 2);
        ctx.fillStyle = 'rgba(255, 255, 255, 0.6)';
        ctx.fill();

        ctx.restore();
      }

      contains(px, py) {
        const dx = px - this.x;
        const dy = py - this.y;
        return dx * dx + dy * dy < this.radius * this.radius * 1.2;
      }

      applyForce(fx, fy) {
        this.vx += fx / this.mass;
        this.vy += fy / this.mass;
      }
    }

    // Ball-to-ball collision
    function ballCollision(a, b) {
      const dx = b.x - a.x;
      const dy = b.y - a.y;
      const dist = Math.sqrt(dx * dx + dy * dy);
      const minDist = a.radius + b.radius;

      if (dist < minDist && dist > 0) {
        const nx = dx / dist;
        const ny = dy / dist;
        const overlap = minDist - dist;

        // Separate balls
        const totalMass = a.mass + b.mass;
        a.x -= nx * overlap * (b.mass / totalMass);
        a.y -= ny * overlap * (b.mass / totalMass);
        b.x += nx * overlap * (a.mass / totalMass);
        b.y += ny * overlap * (a.mass / totalMass);

        // Relative velocity
        const dvx = a.vx - b.vx;
        const dvy = a.vy - b.vy;
        const dvn = dvx * nx + dvy * ny;

        if (dvn > 0) {
          const restitution = 0.6;
          const impulse = (1 + restitution) * dvn / totalMass;

          a.vx -= impulse * b.mass * nx;
          a.vy -= impulse * b.mass * ny;
          b.vx += impulse * a.mass * nx;
          b.vy += impulse * a.mass * ny;

          // Squish effect
          const impact = Math.abs(dvn);
          if (impact > 3) {
            const squish = Math.min(0.25, impact * 0.015);
            a.targetSquishX = 1 - squish;
            a.targetSquishY = 1 + squish * 0.7;
            b.targetSquishX = 1 - squish;
            b.targetSquishY = 1 + squish * 0.7;
            a.wobbleAmp = Math.min(0.1, impact * 0.008);
            b.wobbleAmp = Math.min(0.1, impact * 0.008);
          }
        }
      }
    }

    function spawnBall(x, y) {
      const radius = 30 + Math.random() * 30;
      balls.push(new JellyBall(x, y, radius, selectedColor));
      updateStats();
      hideHint();
    }

    function updateStats() {
      document.getElementById('stats').textContent = `Balls: ${balls.length}`;
    }

    function hideHint() {
      document.getElementById('hint').classList.add('hidden');
    }

    // Input handling
    function getPointerPos(e) {
      if (e.touches) {
        return { x: e.touches[0].clientX, y: e.touches[0].clientY };
      }
      return { x: e.clientX, y: e.clientY };
    }

    function handleStart(e) {
      e.preventDefault();
      const pos = getPointerPos(e);
      mouseX = lastMouseX = pos.x;
      mouseY = lastMouseY = pos.y;

      // Check if clicking on a ball
      for (let i = balls.length - 1; i >= 0; i--) {
        if (balls[i].contains(pos.x, pos.y)) {
          dragging = balls[i];
          dragging.targetSquishX = 0.85;
          dragging.targetSquishY = 1.1;
          return;
        }
      }

      // Spawn new ball
      spawnBall(pos.x, pos.y);
    }

    function handleMove(e) {
      e.preventDefault();
      const pos = getPointerPos(e);
      lastMouseX = mouseX;
      lastMouseY = mouseY;
      mouseX = pos.x;
      mouseY = pos.y;

      if (dragging) {
        const dx = mouseX - dragging.x;
        const dy = mouseY - dragging.y;
        dragging.x += dx * 0.3;
        dragging.y += dy * 0.3;
        dragging.vx = (mouseX - lastMouseX) * 0.5;
        dragging.vy = (mouseY - lastMouseY) * 0.5;

        // Stretch in drag direction
        const dragDist = Math.sqrt(dx * dx + dy * dy);
        if (dragDist > 10) {
          dragging.targetSquishX = 0.8;
          dragging.targetSquishY = 1.15;
        }
      }
    }

    function handleEnd(e) {
      if (dragging) {
        dragging.targetSquishX = 1;
        dragging.targetSquishY = 1;
        dragging.wobbleAmp = 0.1;

        // Apply throw velocity
        dragging.vx = (mouseX - lastMouseX) * 1.5;
        dragging.vy = (mouseY - lastMouseY) * 1.5;

        dragging = null;
      }
    }

    canvas.addEventListener('mousedown', handleStart);
    canvas.addEventListener('mousemove', handleMove);
    canvas.addEventListener('mouseup', handleEnd);
    canvas.addEventListener('mouseleave', handleEnd);

    canvas.addEventListener('touchstart', handleStart, { passive: false });
    canvas.addEventListener('touchmove', handleMove, { passive: false });
    canvas.addEventListener('touchend', handleEnd);

    // UI buttons
    document.getElementById('addBtn').onclick = () => {
      spawnBall(W / 2 + (Math.random() - 0.5) * 200, 100);
    };

    document.getElementById('clearBtn').onclick = () => {
      balls = [];
      updateStats();
    };

    document.getElementById('gravityBtn').onclick = function() {
      gravity = !gravity;
      this.textContent = `Gravity: ${gravity ? 'ON' : 'OFF'}`;
    };

    // Game loop
    function update() {
      // Update balls
      balls.forEach(ball => ball.update());

      // Ball collisions
      for (let i = 0; i < balls.length; i++) {
        for (let j = i + 1; j < balls.length; j++) {
          ballCollision(balls[i], balls[j]);
        }
      }
    }

    function draw() {
      // Clear with gradient
      const bgGrad = ctx.createLinearGradient(0, 0, W, H);
      bgGrad.addColorStop(0, '#1a1a2e');
      bgGrad.addColorStop(0.5, '#16213e');
      bgGrad.addColorStop(1, '#0f3460');
      ctx.fillStyle = bgGrad;
      ctx.fillRect(0, 0, W, H);

      // Draw some ambient particles
      ctx.fillStyle = 'rgba(255, 255, 255, 0.03)';
      for (let i = 0; i < 50; i++) {
        const x = (Math.sin(Date.now() * 0.0001 + i) * 0.5 + 0.5) * W;
        const y = (Math.cos(Date.now() * 0.00015 + i * 1.5) * 0.5 + 0.5) * H;
        ctx.beginPath();
        ctx.arc(x, y, 2 + Math.sin(i) * 2, 0, Math.PI * 2);
        ctx.fill();
      }

      // Draw balls (sorted by y for depth)
      balls.sort((a, b) => a.y - b.y);
      balls.forEach(ball => ball.draw());
    }

    function gameLoop() {
      update();
      draw();
      requestAnimationFrame(gameLoop);
    }

    gameLoop();
  </script>
<script src="/apps/sloppy-header/sloppy-bar.js"></script>
<script src="/vibelib-extended.js"></script>
<script>
  // Compatibility Patch for Legacy Apps
  window.addEventListener("load", () => {
    if (window.SloppyKarma && window.VibeLib.Economy) {
      // Redirect old calls to new engine
      window.SloppyKarma.track = window.VibeLib.Economy.track;
    }
  });
</script>
</body>
</html>
