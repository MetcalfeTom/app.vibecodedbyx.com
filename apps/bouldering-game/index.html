<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Bouldering Game — Climb the Route</title>

    <!-- Social Sharing -->
    <meta property="og:title" content="Bouldering Game — Climb the Route" />
    <meta property="og:description" content="Reach the top fast. Beat the global leaderboard!" />
    <meta property="og:url" content="https://app.vibecodedbyx.com/bouldering-game/" />
    <meta property="og:image" content="https://app.vibecodedbyx.com/bouldering-game/og.png" />
    <meta property="og:type" content="website" />
    <meta name="description" content="Climb fast, stick the top, and race the global leaderboard in this minimalist bouldering puzzle." />
    <meta name="twitter:card" content="summary_large_image" />
    <meta name="twitter:title" content="Bouldering Game — Climb the Route" />
    <meta name="twitter:description" content="Reach the top fast. Beat the global leaderboard!" />
    <meta name="twitter:image" content="https://app.vibecodedbyx.com/bouldering-game/og.png" />
    <link rel="canonical" href="https://app.vibecodedbyx.com/bouldering-game/" />
    <link rel="icon" href='data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 100 100"><text y="0.9em" font-size="90">🧗</text></svg>' />

    <style>
      :root {
        --bg: #0a0b10;
        --bg-2: #0f1120;
        --card: #12131a;
        --ink: #eef1f7;
        --muted: #aab0bc;
        --accent: #5eead4;   /* teal */
        --accent-2: #f59e0b; /* amber */
        --brand-1: #7dd3fc;  /* sky */
        --brand-2: #60a5fa;  /* blue */
        --danger: #ef4444;
        --ok: #22c55e;
        --ring: rgba(94,234,212,0.6);
      }
      * { box-sizing: border-box; }
      html, body { height: 100%; }
      body {
        margin: 0; font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial;
        background:
          radial-gradient(1000px 700px at 50% -10%, #1a2030 0%, transparent 50%),
          radial-gradient(800px 600px at 120% 20%, rgba(96,165,250,0.18), transparent 60%),
          radial-gradient(900px 600px at -20% 60%, rgba(94,234,212,0.12), transparent 70%),
          linear-gradient(180deg, var(--bg-2), var(--bg));
        color: var(--ink);
        display: flex; align-items: center; justify-content: center;
      }
      .wrap { width: min(1100px, 96vw); padding: 20px; }
      header { display: flex; align-items: center; justify-content: space-between; margin-bottom: 14px; }
      .brand { display: flex; align-items: center; gap: 12px; font-weight: 900; letter-spacing: 0.2px; }
      .brand .logo {
        width: 30px; height: 30px; border-radius: 8px;
        background: linear-gradient(135deg, var(--brand-1), var(--brand-2));
        box-shadow: 0 6px 16px rgba(96,165,250,0.35), inset 0 1px 0 rgba(255,255,255,0.25);
      }
      .row { display: grid; grid-template-columns: 1fr; gap: 16px; }
      @media (min-width: 940px) { .row { grid-template-columns: 1.2fr 1fr; } }
      .card {
        background: linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.005))
                    ,var(--card);
        border: 1px solid rgba(255,255,255,0.06);
        border-radius: 16px; padding: 16px;
        box-shadow: 0 10px 30px rgba(0,0,0,0.35), inset 0 1px 0 rgba(255,255,255,0.04);
        backdrop-filter: blur(6px);
      }
      .btn {
        border: 1px solid #2c2f3a;
        background: linear-gradient(180deg, #242635, #171924);
        color: var(--ink); padding: 12px 16px; border-radius: 12px;
        cursor: pointer; touch-action: manipulation; font-weight: 700;
        transition: transform 120ms ease, box-shadow 120ms ease, filter 120ms ease;
        box-shadow: 0 6px 16px rgba(0,0,0,0.25);
      }
      .btn:hover { transform: translateY(-1px); filter: brightness(1.05); }
      .btn:active { transform: translateY(0); filter: brightness(0.98); }
      .btn:focus-visible { outline: 0; box-shadow: 0 0 0 3px var(--ring); }
      .btn.primary {
        border-color: rgba(14,165,233,0.5);
        background: linear-gradient(180deg, #0ea5e9, #0284c7);
        color: #001018; font-weight: 900;
        text-shadow: 0 1px 0 rgba(255,255,255,0.2);
      }
      .muted { color: var(--muted); }
      .link { color: var(--accent); text-decoration: none; }
      .hud { display: flex; gap: 12px; flex-wrap: wrap; align-items: center; }
      .pill {
        background: #0f121a; border: 1px solid rgba(255,255,255,0.06);
        border-radius: 999px; padding: 8px 12px; font-weight: 700; letter-spacing: .2px;
      }

      /* Board */
      .board-wrap { display: grid; place-items: center; }
      .board { position: relative; width: min(520px, 96vw); aspect-ratio: 3/4;
        background: linear-gradient(180deg, #141722, #0d0f17);
        border: 1px solid rgba(255,255,255,0.06); border-radius: 16px; overflow: hidden;
        box-shadow: inset 0 1px 0 rgba(255,255,255,0.03), 0 12px 28px rgba(0,0,0,0.45);
        transition: transform 200ms ease;
      }
      .board:hover { transform: translateY(-1px); }
      .board::after {
        content: ""; position: absolute; inset: 0; pointer-events: none;
        background: radial-gradient(1200px 800px at 50% -20%, rgba(255,255,255,0.04), transparent 60%);
      }
      .grid { position: absolute; inset: 0; background-image: radial-gradient(circle at 1px 1px, #2a2f3a 1px, transparent 0); background-size: calc(100%/8) calc(100%/12); opacity: 0.33; }
      /* Procedural noise texture */
      svg#noiseFilter { position: absolute; width: 0; height: 0; }
      .noise-overlay { position: absolute; inset: 0; opacity: 0.06; pointer-events: none; filter: url(#noise); }
      .hold { position: absolute; width: 32px; height: 32px; margin: -16px 0 0 -16px; border-radius: 50%; display: grid; place-items: center; color: #000; font-size: 14px; font-weight: 900; text-shadow: 0 1px 0 rgba(255,255,255,0.5); box-shadow: 0 8px 18px rgba(0,0,0,0.45); transition: transform 160ms ease, box-shadow 160ms ease, filter 160ms ease; }
      .type-start { background: #22c55e; }
      .type-top { background: #f59e0b; }
      .type-mid { background: #a78bfa; }
      .type-bad { background: #ef4444; }
      /* Hold variety */
      .type-start { width: 38px; height: 34px; margin: -17px 0 0 -19px; border-radius: 14px 18px 12px 16px; transform: rotate(-6deg); }
      .type-top { width: 36px; height: 36px; margin: -18px 0 0 -18px; border-radius: 50%; position: relative; }
      .type-mid { width: 32px; height: 30px; margin: -15px 0 0 -16px; border-radius: 40% 60% 50% 50%; transform: rotate(8deg); }
      .type-bad { width: 28px; height: 26px; margin: -13px 0 0 -14px; border-radius: 42% 58% 46% 54%; filter: saturate(1.1) contrast(1.05); }
      .hold:hover { filter: brightness(1.08); transform: translateY(-1px) scale(1.03); }
      .hold.on-limb { box-shadow: 0 0 0 3px rgba(94,234,212,0.55), 0 12px 24px rgba(0,0,0,0.5); }
      .hold.available { box-shadow: 0 0 0 2px rgba(94,234,212,0.45), 0 10px 22px rgba(0,0,0,0.45); transform: translateY(-2px) scale(1.05); }
      .type-top::after {
        content: ""; position: absolute; inset: -6px; border-radius: 999px;
        box-shadow: 0 0 0 3px rgba(245,158,11,0.5), 0 0 28px rgba(245,158,11,0.35);
        animation: ping 1.6s ease-out infinite;
      }
      @keyframes ping { 0%{opacity:.6; transform:scale(.92);} 80%{opacity:0; transform:scale(1.2);} 100%{opacity:0;} }
      .climber { position: absolute; width: 26px; height: 26px; margin: -13px 0 0 -13px; border-radius: 50%; background: linear-gradient(180deg, #e5e7eb, #9ca3af); border: 2px solid #0d0d0f; box-shadow: 0 10px 20px rgba(0,0,0,0.4), 0 0 0 3px rgba(94,234,212,0.15); }
      .pulse { animation: pulse 1s ease-out; }
      @keyframes pulse { 0%{transform:scale(1);} 50%{transform:scale(1.15);} 100%{transform:scale(1);} }
      /* Chalk particles */
      .chalk { position: absolute; width: 6px; height: 6px; border-radius: 50%; background: rgba(255,255,255,0.75); filter: blur(0.5px); opacity: 0.9; animation: chalk 800ms ease-out forwards; }
      @keyframes chalk { 0%{ transform: translate(0,0) scale(1); opacity:.9; } 100%{ transform: translate(var(--dx,0px), calc(var(--dy,-12px))) scale(.6); opacity:0; } }

      /* D-Pad for mobile */
      .dpad { display: grid; grid-template-columns: 60px 60px 60px; grid-template-rows: 60px 60px 60px; gap: 8px; justify-content: center; align-items: center; }
      .dpad .spacer { visibility: hidden; }
      .dpad .btn { width: 60px; height: 60px; border-radius: 14px; font-size: 20px; display: grid; place-items: center; }
      @media (max-width: 640px) {
        .btn { padding: 14px 18px; border-radius: 14px; }
        .hold { width: 36px; height: 36px; margin: -18px 0 0 -18px; font-size: 16px; }
        .climber { width: 28px; height: 28px; margin: -14px 0 0 -14px; }
        .dpad { grid-template-columns: 66px 66px 66px; grid-template-rows: 66px 66px 66px; gap: 10px; }
        .dpad .btn { width: 66px; height: 66px; font-size: 22px; }
      }
      @supports (padding: max(0px)) {
        body { padding-bottom: max(env(safe-area-inset-bottom), 0px); }
      }

      .leaderboard ol { margin: 0; padding-left: 18px; }
      .leaderboard li { padding: 4px 0; }
      footer { margin-top: 16px; text-align: center; font-size: 14px; color: var(--muted); }

      /* Bones overlay */
      .bones { position: absolute; inset: 0; width: 100%; height: 100%; pointer-events: none; }
      .bones line { stroke: rgba(94,234,212,0.5); stroke-width: 6; stroke-linecap: round; filter: drop-shadow(0 2px 2px rgba(0,0,0,0.4)); }
      .bones #hip-dot { fill: rgba(94,234,212,0.8); }
    </style>
  </head>
  <body>
    <div class="wrap">
      <header>
        <div class="brand"><div class="logo"></div><div>Bouldering Game</div></div>
        <div class="hud">
          <div id="auth" class="muted">Loading…</div>
          <button id="signin" class="btn" style="display:none">Sign in with Twitter</button>
          <button id="signout" class="btn" style="display:none">Sign out</button>
        </div>
      </header>

      <div class="row">
        <section class="card">
          <div class="hud" style="margin-bottom:10px; flex-wrap:wrap">
            <div class="pill">Route: <span id="routeName">Classic V2</span></div>
            <div class="pill">Time: <span id="time">0.00</span>s</div>
            <div class="pill">Best: <span id="best">—</span></div>
            <button id="start" class="btn primary">Start</button>
          </div>
          <div class="hud" style="margin-bottom:10px; flex-wrap:wrap">
            <div class="pill">Limb:</div>
            <button id="btn-LH" class="btn">Left Hand (1)</button>
            <button id="btn-RH" class="btn">Right Hand (2)</button>
            <button id="btn-LF" class="btn">Left Foot (3)</button>
            <button id="btn-RF" class="btn">Right Foot (4)</button>
          </div>
          <div class="board-wrap">
            <div class="board" id="board">
              <div class="grid"></div>
              <!-- subtle noise overlay via feTurbulence -->
              <svg id="noiseFilter" aria-hidden="true">
                <filter id="noise">
                  <feTurbulence type="fractalNoise" baseFrequency="0.8" numOctaves="2" stitchTiles="stitch"/>
                  <feColorMatrix type="saturate" values="0"/>
                </filter>
              </svg>
              <div class="noise-overlay"></div>
              <!-- Holds, bones, and limbs will be injected here -->
              <svg id="bones" class="bones" viewBox="0 0 1000 1000" preserveAspectRatio="none" aria-hidden="true">
                <line id="bone-LH" x1="0" y1="0" x2="0" y2="0" />
                <line id="bone-RH" x1="0" y1="0" x2="0" y2="0" />
                <line id="bone-LF" x1="0" y1="0" x2="0" y2="0" />
                <line id="bone-RF" x1="0" y1="0" x2="0" y2="0" />
                <circle id="hip-dot" cx="0" cy="0" r="10" />
              </svg>
              <div id="limb-LH" class="climber" style="display:none; background: linear-gradient(180deg,#fef08a,#f59e0b)"></div>
              <div id="limb-RH" class="climber" style="display:none; background: linear-gradient(180deg,#bbf7d0,#22c55e)"></div>
              <div id="limb-LF" class="climber" style="display:none; background: linear-gradient(180deg,#c7d2fe,#818cf8)"></div>
              <div id="limb-RF" class="climber" style="display:none; background: linear-gradient(180deg,#fecaca,#ef4444)"></div>
            </div>
          </div>
          <div class="hud" style="justify-content:center; margin-top:12px">
            <div class="dpad" aria-label="Directional pad">
              <div class="spacer"></div>
              <button id="btn-up" class="btn" aria-label="Move Up">⬆️</button>
              <div class="spacer"></div>
              <button id="btn-left" class="btn" aria-label="Move Left">⬅️</button>
              <button id="btn-down" class="btn" aria-label="Move Down">⬇️</button>
              <button id="btn-right" class="btn" aria-label="Move Right">➡️</button>
            </div>
          </div>
          <p class="muted">Controls: select a limb (buttons or keys 1–4) and click any glowing hold to move that limb. You can only move if your body stays within reach: arms and legs have limited length and left/right limbs can’t cross. The timer starts on your first move—stick both hands on the Top (T) to finish.</p>
        </section>

        <aside class="card leaderboard">
          <h3>Top Climbers (fastest)</h3>
          <ol id="leaders"></ol>
          <p class="muted">Your best run saves automatically.</p>
        </aside>
      </div>

      <footer>
        <a class="link" href="https://www.vibecodedbyx.com" target="_blank" rel="noopener">Back to the livestream</a>
      </footer>
    </div>

    <!-- Dummy nodes to satisfy global example code in supabase-config.js -->
    <div id="premium-content" style="display:none"></div>
    <div id="upgrade-button" style="display:none"></div>

    <script type="module">
      import supabase, { supabaseSession } from './supabase-config.js';

      const els = {
        board: document.getElementById('board'),
        limbLH: document.getElementById('limb-LH'),
        limbRH: document.getElementById('limb-RH'),
        limbLF: document.getElementById('limb-LF'),
        limbRF: document.getElementById('limb-RF'),
        start: document.getElementById('start'),
        time: document.getElementById('time'),
        best: document.getElementById('best'),
        leaders: document.getElementById('leaders'),
        auth: document.getElementById('auth'),
        signin: document.getElementById('signin'),
        signout: document.getElementById('signout'),
        btnLH: document.getElementById('btn-LH'),
        btnRH: document.getElementById('btn-RH'),
        btnLF: document.getElementById('btn-LF'),
        btnRF: document.getElementById('btn-RF'),
        btnUp: document.getElementById('btn-up'),
        btnDown: document.getElementById('btn-down'),
        btnLeft: document.getElementById('btn-left'),
        btnRight: document.getElementById('btn-right'),
      };

      const route = {
        name: 'Classic V2',
        // grid 8 x 12, positions as [col,row] in 0..1 normalized
        holds: [
          { x: 0.1, y: 0.95, type: 'start' },
          { x: 0.3, y: 0.82, type: 'mid' },
          { x: 0.52, y: 0.78, type: 'mid' },
          { x: 0.68, y: 0.64, type: 'mid' },
          { x: 0.42, y: 0.58, type: 'mid' },
          { x: 0.23, y: 0.47, type: 'mid' },
          { x: 0.44, y: 0.39, type: 'mid' },
          { x: 0.64, y: 0.31, type: 'mid' },
          { x: 0.48, y: 0.18, type: 'mid' },
          { x: 0.52, y: 0.06, type: 'top' },
        ],
      };

      const MAX_REACH = 0.25; // per-limb adjacency gate
      const ARM_MAX = 0.27;   // hip → hand max distance (normalized)
      const LEG_MAX = 0.33;   // hip → foot max distance (normalized)

      let state = {
        session: null, user: null,
        startedAt: 0, timerId: null, finished: false,
        bestMs: null,
        nodes: [],
        limbs: { LH: 0, RH: 0, LF: 0, RF: 0 },
        selected: 'LH',
      };

      function formatMs(ms) { return (ms/1000).toFixed(2); }
      function escapeHtml(text) {
        return String(text ?? '').replace(/[&<>'"]/g, (ch) => {
          switch (ch) {
            case '&': return '&amp;';
            case '<': return '&lt;';
            case '>': return '&gt;';
            case '"': return '&quot;';
            case "'": return '&#39;';
            default: return ch;
          }
        });
      }
      function dist(a, b) { const dx=a.x-b.x, dy=a.y-b.y; return Math.hypot(dx, dy); }

      function placeHolds() {
        const rect = els.board.getBoundingClientRect();
        els.board.querySelectorAll('.hold').forEach(n=>n.remove());
        state.nodes = route.holds.map((h, i) => {
          const el = document.createElement('div');
          el.className = `hold type-${h.type || 'mid'}`;
          el.style.left = `${h.x*100}%`;
          el.style.top = `${h.y*100}%`;
          el.textContent = i === 0 ? 'S' : (i === route.holds.length-1 ? 'T' : '');
          el.dataset.index = String(i);
          els.board.appendChild(el);
          el.addEventListener('click', () => tryMoveSelectedTo(i));
          return { ...h, el };
        });
      }

      function updateLimbPositions(pulseKey=null) {
        const offset = { LH: [-10,-10], RH: [10,-10], LF: [-10,10], RF: [10,10] };
        for (const key of ['LH','RH','LF','RF']) {
          const idx = state.limbs[key];
          const n = state.nodes[idx]; if (!n) continue;
          const el = key==='LH'?els.limbLH:key==='RH'?els.limbRH:key==='LF'?els.limbLF:els.limbRF;
          el.style.left = `calc(${n.x*100}% + ${offset[key][0]}px)`;
          el.style.top = `calc(${n.y*100}% + ${offset[key][1]}px)`;
          el.style.display = '';
          if (pulseKey===key) { el.classList.remove('pulse'); void el.offsetWidth; el.classList.add('pulse'); }
          el.style.boxShadow = state.selected===key ? '0 0 0 3px rgba(94,234,212,0.9), 0 10px 20px rgba(0,0,0,0.4)' : '0 10px 20px rgba(0,0,0,0.4)';
        }
        drawBones();
        highlightOptions();
      }

      function drawBones() {
        const hip = computeHip();
        const toSvg = (p) => ({ x: p.x * 1000, y: p.y * 1000 });
        const hipSvg = toSvg(hip);
        const pLH = toSvg(getLimbPos('LH')), pRH = toSvg(getLimbPos('RH')), pLF = toSvg(getLimbPos('LF')), pRF = toSvg(getLimbPos('RF'));
        const setLine = (id, p) => {
          const line = document.getElementById(id);
          if (!line) return;
          line.setAttribute('x1', hipSvg.x); line.setAttribute('y1', hipSvg.y);
          line.setAttribute('x2', p.x);     line.setAttribute('y2', p.y);
        };
        setLine('bone-LH', pLH);
        setLine('bone-RH', pRH);
        setLine('bone-LF', pLF);
        setLine('bone-RF', pRF);
        const hipDot = document.getElementById('hip-dot');
        if (hipDot) { hipDot.setAttribute('cx', hipSvg.x); hipDot.setAttribute('cy', hipSvg.y); }
      }

      function highlightOptions() {
        if (!state.nodes?.length) return;
        const current = state.limbs[state.selected];
        state.nodes.forEach((node, idx) => {
          const el = node?.el; if (!el) return;
          if (idx === current) {
            el.classList.add('on-limb');
          } else {
            el.classList.remove('on-limb');
          }
          if (!state.finished && idx !== current && isAdjacent(current, idx) && canMove(state.selected, idx)) {
            el.classList.add('available');
          } else {
            el.classList.remove('available');
          }
        });
      }

      function resetRun() {
        state.finished = false;
        clearInterval(state.timerId);
        state.timerId = null;
        state.startedAt = 0;
        els.time.textContent = '0.00';
        state.limbs = { LH: 0, RH: 0, LF: 0, RF: 0 };
        updateLimbPositions();
      }

      function beginTimer() {
        clearInterval(state.timerId);
        state.finished = false;
        state.startedAt = performance.now();
        els.time.textContent = '0.00';
        state.timerId = setInterval(()=>{
          const elapsed = performance.now() - state.startedAt;
          els.time.textContent = formatMs(elapsed);
        }, 50);
      }

      function startRun() {
        resetRun();
        beginTimer();
      }

      function isAdjacent(i, j) {
        const a = route.holds[i], b = route.holds[j];
        if (!a || !b) return false;
        return dist(a, b) <= MAX_REACH; // roughly two grid steps of reach
      }

      async function finishRun() {
        clearInterval(state.timerId);
        state.timerId = null;
        state.finished = true;
        highlightOptions();
        const ms = Math.round(performance.now() - state.startedAt);
        els.time.textContent = formatMs(ms);
        vibrate([30,50,30]);
        await saveBest(ms);
      }

      function vibrate(pattern=15) {
        try { if (navigator.vibrate) navigator.vibrate(pattern); } catch {}
      }

      function getLimbPos(key, limbs = state.limbs) {
        const idx = limbs[key];
        return route.holds[idx];
      }

      function computeHip(limbs = state.limbs) {
        const pLH = getLimbPos('LH', limbs), pRH = getLimbPos('RH', limbs), pLF = getLimbPos('LF', limbs), pRF = getLimbPos('RF', limbs);
        const sx = (pLH.x + pRH.x + pLF.x + pRF.x) / 4;
        const sy = (pLH.y + pRH.y + pLF.y + pRF.y) / 4;
        return { x: sx, y: sy };
      }

      function withinReach(hip, pos, isHand) {
        const d = dist(hip, pos);
        return d <= (isHand ? ARM_MAX : LEG_MAX);
      }

      function canMove(key, nextIndex) {
        const limbs = { ...state.limbs, [key]: nextIndex };
        const pLH = getLimbPos('LH', limbs), pRH = getLimbPos('RH', limbs), pLF = getLimbPos('LF', limbs), pRF = getLimbPos('RF', limbs);
        // Left/right ordering to avoid crossing
        if (pLH.x > pRH.x) return false;
        if (pLF.x > pRF.x) return false;
        const hip = computeHip(limbs);
        // Hip reach constraints
        if (!withinReach(hip, pLH, true)) return false;
        if (!withinReach(hip, pRH, true)) return false;
        if (!withinReach(hip, pLF, false)) return false;
        if (!withinReach(hip, pRF, false)) return false;
        return true;
      }

      function tryMoveSelectedTo(nextIndex) {
        if (state.finished) return;
        const key = state.selected;
        const cur = state.limbs[key];
        if (!isAdjacent(cur, nextIndex)) return;
        if (!canMove(key, nextIndex)) { vibrate(40); return; }
        if (!state.startedAt) beginTimer();
        state.limbs[key] = nextIndex;
        updateLimbPositions(key);
        vibrate(12);
        spawnChalkAt(route.holds[nextIndex]);
        const last = route.holds.length - 1;
        if (state.limbs.LH === last && state.limbs.RH === last) finishRun();
      }

      function spawnChalkAt(pos) {
        const board = els.board;
        const count = 6 + Math.floor(Math.random()*4);
        for (let i=0;i<count;i++) {
          const dot = document.createElement('div');
          dot.className = 'chalk';
          const jitterX = (Math.random()-0.5)*18;
          const jitterY = (Math.random()-0.5)*10;
          dot.style.left = `calc(${pos.x*100}% + ${jitterX}px)`;
          dot.style.top  = `calc(${pos.y*100}% + ${jitterY}px)`;
          const dx = (Math.random()-0.5)*10 + 'px';
          const dy = (-8 - Math.random()*8) + 'px';
          dot.style.setProperty('--dx', dx);
          dot.style.setProperty('--dy', dy);
          board.appendChild(dot);
          setTimeout(()=> dot.remove(), 900);
        }
      }

      function nearestAdjacent(direction) {
        // direction: 'up' | 'down' | 'left' | 'right'
        const cur = route.holds[state.limbs[state.selected]];
        const candidates = route.holds.map((h, i) => ({...h, i}))
          .filter(o => o.i !== state.limbs[state.selected] && isAdjacent(state.limbs[state.selected], o.i));
        if (!candidates.length) return state.limbs[state.selected];

        const directional = candidates.filter(({x,y}) =>
          direction==='up' ? y < cur.y :
          direction==='down' ? y > cur.y :
          direction==='left' ? x < cur.x : x > cur.x
        );

        const pool = directional.length ? directional : candidates;
        const best = pool
          .map((candidate) => {
            const dx = candidate.x - cur.x;
            const dy = candidate.y - cur.y;
            const weight = direction==='up' || direction==='down'
              ? Math.abs(dx) * 0.7 + Math.abs(dy)
              : Math.abs(dy) * 0.7 + Math.abs(dx);
            return { candidate, weight };
          })
          .sort((a, b) => a.weight - b.weight)[0];

        return best ? best.candidate.i : state.limbs[state.selected];
      }

      function onKey(e) {
        if (state.finished) return;
        const selectMap = { '1':'LH', '2':'RH', '3':'LF', '4':'RF' };
        if (selectMap[e.key]) { selectLimb(selectMap[e.key]); e.preventDefault(); return; }
        const map = { ArrowUp:'up', ArrowDown:'down', ArrowLeft:'left', ArrowRight:'right' };
        const dir = map[e.key]; if (!dir) return;
        e.preventDefault();
        const next = nearestAdjacent(dir);
        if (next !== state.limbs[state.selected]) tryMoveSelectedTo(next);
      }

      function selectLimb(key) {
        state.selected = key;
        updateLimbPositions();
        // Button active styles
        for (const k of ['LH','RH','LF','RF']) {
          const b = k==='LH'?els.btnLH:k==='RH'?els.btnRH:k==='LF'?els.btnLF:els.btnRF;
          b.style.outline = state.selected===k ? '3px solid #5eead4' : 'none';
          b.style.filter = state.selected===k ? 'brightness(1.1)' : 'none';
        }
      }

      async function loadBest() {
        if (!state.user) return null;
        const { data, error } = await supabase
          .from('bouldering_scores')
          .select('time_ms')
          .eq('user_id', state.user.id)
          .eq('route', route.name)
          .limit(1);
        if (error) console.error('Best load error:', error.message);
        return Array.isArray(data) && data[0] ? data[0].time_ms : null;
      }

      async function saveBest(ms) {
        if (!state.user) return;
        const { data: existingRows, error: readError } = await supabase
          .from('bouldering_scores')
          .select('time_ms')
          .eq('user_id', state.user.id)
          .eq('route', route.name)
          .limit(1);

        if (readError && readError.code !== 'PGRST116') {
          console.error('Score read error:', readError.message);
          return;
        }

        const existing = existingRows?.[0];
        const nextBest = existing?.time_ms != null ? Math.min(existing.time_ms, ms) : ms;

        if (!existing) {
          const { error: insertError } = await supabase
            .from('bouldering_scores')
            .insert({ user_id: state.user.id, route: route.name, time_ms: nextBest });
          if (insertError) {
            console.error('Save insert error:', insertError.message);
            return;
          }
        } else if (nextBest < existing.time_ms) {
          const { error: updateError } = await supabase
            .from('bouldering_scores')
            .update({ time_ms: nextBest })
            .eq('user_id', state.user.id)
            .eq('route', route.name);
          if (updateError) {
            console.error('Save update error:', updateError.message);
            return;
          }
        }

        state.bestMs = state.bestMs == null ? nextBest : Math.min(state.bestMs, nextBest);
        els.best.textContent = `${formatMs(state.bestMs)}s`;
        refreshLeaders();
      }

      async function refreshLeaders() {
        const { data, error } = await supabase
          .from('bouldering_scores')
          .select('time_ms, user_id')
          .eq('route', route.name)
          .order('time_ms', { ascending: true })
          .limit(10);
        if (error) {
          console.error('Leaders error:', error.message);
          els.leaders.innerHTML = '<li class="muted">Failed to load leaderboard. Please retry.</li>';
          return;
        }
        const rows = data || [];
        const ids = rows.map((r) => r.user_id).filter(Boolean);
        const nameLookup = {};

        if (ids.length) {
          const { data: profiles, error: profileError } = await supabase
            .from('users')
            .select('user_id, display_name, twitter_handle')
            .in('user_id', ids);
          if (profileError) {
            console.error('Leader profile error:', profileError.message);
          } else {
            for (const profile of profiles) {
              const displayName = profile.display_name?.trim();
              const twitter = profile.twitter_handle?.trim();
              const handle = twitter ? (twitter.startsWith('@') ? twitter : `@${twitter}`) : '';
              const label = displayName || handle;
              if (label) nameLookup[profile.user_id] = label;
            }
          }
        }

        els.leaders.innerHTML = rows
          .map((r, i) => {
            const fallback = `…${String(r.user_id ?? '').slice(-6)}`;
            const label = nameLookup[r.user_id] || fallback;
            const timeLabel = r.time_ms == null ? '—' : `${formatMs(r.time_ms)}s`;
            return `<li>#${i + 1} <strong>${escapeHtml(timeLabel)}</strong> — ${escapeHtml(label)}</li>`;
          })
          .join('');
      }

      async function init() {
        window.addEventListener('resize', () => {
          placeHolds();
          updateLimbPositions();
        });
        document.addEventListener('keydown', onKey);
        els.start.addEventListener('click', startRun);
        placeHolds();
        updateLimbPositions();
        selectLimb('LH');

        const { session, user } = await supabaseSession();
        state.session = session; state.user = user;
        els.auth.textContent = `Signed in: …${String(user.id).slice(-6)}`;
        els.signout.style.display = 'inline-block';
        els.signout.onclick = async ()=>{ await supabase.auth.signOut(); location.reload(); };
        els.btnLH.onclick = () => selectLimb('LH');
        els.btnRH.onclick = () => selectLimb('RH');
        els.btnLF.onclick = () => selectLimb('LF');
        els.btnRF.onclick = () => selectLimb('RF');
        const dpad = [
          ['up', els.btnUp],
          ['down', els.btnDown],
          ['left', els.btnLeft],
          ['right', els.btnRight],
        ];
        for (const [dir, btn] of dpad) {
          const handler = (e) => {
            e.preventDefault();
            e.stopPropagation();
            const next = nearestAdjacent(dir);
            if (next !== state.limbs[state.selected]) tryMoveSelectedTo(next);
          };
          btn.addEventListener('click', handler);
          btn.addEventListener('touchstart', handler, { passive: false });
        }
        els.signin.style.display = 'none';

        state.bestMs = await loadBest();
        els.best.textContent = state.bestMs == null ? '—' : `${formatMs(state.bestMs)}s`;
        refreshLeaders();

        supabase
          .channel('bouldering_scores')
          .on('postgres_changes', { event: '*', schema: 'public', table: 'bouldering_scores' }, refreshLeaders)
          .subscribe();
      }

      init().catch(err => { console.error(err); els.auth.textContent = 'Auth error'; });
    </script>
  </body>
</html>
