<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
  <title>Bug Zap - Arcade Shooter</title>
  <link rel="icon" href="https://emojicdn.elk.sh/☕">
  <meta property="og:title" content="Bug Zap">
  <meta property="og:description" content="Blast undefined and NaN bugs with your coffee cup ship!">
  <meta property="og:url" content="https://app.sloppy.live/bug-zap">
  <meta property="og:image" content="https://emojicdn.elk.sh/☕?style=apple&size=512">
  <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&family=Share+Tech+Mono&display=swap" rel="stylesheet">
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }

    :root {
      --neon-cyan: #00ffff;
      --neon-magenta: #ff00ff;
      --neon-green: #00ff88;
      --neon-yellow: #ffff00;
      --neon-orange: #ff6600;
      --neon-red: #ff0044;
      --bg-dark: #0a0a15;
    }

    body {
      background: var(--bg-dark);
      font-family: 'Press Start 2P', monospace;
      min-height: 100vh;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      overflow: hidden;
      touch-action: none;
    }

    .game-container {
      position: relative;
      border: 3px solid var(--neon-cyan);
      box-shadow: 0 0 30px rgba(0, 255, 255, 0.3), inset 0 0 30px rgba(0, 255, 255, 0.1);
      border-radius: 5px;
    }

    canvas {
      display: block;
      background: linear-gradient(180deg, #0a0a15 0%, #0f1020 50%, #0a0a15 100%);
    }

    .hud {
      position: absolute;
      top: 10px;
      left: 10px;
      right: 10px;
      display: flex;
      justify-content: space-between;
      pointer-events: none;
      z-index: 10;
    }

    .hud-item {
      font-size: 12px;
      color: var(--neon-cyan);
      text-shadow: 0 0 10px var(--neon-cyan);
    }

    .score { color: var(--neon-yellow); text-shadow: 0 0 10px var(--neon-yellow); }
    .lives { color: var(--neon-magenta); text-shadow: 0 0 10px var(--neon-magenta); }
    .wave { color: var(--neon-green); text-shadow: 0 0 10px var(--neon-green); }

    .overlay {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      background: rgba(10, 10, 21, 0.9);
      z-index: 20;
    }

    .overlay.hidden { display: none; }

    .title {
      font-size: clamp(24px, 6vw, 48px);
      color: var(--neon-cyan);
      text-shadow: 0 0 20px var(--neon-cyan), 0 0 40px var(--neon-cyan);
      margin-bottom: 10px;
      animation: pulse 2s ease-in-out infinite;
    }

    @keyframes pulse {
      0%, 100% { text-shadow: 0 0 20px var(--neon-cyan), 0 0 40px var(--neon-cyan); }
      50% { text-shadow: 0 0 30px var(--neon-cyan), 0 0 60px var(--neon-cyan), 0 0 80px var(--neon-magenta); }
    }

    .subtitle {
      font-family: 'Share Tech Mono', monospace;
      font-size: clamp(10px, 2.5vw, 14px);
      color: var(--neon-magenta);
      margin-bottom: 30px;
      text-align: center;
      padding: 0 20px;
    }

    .start-btn {
      font-family: 'Press Start 2P', monospace;
      font-size: clamp(12px, 3vw, 16px);
      padding: 15px 30px;
      background: transparent;
      border: 2px solid var(--neon-green);
      color: var(--neon-green);
      cursor: pointer;
      text-shadow: 0 0 10px var(--neon-green);
      box-shadow: 0 0 20px rgba(0, 255, 136, 0.3);
      transition: all 0.3s;
    }

    .start-btn:hover {
      background: rgba(0, 255, 136, 0.2);
      box-shadow: 0 0 40px rgba(0, 255, 136, 0.5);
      transform: scale(1.05);
    }

    .controls-info {
      margin-top: 30px;
      font-family: 'Share Tech Mono', monospace;
      font-size: 10px;
      color: rgba(255, 255, 255, 0.5);
      text-align: center;
      line-height: 1.8;
    }

    .game-over-score {
      font-size: 18px;
      color: var(--neon-yellow);
      margin: 20px 0;
      text-shadow: 0 0 15px var(--neon-yellow);
    }

    .mobile-controls {
      display: none;
      position: fixed;
      bottom: 20px;
      left: 0;
      right: 0;
      justify-content: space-between;
      padding: 0 20px;
      z-index: 100;
    }

    .mobile-btn {
      width: 70px;
      height: 70px;
      background: rgba(0, 255, 255, 0.15);
      border: 2px solid var(--neon-cyan);
      border-radius: 50%;
      color: var(--neon-cyan);
      font-size: 24px;
      display: flex;
      align-items: center;
      justify-content: center;
      user-select: none;
      -webkit-user-select: none;
      touch-action: manipulation;
    }

    .mobile-btn:active {
      background: rgba(0, 255, 255, 0.4);
    }

    .move-btns {
      display: flex;
      gap: 10px;
    }

    .fire-btn {
      background: rgba(255, 0, 255, 0.2);
      border-color: var(--neon-magenta);
      color: var(--neon-magenta);
      width: 90px;
      height: 90px;
      font-size: 12px;
      font-family: 'Press Start 2P', monospace;
    }

    .fire-btn:active {
      background: rgba(255, 0, 255, 0.5);
    }

    @media (max-width: 768px) {
      .mobile-controls { display: flex; }
    }

    .backlink {
      position: fixed;
      bottom: 10px;
      right: 10px;
      font-family: 'Share Tech Mono', monospace;
      font-size: 10px;
      color: rgba(255, 255, 255, 0.3);
      text-decoration: none;
      z-index: 1000;
    }
    .backlink:hover { color: var(--neon-cyan); }

    .scanlines {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
      background: repeating-linear-gradient(
        0deg,
        rgba(0, 0, 0, 0.1) 0px,
        rgba(0, 0, 0, 0.1) 1px,
        transparent 1px,
        transparent 2px
      );
      z-index: 5;
    }
  </style>
</head>
<body>
  <div class="game-container">
    <canvas id="game"></canvas>
    <div class="scanlines"></div>
    <div class="hud">
      <div class="hud-item score" id="score-display">SCORE: 0</div>
      <div class="hud-item wave" id="wave-display">WAVE 1</div>
      <div class="hud-item lives" id="lives-display">☕☕☕</div>
    </div>
    <div class="overlay" id="start-overlay">
      <div class="title">BUG ZAP</div>
      <div class="subtitle">// EXTERMINATE undefined AND NaN WITH SEMICOLONS //</div>
      <button class="start-btn" id="start-btn">START GAME</button>
      <div class="controls-info">
        ARROWS or WASD to move<br>
        SPACE to fire semicolons<br>
        Destroy all bugs to advance!
      </div>
    </div>
    <div class="overlay hidden" id="gameover-overlay">
      <div class="title" style="color: var(--neon-red); text-shadow: 0 0 20px var(--neon-red);">GAME OVER</div>
      <div class="subtitle">Your code has too many bugs!</div>
      <div class="game-over-score" id="final-score">SCORE: 0</div>
      <button class="start-btn" id="restart-btn">TRY AGAIN</button>
    </div>
  </div>

  <div class="mobile-controls" id="mobile-controls">
    <div class="move-btns">
      <button class="mobile-btn" id="btn-left">◀</button>
      <button class="mobile-btn" id="btn-right">▶</button>
    </div>
    <button class="mobile-btn fire-btn" id="btn-fire">FIRE;</button>
  </div>

  <a href="https://sloppy.live" class="backlink">sloppy.live</a>

  <script>
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');

    // Responsive canvas sizing
    function resizeCanvas() {
      const maxW = Math.min(800, window.innerWidth - 20);
      const maxH = Math.min(600, window.innerHeight - 150);
      canvas.width = maxW;
      canvas.height = maxH;
    }
    resizeCanvas();
    window.addEventListener('resize', resizeCanvas);

    // Game state
    let gameState = 'start'; // start, playing, gameover
    let score = 0;
    let lives = 3;
    let wave = 1;
    let lastTime = 0;

    // Player (coffee cup ship)
    const player = {
      x: 0,
      y: 0,
      width: 50,
      height: 60,
      speed: 300,
      fireRate: 200,
      lastFire: 0
    };

    // Input state
    const keys = { left: false, right: false, up: false, down: false, fire: false };

    // Game objects
    let bullets = [];
    let enemies = [];
    let particles = [];
    let powerups = [];
    let enemyBullets = [];

    // Enemy types
    const enemyTypes = [
      { text: 'undefined', color: '#ff6600', points: 10, health: 1, speed: 50 },
      { text: 'NaN', color: '#ff00ff', points: 15, health: 1, speed: 60 },
      { text: 'null', color: '#00ffff', points: 20, health: 2, speed: 40 },
      { text: 'error', color: '#ff0044', points: 25, health: 2, speed: 70 },
      { text: '[object]', color: '#ffff00', points: 30, health: 3, speed: 35 }
    ];

    // Draw coffee cup ship
    function drawPlayer() {
      ctx.save();
      ctx.translate(player.x, player.y);

      // Glow effect
      ctx.shadowBlur = 20;
      ctx.shadowColor = '#00ffff';

      // Cup body
      ctx.fillStyle = '#ffffff';
      ctx.beginPath();
      ctx.moveTo(-20, -10);
      ctx.lineTo(-15, 25);
      ctx.lineTo(15, 25);
      ctx.lineTo(20, -10);
      ctx.closePath();
      ctx.fill();

      // Cup rim
      ctx.fillStyle = '#00ffff';
      ctx.fillRect(-22, -15, 44, 8);

      // Handle
      ctx.strokeStyle = '#ffffff';
      ctx.lineWidth = 4;
      ctx.beginPath();
      ctx.arc(25, 5, 12, -Math.PI/2, Math.PI/2);
      ctx.stroke();

      // Coffee inside
      ctx.fillStyle = '#4a2c0a';
      ctx.fillRect(-17, -8, 34, 15);

      // Steam (animated)
      ctx.strokeStyle = 'rgba(255, 255, 255, 0.6)';
      ctx.lineWidth = 2;
      const time = Date.now() / 200;
      for (let i = 0; i < 3; i++) {
        ctx.beginPath();
        const sx = -10 + i * 10;
        ctx.moveTo(sx, -18);
        ctx.quadraticCurveTo(
          sx + Math.sin(time + i) * 5, -28,
          sx + Math.sin(time + i + 1) * 3, -35
        );
        ctx.stroke();
      }

      // Semicolon cannon
      ctx.fillStyle = '#ff00ff';
      ctx.shadowColor = '#ff00ff';
      ctx.font = 'bold 16px Share Tech Mono';
      ctx.textAlign = 'center';
      ctx.fillText(';', 0, -20);

      ctx.restore();
    }

    // Draw semicolon bullet
    function drawBullet(bullet) {
      ctx.save();
      ctx.translate(bullet.x, bullet.y);

      ctx.shadowBlur = 15;
      ctx.shadowColor = '#ff00ff';
      ctx.fillStyle = '#ff00ff';
      ctx.font = 'bold 20px Share Tech Mono';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillText(';', 0, 0);

      ctx.restore();
    }

    // Draw enemy
    function drawEnemy(enemy) {
      ctx.save();
      ctx.translate(enemy.x, enemy.y);

      // Drift rotation
      ctx.rotate(Math.sin(Date.now() / 500 + enemy.phase) * 0.2);

      // Glow
      ctx.shadowBlur = 20;
      ctx.shadowColor = enemy.color;

      // Bug body (glitchy rectangle)
      ctx.fillStyle = enemy.color;
      ctx.globalAlpha = 0.3;
      ctx.fillRect(-enemy.width/2 - 5, -enemy.height/2 - 5, enemy.width + 10, enemy.height + 10);

      ctx.globalAlpha = 1;

      // Glitch effect
      if (Math.random() < 0.1) {
        ctx.fillStyle = '#ffffff';
        ctx.fillRect(
          -enemy.width/2 + Math.random() * enemy.width,
          -enemy.height/2,
          Math.random() * 20,
          2
        );
      }

      // Text
      ctx.fillStyle = enemy.color;
      ctx.font = `bold ${enemy.fontSize || 16}px Share Tech Mono`;
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillText(enemy.text, 0, 0);

      // Health indicator
      if (enemy.maxHealth > 1) {
        ctx.fillStyle = '#00ff88';
        const healthWidth = (enemy.health / enemy.maxHealth) * enemy.width;
        ctx.fillRect(-enemy.width/2, enemy.height/2 + 5, healthWidth, 3);
      }

      ctx.restore();
    }

    // Draw particle
    function drawParticle(p) {
      ctx.save();
      ctx.globalAlpha = p.life;
      ctx.fillStyle = p.color;
      ctx.shadowBlur = 10;
      ctx.shadowColor = p.color;

      if (p.text) {
        ctx.font = `${p.size}px Share Tech Mono`;
        ctx.textAlign = 'center';
        ctx.fillText(p.text, p.x, p.y);
      } else {
        ctx.beginPath();
        ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
        ctx.fill();
      }

      ctx.restore();
    }

    // Spawn enemies for wave
    function spawnWave() {
      const enemyCount = 5 + wave * 2;
      const types = enemyTypes.slice(0, Math.min(wave, enemyTypes.length));

      for (let i = 0; i < enemyCount; i++) {
        const type = types[Math.floor(Math.random() * types.length)];
        const enemy = {
          x: Math.random() * (canvas.width - 100) + 50,
          y: -50 - Math.random() * 200,
          width: ctx.measureText(type.text).width || type.text.length * 10,
          height: 20,
          vx: (Math.random() - 0.5) * type.speed,
          vy: type.speed * 0.5 + Math.random() * 30,
          text: type.text,
          color: type.color,
          points: type.points,
          health: type.health + Math.floor(wave / 3),
          maxHealth: type.health + Math.floor(wave / 3),
          phase: Math.random() * Math.PI * 2,
          fontSize: 14 + Math.floor(Math.random() * 6)
        };
        enemy.width = enemy.text.length * (enemy.fontSize * 0.6);
        enemies.push(enemy);
      }
    }

    // Create explosion particles
    function createExplosion(x, y, color, text) {
      // Text fragments
      const chars = text.split('');
      chars.forEach((char, i) => {
        particles.push({
          x: x + (i - chars.length/2) * 10,
          y: y,
          vx: (Math.random() - 0.5) * 150,
          vy: (Math.random() - 0.5) * 150,
          life: 1,
          decay: 0.02,
          color: color,
          text: char,
          size: 14
        });
      });

      // Sparks
      for (let i = 0; i < 10; i++) {
        particles.push({
          x: x,
          y: y,
          vx: (Math.random() - 0.5) * 200,
          vy: (Math.random() - 0.5) * 200,
          life: 1,
          decay: 0.03,
          color: color,
          size: 3 + Math.random() * 3
        });
      }
    }

    // Fire bullet
    function fireBullet() {
      const now = Date.now();
      if (now - player.lastFire < player.fireRate) return;

      player.lastFire = now;
      bullets.push({
        x: player.x,
        y: player.y - 35,
        vy: -500
      });

      // Muzzle flash particles
      for (let i = 0; i < 3; i++) {
        particles.push({
          x: player.x,
          y: player.y - 30,
          vx: (Math.random() - 0.5) * 50,
          vy: -100 - Math.random() * 50,
          life: 1,
          decay: 0.1,
          color: '#ff00ff',
          size: 2
        });
      }
    }

    // Update game
    function update(dt) {
      if (gameState !== 'playing') return;

      // Player movement
      if (keys.left) player.x -= player.speed * dt;
      if (keys.right) player.x += player.speed * dt;
      if (keys.up) player.y -= player.speed * dt;
      if (keys.down) player.y += player.speed * dt;

      // Clamp player position
      player.x = Math.max(30, Math.min(canvas.width - 30, player.x));
      player.y = Math.max(50, Math.min(canvas.height - 40, player.y));

      // Fire
      if (keys.fire) fireBullet();

      // Update bullets
      bullets.forEach(b => b.y += b.vy * dt);
      bullets = bullets.filter(b => b.y > -20);

      // Update enemies
      enemies.forEach(enemy => {
        enemy.x += enemy.vx * dt;
        enemy.y += enemy.vy * dt;

        // Bounce off walls
        if (enemy.x < 30 || enemy.x > canvas.width - 30) {
          enemy.vx *= -1;
          enemy.x = Math.max(30, Math.min(canvas.width - 30, enemy.x));
        }

        // Drift effect
        enemy.vx += (Math.random() - 0.5) * 20 * dt;
        enemy.vx = Math.max(-100, Math.min(100, enemy.vx));
      });

      // Remove enemies that go off screen (and damage player)
      enemies = enemies.filter(enemy => {
        if (enemy.y > canvas.height + 50) {
          lives--;
          updateHUD();
          if (lives <= 0) gameOver();
          return false;
        }
        return true;
      });

      // Bullet-enemy collision
      bullets.forEach((bullet, bi) => {
        enemies.forEach((enemy, ei) => {
          const dx = bullet.x - enemy.x;
          const dy = bullet.y - enemy.y;
          if (Math.abs(dx) < enemy.width/2 + 10 && Math.abs(dy) < enemy.height/2 + 10) {
            enemy.health--;
            bullets.splice(bi, 1);

            if (enemy.health <= 0) {
              score += enemy.points * wave;
              createExplosion(enemy.x, enemy.y, enemy.color, enemy.text);
              enemies.splice(ei, 1);
              updateHUD();
            } else {
              // Hit particles
              for (let i = 0; i < 5; i++) {
                particles.push({
                  x: bullet.x,
                  y: bullet.y,
                  vx: (Math.random() - 0.5) * 100,
                  vy: (Math.random() - 0.5) * 100,
                  life: 1,
                  decay: 0.05,
                  color: '#ffffff',
                  size: 2
                });
              }
            }
          }
        });
      });

      // Player-enemy collision
      enemies.forEach((enemy, ei) => {
        const dx = player.x - enemy.x;
        const dy = player.y - enemy.y;
        if (Math.abs(dx) < 30 && Math.abs(dy) < 30) {
          lives--;
          createExplosion(player.x, player.y, '#00ffff', '☕');
          enemies.splice(ei, 1);
          updateHUD();
          if (lives <= 0) gameOver();
        }
      });

      // Update particles
      particles.forEach(p => {
        p.x += p.vx * dt;
        p.y += p.vy * dt;
        p.life -= p.decay;
      });
      particles = particles.filter(p => p.life > 0);

      // Check wave complete
      if (enemies.length === 0) {
        wave++;
        updateHUD();
        spawnWave();
      }
    }

    // Draw game
    function draw() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);

      // Grid background
      ctx.strokeStyle = 'rgba(0, 255, 255, 0.1)';
      ctx.lineWidth = 1;
      const gridSize = 40;
      for (let x = 0; x < canvas.width; x += gridSize) {
        ctx.beginPath();
        ctx.moveTo(x, 0);
        ctx.lineTo(x, canvas.height);
        ctx.stroke();
      }
      for (let y = 0; y < canvas.height; y += gridSize) {
        ctx.beginPath();
        ctx.moveTo(0, y);
        ctx.lineTo(canvas.width, y);
        ctx.stroke();
      }

      if (gameState === 'playing') {
        // Draw enemies
        enemies.forEach(drawEnemy);

        // Draw bullets
        bullets.forEach(drawBullet);

        // Draw particles
        particles.forEach(drawParticle);

        // Draw player
        drawPlayer();
      }
    }

    // Game loop
    function gameLoop(timestamp) {
      const dt = Math.min((timestamp - lastTime) / 1000, 0.05);
      lastTime = timestamp;

      update(dt);
      draw();

      requestAnimationFrame(gameLoop);
    }

    // Update HUD
    function updateHUD() {
      document.getElementById('score-display').textContent = `SCORE: ${score}`;
      document.getElementById('wave-display').textContent = `WAVE ${wave}`;
      document.getElementById('lives-display').textContent = '☕'.repeat(Math.max(0, lives));
    }

    // Start game
    function startGame() {
      gameState = 'playing';
      score = 0;
      lives = 3;
      wave = 1;
      bullets = [];
      enemies = [];
      particles = [];

      player.x = canvas.width / 2;
      player.y = canvas.height - 60;

      document.getElementById('start-overlay').classList.add('hidden');
      document.getElementById('gameover-overlay').classList.add('hidden');

      updateHUD();
      spawnWave();
    }

    // Game over
    function gameOver() {
      gameState = 'gameover';
      document.getElementById('final-score').textContent = `SCORE: ${score}`;
      document.getElementById('gameover-overlay').classList.remove('hidden');
    }

    // Event listeners
    document.getElementById('start-btn').addEventListener('click', startGame);
    document.getElementById('restart-btn').addEventListener('click', startGame);

    // Keyboard controls
    document.addEventListener('keydown', e => {
      if (e.key === 'ArrowLeft' || e.key === 'a' || e.key === 'A') keys.left = true;
      if (e.key === 'ArrowRight' || e.key === 'd' || e.key === 'D') keys.right = true;
      if (e.key === 'ArrowUp' || e.key === 'w' || e.key === 'W') keys.up = true;
      if (e.key === 'ArrowDown' || e.key === 's' || e.key === 'S') keys.down = true;
      if (e.key === ' ') { keys.fire = true; e.preventDefault(); }
    });

    document.addEventListener('keyup', e => {
      if (e.key === 'ArrowLeft' || e.key === 'a' || e.key === 'A') keys.left = false;
      if (e.key === 'ArrowRight' || e.key === 'd' || e.key === 'D') keys.right = false;
      if (e.key === 'ArrowUp' || e.key === 'w' || e.key === 'W') keys.up = false;
      if (e.key === 'ArrowDown' || e.key === 's' || e.key === 'S') keys.down = false;
      if (e.key === ' ') keys.fire = false;
    });

    // Mobile controls
    function setupMobileBtn(id, key) {
      const btn = document.getElementById(id);
      const start = () => keys[key] = true;
      const end = () => keys[key] = false;

      btn.addEventListener('touchstart', e => { e.preventDefault(); start(); });
      btn.addEventListener('touchend', e => { e.preventDefault(); end(); });
      btn.addEventListener('mousedown', start);
      btn.addEventListener('mouseup', end);
      btn.addEventListener('mouseleave', end);
    }

    setupMobileBtn('btn-left', 'left');
    setupMobileBtn('btn-right', 'right');
    setupMobileBtn('btn-fire', 'fire');

    // Prevent scrolling on mobile
    document.body.addEventListener('touchmove', e => e.preventDefault(), { passive: false });

    // Start game loop
    requestAnimationFrame(gameLoop);
  </script>
<script src="/sloppy-header/sloppy-bar.js"></script>
<script src="/vibelib-extended.js"></script>
<script>
  // Compatibility Patch for Legacy Apps
  window.addEventListener("load", () => {
    if (window.SloppyKarma && window.VibeLib.Economy) {
      // Redirect old calls to new engine
      window.SloppyKarma.track = window.VibeLib.Economy.track;
    }
  });
</script>
</body>
</html>
