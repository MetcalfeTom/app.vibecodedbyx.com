<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
  <title>Stormy Seas Dash</title>
  <meta property="og:title" content="Stormy Seas Dash">
  <meta property="og:description" content="Jump the waves! Don't sink! Pirate runner.">
  <meta property="og:url" content="https://sloppy.live/geometry-dash">
  <meta property="og:image" content="https://emojicdn.elk.sh/‚õµ?style=apple&size=512">
  <link rel="icon" href="https://emojicdn.elk.sh/üåä">
  <link href="https://fonts.googleapis.com/css2?family=Pirata+One&family=Orbitron:wght@400;700;900&display=swap" rel="stylesheet">
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      min-height: 100vh;
      background: #0a0a12;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      font-family: 'Orbitron', sans-serif;
      overflow: hidden;
      touch-action: manipulation;
    }
    .game-container {
      position: relative;
      width: 100vw;
      height: 100vh;
      max-width: 900px;
      max-height: 600px;
    }
    canvas {
      display: block;
      width: 100%;
      height: 100%;
      cursor: pointer;
    }
    .hud {
      position: absolute;
      top: 15px;
      left: 20px;
      right: 20px;
      display: flex;
      justify-content: space-between;
      pointer-events: none;
      z-index: 10;
    }
    .score {
      font-size: 1.5rem;
      color: #d4a84b;
      text-shadow: 0 0 10px #d4a84b, 0 0 20px #d4a84b;
    }
    .best {
      font-size: 0.9rem;
      color: #4ecdc4;
      text-shadow: 0 0 10px #4ecdc4;
    }
    .overlay {
      position: absolute;
      inset: 0;
      background: rgba(10, 10, 18, 0.95);
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      z-index: 100;
      transition: opacity 0.3s;
    }
    .overlay.hidden {
      opacity: 0;
      pointer-events: none;
    }
    .title {
      font-family: 'Pirata One', cursive;
      font-size: 3rem;
      font-weight: 400;
      color: #d4a84b;
      text-shadow: 0 0 20px #d4a84b, 0 0 40px #8b6914, 2px 2px 4px #000;
      margin-bottom: 10px;
      letter-spacing: 0.05em;
    }
    .subtitle {
      font-size: 0.9rem;
      color: #4ecdc4;
      text-shadow: 0 0 10px #4ecdc4;
      margin-bottom: 30px;
    }
    .start-btn {
      font-family: 'Pirata One', cursive;
      font-size: 1.2rem;
      font-weight: 400;
      padding: 15px 50px;
      background: transparent;
      border: 2px solid #d4a84b;
      color: #d4a84b;
      cursor: pointer;
      letter-spacing: 0.1em;
      transition: all 0.2s;
      text-shadow: 0 0 10px #d4a84b;
      box-shadow: 0 0 20px rgba(212, 168, 75, 0.3);
    }
    .start-btn:hover {
      background: #d4a84b;
      color: #0a0a12;
      box-shadow: 0 0 40px rgba(212, 168, 75, 0.6);
    }
    .death-overlay {
      background: rgba(20, 10, 5, 0.95);
    }
    .death-title {
      font-family: 'Pirata One', cursive;
      font-size: 2.5rem;
      color: #c0392b;
      text-shadow: 0 0 20px #c0392b, 0 0 40px #922b21;
      margin-bottom: 15px;
    }
    .death-score {
      font-size: 1.2rem;
      color: #d4a84b;
      margin-bottom: 5px;
    }
    .death-best {
      font-size: 0.9rem;
      color: #4ecdc4;
      margin-bottom: 25px;
    }
    .instructions {
      position: absolute;
      bottom: 15px;
      left: 50%;
      transform: translateX(-50%);
      font-size: 0.7rem;
      color: #444;
    }
    .back-link {
      position: fixed;
      bottom: 5px;
      right: 10px;
      color: #222;
      text-decoration: none;
      font-size: 0.6rem;
      z-index: 5;
    }
    .back-link:hover { color: #444; }
  </style>
</head>
<body>
  <div class="game-container">
    <canvas id="game"></canvas>
    <div class="hud">
      <div class="score" id="score">0</div>
      <div class="best" id="best">BEST: 0</div>
    </div>
    <div class="overlay" id="startOverlay">
      <div class="title">‚ò†Ô∏è STORMY SEAS ‚ò†Ô∏è</div>
      <div class="subtitle">Tap or Space to Sail!</div>
      <button class="start-btn" id="startBtn">SET SAIL</button>
      <div class="instructions">Click / Tap / Space to jump</div>
    </div>
    <div class="overlay death-overlay hidden" id="deathOverlay">
      <div class="death-title">YE SANK!</div>
      <div class="death-score" id="deathScore">Score: 0</div>
      <div class="death-best" id="deathBest">Best: 0</div>
      <button class="start-btn" id="restartBtn">SAIL AGAIN</button>
    </div>
  </div>
  <a href="https://sloppy.live" class="back-link">sloppy.live</a>

<script>
const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d');

// Game constants
const GRAVITY = 0.8;
const JUMP_FORCE = -14;
const GROUND_Y = 0.75; // percentage of canvas height
const SCROLL_SPEED = 7;
const PLAYER_SIZE = 40;

// Game state
let gameRunning = false;
let score = 0;
let bestScore = parseInt(localStorage.getItem('stormySeasBest')) || 0;
let frameCount = 0;

// Player
let player = {
  x: 100,
  y: 0,
  vy: 0,
  rotation: 0,
  rotationSpeed: 0,
  onGround: true,
  size: PLAYER_SIZE
};

// Obstacles and ground
let obstacles = [];
let groundTiles = [];
let particles = [];
let bgPulse = 0;

// Pirate Colors
const NEON_CYAN = '#4ecdc4';    // Teal sea
const NEON_PINK = '#c0392b';    // Blood red
const NEON_BLUE = '#2c3e50';    // Dark sea
const NEON_YELLOW = '#d4a84b';  // Gold

function resize() {
  const container = canvas.parentElement;
  canvas.width = container.clientWidth;
  canvas.height = container.clientHeight;
  player.y = canvas.height * GROUND_Y - player.size;
}

function resetGame() {
  player.x = 100;
  player.y = canvas.height * GROUND_Y - player.size;
  player.vy = 0;
  player.rotation = 0;
  player.rotationSpeed = 0;
  player.onGround = true;

  obstacles = [];
  groundTiles = [];
  particles = [];
  score = 0;
  frameCount = 0;

  // Initialize ground
  for (let x = 0; x < canvas.width + 100; x += 50) {
    groundTiles.push({ x });
  }

  // Initial obstacles
  spawnObstacle(canvas.width + 200);
  spawnObstacle(canvas.width + 500);
  spawnObstacle(canvas.width + 800);
}

function spawnObstacle(x) {
  const types = ['spike', 'spike', 'spike', 'double', 'triple', 'block'];
  const type = types[Math.floor(Math.random() * types.length)];

  if (type === 'spike') {
    obstacles.push({ x, type: 'spike', width: 40, height: 40 });
  } else if (type === 'double') {
    obstacles.push({ x, type: 'spike', width: 40, height: 40 });
    obstacles.push({ x: x + 50, type: 'spike', width: 40, height: 40 });
  } else if (type === 'triple') {
    obstacles.push({ x, type: 'spike', width: 40, height: 40 });
    obstacles.push({ x: x + 50, type: 'spike', width: 40, height: 40 });
    obstacles.push({ x: x + 100, type: 'spike', width: 40, height: 40 });
  } else if (type === 'block') {
    obstacles.push({ x, type: 'block', width: 50, height: 50 });
  }
}

function jump() {
  if (!gameRunning) return;
  if (player.onGround) {
    player.vy = JUMP_FORCE;
    player.onGround = false;
    player.rotationSpeed = 0.15;
    spawnJumpParticles();
  }
}

function spawnJumpParticles() {
  for (let i = 0; i < 8; i++) {
    particles.push({
      x: player.x + player.size / 2,
      y: player.y + player.size,
      vx: (Math.random() - 0.5) * 6,
      vy: Math.random() * 3 + 1,
      size: 3 + Math.random() * 4,
      color: NEON_CYAN,
      alpha: 1,
      decay: 0.03
    });
  }
}

function spawnDeathParticles() {
  for (let i = 0; i < 30; i++) {
    const angle = Math.random() * Math.PI * 2;
    const speed = 3 + Math.random() * 8;
    particles.push({
      x: player.x + player.size / 2,
      y: player.y + player.size / 2,
      vx: Math.cos(angle) * speed,
      vy: Math.sin(angle) * speed,
      size: 4 + Math.random() * 8,
      color: Math.random() > 0.5 ? NEON_PINK : '#f44',
      alpha: 1,
      decay: 0.02
    });
  }
}

function updateParticles() {
  for (let i = particles.length - 1; i >= 0; i--) {
    const p = particles[i];
    p.x += p.vx;
    p.y += p.vy;
    p.vy += 0.2;
    p.alpha -= p.decay;
    if (p.alpha <= 0) particles.splice(i, 1);
  }
}

function checkCollision(obs) {
  const groundY = canvas.height * GROUND_Y;

  if (obs.type === 'spike') {
    // Triangle collision (approximate)
    const spikeX = obs.x + obs.width / 2;
    const spikeTop = groundY - obs.height;
    const spikeLeft = obs.x;
    const spikeRight = obs.x + obs.width;

    const playerRight = player.x + player.size * 0.8;
    const playerLeft = player.x + player.size * 0.2;
    const playerBottom = player.y + player.size;
    const playerTop = player.y + player.size * 0.2;

    // Simple box collision with smaller hitbox
    if (playerRight > spikeLeft + 8 &&
        playerLeft < spikeRight - 8 &&
        playerBottom > spikeTop + 8 &&
        playerTop < groundY) {
      return true;
    }
  } else if (obs.type === 'block') {
    const blockTop = groundY - obs.height;
    const playerRight = player.x + player.size * 0.8;
    const playerLeft = player.x + player.size * 0.2;
    const playerBottom = player.y + player.size;

    if (playerRight > obs.x + 5 &&
        playerLeft < obs.x + obs.width - 5 &&
        playerBottom > blockTop + 5) {
      return true;
    }
  }
  return false;
}

function update() {
  if (!gameRunning) return;

  frameCount++;
  score = Math.floor(frameCount / 5);
  document.getElementById('score').textContent = score;

  // Background pulse
  bgPulse = Math.sin(frameCount * 0.05) * 0.3 + 0.7;

  // Player physics
  player.vy += GRAVITY;
  player.y += player.vy;

  const groundY = canvas.height * GROUND_Y - player.size;

  if (player.y >= groundY) {
    player.y = groundY;
    player.vy = 0;
    player.onGround = true;
    player.rotation = Math.round(player.rotation / (Math.PI / 2)) * (Math.PI / 2);
    player.rotationSpeed = 0;
  } else {
    player.rotation += player.rotationSpeed;
  }

  // Scroll ground
  for (const tile of groundTiles) {
    tile.x -= SCROLL_SPEED;
  }
  if (groundTiles[0].x < -50) {
    groundTiles.shift();
    groundTiles.push({ x: groundTiles[groundTiles.length - 1].x + 50 });
  }

  // Scroll and check obstacles
  for (let i = obstacles.length - 1; i >= 0; i--) {
    obstacles[i].x -= SCROLL_SPEED;

    if (checkCollision(obstacles[i])) {
      die();
      return;
    }

    if (obstacles[i].x < -100) {
      obstacles.splice(i, 1);
    }
  }

  // Spawn new obstacles
  const lastObs = obstacles[obstacles.length - 1];
  if (!lastObs || lastObs.x < canvas.width - 200) {
    const gap = 250 + Math.random() * 200 - Math.min(score / 10, 100);
    spawnObstacle(canvas.width + Math.max(gap, 150));
  }

  updateParticles();
}

function die() {
  gameRunning = false;
  spawnDeathParticles();

  if (score > bestScore) {
    bestScore = score;
    localStorage.setItem('stormySeasBest', bestScore);
  }

  document.getElementById('deathScore').textContent = `Score: ${score}`;
  document.getElementById('deathBest').textContent = `Best: ${bestScore}`;
  document.getElementById('deathOverlay').classList.remove('hidden');
}

function drawGlow(x, y, radius, color) {
  const gradient = ctx.createRadialGradient(x, y, 0, x, y, radius);
  gradient.addColorStop(0, color);
  gradient.addColorStop(1, 'transparent');
  ctx.fillStyle = gradient;
  ctx.beginPath();
  ctx.arc(x, y, radius, 0, Math.PI * 2);
  ctx.fill();
}

function render() {
  const groundY = canvas.height * GROUND_Y;

  // Background - stormy sea gradient
  const bgGrad = ctx.createLinearGradient(0, 0, 0, canvas.height);
  bgGrad.addColorStop(0, `rgba(20, 30, 40, 1)`);
  bgGrad.addColorStop(1, `rgba(10, 20, 30, 1)`);
  ctx.fillStyle = bgGrad;
  ctx.fillRect(0, 0, canvas.width, canvas.height);

  // Background grid lines - like waves
  ctx.strokeStyle = `rgba(78, 205, 196, ${0.05 * bgPulse})`;
  ctx.lineWidth = 1;
  for (let x = (frameCount * 2) % 80; x < canvas.width; x += 80) {
    ctx.beginPath();
    ctx.moveTo(x, 0);
    ctx.lineTo(x, groundY);
    ctx.stroke();
  }
  for (let y = 40; y < groundY; y += 80) {
    ctx.beginPath();
    ctx.moveTo(0, y);
    ctx.lineTo(canvas.width, y);
    ctx.stroke();
  }

  // Ground glow - golden shore
  drawGlow(canvas.width / 2, groundY, canvas.width / 2, `rgba(212, 168, 75, ${0.12 * bgPulse})`);

  // Ground line
  ctx.strokeStyle = NEON_CYAN;
  ctx.lineWidth = 3;
  ctx.shadowColor = NEON_CYAN;
  ctx.shadowBlur = 20;
  ctx.beginPath();
  ctx.moveTo(0, groundY);
  ctx.lineTo(canvas.width, groundY);
  ctx.stroke();
  ctx.shadowBlur = 0;

  // Ground tiles - wooden planks
  ctx.fillStyle = `rgba(139, 105, 20, 0.2)`;
  for (const tile of groundTiles) {
    ctx.fillRect(tile.x, groundY, 48, 30);
    ctx.strokeStyle = `rgba(212, 168, 75, 0.4)`;
    ctx.lineWidth = 1;
    ctx.strokeRect(tile.x, groundY, 48, 30);
  }

  // Obstacles
  for (const obs of obstacles) {
    if (obs.type === 'spike') {
      // Spike triangle
      ctx.fillStyle = NEON_PINK;
      ctx.shadowColor = NEON_PINK;
      ctx.shadowBlur = 15;
      ctx.beginPath();
      ctx.moveTo(obs.x + obs.width / 2, groundY - obs.height);
      ctx.lineTo(obs.x, groundY);
      ctx.lineTo(obs.x + obs.width, groundY);
      ctx.closePath();
      ctx.fill();

      // Spike outline
      ctx.strokeStyle = '#fff';
      ctx.lineWidth = 2;
      ctx.stroke();
      ctx.shadowBlur = 0;
    } else if (obs.type === 'block') {
      ctx.fillStyle = NEON_YELLOW;
      ctx.shadowColor = NEON_YELLOW;
      ctx.shadowBlur = 15;
      ctx.fillRect(obs.x, groundY - obs.height, obs.width, obs.height);
      ctx.strokeStyle = '#fff';
      ctx.lineWidth = 2;
      ctx.strokeRect(obs.x, groundY - obs.height, obs.width, obs.height);
      ctx.shadowBlur = 0;
    }
  }

  // Particles
  for (const p of particles) {
    ctx.globalAlpha = p.alpha;
    ctx.fillStyle = p.color;
    ctx.shadowColor = p.color;
    ctx.shadowBlur = 10;
    ctx.beginPath();
    ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
    ctx.fill();
  }
  ctx.globalAlpha = 1;
  ctx.shadowBlur = 0;

  // Player
  ctx.save();
  ctx.translate(player.x + player.size / 2, player.y + player.size / 2);
  ctx.rotate(player.rotation);

  // Player glow
  ctx.shadowColor = NEON_CYAN;
  ctx.shadowBlur = 25;
  ctx.fillStyle = NEON_CYAN;
  ctx.fillRect(-player.size / 2, -player.size / 2, player.size, player.size);

  // Player outline
  ctx.strokeStyle = '#fff';
  ctx.lineWidth = 3;
  ctx.strokeRect(-player.size / 2, -player.size / 2, player.size, player.size);

  // Player inner
  ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
  ctx.fillRect(-player.size / 2 + 8, -player.size / 2 + 8, player.size - 16, player.size - 16);

  ctx.restore();
  ctx.shadowBlur = 0;
}

function gameLoop() {
  update();
  render();
  requestAnimationFrame(gameLoop);
}

function startGame() {
  document.getElementById('startOverlay').classList.add('hidden');
  document.getElementById('deathOverlay').classList.add('hidden');
  document.getElementById('best').textContent = `BEST: ${bestScore}`;
  resetGame();
  gameRunning = true;
}

// Event listeners
document.getElementById('startBtn').addEventListener('click', startGame);
document.getElementById('restartBtn').addEventListener('click', startGame);

canvas.addEventListener('click', jump);
canvas.addEventListener('touchstart', (e) => {
  e.preventDefault();
  jump();
});

document.addEventListener('keydown', (e) => {
  if (e.code === 'Space' || e.key === 'ArrowUp' || e.key === 'w') {
    e.preventDefault();
    if (!gameRunning && document.getElementById('startOverlay').classList.contains('hidden')) {
      startGame();
    } else {
      jump();
    }
  }
});

window.addEventListener('resize', resize);

// Initialize
resize();
document.getElementById('best').textContent = `BEST: ${bestScore}`;
requestAnimationFrame(gameLoop);
</script>
</body>
</html>
