<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Neon Tetris</title>
  <link rel="icon" href="https://emojicdn.elk.sh/üéÆ">

  <meta property="og:title" content="Neon Tetris">
  <meta property="og:description" content="Classic Tetris with smooth neon aesthetics.">
  <meta property="og:url" content="https://sloppy.live/neon-tetris">
  <meta property="og:image" content="https://sloppy.live/neon-tetris/og-image.png">
  <meta property="og:type" content="website">

  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&display=swap" rel="stylesheet">

  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: 'Orbitron', monospace;
      background: #0a0a0f;
      min-height: 100vh;
      display: flex;
      align-items: center;
      justify-content: center;
      overflow: hidden;
    }

    /* Grid background */
    body::before {
      content: '';
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background-image:
        linear-gradient(rgba(0, 255, 255, 0.03) 1px, transparent 1px),
        linear-gradient(90deg, rgba(0, 255, 255, 0.03) 1px, transparent 1px);
      background-size: 30px 30px;
      pointer-events: none;
    }

    .game-container {
      display: flex;
      gap: 30px;
      align-items: flex-start;
      padding: 20px;
    }

    .main-panel {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 15px;
    }

    h1 {
      font-size: 2rem;
      font-weight: 900;
      color: #0ff;
      text-shadow: 0 0 20px rgba(0, 255, 255, 0.5),
                   0 0 40px rgba(0, 255, 255, 0.3);
      letter-spacing: 8px;
      text-transform: uppercase;
    }

    .game-board {
      position: relative;
      background: rgba(0, 0, 0, 0.8);
      border: 2px solid #0ff;
      box-shadow: 0 0 30px rgba(0, 255, 255, 0.3),
                  inset 0 0 30px rgba(0, 255, 255, 0.1);
    }

    #gameCanvas {
      display: block;
    }

    /* Side panel */
    .side-panel {
      display: flex;
      flex-direction: column;
      gap: 20px;
      min-width: 150px;
    }

    .panel-box {
      background: rgba(0, 0, 0, 0.6);
      border: 1px solid rgba(0, 255, 255, 0.3);
      padding: 15px;
      text-align: center;
    }

    .panel-title {
      font-size: 0.7rem;
      color: rgba(0, 255, 255, 0.6);
      letter-spacing: 3px;
      margin-bottom: 10px;
      text-transform: uppercase;
    }

    .panel-value {
      font-size: 1.5rem;
      font-weight: 700;
      color: #0ff;
      text-shadow: 0 0 10px rgba(0, 255, 255, 0.5);
    }

    #nextCanvas {
      display: block;
      margin: 0 auto;
      background: rgba(0, 0, 0, 0.4);
    }

    /* Controls info */
    .controls {
      font-size: 0.6rem;
      color: rgba(255, 255, 255, 0.4);
      line-height: 1.8;
    }

    .controls span {
      color: #0ff;
    }

    /* Game over overlay */
    .overlay {
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0, 0, 0, 0.9);
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      gap: 20px;
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.3s;
    }

    .overlay.show {
      opacity: 1;
      pointer-events: auto;
    }

    .overlay-title {
      font-size: 1.5rem;
      font-weight: 900;
      color: #f0f;
      text-shadow: 0 0 20px rgba(255, 0, 255, 0.5);
      letter-spacing: 5px;
    }

    .overlay-score {
      font-size: 1rem;
      color: #0ff;
    }

    .play-btn {
      padding: 15px 40px;
      background: transparent;
      border: 2px solid #0ff;
      color: #0ff;
      font-family: 'Orbitron', monospace;
      font-size: 1rem;
      font-weight: 700;
      letter-spacing: 3px;
      cursor: pointer;
      transition: all 0.2s;
    }

    .play-btn:hover {
      background: #0ff;
      color: #0a0a0f;
      box-shadow: 0 0 30px rgba(0, 255, 255, 0.5);
    }

    /* Mobile controls */
    .mobile-controls {
      display: none;
      gap: 10px;
      margin-top: 15px;
    }

    .mobile-btn {
      width: 60px;
      height: 60px;
      background: rgba(0, 255, 255, 0.1);
      border: 1px solid rgba(0, 255, 255, 0.3);
      color: #0ff;
      font-size: 1.5rem;
      cursor: pointer;
      transition: all 0.1s;
    }

    .mobile-btn:active {
      background: rgba(0, 255, 255, 0.3);
    }

    .mobile-row {
      display: flex;
      gap: 10px;
      justify-content: center;
    }

    /* Backlink */
    #backlink {
      position: fixed;
      bottom: 10px;
      right: 10px;
      color: rgba(0, 255, 255, 0.3);
      text-decoration: none;
      font-size: 10px;
    }

    #backlink:hover {
      color: #0ff;
    }

    /* Responsive */
    @media (max-width: 600px) {
      .game-container {
        flex-direction: column;
        align-items: center;
      }
      .side-panel {
        flex-direction: row;
        flex-wrap: wrap;
        justify-content: center;
        min-width: auto;
      }
      .panel-box {
        padding: 10px 15px;
      }
      .controls {
        display: none;
      }
      .mobile-controls {
        display: flex;
        flex-direction: column;
        align-items: center;
      }
      h1 {
        font-size: 1.5rem;
        letter-spacing: 5px;
      }
    }
  </style>
</head>
<body>
  <div class="game-container">
    <div class="main-panel">
      <h1>Tetris</h1>
      <div class="game-board">
        <canvas id="gameCanvas" width="300" height="600"></canvas>
        <div class="overlay" id="overlay">
          <div class="overlay-title" id="overlayTitle">TETRIS</div>
          <div class="overlay-score" id="overlayScore"></div>
          <button class="play-btn" id="playBtn">PLAY</button>
        </div>
      </div>
      <div class="mobile-controls">
        <div class="mobile-row">
          <button class="mobile-btn" id="btnRotate">‚Üª</button>
        </div>
        <div class="mobile-row">
          <button class="mobile-btn" id="btnLeft">‚Üê</button>
          <button class="mobile-btn" id="btnDown">‚Üì</button>
          <button class="mobile-btn" id="btnRight">‚Üí</button>
        </div>
        <div class="mobile-row">
          <button class="mobile-btn" id="btnDrop" style="width:140px;">DROP</button>
        </div>
      </div>
    </div>

    <div class="side-panel">
      <div class="panel-box">
        <div class="panel-title">Score</div>
        <div class="panel-value" id="score">0</div>
      </div>
      <div class="panel-box">
        <div class="panel-title">Level</div>
        <div class="panel-value" id="level">1</div>
      </div>
      <div class="panel-box">
        <div class="panel-title">Lines</div>
        <div class="panel-value" id="lines">0</div>
      </div>
      <div class="panel-box">
        <div class="panel-title">Next</div>
        <canvas id="nextCanvas" width="100" height="80"></canvas>
      </div>
      <div class="panel-box controls">
        <span>‚Üê‚Üí</span> Move<br>
        <span>‚Üë</span> Rotate<br>
        <span>‚Üì</span> Soft Drop<br>
        <span>Space</span> Hard Drop<br>
        <span>P</span> Pause
      </div>
    </div>
  </div>

  <a href="https://sloppy.live" id="backlink">sloppy.live</a>

  <script>
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const nextCanvas = document.getElementById('nextCanvas');
    const nextCtx = nextCanvas.getContext('2d');

    const COLS = 10;
    const ROWS = 20;
    const BLOCK_SIZE = 30;
    const NEXT_BLOCK_SIZE = 20;

    // Neon colors for pieces
    const COLORS = [
      null,
      '#00ffff', // I - Cyan
      '#ffff00', // O - Yellow
      '#ff00ff', // T - Magenta
      '#00ff00', // S - Green
      '#ff0000', // Z - Red
      '#0080ff', // J - Blue
      '#ff8000'  // L - Orange
    ];

    // Tetromino shapes
    const SHAPES = [
      null,
      [[0,0,0,0], [1,1,1,1], [0,0,0,0], [0,0,0,0]], // I
      [[2,2], [2,2]], // O
      [[0,3,0], [3,3,3], [0,0,0]], // T
      [[0,4,4], [4,4,0], [0,0,0]], // S
      [[5,5,0], [0,5,5], [0,0,0]], // Z
      [[6,0,0], [6,6,6], [0,0,0]], // J
      [[0,0,7], [7,7,7], [0,0,0]]  // L
    ];

    let board = [];
    let currentPiece = null;
    let nextPiece = null;
    let score = 0;
    let lines = 0;
    let level = 1;
    let gameOver = false;
    let paused = false;
    let lastTime = 0;
    let dropCounter = 0;
    let dropInterval = 1000;
    let animatingLines = [];

    // Initialize board
    function createBoard() {
      board = [];
      for (let r = 0; r < ROWS; r++) {
        board.push(new Array(COLS).fill(0));
      }
    }

    // Create a piece
    function createPiece(type) {
      return {
        shape: SHAPES[type].map(row => [...row]),
        type: type,
        x: Math.floor(COLS / 2) - Math.floor(SHAPES[type][0].length / 2),
        y: 0
      };
    }

    // Get random piece
    function randomPiece() {
      const type = Math.floor(Math.random() * 7) + 1;
      return createPiece(type);
    }

    // Draw a block with neon glow
    function drawBlock(context, x, y, color, size, ghost = false) {
      const padding = 1;

      if (ghost) {
        context.strokeStyle = color;
        context.lineWidth = 2;
        context.globalAlpha = 0.3;
        context.strokeRect(x * size + padding, y * size + padding, size - padding * 2, size - padding * 2);
        context.globalAlpha = 1;
        return;
      }

      // Glow effect
      context.shadowColor = color;
      context.shadowBlur = 15;

      // Main block
      context.fillStyle = color;
      context.fillRect(x * size + padding, y * size + padding, size - padding * 2, size - padding * 2);

      // Inner highlight
      context.shadowBlur = 0;
      context.fillStyle = 'rgba(255, 255, 255, 0.3)';
      context.fillRect(x * size + padding + 2, y * size + padding + 2, size - padding * 2 - 8, 4);

      // Border
      context.strokeStyle = 'rgba(255, 255, 255, 0.5)';
      context.lineWidth = 1;
      context.strokeRect(x * size + padding, y * size + padding, size - padding * 2, size - padding * 2);
    }

    // Draw the board
    function drawBoard() {
      ctx.fillStyle = 'rgba(10, 10, 15, 0.95)';
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      // Draw grid lines
      ctx.strokeStyle = 'rgba(0, 255, 255, 0.05)';
      ctx.lineWidth = 1;
      for (let x = 0; x <= COLS; x++) {
        ctx.beginPath();
        ctx.moveTo(x * BLOCK_SIZE, 0);
        ctx.lineTo(x * BLOCK_SIZE, canvas.height);
        ctx.stroke();
      }
      for (let y = 0; y <= ROWS; y++) {
        ctx.beginPath();
        ctx.moveTo(0, y * BLOCK_SIZE);
        ctx.lineTo(canvas.width, y * BLOCK_SIZE);
        ctx.stroke();
      }

      // Draw placed blocks
      for (let r = 0; r < ROWS; r++) {
        for (let c = 0; c < COLS; c++) {
          if (board[r][c]) {
            // Check if this row is being cleared
            const clearing = animatingLines.includes(r);
            if (clearing) {
              ctx.globalAlpha = 0.5 + Math.sin(Date.now() / 50) * 0.5;
            }
            drawBlock(ctx, c, r, COLORS[board[r][c]], BLOCK_SIZE);
            ctx.globalAlpha = 1;
          }
        }
      }
    }

    // Draw ghost piece
    function drawGhost() {
      if (!currentPiece) return;

      let ghostY = currentPiece.y;
      while (!collision(currentPiece.shape, currentPiece.x, ghostY + 1)) {
        ghostY++;
      }

      if (ghostY !== currentPiece.y) {
        currentPiece.shape.forEach((row, r) => {
          row.forEach((val, c) => {
            if (val) {
              drawBlock(ctx, currentPiece.x + c, ghostY + r, COLORS[val], BLOCK_SIZE, true);
            }
          });
        });
      }
    }

    // Draw current piece
    function drawPiece() {
      if (!currentPiece) return;

      currentPiece.shape.forEach((row, r) => {
        row.forEach((val, c) => {
          if (val) {
            drawBlock(ctx, currentPiece.x + c, currentPiece.y + r, COLORS[val], BLOCK_SIZE);
          }
        });
      });
    }

    // Draw next piece
    function drawNext() {
      nextCtx.fillStyle = 'rgba(0, 0, 0, 0.8)';
      nextCtx.fillRect(0, 0, nextCanvas.width, nextCanvas.height);

      if (!nextPiece) return;

      const offsetX = (nextCanvas.width - nextPiece.shape[0].length * NEXT_BLOCK_SIZE) / 2;
      const offsetY = (nextCanvas.height - nextPiece.shape.length * NEXT_BLOCK_SIZE) / 2;

      nextPiece.shape.forEach((row, r) => {
        row.forEach((val, c) => {
          if (val) {
            const px = offsetX / NEXT_BLOCK_SIZE + c;
            const py = offsetY / NEXT_BLOCK_SIZE + r;
            drawBlock(nextCtx, px, py, COLORS[val], NEXT_BLOCK_SIZE);
          }
        });
      });
    }

    // Check collision
    function collision(shape, offsetX, offsetY) {
      for (let r = 0; r < shape.length; r++) {
        for (let c = 0; c < shape[r].length; c++) {
          if (shape[r][c]) {
            const newX = offsetX + c;
            const newY = offsetY + r;

            if (newX < 0 || newX >= COLS || newY >= ROWS) {
              return true;
            }

            if (newY >= 0 && board[newY][newX]) {
              return true;
            }
          }
        }
      }
      return false;
    }

    // Merge piece into board
    function merge() {
      currentPiece.shape.forEach((row, r) => {
        row.forEach((val, c) => {
          if (val) {
            const y = currentPiece.y + r;
            if (y >= 0) {
              board[y][currentPiece.x + c] = val;
            }
          }
        });
      });
    }

    // Rotate piece
    function rotate() {
      const shape = currentPiece.shape;
      const N = shape.length;
      const rotated = [];

      for (let c = 0; c < N; c++) {
        rotated.push([]);
        for (let r = N - 1; r >= 0; r--) {
          rotated[c].push(shape[r][c]);
        }
      }

      const oldShape = currentPiece.shape;
      currentPiece.shape = rotated;

      // Wall kick
      let kick = 0;
      if (collision(currentPiece.shape, currentPiece.x, currentPiece.y)) {
        kick = currentPiece.x > COLS / 2 ? -1 : 1;
        if (collision(currentPiece.shape, currentPiece.x + kick, currentPiece.y)) {
          kick = kick * 2;
          if (collision(currentPiece.shape, currentPiece.x + kick, currentPiece.y)) {
            currentPiece.shape = oldShape;
            return;
          }
        }
      }
      currentPiece.x += kick;
    }

    // Clear completed lines
    function clearLines() {
      let cleared = 0;
      animatingLines = [];

      for (let r = ROWS - 1; r >= 0; r--) {
        if (board[r].every(cell => cell !== 0)) {
          animatingLines.push(r);
          cleared++;
        }
      }

      if (cleared > 0) {
        // Animate then remove
        setTimeout(() => {
          animatingLines.sort((a, b) => b - a).forEach(row => {
            board.splice(row, 1);
            board.unshift(new Array(COLS).fill(0));
          });
          animatingLines = [];
        }, 200);

        lines += cleared;

        // Scoring
        const points = [0, 100, 300, 500, 800];
        score += points[cleared] * level;

        // Level up
        level = Math.floor(lines / 10) + 1;
        dropInterval = Math.max(100, 1000 - (level - 1) * 100);

        updateUI();
      }
    }

    // Update UI
    function updateUI() {
      document.getElementById('score').textContent = score;
      document.getElementById('level').textContent = level;
      document.getElementById('lines').textContent = lines;
    }

    // Move piece
    function move(dir) {
      currentPiece.x += dir;
      if (collision(currentPiece.shape, currentPiece.x, currentPiece.y)) {
        currentPiece.x -= dir;
      }
    }

    // Drop piece
    function drop() {
      currentPiece.y++;
      if (collision(currentPiece.shape, currentPiece.x, currentPiece.y)) {
        currentPiece.y--;
        merge();
        clearLines();
        spawnPiece();
      }
      dropCounter = 0;
    }

    // Hard drop
    function hardDrop() {
      while (!collision(currentPiece.shape, currentPiece.x, currentPiece.y + 1)) {
        currentPiece.y++;
        score += 2;
      }
      merge();
      clearLines();
      spawnPiece();
      updateUI();
    }

    // Spawn new piece
    function spawnPiece() {
      currentPiece = nextPiece || randomPiece();
      nextPiece = randomPiece();
      drawNext();

      if (collision(currentPiece.shape, currentPiece.x, currentPiece.y)) {
        gameOver = true;
        showOverlay('GAME OVER', `Score: ${score}`);
      }
    }

    // Show overlay
    function showOverlay(title, scoreText) {
      document.getElementById('overlayTitle').textContent = title;
      document.getElementById('overlayScore').textContent = scoreText || '';
      document.getElementById('overlay').classList.add('show');
    }

    // Hide overlay
    function hideOverlay() {
      document.getElementById('overlay').classList.remove('show');
    }

    // Start game
    function startGame() {
      createBoard();
      score = 0;
      lines = 0;
      level = 1;
      dropInterval = 1000;
      gameOver = false;
      paused = false;
      animatingLines = [];
      updateUI();
      hideOverlay();
      spawnPiece();
      lastTime = performance.now();
      requestAnimationFrame(gameLoop);
    }

    // Game loop
    function gameLoop(time) {
      if (gameOver) return;

      const deltaTime = time - lastTime;
      lastTime = time;

      if (!paused) {
        dropCounter += deltaTime;
        if (dropCounter > dropInterval) {
          drop();
        }

        drawBoard();
        drawGhost();
        drawPiece();
      }

      requestAnimationFrame(gameLoop);
    }

    // Keyboard controls
    document.addEventListener('keydown', (e) => {
      if (gameOver) return;

      switch (e.key) {
        case 'ArrowLeft':
          move(-1);
          break;
        case 'ArrowRight':
          move(1);
          break;
        case 'ArrowDown':
          drop();
          score += 1;
          updateUI();
          break;
        case 'ArrowUp':
          rotate();
          break;
        case ' ':
          e.preventDefault();
          hardDrop();
          break;
        case 'p':
        case 'P':
          paused = !paused;
          if (paused) {
            showOverlay('PAUSED', 'Press P to resume');
          } else {
            hideOverlay();
          }
          break;
      }
    });

    // Mobile controls
    document.getElementById('btnLeft').addEventListener('click', () => move(-1));
    document.getElementById('btnRight').addEventListener('click', () => move(1));
    document.getElementById('btnDown').addEventListener('click', () => { drop(); score += 1; updateUI(); });
    document.getElementById('btnRotate').addEventListener('click', () => rotate());
    document.getElementById('btnDrop').addEventListener('click', () => hardDrop());

    // Play button
    document.getElementById('playBtn').addEventListener('click', startGame);

    // Initial state
    showOverlay('TETRIS', 'Press PLAY to start');
    drawBoard();
    drawNext();
  </script>
  <script src="/sloppy-header/sloppy-bar.js"></script>
</body>
</html>
