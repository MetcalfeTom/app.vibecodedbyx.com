<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Relativistic Starfield</title>
  <link rel="icon" href="https://emojicdn.elk.sh/ðŸš€">
  <meta property="og:title" content="Relativistic Starfield">
  <meta property="og:description" content="Experience light aberration and Doppler shift at 0.99c">
  <meta property="og:url" content="https://app.sloppy.live/relativistic">
  <meta property="og:image" content="https://emojicdn.elk.sh/ðŸš€?style=apple&size=512">
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700&family=JetBrains+Mono:wght@400&display=swap" rel="stylesheet">
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }

    body {
      min-height: 100vh;
      background: #000;
      font-family: 'JetBrains Mono', monospace;
      color: #e0e0e0;
      overflow: hidden;
    }

    .hud {
      position: fixed;
      top: 1rem;
      left: 1rem;
      z-index: 100;
      pointer-events: none;
    }

    .hud-title {
      font-family: 'Orbitron', sans-serif;
      font-size: 1.2rem;
      color: #0ff;
      text-shadow: 0 0 10px #0ff;
      margin-bottom: 0.5rem;
    }

    .hud-stats {
      font-size: 0.7rem;
      color: #888;
      line-height: 1.6;
    }

    .hud-value { color: #0f0; text-shadow: 0 0 5px #0f0; }
    .hud-warning { color: #f80; }

    .controls {
      position: fixed;
      bottom: 1.5rem;
      left: 50%;
      transform: translateX(-50%);
      display: flex;
      gap: 1rem;
      align-items: center;
      z-index: 100;
      flex-wrap: wrap;
      justify-content: center;
    }

    .slider-group {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 0.3rem;
    }

    .slider-label {
      font-size: 0.6rem;
      color: #666;
      text-transform: uppercase;
      letter-spacing: 1px;
    }

    input[type="range"] {
      width: 120px;
      accent-color: #0ff;
    }

    .btn {
      font-family: 'JetBrains Mono', monospace;
      font-size: 0.7rem;
      padding: 0.5rem 1rem;
      background: rgba(0, 255, 255, 0.1);
      border: 1px solid #0ff;
      color: #0ff;
      cursor: pointer;
      transition: all 0.2s;
    }

    .btn:hover {
      background: rgba(0, 255, 255, 0.3);
      box-shadow: 0 0 15px rgba(0, 255, 255, 0.5);
    }

    .btn.active {
      background: #0ff;
      color: #000;
    }

    .info {
      position: fixed;
      bottom: 0.5rem;
      left: 50%;
      transform: translateX(-50%);
      font-size: 0.55rem;
      color: #444;
      text-align: center;
    }

    .info a { color: #555; text-decoration: none; }

    .physics-info {
      position: fixed;
      top: 1rem;
      right: 1rem;
      width: 200px;
      font-size: 0.6rem;
      color: #666;
      background: rgba(0, 0, 0, 0.7);
      padding: 0.8rem;
      border-radius: 4px;
      border: 1px solid #333;
      z-index: 100;
    }

    .physics-info h3 {
      color: #0ff;
      font-family: 'Orbitron', sans-serif;
      font-size: 0.7rem;
      margin-bottom: 0.5rem;
    }

    .physics-item {
      margin-bottom: 0.4rem;
    }

    .physics-item strong { color: #888; }

    canvas { display: block; }

    /* Speed indicator arc */
    .speed-arc {
      position: fixed;
      bottom: 5rem;
      left: 50%;
      transform: translateX(-50%);
      pointer-events: none;
    }
  </style>
</head>
<body>
  <div class="hud">
    <div class="hud-title">ðŸš€ RELATIVISTIC FLIGHT</div>
    <div class="hud-stats">
      Velocity: <span class="hud-value" id="velocity">0.00</span>c<br>
      Lorentz Î³: <span class="hud-value" id="gamma">1.00</span><br>
      Time dilation: <span class="hud-value" id="timeDilation">1.00</span>x slower<br>
      Aberration: <span class="hud-value" id="aberration">0.0</span>Â°<br>
      <span class="hud-warning" id="warning"></span>
    </div>
  </div>

  <div class="physics-info">
    <h3>Relativistic Effects</h3>
    <div class="physics-item"><strong>Doppler:</strong> Stars ahead blue-shift, behind red-shift</div>
    <div class="physics-item"><strong>Aberration:</strong> Stars cluster toward direction of travel</div>
    <div class="physics-item"><strong>Searchlight:</strong> Light intensifies forward</div>
  </div>

  <div class="controls">
    <div class="slider-group">
      <span class="slider-label">Velocity (fraction of c)</span>
      <input type="range" id="velocitySlider" min="0" max="99" value="0" step="1">
    </div>
    <button class="btn" id="accelerateBtn">Accelerate to 0.99c</button>
    <button class="btn" id="resetBtn">Stop</button>
  </div>

  <div class="info">
    Adjust velocity to see relativistic effects â€¢ Based on special relativity<br>
    <a href="https://sloppy.live">sloppy.live</a>
  </div>

  <script type="importmap">
    {
      "imports": {
        "three": "https://unpkg.com/three@0.160.0/build/three.module.js"
      }
    }
  </script>

  <script type="module">
    import * as THREE from 'three';

    // Scene setup
    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(90, window.innerWidth / window.innerHeight, 0.1, 2000);
    camera.position.z = 0;

    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    document.body.appendChild(renderer.domElement);

    // Star data
    const STAR_COUNT = 5000;
    const STAR_RADIUS = 800;

    // Create stars with original positions
    const starData = [];
    for (let i = 0; i < STAR_COUNT; i++) {
      // Uniform distribution on sphere
      const theta = Math.random() * Math.PI * 2;
      const phi = Math.acos(2 * Math.random() - 1);
      const r = STAR_RADIUS * (0.5 + Math.random() * 0.5);

      starData.push({
        theta,    // Original azimuthal angle
        phi,      // Original polar angle
        r,        // Distance
        baseTemp: 3000 + Math.random() * 7000  // Star temperature (K)
      });
    }

    // Create star geometry
    const starGeometry = new THREE.BufferGeometry();
    const starPositions = new Float32Array(STAR_COUNT * 3);
    const starColors = new Float32Array(STAR_COUNT * 3);
    const starSizes = new Float32Array(STAR_COUNT);

    starGeometry.setAttribute('position', new THREE.BufferAttribute(starPositions, 3));
    starGeometry.setAttribute('color', new THREE.BufferAttribute(starColors, 3));
    starGeometry.setAttribute('size', new THREE.BufferAttribute(starSizes, 1));

    // Star material with custom shader
    const starMaterial = new THREE.ShaderMaterial({
      uniforms: {
        pixelRatio: { value: renderer.getPixelRatio() }
      },
      vertexShader: `
        attribute float size;
        attribute vec3 color;
        varying vec3 vColor;
        uniform float pixelRatio;

        void main() {
          vColor = color;
          vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);
          gl_PointSize = size * pixelRatio * (300.0 / -mvPosition.z);
          gl_Position = projectionMatrix * mvPosition;
        }
      `,
      fragmentShader: `
        varying vec3 vColor;

        void main() {
          float dist = length(gl_PointCoord - vec2(0.5));
          if (dist > 0.5) discard;

          float intensity = 1.0 - dist * 2.0;
          intensity = pow(intensity, 1.5);

          gl_FragColor = vec4(vColor * intensity, intensity);
        }
      `,
      transparent: true,
      blending: THREE.AdditiveBlending,
      depthWrite: false
    });

    const stars = new THREE.Points(starGeometry, starMaterial);
    scene.add(stars);

    // Physics state
    let beta = 0;  // v/c
    let targetBeta = 0;
    let accelerating = false;

    // UI elements
    const velocityEl = document.getElementById('velocity');
    const gammaEl = document.getElementById('gamma');
    const timeDilationEl = document.getElementById('timeDilation');
    const aberrationEl = document.getElementById('aberration');
    const warningEl = document.getElementById('warning');
    const velocitySlider = document.getElementById('velocitySlider');

    // Convert temperature to RGB color
    function tempToRGB(temp) {
      // Approximate blackbody radiation
      temp = temp / 100;
      let r, g, b;

      if (temp <= 66) {
        r = 255;
        g = temp;
        g = 99.4708025861 * Math.log(g) - 161.1195681661;
        if (temp <= 19) {
          b = 0;
        } else {
          b = temp - 10;
          b = 138.5177312231 * Math.log(b) - 305.0447927307;
        }
      } else {
        r = temp - 60;
        r = 329.698727446 * Math.pow(r, -0.1332047592);
        g = temp - 60;
        g = 288.1221695283 * Math.pow(g, -0.0755148492);
        b = 255;
      }

      return {
        r: Math.max(0, Math.min(255, r)) / 255,
        g: Math.max(0, Math.min(255, g)) / 255,
        b: Math.max(0, Math.min(255, b)) / 255
      };
    }

    // Doppler shift temperature
    function dopplerShift(baseTemp, cosAngle, beta) {
      if (beta === 0) return baseTemp;

      // Relativistic Doppler factor
      const gamma = 1 / Math.sqrt(1 - beta * beta);
      const doppler = gamma * (1 - beta * cosAngle);

      // Frequency shift affects perceived temperature
      return baseTemp / doppler;
    }

    // Relativistic aberration - transforms angle
    function aberratedAngle(phi, beta) {
      if (beta === 0) return phi;

      const cosPhi = Math.cos(phi);
      const gamma = 1 / Math.sqrt(1 - beta * beta);

      // Aberration formula
      const cosPhiPrime = (cosPhi - beta) / (1 - beta * cosPhi);
      return Math.acos(Math.max(-1, Math.min(1, cosPhiPrime)));
    }

    // Relativistic beaming intensity
    function beamingIntensity(cosAngle, beta) {
      if (beta === 0) return 1;

      const gamma = 1 / Math.sqrt(1 - beta * beta);
      const doppler = gamma * (1 - beta * cosAngle);

      // Intensity scales as doppler^3 for point source
      return Math.pow(1 / doppler, 3);
    }

    // Update star positions and colors based on velocity
    function updateStars() {
      const positions = starGeometry.attributes.position.array;
      const colors = starGeometry.attributes.color.array;
      const sizes = starGeometry.attributes.size.array;

      for (let i = 0; i < STAR_COUNT; i++) {
        const star = starData[i];

        // Apply relativistic aberration to polar angle
        // phi = 0 is forward, phi = PI is backward
        const aberratedPhi = aberratedAngle(star.phi, beta);

        // Convert to Cartesian
        const x = star.r * Math.sin(aberratedPhi) * Math.cos(star.theta);
        const y = star.r * Math.sin(aberratedPhi) * Math.sin(star.theta);
        const z = -star.r * Math.cos(aberratedPhi);  // Negative Z is forward

        positions[i * 3] = x;
        positions[i * 3 + 1] = y;
        positions[i * 3 + 2] = z;

        // Calculate angle for Doppler/beaming (forward = cos = 1)
        const cosAngle = -Math.cos(star.phi);  // Original angle to direction of travel

        // Apply Doppler shift to color temperature
        const shiftedTemp = dopplerShift(star.baseTemp, cosAngle, beta);
        const color = tempToRGB(shiftedTemp);

        // Apply beaming intensity
        const intensity = beamingIntensity(cosAngle, beta);
        const clampedIntensity = Math.min(intensity, 5);

        colors[i * 3] = color.r * clampedIntensity;
        colors[i * 3 + 1] = color.g * clampedIntensity;
        colors[i * 3 + 2] = color.b * clampedIntensity;

        // Size affected by intensity
        sizes[i] = (1 + Math.random() * 0.5) * Math.min(clampedIntensity, 2);
      }

      starGeometry.attributes.position.needsUpdate = true;
      starGeometry.attributes.color.needsUpdate = true;
      starGeometry.attributes.size.needsUpdate = true;
    }

    // Update HUD
    function updateHUD() {
      const gamma = beta > 0 ? 1 / Math.sqrt(1 - beta * beta) : 1;

      velocityEl.textContent = beta.toFixed(3);
      gammaEl.textContent = gamma.toFixed(2);
      timeDilationEl.textContent = gamma.toFixed(2);

      // Calculate max aberration angle (how much stars move)
      if (beta > 0) {
        const maxAberration = Math.acos((1 - beta) / (1 + beta)) * 180 / Math.PI;
        aberrationEl.textContent = maxAberration.toFixed(1);
      } else {
        aberrationEl.textContent = '0.0';
      }

      // Warning at extreme velocities
      if (beta >= 0.99) {
        warningEl.textContent = 'âš  EXTREME RELATIVISTIC REGIME';
      } else if (beta >= 0.9) {
        warningEl.textContent = 'âš  High gamma factor';
      } else {
        warningEl.textContent = '';
      }

      velocitySlider.value = Math.round(beta * 100);
    }

    // Animation
    function animate() {
      requestAnimationFrame(animate);

      // Smooth velocity changes
      if (accelerating) {
        beta += (targetBeta - beta) * 0.02;
        if (Math.abs(beta - targetBeta) < 0.001) {
          beta = targetBeta;
          accelerating = false;
        }
      }

      // Slow rotation
      stars.rotation.z += 0.0001 * (1 - beta);

      updateStars();
      updateHUD();

      renderer.render(scene, camera);
    }

    // Event handlers
    velocitySlider.addEventListener('input', (e) => {
      beta = parseInt(e.target.value) / 100;
      targetBeta = beta;
      accelerating = false;
    });

    document.getElementById('accelerateBtn').addEventListener('click', () => {
      targetBeta = 0.99;
      accelerating = true;
    });

    document.getElementById('resetBtn').addEventListener('click', () => {
      targetBeta = 0;
      accelerating = true;
    });

    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });

    // Initialize
    updateStars();
    animate();
  </script>
<script src="/apps/sloppy-header/sloppy-bar.js"></script>
<script src="/vibelib-extended.js"></script>
<script>
  // Compatibility Patch for Legacy Apps
  window.addEventListener("load", () => {
    if (window.SloppyKarma && window.VibeLib.Economy) {
      // Redirect old calls to new engine
      window.SloppyKarma.track = window.VibeLib.Economy.track;
    }
  });
</script>
</body>
</html>
