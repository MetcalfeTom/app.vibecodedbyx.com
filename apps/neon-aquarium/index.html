<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Neon Aquarium - Deep Sea Dreams</title>
  <link rel="icon" href="https://emojicdn.elk.sh/ðŸª¼">
  <meta property="og:title" content="Neon Aquarium">
  <meta property="og:description" content="Mesmerizing jellyfish and glowing seaweed in a neon deep sea">
  <meta property="og:url" content="https://sloppy.live/neon-aquarium">
  <meta property="og:image" content="https://emojicdn.elk.sh/ðŸª¼?style=apple&size=512">
  <link href="https://fonts.googleapis.com/css2?family=Quicksand:wght@300;500;700&display=swap" rel="stylesheet">
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }

    body {
      background: linear-gradient(180deg, #000510 0%, #001025 50%, #000818 100%);
      overflow: hidden;
      font-family: 'Quicksand', sans-serif;
      min-height: 100vh;
    }

    canvas {
      display: block;
    }

    .title {
      position: fixed;
      top: 20px;
      left: 50%;
      transform: translateX(-50%);
      font-size: 1.5rem;
      font-weight: 300;
      color: rgba(0, 255, 255, 0.4);
      text-shadow: 0 0 20px rgba(0, 255, 255, 0.3);
      letter-spacing: 8px;
      pointer-events: none;
      z-index: 100;
    }

    .controls {
      position: fixed;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      display: flex;
      gap: 15px;
      z-index: 100;
    }

    .control-btn {
      font-family: 'Quicksand', sans-serif;
      font-size: 0.8rem;
      font-weight: 500;
      padding: 10px 20px;
      background: rgba(0, 0, 0, 0.5);
      border: 1px solid rgba(0, 255, 255, 0.3);
      color: #0ff;
      cursor: pointer;
      border-radius: 20px;
      transition: all 0.3s;
    }

    .control-btn:hover {
      background: rgba(0, 255, 255, 0.2);
      box-shadow: 0 0 20px rgba(0, 255, 255, 0.3);
    }

    .backlink {
      position: fixed;
      bottom: 20px;
      right: 20px;
      color: rgba(255, 255, 255, 0.2);
      font-size: 0.7rem;
      text-decoration: none;
      z-index: 100;
    }

    .backlink:hover { color: #0ff; }

    .sub-controls {
      position: fixed;
      bottom: 80px;
      left: 20px;
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 5px;
      z-index: 100;
      opacity: 0.8;
    }

    .sub-controls:hover { opacity: 1; }

    .sub-label {
      color: #ffff00;
      font-size: 0.7rem;
      text-shadow: 0 0 10px #ffff00;
      margin-bottom: 5px;
    }

    .sub-row {
      display: flex;
      gap: 5px;
    }

    .sub-btn {
      width: 45px;
      height: 45px;
      background: rgba(255, 255, 0, 0.15);
      border: 2px solid rgba(255, 255, 0, 0.5);
      color: #ffff00;
      font-size: 1.2rem;
      cursor: pointer;
      border-radius: 8px;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: all 0.2s;
      user-select: none;
      -webkit-user-select: none;
      touch-action: manipulation;
    }

    .sub-btn:hover, .sub-btn:active, .sub-btn.active {
      background: rgba(255, 255, 0, 0.4);
      box-shadow: 0 0 20px rgba(255, 255, 0, 0.5);
    }

    @media (max-width: 600px) {
      .title { font-size: 1rem; letter-spacing: 4px; }
      .control-btn { padding: 8px 15px; font-size: 0.7rem; }
      .sub-controls { bottom: 90px; }
      .sub-btn { width: 50px; height: 50px; }
    }
  </style>
</head>
<body>
  <canvas id="aquarium"></canvas>

  <div class="title">NEON AQUARIUM</div>

  <div class="sub-controls">
    <div class="sub-label">SUBMARINE</div>
    <button class="sub-btn" id="sub-up">â–²</button>
    <div class="sub-row">
      <button class="sub-btn" id="sub-left">â—€</button>
      <button class="sub-btn" id="sub-down">â–¼</button>
      <button class="sub-btn" id="sub-right">â–¶</button>
    </div>
  </div>

  <div class="controls">
    <button class="control-btn" id="add-whale">+ Rave Whale</button>
    <button class="control-btn" id="add-crab">+ Disco Crab</button>
    <button class="control-btn" id="add-jelly">+ Jellyfish</button>
    <button class="control-btn" id="add-octopus">+ DJ Octopus</button>
    <button class="control-btn" id="add-seaweed">+ Seaweed</button>
    <button class="control-btn" id="toggle-bubbles">Bubbles</button>
  </div>

  <a href="https://sloppy.live" class="backlink">sloppy.live</a>

  <script>
    const canvas = document.getElementById('aquarium');
    const ctx = canvas.getContext('2d');

    let W, H;
    function resize() {
      W = canvas.width = window.innerWidth;
      H = canvas.height = window.innerHeight;
    }
    resize();
    window.addEventListener('resize', resize);

    // Settings
    let bubblesEnabled = true;

    // Jellyfish colors
    const jellyColors = [
      { main: '#ff00ff', glow: 'rgba(255, 0, 255, 0.5)' },
      { main: '#00ffff', glow: 'rgba(0, 255, 255, 0.5)' },
      { main: '#ff6b9d', glow: 'rgba(255, 107, 157, 0.5)' },
      { main: '#9d4edd', glow: 'rgba(157, 78, 221, 0.5)' },
      { main: '#00ff88', glow: 'rgba(0, 255, 136, 0.5)' },
      { main: '#ffd700', glow: 'rgba(255, 215, 0, 0.5)' }
    ];

    // Seaweed colors
    const seaweedColors = ['#00ff88', '#00ffaa', '#88ff00', '#00ff66', '#44ffaa'];

    // Octopus colors
    const octoColors = [
      { main: '#ff3366', glow: 'rgba(255, 51, 102, 0.6)' },
      { main: '#00ffcc', glow: 'rgba(0, 255, 204, 0.6)' },
      { main: '#ff6600', glow: 'rgba(255, 102, 0, 0.6)' },
      { main: '#cc00ff', glow: 'rgba(204, 0, 255, 0.6)' }
    ];

    // Whale colors
    const whaleColors = [
      { main: '#00ffff', glow: 'rgba(0, 255, 255, 0.6)', laser: '#ff0000' },
      { main: '#ff00ff', glow: 'rgba(255, 0, 255, 0.6)', laser: '#00ff00' },
      { main: '#ff6600', glow: 'rgba(255, 102, 0, 0.6)', laser: '#00ffff' },
      { main: '#00ff88', glow: 'rgba(0, 255, 136, 0.6)', laser: '#ff00ff' }
    ];

    // Disco crab colors
    const crabColors = [
      { main: '#ff0066', glow: 'rgba(255, 0, 102, 0.6)', hat: '#00ffff' },
      { main: '#00ffcc', glow: 'rgba(0, 255, 204, 0.6)', hat: '#ff00ff' },
      { main: '#ffcc00', glow: 'rgba(255, 204, 0, 0.6)', hat: '#00ff00' },
      { main: '#ff6600', glow: 'rgba(255, 102, 0, 0.6)', hat: '#00ccff' },
      { main: '#cc00ff', glow: 'rgba(204, 0, 255, 0.6)', hat: '#ffff00' }
    ];

    // Submarine (player controlled)
    let submarine = {
      x: 200,
      y: 300,
      vx: 0,
      vy: 0,
      angle: 0,
      targetAngle: 0,
      size: 60,
      propellerPhase: 0,
      laserIntensity: 0.8,
      bubbleTimer: 0
    };

    // Submarine controls
    const subInput = { up: false, down: false, left: false, right: false };

    // Arrays
    let jellyfish = [];
    let octopuses = [];
    let whales = [];
    let crabs = [];
    let seaweeds = [];
    let bubbles = [];
    let particles = [];
    let beatPhase = 0;

    // Create jellyfish
    function createJellyfish(x, y) {
      const color = jellyColors[Math.floor(Math.random() * jellyColors.length)];
      return {
        x: x || Math.random() * W,
        y: y || Math.random() * H * 0.7,
        size: 30 + Math.random() * 40,
        color: color,
        phase: Math.random() * Math.PI * 2,
        pulseSpeed: 1.5 + Math.random() * 1,
        driftSpeed: 0.2 + Math.random() * 0.3,
        driftAngle: Math.random() * Math.PI * 2,
        wobble: Math.random() * Math.PI * 2,
        tentacles: 5 + Math.floor(Math.random() * 4),
        tentacleLength: 60 + Math.random() * 40
      };
    }

    // Create seaweed
    function createSeaweed(x) {
      return {
        x: x || Math.random() * W,
        baseY: H,
        height: 100 + Math.random() * 150,
        segments: 8 + Math.floor(Math.random() * 6),
        color: seaweedColors[Math.floor(Math.random() * seaweedColors.length)],
        phase: Math.random() * Math.PI * 2,
        swaySpeed: 0.5 + Math.random() * 0.5,
        swayAmount: 10 + Math.random() * 15,
        width: 8 + Math.random() * 8
      };
    }

    // Create bubble
    function createBubble() {
      return {
        x: Math.random() * W,
        y: H + 20,
        size: 2 + Math.random() * 6,
        speed: 0.5 + Math.random() * 1.5,
        wobble: Math.random() * Math.PI * 2,
        wobbleSpeed: 2 + Math.random() * 2
      };
    }

    // Create particle (ambient floating bits)
    function createParticle() {
      return {
        x: Math.random() * W,
        y: Math.random() * H,
        size: 1 + Math.random() * 2,
        alpha: 0.2 + Math.random() * 0.4,
        vx: (Math.random() - 0.5) * 0.3,
        vy: (Math.random() - 0.5) * 0.3
      };
    }

    // Create DJ Octopus
    function createOctopus(x, y) {
      const color = octoColors[Math.floor(Math.random() * octoColors.length)];
      return {
        x: x || Math.random() * (W - 200) + 100,
        y: y || H - 150 - Math.random() * 100,
        size: 40 + Math.random() * 20,
        color: color,
        phase: Math.random() * Math.PI * 2,
        bobSpeed: 1 + Math.random() * 0.5,
        scratchPhase: Math.random() * Math.PI * 2,
        headphones: true,
        turntableAngle: 0,
        vibeIntensity: 0.5 + Math.random() * 0.5
      };
    }

    // Create Rave Whale
    function createWhale(x, y) {
      const color = whaleColors[Math.floor(Math.random() * whaleColors.length)];
      const direction = Math.random() > 0.5 ? 1 : -1;
      return {
        x: x !== undefined ? x : (direction === 1 ? -300 : W + 300),
        y: y || 100 + Math.random() * (H * 0.4),
        size: 120 + Math.random() * 60,
        color: color,
        direction: direction,
        speed: 0.3 + Math.random() * 0.3,
        phase: Math.random() * Math.PI * 2,
        tailPhase: Math.random() * Math.PI * 2,
        bobPhase: Math.random() * Math.PI * 2,
        laserActive: true,
        laserPhase: Math.random() * Math.PI * 2,
        laserIntensity: 0.7 + Math.random() * 0.3,
        ravePhase: Math.random() * Math.PI * 2
      };
    }

    // Create Disco Crab
    function createCrab(x) {
      const color = crabColors[Math.floor(Math.random() * crabColors.length)];
      const direction = Math.random() > 0.5 ? 1 : -1;
      return {
        x: x !== undefined ? x : Math.random() * W,
        y: H - 40 - Math.random() * 20,
        size: 25 + Math.random() * 15,
        color: color,
        direction: direction,
        speed: 0.8 + Math.random() * 0.5,
        phase: Math.random() * Math.PI * 2,
        clawPhase: Math.random() * Math.PI * 2,
        legPhase: Math.random() * Math.PI * 2,
        dancePhase: Math.random() * Math.PI * 2,
        hatGlow: 0,
        sidestepTimer: Math.random() * 3
      };
    }

    // Initialize
    function init() {
      jellyfish = [];
      octopuses = [];
      whales = [];
      crabs = [];
      seaweeds = [];
      bubbles = [];
      particles = [];

      // Initial jellyfish
      for (let i = 0; i < 5; i++) {
        jellyfish.push(createJellyfish());
      }

      // Initial DJ octopuses
      for (let i = 0; i < 2; i++) {
        octopuses.push(createOctopus(W * 0.3 + i * W * 0.4, H - 180));
      }

      // Initial rave whale
      whales.push(createWhale(W * 0.5, H * 0.25));

      // Initial disco crabs
      for (let i = 0; i < 4; i++) {
        crabs.push(createCrab(W * 0.15 + i * W * 0.25));
      }

      // Initial seaweed
      for (let i = 0; i < 12; i++) {
        seaweeds.push(createSeaweed(i * (W / 11)));
      }

      // Ambient particles
      for (let i = 0; i < 50; i++) {
        particles.push(createParticle());
      }
    }

    // Update
    let time = 0;
    function update(dt) {
      time += dt;

      // Update jellyfish
      jellyfish.forEach(jelly => {
        jelly.phase += dt * jelly.pulseSpeed;
        jelly.wobble += dt * 2;

        // Gentle drift
        jelly.driftAngle += (Math.random() - 0.5) * 0.1;
        jelly.x += Math.cos(jelly.driftAngle) * jelly.driftSpeed;
        jelly.y += Math.sin(jelly.driftAngle) * jelly.driftSpeed - 0.2; // Slight upward

        // Wrap around
        if (jelly.x < -jelly.size) jelly.x = W + jelly.size;
        if (jelly.x > W + jelly.size) jelly.x = -jelly.size;
        if (jelly.y < -jelly.size * 2) jelly.y = H + jelly.size;
        if (jelly.y > H + jelly.size) jelly.y = -jelly.size * 2;
      });

      // Update seaweed
      seaweeds.forEach(weed => {
        weed.phase += dt * weed.swaySpeed;
      });

      // Update beat phase for DJ octopuses
      beatPhase += dt * 4; // Beat speed

      // Update octopuses
      octopuses.forEach(octo => {
        octo.phase += dt * octo.bobSpeed;
        octo.scratchPhase += dt * 8;
        octo.turntableAngle += dt * 3;
      });

      // Update whales
      whales.forEach(whale => {
        whale.phase += dt;
        whale.tailPhase += dt * 3;
        whale.bobPhase += dt * 0.8;
        whale.laserPhase += dt * 5;
        whale.ravePhase += dt * 4;

        // Move across screen
        whale.x += whale.direction * whale.speed * 60 * dt;
        whale.y += Math.sin(whale.bobPhase) * 0.5;

        // Wrap around when off screen
        if (whale.direction === 1 && whale.x > W + whale.size * 2) {
          whale.x = -whale.size * 2;
          whale.y = 100 + Math.random() * (H * 0.4);
        } else if (whale.direction === -1 && whale.x < -whale.size * 2) {
          whale.x = W + whale.size * 2;
          whale.y = 100 + Math.random() * (H * 0.4);
        }
      });

      // Update disco crabs (synchronized dancing!)
      crabs.forEach(crab => {
        crab.phase += dt;
        crab.clawPhase += dt * 6; // Snap snap!
        crab.legPhase += dt * 8;
        crab.dancePhase = beatPhase; // Sync to beat!
        crab.hatGlow = Math.sin(beatPhase * Math.PI) * 0.5 + 0.5;

        // Sidestep movement
        crab.sidestepTimer -= dt;
        if (crab.sidestepTimer <= 0) {
          crab.direction *= -1;
          crab.sidestepTimer = 1 + Math.random() * 2;
        }

        // Move sideways (crabs walk sideways!)
        crab.x += crab.direction * crab.speed * 30 * dt;

        // Wrap around
        if (crab.x < -crab.size) crab.x = W + crab.size;
        if (crab.x > W + crab.size) crab.x = -crab.size;
      });

      // Update submarine
      const subAccel = 200;
      const subFriction = 0.97;
      const subMaxSpeed = 150;

      // Apply acceleration based on input
      if (subInput.up) submarine.vy -= subAccel * dt;
      if (subInput.down) submarine.vy += subAccel * dt;
      if (subInput.left) submarine.vx -= subAccel * dt;
      if (subInput.right) submarine.vx += subAccel * dt;

      // Apply friction
      submarine.vx *= subFriction;
      submarine.vy *= subFriction;

      // Clamp speed
      const speed = Math.sqrt(submarine.vx * submarine.vx + submarine.vy * submarine.vy);
      if (speed > subMaxSpeed) {
        submarine.vx = (submarine.vx / speed) * subMaxSpeed;
        submarine.vy = (submarine.vy / speed) * subMaxSpeed;
      }

      // Update position
      submarine.x += submarine.vx * dt;
      submarine.y += submarine.vy * dt;

      // Boundary constraints
      submarine.x = Math.max(submarine.size, Math.min(W - submarine.size, submarine.x));
      submarine.y = Math.max(submarine.size, Math.min(H - submarine.size - 40, submarine.y));

      // Update angle based on velocity
      if (speed > 5) {
        submarine.targetAngle = Math.atan2(submarine.vy, submarine.vx);
      }
      // Smooth angle interpolation
      let angleDiff = submarine.targetAngle - submarine.angle;
      while (angleDiff > Math.PI) angleDiff -= Math.PI * 2;
      while (angleDiff < -Math.PI) angleDiff += Math.PI * 2;
      submarine.angle += angleDiff * 5 * dt;

      // Propeller animation
      submarine.propellerPhase += dt * (10 + speed * 0.1);

      // Spawn bubbles from submarine
      submarine.bubbleTimer -= dt;
      if (submarine.bubbleTimer <= 0 && speed > 10) {
        submarine.bubbleTimer = 0.1;
        bubbles.push({
          x: submarine.x - Math.cos(submarine.angle) * submarine.size * 0.8,
          y: submarine.y - Math.sin(submarine.angle) * submarine.size * 0.8,
          size: 3 + Math.random() * 4,
          speed: 1 + Math.random() * 1,
          wobble: Math.random() * Math.PI * 2,
          wobbleSpeed: 3 + Math.random() * 2
        });
      }

      // Update bubbles
      if (bubblesEnabled && Math.random() < 0.1) {
        bubbles.push(createBubble());
      }

      bubbles.forEach(bubble => {
        bubble.y -= bubble.speed;
        bubble.wobble += dt * bubble.wobbleSpeed;
        bubble.x += Math.sin(bubble.wobble) * 0.5;
      });

      bubbles = bubbles.filter(b => b.y > -20);

      // Update particles
      particles.forEach(p => {
        p.x += p.vx;
        p.y += p.vy;

        // Wrap
        if (p.x < 0) p.x = W;
        if (p.x > W) p.x = 0;
        if (p.y < 0) p.y = H;
        if (p.y > H) p.y = 0;
      });
    }

    // Draw jellyfish
    function drawJellyfish(jelly) {
      ctx.save();
      ctx.translate(jelly.x, jelly.y);

      const pulse = Math.sin(jelly.phase);
      const breathe = 0.8 + pulse * 0.2;

      // Glow
      ctx.shadowBlur = 30 + pulse * 20;
      ctx.shadowColor = jelly.color.glow;

      // Bell (dome)
      ctx.fillStyle = jelly.color.main;
      ctx.globalAlpha = 0.6 + pulse * 0.2;
      ctx.beginPath();
      ctx.ellipse(0, 0, jelly.size * breathe, jelly.size * 0.6 * breathe, 0, Math.PI, 0, false);
      ctx.fill();

      // Inner bell highlight
      ctx.fillStyle = '#fff';
      ctx.globalAlpha = 0.2 + pulse * 0.1;
      ctx.beginPath();
      ctx.ellipse(0, -jelly.size * 0.2, jelly.size * 0.4 * breathe, jelly.size * 0.2 * breathe, 0, Math.PI, 0, false);
      ctx.fill();

      // Frilly edge
      ctx.strokeStyle = jelly.color.main;
      ctx.lineWidth = 3;
      ctx.globalAlpha = 0.8;
      ctx.beginPath();
      const frills = 12;
      for (let i = 0; i <= frills; i++) {
        const angle = Math.PI + (i / frills) * Math.PI;
        const x = Math.cos(angle) * jelly.size * breathe;
        const y = Math.sin(angle) * jelly.size * 0.6 * breathe;
        const frillOffset = Math.sin(jelly.phase * 2 + i) * 5;
        if (i === 0) ctx.moveTo(x, y + frillOffset);
        else ctx.lineTo(x, y + frillOffset);
      }
      ctx.stroke();

      ctx.shadowBlur = 0;

      // Tentacles
      ctx.strokeStyle = jelly.color.main;
      ctx.lineWidth = 2;
      ctx.lineCap = 'round';
      ctx.globalAlpha = 0.5;

      for (let i = 0; i < jelly.tentacles; i++) {
        const startX = (i / (jelly.tentacles - 1) - 0.5) * jelly.size * 1.5 * breathe;
        ctx.beginPath();
        ctx.moveTo(startX, jelly.size * 0.3);

        // Wavy tentacle
        let tx = startX;
        let ty = jelly.size * 0.3;
        const segments = 8;

        for (let j = 1; j <= segments; j++) {
          const progress = j / segments;
          const wave = Math.sin(jelly.phase * 3 + i + j * 0.5) * (10 + progress * 15);
          tx = startX + wave;
          ty = jelly.size * 0.3 + progress * jelly.tentacleLength;
          ctx.lineTo(tx, ty);
        }
        ctx.stroke();

        // Glowing tip
        ctx.fillStyle = jelly.color.main;
        ctx.globalAlpha = 0.8;
        ctx.beginPath();
        ctx.arc(tx, ty, 3, 0, Math.PI * 2);
        ctx.fill();
      }

      ctx.restore();
    }

    // Draw seaweed
    function drawSeaweed(weed) {
      ctx.save();

      const segments = weed.segments;
      const segmentHeight = weed.height / segments;

      ctx.strokeStyle = weed.color;
      ctx.lineWidth = weed.width;
      ctx.lineCap = 'round';
      ctx.shadowBlur = 15;
      ctx.shadowColor = weed.color;
      ctx.globalAlpha = 0.7;

      ctx.beginPath();
      ctx.moveTo(weed.x, weed.baseY);

      for (let i = 1; i <= segments; i++) {
        const progress = i / segments;
        const sway = Math.sin(weed.phase + i * 0.5) * weed.swayAmount * progress;
        const x = weed.x + sway;
        const y = weed.baseY - i * segmentHeight;

        ctx.lineTo(x, y);
      }
      ctx.stroke();

      // Add leaves/fronds
      ctx.lineWidth = weed.width * 0.5;
      ctx.globalAlpha = 0.5;

      for (let i = 2; i < segments; i += 2) {
        const progress = i / segments;
        const baseX = weed.x + Math.sin(weed.phase + i * 0.5) * weed.swayAmount * progress;
        const baseY = weed.baseY - i * segmentHeight;
        const leafSway = Math.sin(weed.phase * 1.5 + i) * 10;

        // Left leaf
        ctx.beginPath();
        ctx.moveTo(baseX, baseY);
        ctx.quadraticCurveTo(
          baseX - 20 + leafSway, baseY - 10,
          baseX - 30 + leafSway, baseY + 5
        );
        ctx.stroke();

        // Right leaf
        ctx.beginPath();
        ctx.moveTo(baseX, baseY);
        ctx.quadraticCurveTo(
          baseX + 20 + leafSway, baseY - 10,
          baseX + 30 + leafSway, baseY + 5
        );
        ctx.stroke();
      }

      ctx.restore();
    }

    // Draw DJ Octopus
    function drawOctopus(octo) {
      ctx.save();
      ctx.translate(octo.x, octo.y);

      const beat = Math.sin(beatPhase * Math.PI);
      const bob = Math.sin(octo.phase) * 5;
      const bounce = Math.abs(beat) * 8 * octo.vibeIntensity;

      // Translate for bobbing
      ctx.translate(0, bob - bounce);

      // Glow effect
      ctx.shadowBlur = 25 + beat * 15;
      ctx.shadowColor = octo.color.glow;

      // Draw 8 tentacles (4 on each side) - dancing to the beat
      for (let i = 0; i < 8; i++) {
        const side = i < 4 ? -1 : 1;
        const index = i % 4;
        const baseAngle = (side * (30 + index * 25)) * Math.PI / 180;
        const beatOffset = Math.sin(beatPhase * Math.PI + i * 0.5) * 0.3 * octo.vibeIntensity;

        ctx.strokeStyle = octo.color.main;
        ctx.lineWidth = 6;
        ctx.lineCap = 'round';
        ctx.globalAlpha = 0.8;

        ctx.beginPath();
        let tx = Math.cos(baseAngle + beatOffset) * octo.size * 0.6;
        let ty = Math.sin(baseAngle + Math.PI * 0.3) * octo.size * 0.3 + octo.size * 0.3;
        ctx.moveTo(tx, ty);

        // Wavy tentacle segments
        for (let j = 1; j <= 6; j++) {
          const progress = j / 6;
          const wave = Math.sin(octo.scratchPhase + i + j * 0.8) * (15 + progress * 20) * octo.vibeIntensity;
          const tentacleLength = octo.size * 1.8;
          tx = Math.cos(baseAngle + beatOffset) * (octo.size * 0.6 + progress * tentacleLength * 0.7) + wave * side;
          ty = octo.size * 0.3 + progress * tentacleLength * 0.8;
          ctx.lineTo(tx, ty);
        }
        ctx.stroke();

        // Suction cups
        ctx.fillStyle = octo.color.main;
        ctx.globalAlpha = 0.5;
        ctx.beginPath();
        ctx.arc(tx, ty, 4, 0, Math.PI * 2);
        ctx.fill();
      }

      // Head (mantle)
      ctx.fillStyle = octo.color.main;
      ctx.globalAlpha = 0.9;
      ctx.beginPath();
      ctx.ellipse(0, 0, octo.size, octo.size * 0.8, 0, 0, Math.PI * 2);
      ctx.fill();

      // Head highlight
      ctx.fillStyle = '#fff';
      ctx.globalAlpha = 0.2;
      ctx.beginPath();
      ctx.ellipse(-octo.size * 0.3, -octo.size * 0.3, octo.size * 0.4, octo.size * 0.3, -0.5, 0, Math.PI * 2);
      ctx.fill();

      // Eyes
      ctx.fillStyle = '#fff';
      ctx.globalAlpha = 1;
      ctx.beginPath();
      ctx.ellipse(-octo.size * 0.35, -octo.size * 0.1, 12, 14, 0, 0, Math.PI * 2);
      ctx.fill();
      ctx.beginPath();
      ctx.ellipse(octo.size * 0.35, -octo.size * 0.1, 12, 14, 0, 0, Math.PI * 2);
      ctx.fill();

      // Pupils (looking at turntables)
      ctx.fillStyle = '#000';
      const pupilOffset = Math.sin(octo.scratchPhase * 0.5) * 3;
      ctx.beginPath();
      ctx.arc(-octo.size * 0.35 + pupilOffset, -octo.size * 0.05, 6, 0, Math.PI * 2);
      ctx.fill();
      ctx.beginPath();
      ctx.arc(octo.size * 0.35 + pupilOffset, -octo.size * 0.05, 6, 0, Math.PI * 2);
      ctx.fill();

      // Happy DJ mouth
      ctx.strokeStyle = '#fff';
      ctx.lineWidth = 3;
      ctx.globalAlpha = 0.8;
      ctx.beginPath();
      ctx.arc(0, octo.size * 0.2, 15, 0.2, Math.PI - 0.2);
      ctx.stroke();

      ctx.shadowBlur = 0;

      // Headphones
      if (octo.headphones) {
        ctx.strokeStyle = '#333';
        ctx.lineWidth = 8;
        ctx.globalAlpha = 1;
        // Headband
        ctx.beginPath();
        ctx.arc(0, -octo.size * 0.2, octo.size * 0.9, Math.PI + 0.5, -0.5);
        ctx.stroke();

        // Ear pieces
        ctx.fillStyle = octo.color.main;
        ctx.shadowBlur = 15;
        ctx.shadowColor = octo.color.glow;
        ctx.beginPath();
        ctx.ellipse(-octo.size * 0.85, -octo.size * 0.1, 15, 20, 0.3, 0, Math.PI * 2);
        ctx.fill();
        ctx.beginPath();
        ctx.ellipse(octo.size * 0.85, -octo.size * 0.1, 15, 20, -0.3, 0, Math.PI * 2);
        ctx.fill();
      }

      ctx.shadowBlur = 0;

      // DJ Turntables/Decks below octopus
      ctx.translate(0, octo.size + 40);

      // DJ Table
      ctx.fillStyle = 'rgba(30, 30, 40, 0.9)';
      ctx.globalAlpha = 1;
      ctx.beginPath();
      ctx.roundRect(-80, -10, 160, 50, 5);
      ctx.fill();

      // Turntable 1 (left)
      ctx.fillStyle = '#111';
      ctx.beginPath();
      ctx.arc(-40, 15, 30, 0, Math.PI * 2);
      ctx.fill();

      // Record spinning
      ctx.save();
      ctx.translate(-40, 15);
      ctx.rotate(octo.turntableAngle);
      ctx.fillStyle = '#222';
      ctx.beginPath();
      ctx.arc(0, 0, 25, 0, Math.PI * 2);
      ctx.fill();
      // Record grooves
      ctx.strokeStyle = '#333';
      ctx.lineWidth = 1;
      for (let r = 8; r < 25; r += 4) {
        ctx.beginPath();
        ctx.arc(0, 0, r, 0, Math.PI * 2);
        ctx.stroke();
      }
      // Label
      ctx.fillStyle = octo.color.main;
      ctx.beginPath();
      ctx.arc(0, 0, 8, 0, Math.PI * 2);
      ctx.fill();
      ctx.restore();

      // Turntable 2 (right)
      ctx.fillStyle = '#111';
      ctx.beginPath();
      ctx.arc(40, 15, 30, 0, Math.PI * 2);
      ctx.fill();

      // Record spinning (opposite direction)
      ctx.save();
      ctx.translate(40, 15);
      ctx.rotate(-octo.turntableAngle * 1.1);
      ctx.fillStyle = '#222';
      ctx.beginPath();
      ctx.arc(0, 0, 25, 0, Math.PI * 2);
      ctx.fill();
      ctx.strokeStyle = '#333';
      ctx.lineWidth = 1;
      for (let r = 8; r < 25; r += 4) {
        ctx.beginPath();
        ctx.arc(0, 0, r, 0, Math.PI * 2);
        ctx.stroke();
      }
      ctx.fillStyle = octo.color.main;
      ctx.beginPath();
      ctx.arc(0, 0, 8, 0, Math.PI * 2);
      ctx.fill();
      ctx.restore();

      // Mixer in center
      ctx.fillStyle = '#1a1a2a';
      ctx.beginPath();
      ctx.roundRect(-15, 0, 30, 35, 3);
      ctx.fill();

      // Faders/buttons
      ctx.fillStyle = octo.color.main;
      ctx.shadowBlur = 8;
      ctx.shadowColor = octo.color.glow;
      const faderY = 10 + Math.sin(beatPhase) * 5;
      ctx.fillRect(-10, faderY, 6, 12);
      ctx.fillRect(4, 25 - faderY + 10, 6, 12);

      // LED indicators
      for (let i = 0; i < 3; i++) {
        ctx.fillStyle = i < 2 ? '#0f0' : '#f00';
        ctx.globalAlpha = 0.5 + Math.sin(beatPhase * 2 + i) * 0.5;
        ctx.beginPath();
        ctx.arc(-8 + i * 8, 30, 2, 0, Math.PI * 2);
        ctx.fill();
      }

      ctx.restore();
    }

    // Draw Rave Whale
    function drawWhale(whale) {
      ctx.save();
      ctx.translate(whale.x, whale.y);

      // Flip if going left
      if (whale.direction === -1) {
        ctx.scale(-1, 1);
      }

      const beat = Math.sin(whale.ravePhase * Math.PI);
      const bob = Math.sin(whale.bobPhase) * 5;

      ctx.translate(0, bob);

      // Massive glow
      ctx.shadowBlur = 40 + beat * 20;
      ctx.shadowColor = whale.color.glow;

      // Body
      ctx.fillStyle = whale.color.main;
      ctx.globalAlpha = 0.85;
      ctx.beginPath();
      // Main body ellipse
      ctx.ellipse(0, 0, whale.size, whale.size * 0.45, 0, 0, Math.PI * 2);
      ctx.fill();

      // Head bulge
      ctx.beginPath();
      ctx.ellipse(whale.size * 0.6, -whale.size * 0.1, whale.size * 0.5, whale.size * 0.4, 0.2, 0, Math.PI * 2);
      ctx.fill();

      // Belly (lighter)
      ctx.fillStyle = '#fff';
      ctx.globalAlpha = 0.15;
      ctx.beginPath();
      ctx.ellipse(0, whale.size * 0.15, whale.size * 0.8, whale.size * 0.25, 0, 0, Math.PI);
      ctx.fill();

      // Tail
      const tailWag = Math.sin(whale.tailPhase) * 0.3;
      ctx.fillStyle = whale.color.main;
      ctx.globalAlpha = 0.85;
      ctx.save();
      ctx.translate(-whale.size, 0);
      ctx.rotate(tailWag);
      ctx.beginPath();
      ctx.moveTo(0, 0);
      ctx.quadraticCurveTo(-whale.size * 0.4, -whale.size * 0.4, -whale.size * 0.7, -whale.size * 0.3);
      ctx.quadraticCurveTo(-whale.size * 0.5, 0, -whale.size * 0.7, whale.size * 0.3);
      ctx.quadraticCurveTo(-whale.size * 0.4, whale.size * 0.4, 0, 0);
      ctx.fill();
      ctx.restore();

      // Dorsal fin
      ctx.beginPath();
      ctx.moveTo(-whale.size * 0.2, -whale.size * 0.4);
      ctx.quadraticCurveTo(0, -whale.size * 0.7, whale.size * 0.2, -whale.size * 0.4);
      ctx.quadraticCurveTo(0, -whale.size * 0.45, -whale.size * 0.2, -whale.size * 0.4);
      ctx.fill();

      // Pectoral fin
      ctx.save();
      ctx.translate(whale.size * 0.2, whale.size * 0.25);
      ctx.rotate(0.5 + Math.sin(whale.phase) * 0.2);
      ctx.beginPath();
      ctx.ellipse(0, whale.size * 0.2, whale.size * 0.15, whale.size * 0.35, 0.3, 0, Math.PI * 2);
      ctx.fill();
      ctx.restore();

      ctx.shadowBlur = 0;

      // Eyes with LASER BEAMS
      const eyeX = whale.size * 0.7;
      const eyeY = -whale.size * 0.05;

      // Eye socket glow
      ctx.fillStyle = whale.color.laser;
      ctx.shadowBlur = 30;
      ctx.shadowColor = whale.color.laser;
      ctx.globalAlpha = 0.8 + beat * 0.2;
      ctx.beginPath();
      ctx.ellipse(eyeX, eyeY, 15, 12, 0, 0, Math.PI * 2);
      ctx.fill();

      // Eye core
      ctx.fillStyle = '#fff';
      ctx.globalAlpha = 1;
      ctx.beginPath();
      ctx.ellipse(eyeX, eyeY, 8, 6, 0, 0, Math.PI * 2);
      ctx.fill();

      // LASER BEAMS from eyes!
      if (whale.laserActive) {
        const laserIntensity = (0.5 + Math.sin(whale.laserPhase) * 0.5) * whale.laserIntensity;
        const laserLength = 800 + Math.sin(whale.laserPhase * 2) * 200;
        const laserAngle = Math.sin(whale.laserPhase * 0.5) * 0.3;

        ctx.save();
        ctx.translate(eyeX + 10, eyeY);
        ctx.rotate(laserAngle);

        // Main laser beam
        const laserGrad = ctx.createLinearGradient(0, 0, laserLength, 0);
        laserGrad.addColorStop(0, whale.color.laser);
        laserGrad.addColorStop(0.3, whale.color.laser);
        laserGrad.addColorStop(1, 'transparent');

        ctx.strokeStyle = laserGrad;
        ctx.lineWidth = 8 + beat * 4;
        ctx.shadowBlur = 30;
        ctx.shadowColor = whale.color.laser;
        ctx.globalAlpha = laserIntensity;
        ctx.beginPath();
        ctx.moveTo(0, 0);
        ctx.lineTo(laserLength, Math.sin(whale.laserPhase * 3) * 50);
        ctx.stroke();

        // Inner bright core
        ctx.strokeStyle = '#fff';
        ctx.lineWidth = 3;
        ctx.globalAlpha = laserIntensity * 0.8;
        ctx.beginPath();
        ctx.moveTo(0, 0);
        ctx.lineTo(laserLength * 0.7, Math.sin(whale.laserPhase * 3) * 50 * 0.7);
        ctx.stroke();

        // Laser particles
        for (let i = 0; i < 5; i++) {
          const px = Math.random() * laserLength * 0.8;
          const py = Math.sin(whale.laserPhase * 3) * 50 * (px / laserLength) + (Math.random() - 0.5) * 20;
          ctx.fillStyle = whale.color.laser;
          ctx.globalAlpha = Math.random() * laserIntensity;
          ctx.beginPath();
          ctx.arc(px, py, 2 + Math.random() * 3, 0, Math.PI * 2);
          ctx.fill();
        }

        ctx.restore();
      }

      // Rave patterns on body (neon stripes)
      ctx.globalAlpha = 0.4 + beat * 0.3;
      ctx.strokeStyle = whale.color.laser;
      ctx.lineWidth = 4;
      ctx.shadowBlur = 15;
      ctx.shadowColor = whale.color.laser;

      for (let i = 0; i < 5; i++) {
        const stripeX = -whale.size * 0.6 + i * whale.size * 0.3;
        const stripePhase = whale.ravePhase + i * 0.5;
        const stripeAlpha = 0.3 + Math.sin(stripePhase) * 0.3;
        ctx.globalAlpha = stripeAlpha;
        ctx.beginPath();
        ctx.moveTo(stripeX, -whale.size * 0.35);
        ctx.quadraticCurveTo(stripeX + 10, 0, stripeX, whale.size * 0.35);
        ctx.stroke();
      }

      // Mouth (happy rave whale)
      ctx.strokeStyle = '#fff';
      ctx.lineWidth = 4;
      ctx.globalAlpha = 0.6;
      ctx.shadowBlur = 0;
      ctx.beginPath();
      ctx.arc(whale.size * 0.85, whale.size * 0.15, 20, 0, Math.PI * 0.7);
      ctx.stroke();

      ctx.restore();
    }

    // Draw Disco Crab
    function drawCrab(crab) {
      ctx.save();
      ctx.translate(crab.x, crab.y);

      const beat = Math.sin(crab.dancePhase * Math.PI);
      const bounce = Math.abs(beat) * 6;

      // Dance bounce!
      ctx.translate(0, -bounce);

      // Glow effect
      ctx.shadowBlur = 20 + crab.hatGlow * 20;
      ctx.shadowColor = crab.color.glow;

      // Draw 6 legs (3 on each side)
      ctx.strokeStyle = crab.color.main;
      ctx.lineWidth = 3;
      ctx.lineCap = 'round';
      ctx.globalAlpha = 0.8;

      for (let i = 0; i < 6; i++) {
        const side = i < 3 ? -1 : 1;
        const index = i % 3;
        const legOffset = Math.sin(crab.legPhase + index * 0.8) * 5;
        const baseAngle = (side * (50 + index * 25)) * Math.PI / 180;

        ctx.beginPath();
        const startX = side * crab.size * 0.6;
        const startY = crab.size * 0.1;
        ctx.moveTo(startX, startY);

        // First segment
        const midX = startX + side * crab.size * 0.4;
        const midY = startY + crab.size * 0.3 + legOffset;
        ctx.lineTo(midX, midY);

        // Second segment (foot)
        const footX = midX + side * crab.size * 0.3;
        const footY = midY + crab.size * 0.2;
        ctx.lineTo(footX, footY);
        ctx.stroke();
      }

      // Draw claws (snapping to the beat!)
      const clawOpen = Math.sin(crab.clawPhase) * 0.3 + 0.3;

      for (let side = -1; side <= 1; side += 2) {
        ctx.save();
        ctx.translate(side * crab.size * 0.8, -crab.size * 0.2);
        ctx.rotate(side * -0.5);

        // Claw arm
        ctx.fillStyle = crab.color.main;
        ctx.beginPath();
        ctx.ellipse(side * crab.size * 0.3, 0, crab.size * 0.35, crab.size * 0.2, side * 0.3, 0, Math.PI * 2);
        ctx.fill();

        // Claw pincers
        ctx.save();
        ctx.translate(side * crab.size * 0.6, 0);

        // Top pincer
        ctx.save();
        ctx.rotate(-clawOpen);
        ctx.beginPath();
        ctx.moveTo(0, 0);
        ctx.lineTo(crab.size * 0.4, -crab.size * 0.15);
        ctx.lineTo(crab.size * 0.35, 0);
        ctx.closePath();
        ctx.fill();
        ctx.restore();

        // Bottom pincer
        ctx.save();
        ctx.rotate(clawOpen);
        ctx.beginPath();
        ctx.moveTo(0, 0);
        ctx.lineTo(crab.size * 0.4, crab.size * 0.15);
        ctx.lineTo(crab.size * 0.35, 0);
        ctx.closePath();
        ctx.fill();
        ctx.restore();

        ctx.restore();
        ctx.restore();
      }

      // Body (shell)
      ctx.fillStyle = crab.color.main;
      ctx.globalAlpha = 0.9;
      ctx.beginPath();
      ctx.ellipse(0, 0, crab.size, crab.size * 0.6, 0, 0, Math.PI * 2);
      ctx.fill();

      // Shell highlight
      ctx.fillStyle = '#fff';
      ctx.globalAlpha = 0.2;
      ctx.beginPath();
      ctx.ellipse(-crab.size * 0.2, -crab.size * 0.2, crab.size * 0.4, crab.size * 0.25, -0.5, 0, Math.PI * 2);
      ctx.fill();

      // Shell pattern (spots)
      ctx.fillStyle = crab.color.hat;
      ctx.globalAlpha = 0.3 + crab.hatGlow * 0.3;
      for (let i = 0; i < 3; i++) {
        ctx.beginPath();
        ctx.arc(-crab.size * 0.3 + i * crab.size * 0.3, 0, crab.size * 0.12, 0, Math.PI * 2);
        ctx.fill();
      }

      // Eyes on stalks
      ctx.fillStyle = crab.color.main;
      ctx.globalAlpha = 1;
      for (let side = -1; side <= 1; side += 2) {
        // Eye stalk
        ctx.strokeStyle = crab.color.main;
        ctx.lineWidth = 4;
        ctx.beginPath();
        ctx.moveTo(side * crab.size * 0.25, -crab.size * 0.4);
        ctx.lineTo(side * crab.size * 0.3, -crab.size * 0.7);
        ctx.stroke();

        // Eye ball
        ctx.fillStyle = '#fff';
        ctx.beginPath();
        ctx.arc(side * crab.size * 0.3, -crab.size * 0.75, 6, 0, Math.PI * 2);
        ctx.fill();

        // Pupil
        ctx.fillStyle = '#000';
        ctx.beginPath();
        ctx.arc(side * crab.size * 0.3, -crab.size * 0.73, 3, 0, Math.PI * 2);
        ctx.fill();
      }

      ctx.shadowBlur = 0;

      // GLOWING PARTY HAT!
      ctx.save();
      ctx.translate(0, -crab.size * 0.5);

      // Hat glow
      ctx.shadowBlur = 30 + crab.hatGlow * 40;
      ctx.shadowColor = crab.color.hat;

      // Hat cone
      ctx.fillStyle = crab.color.hat;
      ctx.globalAlpha = 0.9;
      ctx.beginPath();
      ctx.moveTo(0, -crab.size * 0.8);
      ctx.lineTo(-crab.size * 0.35, 0);
      ctx.lineTo(crab.size * 0.35, 0);
      ctx.closePath();
      ctx.fill();

      // Hat stripes (cycling colors)
      const stripeColors = ['#ff0066', '#00ffff', '#ffff00', '#00ff00', '#ff00ff'];
      ctx.globalAlpha = 0.6;
      for (let i = 0; i < 4; i++) {
        const y = -crab.size * 0.2 - i * crab.size * 0.15;
        const width = crab.size * 0.3 - i * 0.06 * crab.size;
        const colorIndex = Math.floor(crab.dancePhase + i) % stripeColors.length;
        ctx.fillStyle = stripeColors[colorIndex];
        ctx.fillRect(-width, y, width * 2, crab.size * 0.08);
      }

      // Pom pom on top
      ctx.fillStyle = '#fff';
      ctx.shadowBlur = 20;
      ctx.shadowColor = '#fff';
      ctx.globalAlpha = 0.8 + crab.hatGlow * 0.2;
      ctx.beginPath();
      ctx.arc(0, -crab.size * 0.85, crab.size * 0.15, 0, Math.PI * 2);
      ctx.fill();

      ctx.restore();
      ctx.restore();
    }

    // Draw Submarine
    function drawSubmarine() {
      ctx.save();
      ctx.translate(submarine.x, submarine.y);
      ctx.rotate(submarine.angle);

      const size = submarine.size;
      const speed = Math.sqrt(submarine.vx * submarine.vx + submarine.vy * submarine.vy);

      // LASER HEADLIGHTS!
      ctx.save();
      ctx.translate(size * 0.9, 0);

      // Main laser beams
      const laserLength = 300 + Math.sin(time * 10) * 50;
      const laserGrad = ctx.createLinearGradient(0, 0, laserLength, 0);
      laserGrad.addColorStop(0, '#ffff00');
      laserGrad.addColorStop(0.5, 'rgba(255, 255, 0, 0.5)');
      laserGrad.addColorStop(1, 'transparent');

      ctx.shadowBlur = 30;
      ctx.shadowColor = '#ffff00';
      ctx.globalAlpha = submarine.laserIntensity;

      // Upper laser
      ctx.strokeStyle = laserGrad;
      ctx.lineWidth = 6;
      ctx.beginPath();
      ctx.moveTo(0, -8);
      ctx.lineTo(laserLength, -15 + Math.sin(time * 8) * 10);
      ctx.stroke();

      // Lower laser
      ctx.beginPath();
      ctx.moveTo(0, 8);
      ctx.lineTo(laserLength, 15 + Math.sin(time * 8 + 1) * 10);
      ctx.stroke();

      // Inner bright core
      ctx.strokeStyle = '#fff';
      ctx.lineWidth = 2;
      ctx.globalAlpha = 0.8;
      ctx.beginPath();
      ctx.moveTo(0, -8);
      ctx.lineTo(laserLength * 0.6, -15 + Math.sin(time * 8) * 10 * 0.6);
      ctx.stroke();
      ctx.beginPath();
      ctx.moveTo(0, 8);
      ctx.lineTo(laserLength * 0.6, 15 + Math.sin(time * 8 + 1) * 10 * 0.6);
      ctx.stroke();

      ctx.restore();

      // Submarine glow
      ctx.shadowBlur = 25;
      ctx.shadowColor = 'rgba(255, 255, 0, 0.8)';

      // Main hull (yellow)
      ctx.fillStyle = '#ffff00';
      ctx.globalAlpha = 0.9;
      ctx.beginPath();
      ctx.ellipse(0, 0, size, size * 0.4, 0, 0, Math.PI * 2);
      ctx.fill();

      // Hull highlight
      ctx.fillStyle = '#fff';
      ctx.globalAlpha = 0.3;
      ctx.beginPath();
      ctx.ellipse(-size * 0.2, -size * 0.15, size * 0.5, size * 0.15, -0.2, 0, Math.PI * 2);
      ctx.fill();

      // Conning tower (top)
      ctx.fillStyle = '#ffff00';
      ctx.globalAlpha = 0.9;
      ctx.beginPath();
      ctx.ellipse(0, -size * 0.35, size * 0.25, size * 0.2, 0, 0, Math.PI * 2);
      ctx.fill();

      // Periscope
      ctx.strokeStyle = '#ffff00';
      ctx.lineWidth = 4;
      ctx.beginPath();
      ctx.moveTo(0, -size * 0.5);
      ctx.lineTo(0, -size * 0.75);
      ctx.lineTo(size * 0.1, -size * 0.75);
      ctx.stroke();

      ctx.shadowBlur = 0;

      // Windows (portholes)
      ctx.fillStyle = '#00ffff';
      ctx.shadowBlur = 15;
      ctx.shadowColor = '#00ffff';
      ctx.globalAlpha = 0.8;
      for (let i = -1; i <= 1; i++) {
        ctx.beginPath();
        ctx.arc(i * size * 0.35, 0, size * 0.1, 0, Math.PI * 2);
        ctx.fill();

        // Window shine
        ctx.fillStyle = '#fff';
        ctx.globalAlpha = 0.4;
        ctx.beginPath();
        ctx.arc(i * size * 0.35 - 3, -3, size * 0.04, 0, Math.PI * 2);
        ctx.fill();
        ctx.fillStyle = '#00ffff';
        ctx.globalAlpha = 0.8;
      }

      // Headlight housings
      ctx.fillStyle = '#cc9900';
      ctx.shadowBlur = 0;
      ctx.globalAlpha = 1;
      ctx.beginPath();
      ctx.arc(size * 0.9, -8, 8, 0, Math.PI * 2);
      ctx.fill();
      ctx.beginPath();
      ctx.arc(size * 0.9, 8, 8, 0, Math.PI * 2);
      ctx.fill();

      // Headlight glow
      ctx.fillStyle = '#ffff00';
      ctx.shadowBlur = 20;
      ctx.shadowColor = '#ffff00';
      ctx.beginPath();
      ctx.arc(size * 0.9, -8, 5, 0, Math.PI * 2);
      ctx.fill();
      ctx.beginPath();
      ctx.arc(size * 0.9, 8, 5, 0, Math.PI * 2);
      ctx.fill();

      // Propeller at back
      ctx.save();
      ctx.translate(-size * 0.95, 0);

      // Propeller hub
      ctx.fillStyle = '#888';
      ctx.shadowBlur = 0;
      ctx.beginPath();
      ctx.arc(0, 0, 8, 0, Math.PI * 2);
      ctx.fill();

      // Propeller blades
      ctx.fillStyle = '#aaa';
      for (let i = 0; i < 4; i++) {
        ctx.save();
        ctx.rotate(submarine.propellerPhase + i * Math.PI / 2);
        ctx.beginPath();
        ctx.ellipse(12, 0, 15, 5, 0.3, 0, Math.PI * 2);
        ctx.fill();
        ctx.restore();
      }

      ctx.restore();

      // Tail fin
      ctx.fillStyle = '#ffff00';
      ctx.globalAlpha = 0.9;
      ctx.shadowBlur = 15;
      ctx.shadowColor = 'rgba(255, 255, 0, 0.5)';
      ctx.beginPath();
      ctx.moveTo(-size * 0.7, 0);
      ctx.lineTo(-size * 1.1, -size * 0.25);
      ctx.lineTo(-size * 1.1, size * 0.25);
      ctx.closePath();
      ctx.fill();

      ctx.restore();
    }

    // Draw
    function draw() {
      // Deep sea gradient background
      const gradient = ctx.createLinearGradient(0, 0, 0, H);
      gradient.addColorStop(0, '#000510');
      gradient.addColorStop(0.3, '#001030');
      gradient.addColorStop(0.7, '#001525');
      gradient.addColorStop(1, '#000a15');
      ctx.fillStyle = gradient;
      ctx.fillRect(0, 0, W, H);

      // Light rays from above
      ctx.save();
      for (let i = 0; i < 5; i++) {
        const x = W * (0.2 + i * 0.15) + Math.sin(time * 0.5 + i) * 30;
        const rayGradient = ctx.createLinearGradient(x, 0, x + 100, H);
        rayGradient.addColorStop(0, 'rgba(0, 150, 255, 0.03)');
        rayGradient.addColorStop(0.5, 'rgba(0, 100, 200, 0.01)');
        rayGradient.addColorStop(1, 'transparent');

        ctx.fillStyle = rayGradient;
        ctx.beginPath();
        ctx.moveTo(x, 0);
        ctx.lineTo(x + 150, H);
        ctx.lineTo(x - 50, H);
        ctx.closePath();
        ctx.fill();
      }
      ctx.restore();

      // Draw ambient particles
      ctx.fillStyle = '#0ff';
      particles.forEach(p => {
        ctx.globalAlpha = p.alpha;
        ctx.beginPath();
        ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
        ctx.fill();
      });
      ctx.globalAlpha = 1;

      // Draw seaweed (behind everything)
      seaweeds.forEach(drawSeaweed);

      // Draw rave whales (massive, in back)
      whales.forEach(drawWhale);

      // Draw bubbles
      bubbles.forEach(bubble => {
        ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
        ctx.fillStyle = 'rgba(0, 255, 255, 0.1)';
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.arc(bubble.x, bubble.y, bubble.size, 0, Math.PI * 2);
        ctx.fill();
        ctx.stroke();

        // Highlight
        ctx.fillStyle = 'rgba(255, 255, 255, 0.4)';
        ctx.beginPath();
        ctx.arc(bubble.x - bubble.size * 0.3, bubble.y - bubble.size * 0.3, bubble.size * 0.3, 0, Math.PI * 2);
        ctx.fill();
      });

      // Draw DJ octopuses
      octopuses.forEach(drawOctopus);

      // Draw disco crabs (on the sandy bottom)
      crabs.forEach(drawCrab);

      // Draw submarine (player controlled)
      drawSubmarine();

      // Draw jellyfish
      jellyfish.forEach(drawJellyfish);

      // Sandy bottom gradient
      const sandGradient = ctx.createLinearGradient(0, H - 60, 0, H);
      sandGradient.addColorStop(0, 'transparent');
      sandGradient.addColorStop(1, 'rgba(20, 15, 10, 0.8)');
      ctx.fillStyle = sandGradient;
      ctx.fillRect(0, H - 60, W, 60);
    }

    // Controls
    document.getElementById('add-whale').addEventListener('click', () => {
      whales.push(createWhale());
    });

    document.getElementById('add-crab').addEventListener('click', () => {
      crabs.push(createCrab());
    });

    document.getElementById('add-jelly').addEventListener('click', () => {
      jellyfish.push(createJellyfish(W / 2, H / 2));
    });

    document.getElementById('add-octopus').addEventListener('click', () => {
      octopuses.push(createOctopus(Math.random() * (W - 200) + 100, H - 180));
    });

    document.getElementById('add-seaweed').addEventListener('click', () => {
      seaweeds.push(createSeaweed(Math.random() * W));
    });

    document.getElementById('toggle-bubbles').addEventListener('click', () => {
      bubblesEnabled = !bubblesEnabled;
    });

    // Click to add jellyfish
    canvas.addEventListener('click', e => {
      jellyfish.push(createJellyfish(e.clientX, e.clientY));
    });

    // Submarine keyboard controls
    document.addEventListener('keydown', e => {
      if (e.key === 'ArrowUp' || e.key === 'w' || e.key === 'W') subInput.up = true;
      if (e.key === 'ArrowDown' || e.key === 's' || e.key === 'S') subInput.down = true;
      if (e.key === 'ArrowLeft' || e.key === 'a' || e.key === 'A') subInput.left = true;
      if (e.key === 'ArrowRight' || e.key === 'd' || e.key === 'D') subInput.right = true;
    });

    document.addEventListener('keyup', e => {
      if (e.key === 'ArrowUp' || e.key === 'w' || e.key === 'W') subInput.up = false;
      if (e.key === 'ArrowDown' || e.key === 's' || e.key === 'S') subInput.down = false;
      if (e.key === 'ArrowLeft' || e.key === 'a' || e.key === 'A') subInput.left = false;
      if (e.key === 'ArrowRight' || e.key === 'd' || e.key === 'D') subInput.right = false;
    });

    // Submarine touch/mouse button controls
    function setupSubBtn(id, key) {
      const btn = document.getElementById(id);

      const activate = () => {
        subInput[key] = true;
        btn.classList.add('active');
      };
      const deactivate = () => {
        subInput[key] = false;
        btn.classList.remove('active');
      };

      btn.addEventListener('mousedown', activate);
      btn.addEventListener('mouseup', deactivate);
      btn.addEventListener('mouseleave', deactivate);
      btn.addEventListener('touchstart', e => { e.preventDefault(); activate(); });
      btn.addEventListener('touchend', e => { e.preventDefault(); deactivate(); });
    }

    setupSubBtn('sub-up', 'up');
    setupSubBtn('sub-down', 'down');
    setupSubBtn('sub-left', 'left');
    setupSubBtn('sub-right', 'right');

    // Game loop
    let lastTime = 0;
    function gameLoop(timestamp) {
      const dt = Math.min((timestamp - lastTime) / 1000, 0.05);
      lastTime = timestamp;

      update(dt);
      draw();

      requestAnimationFrame(gameLoop);
    }

    init();
    requestAnimationFrame(gameLoop);
  </script>
</body>
</html>
