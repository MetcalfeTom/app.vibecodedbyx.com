<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SubmarineCraft - Underwater Block Adventure</title>
    <link rel="icon" href="https://emojicdn.elk.sh/üö¢">

    <meta property="og:title" content="SubmarineCraft - Underwater Block Adventure">
    <meta property="og:description" content="Navigate your submarine through underwater caves, collect blocks, avoid mines">
    <meta property="og:url" content="https://app.vibecodedbyx.com/submarine-craft">
    <meta property="og:image" content="https://emojicdn.elk.sh/üö¢.png">

    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background: linear-gradient(180deg, #001a33 0%, #003d5c 50%, #004d73 100%);
            font-family: 'Courier New', monospace;
            overflow: hidden;
            color: #fff;
            user-select: none;
        }

        .game-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            height: 100vh;
            padding: 10px;
        }

        .header {
            background: rgba(0, 20, 40, 0.8);
            padding: 12px 20px;
            border-radius: 8px;
            margin-bottom: 10px;
            width: 100%;
            max-width: 800px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border: 2px solid #4a90a4;
            box-shadow: 0 0 20px rgba(74, 144, 164, 0.3);
        }

        .title {
            font-size: 24px;
            font-weight: bold;
            color: #66d9ff;
            text-shadow: 0 0 10px rgba(102, 217, 255, 0.5);
        }

        .stats {
            display: flex;
            gap: 20px;
            font-size: 16px;
        }

        .stat {
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .stat-label {
            color: #8dd3ff;
        }

        .stat-value {
            color: #ffeb3b;
            font-weight: bold;
        }

        #canvas {
            border: 4px solid #2d5f7a;
            background: #001a2e;
            box-shadow: 0 0 30px rgba(0, 100, 150, 0.5);
            image-rendering: pixelated;
            image-rendering: crisp-edges;
        }

        .controls {
            margin-top: 10px;
            background: rgba(0, 20, 40, 0.8);
            padding: 12px 20px;
            border-radius: 8px;
            border: 2px solid #4a90a4;
            text-align: center;
            max-width: 800px;
        }

        .controls p {
            margin: 5px 0;
            color: #8dd3ff;
            font-size: 14px;
        }

        .game-over {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 20, 40, 0.95);
            padding: 40px;
            border-radius: 12px;
            border: 3px solid #ff6b6b;
            display: none;
            text-align: center;
            z-index: 100;
        }

        .game-over.show {
            display: block;
        }

        .game-over h2 {
            color: #ff6b6b;
            font-size: 36px;
            margin-bottom: 20px;
        }

        .game-over p {
            color: #8dd3ff;
            font-size: 18px;
            margin: 10px 0;
        }

        .btn {
            background: linear-gradient(180deg, #4a90a4, #2d5f7a);
            color: white;
            border: 2px solid #66d9ff;
            padding: 12px 30px;
            font-size: 16px;
            font-family: 'Courier New', monospace;
            font-weight: bold;
            cursor: pointer;
            border-radius: 6px;
            margin-top: 20px;
            transition: all 0.2s;
        }

        .btn:hover {
            background: linear-gradient(180deg, #5aa5ba, #3d7090);
            box-shadow: 0 0 15px rgba(102, 217, 255, 0.5);
        }

        .back-link {
            position: absolute;
            top: 10px;
            left: 10px;
            color: #66d9ff;
            text-decoration: none;
            font-size: 14px;
            background: rgba(0, 20, 40, 0.8);
            padding: 8px 14px;
            border-radius: 6px;
            border: 2px solid #4a90a4;
        }

        .back-link:hover {
            background: rgba(0, 30, 50, 0.9);
        }
    </style>
</head>
<body>
    <a href="https://www.vibecodedbyx.com" class="back-link">‚Üê Back to stream</a>

    <div class="game-container">
        <div class="header">
            <div class="title">üö¢ SubmarineCraft</div>
            <div class="stats">
                <div class="stat">
                    <span class="stat-label">‚ö° Air:</span>
                    <span class="stat-value" id="air">100</span>
                </div>
                <div class="stat">
                    <span class="stat-label">üíé Blocks:</span>
                    <span class="stat-value" id="blocks">0</span>
                </div>
                <div class="stat">
                    <span class="stat-label">üìè Depth:</span>
                    <span class="stat-value" id="depth">0</span>
                </div>
            </div>
        </div>

        <canvas id="canvas" width="800" height="600"></canvas>

        <div class="controls">
            <p><strong>Controls:</strong> Arrow Keys or WASD to move submarine ‚Ä¢ Collect üíé blocks ‚Ä¢ Avoid üí£ mines ‚Ä¢ Refill air at üü¢ bubbles</p>
        </div>
    </div>

    <div class="game-over" id="gameOver">
        <h2>üíÄ GAME OVER</h2>
        <p>Final Depth: <span id="finalDepth">0</span>m</p>
        <p>Blocks Collected: <span id="finalBlocks">0</span></p>
        <button class="btn" onclick="restart()">üîÑ Restart</button>
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const W = canvas.width;
        const H = canvas.height;

        // Block size
        const BLOCK = 20;
        const COLS = W / BLOCK;
        const ROWS = H / BLOCK;

        // Game state
        let submarine = {
            x: 100,
            y: H / 2,
            vx: 0,
            vy: 0,
            width: 40,
            height: 24,
            speed: 3,
            air: 100,
            blocks: 0
        };

        let camera = { y: 0 };
        let world = [];
        let collectibles = [];
        let mines = [];
        let airBubbles = [];
        let gameRunning = true;
        let keys = {};

        // World generation
        function generateWorld() {
            world = [];
            collectibles = [];
            mines = [];
            airBubbles = [];

            // Generate cave-like terrain
            for (let row = 0; row < 100; row++) {
                const worldRow = [];
                const leftWall = Math.floor(2 + Math.sin(row * 0.3) * 3 + Math.random() * 2);
                const rightWall = Math.floor(COLS - 5 - Math.sin(row * 0.4) * 3 - Math.random() * 2);

                for (let col = 0; col < COLS; col++) {
                    if (col < leftWall || col > rightWall) {
                        worldRow.push(1); // Wall
                    } else {
                        worldRow.push(0); // Empty

                        // Spawn collectibles
                        if (Math.random() < 0.02 && row > 5) {
                            collectibles.push({ x: col * BLOCK, y: row * BLOCK, type: 'diamond' });
                        }

                        // Spawn mines
                        if (Math.random() < 0.01 && row > 10) {
                            mines.push({ x: col * BLOCK, y: row * BLOCK, radius: 12 });
                        }

                        // Spawn air bubbles
                        if (Math.random() < 0.008 && row > 8) {
                            airBubbles.push({ x: col * BLOCK, y: row * BLOCK, radius: 15 });
                        }
                    }
                }
                world.push(worldRow);
            }
        }

        // Initialize
        generateWorld();

        // Input handling
        window.addEventListener('keydown', (e) => {
            keys[e.key.toLowerCase()] = true;
            if (['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight', ' '].includes(e.key)) {
                e.preventDefault();
            }
        });

        window.addEventListener('keyup', (e) => {
            keys[e.key.toLowerCase()] = false;
        });

        // Check collision with blocks
        function checkCollision(x, y, w, h) {
            const row = Math.floor((y + camera.y) / BLOCK);
            const col = Math.floor(x / BLOCK);

            // Check all corners
            const corners = [
                { r: Math.floor((y + camera.y) / BLOCK), c: Math.floor(x / BLOCK) },
                { r: Math.floor((y + camera.y) / BLOCK), c: Math.floor((x + w) / BLOCK) },
                { r: Math.floor((y + h + camera.y) / BLOCK), c: Math.floor(x / BLOCK) },
                { r: Math.floor((y + h + camera.y) / BLOCK), c: Math.floor((x + w) / BLOCK) }
            ];

            for (let corner of corners) {
                if (corner.r >= 0 && corner.r < world.length && corner.c >= 0 && corner.c < COLS) {
                    if (world[corner.r][corner.c] === 1) {
                        return true;
                    }
                }
            }
            return false;
        }

        // Game loop
        function update() {
            if (!gameRunning) return;

            // Movement
            submarine.vx = 0;
            submarine.vy = 0;

            if (keys['arrowleft'] || keys['a']) submarine.vx = -submarine.speed;
            if (keys['arrowright'] || keys['d']) submarine.vx = submarine.speed;
            if (keys['arrowup'] || keys['w']) submarine.vy = -submarine.speed;
            if (keys['arrowdown'] || keys['s']) submarine.vy = submarine.speed;

            // Try to move
            const newX = submarine.x + submarine.vx;
            const newY = submarine.y + submarine.vy;

            // Check boundaries and collisions
            if (newX >= 0 && newX + submarine.width <= W) {
                if (!checkCollision(newX, submarine.y, submarine.width, submarine.height)) {
                    submarine.x = newX;
                }
            }

            if (!checkCollision(submarine.x, newY, submarine.width, submarine.height)) {
                submarine.y = newY;
            }

            // Camera follows submarine
            const targetCameraY = submarine.y + camera.y - H / 2;
            camera.y += (targetCameraY - camera.y) * 0.1;
            camera.y = Math.max(0, camera.y);

            // Air depletion
            submarine.air -= 0.05;
            if (submarine.air <= 0) {
                gameOver();
            }

            // Collect diamonds
            const subCenterX = submarine.x + submarine.width / 2;
            const subCenterY = submarine.y + camera.y + submarine.height / 2;

            collectibles = collectibles.filter(item => {
                const dx = subCenterX - (item.x + BLOCK / 2);
                const dy = subCenterY - (item.y + BLOCK / 2);
                const dist = Math.sqrt(dx * dx + dy * dy);

                if (dist < 25) {
                    submarine.blocks++;
                    return false;
                }
                return true;
            });

            // Check mines collision
            for (let mine of mines) {
                const dx = subCenterX - (mine.x + BLOCK / 2);
                const dy = subCenterY - (mine.y + BLOCK / 2);
                const dist = Math.sqrt(dx * dx + dy * dy);

                if (dist < mine.radius + 15) {
                    gameOver();
                    break;
                }
            }

            // Collect air bubbles
            airBubbles = airBubbles.filter(bubble => {
                const dx = subCenterX - (bubble.x + BLOCK / 2);
                const dy = subCenterY - (bubble.y + BLOCK / 2);
                const dist = Math.sqrt(dx * dx + dy * dy);

                if (dist < bubble.radius + 15) {
                    submarine.air = Math.min(100, submarine.air + 30);
                    return false;
                }
                return true;
            });

            // Update UI
            document.getElementById('air').textContent = Math.floor(submarine.air);
            document.getElementById('blocks').textContent = submarine.blocks;
            document.getElementById('depth').textContent = Math.floor(camera.y / BLOCK);
        }

        function draw() {
            // Clear
            ctx.fillStyle = '#001a2e';
            ctx.fillRect(0, 0, W, H);

            // Draw water effect
            ctx.fillStyle = 'rgba(0, 100, 150, 0.1)';
            for (let i = 0; i < 5; i++) {
                ctx.fillRect(0, (camera.y % 40) + i * 40 - 40, W, 20);
            }

            // Draw world blocks (stone/cave walls)
            const startRow = Math.max(0, Math.floor(camera.y / BLOCK) - 2);
            const endRow = Math.min(world.length, Math.floor((camera.y + H) / BLOCK) + 2);

            for (let row = startRow; row < endRow; row++) {
                for (let col = 0; col < COLS; col++) {
                    if (world[row][col] === 1) {
                        const y = row * BLOCK - camera.y;
                        const x = col * BLOCK;

                        // Draw block with Minecraft-style shading
                        ctx.fillStyle = '#6b6b6b';
                        ctx.fillRect(x, y, BLOCK, BLOCK);

                        ctx.fillStyle = '#8b8b8b';
                        ctx.fillRect(x, y, BLOCK - 2, 2);
                        ctx.fillRect(x, y, 2, BLOCK - 2);

                        ctx.fillStyle = '#4b4b4b';
                        ctx.fillRect(x + BLOCK - 2, y, 2, BLOCK);
                        ctx.fillRect(x, y + BLOCK - 2, BLOCK, 2);

                        // Block outline
                        ctx.strokeStyle = '#2b2b2b';
                        ctx.strokeRect(x, y, BLOCK, BLOCK);
                    }
                }
            }

            // Draw collectibles (diamonds)
            ctx.fillStyle = '#00ffff';
            ctx.strokeStyle = '#00aaaa';
            ctx.lineWidth = 2;
            collectibles.forEach(item => {
                const y = item.y - camera.y;
                if (y > -BLOCK && y < H + BLOCK) {
                    ctx.beginPath();
                    ctx.moveTo(item.x + BLOCK / 2, y + 4);
                    ctx.lineTo(item.x + BLOCK - 4, y + BLOCK / 2);
                    ctx.lineTo(item.x + BLOCK / 2, y + BLOCK - 4);
                    ctx.lineTo(item.x + 4, y + BLOCK / 2);
                    ctx.closePath();
                    ctx.fill();
                    ctx.stroke();
                }
            });

            // Draw mines
            ctx.fillStyle = '#ff3333';
            ctx.strokeStyle = '#aa0000';
            mines.forEach(mine => {
                const y = mine.y - camera.y;
                if (y > -BLOCK && y < H + BLOCK) {
                    ctx.beginPath();
                    ctx.arc(mine.x + BLOCK / 2, y + BLOCK / 2, mine.radius, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.stroke();

                    // Spikes
                    ctx.beginPath();
                    for (let i = 0; i < 8; i++) {
                        const angle = (i / 8) * Math.PI * 2;
                        ctx.moveTo(mine.x + BLOCK / 2, y + BLOCK / 2);
                        ctx.lineTo(
                            mine.x + BLOCK / 2 + Math.cos(angle) * (mine.radius + 4),
                            y + BLOCK / 2 + Math.sin(angle) * (mine.radius + 4)
                        );
                    }
                    ctx.stroke();
                }
            });

            // Draw air bubbles
            ctx.fillStyle = 'rgba(100, 200, 255, 0.6)';
            ctx.strokeStyle = 'rgba(150, 220, 255, 0.8)';
            airBubbles.forEach(bubble => {
                const y = bubble.y - camera.y;
                if (y > -BLOCK && y < H + BLOCK) {
                    ctx.beginPath();
                    ctx.arc(bubble.x + BLOCK / 2, y + BLOCK / 2, bubble.radius, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.stroke();
                }
            });

            // Draw submarine
            const subY = submarine.y;

            // Sub body (yellow)
            ctx.fillStyle = '#ffeb3b';
            ctx.fillRect(submarine.x, subY, submarine.width, submarine.height);

            // Window (blue tint)
            ctx.fillStyle = '#4a90a4';
            ctx.fillRect(submarine.x + 8, subY + 6, 12, 12);

            // Propeller (gray)
            ctx.fillStyle = '#666';
            ctx.fillRect(submarine.x + submarine.width, subY + 8, 6, 8);

            // Outline
            ctx.strokeStyle = '#d4a900';
            ctx.lineWidth = 2;
            ctx.strokeRect(submarine.x, subY, submarine.width, submarine.height);

            // Top periscope
            ctx.fillStyle = '#666';
            ctx.fillRect(submarine.x + 15, subY - 6, 3, 8);

            // Air indicator on submarine
            if (submarine.air < 30) {
                ctx.fillStyle = submarine.air < 15 ? '#ff3333' : '#ffaa00';
                ctx.fillRect(submarine.x + 2, subY - 4, submarine.width - 4, 2);
            }
        }

        function gameLoop() {
            update();
            draw();
            if (gameRunning) {
                requestAnimationFrame(gameLoop);
            }
        }

        function gameOver() {
            gameRunning = false;
            document.getElementById('finalDepth').textContent = Math.floor(camera.y / BLOCK);
            document.getElementById('finalBlocks').textContent = submarine.blocks;
            document.getElementById('gameOver').classList.add('show');
        }

        function restart() {
            submarine = {
                x: 100,
                y: H / 2,
                vx: 0,
                vy: 0,
                width: 40,
                height: 24,
                speed: 3,
                air: 100,
                blocks: 0
            };
            camera = { y: 0 };
            gameRunning = true;
            generateWorld();
            document.getElementById('gameOver').classList.remove('show');
            gameLoop();
        }

        // Start game
        gameLoop();
    </script>
</body>
</html>
