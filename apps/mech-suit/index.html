<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>IRON MECH DEFENSE</title>
  <link rel="icon" href="https://emojicdn.elk.sh/ðŸ¤–">
  <meta property="og:title" content="IRON MECH DEFENSE">
  <meta property="og:description" content="Encase yourself in heavy iron armor and block those paws!">
  <meta property="og:url" content="https://sloppy.live/mech-suit">
  <meta property="og:image" content="https://emojicdn.elk.sh/ðŸ¦¾?style=apple&size=512">
  <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@700;900&family=Roboto+Mono:wght@400;700&display=swap" rel="stylesheet">
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      min-height: 100vh;
      background: linear-gradient(180deg, #1a1a2e 0%, #16213e 50%, #0f0f23 100%);
      font-family: 'Roboto Mono', monospace;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      overflow: hidden;
    }
    .game-container {
      position: relative;
      width: 100vw;
      height: 100vh;
    }
    canvas { display: block; width: 100%; height: 100%; }
    .hud {
      position: absolute;
      top: 15px;
      left: 20px;
      right: 20px;
      display: flex;
      justify-content: space-between;
      pointer-events: none;
      z-index: 10;
    }
    .title {
      font-family: 'Orbitron', sans-serif;
      font-size: 1.3rem;
      color: #4ecdc4;
      text-shadow: 0 0 20px rgba(78,205,196,0.5);
      letter-spacing: 0.1em;
    }
    .stats {
      font-size: 0.9rem;
      color: #ff6b6b;
      text-shadow: 0 0 10px rgba(255,107,107,0.5);
    }
    .armor-bar {
      position: absolute;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      width: 300px;
      height: 30px;
      background: rgba(0,0,0,0.5);
      border: 2px solid #4ecdc4;
      border-radius: 5px;
      overflow: hidden;
    }
    .armor-fill {
      height: 100%;
      background: linear-gradient(90deg, #4ecdc4, #45b7aa);
      transition: width 0.3s;
      box-shadow: 0 0 20px rgba(78,205,196,0.5);
    }
    .armor-label {
      position: absolute;
      bottom: 55px;
      left: 50%;
      transform: translateX(-50%);
      font-family: 'Orbitron', sans-serif;
      font-size: 0.8rem;
      color: #4ecdc4;
      letter-spacing: 0.2em;
    }
    .instructions {
      position: absolute;
      top: 50px;
      left: 50%;
      transform: translateX(-50%);
      font-size: 0.75rem;
      color: rgba(255,255,255,0.4);
      text-align: center;
    }
    .back-link {
      position: fixed;
      bottom: 5px;
      right: 10px;
      color: #4ecdc4;
      text-decoration: none;
      font-size: 0.7rem;
      opacity: 0.5;
    }
  </style>
</head>
<body>
  <div class="game-container">
    <canvas id="canvas"></canvas>
    <div class="hud">
      <div class="title">ðŸ¤– IRON MECH DEFENSE</div>
      <div class="stats">BLOCKED: <span id="blocked">0</span></div>
    </div>
    <div class="instructions">Click to add armor plates â€¢ Block the incoming paws!</div>
    <div class="armor-label">ARMOR INTEGRITY</div>
    <div class="armor-bar">
      <div class="armor-fill" id="armorFill" style="width: 0%"></div>
    </div>
  </div>
  <a href="https://sloppy.live" class="back-link">sloppy.live</a>

<script>
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');

let frameCount = 0;
let armorLevel = 0;
let pawsBlocked = 0;
let shakeIntensity = 0;
let armorPieces = [];
let paws = [];
let sparks = [];
let clankTexts = [];

const mech = {
  x: 0, y: 0,
  bodyWidth: 120,
  bodyHeight: 180
};

function resize() {
  canvas.width = window.innerWidth;
  canvas.height = window.innerHeight;
  mech.x = canvas.width / 2;
  mech.y = canvas.height / 2;
}

function addArmorPiece(x, y) {
  const angle = Math.atan2(y - mech.y, x - mech.x);
  const distance = 80 + Math.random() * 40;
  
  armorPieces.push({
    angle,
    distance,
    width: 40 + Math.random() * 30,
    height: 30 + Math.random() * 20,
    thickness: 0,
    targetThickness: 8 + Math.random() * 8,
    glow: 1,
    rivets: Math.floor(Math.random() * 3) + 2
  });
  
  armorLevel = Math.min(100, armorLevel + 5);
  updateArmorBar();
  
  // Spawn sparks
  for (let i = 0; i < 10; i++) {
    sparks.push({
      x: mech.x + Math.cos(angle) * distance,
      y: mech.y + Math.sin(angle) * distance,
      vx: (Math.random() - 0.5) * 10,
      vy: (Math.random() - 0.5) * 10,
      life: 1,
      color: Math.random() > 0.5 ? '#ffaa00' : '#4ecdc4'
    });
  }
  
  shakeIntensity = 5;
}

function spawnPaw() {
  const side = Math.floor(Math.random() * 4);
  let x, y, vx, vy;
  
  switch(side) {
    case 0: x = Math.random() * canvas.width; y = -50; vx = (Math.random()-0.5)*2; vy = 4 + Math.random()*3; break;
    case 1: x = canvas.width + 50; y = Math.random() * canvas.height; vx = -4 - Math.random()*3; vy = (Math.random()-0.5)*2; break;
    case 2: x = Math.random() * canvas.width; y = canvas.height + 50; vx = (Math.random()-0.5)*2; vy = -4 - Math.random()*3; break;
    case 3: x = -50; y = Math.random() * canvas.height; vx = 4 + Math.random()*3; vy = (Math.random()-0.5)*2; break;
  }
  
  paws.push({ x, y, vx, vy, rotation: Math.random() * Math.PI * 2, size: 30 + Math.random() * 20 });
}

function checkPawCollision(paw) {
  const dx = paw.x - mech.x;
  const dy = paw.y - mech.y;
  const dist = Math.sqrt(dx*dx + dy*dy);
  
  // Check armor collision
  for (const armor of armorPieces) {
    const ax = mech.x + Math.cos(armor.angle) * armor.distance;
    const ay = mech.y + Math.sin(armor.angle) * armor.distance;
    const aDist = Math.sqrt((paw.x-ax)**2 + (paw.y-ay)**2);
    
    if (aDist < armor.width/2 + paw.size/2) {
      return 'blocked';
    }
  }
  
  // Check body collision
  if (dist < 80) {
    return 'hit';
  }
  
  return null;
}

function spawnBlockEffect(x, y) {
  shakeIntensity = 15;
  pawsBlocked++;
  document.getElementById('blocked').textContent = pawsBlocked;
  
  // Metal sparks
  for (let i = 0; i < 20; i++) {
    sparks.push({
      x, y,
      vx: (Math.random() - 0.5) * 15,
      vy: (Math.random() - 0.5) * 15,
      life: 1,
      color: ['#ffaa00', '#ff6600', '#ffffff', '#4ecdc4'][Math.floor(Math.random()*4)]
    });
  }
  
  // Clank text
  clankTexts.push({
    x, y,
    text: ['CLANK!', 'BLOCKED!', 'DENIED!', 'DEFLECTED!'][Math.floor(Math.random()*4)],
    alpha: 1,
    scale: 1,
    vy: -2
  });
}

function update() {
  frameCount++;
  
  // Spawn paws
  const spawnRate = Math.max(30, 80 - Math.floor(pawsBlocked / 5));
  if (frameCount % spawnRate === 0) {
    spawnPaw();
  }
  
  // Update paws
  for (let i = paws.length - 1; i >= 0; i--) {
    const paw = paws[i];
    paw.x += paw.vx;
    paw.y += paw.vy;
    paw.rotation += 0.1;
    
    const collision = checkPawCollision(paw);
    if (collision === 'blocked') {
      spawnBlockEffect(paw.x, paw.y);
      paws.splice(i, 1);
    } else if (collision === 'hit') {
      armorLevel = Math.max(0, armorLevel - 10);
      updateArmorBar();
      shakeIntensity = 20;
      paws.splice(i, 1);
    } else if (paw.x < -100 || paw.x > canvas.width+100 || paw.y < -100 || paw.y > canvas.height+100) {
      paws.splice(i, 1);
    }
  }
  
  // Update armor
  for (const armor of armorPieces) {
    armor.thickness += (armor.targetThickness - armor.thickness) * 0.1;
    armor.glow *= 0.95;
  }
  
  // Update sparks
  for (let i = sparks.length - 1; i >= 0; i--) {
    const s = sparks[i];
    s.x += s.vx;
    s.y += s.vy;
    s.vy += 0.3;
    s.vx *= 0.98;
    s.life -= 0.03;
    if (s.life <= 0) sparks.splice(i, 1);
  }
  
  // Update clank texts
  for (let i = clankTexts.length - 1; i >= 0; i--) {
    const t = clankTexts[i];
    t.y += t.vy;
    t.alpha -= 0.02;
    t.scale += 0.02;
    if (t.alpha <= 0) clankTexts.splice(i, 1);
  }
  
  shakeIntensity *= 0.9;
}

function drawPurpleBody() {
  ctx.save();
  ctx.translate(mech.x, mech.y);
  
  // Body glow
  const glow = ctx.createRadialGradient(0, 0, 30, 0, 0, 100);
  glow.addColorStop(0, 'rgba(138, 43, 226, 0.3)');
  glow.addColorStop(1, 'transparent');
  ctx.fillStyle = glow;
  ctx.beginPath();
  ctx.arc(0, 0, 100, 0, Math.PI * 2);
  ctx.fill();
  
  // Main body
  const bodyGrad = ctx.createRadialGradient(0, -20, 10, 0, 0, 70);
  bodyGrad.addColorStop(0, '#da70d6');
  bodyGrad.addColorStop(0.5, '#9932cc');
  bodyGrad.addColorStop(1, '#6a0dad');
  ctx.fillStyle = bodyGrad;
  ctx.beginPath();
  ctx.ellipse(0, 0, 60, 75, 0, 0, Math.PI * 2);
  ctx.fill();
  
  // Face
  ctx.fillStyle = '#fff';
  ctx.beginPath();
  ctx.ellipse(-18, -15, 10, 12, 0, 0, Math.PI * 2);
  ctx.ellipse(18, -15, 10, 12, 0, 0, Math.PI * 2);
  ctx.fill();
  
  ctx.fillStyle = '#1a1a2e';
  ctx.beginPath();
  ctx.arc(-18, -13, 5, 0, Math.PI * 2);
  ctx.arc(18, -13, 5, 0, Math.PI * 2);
  ctx.fill();
  
  // Worried expression when low armor
  ctx.strokeStyle = '#6a0dad';
  ctx.lineWidth = 3;
  ctx.beginPath();
  if (armorLevel < 30) {
    ctx.arc(0, 25, 15, 0.2 * Math.PI, 0.8 * Math.PI);
  } else {
    ctx.arc(0, 15, 12, 0, Math.PI);
  }
  ctx.stroke();
  
  ctx.restore();
}

function drawArmorPiece(armor) {
  const x = mech.x + Math.cos(armor.angle) * armor.distance;
  const y = mech.y + Math.sin(armor.angle) * armor.distance;
  
  ctx.save();
  ctx.translate(x, y);
  ctx.rotate(armor.angle + Math.PI/2);
  
  // Armor plate shadow
  ctx.fillStyle = 'rgba(0,0,0,0.3)';
  ctx.fillRect(-armor.width/2 + 3, -armor.height/2 + 3, armor.width, armor.height);
  
  // Main plate
  const plateGrad = ctx.createLinearGradient(-armor.width/2, 0, armor.width/2, 0);
  plateGrad.addColorStop(0, '#3a3a4a');
  plateGrad.addColorStop(0.3, '#5a5a6a');
  plateGrad.addColorStop(0.5, '#6a6a7a');
  plateGrad.addColorStop(0.7, '#5a5a6a');
  plateGrad.addColorStop(1, '#3a3a4a');
  ctx.fillStyle = plateGrad;
  ctx.fillRect(-armor.width/2, -armor.height/2, armor.width, armor.height);
  
  // Plate border
  ctx.strokeStyle = '#2a2a3a';
  ctx.lineWidth = armor.thickness / 2;
  ctx.strokeRect(-armor.width/2, -armor.height/2, armor.width, armor.height);
  
  // Inner highlight
  ctx.strokeStyle = 'rgba(150, 150, 170, 0.5)';
  ctx.lineWidth = 2;
  ctx.strokeRect(-armor.width/2 + 5, -armor.height/2 + 5, armor.width - 10, armor.height - 10);
  
  // Rivets
  ctx.fillStyle = '#4a4a5a';
  for (let i = 0; i < armor.rivets; i++) {
    const rx = -armor.width/2 + 8 + (i * (armor.width-16) / (armor.rivets-1 || 1));
    ctx.beginPath();
    ctx.arc(rx, -armor.height/2 + 8, 4, 0, Math.PI * 2);
    ctx.arc(rx, armor.height/2 - 8, 4, 0, Math.PI * 2);
    ctx.fill();
  }
  
  // Glow effect
  if (armor.glow > 0.1) {
    ctx.strokeStyle = `rgba(78, 205, 196, ${armor.glow})`;
    ctx.lineWidth = 3;
    ctx.strokeRect(-armor.width/2 - 2, -armor.height/2 - 2, armor.width + 4, armor.height + 4);
  }
  
  ctx.restore();
}

function drawPaw(paw) {
  ctx.save();
  ctx.translate(paw.x, paw.y);
  ctx.rotate(paw.rotation);
  
  // Paw pad
  ctx.fillStyle = '#ffb6c1';
  ctx.beginPath();
  ctx.ellipse(0, 0, paw.size * 0.8, paw.size * 0.6, 0, 0, Math.PI * 2);
  ctx.fill();
  
  // Toe beans
  ctx.fillStyle = '#ff91a4';
  const toes = [[-0.5, -0.6], [0, -0.7], [0.5, -0.6], [-0.3, -0.3], [0.3, -0.3]];
  for (const [tx, ty] of toes) {
    ctx.beginPath();
    ctx.ellipse(tx * paw.size, ty * paw.size, paw.size * 0.2, paw.size * 0.15, 0, 0, Math.PI * 2);
    ctx.fill();
  }
  
  // Main pad
  ctx.fillStyle = '#ff7799';
  ctx.beginPath();
  ctx.ellipse(0, paw.size * 0.15, paw.size * 0.35, paw.size * 0.25, 0, 0, Math.PI * 2);
  ctx.fill();
  
  ctx.restore();
}

function render() {
  ctx.save();
  
  // Screen shake
  if (shakeIntensity > 0.5) {
    ctx.translate(
      (Math.random() - 0.5) * shakeIntensity,
      (Math.random() - 0.5) * shakeIntensity
    );
  }
  
  // Background
  const bgGrad = ctx.createRadialGradient(mech.x, mech.y, 100, mech.x, mech.y, canvas.width);
  bgGrad.addColorStop(0, '#1a1a2e');
  bgGrad.addColorStop(1, '#0a0a15');
  ctx.fillStyle = bgGrad;
  ctx.fillRect(0, 0, canvas.width, canvas.height);
  
  // Grid lines
  ctx.strokeStyle = 'rgba(78, 205, 196, 0.1)';
  ctx.lineWidth = 1;
  for (let x = 0; x < canvas.width; x += 50) {
    ctx.beginPath();
    ctx.moveTo(x, 0);
    ctx.lineTo(x, canvas.height);
    ctx.stroke();
  }
  for (let y = 0; y < canvas.height; y += 50) {
    ctx.beginPath();
    ctx.moveTo(0, y);
    ctx.lineTo(canvas.width, y);
    ctx.stroke();
  }
  
  // Draw paws (behind)
  for (const paw of paws) {
    drawPaw(paw);
  }
  
  // Draw purple body
  drawPurpleBody();
  
  // Draw armor
  for (const armor of armorPieces) {
    drawArmorPiece(armor);
  }
  
  // Draw sparks
  for (const s of sparks) {
    ctx.globalAlpha = s.life;
    ctx.fillStyle = s.color;
    ctx.beginPath();
    ctx.arc(s.x, s.y, 3 * s.life, 0, Math.PI * 2);
    ctx.fill();
  }
  ctx.globalAlpha = 1;
  
  // Draw clank texts
  ctx.font = 'bold 24px Orbitron';
  ctx.textAlign = 'center';
  for (const t of clankTexts) {
    ctx.globalAlpha = t.alpha;
    ctx.fillStyle = '#4ecdc4';
    ctx.save();
    ctx.translate(t.x, t.y);
    ctx.scale(t.scale, t.scale);
    ctx.fillText(t.text, 0, 0);
    ctx.restore();
  }
  ctx.globalAlpha = 1;
  
  ctx.restore();
}

function updateArmorBar() {
  document.getElementById('armorFill').style.width = armorLevel + '%';
}

function gameLoop() {
  update();
  render();
  requestAnimationFrame(gameLoop);
}

canvas.addEventListener('click', e => {
  const rect = canvas.getBoundingClientRect();
  addArmorPiece(e.clientX - rect.left, e.clientY - rect.top);
});

canvas.addEventListener('touchstart', e => {
  e.preventDefault();
  const touch = e.touches[0];
  const rect = canvas.getBoundingClientRect();
  addArmorPiece(touch.clientX - rect.left, touch.clientY - rect.top);
});

window.addEventListener('resize', resize);

resize();
gameLoop();
</script>
</body>
</html>
