<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Minecraft Pixel Art Editor - Texture Creator</title>
    <link rel="icon" href="https://emojicdn.elk.sh/üé®">

    <meta property="og:title" content="Minecraft Pixel Art Editor">
    <meta property="og:description" content="Create custom Minecraft textures with a 16x16 pixel art editor">
    <meta property="og:url" content="https://app.vibecodedbyx.com/pixel-editor">
    <meta property="og:image" content="https://image.pollinations.ai/prompt/minecraft%20pixel%20art%20texture%20editor%20grid%2016x16?width=1200&height=630&referrer=vibecodedbyx.com">

    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Courier New', monospace;
            background: #2d2d2d;
            color: #fff;
            padding: 20px;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
        }

        header {
            text-align: center;
            margin-bottom: 30px;
        }

        h1 {
            font-size: 36px;
            color: #4CAF50;
            margin-bottom: 10px;
            text-shadow: 2px 2px 0 #000;
        }

        .subtitle {
            color: #aaa;
            font-size: 16px;
        }

        .editor-layout {
            display: grid;
            grid-template-columns: 300px 1fr 250px;
            gap: 20px;
            margin-bottom: 20px;
        }

        /* Tools Panel */
        .tools-panel {
            background: #1a1a1a;
            border: 2px solid #333;
            border-radius: 8px;
            padding: 20px;
        }

        .panel-title {
            font-size: 18px;
            font-weight: bold;
            color: #4CAF50;
            margin-bottom: 15px;
            border-bottom: 2px solid #333;
            padding-bottom: 8px;
        }

        .tool-group {
            margin-bottom: 20px;
        }

        .tool-label {
            display: block;
            margin-bottom: 8px;
            color: #aaa;
            font-size: 14px;
        }

        .tool-buttons {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 8px;
        }

        .tool-btn {
            padding: 12px;
            background: #333;
            border: 2px solid #444;
            color: #fff;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 5px;
        }

        .tool-btn:hover {
            background: #444;
            border-color: #4CAF50;
        }

        .tool-btn.active {
            background: #4CAF50;
            border-color: #4CAF50;
            color: #000;
        }

        .color-input-wrapper {
            display: flex;
            gap: 10px;
            align-items: center;
        }

        .color-input {
            width: 60px;
            height: 40px;
            border: 2px solid #444;
            border-radius: 4px;
            cursor: pointer;
            background: transparent;
        }

        .color-value {
            flex: 1;
            padding: 8px;
            background: #333;
            border: 2px solid #444;
            color: #fff;
            border-radius: 4px;
            font-family: monospace;
        }

        /* Canvas Area */
        .canvas-area {
            background: #1a1a1a;
            border: 2px solid #333;
            border-radius: 8px;
            padding: 20px;
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        .canvas-wrapper {
            background: #000;
            padding: 20px;
            border-radius: 8px;
            display: inline-block;
            box-shadow: 0 0 20px rgba(0,0,0,0.5);
        }

        #pixelCanvas {
            border: 2px solid #666;
            image-rendering: pixelated;
            cursor: crosshair;
            background:
                repeating-linear-gradient(0deg, #555 0px, #555 1px, transparent 1px, transparent 2px),
                repeating-linear-gradient(90deg, #555 0px, #555 1px, transparent 1px, transparent 2px);
        }

        .canvas-info {
            margin-top: 15px;
            color: #aaa;
            font-size: 14px;
        }

        .zoom-controls {
            margin-top: 15px;
            display: flex;
            gap: 10px;
            align-items: center;
        }

        .zoom-btn {
            padding: 8px 16px;
            background: #333;
            border: 2px solid #444;
            color: #fff;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
        }

        .zoom-btn:hover {
            background: #444;
            border-color: #4CAF50;
        }

        /* Palette Panel */
        .palette-panel {
            background: #1a1a1a;
            border: 2px solid #333;
            border-radius: 8px;
            padding: 20px;
        }

        .minecraft-palette {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 6px;
            margin-bottom: 20px;
        }

        .palette-color {
            width: 100%;
            aspect-ratio: 1;
            border: 2px solid #444;
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .palette-color:hover {
            transform: scale(1.1);
            border-color: #4CAF50;
        }

        .palette-color.active {
            border: 3px solid #4CAF50;
            box-shadow: 0 0 10px #4CAF50;
        }

        /* Actions */
        .actions {
            background: #1a1a1a;
            border: 2px solid #333;
            border-radius: 8px;
            padding: 20px;
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            justify-content: center;
        }

        .action-btn {
            padding: 12px 24px;
            background: #4CAF50;
            border: none;
            color: #000;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            font-weight: bold;
            transition: all 0.2s;
        }

        .action-btn:hover {
            background: #5CDB60;
            transform: translateY(-2px);
        }

        .action-btn.secondary {
            background: #666;
            color: #fff;
        }

        .action-btn.secondary:hover {
            background: #777;
        }

        .action-btn.danger {
            background: #f44336;
            color: #fff;
        }

        .action-btn.danger:hover {
            background: #ff5544;
        }

        /* Preview */
        .preview-section {
            text-align: center;
            margin-top: 20px;
        }

        #preview {
            image-rendering: pixelated;
            border: 2px solid #666;
            background: #000;
            margin-top: 10px;
        }

        /* Back Link */
        .back-link {
            position: fixed;
            bottom: 20px;
            right: 20px;
            padding: 12px 24px;
            background: rgba(0,0,0,0.8);
            border: 2px solid #4CAF50;
            border-radius: 4px;
            color: #4CAF50;
            text-decoration: none;
            font-size: 14px;
            transition: all 0.2s;
        }

        .back-link:hover {
            background: rgba(0,0,0,0.9);
            transform: translateY(-2px);
        }

        @media (max-width: 1200px) {
            .editor-layout {
                grid-template-columns: 1fr;
            }

            .minecraft-palette {
                grid-template-columns: repeat(8, 1fr);
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>‚õèÔ∏è Minecraft Pixel Art Editor üé®</h1>
            <p class="subtitle">Create custom 16x16 textures for Minecraft</p>
        </header>

        <div class="editor-layout">
            <!-- Tools Panel -->
            <div class="tools-panel">
                <div class="panel-title">üõ†Ô∏è Tools</div>

                <div class="tool-group">
                    <label class="tool-label">Draw Mode</label>
                    <div class="tool-buttons">
                        <button class="tool-btn active" onclick="setTool('pencil')">‚úèÔ∏è Pencil</button>
                        <button class="tool-btn" onclick="setTool('eraser')">üßπ Eraser</button>
                        <button class="tool-btn" onclick="setTool('fill')">ü™£ Fill</button>
                        <button class="tool-btn" onclick="setTool('eyedropper')">üíß Pick</button>
                    </div>
                </div>

                <div class="tool-group">
                    <label class="tool-label">Color</label>
                    <div class="color-input-wrapper">
                        <input type="color" id="colorPicker" class="color-input" value="#4CAF50" onchange="updateColor(this.value)">
                        <input type="text" id="colorValue" class="color-value" value="#4CAF50" onchange="updateColorFromText(this.value)">
                    </div>
                </div>

                <div class="tool-group">
                    <label class="tool-label">Grid Size</label>
                    <div class="tool-buttons">
                        <button class="tool-btn" onclick="setGridSize(8)">8x8</button>
                        <button class="tool-btn active" onclick="setGridSize(16)">16x16</button>
                        <button class="tool-btn" onclick="setGridSize(32)">32x32</button>
                        <button class="tool-btn" onclick="setGridSize(64)">64x64</button>
                    </div>
                </div>

                <div class="tool-group">
                    <label class="tool-label">Grid Display</label>
                    <div class="tool-buttons">
                        <button class="tool-btn active" onclick="toggleGrid()">üìê Toggle Grid</button>
                    </div>
                </div>

                <div class="preview-section">
                    <div class="tool-label">Preview (4x scale)</div>
                    <canvas id="preview" width="64" height="64"></canvas>
                </div>
            </div>

            <!-- Canvas Area -->
            <div class="canvas-area">
                <div class="canvas-wrapper">
                    <canvas id="pixelCanvas" width="512" height="512"></canvas>
                </div>
                <div class="canvas-info">
                    Current: <span id="gridSizeDisplay">16x16</span> pixels | Tool: <span id="toolDisplay">Pencil</span>
                </div>
                <div class="zoom-controls">
                    <button class="zoom-btn" onclick="zoom(-1)">‚ûñ Zoom Out</button>
                    <span id="zoomDisplay">32px</span>
                    <button class="zoom-btn" onclick="zoom(1)">‚ûï Zoom In</button>
                </div>
            </div>

            <!-- Palette Panel -->
            <div class="palette-panel">
                <div class="panel-title">üé® Minecraft Palette</div>
                <div class="minecraft-palette" id="minecraftPalette"></div>
            </div>
        </div>

        <!-- Actions -->
        <div class="actions">
            <button class="action-btn" onclick="downloadTexture()">üíæ Download PNG</button>
            <button class="action-btn secondary" onclick="loadFromFile()">üìÇ Load Image</button>
            <button class="action-btn danger" onclick="clearCanvas()">üóëÔ∏è Clear</button>
            <button class="action-btn secondary" onclick="fillBackground()">‚¨ú White BG</button>
        </div>
    </div>

    <input type="file" id="fileInput" accept="image/*" style="display: none;" onchange="handleFileLoad(event)">

    <a href="https://www.vibecodedbyx.com" class="back-link">‚Üê Back to VibeCodedByX</a>

    <script>
        const canvas = document.getElementById('pixelCanvas');
        const ctx = canvas.getContext('2d', { willReadFrequently: true });
        const preview = document.getElementById('preview');
        const previewCtx = preview.getContext('2d');

        let gridSize = 16;
        let pixelSize = 32;
        let currentColor = '#4CAF50';
        let currentTool = 'pencil';
        let isDrawing = false;
        let showGrid = true;

        const minecraftColors = [
            '#FFFFFF', '#F0F0F0', '#C0C0C0', '#808080',
            '#404040', '#000000', '#8B4513', '#654321',
            '#228B22', '#32CD32', '#006400', '#90EE90',
            '#1E90FF', '#4169E1', '#000080', '#ADD8E6',
            '#FFD700', '#FFA500', '#FF8C00', '#FF4500',
            '#FF0000', '#8B0000', '#DC143C', '#FF69B4',
            '#800080', '#9370DB', '#8B008B', '#DDA0DD',
            '#A52A2A', '#D2691E', '#CD853F', '#F4A460'
        ];

        function init() {
            initPalette();
            clearCanvas();
            updatePreview();

            canvas.addEventListener('mousedown', startDrawing);
            canvas.addEventListener('mousemove', draw);
            canvas.addEventListener('mouseup', stopDrawing);
            canvas.addEventListener('mouseleave', stopDrawing);
        }

        function initPalette() {
            const palette = document.getElementById('minecraftPalette');
            palette.innerHTML = minecraftColors.map(color =>
                `<div class="palette-color" style="background: ${color}" onclick="selectPaletteColor('${color}')"></div>`
            ).join('');
        }

        function selectPaletteColor(color) {
            currentColor = color;
            document.getElementById('colorPicker').value = color;
            document.getElementById('colorValue').value = color;
            updatePaletteSelection();
        }

        function updatePaletteSelection() {
            document.querySelectorAll('.palette-color').forEach(el => {
                el.classList.toggle('active', el.style.background === currentColor || rgbToHex(el.style.background) === currentColor);
            });
        }

        function rgbToHex(rgb) {
            const match = rgb.match(/^rgb\((\d+),\s*(\d+),\s*(\d+)\)$/);
            if (!match) return rgb;
            return '#' + [1,2,3].map(i => parseInt(match[i]).toString(16).padStart(2, '0')).join('');
        }

        function setTool(tool) {
            currentTool = tool;
            document.querySelectorAll('.tool-btn').forEach(btn => btn.classList.remove('active'));
            event.target.classList.add('active');
            document.getElementById('toolDisplay').textContent = tool.charAt(0).toUpperCase() + tool.slice(1);
            canvas.style.cursor = tool === 'eyedropper' ? 'crosshair' : tool === 'eraser' ? 'not-allowed' : 'crosshair';
        }

        function updateColor(color) {
            currentColor = color;
            document.getElementById('colorValue').value = color;
            updatePaletteSelection();
        }

        function updateColorFromText(color) {
            if (/^#[0-9A-F]{6}$/i.test(color)) {
                currentColor = color;
                document.getElementById('colorPicker').value = color;
                updatePaletteSelection();
            }
        }

        function setGridSize(size) {
            gridSize = size;
            document.querySelectorAll('.tool-group')[2].querySelectorAll('.tool-btn').forEach(btn => btn.classList.remove('active'));
            event.target.classList.add('active');
            document.getElementById('gridSizeDisplay').textContent = `${size}x${size}`;
            pixelSize = 512 / gridSize;
            clearCanvas();
            redraw();
        }

        function toggleGrid() {
            showGrid = !showGrid;
            redraw();
        }

        function getPixelCoords(e) {
            const rect = canvas.getBoundingClientRect();
            const x = Math.floor((e.clientX - rect.left) / pixelSize);
            const y = Math.floor((e.clientY - rect.top) / pixelSize);
            return { x, y };
        }

        function startDrawing(e) {
            isDrawing = true;
            const { x, y } = getPixelCoords(e);

            if (currentTool === 'eyedropper') {
                pickColor(x, y);
                isDrawing = false;
            } else if (currentTool === 'fill') {
                floodFill(x, y);
                isDrawing = false;
            } else {
                drawPixel(x, y);
            }
        }

        function draw(e) {
            if (!isDrawing) return;
            if (currentTool === 'fill' || currentTool === 'eyedropper') return;

            const { x, y } = getPixelCoords(e);
            drawPixel(x, y);
        }

        function stopDrawing() {
            isDrawing = false;
        }

        function drawPixel(x, y) {
            if (x < 0 || x >= gridSize || y < 0 || y >= gridSize) return;

            if (currentTool === 'eraser') {
                ctx.clearRect(x * pixelSize, y * pixelSize, pixelSize, pixelSize);
            } else {
                ctx.fillStyle = currentColor;
                ctx.fillRect(x * pixelSize, y * pixelSize, pixelSize, pixelSize);
            }

            if (showGrid) drawGrid();
            updatePreview();
        }

        function pickColor(x, y) {
            const imageData = ctx.getImageData(x * pixelSize + 1, y * pixelSize + 1, 1, 1);
            const [r, g, b, a] = imageData.data;
            if (a === 0) return;

            const hex = '#' + [r, g, b].map(v => v.toString(16).padStart(2, '0')).join('');
            selectPaletteColor(hex);
        }

        function floodFill(startX, startY) {
            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            const targetColor = getPixelColor(imageData, startX * pixelSize + 1, startY * pixelSize + 1);
            const fillColor = hexToRgb(currentColor);

            if (colorsMatch(targetColor, fillColor)) return;

            const stack = [[startX, startY]];

            while (stack.length > 0) {
                const [x, y] = stack.pop();
                if (x < 0 || x >= gridSize || y < 0 || y >= gridSize) continue;

                const pixelColor = getPixelColor(imageData, x * pixelSize + 1, y * pixelSize + 1);
                if (!colorsMatch(pixelColor, targetColor)) continue;

                ctx.fillStyle = currentColor;
                ctx.fillRect(x * pixelSize, y * pixelSize, pixelSize, pixelSize);

                stack.push([x + 1, y], [x - 1, y], [x, y + 1], [x, y - 1]);
            }

            if (showGrid) drawGrid();
            updatePreview();
        }

        function getPixelColor(imageData, x, y) {
            const i = (y * imageData.width + x) * 4;
            return [imageData.data[i], imageData.data[i + 1], imageData.data[i + 2], imageData.data[i + 3]];
        }

        function hexToRgb(hex) {
            const r = parseInt(hex.slice(1, 3), 16);
            const g = parseInt(hex.slice(3, 5), 16);
            const b = parseInt(hex.slice(5, 7), 16);
            return [r, g, b, 255];
        }

        function colorsMatch(c1, c2) {
            return c1[0] === c2[0] && c1[1] === c2[1] && c1[2] === c2[2] && c1[3] === c2[3];
        }

        function drawGrid() {
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.1)';
            ctx.lineWidth = 1;

            for (let i = 0; i <= gridSize; i++) {
                ctx.beginPath();
                ctx.moveTo(i * pixelSize, 0);
                ctx.lineTo(i * pixelSize, canvas.height);
                ctx.stroke();

                ctx.beginPath();
                ctx.moveTo(0, i * pixelSize);
                ctx.lineTo(canvas.width, i * pixelSize);
                ctx.stroke();
            }
        }

        function redraw() {
            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            ctx.putImageData(imageData, 0, 0);
            if (showGrid) drawGrid();
        }

        function updatePreview() {
            previewCtx.clearRect(0, 0, preview.width, preview.height);
            previewCtx.imageSmoothingEnabled = false;
            previewCtx.drawImage(canvas, 0, 0, preview.width, preview.height);
        }

        function clearCanvas() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            if (showGrid) drawGrid();
            updatePreview();
        }

        function fillBackground() {
            ctx.fillStyle = '#FFFFFF';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            if (showGrid) drawGrid();
            updatePreview();
        }

        function downloadTexture() {
            const tempCanvas = document.createElement('canvas');
            tempCanvas.width = gridSize;
            tempCanvas.height = gridSize;
            const tempCtx = tempCanvas.getContext('2d');

            tempCtx.imageSmoothingEnabled = false;
            tempCtx.drawImage(canvas, 0, 0, gridSize, gridSize);

            const link = document.createElement('a');
            link.download = `minecraft-texture-${gridSize}x${gridSize}.png`;
            link.href = tempCanvas.toDataURL();
            link.click();
        }

        function loadFromFile() {
            document.getElementById('fileInput').click();
        }

        function handleFileLoad(e) {
            const file = e.target.files[0];
            if (!file) return;

            const img = new Image();
            img.onload = function() {
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                ctx.imageSmoothingEnabled = false;
                ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
                if (showGrid) drawGrid();
                updatePreview();
            };
            img.src = URL.createObjectURL(file);
        }

        function zoom(direction) {
            // Placeholder for zoom functionality
            alert('Zoom feature coming soon!');
        }

        init();
    </script>
</body>
</html>
