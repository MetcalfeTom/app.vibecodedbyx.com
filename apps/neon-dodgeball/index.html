<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
  <title>NEON DODGEBALL - Survive the Light</title>
  <link rel="icon" href="https://emojicdn.elk.sh/âš¡">
  <meta property="og:title" content="NEON DODGEBALL - Survive the Light">
  <meta property="og:description" content="Dodge bouncing light spheres in a pulsing neon arena!">
  <meta property="og:url" content="https://sloppy.live/neon-dodgeball">
  <meta property="og:image" content="https://emojicdn.elk.sh/ðŸ”®?style=apple&size=512">
  <link href="https://fonts.googleapis.com/css2?family=Audiowide&display=swap" rel="stylesheet">
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      min-height: 100vh;
      background: #0a0a0f;
      font-family: 'Audiowide', cursive;
      display: flex;
      align-items: center;
      justify-content: center;
      overflow: hidden;
    }
    .game-container {
      position: relative;
      width: 100vw;
      height: 100vh;
    }
    canvas { display: block; width: 100%; height: 100%; }
    .hud {
      position: absolute;
      top: 15px;
      left: 20px;
      right: 20px;
      display: flex;
      justify-content: space-between;
      pointer-events: none;
      z-index: 10;
    }
    .title {
      font-size: 1.2rem;
      color: #0ff;
      text-shadow: 0 0 20px #0ff, 0 0 40px #08f;
      letter-spacing: 0.1em;
    }
    .score {
      font-size: 1rem;
      color: #f0f;
      text-shadow: 0 0 15px #f0f;
    }
    .lives {
      position: absolute;
      top: 45px;
      right: 20px;
      font-size: 1.5rem;
      pointer-events: none;
    }
    .overlay {
      position: absolute;
      inset: 0;
      background: rgba(5, 5, 15, 0.95);
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      z-index: 100;
      transition: opacity 0.5s;
    }
    .overlay.hidden { opacity: 0; pointer-events: none; }
    .overlay-title {
      font-size: 2.5rem;
      color: #0ff;
      text-shadow: 0 0 30px #0ff, 0 0 60px #f0f;
      margin-bottom: 10px;
    }
    .overlay-sub {
      font-size: 0.85rem;
      color: #888;
      margin-bottom: 30px;
      text-align: center;
      max-width: 300px;
    }
    .btn {
      font-family: 'Audiowide', cursive;
      font-size: 1rem;
      padding: 15px 40px;
      background: transparent;
      border: 2px solid #f0f;
      color: #f0f;
      cursor: pointer;
      letter-spacing: 0.1em;
      transition: all 0.2s;
    }
    .btn:hover {
      background: #f0f;
      color: #0a0a0f;
      box-shadow: 0 0 30px #f0f;
    }
    .final-score {
      font-size: 3rem;
      color: #0ff;
      text-shadow: 0 0 20px #0ff;
      margin: 10px 0 20px;
    }
    .back-link {
      position: fixed;
      bottom: 5px;
      right: 10px;
      color: #f0f;
      text-decoration: none;
      font-size: 0.65rem;
      opacity: 0.4;
    }
    .instructions {
      position: absolute;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      font-size: 0.7rem;
      color: #666;
      pointer-events: none;
    }
  </style>
</head>
<body>
  <div class="game-container">
    <canvas id="canvas"></canvas>
    <div class="hud">
      <div class="title">âš¡ NEON DODGEBALL</div>
      <div class="score">TIME: <span id="time">0</span>s</div>
    </div>
    <div class="lives" id="lives"></div>
    <div class="instructions">Move to dodge â€¢ Catch the monkey-seahorse for extra lives!</div>

    <div class="overlay" id="startOverlay">
      <div class="overlay-title">NEON DODGEBALL</div>
      <div class="overlay-sub">Dodge the bouncing light spheres and pulsing obstacles. How long can you survive?</div>
      <button class="btn" id="startBtn">ENTER ARENA</button>
    </div>

    <div class="overlay hidden" id="gameOverOverlay">
      <div class="overlay-title">ELIMINATED</div>
      <div class="final-score" id="finalTime">0s</div>
      <button class="btn" id="restartBtn">RETRY</button>
    </div>
  </div>
  <a href="https://sloppy.live" class="back-link">sloppy.live</a>

<script>
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');

let gameRunning = false;
let frameCount = 0;
let survivalTime = 0;
let lives = 3;
let invulnerable = 0;
let beatPhase = 0;
const BPM = 120;
const BEAT_INTERVAL = 60 / BPM;

const player = { x: 0, y: 0, radius: 15, targetX: 0, targetY: 0 };
const balls = [];
const obstacles = [];
const particles = [];
const seahorses = [];

const COLORS = ['#0ff', '#f0f', '#ff0', '#0f0', '#f00', '#00f'];

function resize() {
  canvas.width = window.innerWidth;
  canvas.height = window.innerHeight;
  player.x = canvas.width / 2;
  player.y = canvas.height / 2;
  player.targetX = player.x;
  player.targetY = player.y;
}

function spawnBall() {
  const side = Math.floor(Math.random() * 4);
  let x, y, vx, vy;
  const speed = 3 + Math.random() * 3 + survivalTime * 0.05;

  switch(side) {
    case 0: x = Math.random() * canvas.width; y = -30; break;
    case 1: x = canvas.width + 30; y = Math.random() * canvas.height; break;
    case 2: x = Math.random() * canvas.width; y = canvas.height + 30; break;
    case 3: x = -30; y = Math.random() * canvas.height; break;
  }

  const angle = Math.atan2(player.y - y, player.x - x) + (Math.random() - 0.5) * 0.5;
  vx = Math.cos(angle) * speed;
  vy = Math.sin(angle) * speed;

  balls.push({
    x, y, vx, vy,
    radius: 12 + Math.random() * 10,
    color: COLORS[Math.floor(Math.random() * COLORS.length)],
    glow: 1
  });
}

function spawnObstacle() {
  const type = Math.floor(Math.random() * 3);

  if (type === 0) {
    // Horizontal bar
    obstacles.push({
      type: 'hbar',
      y: 100 + Math.random() * (canvas.height - 200),
      width: 150 + Math.random() * 200,
      height: 20,
      speed: (Math.random() > 0.5 ? 1 : -1) * (2 + Math.random() * 2),
      x: Math.random() * canvas.width,
      color: COLORS[Math.floor(Math.random() * COLORS.length)],
      pulseOffset: Math.random() * Math.PI * 2
    });
  } else if (type === 1) {
    // Vertical bar
    obstacles.push({
      type: 'vbar',
      x: 100 + Math.random() * (canvas.width - 200),
      width: 20,
      height: 100 + Math.random() * 150,
      speed: (Math.random() > 0.5 ? 1 : -1) * (2 + Math.random() * 2),
      y: Math.random() * canvas.height,
      color: COLORS[Math.floor(Math.random() * COLORS.length)],
      pulseOffset: Math.random() * Math.PI * 2
    });
  } else {
    // Rotating spinner
    obstacles.push({
      type: 'spinner',
      x: 100 + Math.random() * (canvas.width - 200),
      y: 100 + Math.random() * (canvas.height - 200),
      length: 80 + Math.random() * 60,
      angle: Math.random() * Math.PI * 2,
      speed: (Math.random() > 0.5 ? 1 : -1) * (0.02 + Math.random() * 0.03),
      color: COLORS[Math.floor(Math.random() * COLORS.length)],
      pulseOffset: Math.random() * Math.PI * 2
    });
  }
}

function spawnParticle(x, y, color) {
  for (let i = 0; i < 8; i++) {
    const angle = (i / 8) * Math.PI * 2;
    particles.push({
      x, y,
      vx: Math.cos(angle) * (3 + Math.random() * 3),
      vy: Math.sin(angle) * (3 + Math.random() * 3),
      radius: 3 + Math.random() * 3,
      color,
      alpha: 1
    });
  }
}

function spawnSeahorse() {
  if (seahorses.length >= 1) return; // Only one at a time

  seahorses.push({
    x: 100 + Math.random() * (canvas.width - 200),
    y: 100 + Math.random() * (canvas.height - 200),
    size: 50,
    angle: 0,
    wobble: Math.random() * Math.PI * 2,
    alpha: 0,
    lifetime: 600, // 10 seconds
    color1: '#0ff',
    color2: '#f0f'
  });
}

function drawSeahorse(sh) {
  ctx.save();
  ctx.translate(sh.x, sh.y);
  ctx.rotate(Math.sin(sh.wobble) * 0.1);
  ctx.scale(sh.size / 64, sh.size / 64);
  ctx.globalAlpha = sh.alpha;

  // Glow effect
  ctx.shadowColor = sh.color1;
  ctx.shadowBlur = 30 + Math.sin(sh.wobble * 2) * 10;

  // Create gradient for body
  const grad = ctx.createLinearGradient(-20, -40, 20, 50);
  grad.addColorStop(0, sh.color1);
  grad.addColorStop(0.5, sh.color2);
  grad.addColorStop(1, sh.color1);

  // Long curled tail (starts from bottom, spirals)
  ctx.strokeStyle = grad;
  ctx.lineWidth = 8;
  ctx.lineCap = 'round';
  ctx.beginPath();
  ctx.moveTo(0, 10);
  ctx.quadraticCurveTo(8, 20, 12, 30);
  ctx.quadraticCurveTo(16, 45, 8, 55);
  ctx.quadraticCurveTo(-2, 65, -10, 58);
  ctx.quadraticCurveTo(-18, 50, -12, 42);
  ctx.quadraticCurveTo(-6, 35, 0, 40);
  ctx.quadraticCurveTo(6, 45, 4, 50);
  ctx.stroke();

  // Body (shorter, connects head to tail)
  ctx.fillStyle = grad;
  ctx.beginPath();
  ctx.ellipse(0, 0, 12, 16, 0, 0, Math.PI * 2);
  ctx.fill();

  // Monkey head (round)
  ctx.beginPath();
  ctx.arc(0, -22, 18, 0, Math.PI * 2);
  ctx.fill();

  // Monkey ears
  ctx.beginPath();
  ctx.arc(-18, -24, 10, 0, Math.PI * 2);
  ctx.arc(18, -24, 10, 0, Math.PI * 2);
  ctx.fill();

  // Inner ears
  ctx.fillStyle = sh.color2;
  ctx.beginPath();
  ctx.arc(-18, -24, 6, 0, Math.PI * 2);
  ctx.arc(18, -24, 6, 0, Math.PI * 2);
  ctx.fill();

  // Face (lighter area)
  ctx.fillStyle = '#ffd4aa';
  ctx.shadowBlur = 0;
  ctx.beginPath();
  ctx.ellipse(0, -18, 12, 10, 0, 0, Math.PI * 2);
  ctx.fill();

  // Eyes
  ctx.fillStyle = '#fff';
  ctx.beginPath();
  ctx.arc(-6, -22, 5, 0, Math.PI * 2);
  ctx.arc(6, -22, 5, 0, Math.PI * 2);
  ctx.fill();

  // Pupils
  ctx.fillStyle = '#000';
  ctx.beginPath();
  ctx.arc(-5, -22, 2.5, 0, Math.PI * 2);
  ctx.arc(7, -22, 2.5, 0, Math.PI * 2);
  ctx.fill();

  // Eye shine
  ctx.fillStyle = '#fff';
  ctx.beginPath();
  ctx.arc(-6, -23, 1, 0, Math.PI * 2);
  ctx.arc(6, -23, 1, 0, Math.PI * 2);
  ctx.fill();

  // Nose
  ctx.fillStyle = '#aa7755';
  ctx.beginPath();
  ctx.ellipse(0, -15, 4, 3, 0, 0, Math.PI * 2);
  ctx.fill();

  // Nostrils
  ctx.fillStyle = '#553322';
  ctx.beginPath();
  ctx.arc(-2, -15, 1, 0, Math.PI * 2);
  ctx.arc(2, -15, 1, 0, Math.PI * 2);
  ctx.fill();

  // Smile
  ctx.strokeStyle = '#aa7755';
  ctx.lineWidth = 2;
  ctx.beginPath();
  ctx.arc(0, -12, 6, 0.2 * Math.PI, 0.8 * Math.PI);
  ctx.stroke();

  // Neon glow outline on head
  ctx.strokeStyle = sh.color1;
  ctx.lineWidth = 2;
  ctx.shadowColor = sh.color1;
  ctx.shadowBlur = 15;
  ctx.beginPath();
  ctx.arc(0, -22, 18, 0, Math.PI * 2);
  ctx.stroke();

  ctx.restore();
}

function checkCollision(obj) {
  if (obj.type === 'spinner') {
    // Line collision for spinner
    const endX = obj.x + Math.cos(obj.angle) * obj.length;
    const endY = obj.y + Math.sin(obj.angle) * obj.length;
    const endX2 = obj.x - Math.cos(obj.angle) * obj.length;
    const endY2 = obj.y - Math.sin(obj.angle) * obj.length;

    return pointToLineDistance(player.x, player.y, obj.x, obj.y, endX, endY) < player.radius + 8 ||
           pointToLineDistance(player.x, player.y, obj.x, obj.y, endX2, endY2) < player.radius + 8;
  } else {
    // Rectangle collision
    const closestX = Math.max(obj.x, Math.min(player.x, obj.x + obj.width));
    const closestY = Math.max(obj.y, Math.min(player.y, obj.y + obj.height));
    const dx = player.x - closestX;
    const dy = player.y - closestY;
    return (dx * dx + dy * dy) < (player.radius * player.radius);
  }
}

function pointToLineDistance(px, py, x1, y1, x2, y2) {
  const A = px - x1;
  const B = py - y1;
  const C = x2 - x1;
  const D = y2 - y1;
  const dot = A * C + B * D;
  const lenSq = C * C + D * D;
  let param = -1;
  if (lenSq !== 0) param = dot / lenSq;

  let xx, yy;
  if (param < 0) { xx = x1; yy = y1; }
  else if (param > 1) { xx = x2; yy = y2; }
  else { xx = x1 + param * C; yy = y1 + param * D; }

  const dx = px - xx;
  const dy = py - yy;
  return Math.sqrt(dx * dx + dy * dy);
}

function hit() {
  if (invulnerable > 0) return;

  lives--;
  updateLives();
  invulnerable = 90; // 1.5 seconds at 60fps
  spawnParticle(player.x, player.y, '#f00');

  if (lives <= 0) {
    gameOver();
  }
}

function updateLives() {
  document.getElementById('lives').textContent = 'â¤ï¸'.repeat(Math.max(0, lives));
}

function update() {
  if (!gameRunning) return;

  frameCount++;
  beatPhase += (1 / 60) / BEAT_INTERVAL;

  if (frameCount % 60 === 0) {
    survivalTime++;
    document.getElementById('time').textContent = survivalTime;
  }

  // Spawn balls
  const ballSpawnRate = Math.max(30, 90 - survivalTime);
  if (frameCount % ballSpawnRate === 0) {
    spawnBall();
  }

  // Spawn obstacles
  if (frameCount % 300 === 0 && obstacles.length < 5 + Math.floor(survivalTime / 20)) {
    spawnObstacle();
  }

  // Update player (smooth follow)
  player.x += (player.targetX - player.x) * 0.15;
  player.y += (player.targetY - player.y) * 0.15;

  // Keep player in bounds
  player.x = Math.max(player.radius, Math.min(canvas.width - player.radius, player.x));
  player.y = Math.max(player.radius, Math.min(canvas.height - player.radius, player.y));

  if (invulnerable > 0) invulnerable--;

  // Update balls
  for (let i = balls.length - 1; i >= 0; i--) {
    const ball = balls[i];
    ball.x += ball.vx;
    ball.y += ball.vy;

    // Bounce off walls
    if (ball.x < ball.radius || ball.x > canvas.width - ball.radius) {
      ball.vx *= -1;
      ball.x = Math.max(ball.radius, Math.min(canvas.width - ball.radius, ball.x));
      ball.glow = 1.5;
    }
    if (ball.y < ball.radius || ball.y > canvas.height - ball.radius) {
      ball.vy *= -1;
      ball.y = Math.max(ball.radius, Math.min(canvas.height - ball.radius, ball.y));
      ball.glow = 1.5;
    }

    ball.glow = Math.max(1, ball.glow - 0.02);

    // Check player collision
    const dx = player.x - ball.x;
    const dy = player.y - ball.y;
    const dist = Math.sqrt(dx * dx + dy * dy);
    if (dist < player.radius + ball.radius) {
      hit();
      spawnParticle(ball.x, ball.y, ball.color);
      balls.splice(i, 1);
      continue;
    }

    // Remove old balls
    if (frameCount > 600 && balls.length > 15) {
      balls.splice(i, 1);
    }
  }

  // Update obstacles
  for (let i = obstacles.length - 1; i >= 0; i--) {
    const obs = obstacles[i];

    if (obs.type === 'hbar') {
      obs.x += obs.speed;
      if (obs.x < -obs.width) obs.x = canvas.width;
      if (obs.x > canvas.width) obs.x = -obs.width;
    } else if (obs.type === 'vbar') {
      obs.y += obs.speed;
      if (obs.y < -obs.height) obs.y = canvas.height;
      if (obs.y > canvas.height) obs.y = -obs.height;
    } else if (obs.type === 'spinner') {
      obs.angle += obs.speed;
    }

    // Pulse with beat
    obs.pulse = 1 + Math.sin(beatPhase * Math.PI * 2 + obs.pulseOffset) * 0.3;

    // Check collision
    if (checkCollision(obs)) {
      hit();
    }

    // Remove old obstacles
    if (survivalTime > 30 && obstacles.length > 3 && Math.random() < 0.0005) {
      obstacles.splice(i, 1);
    }
  }

  // Update particles
  for (let i = particles.length - 1; i >= 0; i--) {
    const p = particles[i];
    p.x += p.vx;
    p.y += p.vy;
    p.vx *= 0.95;
    p.vy *= 0.95;
    p.alpha -= 0.03;
    if (p.alpha <= 0) particles.splice(i, 1);
  }

  // Spawn seahorse (rare - every ~15 seconds on average)
  if (frameCount % 900 === 0 && Math.random() < 0.5) {
    spawnSeahorse();
  }

  // Update seahorses
  for (let i = seahorses.length - 1; i >= 0; i--) {
    const sh = seahorses[i];
    sh.wobble += 0.05;
    sh.lifetime--;

    // Fade in
    if (sh.alpha < 1 && sh.lifetime > 60) {
      sh.alpha = Math.min(1, sh.alpha + 0.02);
    }
    // Fade out
    if (sh.lifetime < 60) {
      sh.alpha = sh.lifetime / 60;
    }

    // Gentle floating motion
    sh.y += Math.sin(sh.wobble) * 0.3;
    sh.x += Math.cos(sh.wobble * 0.7) * 0.2;

    // Check player collision (collect seahorse)
    const dx = player.x - sh.x;
    const dy = player.y - sh.y;
    const dist = Math.sqrt(dx * dx + dy * dy);
    if (dist < player.radius + sh.size * 0.5) {
      // Collected! Extra life!
      lives = Math.min(5, lives + 1);
      updateLives();
      spawnParticle(sh.x, sh.y, '#0ff');
      spawnParticle(sh.x, sh.y, '#f0f');
      seahorses.splice(i, 1);
      continue;
    }

    // Remove if lifetime expired
    if (sh.lifetime <= 0) {
      seahorses.splice(i, 1);
    }
  }
}

function drawGrid() {
  const pulse = 1 + Math.sin(beatPhase * Math.PI * 2) * 0.2;
  ctx.strokeStyle = `rgba(255, 0, 255, ${0.1 * pulse})`;
  ctx.lineWidth = 1;

  const gridSize = 60;
  for (let x = 0; x < canvas.width; x += gridSize) {
    ctx.beginPath();
    ctx.moveTo(x, 0);
    ctx.lineTo(x, canvas.height);
    ctx.stroke();
  }
  for (let y = 0; y < canvas.height; y += gridSize) {
    ctx.beginPath();
    ctx.moveTo(0, y);
    ctx.lineTo(canvas.width, y);
    ctx.stroke();
  }
}

function drawPlayer() {
  const pulse = invulnerable > 0 ? (Math.sin(invulnerable * 0.5) * 0.5 + 0.5) : 1;

  // Glow
  const glow = ctx.createRadialGradient(player.x, player.y, 0, player.x, player.y, player.radius * 3);
  glow.addColorStop(0, `rgba(0, 255, 255, ${0.4 * pulse})`);
  glow.addColorStop(1, 'transparent');
  ctx.fillStyle = glow;
  ctx.beginPath();
  ctx.arc(player.x, player.y, player.radius * 3, 0, Math.PI * 2);
  ctx.fill();

  // Body
  ctx.fillStyle = `rgba(0, 255, 255, ${pulse})`;
  ctx.shadowColor = '#0ff';
  ctx.shadowBlur = 20;
  ctx.beginPath();
  ctx.arc(player.x, player.y, player.radius, 0, Math.PI * 2);
  ctx.fill();

  // Inner
  ctx.fillStyle = '#fff';
  ctx.shadowBlur = 0;
  ctx.beginPath();
  ctx.arc(player.x, player.y, player.radius * 0.5, 0, Math.PI * 2);
  ctx.fill();
}

function drawBalls() {
  for (const ball of balls) {
    // Glow
    const glow = ctx.createRadialGradient(ball.x, ball.y, 0, ball.x, ball.y, ball.radius * 2 * ball.glow);
    glow.addColorStop(0, ball.color + '80');
    glow.addColorStop(1, 'transparent');
    ctx.fillStyle = glow;
    ctx.beginPath();
    ctx.arc(ball.x, ball.y, ball.radius * 2 * ball.glow, 0, Math.PI * 2);
    ctx.fill();

    // Ball
    ctx.fillStyle = ball.color;
    ctx.shadowColor = ball.color;
    ctx.shadowBlur = 15 * ball.glow;
    ctx.beginPath();
    ctx.arc(ball.x, ball.y, ball.radius, 0, Math.PI * 2);
    ctx.fill();
    ctx.shadowBlur = 0;
  }
}

function drawObstacles() {
  for (const obs of obstacles) {
    ctx.fillStyle = obs.color;
    ctx.shadowColor = obs.color;
    ctx.shadowBlur = 20 * obs.pulse;

    if (obs.type === 'hbar' || obs.type === 'vbar') {
      const w = obs.type === 'hbar' ? obs.width * obs.pulse : obs.width;
      const h = obs.type === 'vbar' ? obs.height * obs.pulse : obs.height;
      ctx.fillRect(obs.x - (w - obs.width) / 2, obs.y - (h - obs.height) / 2, w, h);
    } else if (obs.type === 'spinner') {
      ctx.strokeStyle = obs.color;
      ctx.lineWidth = 8 * obs.pulse;
      ctx.lineCap = 'round';
      ctx.beginPath();
      const len = obs.length * obs.pulse;
      ctx.moveTo(obs.x - Math.cos(obs.angle) * len, obs.y - Math.sin(obs.angle) * len);
      ctx.lineTo(obs.x + Math.cos(obs.angle) * len, obs.y + Math.sin(obs.angle) * len);
      ctx.stroke();

      // Center
      ctx.fillStyle = '#fff';
      ctx.beginPath();
      ctx.arc(obs.x, obs.y, 8, 0, Math.PI * 2);
      ctx.fill();
    }
    ctx.shadowBlur = 0;
  }
}

function drawParticles() {
  for (const p of particles) {
    ctx.globalAlpha = p.alpha;
    ctx.fillStyle = p.color;
    ctx.shadowColor = p.color;
    ctx.shadowBlur = 10;
    ctx.beginPath();
    ctx.arc(p.x, p.y, p.radius, 0, Math.PI * 2);
    ctx.fill();
  }
  ctx.globalAlpha = 1;
  ctx.shadowBlur = 0;
}

function drawSeahorses() {
  for (const sh of seahorses) {
    drawSeahorse(sh);
  }
}

function render() {
  // Dark background
  ctx.fillStyle = '#0a0a0f';
  ctx.fillRect(0, 0, canvas.width, canvas.height);

  drawGrid();
  drawSeahorses();
  drawObstacles();
  drawBalls();
  drawPlayer();
  drawParticles();

  // Vignette
  const vignette = ctx.createRadialGradient(
    canvas.width / 2, canvas.height / 2, canvas.height * 0.4,
    canvas.width / 2, canvas.height / 2, canvas.height
  );
  vignette.addColorStop(0, 'transparent');
  vignette.addColorStop(1, 'rgba(0, 0, 0, 0.6)');
  ctx.fillStyle = vignette;
  ctx.fillRect(0, 0, canvas.width, canvas.height);
}

function gameLoop() {
  update();
  render();
  requestAnimationFrame(gameLoop);
}

function startGame() {
  document.getElementById('startOverlay').classList.add('hidden');
  document.getElementById('gameOverOverlay').classList.add('hidden');

  balls.length = 0;
  obstacles.length = 0;
  particles.length = 0;
  seahorses.length = 0;
  frameCount = 0;
  survivalTime = 0;
  lives = 3;
  invulnerable = 60;
  beatPhase = 0;

  player.x = canvas.width / 2;
  player.y = canvas.height / 2;
  player.targetX = player.x;
  player.targetY = player.y;

  document.getElementById('time').textContent = '0';
  updateLives();

  gameRunning = true;
}

function gameOver() {
  gameRunning = false;
  document.getElementById('finalTime').textContent = survivalTime + 's';
  document.getElementById('gameOverOverlay').classList.remove('hidden');
}

// Events
document.getElementById('startBtn').addEventListener('click', startGame);
document.getElementById('restartBtn').addEventListener('click', startGame);

canvas.addEventListener('mousemove', e => {
  player.targetX = e.clientX;
  player.targetY = e.clientY;
});

canvas.addEventListener('touchmove', e => {
  e.preventDefault();
  player.targetX = e.touches[0].clientX;
  player.targetY = e.touches[0].clientY;
});

canvas.addEventListener('touchstart', e => {
  e.preventDefault();
  player.targetX = e.touches[0].clientX;
  player.targetY = e.touches[0].clientY;
});

window.addEventListener('resize', resize);

resize();
updateLives();
gameLoop();
</script>
</body>
</html>
