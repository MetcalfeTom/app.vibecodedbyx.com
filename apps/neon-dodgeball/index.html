<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
  <title>CANNONBALL COVE - Dodge the Deck</title>
  <link rel="icon" href="https://emojicdn.elk.sh/‚öì">
  <meta property="og:title" content="CANNONBALL COVE - Dodge the Deck">
  <meta property="og:description" content="Dodge rolling barrels and swinging anchors on the pirate ship deck!">
  <meta property="og:url" content="https://app.sloppy.live/neon-dodgeball">
  <meta property="og:image" content="https://emojicdn.elk.sh/üè¥‚Äç‚ò†Ô∏è?style=apple&size=512">
  <link href="https://fonts.googleapis.com/css2?family=Pirata+One&family=IM+Fell+English+SC&display=swap" rel="stylesheet">
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      min-height: 100vh;
      background: #0d1a2a;
      font-family: 'IM Fell English SC', serif;
      display: flex;
      align-items: center;
      justify-content: center;
      overflow: hidden;
    }
    .game-container {
      position: relative;
      width: 100vw;
      height: 100vh;
    }
    canvas { display: block; width: 100%; height: 100%; }
    .hud {
      position: absolute;
      top: 15px;
      left: 20px;
      right: 20px;
      display: flex;
      justify-content: space-between;
      pointer-events: none;
      z-index: 10;
    }
    .title {
      font-family: 'Pirata One', cursive;
      font-size: 1.3rem;
      color: #d4a84b;
      text-shadow: 0 0 20px #d4a84b55, 2px 2px 0 #5c3a1e;
      letter-spacing: 0.1em;
    }
    .score {
      font-family: 'Pirata One', cursive;
      font-size: 1rem;
      color: #ffd700;
      text-shadow: 0 0 15px #ffd70055;
    }
    .lives {
      position: absolute;
      top: 45px;
      right: 20px;
      font-size: 1.5rem;
      pointer-events: none;
    }
    .overlay {
      position: absolute;
      inset: 0;
      background: rgba(10, 5, 0, 0.95);
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      z-index: 100;
      transition: opacity 0.5s;
    }
    .overlay.hidden { opacity: 0; pointer-events: none; }
    .overlay-title {
      font-family: 'Pirata One', cursive;
      font-size: 2.5rem;
      color: #d4a84b;
      text-shadow: 0 0 30px #d4a84b, 0 0 60px #8b4513;
      margin-bottom: 10px;
    }
    .overlay-sub {
      font-size: 0.85rem;
      color: #8b7355;
      margin-bottom: 30px;
      text-align: center;
      max-width: 300px;
    }
    .btn {
      font-family: 'Pirata One', cursive;
      font-size: 1.2rem;
      padding: 15px 40px;
      background: transparent;
      border: 2px solid #d4a84b;
      color: #d4a84b;
      cursor: pointer;
      letter-spacing: 0.1em;
      transition: all 0.2s;
    }
    .btn:hover {
      background: #d4a84b;
      color: #1a0f0a;
      box-shadow: 0 0 30px #d4a84b55;
    }
    .final-score {
      font-family: 'Pirata One', cursive;
      font-size: 3rem;
      color: #ffd700;
      text-shadow: 0 0 20px #ffd70055;
      margin: 10px 0 20px;
    }
    .back-link {
      position: fixed;
      bottom: 5px;
      right: 10px;
      color: #d4a84b55;
      text-decoration: none;
      font-size: 0.65rem;
    }
    .instructions {
      position: absolute;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      font-size: 0.7rem;
      color: #5c3a1e;
      pointer-events: none;
      opacity: 1;
      transition: opacity 0.5s;
    }
    .instructions.hidden { opacity: 0; }
  </style>
</head>
<body>
  <div class="game-container">
    <canvas id="canvas"></canvas>
    <div class="hud">
      <div class="title">‚öì CANNONBALL COVE</div>
      <div class="score">SURVIVED: <span id="time">0</span>s</div>
    </div>
    <div class="lives" id="lives"></div>
    <div class="instructions" id="instructions">Move to dodge barrels and anchors ‚Ä¢ Grab rum for grog!</div>

    <div class="overlay" id="startOverlay">
      <div class="overlay-title">‚öì CANNONBALL COVE ‚öì</div>
      <div class="overlay-sub">The deck be chaos! Dodge rolling barrels and swinging anchor chains. How long can ye stay on yer feet?</div>
      <button class="btn" id="startBtn">STEP ABOARD</button>
    </div>

    <div class="overlay hidden" id="gameOverOverlay">
      <div class="overlay-title">üíÄ OVERBOARD! üíÄ</div>
      <div class="final-score" id="finalTime">0s</div>
      <button class="btn" id="restartBtn">CLIMB BACK</button>
    </div>
  </div>
  <a href="https://sloppy.live" class="back-link">‚Üê sloppy.live</a>

<script>
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');

let gameRunning = false;
let frameCount = 0;
let survivalTime = 0;
let lives = 3;
let invulnerable = 0;
let shipRock = 0;

const player = { x: 0, y: 0, radius: 18, targetX: 0, targetY: 0, facing: 1, bobble: 0 };
const barrels = [];
const anchors = [];
const particles = [];
const grog = [];
const planks = [];

// Plank positions for deck floor
function initPlanks() {
  planks.length = 0;
  const plankHeight = 35;
  for (let y = 0; y < canvas.height + plankHeight; y += plankHeight) {
    planks.push({
      y: y,
      offset: Math.random() * 20 - 10,
      shade: 0.9 + Math.random() * 0.2
    });
  }
}

function resize() {
  canvas.width = window.innerWidth;
  canvas.height = window.innerHeight;
  player.x = canvas.width / 2;
  player.y = canvas.height / 2;
  player.targetX = player.x;
  player.targetY = player.y;
  initPlanks();
}

function spawnBarrel() {
  const side = Math.floor(Math.random() * 4);
  let x, y, vx, vy;
  const speed = 2 + Math.random() * 2 + survivalTime * 0.03;

  switch(side) {
    case 0: x = Math.random() * canvas.width; y = -40; break;
    case 1: x = canvas.width + 40; y = Math.random() * canvas.height; break;
    case 2: x = Math.random() * canvas.width; y = canvas.height + 40; break;
    case 3: x = -40; y = Math.random() * canvas.height; break;
  }

  // Roll toward player with some randomness
  const angle = Math.atan2(player.y - y, player.x - x) + (Math.random() - 0.5) * 0.8;
  vx = Math.cos(angle) * speed;
  vy = Math.sin(angle) * speed;

  barrels.push({
    x, y, vx, vy,
    radius: 22 + Math.random() * 8,
    rotation: 0,
    rotSpeed: (Math.random() > 0.5 ? 1 : -1) * (0.1 + Math.random() * 0.1)
  });
}

function spawnAnchor() {
  // Swinging anchor chains from edges or corners
  const positions = [
    { x: 80, y: 80 },
    { x: canvas.width - 80, y: 80 },
    { x: 80, y: canvas.height - 80 },
    { x: canvas.width - 80, y: canvas.height - 80 },
    { x: canvas.width / 2, y: 60 },
    { x: canvas.width / 2, y: canvas.height - 60 }
  ];

  // Filter out positions too close to existing anchors
  const available = positions.filter(pos => {
    return !anchors.some(a => {
      const dx = a.pivotX - pos.x;
      const dy = a.pivotY - pos.y;
      return Math.sqrt(dx*dx + dy*dy) < 150;
    });
  });

  if (available.length === 0) return;

  const pos = available[Math.floor(Math.random() * available.length)];
  const chainLength = 100 + Math.random() * 80;

  anchors.push({
    pivotX: pos.x,
    pivotY: pos.y,
    chainLength: chainLength,
    angle: Math.random() * Math.PI * 2,
    swingSpeed: (0.02 + Math.random() * 0.02) * (Math.random() > 0.5 ? 1 : -1),
    swingAmplitude: Math.PI * 0.4 + Math.random() * Math.PI * 0.3,
    baseAngle: Math.random() * Math.PI * 2,
    lifetime: 600 + Math.random() * 400
  });
}

function spawnParticle(x, y, color, count = 8) {
  for (let i = 0; i < count; i++) {
    const angle = (i / count) * Math.PI * 2 + Math.random() * 0.5;
    particles.push({
      x, y,
      vx: Math.cos(angle) * (2 + Math.random() * 3),
      vy: Math.sin(angle) * (2 + Math.random() * 3),
      radius: 2 + Math.random() * 3,
      color,
      alpha: 1
    });
  }
}

function spawnGrog() {
  if (grog.length >= 1) return;

  grog.push({
    x: 100 + Math.random() * (canvas.width - 200),
    y: 100 + Math.random() * (canvas.height - 200),
    size: 30,
    wobble: Math.random() * Math.PI * 2,
    alpha: 0,
    lifetime: 500
  });
}

function hit() {
  if (invulnerable > 0) return;

  lives--;
  updateLives();
  invulnerable = 90;
  spawnParticle(player.x, player.y, '#8b4513', 12);

  if (lives <= 0) {
    gameOver();
  }
}

function updateLives() {
  document.getElementById('lives').textContent = 'üè¥‚Äç‚ò†Ô∏è'.repeat(Math.max(0, lives));
}

function update() {
  if (!gameRunning) return;

  frameCount++;
  shipRock = Math.sin(frameCount * 0.015) * 3;
  player.bobble += 0.1;

  if (frameCount % 60 === 0) {
    survivalTime++;
    document.getElementById('time').textContent = survivalTime;
  }

  // Hide instructions after 3 seconds
  if (frameCount === 180) {
    document.getElementById('instructions').classList.add('hidden');
  }

  // Spawn barrels
  const barrelRate = Math.max(40, 100 - survivalTime);
  if (frameCount % barrelRate === 0) {
    spawnBarrel();
  }

  // Spawn anchors
  if (frameCount % 350 === 0 && anchors.length < 3 + Math.floor(survivalTime / 30)) {
    spawnAnchor();
  }

  // Update player
  const dx = player.targetX - player.x;
  const dy = player.targetY - player.y;
  player.x += dx * 0.1;
  player.y += dy * 0.1;

  if (Math.abs(dx) > 2) {
    player.facing = dx > 0 ? 1 : -1;
  }

  player.x = Math.max(player.radius + 20, Math.min(canvas.width - player.radius - 20, player.x));
  player.y = Math.max(player.radius + 60, Math.min(canvas.height - player.radius - 20, player.y));

  if (invulnerable > 0) invulnerable--;

  // Update barrels
  for (let i = barrels.length - 1; i >= 0; i--) {
    const barrel = barrels[i];

    barrel.x += barrel.vx;
    barrel.y += barrel.vy;
    barrel.rotation += barrel.rotSpeed;

    // Bounce off walls
    if (barrel.x < barrel.radius || barrel.x > canvas.width - barrel.radius) {
      barrel.vx *= -0.7;
      barrel.x = Math.max(barrel.radius, Math.min(canvas.width - barrel.radius, barrel.x));
      spawnParticle(barrel.x, barrel.y, '#5c3a1e', 4);
    }
    if (barrel.y < barrel.radius || barrel.y > canvas.height - barrel.radius) {
      barrel.vy *= -0.7;
      barrel.y = Math.max(barrel.radius, Math.min(canvas.height - barrel.radius, barrel.y));
      spawnParticle(barrel.x, barrel.y, '#5c3a1e', 4);
    }

    // Slow down over time
    barrel.vx *= 0.998;
    barrel.vy *= 0.998;

    // Check player collision
    const cdx = player.x - barrel.x;
    const cdy = player.y - barrel.y;
    const dist = Math.sqrt(cdx * cdx + cdy * cdy);
    if (dist < player.radius + barrel.radius * 0.8) {
      hit();
      spawnParticle(barrel.x, barrel.y, '#8b4513', 6);
      barrels.splice(i, 1);
      continue;
    }

    // Remove slow/old barrels
    const speed = Math.sqrt(barrel.vx * barrel.vx + barrel.vy * barrel.vy);
    if (speed < 0.3 || (frameCount > 300 && barrels.length > 15)) {
      barrels.splice(i, 1);
    }
  }

  // Update anchors
  for (let i = anchors.length - 1; i >= 0; i--) {
    const anchor = anchors[i];

    anchor.angle += anchor.swingSpeed;
    anchor.lifetime--;

    // Anchor tip position
    const tipX = anchor.pivotX + Math.cos(anchor.baseAngle + Math.sin(anchor.angle) * anchor.swingAmplitude) * anchor.chainLength;
    const tipY = anchor.pivotY + Math.sin(anchor.baseAngle + Math.sin(anchor.angle) * anchor.swingAmplitude) * anchor.chainLength;

    // Check collision with chain (multiple points along chain)
    for (let t = 0.3; t <= 1; t += 0.1) {
      const chainX = anchor.pivotX + (tipX - anchor.pivotX) * t;
      const chainY = anchor.pivotY + (tipY - anchor.pivotY) * t;
      const hitRadius = t > 0.8 ? 25 : 10;

      const cdx = player.x - chainX;
      const cdy = player.y - chainY;
      const dist = Math.sqrt(cdx * cdx + cdy * cdy);
      if (dist < player.radius + hitRadius) {
        hit();
        break;
      }
    }

    if (anchor.lifetime <= 0) {
      anchors.splice(i, 1);
    }
  }

  // Update particles
  for (let i = particles.length - 1; i >= 0; i--) {
    const p = particles[i];
    p.x += p.vx;
    p.y += p.vy;
    p.vy += 0.15;
    p.alpha -= 0.02;
    if (p.alpha <= 0) particles.splice(i, 1);
  }

  // Spawn grog
  if (frameCount % 700 === 0 && Math.random() < 0.6) {
    spawnGrog();
  }

  // Update grog
  for (let i = grog.length - 1; i >= 0; i--) {
    const g = grog[i];
    g.wobble += 0.05;
    g.lifetime--;

    if (g.alpha < 1 && g.lifetime > 60) {
      g.alpha = Math.min(1, g.alpha + 0.03);
    }
    if (g.lifetime < 60) {
      g.alpha = g.lifetime / 60;
    }

    const gdx = player.x - g.x;
    const gdy = player.y - g.y;
    const gdist = Math.sqrt(gdx * gdx + gdy * gdy);
    if (gdist < player.radius + g.size * 0.4) {
      lives = Math.min(5, lives + 1);
      updateLives();
      spawnParticle(g.x, g.y, '#8b4513', 10);
      grog.splice(i, 1);
      continue;
    }

    if (g.lifetime <= 0) {
      grog.splice(i, 1);
    }
  }
}

function drawDeck() {
  // Sky visible at edges
  const skyGrad = ctx.createLinearGradient(0, 0, 0, canvas.height);
  skyGrad.addColorStop(0, '#1a2535');
  skyGrad.addColorStop(1, '#0d1a2a');
  ctx.fillStyle = skyGrad;
  ctx.fillRect(0, 0, canvas.width, canvas.height);

  ctx.save();
  ctx.translate(canvas.width / 2, canvas.height / 2);
  ctx.rotate(shipRock * 0.003);
  ctx.translate(-canvas.width / 2, -canvas.height / 2);

  // Deck planks
  for (const plank of planks) {
    const baseColor = Math.floor(90 * plank.shade);
    const r = Math.floor(139 * plank.shade);
    const g = Math.floor(90 * plank.shade);
    const b = Math.floor(43 * plank.shade);

    ctx.fillStyle = `rgb(${r}, ${g}, ${b})`;
    ctx.fillRect(0, plank.y + plank.offset, canvas.width, 34);

    // Plank lines
    ctx.strokeStyle = `rgba(60, 40, 20, 0.5)`;
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.moveTo(0, plank.y + plank.offset);
    ctx.lineTo(canvas.width, plank.y + plank.offset);
    ctx.stroke();

    // Nail details
    ctx.fillStyle = '#4a3520';
    for (let x = 30; x < canvas.width; x += 100) {
      ctx.beginPath();
      ctx.arc(x + plank.offset, plank.y + plank.offset + 17, 3, 0, Math.PI * 2);
      ctx.fill();
    }
  }

  // Deck border/railing shadow
  ctx.fillStyle = '#3a2510';
  ctx.fillRect(0, 0, canvas.width, 50);
  ctx.fillRect(0, canvas.height - 15, canvas.width, 15);
  ctx.fillRect(0, 0, 15, canvas.height);
  ctx.fillRect(canvas.width - 15, 0, 15, canvas.height);

  // Rope coils decoration
  ctx.strokeStyle = '#8b7355';
  ctx.lineWidth = 8;
  for (let corner of [[60, 70], [canvas.width - 60, 70]]) {
    ctx.beginPath();
    ctx.arc(corner[0], corner[1], 20, 0, Math.PI * 2);
    ctx.stroke();
    ctx.beginPath();
    ctx.arc(corner[0], corner[1], 12, 0, Math.PI * 2);
    ctx.stroke();
  }

  ctx.restore();
}

function drawPlayer() {
  const flash = invulnerable > 0 ? (Math.sin(invulnerable * 0.5) * 0.5 + 0.5) : 1;

  ctx.save();
  ctx.translate(player.x, player.y);
  ctx.scale(player.facing, 1);
  ctx.globalAlpha = flash;

  // Shadow
  ctx.fillStyle = 'rgba(0,0,0,0.3)';
  ctx.beginPath();
  ctx.ellipse(0, player.radius - 5, player.radius * 0.8, 6, 0, 0, Math.PI * 2);
  ctx.fill();

  // Legs with walking animation
  const legOffset = Math.sin(player.bobble * 2) * 3;
  ctx.fillStyle = '#2a1a0a';
  ctx.fillRect(-8, 5, 6, 12 + legOffset);
  ctx.fillRect(2, 5, 6, 12 - legOffset);

  // Boots
  ctx.fillStyle = '#1a1a1a';
  ctx.fillRect(-10, 15 + legOffset, 10, 5);
  ctx.fillRect(0, 15 - legOffset, 10, 5);

  // Pegleg (sometimes)
  if (invulnerable > 0 && lives === 1) {
    ctx.fillStyle = '#8b7355';
    ctx.fillRect(2, 5, 5, 15 - legOffset);
  }

  // Body (vest)
  ctx.fillStyle = '#8b2500';
  ctx.beginPath();
  ctx.moveTo(-12, -10);
  ctx.lineTo(-10, 8);
  ctx.lineTo(10, 8);
  ctx.lineTo(12, -10);
  ctx.closePath();
  ctx.fill();

  // Shirt
  ctx.fillStyle = '#f5f5dc';
  ctx.beginPath();
  ctx.moveTo(-6, -8);
  ctx.lineTo(-4, 6);
  ctx.lineTo(4, 6);
  ctx.lineTo(6, -8);
  ctx.closePath();
  ctx.fill();

  // Arms
  ctx.fillStyle = '#d4a574';
  ctx.fillRect(-18, -8, 8, 5);
  ctx.fillRect(10, -8, 8, 5);

  // Head
  ctx.fillStyle = '#d4a574';
  ctx.beginPath();
  ctx.arc(0, -18, 10, 0, Math.PI * 2);
  ctx.fill();

  // Bandana
  ctx.fillStyle = '#c41e3a';
  ctx.beginPath();
  ctx.arc(0, -20, 10, Math.PI, Math.PI * 2);
  ctx.fill();

  // Bandana knot
  ctx.fillStyle = '#c41e3a';
  ctx.beginPath();
  ctx.moveTo(8, -18);
  ctx.lineTo(15, -15);
  ctx.lineTo(14, -20);
  ctx.lineTo(8, -18);
  ctx.fill();

  // Eye
  ctx.fillStyle = '#1a1a1a';
  ctx.beginPath();
  ctx.arc(3, -18, 2, 0, Math.PI * 2);
  ctx.fill();

  // Eyepatch
  ctx.fillStyle = '#1a1a1a';
  ctx.beginPath();
  ctx.ellipse(-4, -18, 4, 5, 0, 0, Math.PI * 2);
  ctx.fill();
  ctx.strokeStyle = '#1a1a1a';
  ctx.lineWidth = 1;
  ctx.beginPath();
  ctx.moveTo(-8, -18);
  ctx.lineTo(-10, -25);
  ctx.moveTo(0, -18);
  ctx.lineTo(8, -25);
  ctx.stroke();

  // Beard stubble
  ctx.fillStyle = '#5c4033';
  ctx.beginPath();
  ctx.arc(0, -12, 6, 0, Math.PI);
  ctx.fill();

  ctx.restore();
  ctx.globalAlpha = 1;
}

function drawBarrels() {
  for (const barrel of barrels) {
    ctx.save();
    ctx.translate(barrel.x, barrel.y);
    ctx.rotate(barrel.rotation);

    // Barrel shadow
    ctx.fillStyle = 'rgba(0,0,0,0.3)';
    ctx.beginPath();
    ctx.ellipse(4, 4, barrel.radius, barrel.radius * 0.4, 0, 0, Math.PI * 2);
    ctx.fill();

    // Barrel body
    const grad = ctx.createRadialGradient(-barrel.radius * 0.3, -barrel.radius * 0.3, 0, 0, 0, barrel.radius);
    grad.addColorStop(0, '#a0724a');
    grad.addColorStop(0.5, '#8b5a2b');
    grad.addColorStop(1, '#5c3a1e');
    ctx.fillStyle = grad;
    ctx.beginPath();
    ctx.arc(0, 0, barrel.radius, 0, Math.PI * 2);
    ctx.fill();

    // Barrel bands
    ctx.strokeStyle = '#3a3a3a';
    ctx.lineWidth = 3;
    ctx.beginPath();
    ctx.arc(0, 0, barrel.radius * 0.85, 0, Math.PI * 2);
    ctx.stroke();
    ctx.beginPath();
    ctx.arc(0, 0, barrel.radius * 0.5, 0, Math.PI * 2);
    ctx.stroke();

    // Wood grain lines
    ctx.strokeStyle = 'rgba(60, 40, 20, 0.4)';
    ctx.lineWidth = 1;
    for (let i = 0; i < 8; i++) {
      const angle = (i / 8) * Math.PI * 2;
      ctx.beginPath();
      ctx.moveTo(0, 0);
      ctx.lineTo(Math.cos(angle) * barrel.radius, Math.sin(angle) * barrel.radius);
      ctx.stroke();
    }

    // Highlight
    ctx.fillStyle = 'rgba(255,255,255,0.15)';
    ctx.beginPath();
    ctx.arc(-barrel.radius * 0.3, -barrel.radius * 0.3, barrel.radius * 0.4, 0, Math.PI * 2);
    ctx.fill();

    ctx.restore();
  }
}

function drawAnchors() {
  for (const anchor of anchors) {
    const swingAngle = anchor.baseAngle + Math.sin(anchor.angle) * anchor.swingAmplitude;
    const tipX = anchor.pivotX + Math.cos(swingAngle) * anchor.chainLength;
    const tipY = anchor.pivotY + Math.sin(swingAngle) * anchor.chainLength;

    // Chain
    ctx.strokeStyle = '#5a5a5a';
    ctx.lineWidth = 6;
    ctx.beginPath();
    ctx.moveTo(anchor.pivotX, anchor.pivotY);

    // Chain links effect
    const segments = 10;
    for (let i = 1; i <= segments; i++) {
      const t = i / segments;
      const x = anchor.pivotX + (tipX - anchor.pivotX) * t;
      const y = anchor.pivotY + (tipY - anchor.pivotY) * t;
      const wobble = Math.sin(i * Math.PI + frameCount * 0.1) * 3;
      ctx.lineTo(x + wobble, y);
    }
    ctx.stroke();

    // Chain highlight
    ctx.strokeStyle = '#7a7a7a';
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(anchor.pivotX, anchor.pivotY);
    for (let i = 1; i <= segments; i++) {
      const t = i / segments;
      const x = anchor.pivotX + (tipX - anchor.pivotX) * t - 2;
      const y = anchor.pivotY + (tipY - anchor.pivotY) * t - 2;
      const wobble = Math.sin(i * Math.PI + frameCount * 0.1) * 3;
      ctx.lineTo(x + wobble, y);
    }
    ctx.stroke();

    // Anchor head
    ctx.save();
    ctx.translate(tipX, tipY);
    ctx.rotate(swingAngle + Math.PI / 2);

    // Anchor shank
    ctx.fillStyle = '#3a3a3a';
    ctx.fillRect(-4, -30, 8, 35);

    // Anchor ring
    ctx.strokeStyle = '#3a3a3a';
    ctx.lineWidth = 5;
    ctx.beginPath();
    ctx.arc(0, -35, 10, 0, Math.PI * 2);
    ctx.stroke();

    // Anchor flukes (arms)
    ctx.fillStyle = '#3a3a3a';
    ctx.beginPath();
    ctx.moveTo(-25, 8);
    ctx.quadraticCurveTo(-15, -5, 0, 0);
    ctx.quadraticCurveTo(15, -5, 25, 8);
    ctx.lineTo(20, 15);
    ctx.quadraticCurveTo(10, 5, 0, 8);
    ctx.quadraticCurveTo(-10, 5, -20, 15);
    ctx.closePath();
    ctx.fill();

    // Crown
    ctx.fillRect(-12, -5, 24, 8);

    // Highlight
    ctx.fillStyle = 'rgba(255,255,255,0.2)';
    ctx.fillRect(-2, -28, 3, 30);

    ctx.restore();

    // Pivot point (hook on ceiling/wall)
    ctx.fillStyle = '#5a5a5a';
    ctx.beginPath();
    ctx.arc(anchor.pivotX, anchor.pivotY, 10, 0, Math.PI * 2);
    ctx.fill();
    ctx.fillStyle = '#3a3a3a';
    ctx.beginPath();
    ctx.arc(anchor.pivotX, anchor.pivotY, 6, 0, Math.PI * 2);
    ctx.fill();
  }
}

function drawParticles() {
  for (const p of particles) {
    ctx.globalAlpha = p.alpha;
    ctx.fillStyle = p.color;
    ctx.beginPath();
    ctx.arc(p.x, p.y, p.radius, 0, Math.PI * 2);
    ctx.fill();
  }
  ctx.globalAlpha = 1;
}

function drawGrog() {
  for (const g of grog) {
    ctx.save();
    ctx.translate(g.x, g.y + Math.sin(g.wobble) * 3);
    ctx.globalAlpha = g.alpha;

    // Glow
    ctx.shadowColor = '#ffd700';
    ctx.shadowBlur = 15 + Math.sin(g.wobble * 2) * 5;

    // Bottle
    ctx.fillStyle = '#2d5a27';
    ctx.beginPath();
    ctx.moveTo(-8, -15);
    ctx.lineTo(-8, 10);
    ctx.quadraticCurveTo(-8, 15, 0, 15);
    ctx.quadraticCurveTo(8, 15, 8, 10);
    ctx.lineTo(8, -15);
    ctx.closePath();
    ctx.fill();

    // Neck
    ctx.fillStyle = '#2d5a27';
    ctx.fillRect(-4, -22, 8, 10);

    // Cork
    ctx.fillStyle = '#8b7355';
    ctx.fillRect(-3, -26, 6, 6);

    // Label
    ctx.fillStyle = '#f5f5dc';
    ctx.fillRect(-6, -5, 12, 10);

    // Skull on label
    ctx.fillStyle = '#1a1a1a';
    ctx.font = '10px serif';
    ctx.fillText('‚ò†', -5, 3);

    // Liquid shine
    ctx.fillStyle = 'rgba(255,255,255,0.3)';
    ctx.fillRect(-5, 5, 3, 8);

    ctx.restore();
  }
}

function render() {
  drawDeck();
  drawGrog();
  drawAnchors();
  drawBarrels();
  drawPlayer();
  drawParticles();

  // Vignette
  const vignette = ctx.createRadialGradient(
    canvas.width / 2, canvas.height / 2, canvas.height * 0.3,
    canvas.width / 2, canvas.height / 2, canvas.height * 0.8
  );
  vignette.addColorStop(0, 'transparent');
  vignette.addColorStop(1, 'rgba(0, 0, 0, 0.6)');
  ctx.fillStyle = vignette;
  ctx.fillRect(0, 0, canvas.width, canvas.height);
}

function gameLoop() {
  update();
  render();
  requestAnimationFrame(gameLoop);
}

function startGame() {
  document.getElementById('startOverlay').classList.add('hidden');
  document.getElementById('gameOverOverlay').classList.add('hidden');
  document.getElementById('instructions').classList.remove('hidden');

  barrels.length = 0;
  anchors.length = 0;
  particles.length = 0;
  grog.length = 0;
  frameCount = 0;
  survivalTime = 0;
  lives = 3;
  invulnerable = 60;
  shipRock = 0;

  player.x = canvas.width / 2;
  player.y = canvas.height / 2;
  player.targetX = player.x;
  player.targetY = player.y;
  player.facing = 1;
  player.bobble = 0;

  document.getElementById('time').textContent = '0';
  updateLives();

  gameRunning = true;
}

function gameOver() {
  gameRunning = false;
  document.getElementById('finalTime').textContent = survivalTime + 's';
  document.getElementById('gameOverOverlay').classList.remove('hidden');
}

// Events
document.getElementById('startBtn').addEventListener('click', startGame);
document.getElementById('restartBtn').addEventListener('click', startGame);

canvas.addEventListener('mousemove', e => {
  player.targetX = e.clientX;
  player.targetY = e.clientY;
});

canvas.addEventListener('touchmove', e => {
  e.preventDefault();
  player.targetX = e.touches[0].clientX;
  player.targetY = e.touches[0].clientY;
});

canvas.addEventListener('touchstart', e => {
  e.preventDefault();
  player.targetX = e.touches[0].clientX;
  player.targetY = e.touches[0].clientY;
});

window.addEventListener('resize', resize);

resize();
updateLives();
gameLoop();
</script>
<script src="/apps/sloppy-header/sloppy-bar.js"></script>
<script src="/vibelib-extended.js"></script>
<script>
  // Compatibility Patch for Legacy Apps
  window.addEventListener("load", () => {
    if (window.SloppyKarma && window.VibeLib.Economy) {
      // Redirect old calls to new engine
      window.SloppyKarma.track = window.VibeLib.Economy.track;
    }
  });
</script>
</body>
</html>
