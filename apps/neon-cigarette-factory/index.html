<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Neon Cigarette Factory</title>
  <meta name="description" content="3D neon factory spawning 500 glowing sticks">
  <meta property="og:title" content="Neon Cigarette Factory">
  <meta property="og:description" content="Watch 500 glowing sticks roll off the neon assembly line">
  <meta property="og:url" content="https://sloppy.live/neon-cigarette-factory/">
  <meta property="og:image" content="https://emojicdn.elk.sh/ğŸš¬">
  <link rel="icon" href="https://emojicdn.elk.sh/ğŸ­">
  <style>
    @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700&display=swap');

    * { margin: 0; padding: 0; box-sizing: border-box; }

    body {
      background: #0a0a0f;
      overflow: hidden;
      font-family: 'Orbitron', monospace;
    }

    #canvas-container {
      width: 100vw;
      height: 100vh;
      position: fixed;
      top: 0;
      left: 0;
    }

    #ui {
      position: fixed;
      top: 20px;
      left: 20px;
      z-index: 100;
      color: #0ff;
      text-shadow: 0 0 10px #0ff, 0 0 20px #0ff;
    }

    h1 {
      font-size: 1.5rem;
      margin-bottom: 10px;
      color: #f0f;
      text-shadow: 0 0 10px #f0f, 0 0 20px #f0f;
    }

    #counter {
      font-size: 2rem;
      color: #0f0;
      text-shadow: 0 0 10px #0f0, 0 0 30px #0f0;
    }

    #status {
      margin-top: 10px;
      font-size: 0.8rem;
      opacity: 0.8;
    }

    #backlink {
      position: fixed;
      bottom: 20px;
      left: 20px;
      z-index: 100;
    }

    #backlink a {
      color: #f0f;
      text-decoration: none;
      font-size: 0.8rem;
      opacity: 0.7;
      transition: opacity 0.3s;
    }

    #backlink a:hover {
      opacity: 1;
      text-shadow: 0 0 10px #f0f;
    }

    #controls {
      position: fixed;
      bottom: 20px;
      right: 20px;
      z-index: 100;
      color: #666;
      font-size: 0.7rem;
      text-align: right;
    }
  </style>
</head>
<body>
  <div id="canvas-container"></div>

  <div id="ui">
    <h1>NEON CIGARETTE FACTORY</h1>
    <div id="counter">0 / 500</div>
    <div id="status">Initializing production line...</div>
  </div>

  <div id="backlink">
    <a href="https://sloppy.live">â† sloppy.live</a>
  </div>

  <div id="controls">
    Drag to rotate â€¢ Scroll to zoom
  </div>

  <script type="importmap">
  {
    "imports": {
      "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
      "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
    }
  }
  </script>

  <script type="module">
    import * as THREE from 'three';
    import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
    import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
    import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
    import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';

    // Scene setup
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x050508);
    scene.fog = new THREE.FogExp2(0x050508, 0.015);

    const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.set(30, 25, 40);

    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    renderer.toneMapping = THREE.ReinhardToneMapping;
    renderer.toneMappingExposure = 1.5;
    document.getElementById('canvas-container').appendChild(renderer.domElement);

    // Controls
    const controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;
    controls.dampingFactor = 0.05;
    controls.maxPolarAngle = Math.PI / 2.1;

    // Post-processing bloom
    const composer = new EffectComposer(renderer);
    composer.addPass(new RenderPass(scene, camera));
    const bloomPass = new UnrealBloomPass(
      new THREE.Vector2(window.innerWidth, window.innerHeight),
      1.5, 0.4, 0.85
    );
    bloomPass.threshold = 0.1;
    bloomPass.strength = 2;
    bloomPass.radius = 0.5;
    composer.addPass(bloomPass);

    // Neon materials
    const neonCyan = new THREE.MeshStandardMaterial({
      color: 0x00ffff,
      emissive: 0x00ffff,
      emissiveIntensity: 0.5,
      metalness: 0.8,
      roughness: 0.2
    });

    const neonMagenta = new THREE.MeshStandardMaterial({
      color: 0xff00ff,
      emissive: 0xff00ff,
      emissiveIntensity: 0.5,
      metalness: 0.8,
      roughness: 0.2
    });

    const neonOrange = new THREE.MeshStandardMaterial({
      color: 0xff6600,
      emissive: 0xff4400,
      emissiveIntensity: 0.8,
      metalness: 0.3,
      roughness: 0.4
    });

    const whiteMaterial = new THREE.MeshStandardMaterial({
      color: 0xeeeeee,
      emissive: 0x333333,
      emissiveIntensity: 0.2,
      metalness: 0.1,
      roughness: 0.6
    });

    const darkMetal = new THREE.MeshStandardMaterial({
      color: 0x222233,
      metalness: 0.9,
      roughness: 0.3
    });

    // Factory floor
    const floorGeo = new THREE.PlaneGeometry(200, 200);
    const floorMat = new THREE.MeshStandardMaterial({
      color: 0x111118,
      metalness: 0.8,
      roughness: 0.4
    });
    const floor = new THREE.Mesh(floorGeo, floorMat);
    floor.rotation.x = -Math.PI / 2;
    floor.position.y = -0.1;
    scene.add(floor);

    // Grid lines on floor
    const gridHelper = new THREE.GridHelper(200, 50, 0x00ffff, 0x111133);
    gridHelper.position.y = 0;
    scene.add(gridHelper);

    // Factory machine base
    const machineBaseGeo = new THREE.BoxGeometry(20, 4, 10);
    const machineBase = new THREE.Mesh(machineBaseGeo, darkMetal);
    machineBase.position.set(0, 2, 0);
    scene.add(machineBase);

    // Machine top
    const machineTopGeo = new THREE.BoxGeometry(18, 6, 8);
    const machineTop = new THREE.Mesh(machineTopGeo, darkMetal);
    machineTop.position.set(0, 7, 0);
    scene.add(machineTop);

    // Neon trim on machine
    const trimGeo = new THREE.BoxGeometry(20.2, 0.3, 10.2);
    const trim1 = new THREE.Mesh(trimGeo, neonCyan);
    trim1.position.set(0, 4.1, 0);
    scene.add(trim1);

    const trim2 = new THREE.Mesh(trimGeo.clone(), neonMagenta);
    trim2.position.set(0, 0.1, 0);
    scene.add(trim2);

    // Conveyor belt
    const conveyorGeo = new THREE.BoxGeometry(60, 0.5, 4);
    const conveyorMat = new THREE.MeshStandardMaterial({
      color: 0x1a1a2e,
      metalness: 0.6,
      roughness: 0.5
    });
    const conveyor = new THREE.Mesh(conveyorGeo, conveyorMat);
    conveyor.position.set(20, 1, 0);
    scene.add(conveyor);

    // Conveyor side rails
    const railGeo = new THREE.BoxGeometry(60, 1, 0.2);
    const rail1 = new THREE.Mesh(railGeo, neonCyan);
    rail1.position.set(20, 1.5, 2);
    scene.add(rail1);
    const rail2 = new THREE.Mesh(railGeo, neonCyan);
    rail2.position.set(20, 1.5, -2);
    scene.add(rail2);

    // Smoke stacks
    for (let i = 0; i < 3; i++) {
      const stackGeo = new THREE.CylinderGeometry(1, 1.5, 12, 8);
      const stack = new THREE.Mesh(stackGeo, darkMetal);
      stack.position.set(-5 + i * 5, 16, -3);
      scene.add(stack);

      // Neon ring on stack
      const ringGeo = new THREE.TorusGeometry(1.2, 0.15, 8, 16);
      const ring = new THREE.Mesh(ringGeo, neonMagenta);
      ring.rotation.x = Math.PI / 2;
      ring.position.set(-5 + i * 5, 22, -3);
      scene.add(ring);
    }

    // Lights
    const ambientLight = new THREE.AmbientLight(0x111122, 0.5);
    scene.add(ambientLight);

    const mainLight = new THREE.PointLight(0x00ffff, 100, 100);
    mainLight.position.set(0, 20, 10);
    scene.add(mainLight);

    const accentLight = new THREE.PointLight(0xff00ff, 80, 80);
    accentLight.position.set(-10, 15, -10);
    scene.add(accentLight);

    const factoryLight = new THREE.SpotLight(0xffaa00, 100, 50, Math.PI / 4);
    factoryLight.position.set(0, 25, 0);
    factoryLight.target.position.set(10, 0, 0);
    scene.add(factoryLight);
    scene.add(factoryLight.target);

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // MASSIVE NEON GODZILLA
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    const godzillaGroup = new THREE.Group();
    godzillaGroup.position.set(-40, 0, 20);

    const neonGodzilla = new THREE.MeshStandardMaterial({
      color: 0x00ff88,
      emissive: 0x00ff44,
      emissiveIntensity: 0.6,
      metalness: 0.5,
      roughness: 0.3
    });

    const neonSpines = new THREE.MeshStandardMaterial({
      color: 0x00ffff,
      emissive: 0x00ffff,
      emissiveIntensity: 1.2,
      metalness: 0.7,
      roughness: 0.2
    });

    const neonBelly = new THREE.MeshStandardMaterial({
      color: 0x88ffaa,
      emissive: 0x44ff66,
      emissiveIntensity: 0.4,
      metalness: 0.3,
      roughness: 0.5
    });

    // Godzilla body (massive torso)
    const torsoGeo = new THREE.CylinderGeometry(6, 8, 25, 12);
    const torso = new THREE.Mesh(torsoGeo, neonGodzilla);
    torso.position.set(0, 20, 0);
    godzillaGroup.add(torso);

    // Belly plate
    const bellyGeo = new THREE.CylinderGeometry(5, 7, 20, 12, 1, false, 0, Math.PI);
    const belly = new THREE.Mesh(bellyGeo, neonBelly);
    belly.position.set(0, 18, 3);
    belly.rotation.y = Math.PI;
    godzillaGroup.add(belly);

    // Godzilla legs (massive)
    const thighGeo = new THREE.CylinderGeometry(3, 4, 12, 8);
    const calfGeo = new THREE.CylinderGeometry(2.5, 3, 10, 8);
    const footGeo = new THREE.BoxGeometry(6, 2, 8);

    // Left leg
    const leftThigh = new THREE.Mesh(thighGeo, neonGodzilla);
    leftThigh.position.set(-5, 10, 0);
    leftThigh.rotation.z = 0.1;
    godzillaGroup.add(leftThigh);
    const leftCalf = new THREE.Mesh(calfGeo, neonGodzilla);
    leftCalf.position.set(-6, 2, 0);
    godzillaGroup.add(leftCalf);
    const leftFoot = new THREE.Mesh(footGeo, neonGodzilla);
    leftFoot.position.set(-6, -2, 1);
    godzillaGroup.add(leftFoot);

    // Right leg
    const rightThigh = new THREE.Mesh(thighGeo, neonGodzilla);
    rightThigh.position.set(5, 10, 0);
    rightThigh.rotation.z = -0.1;
    godzillaGroup.add(rightThigh);
    const rightCalf = new THREE.Mesh(calfGeo, neonGodzilla);
    rightCalf.position.set(6, 2, 0);
    godzillaGroup.add(rightCalf);
    const rightFoot = new THREE.Mesh(footGeo, neonGodzilla);
    rightFoot.position.set(6, -2, 1);
    godzillaGroup.add(rightFoot);

    // Claws on feet
    const clawGeo = new THREE.ConeGeometry(0.5, 2, 6);
    for (let foot of [-6, 6]) {
      for (let c = -2; c <= 2; c += 2) {
        const claw = new THREE.Mesh(clawGeo, neonSpines);
        claw.position.set(foot, -3, 4 + c * 0.3);
        claw.rotation.x = Math.PI / 2;
        godzillaGroup.add(claw);
      }
    }

    // Arms (small T-rex style)
    const armGeo = new THREE.CylinderGeometry(1, 1.5, 6, 6);
    const leftArm = new THREE.Mesh(armGeo, neonGodzilla);
    leftArm.position.set(-7, 28, 4);
    leftArm.rotation.z = 0.8;
    leftArm.rotation.x = -0.3;
    godzillaGroup.add(leftArm);
    const rightArm = new THREE.Mesh(armGeo, neonGodzilla);
    rightArm.position.set(7, 28, 4);
    rightArm.rotation.z = -0.8;
    rightArm.rotation.x = -0.3;
    godzillaGroup.add(rightArm);

    // Neck
    const neckGeo = new THREE.CylinderGeometry(3, 5, 10, 8);
    const neck = new THREE.Mesh(neckGeo, neonGodzilla);
    neck.position.set(0, 38, 2);
    neck.rotation.x = -0.3;
    godzillaGroup.add(neck);

    // Head
    const headGeo = new THREE.SphereGeometry(5, 12, 12);
    const head = new THREE.Mesh(headGeo, neonGodzilla);
    head.position.set(0, 46, 5);
    head.scale.set(1, 0.8, 1.3);
    godzillaGroup.add(head);

    // Snout/Jaw
    const jawGeo = new THREE.BoxGeometry(4, 3, 8);
    const jaw = new THREE.Mesh(jawGeo, neonGodzilla);
    jaw.position.set(0, 44, 10);
    godzillaGroup.add(jaw);

    // Teeth
    for (let i = -1.5; i <= 1.5; i += 1) {
      const toothGeo = new THREE.ConeGeometry(0.3, 1.5, 4);
      const tooth = new THREE.Mesh(toothGeo, neonSpines);
      tooth.position.set(i, 42.5, 13);
      tooth.rotation.x = Math.PI;
      godzillaGroup.add(tooth);
    }

    // Eyes (glowing red menacing)
    const eyeGeo = new THREE.SphereGeometry(1, 8, 8);
    const eyeMat = new THREE.MeshStandardMaterial({
      color: 0xff0000,
      emissive: 0xff0000,
      emissiveIntensity: 3
    });
    const eye1 = new THREE.Mesh(eyeGeo, eyeMat);
    eye1.position.set(-2.5, 47, 8);
    godzillaGroup.add(eye1);
    const eye2 = new THREE.Mesh(eyeGeo, eyeMat);
    eye2.position.set(2.5, 47, 8);
    godzillaGroup.add(eye2);

    // Dorsal spines (iconic!)
    const spineHeights = [4, 6, 8, 10, 9, 7, 5, 4, 3, 2, 1.5];
    spineHeights.forEach((h, i) => {
      const spineGeo = new THREE.ConeGeometry(1 + h * 0.1, h, 4);
      const spine = new THREE.Mesh(spineGeo, neonSpines);
      spine.position.set(0, 20 + i * 2, -6 - i * 0.5);
      spine.rotation.x = -0.2;
      godzillaGroup.add(spine);
    });

    // MASSIVE TAIL
    const tailSegments = 12;
    for (let i = 0; i < tailSegments; i++) {
      const segSize = 4 - i * 0.25;
      const tailSegGeo = new THREE.CylinderGeometry(segSize * 0.8, segSize, 5, 8);
      const tailSeg = new THREE.Mesh(tailSegGeo, neonGodzilla);
      tailSeg.position.set(0, 8 - i * 1.5, -10 - i * 4);
      tailSeg.rotation.x = 0.2 + i * 0.05;
      godzillaGroup.add(tailSeg);

      // Tail spines
      if (i < 8) {
        const tailSpineGeo = new THREE.ConeGeometry(0.5, 2 - i * 0.15, 4);
        const tailSpine = new THREE.Mesh(tailSpineGeo, neonSpines);
        tailSpine.position.set(0, 10 - i * 1.2, -10 - i * 4);
        godzillaGroup.add(tailSpine);
      }
    }

    // Tail tip (for gas emission reference)
    const tailTipPos = new THREE.Vector3(0, -8, -55);

    scene.add(godzillaGroup);

    // Godzilla lights
    const godzillaLight = new THREE.PointLight(0x00ff88, 200, 80);
    godzillaLight.position.set(-40, 35, 20);
    scene.add(godzillaLight);

    const spineLight = new THREE.PointLight(0x00ffff, 100, 50);
    spineLight.position.set(-40, 30, 10);
    scene.add(spineLight);

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // TOXIC GAS CLOUDS (from mouth AND tail)
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    const toxicClouds = [];
    const MAX_CLOUDS = 80;

    function createToxicCloud(source) {
      const cloudGroup = new THREE.Group();

      const cloudMat = new THREE.MeshStandardMaterial({
        color: 0x00ff00,
        emissive: 0x00ff00,
        emissiveIntensity: 1,
        transparent: true,
        opacity: 0.7,
        metalness: 0.2,
        roughness: 0.8
      });

      for (let i = 0; i < 6; i++) {
        const size = 1.5 + Math.random() * 2.5;
        const sphereGeo = new THREE.SphereGeometry(size, 8, 8);
        const sphere = new THREE.Mesh(sphereGeo, cloudMat.clone());
        sphere.position.set(
          (Math.random() - 0.5) * 4,
          (Math.random() - 0.5) * 3,
          (Math.random() - 0.5) * 4
        );
        cloudGroup.add(sphere);
      }

      if (source === 'mouth') {
        // From Godzilla's mouth
        cloudGroup.position.set(
          -40 + (Math.random() - 0.5) * 2,
          44 + Math.random() * 2,
          35 + Math.random() * 3
        );
        cloudGroup.userData = {
          velocity: new THREE.Vector3(
            (Math.random() - 0.5) * 0.05,
            0.02 + Math.random() * 0.03,
            0.15 + Math.random() * 0.1
          ),
          life: 0,
          maxLife: 150 + Math.random() * 80,
          source: 'mouth'
        };
      } else {
        // From Godzilla's tail
        cloudGroup.position.set(
          -40 + (Math.random() - 0.5) * 3,
          5 + Math.random() * 3,
          -35 + (Math.random() - 0.5) * 5
        );
        cloudGroup.userData = {
          velocity: new THREE.Vector3(
            (Math.random() - 0.5) * 0.08,
            0.03 + Math.random() * 0.05,
            -0.1 - Math.random() * 0.1
          ),
          life: 0,
          maxLife: 200 + Math.random() * 100,
          source: 'tail'
        };
      }

      return cloudGroup;
    }

    let mouthGasTimer = 0;
    let tailGasTimer = 0;
    const mouthGasInterval = 0.15; // Faster mouth blasts
    const tailGasInterval = 0.25;

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // GOLDEN SPRINGLOCK SUIT
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    const springlockGroup = new THREE.Group();
    springlockGroup.position.set(25, 0, -15);

    const goldenMetal = new THREE.MeshStandardMaterial({
      color: 0xffd700,
      emissive: 0xaa8800,
      emissiveIntensity: 0.3,
      metalness: 0.9,
      roughness: 0.2
    });

    const darkGold = new THREE.MeshStandardMaterial({
      color: 0xb8860b,
      emissive: 0x664400,
      emissiveIntensity: 0.2,
      metalness: 0.8,
      roughness: 0.3
    });

    const springlockEyes = new THREE.MeshStandardMaterial({
      color: 0x000000,
      emissive: 0xff0000,
      emissiveIntensity: 0,
      metalness: 0.5,
      roughness: 0.5
    });

    // Suit body (torso - opens like a shell)
    const torsoFrontGeo = new THREE.CylinderGeometry(3, 4, 10, 8, 1, false, 0, Math.PI);
    const torsoFront = new THREE.Mesh(torsoFrontGeo, goldenMetal);
    torsoFront.position.set(0, 8, 0);
    torsoFront.rotation.y = Math.PI / 2;
    springlockGroup.add(torsoFront);

    const torsoBackGeo = new THREE.CylinderGeometry(3, 4, 10, 8, 1, false, Math.PI, Math.PI);
    const torsoBack = new THREE.Mesh(torsoBackGeo, goldenMetal);
    torsoBack.position.set(0, 8, 0);
    torsoBack.rotation.y = Math.PI / 2;
    springlockGroup.add(torsoBack);

    // Inner mechanism (visible when open)
    const innerGeo = new THREE.CylinderGeometry(2.5, 3.5, 9, 8);
    const innerMat = new THREE.MeshStandardMaterial({
      color: 0x333333,
      metalness: 0.9,
      roughness: 0.4
    });
    const inner = new THREE.Mesh(innerGeo, innerMat);
    inner.position.set(0, 8, 0);
    springlockGroup.add(inner);

    // Spring coils inside
    for (let i = 0; i < 6; i++) {
      const springGeo = new THREE.TorusGeometry(0.3, 0.1, 8, 16);
      const springMat = new THREE.MeshStandardMaterial({
        color: 0x888888,
        metalness: 0.9,
        roughness: 0.3
      });
      const spring = new THREE.Mesh(springGeo, springMat);
      spring.position.set(
        Math.cos(i * Math.PI / 3) * 2,
        5 + i * 1.2,
        Math.sin(i * Math.PI / 3) * 2
      );
      spring.rotation.x = Math.PI / 2;
      springlockGroup.add(spring);
    }

    // Head (also splits)
    const headFrontGeo = new THREE.SphereGeometry(2.5, 12, 12, 0, Math.PI);
    const headFront = new THREE.Mesh(headFrontGeo, goldenMetal);
    headFront.position.set(0, 15, 0);
    headFront.rotation.y = Math.PI / 2;
    springlockGroup.add(headFront);

    const headBackGeo = new THREE.SphereGeometry(2.5, 12, 12, Math.PI, Math.PI);
    const headBack = new THREE.Mesh(headBackGeo, goldenMetal);
    headBack.position.set(0, 15, 0);
    headBack.rotation.y = Math.PI / 2;
    springlockGroup.add(headBack);

    // Ears (bunny-like)
    const earGeo = new THREE.CylinderGeometry(0.5, 0.8, 4, 6);
    const earLeft = new THREE.Mesh(earGeo, goldenMetal);
    earLeft.position.set(-1.5, 18.5, 0);
    earLeft.rotation.z = 0.2;
    springlockGroup.add(earLeft);
    const earRight = new THREE.Mesh(earGeo, goldenMetal);
    earRight.position.set(1.5, 18.5, 0);
    earRight.rotation.z = -0.2;
    springlockGroup.add(earRight);

    // Eyes (menacing when triggered)
    const eyeGeoSpring = new THREE.SphereGeometry(0.5, 8, 8);
    const eyeLeft = new THREE.Mesh(eyeGeoSpring, springlockEyes.clone());
    eyeLeft.position.set(-1, 15.5, 2);
    springlockGroup.add(eyeLeft);
    const eyeRight = new THREE.Mesh(eyeGeoSpring, springlockEyes.clone());
    eyeRight.position.set(1, 15.5, 2);
    springlockGroup.add(eyeRight);

    // Mouth (creepy smile)
    const mouthGeo = new THREE.TorusGeometry(1, 0.2, 8, 16, Math.PI);
    const mouth = new THREE.Mesh(mouthGeo, darkGold);
    mouth.position.set(0, 13.5, 2.2);
    mouth.rotation.x = Math.PI;
    springlockGroup.add(mouth);

    // Arms (jointed, can snap)
    const armUpperGeo = new THREE.CylinderGeometry(0.8, 1, 5, 6);
    const armLowerGeo = new THREE.CylinderGeometry(0.6, 0.8, 4, 6);
    const handGeo = new THREE.SphereGeometry(0.8, 8, 8);

    // Left arm
    const leftArmUpper = new THREE.Mesh(armUpperGeo, goldenMetal);
    leftArmUpper.position.set(-4.5, 10, 0);
    leftArmUpper.rotation.z = 0.5;
    springlockGroup.add(leftArmUpper);
    const leftArmLower = new THREE.Mesh(armLowerGeo, goldenMetal);
    leftArmLower.position.set(-6, 6, 0);
    leftArmLower.rotation.z = 0.3;
    springlockGroup.add(leftArmLower);
    const leftHand = new THREE.Mesh(handGeo, goldenMetal);
    leftHand.position.set(-7, 3.5, 0);
    springlockGroup.add(leftHand);

    // Right arm
    const rightArmUpper = new THREE.Mesh(armUpperGeo, goldenMetal);
    rightArmUpper.position.set(4.5, 10, 0);
    rightArmUpper.rotation.z = -0.5;
    springlockGroup.add(rightArmUpper);
    const rightArmLower = new THREE.Mesh(armLowerGeo, goldenMetal);
    rightArmLower.position.set(6, 6, 0);
    rightArmLower.rotation.z = -0.3;
    springlockGroup.add(rightArmLower);
    const rightHand = new THREE.Mesh(handGeo, goldenMetal);
    rightHand.position.set(7, 3.5, 0);
    springlockGroup.add(rightHand);

    // Legs
    const legGeoSpring = new THREE.CylinderGeometry(1.2, 1.5, 6, 6);
    const leftLeg = new THREE.Mesh(legGeoSpring, goldenMetal);
    leftLeg.position.set(-2, 0, 0);
    springlockGroup.add(leftLeg);
    const rightLeg = new THREE.Mesh(legGeoSpring, goldenMetal);
    rightLeg.position.set(2, 0, 0);
    springlockGroup.add(rightLeg);

    // Feet
    const footGeoSpring = new THREE.BoxGeometry(2, 1, 3);
    const leftFootSpring = new THREE.Mesh(footGeoSpring, goldenMetal);
    leftFootSpring.position.set(-2, -3, 0.5);
    springlockGroup.add(leftFootSpring);
    const rightFootSpring = new THREE.Mesh(footGeoSpring, goldenMetal);
    rightFootSpring.position.set(2, -3, 0.5);
    springlockGroup.add(rightFootSpring);

    // Bow tie
    const bowtieGeo = new THREE.BoxGeometry(2, 0.8, 0.3);
    const bowtieMat = new THREE.MeshStandardMaterial({
      color: 0x8b0000,
      emissive: 0x440000,
      emissiveIntensity: 0.3
    });
    const bowtie = new THREE.Mesh(bowtieGeo, bowtieMat);
    bowtie.position.set(0, 12.5, 3.5);
    springlockGroup.add(bowtie);

    scene.add(springlockGroup);

    // Springlock light
    const springlockLight = new THREE.PointLight(0xffd700, 80, 40);
    springlockLight.position.set(25, 10, -15);
    scene.add(springlockLight);

    // Springlock state
    let springlockOpen = true; // Starts open, waiting
    let springlockTriggered = false;
    let snapProgress = 0;
    const TRIGGER_DISTANCE = 35; // Distance at which it snaps
    let warningFlash = 0;

    // Cigarette storage
    const cigarettes = [];
    const MAX_CIGARETTES = 500;
    let spawnedCount = 0;
    let productionComplete = false;

    // Create cigarette geometry (reusable)
    const stickGeo = new THREE.CylinderGeometry(0.15, 0.15, 3, 8);
    const filterGeo = new THREE.CylinderGeometry(0.16, 0.16, 0.8, 8);
    const tipGeo = new THREE.CylinderGeometry(0.14, 0.14, 0.1, 8);

    function createCigarette(x, y, z) {
      const group = new THREE.Group();

      // White stick
      const stick = new THREE.Mesh(stickGeo, whiteMaterial.clone());
      stick.rotation.z = Math.PI / 2;
      group.add(stick);

      // Orange filter
      const filter = new THREE.Mesh(filterGeo, neonOrange.clone());
      filter.rotation.z = Math.PI / 2;
      filter.position.x = -1.9;
      group.add(filter);

      // Glowing tip
      const tipMat = new THREE.MeshStandardMaterial({
        color: 0xff2200,
        emissive: 0xff4400,
        emissiveIntensity: 1.5
      });
      const tip = new THREE.Mesh(tipGeo, tipMat);
      tip.rotation.z = Math.PI / 2;
      tip.position.x = 1.55;
      group.add(tip);

      group.position.set(x, y, z);
      group.userData = {
        velocity: new THREE.Vector3(0.08 + Math.random() * 0.02, 0, 0),
        onConveyor: true,
        settled: false,
        settleTime: 0
      };

      return group;
    }

    // Collection bin at end of conveyor
    const binGeo = new THREE.BoxGeometry(15, 5, 8);
    const binMat = new THREE.MeshStandardMaterial({
      color: 0x1a1a2e,
      metalness: 0.7,
      roughness: 0.3,
      transparent: true,
      opacity: 0.8
    });
    const bin = new THREE.Mesh(binGeo, binMat);
    bin.position.set(55, 2.5, 0);
    scene.add(bin);

    // Bin neon trim
    const binTrimGeo = new THREE.BoxGeometry(15.2, 0.2, 8.2);
    const binTrim = new THREE.Mesh(binTrimGeo, neonCyan);
    binTrim.position.set(55, 5.1, 0);
    scene.add(binTrim);

    // Spawn timer
    let spawnTimer = 0;
    const spawnInterval = 0.05; // Spawn rate

    // UI elements
    const counterEl = document.getElementById('counter');
    const statusEl = document.getElementById('status');

    // Animation
    const clock = new THREE.Clock();

    function animate() {
      requestAnimationFrame(animate);

      const delta = clock.getDelta();

      // Spawn cigarettes
      if (spawnedCount < MAX_CIGARETTES) {
        spawnTimer += delta;
        if (spawnTimer >= spawnInterval) {
          spawnTimer = 0;
          const cig = createCigarette(
            -8,
            4 + Math.random() * 0.5,
            (Math.random() - 0.5) * 2
          );
          scene.add(cig);
          cigarettes.push(cig);
          spawnedCount++;

          counterEl.textContent = `${spawnedCount} / ${MAX_CIGARETTES}`;

          if (spawnedCount < MAX_CIGARETTES) {
            statusEl.textContent = `Production: ${Math.floor(spawnedCount / MAX_CIGARETTES * 100)}%`;
          } else {
            statusEl.textContent = 'PRODUCTION COMPLETE';
            productionComplete = true;
          }
        }
      }

      // Update cigarettes
      cigarettes.forEach((cig, index) => {
        if (cig.userData.onConveyor) {
          // Move along conveyor
          cig.position.add(cig.userData.velocity);

          // Slight bobbing
          cig.position.y = 1.8 + Math.sin(clock.elapsedTime * 5 + index) * 0.05;

          // Fall into bin at end
          if (cig.position.x > 48) {
            cig.userData.onConveyor = false;
            cig.userData.velocity = new THREE.Vector3(
              (Math.random() - 0.5) * 0.1,
              -0.05,
              (Math.random() - 0.5) * 0.1
            );
          }
        } else if (!cig.userData.settled) {
          // Falling into bin
          cig.position.add(cig.userData.velocity);
          cig.userData.velocity.y -= 0.003; // gravity

          // Settle in bin
          const binBottom = 0.5 + (index * 0.008); // Stack up
          if (cig.position.y < binBottom) {
            cig.position.y = binBottom;
            cig.userData.settled = true;
            // Random rotation when settled
            cig.rotation.y = Math.random() * Math.PI;
            cig.rotation.z = Math.PI / 2 + (Math.random() - 0.5) * 0.3;
          }

          // Keep in bin bounds
          cig.position.x = Math.max(48, Math.min(62, cig.position.x));
          cig.position.z = Math.max(-3.5, Math.min(3.5, cig.position.z));
        }

        // Pulse the glowing tips
        const tip = cig.children[2];
        if (tip && tip.material) {
          tip.material.emissiveIntensity = 1 + Math.sin(clock.elapsedTime * 3 + index) * 0.5;
        }
      });

      // Animate lights
      mainLight.intensity = 100 + Math.sin(clock.elapsedTime * 2) * 20;
      accentLight.intensity = 80 + Math.cos(clock.elapsedTime * 1.5) * 15;

      // Animate Godzilla (menacing sway and breathing)
      godzillaGroup.rotation.y = Math.sin(clock.elapsedTime * 0.3) * 0.03;
      // Breathing effect on torso
      const breathScale = 1 + Math.sin(clock.elapsedTime * 1.5) * 0.02;
      godzillaGroup.children[0].scale.set(breathScale, 1, breathScale);
      // Tail sway
      godzillaGroup.children.forEach((child, i) => {
        if (i > 20 && i < 35) { // Tail segments
          child.rotation.y = Math.sin(clock.elapsedTime * 0.8 + i * 0.3) * 0.1;
        }
      });

      // Spawn toxic gas from MOUTH
      mouthGasTimer += delta;
      if (mouthGasTimer >= mouthGasInterval && toxicClouds.length < MAX_CLOUDS) {
        mouthGasTimer = 0;
        const cloud = createToxicCloud('mouth');
        scene.add(cloud);
        toxicClouds.push(cloud);
      }

      // Spawn toxic gas from TAIL
      tailGasTimer += delta;
      if (tailGasTimer >= tailGasInterval && toxicClouds.length < MAX_CLOUDS) {
        tailGasTimer = 0;
        const cloud = createToxicCloud('tail');
        scene.add(cloud);
        toxicClouds.push(cloud);
      }

      // Update toxic gas clouds
      for (let i = toxicClouds.length - 1; i >= 0; i--) {
        const cloud = toxicClouds[i];
        cloud.position.add(cloud.userData.velocity);
        cloud.userData.life++;

        // Expand and fade
        const lifeRatio = cloud.userData.life / cloud.userData.maxLife;
        const scale = 1 + lifeRatio * 2;
        cloud.scale.set(scale, scale, scale);

        // Fade out
        cloud.children.forEach(sphere => {
          if (sphere.material) {
            sphere.material.opacity = 0.6 * (1 - lifeRatio);
          }
        });

        // Pulse glow
        cloud.children.forEach((sphere, j) => {
          if (sphere.material) {
            sphere.material.emissiveIntensity = 0.5 + Math.sin(clock.elapsedTime * 3 + j) * 0.3;
          }
        });

        // Remove dead clouds
        if (cloud.userData.life >= cloud.userData.maxLife) {
          scene.remove(cloud);
          cloud.children.forEach(c => {
            if (c.geometry) c.geometry.dispose();
            if (c.material) c.material.dispose();
          });
          toxicClouds.splice(i, 1);
        }
      }

      // Godzilla lights pulse
      godzillaLight.intensity = 200 + Math.sin(clock.elapsedTime * 1.5) * 50;
      spineLight.intensity = 100 + Math.sin(clock.elapsedTime * 3) * 40;

      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      // SPRINGLOCK SUIT ANIMATION
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

      // Springlock triggers periodically when Godzilla "gets close"
      // Simulated by time-based cycle (every 8 seconds it snaps)
      const snapCycle = Math.floor(clock.elapsedTime / 8);
      const cyclePhase = (clock.elapsedTime % 8);

      // Trigger snap at start of each cycle (if not already snapping)
      if (cyclePhase < 0.1 && springlockOpen && !springlockTriggered && snapCycle > 0) {
        springlockTriggered = true;
        springlockOpen = false;
      }

      // Animate the springlock based on state
      if (springlockOpen) {
        // Open state - parts spread apart, inviting
        const openAmount = 0.5 + Math.sin(clock.elapsedTime * 2) * 0.1;

        // Torso halves spread
        torsoFront.position.z = 2 * openAmount;
        torsoBack.position.z = -2 * openAmount;

        // Head halves spread
        headFront.position.z = 1.5 * openAmount;
        headBack.position.z = -1.5 * openAmount;

        // Arms spread wide
        leftArmUpper.rotation.z = 0.5 + openAmount * 0.5;
        rightArmUpper.rotation.z = -0.5 - openAmount * 0.5;

        // Gentle idle sway
        springlockGroup.rotation.y = Math.sin(clock.elapsedTime * 0.5) * 0.05;

        // Eyes dim
        eyeLeft.material.emissiveIntensity = 0.1;
        eyeRight.material.emissiveIntensity = 0.1;

      } else if (springlockTriggered) {
        // SNAP SHUT!
        snapProgress = Math.min(1, snapProgress + delta * 3); // Fast snap

        const easeOut = 1 - Math.pow(1 - snapProgress, 3);
        const snapAmount = 1 - easeOut;

        // Torso SLAMS shut
        torsoFront.position.z = 1 * snapAmount;
        torsoBack.position.z = -1 * snapAmount;

        // Head SLAMS shut
        headFront.position.z = 0.75 * snapAmount;
        headBack.position.z = -0.75 * snapAmount;

        // Arms snap inward (grabbing motion)
        leftArmUpper.rotation.z = 0.5 * snapAmount - 0.3 * easeOut;
        rightArmUpper.rotation.z = -0.5 * snapAmount + 0.3 * easeOut;
        leftArmLower.rotation.z = 0.3 * snapAmount + 0.5 * easeOut;
        rightArmLower.rotation.z = -0.3 * snapAmount - 0.5 * easeOut;

        // Eyes GLOW RED menacingly
        const eyeGlow = 2 + Math.sin(clock.elapsedTime * 10) * 1;
        eyeLeft.material.emissiveIntensity = eyeGlow * easeOut;
        eyeRight.material.emissiveIntensity = eyeGlow * easeOut;

        // Warning flash on light
        warningFlash += delta * 15;
        springlockLight.color.setHex(
          Math.sin(warningFlash) > 0 ? 0xff0000 : 0xffd700
        );
        springlockLight.intensity = 150 + Math.sin(warningFlash * 2) * 50;

        // Shake when snapping
        if (snapProgress < 0.5) {
          springlockGroup.position.x = 25 + (Math.random() - 0.5) * 0.5;
          springlockGroup.position.z = -15 + (Math.random() - 0.5) * 0.5;
        }

        // Reset after fully snapped and some time passes
        if (snapProgress >= 1) {
          // Stay closed for a moment, then slowly reopen
          setTimeout(() => {
            springlockTriggered = false;
            springlockOpen = true;
            snapProgress = 0;
            springlockLight.color.setHex(0xffd700);
            springlockGroup.position.set(25, 0, -15);
          }, 3000);
        }
      }

      controls.update();
      composer.render();
    }

    // Handle resize
    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
      composer.setSize(window.innerWidth, window.innerHeight);
    });

    // Start
    statusEl.textContent = 'Production starting...';
    animate();
  </script>
</body>
</html>
