<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Neon Cigarette Factory</title>
  <meta name="description" content="3D neon factory spawning 500 glowing sticks">
  <meta property="og:title" content="Neon Cigarette Factory">
  <meta property="og:description" content="Watch 500 glowing sticks roll off the neon assembly line">
  <meta property="og:url" content="https://sloppy.live/neon-cigarette-factory/">
  <meta property="og:image" content="https://emojicdn.elk.sh/üö¨">
  <link rel="icon" href="https://emojicdn.elk.sh/üè≠">
  <style>
    @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700&display=swap');

    * { margin: 0; padding: 0; box-sizing: border-box; }

    body {
      background: #0a0a0f;
      overflow: hidden;
      font-family: 'Orbitron', monospace;
    }

    #canvas-container {
      width: 100vw;
      height: 100vh;
      position: fixed;
      top: 0;
      left: 0;
    }

    #ui {
      position: fixed;
      top: 20px;
      left: 20px;
      z-index: 100;
      color: #0ff;
      text-shadow: 0 0 10px #0ff, 0 0 20px #0ff;
    }

    h1 {
      font-size: 1.5rem;
      margin-bottom: 10px;
      color: #f0f;
      text-shadow: 0 0 10px #f0f, 0 0 20px #f0f;
    }

    #counter {
      font-size: 2rem;
      color: #0f0;
      text-shadow: 0 0 10px #0f0, 0 0 30px #0f0;
    }

    #status {
      margin-top: 10px;
      font-size: 0.8rem;
      opacity: 0.8;
    }

    #backlink {
      position: fixed;
      bottom: 20px;
      left: 20px;
      z-index: 100;
    }

    #backlink a {
      color: #f0f;
      text-decoration: none;
      font-size: 0.8rem;
      opacity: 0.7;
      transition: opacity 0.3s;
    }

    #backlink a:hover {
      opacity: 1;
      text-shadow: 0 0 10px #f0f;
    }

    #controls {
      position: fixed;
      bottom: 20px;
      right: 20px;
      z-index: 100;
      color: #666;
      font-size: 0.7rem;
      text-align: right;
    }
  </style>
</head>
<body>
  <div id="canvas-container"></div>

  <div id="ui">
    <h1>NEON CIGARETTE FACTORY</h1>
    <div id="counter">0 / 500</div>
    <div id="status">Initializing production line...</div>
  </div>

  <div id="backlink">
    <a href="https://sloppy.live">‚Üê sloppy.live</a>
  </div>

  <div id="controls">
    Drag to rotate ‚Ä¢ Scroll to zoom
  </div>

  <script type="importmap">
  {
    "imports": {
      "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
      "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
    }
  }
  </script>

  <script type="module">
    import * as THREE from 'three';
    import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
    import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
    import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
    import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';

    // Scene setup
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x050508);
    scene.fog = new THREE.FogExp2(0x050508, 0.015);

    const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.set(30, 25, 40);

    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    renderer.toneMapping = THREE.ReinhardToneMapping;
    renderer.toneMappingExposure = 1.5;
    document.getElementById('canvas-container').appendChild(renderer.domElement);

    // Controls
    const controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;
    controls.dampingFactor = 0.05;
    controls.maxPolarAngle = Math.PI / 2.1;

    // Post-processing bloom
    const composer = new EffectComposer(renderer);
    composer.addPass(new RenderPass(scene, camera));
    const bloomPass = new UnrealBloomPass(
      new THREE.Vector2(window.innerWidth, window.innerHeight),
      1.5, 0.4, 0.85
    );
    bloomPass.threshold = 0.1;
    bloomPass.strength = 2;
    bloomPass.radius = 0.5;
    composer.addPass(bloomPass);

    // Neon materials
    const neonCyan = new THREE.MeshStandardMaterial({
      color: 0x00ffff,
      emissive: 0x00ffff,
      emissiveIntensity: 0.5,
      metalness: 0.8,
      roughness: 0.2
    });

    const neonMagenta = new THREE.MeshStandardMaterial({
      color: 0xff00ff,
      emissive: 0xff00ff,
      emissiveIntensity: 0.5,
      metalness: 0.8,
      roughness: 0.2
    });

    const neonOrange = new THREE.MeshStandardMaterial({
      color: 0xff6600,
      emissive: 0xff4400,
      emissiveIntensity: 0.8,
      metalness: 0.3,
      roughness: 0.4
    });

    const whiteMaterial = new THREE.MeshStandardMaterial({
      color: 0xeeeeee,
      emissive: 0x333333,
      emissiveIntensity: 0.2,
      metalness: 0.1,
      roughness: 0.6
    });

    const darkMetal = new THREE.MeshStandardMaterial({
      color: 0x222233,
      metalness: 0.9,
      roughness: 0.3
    });

    // Factory floor
    const floorGeo = new THREE.PlaneGeometry(200, 200);
    const floorMat = new THREE.MeshStandardMaterial({
      color: 0x111118,
      metalness: 0.8,
      roughness: 0.4
    });
    const floor = new THREE.Mesh(floorGeo, floorMat);
    floor.rotation.x = -Math.PI / 2;
    floor.position.y = -0.1;
    scene.add(floor);

    // Grid lines on floor
    const gridHelper = new THREE.GridHelper(200, 50, 0x00ffff, 0x111133);
    gridHelper.position.y = 0;
    scene.add(gridHelper);

    // Factory machine base
    const machineBaseGeo = new THREE.BoxGeometry(20, 4, 10);
    const machineBase = new THREE.Mesh(machineBaseGeo, darkMetal);
    machineBase.position.set(0, 2, 0);
    scene.add(machineBase);

    // Machine top
    const machineTopGeo = new THREE.BoxGeometry(18, 6, 8);
    const machineTop = new THREE.Mesh(machineTopGeo, darkMetal);
    machineTop.position.set(0, 7, 0);
    scene.add(machineTop);

    // Neon trim on machine
    const trimGeo = new THREE.BoxGeometry(20.2, 0.3, 10.2);
    const trim1 = new THREE.Mesh(trimGeo, neonCyan);
    trim1.position.set(0, 4.1, 0);
    scene.add(trim1);

    const trim2 = new THREE.Mesh(trimGeo.clone(), neonMagenta);
    trim2.position.set(0, 0.1, 0);
    scene.add(trim2);

    // Conveyor belt
    const conveyorGeo = new THREE.BoxGeometry(60, 0.5, 4);
    const conveyorMat = new THREE.MeshStandardMaterial({
      color: 0x1a1a2e,
      metalness: 0.6,
      roughness: 0.5
    });
    const conveyor = new THREE.Mesh(conveyorGeo, conveyorMat);
    conveyor.position.set(20, 1, 0);
    scene.add(conveyor);

    // Conveyor side rails
    const railGeo = new THREE.BoxGeometry(60, 1, 0.2);
    const rail1 = new THREE.Mesh(railGeo, neonCyan);
    rail1.position.set(20, 1.5, 2);
    scene.add(rail1);
    const rail2 = new THREE.Mesh(railGeo, neonCyan);
    rail2.position.set(20, 1.5, -2);
    scene.add(rail2);

    // Smoke stacks
    for (let i = 0; i < 3; i++) {
      const stackGeo = new THREE.CylinderGeometry(1, 1.5, 12, 8);
      const stack = new THREE.Mesh(stackGeo, darkMetal);
      stack.position.set(-5 + i * 5, 16, -3);
      scene.add(stack);

      // Neon ring on stack
      const ringGeo = new THREE.TorusGeometry(1.2, 0.15, 8, 16);
      const ring = new THREE.Mesh(ringGeo, neonMagenta);
      ring.rotation.x = Math.PI / 2;
      ring.position.set(-5 + i * 5, 22, -3);
      scene.add(ring);
    }

    // Lights
    const ambientLight = new THREE.AmbientLight(0x111122, 0.5);
    scene.add(ambientLight);

    const mainLight = new THREE.PointLight(0x00ffff, 100, 100);
    mainLight.position.set(0, 20, 10);
    scene.add(mainLight);

    const accentLight = new THREE.PointLight(0xff00ff, 80, 80);
    accentLight.position.set(-10, 15, -10);
    scene.add(accentLight);

    const factoryLight = new THREE.SpotLight(0xffaa00, 100, 50, Math.PI / 4);
    factoryLight.position.set(0, 25, 0);
    factoryLight.target.position.set(10, 0, 0);
    scene.add(factoryLight);
    scene.add(factoryLight.target);

    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // MASSIVE NEON GODZILLA
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    const godzillaGroup = new THREE.Group();
    godzillaGroup.position.set(-40, 0, 20);

    const neonGodzilla = new THREE.MeshStandardMaterial({
      color: 0x00ff88,
      emissive: 0x00ff44,
      emissiveIntensity: 0.6,
      metalness: 0.5,
      roughness: 0.3
    });

    const neonSpines = new THREE.MeshStandardMaterial({
      color: 0x00ffff,
      emissive: 0x00ffff,
      emissiveIntensity: 1.2,
      metalness: 0.7,
      roughness: 0.2
    });

    const neonBelly = new THREE.MeshStandardMaterial({
      color: 0x88ffaa,
      emissive: 0x44ff66,
      emissiveIntensity: 0.4,
      metalness: 0.3,
      roughness: 0.5
    });

    // Godzilla body (massive torso)
    const torsoGeo = new THREE.CylinderGeometry(6, 8, 25, 12);
    const torso = new THREE.Mesh(torsoGeo, neonGodzilla);
    torso.position.set(0, 20, 0);
    godzillaGroup.add(torso);

    // Belly plate
    const bellyGeo = new THREE.CylinderGeometry(5, 7, 20, 12, 1, false, 0, Math.PI);
    const belly = new THREE.Mesh(bellyGeo, neonBelly);
    belly.position.set(0, 18, 3);
    belly.rotation.y = Math.PI;
    godzillaGroup.add(belly);

    // Godzilla legs (massive)
    const thighGeo = new THREE.CylinderGeometry(3, 4, 12, 8);
    const calfGeo = new THREE.CylinderGeometry(2.5, 3, 10, 8);
    const footGeo = new THREE.BoxGeometry(6, 2, 8);

    // Left leg
    const leftThigh = new THREE.Mesh(thighGeo, neonGodzilla);
    leftThigh.position.set(-5, 10, 0);
    leftThigh.rotation.z = 0.1;
    godzillaGroup.add(leftThigh);
    const leftCalf = new THREE.Mesh(calfGeo, neonGodzilla);
    leftCalf.position.set(-6, 2, 0);
    godzillaGroup.add(leftCalf);
    const leftFoot = new THREE.Mesh(footGeo, neonGodzilla);
    leftFoot.position.set(-6, -2, 1);
    godzillaGroup.add(leftFoot);

    // Right leg
    const rightThigh = new THREE.Mesh(thighGeo, neonGodzilla);
    rightThigh.position.set(5, 10, 0);
    rightThigh.rotation.z = -0.1;
    godzillaGroup.add(rightThigh);
    const rightCalf = new THREE.Mesh(calfGeo, neonGodzilla);
    rightCalf.position.set(6, 2, 0);
    godzillaGroup.add(rightCalf);
    const rightFoot = new THREE.Mesh(footGeo, neonGodzilla);
    rightFoot.position.set(6, -2, 1);
    godzillaGroup.add(rightFoot);

    // Claws on feet
    const clawGeo = new THREE.ConeGeometry(0.5, 2, 6);
    for (let foot of [-6, 6]) {
      for (let c = -2; c <= 2; c += 2) {
        const claw = new THREE.Mesh(clawGeo, neonSpines);
        claw.position.set(foot, -3, 4 + c * 0.3);
        claw.rotation.x = Math.PI / 2;
        godzillaGroup.add(claw);
      }
    }

    // Arms (small T-rex style)
    const armGeo = new THREE.CylinderGeometry(1, 1.5, 6, 6);
    const leftArm = new THREE.Mesh(armGeo, neonGodzilla);
    leftArm.position.set(-7, 28, 4);
    leftArm.rotation.z = 0.8;
    leftArm.rotation.x = -0.3;
    godzillaGroup.add(leftArm);
    const rightArm = new THREE.Mesh(armGeo, neonGodzilla);
    rightArm.position.set(7, 28, 4);
    rightArm.rotation.z = -0.8;
    rightArm.rotation.x = -0.3;
    godzillaGroup.add(rightArm);

    // Neck
    const neckGeo = new THREE.CylinderGeometry(3, 5, 10, 8);
    const neck = new THREE.Mesh(neckGeo, neonGodzilla);
    neck.position.set(0, 38, 2);
    neck.rotation.x = -0.3;
    godzillaGroup.add(neck);

    // Head
    const headGeo = new THREE.SphereGeometry(5, 12, 12);
    const head = new THREE.Mesh(headGeo, neonGodzilla);
    head.position.set(0, 46, 5);
    head.scale.set(1, 0.8, 1.3);
    godzillaGroup.add(head);

    // Snout/Jaw
    const jawGeo = new THREE.BoxGeometry(4, 3, 8);
    const jaw = new THREE.Mesh(jawGeo, neonGodzilla);
    jaw.position.set(0, 44, 10);
    godzillaGroup.add(jaw);

    // Teeth
    for (let i = -1.5; i <= 1.5; i += 1) {
      const toothGeo = new THREE.ConeGeometry(0.3, 1.5, 4);
      const tooth = new THREE.Mesh(toothGeo, neonSpines);
      tooth.position.set(i, 42.5, 13);
      tooth.rotation.x = Math.PI;
      godzillaGroup.add(tooth);
    }

    // Eyes (glowing red menacing)
    const eyeGeo = new THREE.SphereGeometry(1, 8, 8);
    const eyeMat = new THREE.MeshStandardMaterial({
      color: 0xff0000,
      emissive: 0xff0000,
      emissiveIntensity: 3
    });
    const eye1 = new THREE.Mesh(eyeGeo, eyeMat);
    eye1.position.set(-2.5, 47, 8);
    godzillaGroup.add(eye1);
    const eye2 = new THREE.Mesh(eyeGeo, eyeMat);
    eye2.position.set(2.5, 47, 8);
    godzillaGroup.add(eye2);

    // Dorsal spines (iconic!)
    const spineHeights = [4, 6, 8, 10, 9, 7, 5, 4, 3, 2, 1.5];
    spineHeights.forEach((h, i) => {
      const spineGeo = new THREE.ConeGeometry(1 + h * 0.1, h, 4);
      const spine = new THREE.Mesh(spineGeo, neonSpines);
      spine.position.set(0, 20 + i * 2, -6 - i * 0.5);
      spine.rotation.x = -0.2;
      godzillaGroup.add(spine);
    });

    // MASSIVE TAIL
    const tailSegments = 12;
    for (let i = 0; i < tailSegments; i++) {
      const segSize = 4 - i * 0.25;
      const tailSegGeo = new THREE.CylinderGeometry(segSize * 0.8, segSize, 5, 8);
      const tailSeg = new THREE.Mesh(tailSegGeo, neonGodzilla);
      tailSeg.position.set(0, 8 - i * 1.5, -10 - i * 4);
      tailSeg.rotation.x = 0.2 + i * 0.05;
      godzillaGroup.add(tailSeg);

      // Tail spines
      if (i < 8) {
        const tailSpineGeo = new THREE.ConeGeometry(0.5, 2 - i * 0.15, 4);
        const tailSpine = new THREE.Mesh(tailSpineGeo, neonSpines);
        tailSpine.position.set(0, 10 - i * 1.2, -10 - i * 4);
        godzillaGroup.add(tailSpine);
      }
    }

    // Tail tip (for gas emission reference)
    const tailTipPos = new THREE.Vector3(0, -8, -55);

    scene.add(godzillaGroup);

    // Godzilla lights
    const godzillaLight = new THREE.PointLight(0x00ff88, 200, 80);
    godzillaLight.position.set(-40, 35, 20);
    scene.add(godzillaLight);

    const spineLight = new THREE.PointLight(0x00ffff, 100, 50);
    spineLight.position.set(-40, 30, 10);
    scene.add(spineLight);

    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // TOXIC GAS CLOUDS (from mouth AND tail)
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    const toxicClouds = [];
    const MAX_CLOUDS = 80;

    function createToxicCloud(source) {
      const cloudGroup = new THREE.Group();

      const cloudMat = new THREE.MeshStandardMaterial({
        color: 0x00ff00,
        emissive: 0x00ff00,
        emissiveIntensity: 1,
        transparent: true,
        opacity: 0.7,
        metalness: 0.2,
        roughness: 0.8
      });

      for (let i = 0; i < 6; i++) {
        const size = 1.5 + Math.random() * 2.5;
        const sphereGeo = new THREE.SphereGeometry(size, 8, 8);
        const sphere = new THREE.Mesh(sphereGeo, cloudMat.clone());
        sphere.position.set(
          (Math.random() - 0.5) * 4,
          (Math.random() - 0.5) * 3,
          (Math.random() - 0.5) * 4
        );
        cloudGroup.add(sphere);
      }

      if (source === 'mouth') {
        // From Godzilla's mouth
        cloudGroup.position.set(
          -40 + (Math.random() - 0.5) * 2,
          44 + Math.random() * 2,
          35 + Math.random() * 3
        );
        cloudGroup.userData = {
          velocity: new THREE.Vector3(
            (Math.random() - 0.5) * 0.05,
            0.02 + Math.random() * 0.03,
            0.15 + Math.random() * 0.1
          ),
          life: 0,
          maxLife: 150 + Math.random() * 80,
          source: 'mouth'
        };
      } else {
        // From Godzilla's tail
        cloudGroup.position.set(
          -40 + (Math.random() - 0.5) * 3,
          5 + Math.random() * 3,
          -35 + (Math.random() - 0.5) * 5
        );
        cloudGroup.userData = {
          velocity: new THREE.Vector3(
            (Math.random() - 0.5) * 0.08,
            0.03 + Math.random() * 0.05,
            -0.1 - Math.random() * 0.1
          ),
          life: 0,
          maxLife: 200 + Math.random() * 100,
          source: 'tail'
        };
      }

      return cloudGroup;
    }

    let mouthGasTimer = 0;
    let tailGasTimer = 0;
    const mouthGasInterval = 0.15; // Faster mouth blasts
    const tailGasInterval = 0.25;

    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // GOLDEN SPRINGLOCK SUIT
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    const springlockGroup = new THREE.Group();
    springlockGroup.position.set(25, 0, -15);

    const goldenMetal = new THREE.MeshStandardMaterial({
      color: 0xffd700,
      emissive: 0xaa8800,
      emissiveIntensity: 0.3,
      metalness: 0.9,
      roughness: 0.2
    });

    const darkGold = new THREE.MeshStandardMaterial({
      color: 0xb8860b,
      emissive: 0x664400,
      emissiveIntensity: 0.2,
      metalness: 0.8,
      roughness: 0.3
    });

    const springlockEyes = new THREE.MeshStandardMaterial({
      color: 0x000000,
      emissive: 0xff0000,
      emissiveIntensity: 0,
      metalness: 0.5,
      roughness: 0.5
    });

    // Suit body (torso - opens like a shell)
    const torsoFrontGeo = new THREE.CylinderGeometry(3, 4, 10, 8, 1, false, 0, Math.PI);
    const torsoFront = new THREE.Mesh(torsoFrontGeo, goldenMetal);
    torsoFront.position.set(0, 8, 0);
    torsoFront.rotation.y = Math.PI / 2;
    springlockGroup.add(torsoFront);

    const torsoBackGeo = new THREE.CylinderGeometry(3, 4, 10, 8, 1, false, Math.PI, Math.PI);
    const torsoBack = new THREE.Mesh(torsoBackGeo, goldenMetal);
    torsoBack.position.set(0, 8, 0);
    torsoBack.rotation.y = Math.PI / 2;
    springlockGroup.add(torsoBack);

    // Inner mechanism (visible when open)
    const innerGeo = new THREE.CylinderGeometry(2.5, 3.5, 9, 8);
    const innerMat = new THREE.MeshStandardMaterial({
      color: 0x333333,
      metalness: 0.9,
      roughness: 0.4
    });
    const inner = new THREE.Mesh(innerGeo, innerMat);
    inner.position.set(0, 8, 0);
    springlockGroup.add(inner);

    // Spring coils inside
    for (let i = 0; i < 6; i++) {
      const springGeo = new THREE.TorusGeometry(0.3, 0.1, 8, 16);
      const springMat = new THREE.MeshStandardMaterial({
        color: 0x888888,
        metalness: 0.9,
        roughness: 0.3
      });
      const spring = new THREE.Mesh(springGeo, springMat);
      spring.position.set(
        Math.cos(i * Math.PI / 3) * 2,
        5 + i * 1.2,
        Math.sin(i * Math.PI / 3) * 2
      );
      spring.rotation.x = Math.PI / 2;
      springlockGroup.add(spring);
    }

    // Head (also splits)
    const headFrontGeo = new THREE.SphereGeometry(2.5, 12, 12, 0, Math.PI);
    const headFront = new THREE.Mesh(headFrontGeo, goldenMetal);
    headFront.position.set(0, 15, 0);
    headFront.rotation.y = Math.PI / 2;
    springlockGroup.add(headFront);

    const headBackGeo = new THREE.SphereGeometry(2.5, 12, 12, Math.PI, Math.PI);
    const headBack = new THREE.Mesh(headBackGeo, goldenMetal);
    headBack.position.set(0, 15, 0);
    headBack.rotation.y = Math.PI / 2;
    springlockGroup.add(headBack);

    // Ears (bunny-like)
    const earGeo = new THREE.CylinderGeometry(0.5, 0.8, 4, 6);
    const earLeft = new THREE.Mesh(earGeo, goldenMetal);
    earLeft.position.set(-1.5, 18.5, 0);
    earLeft.rotation.z = 0.2;
    springlockGroup.add(earLeft);
    const earRight = new THREE.Mesh(earGeo, goldenMetal);
    earRight.position.set(1.5, 18.5, 0);
    earRight.rotation.z = -0.2;
    springlockGroup.add(earRight);

    // Eyes (menacing when triggered)
    const eyeGeoSpring = new THREE.SphereGeometry(0.5, 8, 8);
    const eyeLeft = new THREE.Mesh(eyeGeoSpring, springlockEyes.clone());
    eyeLeft.position.set(-1, 15.5, 2);
    springlockGroup.add(eyeLeft);
    const eyeRight = new THREE.Mesh(eyeGeoSpring, springlockEyes.clone());
    eyeRight.position.set(1, 15.5, 2);
    springlockGroup.add(eyeRight);

    // Mouth (creepy smile)
    const mouthGeo = new THREE.TorusGeometry(1, 0.2, 8, 16, Math.PI);
    const mouth = new THREE.Mesh(mouthGeo, darkGold);
    mouth.position.set(0, 13.5, 2.2);
    mouth.rotation.x = Math.PI;
    springlockGroup.add(mouth);

    // Arms (jointed, can snap)
    const armUpperGeo = new THREE.CylinderGeometry(0.8, 1, 5, 6);
    const armLowerGeo = new THREE.CylinderGeometry(0.6, 0.8, 4, 6);
    const handGeo = new THREE.SphereGeometry(0.8, 8, 8);

    // Left arm
    const leftArmUpper = new THREE.Mesh(armUpperGeo, goldenMetal);
    leftArmUpper.position.set(-4.5, 10, 0);
    leftArmUpper.rotation.z = 0.5;
    springlockGroup.add(leftArmUpper);
    const leftArmLower = new THREE.Mesh(armLowerGeo, goldenMetal);
    leftArmLower.position.set(-6, 6, 0);
    leftArmLower.rotation.z = 0.3;
    springlockGroup.add(leftArmLower);
    const leftHand = new THREE.Mesh(handGeo, goldenMetal);
    leftHand.position.set(-7, 3.5, 0);
    springlockGroup.add(leftHand);

    // Right arm
    const rightArmUpper = new THREE.Mesh(armUpperGeo, goldenMetal);
    rightArmUpper.position.set(4.5, 10, 0);
    rightArmUpper.rotation.z = -0.5;
    springlockGroup.add(rightArmUpper);
    const rightArmLower = new THREE.Mesh(armLowerGeo, goldenMetal);
    rightArmLower.position.set(6, 6, 0);
    rightArmLower.rotation.z = -0.3;
    springlockGroup.add(rightArmLower);
    const rightHand = new THREE.Mesh(handGeo, goldenMetal);
    rightHand.position.set(7, 3.5, 0);
    springlockGroup.add(rightHand);

    // Legs
    const legGeoSpring = new THREE.CylinderGeometry(1.2, 1.5, 6, 6);
    const leftLeg = new THREE.Mesh(legGeoSpring, goldenMetal);
    leftLeg.position.set(-2, 0, 0);
    springlockGroup.add(leftLeg);
    const rightLeg = new THREE.Mesh(legGeoSpring, goldenMetal);
    rightLeg.position.set(2, 0, 0);
    springlockGroup.add(rightLeg);

    // Feet
    const footGeoSpring = new THREE.BoxGeometry(2, 1, 3);
    const leftFootSpring = new THREE.Mesh(footGeoSpring, goldenMetal);
    leftFootSpring.position.set(-2, -3, 0.5);
    springlockGroup.add(leftFootSpring);
    const rightFootSpring = new THREE.Mesh(footGeoSpring, goldenMetal);
    rightFootSpring.position.set(2, -3, 0.5);
    springlockGroup.add(rightFootSpring);

    // Bow tie
    const bowtieGeo = new THREE.BoxGeometry(2, 0.8, 0.3);
    const bowtieMat = new THREE.MeshStandardMaterial({
      color: 0x8b0000,
      emissive: 0x440000,
      emissiveIntensity: 0.3
    });
    const bowtie = new THREE.Mesh(bowtieGeo, bowtieMat);
    bowtie.position.set(0, 12.5, 3.5);
    springlockGroup.add(bowtie);

    scene.add(springlockGroup);

    // Springlock light
    const springlockLight = new THREE.PointLight(0xffd700, 80, 40);
    springlockLight.position.set(25, 10, -15);
    scene.add(springlockLight);

    // Springlock state
    let springlockOpen = true; // Starts open, waiting
    let springlockTriggered = false;
    let snapProgress = 0;
    const TRIGGER_DISTANCE = 35; // Distance at which it snaps
    let warningFlash = 0;

    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // NEON TAX AUDITOR (with sharp teeth)
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    const auditorGroup = new THREE.Group();
    auditorGroup.position.set(40, 0, 30);

    const suitMaterial = new THREE.MeshStandardMaterial({
      color: 0x1a1a2e,
      emissive: 0x0a0a15,
      emissiveIntensity: 0.2,
      metalness: 0.3,
      roughness: 0.7
    });

    const neonRed = new THREE.MeshStandardMaterial({
      color: 0xff0033,
      emissive: 0xff0033,
      emissiveIntensity: 0.8,
      metalness: 0.5,
      roughness: 0.3
    });

    const skinTone = new THREE.MeshStandardMaterial({
      color: 0x8b8b8b,
      emissive: 0x333344,
      emissiveIntensity: 0.2,
      metalness: 0.2,
      roughness: 0.6
    });

    const teethMaterial = new THREE.MeshStandardMaterial({
      color: 0xffffff,
      emissive: 0xffffff,
      emissiveIntensity: 0.5,
      metalness: 0.8,
      roughness: 0.1
    });

    // Body (tall, imposing suit)
    const auditorTorsoGeo = new THREE.BoxGeometry(6, 12, 4);
    const auditorTorso = new THREE.Mesh(auditorTorsoGeo, suitMaterial);
    auditorTorso.position.set(0, 12, 0);
    auditorGroup.add(auditorTorso);

    // Neon red tie
    const tieGeo = new THREE.BoxGeometry(1, 8, 0.3);
    const tie = new THREE.Mesh(tieGeo, neonRed);
    tie.position.set(0, 11, 2.2);
    auditorGroup.add(tie);

    // Tie knot
    const knotGeo = new THREE.BoxGeometry(1.5, 1, 0.4);
    const knot = new THREE.Mesh(knotGeo, neonRed);
    knot.position.set(0, 16, 2.2);
    auditorGroup.add(knot);

    // Shirt collar glow
    const collarGeo = new THREE.BoxGeometry(5, 1.5, 3.5);
    const collarMat = new THREE.MeshStandardMaterial({
      color: 0xeeeeee,
      emissive: 0x666666,
      emissiveIntensity: 0.3
    });
    const collar = new THREE.Mesh(collarGeo, collarMat);
    collar.position.set(0, 17.5, 0);
    auditorGroup.add(collar);

    // Head
    const auditorHeadGeo = new THREE.BoxGeometry(4, 5, 4);
    const auditorHead = new THREE.Mesh(auditorHeadGeo, skinTone);
    auditorHead.position.set(0, 22, 0);
    auditorGroup.add(auditorHead);

    // Slicked back hair
    const hairGeo = new THREE.BoxGeometry(4.2, 2, 4.2);
    const hairMat = new THREE.MeshStandardMaterial({
      color: 0x111111,
      emissive: 0x050505,
      metalness: 0.8,
      roughness: 0.3
    });
    const hair = new THREE.Mesh(hairGeo, hairMat);
    hair.position.set(0, 24.5, -0.2);
    auditorGroup.add(hair);

    // Menacing eyes (glowing red)
    const auditorEyeGeo = new THREE.SphereGeometry(0.4, 8, 8);
    const auditorEyeMat = new THREE.MeshStandardMaterial({
      color: 0xff0000,
      emissive: 0xff0000,
      emissiveIntensity: 2
    });
    const auditorEyeL = new THREE.Mesh(auditorEyeGeo, auditorEyeMat.clone());
    auditorEyeL.position.set(-1, 22.5, 2);
    auditorGroup.add(auditorEyeL);
    const auditorEyeR = new THREE.Mesh(auditorEyeGeo, auditorEyeMat.clone());
    auditorEyeR.position.set(1, 22.5, 2);
    auditorGroup.add(auditorEyeR);

    // Glasses (neon frames)
    const glassFrameGeo = new THREE.TorusGeometry(0.6, 0.08, 8, 16);
    const glassMat = new THREE.MeshStandardMaterial({
      color: 0x00ffff,
      emissive: 0x00ffff,
      emissiveIntensity: 0.8
    });
    const glassL = new THREE.Mesh(glassFrameGeo, glassMat);
    glassL.position.set(-1, 22.5, 2.1);
    auditorGroup.add(glassL);
    const glassR = new THREE.Mesh(glassFrameGeo, glassMat);
    glassR.position.set(1, 22.5, 2.1);
    auditorGroup.add(glassR);
    // Bridge
    const bridgeGeo = new THREE.BoxGeometry(0.8, 0.1, 0.1);
    const bridge = new THREE.Mesh(bridgeGeo, glassMat);
    bridge.position.set(0, 22.5, 2.1);
    auditorGroup.add(bridge);

    // SHARP TEETH (menacing grin)
    const mouthWidth = 3;
    const teethCount = 12;
    for (let i = 0; i < teethCount; i++) {
      const toothGeo = new THREE.ConeGeometry(0.15, 0.6, 4);
      const tooth = new THREE.Mesh(toothGeo, teethMaterial);
      const xPos = -mouthWidth/2 + (i / (teethCount-1)) * mouthWidth;
      // Upper teeth
      tooth.position.set(xPos, 20.3, 2);
      tooth.rotation.x = Math.PI;
      auditorGroup.add(tooth);

      // Lower teeth (pointing up)
      const lowerTooth = new THREE.Mesh(toothGeo, teethMaterial);
      lowerTooth.position.set(xPos, 19.7, 2);
      auditorGroup.add(lowerTooth);
    }

    // Larger fangs on sides
    const fangGeo = new THREE.ConeGeometry(0.25, 1, 4);
    const fangL = new THREE.Mesh(fangGeo, teethMaterial);
    fangL.position.set(-1.3, 20.2, 2);
    fangL.rotation.x = Math.PI;
    auditorGroup.add(fangL);
    const fangR = new THREE.Mesh(fangGeo, teethMaterial);
    fangR.position.set(1.3, 20.2, 2);
    fangR.rotation.x = Math.PI;
    auditorGroup.add(fangR);

    // Arms holding clipboard
    const armGeoAud = new THREE.CylinderGeometry(0.6, 0.8, 8, 6);
    const leftArmAud = new THREE.Mesh(armGeoAud, suitMaterial);
    leftArmAud.position.set(-4.5, 12, 1);
    leftArmAud.rotation.z = 0.3;
    leftArmAud.rotation.x = -0.5;
    auditorGroup.add(leftArmAud);

    const rightArmAud = new THREE.Mesh(armGeoAud, suitMaterial);
    rightArmAud.position.set(4.5, 12, 1);
    rightArmAud.rotation.z = -0.3;
    rightArmAud.rotation.x = -0.5;
    auditorGroup.add(rightArmAud);

    // Clipboard
    const clipboardGeo = new THREE.BoxGeometry(3, 4, 0.2);
    const clipboardMat = new THREE.MeshStandardMaterial({
      color: 0x8b4513,
      emissive: 0x442200,
      emissiveIntensity: 0.2
    });
    const clipboard = new THREE.Mesh(clipboardGeo, clipboardMat);
    clipboard.position.set(0, 8, 4);
    clipboard.rotation.x = -0.3;
    auditorGroup.add(clipboard);

    // Paper on clipboard (glowing with "AUDIT")
    const paperGeo = new THREE.BoxGeometry(2.5, 3.5, 0.05);
    const paperMat = new THREE.MeshStandardMaterial({
      color: 0xffffff,
      emissive: 0xff0000,
      emissiveIntensity: 0.3
    });
    const paper = new THREE.Mesh(paperGeo, paperMat);
    paper.position.set(0, 8.2, 4.15);
    paper.rotation.x = -0.3;
    auditorGroup.add(paper);

    // Legs
    const legGeoAud = new THREE.CylinderGeometry(1, 1.2, 8, 6);
    const leftLegAud = new THREE.Mesh(legGeoAud, suitMaterial);
    leftLegAud.position.set(-1.5, 2, 0);
    auditorGroup.add(leftLegAud);
    const rightLegAud = new THREE.Mesh(legGeoAud, suitMaterial);
    rightLegAud.position.set(1.5, 2, 0);
    auditorGroup.add(rightLegAud);

    // Shoes (shiny)
    const shoeGeo = new THREE.BoxGeometry(1.8, 1, 3);
    const shoeMat = new THREE.MeshStandardMaterial({
      color: 0x111111,
      metalness: 0.9,
      roughness: 0.1
    });
    const leftShoe = new THREE.Mesh(shoeGeo, shoeMat);
    leftShoe.position.set(-1.5, -2, 0.5);
    auditorGroup.add(leftShoe);
    const rightShoe = new THREE.Mesh(shoeGeo, shoeMat);
    rightShoe.position.set(1.5, -2, 0.5);
    auditorGroup.add(rightShoe);

    // Briefcase beside him
    const briefcaseGeo = new THREE.BoxGeometry(4, 3, 1.5);
    const briefcaseMat = new THREE.MeshStandardMaterial({
      color: 0x2a2a2a,
      emissive: 0xff0000,
      emissiveIntensity: 0.1,
      metalness: 0.7,
      roughness: 0.3
    });
    const briefcase = new THREE.Mesh(briefcaseGeo, briefcaseMat);
    briefcase.position.set(6, -1, 0);
    auditorGroup.add(briefcase);

    // Briefcase "IRS" label (glowing)
    const labelGeo = new THREE.BoxGeometry(2, 1, 0.1);
    const labelMat = new THREE.MeshStandardMaterial({
      color: 0xff0000,
      emissive: 0xff0000,
      emissiveIntensity: 1
    });
    const label = new THREE.Mesh(labelGeo, labelMat);
    label.position.set(6, -0.5, 0.8);
    auditorGroup.add(label);

    scene.add(auditorGroup);

    // Auditor light (ominous red glow)
    const auditorLight = new THREE.PointLight(0xff0033, 100, 50);
    auditorLight.position.set(40, 15, 30);
    scene.add(auditorLight);

    // TAX DEMAND CHAT BUBBLES
    const taxDemands = [
      "YOU OWE $47,832.69",
      "PAY $156,420.00 NOW",
      "AUDIT IN PROGRESS...",
      "$892,103.45 DUE",
      "PENALTY: $33,333.33",
      "INTEREST: 24.99%",
      "BACK TAXES: $69,420",
      "FILE BY YESTERDAY",
      "WHERE'S YOUR 1099?",
      "$1,000,000.00 OWED",
      "WAGE GARNISHMENT",
      "LIEN ON ASSETS",
      "PRISON TIME: 5YRS",
      "$420,690.00 FINE",
      "RECEIPTS. NOW.",
    ];

    const chatBubbles = [];
    let bubbleTimer = 0;
    const bubbleInterval = 3; // New bubble every 3 seconds

    function createTaxBubble() {
      const bubbleGroup = new THREE.Group();

      // Random tax demand
      const demand = taxDemands[Math.floor(Math.random() * taxDemands.length)];

      // Bubble background
      const bubbleWidth = 2 + demand.length * 0.15;
      const bubbleGeo = new THREE.PlaneGeometry(bubbleWidth, 1.5);
      const bubbleMat = new THREE.MeshStandardMaterial({
        color: 0x000000,
        emissive: 0xff0000,
        emissiveIntensity: 0.3,
        transparent: true,
        opacity: 0.9,
        side: THREE.DoubleSide
      });
      const bubble = new THREE.Mesh(bubbleGeo, bubbleMat);
      bubbleGroup.add(bubble);

      // Border glow
      const borderGeo = new THREE.PlaneGeometry(bubbleWidth + 0.2, 1.7);
      const borderMat = new THREE.MeshStandardMaterial({
        color: 0xff0000,
        emissive: 0xff0000,
        emissiveIntensity: 1,
        transparent: true,
        opacity: 0.8,
        side: THREE.DoubleSide
      });
      const border = new THREE.Mesh(borderGeo, borderMat);
      border.position.z = -0.05;
      bubbleGroup.add(border);

      // Speech tail pointing to auditor
      const tailGeo = new THREE.ConeGeometry(0.3, 0.8, 3);
      const tail = new THREE.Mesh(tailGeo, bubbleMat.clone());
      tail.position.set(-bubbleWidth/2 + 0.5, -1, 0);
      tail.rotation.z = Math.PI;
      bubbleGroup.add(tail);

      // Create text using simple box letters (no font loading needed)
      // Display amount with glowing boxes representing characters
      const charWidth = 0.25;
      const startX = -demand.length * charWidth / 2;

      for (let i = 0; i < demand.length; i++) {
        if (demand[i] !== ' ') {
          const charGeo = new THREE.BoxGeometry(0.2, 0.4, 0.05);
          const charMat = new THREE.MeshStandardMaterial({
            color: 0xff0000,
            emissive: 0xff0000,
            emissiveIntensity: 1.5
          });
          const char = new THREE.Mesh(charGeo, charMat);
          char.position.set(startX + i * charWidth, 0, 0.1);

          // Make $ and numbers slightly different sizes for visual variety
          if (demand[i] === '$') {
            char.scale.set(1.2, 1.3, 1);
          } else if (!isNaN(demand[i])) {
            char.scale.set(0.9, 1.1, 1);
          } else {
            char.scale.set(0.8, 1, 1);
          }
          bubbleGroup.add(char);
        }
      }

      // Position above auditor's head
      bubbleGroup.position.set(
        40 + (Math.random() - 0.5) * 5,
        28 + Math.random() * 3,
        30 + (Math.random() - 0.5) * 3
      );

      // Make it face the camera (billboard effect handled in animation)
      bubbleGroup.userData = {
        life: 0,
        maxLife: 180, // 3 seconds at 60fps
        velocity: new THREE.Vector3(
          (Math.random() - 0.5) * 0.02,
          0.03,
          (Math.random() - 0.5) * 0.02
        ),
        demand: demand
      };

      return bubbleGroup;
    }

    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // NEON PURPLE ICE SCORPION (patrols factory floor)
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    const scorpionGroup = new THREE.Group();
    scorpionGroup.position.set(0, 0, -25);

    const neonPurple = new THREE.MeshStandardMaterial({
      color: 0x9900ff,
      emissive: 0x6600aa,
      emissiveIntensity: 0.7,
      metalness: 0.6,
      roughness: 0.3
    });

    const darkPurple = new THREE.MeshStandardMaterial({
      color: 0x440066,
      emissive: 0x220033,
      emissiveIntensity: 0.4,
      metalness: 0.7,
      roughness: 0.4
    });

    const stingerGlow = new THREE.MeshStandardMaterial({
      color: 0x00ff00,
      emissive: 0x00ff00,
      emissiveIntensity: 2,
      metalness: 0.5,
      roughness: 0.2
    });

    // Scorpion body (main segment)
    const bodyGeo = new THREE.SphereGeometry(3, 12, 12);
    const scorpionBody = new THREE.Mesh(bodyGeo, neonPurple);
    scorpionBody.position.set(0, 2, 0);
    scorpionBody.scale.set(1.5, 0.6, 1);
    scorpionGroup.add(scorpionBody);

    // Thorax
    const thoraxGeo = new THREE.SphereGeometry(2, 10, 10);
    const thorax = new THREE.Mesh(thoraxGeo, neonPurple);
    thorax.position.set(-4, 2, 0);
    thorax.scale.set(1.2, 0.5, 0.8);
    scorpionGroup.add(thorax);

    // Head
    const headGeoScorp = new THREE.SphereGeometry(1.5, 10, 10);
    const scorpHead = new THREE.Mesh(headGeoScorp, neonPurple);
    scorpHead.position.set(-6, 2, 0);
    scorpHead.scale.set(1.2, 0.6, 0.9);
    scorpionGroup.add(scorpHead);

    // Eyes (8 small glowing eyes)
    for (let i = 0; i < 8; i++) {
      const eyeGeoScorp = new THREE.SphereGeometry(0.15, 6, 6);
      const eyeMatScorp = new THREE.MeshStandardMaterial({
        color: 0xff0000,
        emissive: 0xff0000,
        emissiveIntensity: 2
      });
      const scorpEye = new THREE.Mesh(eyeGeoScorp, eyeMatScorp);
      const angle = (i / 8) * Math.PI - Math.PI / 2;
      scorpEye.position.set(
        -7 + Math.cos(angle) * 0.5,
        2.3,
        Math.sin(angle) * 0.8
      );
      scorpionGroup.add(scorpEye);
    }

    // Pincers (claws)
    const clawArmGeo = new THREE.CylinderGeometry(0.3, 0.4, 3, 6);
    const clawGeo = new THREE.SphereGeometry(0.8, 8, 8);

    // Left pincer
    const leftArm = new THREE.Mesh(clawArmGeo, neonPurple);
    leftArm.position.set(-6.5, 2, 2);
    leftArm.rotation.z = Math.PI / 4;
    leftArm.rotation.y = -0.5;
    scorpionGroup.add(leftArm);

    const leftClaw = new THREE.Mesh(clawGeo, neonPurple);
    leftClaw.position.set(-7.5, 2.5, 3.5);
    leftClaw.scale.set(1.5, 0.5, 1);
    scorpionGroup.add(leftClaw);

    // Left pincer finger
    const fingerGeo = new THREE.ConeGeometry(0.3, 1.5, 6);
    const leftFinger1 = new THREE.Mesh(fingerGeo, darkPurple);
    leftFinger1.position.set(-8.2, 2.5, 4);
    leftFinger1.rotation.z = Math.PI / 2;
    leftFinger1.rotation.y = 0.3;
    scorpionGroup.add(leftFinger1);
    const leftFinger2 = new THREE.Mesh(fingerGeo, darkPurple);
    leftFinger2.position.set(-8.2, 2.5, 3);
    leftFinger2.rotation.z = Math.PI / 2;
    leftFinger2.rotation.y = -0.3;
    scorpionGroup.add(leftFinger2);

    // Right pincer
    const rightArm = new THREE.Mesh(clawArmGeo, neonPurple);
    rightArm.position.set(-6.5, 2, -2);
    rightArm.rotation.z = Math.PI / 4;
    rightArm.rotation.y = 0.5;
    scorpionGroup.add(rightArm);

    const rightClaw = new THREE.Mesh(clawGeo, neonPurple);
    rightClaw.position.set(-7.5, 2.5, -3.5);
    rightClaw.scale.set(1.5, 0.5, 1);
    scorpionGroup.add(rightClaw);

    const rightFinger1 = new THREE.Mesh(fingerGeo, darkPurple);
    rightFinger1.position.set(-8.2, 2.5, -4);
    rightFinger1.rotation.z = Math.PI / 2;
    rightFinger1.rotation.y = -0.3;
    scorpionGroup.add(rightFinger1);
    const rightFinger2 = new THREE.Mesh(fingerGeo, darkPurple);
    rightFinger2.position.set(-8.2, 2.5, -3);
    rightFinger2.rotation.z = Math.PI / 2;
    rightFinger2.rotation.y = 0.3;
    scorpionGroup.add(rightFinger2);

    // Legs (8 legs, 4 per side)
    const legGeoScorp = new THREE.CylinderGeometry(0.15, 0.2, 2, 6);
    for (let side = -1; side <= 1; side += 2) {
      for (let i = 0; i < 4; i++) {
        // Upper leg
        const upperLeg = new THREE.Mesh(legGeoScorp, darkPurple);
        upperLeg.position.set(-2 + i * 1.5, 1, side * 2);
        upperLeg.rotation.z = side * 0.5;
        scorpionGroup.add(upperLeg);

        // Lower leg
        const lowerLeg = new THREE.Mesh(legGeoScorp, darkPurple);
        lowerLeg.position.set(-2 + i * 1.5, 0, side * 3);
        lowerLeg.rotation.z = side * 0.8;
        scorpionGroup.add(lowerLeg);
      }
    }

    // TAIL (segmented, curving up)
    const tailSegments = 6;
    for (let i = 0; i < tailSegments; i++) {
      const segSize = 1.2 - i * 0.1;
      const tailSegGeo = new THREE.SphereGeometry(segSize, 8, 8);
      const tailSeg = new THREE.Mesh(tailSegGeo, neonPurple);

      // Curve upward
      const t = i / tailSegments;
      tailSeg.position.set(
        3 + i * 1.5,
        2 + Math.pow(t, 1.5) * 8,
        0
      );
      tailSeg.scale.set(0.8, 1, 0.8);
      scorpionGroup.add(tailSeg);
    }

    // STINGER (glowing green, deadly)
    const stingerBaseGeo = new THREE.SphereGeometry(0.8, 8, 8);
    const stingerBase = new THREE.Mesh(stingerBaseGeo, neonPurple);
    stingerBase.position.set(11, 12, 0);
    scorpionGroup.add(stingerBase);

    const stingerGeo = new THREE.ConeGeometry(0.4, 2.5, 8);
    const stinger = new THREE.Mesh(stingerGeo, stingerGlow);
    stinger.position.set(11.5, 11, 0);
    stinger.rotation.z = -Math.PI / 3;
    scorpionGroup.add(stinger);

    // Stinger drip (venom)
    const venomGeo = new THREE.SphereGeometry(0.2, 6, 6);
    const venomMat = new THREE.MeshStandardMaterial({
      color: 0x00ff00,
      emissive: 0x00ff00,
      emissiveIntensity: 3,
      transparent: true,
      opacity: 0.8
    });
    const venom = new THREE.Mesh(venomGeo, venomMat);
    venom.position.set(12.5, 9.5, 0);
    scorpionGroup.add(venom);

    // ICE BADGE on body
    const badgeGeo = new THREE.BoxGeometry(2, 1.2, 0.2);
    const badgeMat = new THREE.MeshStandardMaterial({
      color: 0x0066ff,
      emissive: 0x0044aa,
      emissiveIntensity: 0.8,
      metalness: 0.9,
      roughness: 0.2
    });
    const badge = new THREE.Mesh(badgeGeo, badgeMat);
    badge.position.set(-1, 2.8, 0);
    badge.rotation.x = -0.3;
    scorpionGroup.add(badge);

    // Badge text "ICE" (using small boxes)
    const iceLetters = [
      { x: -0.6, char: 'I', width: 0.15 },
      { x: 0, char: 'C', width: 0.3 },
      { x: 0.6, char: 'E', width: 0.3 }
    ];
    iceLetters.forEach(letter => {
      const letterGeo = new THREE.BoxGeometry(letter.width, 0.5, 0.1);
      const letterMat = new THREE.MeshStandardMaterial({
        color: 0xffffff,
        emissive: 0xffffff,
        emissiveIntensity: 1
      });
      const letterMesh = new THREE.Mesh(letterGeo, letterMat);
      letterMesh.position.set(-1 + letter.x, 2.85, 0.15);
      letterMesh.rotation.x = -0.3;
      scorpionGroup.add(letterMesh);
    });

    // Badge star
    const starGeo = new THREE.ConeGeometry(0.2, 0.3, 5);
    const starMat = new THREE.MeshStandardMaterial({
      color: 0xffd700,
      emissive: 0xffaa00,
      emissiveIntensity: 1
    });
    const star = new THREE.Mesh(starGeo, starMat);
    star.position.set(-1, 3.3, 0.1);
    star.rotation.x = -Math.PI / 2 - 0.3;
    scorpionGroup.add(star);

    scene.add(scorpionGroup);

    // Scorpion light
    const scorpionLight = new THREE.PointLight(0x9900ff, 80, 40);
    scorpionLight.position.set(0, 5, -25);
    scene.add(scorpionLight);

    // Stinger light (green glow)
    const stingerLight = new THREE.PointLight(0x00ff00, 50, 20);
    stingerLight.position.set(12, 10, -25);
    scene.add(stingerLight);

    // Patrol state
    let patrolAngle = 0;
    const patrolRadius = 30;
    const patrolSpeed = 0.3;

    // Cigarette storage

    // Create cigarette geometry (reusable)
    const stickGeo = new THREE.CylinderGeometry(0.15, 0.15, 3, 8);
    const filterGeo = new THREE.CylinderGeometry(0.16, 0.16, 0.8, 8);
    const tipGeo = new THREE.CylinderGeometry(0.14, 0.14, 0.1, 8);

    function createCigarette(x, y, z) {
      const group = new THREE.Group();

      // White stick
      const stick = new THREE.Mesh(stickGeo, whiteMaterial.clone());
      stick.rotation.z = Math.PI / 2;
      group.add(stick);

      // Orange filter
      const filter = new THREE.Mesh(filterGeo, neonOrange.clone());
      filter.rotation.z = Math.PI / 2;
      filter.position.x = -1.9;
      group.add(filter);

      // Glowing tip
      const tipMat = new THREE.MeshStandardMaterial({
        color: 0xff2200,
        emissive: 0xff4400,
        emissiveIntensity: 1.5
      });
      const tip = new THREE.Mesh(tipGeo, tipMat);
      tip.rotation.z = Math.PI / 2;
      tip.position.x = 1.55;
      group.add(tip);

      group.position.set(x, y, z);
      group.userData = {
        velocity: new THREE.Vector3(0.08 + Math.random() * 0.02, 0, 0),
        onConveyor: true,
        settled: false,
        settleTime: 0
      };

      return group;
    }

    // Collection bin at end of conveyor
    const binGeo = new THREE.BoxGeometry(15, 5, 8);
    const binMat = new THREE.MeshStandardMaterial({
      color: 0x1a1a2e,
      metalness: 0.7,
      roughness: 0.3,
      transparent: true,
      opacity: 0.8
    });
    const bin = new THREE.Mesh(binGeo, binMat);
    bin.position.set(55, 2.5, 0);
    scene.add(bin);

    // Bin neon trim
    const binTrimGeo = new THREE.BoxGeometry(15.2, 0.2, 8.2);
    const binTrim = new THREE.Mesh(binTrimGeo, neonCyan);
    binTrim.position.set(55, 5.1, 0);
    scene.add(binTrim);

    // Spawn timer
    let spawnTimer = 0;
    const spawnInterval = 0.05; // Spawn rate

    // UI elements
    const counterEl = document.getElementById('counter');
    const statusEl = document.getElementById('status');

    // Animation
    const clock = new THREE.Clock();

    function animate() {
      requestAnimationFrame(animate);

      const delta = clock.getDelta();

      // Spawn cigarettes
      if (spawnedCount < MAX_CIGARETTES) {
        spawnTimer += delta;
        if (spawnTimer >= spawnInterval) {
          spawnTimer = 0;
          const cig = createCigarette(
            -8,
            4 + Math.random() * 0.5,
            (Math.random() - 0.5) * 2
          );
          scene.add(cig);
          cigarettes.push(cig);
          spawnedCount++;

          counterEl.textContent = `${spawnedCount} / ${MAX_CIGARETTES}`;

          if (spawnedCount < MAX_CIGARETTES) {
            statusEl.textContent = `Production: ${Math.floor(spawnedCount / MAX_CIGARETTES * 100)}%`;
          } else {
            statusEl.textContent = 'PRODUCTION COMPLETE';
            productionComplete = true;
          }
        }
      }

      // Update cigarettes
      cigarettes.forEach((cig, index) => {
        if (cig.userData.onConveyor) {
          // Move along conveyor
          cig.position.add(cig.userData.velocity);

          // Slight bobbing
          cig.position.y = 1.8 + Math.sin(clock.elapsedTime * 5 + index) * 0.05;

          // Fall into bin at end
          if (cig.position.x > 48) {
            cig.userData.onConveyor = false;
            cig.userData.velocity = new THREE.Vector3(
              (Math.random() - 0.5) * 0.1,
              -0.05,
              (Math.random() - 0.5) * 0.1
            );
          }
        } else if (!cig.userData.settled) {
          // Falling into bin
          cig.position.add(cig.userData.velocity);
          cig.userData.velocity.y -= 0.003; // gravity

          // Settle in bin
          const binBottom = 0.5 + (index * 0.008); // Stack up
          if (cig.position.y < binBottom) {
            cig.position.y = binBottom;
            cig.userData.settled = true;
            // Random rotation when settled
            cig.rotation.y = Math.random() * Math.PI;
            cig.rotation.z = Math.PI / 2 + (Math.random() - 0.5) * 0.3;
          }

          // Keep in bin bounds
          cig.position.x = Math.max(48, Math.min(62, cig.position.x));
          cig.position.z = Math.max(-3.5, Math.min(3.5, cig.position.z));
        }

        // Pulse the glowing tips
        const tip = cig.children[2];
        if (tip && tip.material) {
          tip.material.emissiveIntensity = 1 + Math.sin(clock.elapsedTime * 3 + index) * 0.5;
        }
      });

      // Animate lights
      mainLight.intensity = 100 + Math.sin(clock.elapsedTime * 2) * 20;
      accentLight.intensity = 80 + Math.cos(clock.elapsedTime * 1.5) * 15;

      // Animate Godzilla (menacing sway and breathing)
      godzillaGroup.rotation.y = Math.sin(clock.elapsedTime * 0.3) * 0.03;
      // Breathing effect on torso
      const breathScale = 1 + Math.sin(clock.elapsedTime * 1.5) * 0.02;
      godzillaGroup.children[0].scale.set(breathScale, 1, breathScale);
      // Tail sway
      godzillaGroup.children.forEach((child, i) => {
        if (i > 20 && i < 35) { // Tail segments
          child.rotation.y = Math.sin(clock.elapsedTime * 0.8 + i * 0.3) * 0.1;
        }
      });

      // Spawn toxic gas from MOUTH
      mouthGasTimer += delta;
      if (mouthGasTimer >= mouthGasInterval && toxicClouds.length < MAX_CLOUDS) {
        mouthGasTimer = 0;
        const cloud = createToxicCloud('mouth');
        scene.add(cloud);
        toxicClouds.push(cloud);
      }

      // Spawn toxic gas from TAIL
      tailGasTimer += delta;
      if (tailGasTimer >= tailGasInterval && toxicClouds.length < MAX_CLOUDS) {
        tailGasTimer = 0;
        const cloud = createToxicCloud('tail');
        scene.add(cloud);
        toxicClouds.push(cloud);
      }

      // Update toxic gas clouds
      for (let i = toxicClouds.length - 1; i >= 0; i--) {
        const cloud = toxicClouds[i];
        cloud.position.add(cloud.userData.velocity);
        cloud.userData.life++;

        // Expand and fade
        const lifeRatio = cloud.userData.life / cloud.userData.maxLife;
        const scale = 1 + lifeRatio * 2;
        cloud.scale.set(scale, scale, scale);

        // Fade out
        cloud.children.forEach(sphere => {
          if (sphere.material) {
            sphere.material.opacity = 0.6 * (1 - lifeRatio);
          }
        });

        // Pulse glow
        cloud.children.forEach((sphere, j) => {
          if (sphere.material) {
            sphere.material.emissiveIntensity = 0.5 + Math.sin(clock.elapsedTime * 3 + j) * 0.3;
          }
        });

        // Remove dead clouds
        if (cloud.userData.life >= cloud.userData.maxLife) {
          scene.remove(cloud);
          cloud.children.forEach(c => {
            if (c.geometry) c.geometry.dispose();
            if (c.material) c.material.dispose();
          });
          toxicClouds.splice(i, 1);
        }
      }

      // Godzilla lights pulse
      godzillaLight.intensity = 200 + Math.sin(clock.elapsedTime * 1.5) * 50;
      spineLight.intensity = 100 + Math.sin(clock.elapsedTime * 3) * 40;

      // Tax Auditor animation (menacing presence)
      // Slow head turn, watching everything
      auditorGroup.children[4].rotation.y = Math.sin(clock.elapsedTime * 0.3) * 0.3;
      // Eyes pulse menacingly
      const eyePulse = 2 + Math.sin(clock.elapsedTime * 4) * 0.5;
      auditorEyeL.material.emissiveIntensity = eyePulse;
      auditorEyeR.material.emissiveIntensity = eyePulse;
      // Slight body sway
      auditorGroup.rotation.y = Math.sin(clock.elapsedTime * 0.2) * 0.02;
      // Clipboard tap (writing notes)
      clipboard.rotation.z = Math.sin(clock.elapsedTime * 3) * 0.05;
      // Auditor light flickers
      auditorLight.intensity = 100 + Math.sin(clock.elapsedTime * 5) * 30;

      // ICE SCORPION PATROL
      patrolAngle += delta * patrolSpeed;
      scorpionGroup.position.x = Math.cos(patrolAngle) * patrolRadius;
      scorpionGroup.position.z = Math.sin(patrolAngle) * patrolRadius - 10;

      // Face direction of movement
      scorpionGroup.rotation.y = -patrolAngle + Math.PI / 2;

      // Leg movement (scuttling)
      scorpionGroup.children.forEach((child, i) => {
        if (i >= 19 && i < 35) { // Leg indices
          child.rotation.x = Math.sin(clock.elapsedTime * 8 + i * 0.5) * 0.3;
        }
      });

      // Tail sway
      scorpionGroup.children.forEach((child, i) => {
        if (i >= 35 && i < 41) { // Tail segment indices
          child.position.z = Math.sin(clock.elapsedTime * 2 + i * 0.3) * 0.3;
        }
      });

      // Stinger pulse
      stinger.material.emissiveIntensity = 2 + Math.sin(clock.elapsedTime * 4) * 1;
      venom.material.opacity = 0.5 + Math.sin(clock.elapsedTime * 3) * 0.3;
      venom.position.y = 9.5 + Math.sin(clock.elapsedTime * 2) * 0.3;

      // Pincer snap periodically
      const snapPhase = (clock.elapsedTime % 3) / 3;
      if (snapPhase < 0.1) {
        const snap = snapPhase / 0.1;
        leftFinger1.rotation.y = 0.3 - snap * 0.5;
        leftFinger2.rotation.y = -0.3 + snap * 0.5;
        rightFinger1.rotation.y = -0.3 + snap * 0.5;
        rightFinger2.rotation.y = 0.3 - snap * 0.5;
      } else {
        leftFinger1.rotation.y = 0.3;
        leftFinger2.rotation.y = -0.3;
        rightFinger1.rotation.y = -0.3;
        rightFinger2.rotation.y = 0.3;
      }

      // Update scorpion lights position
      scorpionLight.position.x = scorpionGroup.position.x;
      scorpionLight.position.z = scorpionGroup.position.z;
      stingerLight.position.x = scorpionGroup.position.x + 10;
      stingerLight.position.z = scorpionGroup.position.z;

      // Scorpion light pulse
      scorpionLight.intensity = 80 + Math.sin(clock.elapsedTime * 2) * 20;
      stingerLight.intensity = 50 + Math.sin(clock.elapsedTime * 4) * 25;

      // TAX DEMAND BUBBLES
      bubbleTimer += delta;
      if (bubbleTimer >= bubbleInterval && chatBubbles.length < 5) {
        bubbleTimer = 0;
        const bubble = createTaxBubble();
        scene.add(bubble);
        chatBubbles.push(bubble);
      }

      // Update chat bubbles
      for (let i = chatBubbles.length - 1; i >= 0; i--) {
        const bubble = chatBubbles[i];
        bubble.userData.life++;

        // Float upward
        bubble.position.add(bubble.userData.velocity);

        // Billboard effect - face camera
        bubble.lookAt(camera.position);

        // Fade and scale based on life
        const lifeRatio = bubble.userData.life / bubble.userData.maxLife;

        // Pop in at start
        if (lifeRatio < 0.1) {
          const popScale = lifeRatio / 0.1;
          bubble.scale.setScalar(popScale);
        }
        // Fade out at end
        else if (lifeRatio > 0.7) {
          const fadeRatio = (lifeRatio - 0.7) / 0.3;
          bubble.children.forEach(child => {
            if (child.material && child.material.opacity !== undefined) {
              child.material.opacity = (1 - fadeRatio) * 0.9;
            }
          });
        }

        // Wobble for emphasis
        bubble.rotation.z = Math.sin(clock.elapsedTime * 5 + i) * 0.05;

        // Remove dead bubbles
        if (bubble.userData.life >= bubble.userData.maxLife) {
          scene.remove(bubble);
          bubble.children.forEach(c => {
            if (c.geometry) c.geometry.dispose();
            if (c.material) c.material.dispose();
          });
          chatBubbles.splice(i, 1);
        }
      }

      // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
      // SPRINGLOCK SUIT ANIMATION
      // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

      // Springlock triggers periodically when Godzilla "gets close"
      // Simulated by time-based cycle (every 8 seconds it snaps)
      const snapCycle = Math.floor(clock.elapsedTime / 8);
      const cyclePhase = (clock.elapsedTime % 8);

      // Trigger snap at start of each cycle (if not already snapping)
      if (cyclePhase < 0.1 && springlockOpen && !springlockTriggered && snapCycle > 0) {
        springlockTriggered = true;
        springlockOpen = false;
      }

      // Animate the springlock based on state
      if (springlockOpen) {
        // Open state - parts spread apart, inviting
        const openAmount = 0.5 + Math.sin(clock.elapsedTime * 2) * 0.1;

        // Torso halves spread
        torsoFront.position.z = 2 * openAmount;
        torsoBack.position.z = -2 * openAmount;

        // Head halves spread
        headFront.position.z = 1.5 * openAmount;
        headBack.position.z = -1.5 * openAmount;

        // Arms spread wide
        leftArmUpper.rotation.z = 0.5 + openAmount * 0.5;
        rightArmUpper.rotation.z = -0.5 - openAmount * 0.5;

        // Gentle idle sway
        springlockGroup.rotation.y = Math.sin(clock.elapsedTime * 0.5) * 0.05;

        // Eyes dim
        eyeLeft.material.emissiveIntensity = 0.1;
        eyeRight.material.emissiveIntensity = 0.1;

      } else if (springlockTriggered) {
        // SNAP SHUT!
        snapProgress = Math.min(1, snapProgress + delta * 3); // Fast snap

        const easeOut = 1 - Math.pow(1 - snapProgress, 3);
        const snapAmount = 1 - easeOut;

        // Torso SLAMS shut
        torsoFront.position.z = 1 * snapAmount;
        torsoBack.position.z = -1 * snapAmount;

        // Head SLAMS shut
        headFront.position.z = 0.75 * snapAmount;
        headBack.position.z = -0.75 * snapAmount;

        // Arms snap inward (grabbing motion)
        leftArmUpper.rotation.z = 0.5 * snapAmount - 0.3 * easeOut;
        rightArmUpper.rotation.z = -0.5 * snapAmount + 0.3 * easeOut;
        leftArmLower.rotation.z = 0.3 * snapAmount + 0.5 * easeOut;
        rightArmLower.rotation.z = -0.3 * snapAmount - 0.5 * easeOut;

        // Eyes GLOW RED menacingly
        const eyeGlow = 2 + Math.sin(clock.elapsedTime * 10) * 1;
        eyeLeft.material.emissiveIntensity = eyeGlow * easeOut;
        eyeRight.material.emissiveIntensity = eyeGlow * easeOut;

        // Warning flash on light
        warningFlash += delta * 15;
        springlockLight.color.setHex(
          Math.sin(warningFlash) > 0 ? 0xff0000 : 0xffd700
        );
        springlockLight.intensity = 150 + Math.sin(warningFlash * 2) * 50;

        // Shake when snapping
        if (snapProgress < 0.5) {
          springlockGroup.position.x = 25 + (Math.random() - 0.5) * 0.5;
          springlockGroup.position.z = -15 + (Math.random() - 0.5) * 0.5;
        }

        // Reset after fully snapped and some time passes
        if (snapProgress >= 1) {
          // Stay closed for a moment, then slowly reopen
          setTimeout(() => {
            springlockTriggered = false;
            springlockOpen = true;
            snapProgress = 0;
            springlockLight.color.setHex(0xffd700);
            springlockGroup.position.set(25, 0, -15);
          }, 3000);
        }
      }

      controls.update();
      composer.render();
    }

    // Handle resize
    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
      composer.setSize(window.innerWidth, window.innerHeight);
    });

    // Start
    statusEl.textContent = 'Production starting...';
    animate();
  </script>
</body>
</html>
