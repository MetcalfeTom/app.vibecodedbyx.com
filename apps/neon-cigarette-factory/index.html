<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Neon Cigarette Factory</title>
  <meta name="description" content="3D neon factory spawning 500 glowing sticks">
  <meta property="og:title" content="Neon Cigarette Factory">
  <meta property="og:description" content="Watch 500 glowing sticks roll off the neon assembly line">
  <meta property="og:url" content="https://sloppy.live/neon-cigarette-factory/">
  <meta property="og:image" content="https://emojicdn.elk.sh/üö¨">
  <link rel="icon" href="https://emojicdn.elk.sh/üè≠">
  <style>
    @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700&display=swap');

    * { margin: 0; padding: 0; box-sizing: border-box; }

    body {
      background: #0a0a0f;
      overflow: hidden;
      font-family: 'Orbitron', monospace;
    }

    #canvas-container {
      width: 100vw;
      height: 100vh;
      position: fixed;
      top: 0;
      left: 0;
    }

    #ui {
      position: fixed;
      top: 20px;
      left: 20px;
      z-index: 100;
      color: #0ff;
      text-shadow: 0 0 10px #0ff, 0 0 20px #0ff;
    }

    h1 {
      font-size: 1.5rem;
      margin-bottom: 10px;
      color: #f0f;
      text-shadow: 0 0 10px #f0f, 0 0 20px #f0f;
    }

    #counter {
      font-size: 2rem;
      color: #0f0;
      text-shadow: 0 0 10px #0f0, 0 0 30px #0f0;
    }

    #status {
      margin-top: 10px;
      font-size: 0.8rem;
      opacity: 0.8;
    }

    #backlink {
      position: fixed;
      bottom: 20px;
      left: 20px;
      z-index: 100;
    }

    #backlink a {
      color: #f0f;
      text-decoration: none;
      font-size: 0.8rem;
      opacity: 0.7;
      transition: opacity 0.3s;
    }

    #backlink a:hover {
      opacity: 1;
      text-shadow: 0 0 10px #f0f;
    }

    #controls {
      position: fixed;
      bottom: 20px;
      right: 20px;
      z-index: 100;
      color: #666;
      font-size: 0.7rem;
      text-align: right;
    }
  </style>
</head>
<body>
  <div id="canvas-container"></div>

  <div id="ui">
    <h1>NEON CIGARETTE FACTORY</h1>
    <div id="counter">0 / 500</div>
    <div id="status">Initializing production line...</div>
  </div>

  <div id="backlink">
    <a href="https://sloppy.live">‚Üê sloppy.live</a>
  </div>

  <div id="controls">
    Drag to rotate ‚Ä¢ Scroll to zoom
  </div>

  <script type="importmap">
  {
    "imports": {
      "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
      "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
    }
  }
  </script>

  <script type="module">
    import * as THREE from 'three';
    import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
    import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
    import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
    import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';

    // Scene setup
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x050508);
    scene.fog = new THREE.FogExp2(0x050508, 0.015);

    const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.set(30, 25, 40);

    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    renderer.toneMapping = THREE.ReinhardToneMapping;
    renderer.toneMappingExposure = 1.5;
    document.getElementById('canvas-container').appendChild(renderer.domElement);

    // Controls
    const controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;
    controls.dampingFactor = 0.05;
    controls.maxPolarAngle = Math.PI / 2.1;

    // Post-processing bloom
    const composer = new EffectComposer(renderer);
    composer.addPass(new RenderPass(scene, camera));
    const bloomPass = new UnrealBloomPass(
      new THREE.Vector2(window.innerWidth, window.innerHeight),
      1.5, 0.4, 0.85
    );
    bloomPass.threshold = 0.1;
    bloomPass.strength = 2;
    bloomPass.radius = 0.5;
    composer.addPass(bloomPass);

    // Neon materials
    const neonCyan = new THREE.MeshStandardMaterial({
      color: 0x00ffff,
      emissive: 0x00ffff,
      emissiveIntensity: 0.5,
      metalness: 0.8,
      roughness: 0.2
    });

    const neonMagenta = new THREE.MeshStandardMaterial({
      color: 0xff00ff,
      emissive: 0xff00ff,
      emissiveIntensity: 0.5,
      metalness: 0.8,
      roughness: 0.2
    });

    const neonOrange = new THREE.MeshStandardMaterial({
      color: 0xff6600,
      emissive: 0xff4400,
      emissiveIntensity: 0.8,
      metalness: 0.3,
      roughness: 0.4
    });

    const whiteMaterial = new THREE.MeshStandardMaterial({
      color: 0xeeeeee,
      emissive: 0x333333,
      emissiveIntensity: 0.2,
      metalness: 0.1,
      roughness: 0.6
    });

    const darkMetal = new THREE.MeshStandardMaterial({
      color: 0x222233,
      metalness: 0.9,
      roughness: 0.3
    });

    // Factory floor
    const floorGeo = new THREE.PlaneGeometry(200, 200);
    const floorMat = new THREE.MeshStandardMaterial({
      color: 0x111118,
      metalness: 0.8,
      roughness: 0.4
    });
    const floor = new THREE.Mesh(floorGeo, floorMat);
    floor.rotation.x = -Math.PI / 2;
    floor.position.y = -0.1;
    scene.add(floor);

    // Grid lines on floor
    const gridHelper = new THREE.GridHelper(200, 50, 0x00ffff, 0x111133);
    gridHelper.position.y = 0;
    scene.add(gridHelper);

    // Factory machine base
    const machineBaseGeo = new THREE.BoxGeometry(20, 4, 10);
    const machineBase = new THREE.Mesh(machineBaseGeo, darkMetal);
    machineBase.position.set(0, 2, 0);
    scene.add(machineBase);

    // Machine top
    const machineTopGeo = new THREE.BoxGeometry(18, 6, 8);
    const machineTop = new THREE.Mesh(machineTopGeo, darkMetal);
    machineTop.position.set(0, 7, 0);
    scene.add(machineTop);

    // Neon trim on machine
    const trimGeo = new THREE.BoxGeometry(20.2, 0.3, 10.2);
    const trim1 = new THREE.Mesh(trimGeo, neonCyan);
    trim1.position.set(0, 4.1, 0);
    scene.add(trim1);

    const trim2 = new THREE.Mesh(trimGeo.clone(), neonMagenta);
    trim2.position.set(0, 0.1, 0);
    scene.add(trim2);

    // Conveyor belt
    const conveyorGeo = new THREE.BoxGeometry(60, 0.5, 4);
    const conveyorMat = new THREE.MeshStandardMaterial({
      color: 0x1a1a2e,
      metalness: 0.6,
      roughness: 0.5
    });
    const conveyor = new THREE.Mesh(conveyorGeo, conveyorMat);
    conveyor.position.set(20, 1, 0);
    scene.add(conveyor);

    // Conveyor side rails
    const railGeo = new THREE.BoxGeometry(60, 1, 0.2);
    const rail1 = new THREE.Mesh(railGeo, neonCyan);
    rail1.position.set(20, 1.5, 2);
    scene.add(rail1);
    const rail2 = new THREE.Mesh(railGeo, neonCyan);
    rail2.position.set(20, 1.5, -2);
    scene.add(rail2);

    // Smoke stacks
    for (let i = 0; i < 3; i++) {
      const stackGeo = new THREE.CylinderGeometry(1, 1.5, 12, 8);
      const stack = new THREE.Mesh(stackGeo, darkMetal);
      stack.position.set(-5 + i * 5, 16, -3);
      scene.add(stack);

      // Neon ring on stack
      const ringGeo = new THREE.TorusGeometry(1.2, 0.15, 8, 16);
      const ring = new THREE.Mesh(ringGeo, neonMagenta);
      ring.rotation.x = Math.PI / 2;
      ring.position.set(-5 + i * 5, 22, -3);
      scene.add(ring);
    }

    // Lights
    const ambientLight = new THREE.AmbientLight(0x111122, 0.5);
    scene.add(ambientLight);

    const mainLight = new THREE.PointLight(0x00ffff, 100, 100);
    mainLight.position.set(0, 20, 10);
    scene.add(mainLight);

    const accentLight = new THREE.PointLight(0xff00ff, 80, 80);
    accentLight.position.set(-10, 15, -10);
    scene.add(accentLight);

    const factoryLight = new THREE.SpotLight(0xffaa00, 100, 50, Math.PI / 4);
    factoryLight.position.set(0, 25, 0);
    factoryLight.target.position.set(10, 0, 0);
    scene.add(factoryLight);
    scene.add(factoryLight.target);

    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // MASSIVE NEON GIRAFFE
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    const giraffeGroup = new THREE.Group();
    giraffeGroup.position.set(-35, 0, 15);

    const neonYellow = new THREE.MeshStandardMaterial({
      color: 0xffff00,
      emissive: 0xffaa00,
      emissiveIntensity: 0.6,
      metalness: 0.5,
      roughness: 0.3
    });

    const neonGreen = new THREE.MeshStandardMaterial({
      color: 0x00ff00,
      emissive: 0x00ff00,
      emissiveIntensity: 0.8,
      metalness: 0.6,
      roughness: 0.2
    });

    const spotMaterial = new THREE.MeshStandardMaterial({
      color: 0xff6600,
      emissive: 0xff4400,
      emissiveIntensity: 0.5,
      metalness: 0.4,
      roughness: 0.4
    });

    // Giraffe body
    const bodyGeo = new THREE.CylinderGeometry(4, 3.5, 12, 12);
    const body = new THREE.Mesh(bodyGeo, neonYellow);
    body.rotation.z = Math.PI / 2;
    body.position.set(0, 18, 0);
    giraffeGroup.add(body);

    // Giraffe legs (4)
    const legGeo = new THREE.CylinderGeometry(0.8, 0.6, 18, 8);
    const legPositions = [
      { x: -4, z: 2 },
      { x: -4, z: -2 },
      { x: 4, z: 2 },
      { x: 4, z: -2 }
    ];
    legPositions.forEach(pos => {
      const leg = new THREE.Mesh(legGeo, neonYellow);
      leg.position.set(pos.x, 9, pos.z);
      giraffeGroup.add(leg);

      // Neon hoof
      const hoofGeo = new THREE.CylinderGeometry(0.9, 1, 1, 8);
      const hoof = new THREE.Mesh(hoofGeo, neonMagenta);
      hoof.position.set(pos.x, 0.5, pos.z);
      giraffeGroup.add(hoof);
    });

    // Giraffe neck
    const neckGeo = new THREE.CylinderGeometry(1.5, 2.5, 20, 8);
    const neck = new THREE.Mesh(neckGeo, neonYellow);
    neck.position.set(-8, 30, 0);
    neck.rotation.z = 0.3;
    giraffeGroup.add(neck);

    // Neon rings on neck
    for (let i = 0; i < 5; i++) {
      const ringGeo = new THREE.TorusGeometry(1.8 - i * 0.1, 0.2, 8, 16);
      const ring = new THREE.Mesh(ringGeo, neonGreen);
      ring.position.set(-8 - i * 0.6, 22 + i * 4, 0);
      ring.rotation.y = Math.PI / 2;
      ring.rotation.x = 0.3;
      giraffeGroup.add(ring);
    }

    // Giraffe head
    const headGeo = new THREE.SphereGeometry(3, 12, 12);
    const head = new THREE.Mesh(headGeo, neonYellow);
    head.position.set(-12, 42, 0);
    head.scale.set(1, 1.3, 0.8);
    giraffeGroup.add(head);

    // Snout
    const snoutGeo = new THREE.CylinderGeometry(1, 1.5, 4, 8);
    const snout = new THREE.Mesh(snoutGeo, neonYellow);
    snout.position.set(-15, 41, 0);
    snout.rotation.z = Math.PI / 2;
    giraffeGroup.add(snout);

    // Eyes (glowing cyan)
    const eyeGeo = new THREE.SphereGeometry(0.6, 8, 8);
    const eyeMat = new THREE.MeshStandardMaterial({
      color: 0x00ffff,
      emissive: 0x00ffff,
      emissiveIntensity: 2
    });
    const eye1 = new THREE.Mesh(eyeGeo, eyeMat);
    eye1.position.set(-13, 43, 2);
    giraffeGroup.add(eye1);
    const eye2 = new THREE.Mesh(eyeGeo, eyeMat);
    eye2.position.set(-13, 43, -2);
    giraffeGroup.add(eye2);

    // Horns (ossicones)
    const hornGeo = new THREE.CylinderGeometry(0.3, 0.4, 3, 6);
    const horn1 = new THREE.Mesh(hornGeo, neonMagenta);
    horn1.position.set(-11, 46, 1.5);
    giraffeGroup.add(horn1);
    const horn2 = new THREE.Mesh(hornGeo, neonMagenta);
    horn2.position.set(-11, 46, -1.5);
    giraffeGroup.add(horn2);

    // Spots on body (glowing)
    for (let i = 0; i < 15; i++) {
      const spotGeo = new THREE.SphereGeometry(0.5 + Math.random() * 0.5, 6, 6);
      const spot = new THREE.Mesh(spotGeo, spotMaterial);
      spot.position.set(
        (Math.random() - 0.5) * 10,
        15 + Math.random() * 8,
        (Math.random() - 0.5) * 5
      );
      giraffeGroup.add(spot);
    }

    // Tail
    const tailGeo = new THREE.CylinderGeometry(0.2, 0.4, 6, 6);
    const tail = new THREE.Mesh(tailGeo, neonYellow);
    tail.position.set(8, 16, 0);
    tail.rotation.z = -0.5;
    giraffeGroup.add(tail);

    // Tail tuft
    const tuftGeo = new THREE.SphereGeometry(0.8, 8, 8);
    const tuft = new THREE.Mesh(tuftGeo, neonMagenta);
    tuft.position.set(10, 13, 0);
    giraffeGroup.add(tuft);

    scene.add(giraffeGroup);

    // Giraffe light
    const giraffeLight = new THREE.PointLight(0xffff00, 150, 60);
    giraffeLight.position.set(-35, 30, 15);
    scene.add(giraffeLight);

    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // TOXIC GAS CLOUDS
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    const toxicClouds = [];
    const MAX_CLOUDS = 50;

    function createToxicCloud() {
      const cloudGroup = new THREE.Group();

      // Multiple spheres for cloud effect
      const cloudMat = new THREE.MeshStandardMaterial({
        color: 0x00ff00,
        emissive: 0x00ff00,
        emissiveIntensity: 0.8,
        transparent: true,
        opacity: 0.6,
        metalness: 0.2,
        roughness: 0.8
      });

      for (let i = 0; i < 5; i++) {
        const size = 1 + Math.random() * 2;
        const sphereGeo = new THREE.SphereGeometry(size, 8, 8);
        const sphere = new THREE.Mesh(sphereGeo, cloudMat.clone());
        sphere.position.set(
          (Math.random() - 0.5) * 3,
          (Math.random() - 0.5) * 2,
          (Math.random() - 0.5) * 3
        );
        cloudGroup.add(sphere);
      }

      // Start position (giraffe's rear)
      cloudGroup.position.set(
        -35 + 10 + (Math.random() - 0.5) * 2,
        12 + Math.random() * 3,
        15 + (Math.random() - 0.5) * 3
      );

      cloudGroup.userData = {
        velocity: new THREE.Vector3(
          0.05 + Math.random() * 0.1,
          0.02 + Math.random() * 0.05,
          (Math.random() - 0.5) * 0.1
        ),
        life: 0,
        maxLife: 200 + Math.random() * 100
      };

      return cloudGroup;
    }

    let gasTimer = 0;
    const gasInterval = 0.3; // Emit gas every 0.3 seconds

    // Cigarette storage
    const cigarettes = [];
    const MAX_CIGARETTES = 500;
    let spawnedCount = 0;
    let productionComplete = false;

    // Create cigarette geometry (reusable)
    const stickGeo = new THREE.CylinderGeometry(0.15, 0.15, 3, 8);
    const filterGeo = new THREE.CylinderGeometry(0.16, 0.16, 0.8, 8);
    const tipGeo = new THREE.CylinderGeometry(0.14, 0.14, 0.1, 8);

    function createCigarette(x, y, z) {
      const group = new THREE.Group();

      // White stick
      const stick = new THREE.Mesh(stickGeo, whiteMaterial.clone());
      stick.rotation.z = Math.PI / 2;
      group.add(stick);

      // Orange filter
      const filter = new THREE.Mesh(filterGeo, neonOrange.clone());
      filter.rotation.z = Math.PI / 2;
      filter.position.x = -1.9;
      group.add(filter);

      // Glowing tip
      const tipMat = new THREE.MeshStandardMaterial({
        color: 0xff2200,
        emissive: 0xff4400,
        emissiveIntensity: 1.5
      });
      const tip = new THREE.Mesh(tipGeo, tipMat);
      tip.rotation.z = Math.PI / 2;
      tip.position.x = 1.55;
      group.add(tip);

      group.position.set(x, y, z);
      group.userData = {
        velocity: new THREE.Vector3(0.08 + Math.random() * 0.02, 0, 0),
        onConveyor: true,
        settled: false,
        settleTime: 0
      };

      return group;
    }

    // Collection bin at end of conveyor
    const binGeo = new THREE.BoxGeometry(15, 5, 8);
    const binMat = new THREE.MeshStandardMaterial({
      color: 0x1a1a2e,
      metalness: 0.7,
      roughness: 0.3,
      transparent: true,
      opacity: 0.8
    });
    const bin = new THREE.Mesh(binGeo, binMat);
    bin.position.set(55, 2.5, 0);
    scene.add(bin);

    // Bin neon trim
    const binTrimGeo = new THREE.BoxGeometry(15.2, 0.2, 8.2);
    const binTrim = new THREE.Mesh(binTrimGeo, neonCyan);
    binTrim.position.set(55, 5.1, 0);
    scene.add(binTrim);

    // Spawn timer
    let spawnTimer = 0;
    const spawnInterval = 0.05; // Spawn rate

    // UI elements
    const counterEl = document.getElementById('counter');
    const statusEl = document.getElementById('status');

    // Animation
    const clock = new THREE.Clock();

    function animate() {
      requestAnimationFrame(animate);

      const delta = clock.getDelta();

      // Spawn cigarettes
      if (spawnedCount < MAX_CIGARETTES) {
        spawnTimer += delta;
        if (spawnTimer >= spawnInterval) {
          spawnTimer = 0;
          const cig = createCigarette(
            -8,
            4 + Math.random() * 0.5,
            (Math.random() - 0.5) * 2
          );
          scene.add(cig);
          cigarettes.push(cig);
          spawnedCount++;

          counterEl.textContent = `${spawnedCount} / ${MAX_CIGARETTES}`;

          if (spawnedCount < MAX_CIGARETTES) {
            statusEl.textContent = `Production: ${Math.floor(spawnedCount / MAX_CIGARETTES * 100)}%`;
          } else {
            statusEl.textContent = 'PRODUCTION COMPLETE';
            productionComplete = true;
          }
        }
      }

      // Update cigarettes
      cigarettes.forEach((cig, index) => {
        if (cig.userData.onConveyor) {
          // Move along conveyor
          cig.position.add(cig.userData.velocity);

          // Slight bobbing
          cig.position.y = 1.8 + Math.sin(clock.elapsedTime * 5 + index) * 0.05;

          // Fall into bin at end
          if (cig.position.x > 48) {
            cig.userData.onConveyor = false;
            cig.userData.velocity = new THREE.Vector3(
              (Math.random() - 0.5) * 0.1,
              -0.05,
              (Math.random() - 0.5) * 0.1
            );
          }
        } else if (!cig.userData.settled) {
          // Falling into bin
          cig.position.add(cig.userData.velocity);
          cig.userData.velocity.y -= 0.003; // gravity

          // Settle in bin
          const binBottom = 0.5 + (index * 0.008); // Stack up
          if (cig.position.y < binBottom) {
            cig.position.y = binBottom;
            cig.userData.settled = true;
            // Random rotation when settled
            cig.rotation.y = Math.random() * Math.PI;
            cig.rotation.z = Math.PI / 2 + (Math.random() - 0.5) * 0.3;
          }

          // Keep in bin bounds
          cig.position.x = Math.max(48, Math.min(62, cig.position.x));
          cig.position.z = Math.max(-3.5, Math.min(3.5, cig.position.z));
        }

        // Pulse the glowing tips
        const tip = cig.children[2];
        if (tip && tip.material) {
          tip.material.emissiveIntensity = 1 + Math.sin(clock.elapsedTime * 3 + index) * 0.5;
        }
      });

      // Animate lights
      mainLight.intensity = 100 + Math.sin(clock.elapsedTime * 2) * 20;
      accentLight.intensity = 80 + Math.cos(clock.elapsedTime * 1.5) * 15;

      // Animate giraffe (subtle swaying)
      giraffeGroup.rotation.y = Math.sin(clock.elapsedTime * 0.5) * 0.05;
      giraffeGroup.children.forEach((child, i) => {
        if (child.geometry && child.geometry.type === 'CylinderGeometry' && i > 0 && i < 5) {
          // Leg sway
          child.rotation.x = Math.sin(clock.elapsedTime * 2 + i) * 0.03;
        }
      });

      // Spawn toxic gas clouds
      gasTimer += delta;
      if (gasTimer >= gasInterval && toxicClouds.length < MAX_CLOUDS) {
        gasTimer = 0;
        const cloud = createToxicCloud();
        scene.add(cloud);
        toxicClouds.push(cloud);
      }

      // Update toxic gas clouds
      for (let i = toxicClouds.length - 1; i >= 0; i--) {
        const cloud = toxicClouds[i];
        cloud.position.add(cloud.userData.velocity);
        cloud.userData.life++;

        // Expand and fade
        const lifeRatio = cloud.userData.life / cloud.userData.maxLife;
        const scale = 1 + lifeRatio * 2;
        cloud.scale.set(scale, scale, scale);

        // Fade out
        cloud.children.forEach(sphere => {
          if (sphere.material) {
            sphere.material.opacity = 0.6 * (1 - lifeRatio);
          }
        });

        // Pulse glow
        cloud.children.forEach((sphere, j) => {
          if (sphere.material) {
            sphere.material.emissiveIntensity = 0.5 + Math.sin(clock.elapsedTime * 3 + j) * 0.3;
          }
        });

        // Remove dead clouds
        if (cloud.userData.life >= cloud.userData.maxLife) {
          scene.remove(cloud);
          cloud.children.forEach(c => {
            if (c.geometry) c.geometry.dispose();
            if (c.material) c.material.dispose();
          });
          toxicClouds.splice(i, 1);
        }
      }

      // Giraffe light pulse
      giraffeLight.intensity = 150 + Math.sin(clock.elapsedTime * 1.5) * 30;

      controls.update();
      composer.render();
    }

    // Handle resize
    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
      composer.setSize(window.innerWidth, window.innerHeight);
    });

    // Start
    statusEl.textContent = 'Production starting...';
    animate();
  </script>
</body>
</html>
