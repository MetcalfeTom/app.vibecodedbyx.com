<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>The Singularity</title>
  <link rel="icon" href="https://emojicdn.elk.sh/♾️">
  <meta property="og:title" content="The Singularity">
  <meta property="og:description" content="Complex plane warping under undefined mathematical operations">
  <meta property="og:url" content="https://app.sloppy.live/the-singularity">
  <meta property="og:image" content="https://emojicdn.elk.sh/♾️?style=apple&size=512">
  <link href="https://fonts.googleapis.com/css2?family=Crimson+Pro:wght@400;600&family=JetBrains+Mono:wght@400;700&display=swap" rel="stylesheet">
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }

    :root {
      --bg: #050508;
      --panel: #0a0a10;
      --border: #1a1a2e;
      --gold: #ffd700;
      --red: #ff3366;
      --blue: #4466ff;
      --cyan: #00ffff;
      --purple: #9933ff;
      --text: #e8e8f0;
      --muted: #6a6a8a;
    }

    body {
      background: var(--bg);
      font-family: 'Crimson Pro', serif;
      color: var(--text);
      overflow: hidden;
      height: 100vh;
    }

    .container {
      display: grid;
      grid-template-columns: 320px 1fr;
      height: 100vh;
    }

    @media (max-width: 900px) {
      .container {
        grid-template-columns: 1fr;
      }
      .control-panel {
        position: fixed;
        bottom: 0;
        left: 0;
        right: 0;
        height: auto;
        max-height: 50vh;
        overflow-y: auto;
        z-index: 100;
      }
    }

    /* Control Panel */
    .control-panel {
      background: var(--panel);
      border-right: 1px solid var(--border);
      padding: 25px;
      overflow-y: auto;
    }

    .logo {
      text-align: center;
      margin-bottom: 30px;
      padding-bottom: 20px;
      border-bottom: 1px solid var(--border);
    }

    .logo h1 {
      font-size: 1.8rem;
      font-weight: 600;
      letter-spacing: 3px;
      background: linear-gradient(135deg, var(--gold), var(--red));
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
    }

    .logo p {
      font-size: 0.85rem;
      color: var(--muted);
      margin-top: 5px;
      font-style: italic;
    }

    .section {
      margin-bottom: 25px;
    }

    .section-title {
      font-size: 0.75rem;
      text-transform: uppercase;
      letter-spacing: 2px;
      color: var(--muted);
      margin-bottom: 12px;
    }

    /* Expression Input */
    .expression-input {
      background: var(--bg);
      border: 1px solid var(--border);
      border-radius: 8px;
      padding: 15px;
      font-family: 'JetBrains Mono', monospace;
      font-size: 1.1rem;
      color: var(--cyan);
      width: 100%;
      outline: none;
      transition: border-color 0.3s;
    }

    .expression-input:focus {
      border-color: var(--gold);
    }

    .expression-hint {
      font-size: 0.75rem;
      color: var(--muted);
      margin-top: 8px;
    }

    /* Presets */
    .preset-grid {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 8px;
    }

    .preset-btn {
      background: var(--bg);
      border: 1px solid var(--border);
      color: var(--text);
      padding: 10px;
      border-radius: 6px;
      cursor: pointer;
      font-family: 'JetBrains Mono', monospace;
      font-size: 0.75rem;
      transition: all 0.2s;
      text-align: left;
    }

    .preset-btn:hover {
      border-color: var(--gold);
      background: rgba(255, 215, 0, 0.05);
    }

    .preset-btn.active {
      border-color: var(--gold);
      background: rgba(255, 215, 0, 0.1);
    }

    .preset-name {
      display: block;
      color: var(--gold);
      margin-bottom: 3px;
    }

    .preset-formula {
      color: var(--muted);
      font-size: 0.7rem;
    }

    /* Sliders */
    .slider-group {
      margin-bottom: 15px;
    }

    .slider-label {
      display: flex;
      justify-content: space-between;
      font-size: 0.85rem;
      margin-bottom: 5px;
    }

    .slider-value {
      font-family: 'JetBrains Mono', monospace;
      color: var(--cyan);
    }

    input[type="range"] {
      width: 100%;
      height: 6px;
      -webkit-appearance: none;
      background: var(--border);
      border-radius: 3px;
      outline: none;
    }

    input[type="range"]::-webkit-slider-thumb {
      -webkit-appearance: none;
      width: 16px;
      height: 16px;
      background: var(--gold);
      border-radius: 50%;
      cursor: pointer;
    }

    /* Output Display */
    .output-display {
      background: var(--bg);
      border: 1px solid var(--border);
      border-radius: 8px;
      padding: 15px;
      font-family: 'JetBrains Mono', monospace;
      font-size: 0.8rem;
    }

    .output-row {
      display: flex;
      justify-content: space-between;
      padding: 5px 0;
      border-bottom: 1px solid var(--border);
    }

    .output-row:last-child {
      border-bottom: none;
    }

    .output-label {
      color: var(--muted);
    }

    .output-value {
      color: var(--cyan);
    }

    .output-value.undefined {
      color: var(--red);
      animation: pulse-red 1s ease-in-out infinite;
    }

    .output-value.imaginary {
      color: var(--purple);
    }

    @keyframes pulse-red {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.5; }
    }

    /* Canvas */
    .canvas-container {
      position: relative;
      background: var(--bg);
    }

    canvas {
      display: block;
    }

    .canvas-overlay {
      position: absolute;
      top: 20px;
      right: 20px;
      background: rgba(10, 10, 16, 0.9);
      border: 1px solid var(--border);
      border-radius: 8px;
      padding: 15px;
      font-family: 'JetBrains Mono', monospace;
      font-size: 0.75rem;
    }

    .coord-display {
      margin-bottom: 10px;
    }

    .coord-label {
      color: var(--muted);
    }

    .coord-value {
      color: var(--cyan);
    }

    .singularity-warning {
      display: none;
      background: rgba(255, 51, 102, 0.1);
      border: 1px solid var(--red);
      border-radius: 6px;
      padding: 10px;
      margin-top: 10px;
      color: var(--red);
      animation: warning-pulse 0.5s ease-in-out infinite;
    }

    .singularity-warning.active {
      display: block;
    }

    @keyframes warning-pulse {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.7; }
    }

    .legend {
      position: absolute;
      bottom: 20px;
      right: 20px;
      background: rgba(10, 10, 16, 0.9);
      border: 1px solid var(--border);
      border-radius: 8px;
      padding: 12px;
      font-size: 0.7rem;
    }

    .legend-item {
      display: flex;
      align-items: center;
      gap: 8px;
      margin-bottom: 5px;
    }

    .legend-item:last-child {
      margin-bottom: 0;
    }

    .legend-color {
      width: 12px;
      height: 12px;
      border-radius: 2px;
    }

    .back-link {
      position: fixed;
      top: 20px;
      right: 20px;
      color: var(--muted);
      text-decoration: none;
      font-size: 0.75rem;
      z-index: 50;
    }

    .back-link:hover {
      color: var(--gold);
    }

    /* Equations */
    .equation {
      text-align: center;
      padding: 15px;
      background: var(--bg);
      border: 1px solid var(--border);
      border-radius: 8px;
      font-family: 'JetBrains Mono', monospace;
      margin-bottom: 15px;
    }

    .equation-main {
      font-size: 1.2rem;
      color: var(--gold);
      margin-bottom: 5px;
    }

    .equation-desc {
      font-size: 0.7rem;
      color: var(--muted);
    }
  </style>
</head>
<body>
  <div class="container">
    <div class="control-panel">
      <div class="logo">
        <h1>THE SINGULARITY</h1>
        <p>Where mathematics breaks down</p>
      </div>

      <div class="section">
        <div class="section-title">Function f(z)</div>
        <input type="text" class="expression-input" id="expression" value="1/z" placeholder="Enter complex function...">
        <div class="expression-hint">Use z for complex variable, i for √-1</div>
      </div>

      <div class="section">
        <div class="section-title">Presets</div>
        <div class="preset-grid">
          <button class="preset-btn active" onclick="setPreset('1/z')">
            <span class="preset-name">Simple Pole</span>
            <span class="preset-formula">f(z) = 1/z</span>
          </button>
          <button class="preset-btn" onclick="setPreset('1/(z*z)')">
            <span class="preset-name">Double Pole</span>
            <span class="preset-formula">f(z) = 1/z²</span>
          </button>
          <button class="preset-btn" onclick="setPreset('z*z')">
            <span class="preset-name">Parabolic</span>
            <span class="preset-formula">f(z) = z²</span>
          </button>
          <button class="preset-btn" onclick="setPreset('exp(1/z)')">
            <span class="preset-name">Essential</span>
            <span class="preset-formula">f(z) = e^(1/z)</span>
          </button>
          <button class="preset-btn" onclick="setPreset('sin(1/z)')">
            <span class="preset-name">Oscillating</span>
            <span class="preset-formula">f(z) = sin(1/z)</span>
          </button>
          <button class="preset-btn" onclick="setPreset('(z-1)/(z+1)')">
            <span class="preset-name">Möbius</span>
            <span class="preset-formula">f(z) = (z-1)/(z+1)</span>
          </button>
          <button class="preset-btn" onclick="setPreset('sqrt(z)')">
            <span class="preset-name">Branch Cut</span>
            <span class="preset-formula">f(z) = √z</span>
          </button>
          <button class="preset-btn" onclick="setPreset('log(z)')">
            <span class="preset-name">Logarithm</span>
            <span class="preset-formula">f(z) = ln(z)</span>
          </button>
        </div>
      </div>

      <div class="section">
        <div class="section-title">View Controls</div>
        <div class="slider-group">
          <div class="slider-label">
            <span>Zoom</span>
            <span class="slider-value" id="zoom-value">1.0x</span>
          </div>
          <input type="range" id="zoom" min="0.1" max="5" step="0.1" value="1">
        </div>
        <div class="slider-group">
          <div class="slider-label">
            <span>Grid Density</span>
            <span class="slider-value" id="density-value">20</span>
          </div>
          <input type="range" id="density" min="10" max="50" step="5" value="20">
        </div>
        <div class="slider-group">
          <div class="slider-label">
            <span>Warp Intensity</span>
            <span class="slider-value" id="warp-value">1.0</span>
          </div>
          <input type="range" id="warp" min="0" max="2" step="0.1" value="1">
        </div>
        <div class="slider-group">
          <div class="slider-label">
            <span>Animation Speed</span>
            <span class="slider-value" id="speed-value">1.0x</span>
          </div>
          <input type="range" id="speed" min="0" max="3" step="0.1" value="1">
        </div>
      </div>

      <div class="section">
        <div class="section-title">Probe Point</div>
        <div class="equation">
          <div class="equation-main" id="probe-input">z = 0 + 0i</div>
          <div class="equation-desc">Click on plane to probe</div>
        </div>
        <div class="output-display">
          <div class="output-row">
            <span class="output-label">f(z) =</span>
            <span class="output-value" id="output-result">∞ (undefined)</span>
          </div>
          <div class="output-row">
            <span class="output-label">|f(z)| =</span>
            <span class="output-value" id="output-magnitude">∞</span>
          </div>
          <div class="output-row">
            <span class="output-label">arg(f(z)) =</span>
            <span class="output-value" id="output-arg">undefined</span>
          </div>
          <div class="output-row">
            <span class="output-label">Type:</span>
            <span class="output-value" id="output-type">Singularity</span>
          </div>
        </div>
      </div>
    </div>

    <div class="canvas-container">
      <canvas id="plane"></canvas>
      <div class="canvas-overlay">
        <div class="coord-display">
          <span class="coord-label">Cursor: </span>
          <span class="coord-value" id="cursor-coords">0 + 0i</span>
        </div>
        <div class="coord-display">
          <span class="coord-label">Mapped: </span>
          <span class="coord-value" id="mapped-coords">∞</span>
        </div>
        <div class="singularity-warning" id="singularity-warning">
          ⚠ SINGULARITY DETECTED<br>
          Division by zero imminent
        </div>
      </div>
      <div class="legend">
        <div class="legend-item">
          <div class="legend-color" style="background: #ff3366;"></div>
          <span>Singularity (pole)</span>
        </div>
        <div class="legend-item">
          <div class="legend-color" style="background: #ffd700;"></div>
          <span>Real axis</span>
        </div>
        <div class="legend-item">
          <div class="legend-color" style="background: #00ffff;"></div>
          <span>Imaginary axis</span>
        </div>
        <div class="legend-item">
          <div class="legend-color" style="background: linear-gradient(90deg, #4466ff, #9933ff);"></div>
          <span>Grid lines (warped)</span>
        </div>
      </div>
    </div>
  </div>

  <a href="https://sloppy.live" class="back-link">← sloppy.live</a>

  <script>
    const canvas = document.getElementById('plane');
    const ctx = canvas.getContext('2d');

    let width, height, centerX, centerY;
    let time = 0;
    let mouseX = 0, mouseY = 0;
    let probeZ = { re: 0, im: 0 };

    // Settings
    let settings = {
      expression: '1/z',
      zoom: 1,
      density: 20,
      warp: 1,
      speed: 1
    };

    // Complex number operations
    const Complex = {
      add: (a, b) => ({ re: a.re + b.re, im: a.im + b.im }),
      sub: (a, b) => ({ re: a.re - b.re, im: a.im - b.im }),
      mul: (a, b) => ({
        re: a.re * b.re - a.im * b.im,
        im: a.re * b.im + a.im * b.re
      }),
      div: (a, b) => {
        const denom = b.re * b.re + b.im * b.im;
        if (denom === 0) return { re: Infinity, im: Infinity, singular: true };
        return {
          re: (a.re * b.re + a.im * b.im) / denom,
          im: (a.im * b.re - a.re * b.im) / denom
        };
      },
      abs: (z) => Math.sqrt(z.re * z.re + z.im * z.im),
      arg: (z) => Math.atan2(z.im, z.re),
      exp: (z) => {
        const r = Math.exp(z.re);
        return { re: r * Math.cos(z.im), im: r * Math.sin(z.im) };
      },
      log: (z) => {
        const r = Complex.abs(z);
        if (r === 0) return { re: -Infinity, im: 0, singular: true };
        return { re: Math.log(r), im: Complex.arg(z) };
      },
      sin: (z) => {
        return {
          re: Math.sin(z.re) * Math.cosh(z.im),
          im: Math.cos(z.re) * Math.sinh(z.im)
        };
      },
      cos: (z) => {
        return {
          re: Math.cos(z.re) * Math.cosh(z.im),
          im: -Math.sin(z.re) * Math.sinh(z.im)
        };
      },
      sqrt: (z) => {
        const r = Complex.abs(z);
        const theta = Complex.arg(z);
        const sqrtR = Math.sqrt(r);
        return {
          re: sqrtR * Math.cos(theta / 2),
          im: sqrtR * Math.sin(theta / 2)
        };
      },
      pow: (z, n) => {
        const r = Complex.abs(z);
        const theta = Complex.arg(z);
        const newR = Math.pow(r, n);
        return {
          re: newR * Math.cos(n * theta),
          im: newR * Math.sin(n * theta)
        };
      }
    };

    // Parse and evaluate expression
    function evaluate(expr, z) {
      try {
        // Replace mathematical notation
        let parsed = expr
          .replace(/\^/g, '**')
          .replace(/(\d)([zi])/g, '$1*$2')
          .replace(/([zi])(\d)/g, '$1*$2')
          .replace(/\)(\()/g, ')*(');

        // Create evaluation context
        const i = { re: 0, im: 1 };

        // Simple parser for common operations
        const evalComplex = (expr, z) => {
          expr = expr.trim();

          // Handle 1/z (simple pole)
          if (expr === '1/z') {
            return Complex.div({ re: 1, im: 0 }, z);
          }

          // Handle 1/(z*z) (double pole)
          if (expr === '1/(z*z)') {
            const z2 = Complex.mul(z, z);
            return Complex.div({ re: 1, im: 0 }, z2);
          }

          // Handle z*z
          if (expr === 'z*z') {
            return Complex.mul(z, z);
          }

          // Handle exp(1/z)
          if (expr === 'exp(1/z)') {
            const inv = Complex.div({ re: 1, im: 0 }, z);
            if (inv.singular) return inv;
            return Complex.exp(inv);
          }

          // Handle sin(1/z)
          if (expr === 'sin(1/z)') {
            const inv = Complex.div({ re: 1, im: 0 }, z);
            if (inv.singular) return inv;
            return Complex.sin(inv);
          }

          // Handle (z-1)/(z+1) Möbius
          if (expr === '(z-1)/(z+1)') {
            const num = Complex.sub(z, { re: 1, im: 0 });
            const den = Complex.add(z, { re: 1, im: 0 });
            return Complex.div(num, den);
          }

          // Handle sqrt(z)
          if (expr === 'sqrt(z)') {
            return Complex.sqrt(z);
          }

          // Handle log(z)
          if (expr === 'log(z)') {
            return Complex.log(z);
          }

          // Handle z^n
          const powerMatch = expr.match(/z\*\*(\d+)/);
          if (powerMatch) {
            return Complex.pow(z, parseInt(powerMatch[1]));
          }

          // Default: return z
          return z;
        };

        return evalComplex(expr, z);
      } catch (e) {
        return { re: NaN, im: NaN };
      }
    }

    // Convert screen to complex coordinates
    function screenToComplex(x, y) {
      const scale = 4 / settings.zoom;
      return {
        re: (x - centerX) / (width / 2) * scale,
        im: -(y - centerY) / (height / 2) * scale
      };
    }

    // Convert complex to screen coordinates
    function complexToScreen(z) {
      const scale = 4 / settings.zoom;
      return {
        x: centerX + (z.re / scale) * (width / 2),
        y: centerY - (z.im / scale) * (height / 2)
      };
    }

    // Format complex number for display
    function formatComplex(z) {
      if (z.singular || !isFinite(z.re) || !isFinite(z.im)) {
        return '∞ (undefined)';
      }
      if (isNaN(z.re) || isNaN(z.im)) {
        return 'NaN';
      }

      const re = z.re.toFixed(3);
      const im = Math.abs(z.im).toFixed(3);
      const sign = z.im >= 0 ? '+' : '-';

      if (Math.abs(z.im) < 0.001) return re;
      if (Math.abs(z.re) < 0.001) return `${z.im >= 0 ? '' : '-'}${im}i`;
      return `${re} ${sign} ${im}i`;
    }

    // Draw the complex plane
    function render() {
      ctx.fillStyle = '#050508';
      ctx.fillRect(0, 0, width, height);

      const scale = 4 / settings.zoom;
      const gridSize = settings.density;
      const warp = settings.warp;

      // Draw warped grid
      ctx.lineWidth = 1;

      // Vertical lines (constant real part)
      for (let i = -gridSize; i <= gridSize; i++) {
        const re = (i / gridSize) * scale;

        ctx.beginPath();
        let firstPoint = true;

        for (let j = -gridSize * 2; j <= gridSize * 2; j++) {
          const im = (j / gridSize) * scale;
          const z = { re, im };
          const w = evaluate(settings.expression, z);

          if (w.singular || !isFinite(w.re) || !isFinite(w.im)) {
            firstPoint = true;
            continue;
          }

          // Apply warp
          const warped = {
            re: z.re + (w.re - z.re) * warp,
            im: z.im + (w.im - z.im) * warp
          };

          const screen = complexToScreen(warped);

          if (screen.x < -100 || screen.x > width + 100 ||
              screen.y < -100 || screen.y > height + 100) {
            firstPoint = true;
            continue;
          }

          if (firstPoint) {
            ctx.moveTo(screen.x, screen.y);
            firstPoint = false;
          } else {
            ctx.lineTo(screen.x, screen.y);
          }
        }

        const hue = (240 + i * 5 + time * 20) % 360;
        ctx.strokeStyle = `hsla(${hue}, 70%, 50%, 0.4)`;
        ctx.stroke();
      }

      // Horizontal lines (constant imaginary part)
      for (let j = -gridSize; j <= gridSize; j++) {
        const im = (j / gridSize) * scale;

        ctx.beginPath();
        let firstPoint = true;

        for (let i = -gridSize * 2; i <= gridSize * 2; i++) {
          const re = (i / gridSize) * scale;
          const z = { re, im };
          const w = evaluate(settings.expression, z);

          if (w.singular || !isFinite(w.re) || !isFinite(w.im)) {
            firstPoint = true;
            continue;
          }

          const warped = {
            re: z.re + (w.re - z.re) * warp,
            im: z.im + (w.im - z.im) * warp
          };

          const screen = complexToScreen(warped);

          if (screen.x < -100 || screen.x > width + 100 ||
              screen.y < -100 || screen.y > height + 100) {
            firstPoint = true;
            continue;
          }

          if (firstPoint) {
            ctx.moveTo(screen.x, screen.y);
            firstPoint = false;
          } else {
            ctx.lineTo(screen.x, screen.y);
          }
        }

        const hue = (280 + j * 5 + time * 20) % 360;
        ctx.strokeStyle = `hsla(${hue}, 70%, 50%, 0.4)`;
        ctx.stroke();
      }

      // Draw axes
      ctx.lineWidth = 2;

      // Real axis (gold)
      ctx.beginPath();
      ctx.moveTo(0, centerY);
      ctx.lineTo(width, centerY);
      ctx.strokeStyle = 'rgba(255, 215, 0, 0.5)';
      ctx.stroke();

      // Imaginary axis (cyan)
      ctx.beginPath();
      ctx.moveTo(centerX, 0);
      ctx.lineTo(centerX, height);
      ctx.strokeStyle = 'rgba(0, 255, 255, 0.5)';
      ctx.stroke();

      // Draw singularities (poles)
      const singularities = findSingularities();
      singularities.forEach(s => {
        const screen = complexToScreen(s);
        const pulseSize = 15 + Math.sin(time * 5) * 5;

        // Glow effect
        const gradient = ctx.createRadialGradient(
          screen.x, screen.y, 0,
          screen.x, screen.y, pulseSize * 3
        );
        gradient.addColorStop(0, 'rgba(255, 51, 102, 0.8)');
        gradient.addColorStop(0.5, 'rgba(255, 51, 102, 0.2)');
        gradient.addColorStop(1, 'rgba(255, 51, 102, 0)');

        ctx.fillStyle = gradient;
        ctx.beginPath();
        ctx.arc(screen.x, screen.y, pulseSize * 3, 0, Math.PI * 2);
        ctx.fill();

        // Core
        ctx.fillStyle = '#ff3366';
        ctx.beginPath();
        ctx.arc(screen.x, screen.y, 5, 0, Math.PI * 2);
        ctx.fill();

        // Infinity symbol
        ctx.fillStyle = '#fff';
        ctx.font = '16px serif';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText('∞', screen.x, screen.y);
      });

      // Draw probe point
      if (probeZ) {
        const probeScreen = complexToScreen(probeZ);
        ctx.strokeStyle = '#ffd700';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.arc(probeScreen.x, probeScreen.y, 8, 0, Math.PI * 2);
        ctx.stroke();

        // Cross
        ctx.beginPath();
        ctx.moveTo(probeScreen.x - 12, probeScreen.y);
        ctx.lineTo(probeScreen.x + 12, probeScreen.y);
        ctx.moveTo(probeScreen.x, probeScreen.y - 12);
        ctx.lineTo(probeScreen.x, probeScreen.y + 12);
        ctx.stroke();
      }

      // Update time
      time += 0.016 * settings.speed;

      requestAnimationFrame(render);
    }

    // Find singularities in the current function
    function findSingularities() {
      const expr = settings.expression;
      const singularities = [];

      // Check common singularity points
      const testPoints = [
        { re: 0, im: 0 },
        { re: 1, im: 0 },
        { re: -1, im: 0 },
        { re: 0, im: 1 },
        { re: 0, im: -1 }
      ];

      testPoints.forEach(z => {
        const w = evaluate(expr, z);
        if (w.singular || !isFinite(Complex.abs(w))) {
          singularities.push(z);
        }
      });

      return singularities;
    }

    // Update probe display
    function updateProbe(z) {
      probeZ = z;
      const w = evaluate(settings.expression, z);

      document.getElementById('probe-input').textContent = `z = ${formatComplex(z)}`;
      document.getElementById('output-result').textContent = formatComplex(w);
      document.getElementById('output-result').className = 'output-value' +
        (w.singular ? ' undefined' : (Math.abs(w.im) > 0.001 ? ' imaginary' : ''));

      const mag = Complex.abs(w);
      document.getElementById('output-magnitude').textContent =
        isFinite(mag) ? mag.toFixed(4) : '∞';

      const arg = Complex.arg(w);
      document.getElementById('output-arg').textContent =
        isFinite(arg) ? `${(arg * 180 / Math.PI).toFixed(2)}°` : 'undefined';

      // Determine type
      let type = 'Regular point';
      if (w.singular) type = 'Singularity (pole)';
      else if (!isFinite(mag)) type = 'Diverges to ∞';
      else if (Math.abs(w.im) > 0.001) type = 'Complex value';
      document.getElementById('output-type').textContent = type;

      // Warning
      const warning = document.getElementById('singularity-warning');
      const distToOrigin = Complex.abs(z);
      warning.classList.toggle('active', distToOrigin < 0.1 && settings.expression.includes('1/z'));
    }

    // Set preset function
    function setPreset(expr) {
      settings.expression = expr;
      document.getElementById('expression').value = expr;

      // Update button states
      document.querySelectorAll('.preset-btn').forEach(btn => {
        btn.classList.toggle('active', btn.querySelector('.preset-formula').textContent.includes(expr));
      });

      updateProbe(probeZ);
    }

    // Resize handler
    function resize() {
      width = canvas.width = canvas.parentElement.clientWidth;
      height = canvas.height = canvas.parentElement.clientHeight;
      centerX = width / 2;
      centerY = height / 2;
    }

    // Event listeners
    window.addEventListener('resize', resize);

    canvas.addEventListener('mousemove', (e) => {
      const rect = canvas.getBoundingClientRect();
      mouseX = e.clientX - rect.left;
      mouseY = e.clientY - rect.top;

      const z = screenToComplex(mouseX, mouseY);
      const w = evaluate(settings.expression, z);

      document.getElementById('cursor-coords').textContent = formatComplex(z);
      document.getElementById('mapped-coords').textContent = formatComplex(w);

      // Check proximity to singularity
      const warning = document.getElementById('singularity-warning');
      const distToOrigin = Complex.abs(z);
      warning.classList.toggle('active',
        distToOrigin < 0.2 && settings.expression.includes('1/z'));
    });

    canvas.addEventListener('click', (e) => {
      const rect = canvas.getBoundingClientRect();
      const x = e.clientX - rect.left;
      const y = e.clientY - rect.top;
      const z = screenToComplex(x, y);
      updateProbe(z);
    });

    document.getElementById('expression').addEventListener('input', (e) => {
      settings.expression = e.target.value;
      updateProbe(probeZ);
    });

    document.getElementById('zoom').addEventListener('input', (e) => {
      settings.zoom = parseFloat(e.target.value);
      document.getElementById('zoom-value').textContent = settings.zoom.toFixed(1) + 'x';
    });

    document.getElementById('density').addEventListener('input', (e) => {
      settings.density = parseInt(e.target.value);
      document.getElementById('density-value').textContent = settings.density;
    });

    document.getElementById('warp').addEventListener('input', (e) => {
      settings.warp = parseFloat(e.target.value);
      document.getElementById('warp-value').textContent = settings.warp.toFixed(1);
    });

    document.getElementById('speed').addEventListener('input', (e) => {
      settings.speed = parseFloat(e.target.value);
      document.getElementById('speed-value').textContent = settings.speed.toFixed(1) + 'x';
    });

    // Initialize
    resize();
    updateProbe({ re: 0.5, im: 0.5 });
    render();
  </script>
<script src="/sloppy-header/sloppy-bar.js"></script>
<script src="/vibelib-extended.js"></script>
<script>
  // Compatibility Patch for Legacy Apps
  window.addEventListener("load", () => {
    if (window.SloppyKarma && window.VibeLib.Economy) {
      // Redirect old calls to new engine
      window.SloppyKarma.track = window.VibeLib.Economy.track;
    }
  });
</script>
</body>
</html>
