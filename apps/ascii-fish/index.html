<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
  <title>ASCII Aquarium</title>
  <link rel="icon" href="https://emojicdn.elk.sh/ðŸŸ">
  <meta name="description" content="Watch ASCII fish swim in a retro terminal aquarium">
  <meta property="og:title" content="ASCII Aquarium">
  <meta property="og:description" content="Watch ASCII fish swim in a retro terminal aquarium">
  <meta property="og:image" content="https://emojicdn.elk.sh/ðŸŸ?style=google">
  <meta property="og:url" content="https://app.sloppy.live/ascii-fish">
  <style>
    @import url('https://fonts.googleapis.com/css2?family=VT323&display=swap');

    * { margin: 0; padding: 0; box-sizing: border-box; }

    body {
      min-height: 100vh;
      background: #0a0a0a;
      font-family: 'VT323', monospace;
      overflow: hidden;
    }

    .back-link {
      position: fixed;
      top: 8px;
      left: 12px;
      color: #0f0;
      text-decoration: none;
      font-size: 1rem;
      z-index: 100;
      opacity: 0.5;
    }

    .terminal {
      width: 100vw;
      height: 100vh;
      background: #0a0a0a;
      position: relative;
      overflow: hidden;
    }

    /* CRT effect */
    .terminal::before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: linear-gradient(
        transparent 50%,
        rgba(0, 0, 0, 0.1) 50%
      );
      background-size: 100% 4px;
      pointer-events: none;
      z-index: 1000;
    }

    .terminal::after {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: radial-gradient(
        ellipse at center,
        transparent 0%,
        rgba(0,0,0,0.3) 100%
      );
      pointer-events: none;
      z-index: 999;
    }

    .screen {
      width: 100%;
      height: 100%;
      position: relative;
      padding: 40px 20px 60px;
    }

    #aquarium {
      width: 100%;
      height: 100%;
      color: #0f0;
      font-size: 14px;
      line-height: 1.2;
      white-space: pre;
      overflow: hidden;
      text-shadow: 0 0 5px #0f0;
    }

    .header-bar {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      padding: 8px 15px;
      background: #0f0;
      color: #000;
      font-size: 1rem;
      display: flex;
      justify-content: space-between;
      z-index: 100;
    }

    .status-bar {
      position: fixed;
      bottom: 0;
      left: 0;
      right: 0;
      padding: 8px 15px;
      background: #111;
      border-top: 1px solid #0f0;
      color: #0f0;
      font-size: 0.9rem;
      display: flex;
      justify-content: space-between;
      z-index: 100;
    }

    .controls {
      display: flex;
      gap: 15px;
    }

    .ctrl-btn {
      background: none;
      border: 1px solid #0f0;
      color: #0f0;
      padding: 2px 10px;
      font-family: 'VT323', monospace;
      font-size: 0.9rem;
      cursor: pointer;
      transition: all 0.2s;
    }

    .ctrl-btn:hover {
      background: #0f0;
      color: #000;
    }

    .blink {
      animation: blink 1s infinite;
    }

    @keyframes blink {
      0%, 50% { opacity: 1; }
      51%, 100% { opacity: 0; }
    }
  </style>
</head>
<body>
  <a href="https://sloppy.live" class="back-link">[ESC] EXIT</a>

  <div class="header-bar">
    <span>ASCII AQUARIUM v1.0</span>
    <span id="clock"></span>
  </div>

  <div class="terminal">
    <div class="screen">
      <div id="aquarium"></div>
    </div>
  </div>

  <div class="status-bar">
    <span>FISH: <span id="fishCount">0</span> | BUBBLES: <span id="bubbleCount">0</span></span>
    <div class="controls">
      <button class="ctrl-btn" onclick="addFish()">[F] ADD FISH</button>
      <button class="ctrl-btn" onclick="togglePause()">[P] PAUSE</button>
      <button class="ctrl-btn" onclick="clearAll()">[C] CLEAR</button>
    </div>
  </div>

  <script>
    const aquarium = document.getElementById('aquarium');
    let cols, rows;
    let grid = [];
    let fish = [];
    let bubbles = [];
    let seaweed = [];
    let paused = false;

    // Fish ASCII art (facing right and left)
    const fishShapes = [
      { right: ['><>'], left: ['<><'] },
      { right: ['><))Â°>'], left: ['<Â°((><'] },
      { right: [' /\\', '><_/>'], left: ['/\\ ', '<\\_><'] },
      { right: ['Â°>=>'], left: ['<=<Â°'] },
      { right: ['>Â°)))><'], left: ['><(((Â°<'] },
      { right: ['~=<*))><'], left: ['><((*>=~'] },
    ];

    const fishColors = ['#0f0', '#0ff', '#ff0', '#f0f', '#f80', '#8f0'];

    function resize() {
      const fontSize = 14;
      const lineHeight = fontSize * 1.2;
      cols = Math.floor((window.innerWidth - 40) / (fontSize * 0.6));
      rows = Math.floor((window.innerHeight - 120) / lineHeight);
      initGrid();
      initSeaweed();
    }

    function initGrid() {
      grid = [];
      for (let y = 0; y < rows; y++) {
        grid[y] = [];
        for (let x = 0; x < cols; x++) {
          grid[y][x] = { char: ' ', color: '#0f0' };
        }
      }
    }

    function initSeaweed() {
      seaweed = [];
      const count = Math.floor(cols / 12);
      for (let i = 0; i < count; i++) {
        seaweed.push({
          x: 5 + i * 12 + Math.floor(Math.random() * 6),
          height: 4 + Math.floor(Math.random() * 6),
          phase: Math.random() * Math.PI * 2
        });
      }
    }

    class Fish {
      constructor(x, y) {
        this.shapeIndex = Math.floor(Math.random() * fishShapes.length);
        this.shape = fishShapes[this.shapeIndex];
        this.x = x !== undefined ? x : Math.floor(Math.random() * (cols - 10));
        this.y = y !== undefined ? y : 2 + Math.floor(Math.random() * (rows - 8));
        this.direction = Math.random() > 0.5 ? 1 : -1;
        this.speed = 0.3 + Math.random() * 0.4;
        this.moveCounter = 0;
        this.color = fishColors[Math.floor(Math.random() * fishColors.length)];
        this.verticalDir = (Math.random() - 0.5) * 0.1;
        this.floatY = this.y;
      }

      update() {
        this.moveCounter += this.speed;
        if (this.moveCounter >= 1) {
          this.moveCounter = 0;
          this.x += this.direction;

          // Vertical float
          this.floatY += this.verticalDir;
          if (Math.random() < 0.05) {
            this.verticalDir = (Math.random() - 0.5) * 0.2;
          }
          this.floatY = Math.max(2, Math.min(rows - 5, this.floatY));
          this.y = Math.round(this.floatY);

          // Turn around at edges
          const art = this.direction > 0 ? this.shape.right : this.shape.left;
          const width = Math.max(...art.map(l => l.length));

          if (this.x < -width) {
            this.x = -width;
            this.direction = 1;
          }
          if (this.x > cols) {
            this.x = cols;
            this.direction = -1;
          }
        }

        // Random bubble
        if (Math.random() < 0.01) {
          const art = this.direction > 0 ? this.shape.right : this.shape.left;
          const bx = this.direction > 0 ? this.x + art[0].length : this.x;
          bubbles.push(new Bubble(bx, this.y));
        }
      }

      draw() {
        const art = this.direction > 0 ? this.shape.right : this.shape.left;
        for (let i = 0; i < art.length; i++) {
          const line = art[i];
          for (let j = 0; j < line.length; j++) {
            const px = this.x + j;
            const py = this.y + i;
            if (px >= 0 && px < cols && py >= 0 && py < rows && line[j] !== ' ') {
              grid[py][px] = { char: line[j], color: this.color };
            }
          }
        }
      }
    }

    class Bubble {
      constructor(x, y) {
        this.x = x;
        this.y = y;
        this.floatX = x;
        this.speed = 0.2 + Math.random() * 0.3;
        this.moveCounter = 0;
        this.char = Math.random() > 0.5 ? 'o' : 'Â°';
      }

      update() {
        this.moveCounter += this.speed;
        if (this.moveCounter >= 1) {
          this.moveCounter = 0;
          this.y--;
          this.floatX += (Math.random() - 0.5) * 0.5;
          this.x = Math.round(this.floatX);
        }
        return this.y > 0;
      }

      draw() {
        if (this.x >= 0 && this.x < cols && this.y >= 0 && this.y < rows) {
          grid[this.y][this.x] = { char: this.char, color: '#0ff' };
        }
      }
    }

    function drawSeaweed(time) {
      seaweed.forEach(sw => {
        for (let i = 0; i < sw.height; i++) {
          const py = rows - 2 - i;
          const sway = Math.sin(time * 0.002 + sw.phase + i * 0.5) * (i * 0.3);
          const px = sw.x + Math.round(sway);
          if (px >= 0 && px < cols && py >= 0 && py < rows) {
            const chars = [')', '(', '|', '/', '\\'];
            const char = chars[Math.floor((time * 0.01 + i) % chars.length)];
            grid[py][px] = { char: i === sw.height - 1 ? '*' : char, color: '#0a0' };
          }
        }
      });
    }

    function drawFloor() {
      for (let x = 0; x < cols; x++) {
        const char = Math.random() > 0.9 ? '.' : (Math.random() > 0.95 ? ',' : '_');
        grid[rows - 1][x] = { char, color: '#660' };
      }
    }

    function drawSurface(time) {
      for (let x = 0; x < cols; x++) {
        const wave = Math.sin(time * 0.003 + x * 0.2);
        const char = wave > 0.3 ? '~' : (wave < -0.3 ? '~' : '-');
        grid[0][x] = { char, color: '#068' };
      }
    }

    function render(time) {
      // Clear grid
      initGrid();

      // Draw environment
      drawSurface(time);
      drawFloor();
      drawSeaweed(time);

      // Update and draw bubbles
      bubbles = bubbles.filter(b => b.update());
      bubbles.forEach(b => b.draw());

      // Update and draw fish
      fish.forEach(f => {
        f.update();
        f.draw();
      });

      // Convert grid to string with colors
      let html = '';
      for (let y = 0; y < rows; y++) {
        for (let x = 0; x < cols; x++) {
          const cell = grid[y][x];
          if (cell.color !== '#0f0') {
            html += `<span style="color:${cell.color}">${escapeHtml(cell.char)}</span>`;
          } else {
            html += escapeHtml(cell.char);
          }
        }
        html += '\n';
      }

      aquarium.innerHTML = html;

      // Update counts
      document.getElementById('fishCount').textContent = fish.length;
      document.getElementById('bubbleCount').textContent = bubbles.length;
    }

    function escapeHtml(char) {
      if (char === '<') return '&lt;';
      if (char === '>') return '&gt;';
      if (char === '&') return '&amp;';
      return char;
    }

    function addFish(x, y) {
      if (fish.length < 30) {
        fish.push(new Fish(x, y));
      }
    }

    function togglePause() {
      paused = !paused;
    }

    function clearAll() {
      fish = [];
      bubbles = [];
    }

    function updateClock() {
      const now = new Date();
      document.getElementById('clock').textContent = now.toLocaleTimeString();
    }

    // Keyboard controls
    document.addEventListener('keydown', (e) => {
      if (e.key === 'f' || e.key === 'F') addFish();
      if (e.key === 'p' || e.key === 'P') togglePause();
      if (e.key === 'c' || e.key === 'C') clearAll();
    });

    // Click to add fish
    aquarium.addEventListener('click', (e) => {
      const rect = aquarium.getBoundingClientRect();
      const fontSize = 14;
      const x = Math.floor((e.clientX - rect.left) / (fontSize * 0.6));
      const y = Math.floor((e.clientY - rect.top) / (fontSize * 1.2));
      addFish(x, y);
    });

    // Initialize
    resize();
    window.addEventListener('resize', resize);

    // Add initial fish
    for (let i = 0; i < 5; i++) {
      addFish();
    }

    // Main loop
    let lastTime = 0;
    function loop(time) {
      if (!paused) {
        render(time);
      }
      updateClock();
      requestAnimationFrame(loop);
    }

    setInterval(updateClock, 1000);
    loop(0);
  </script>
<script src="/apps/sloppy-header/sloppy-bar.js"></script>
<script src="/vibelib-extended.js"></script>
<script>
  // Compatibility Patch for Legacy Apps
  window.addEventListener("load", () => {
    if (window.SloppyKarma && window.VibeLib.Economy) {
      // Redirect old calls to new engine
      window.SloppyKarma.track = window.VibeLib.Economy.track;
    }
  });
</script>
</body>
</html>
