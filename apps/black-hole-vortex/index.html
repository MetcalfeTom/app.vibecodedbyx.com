<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Black Hole Vortex - Survive the Gravity</title>
  <link rel="icon" href="https://emojicdn.elk.sh/ðŸ•³ï¸">
  <meta property="og:title" content="Black Hole Vortex">
  <meta property="og:description" content="Survive the gravitational pull of a neon black hole">
  <meta property="og:url" content="https://sloppy.live/black-hole-vortex">
  <meta property="og:image" content="https://emojicdn.elk.sh/ðŸŒ€?style=apple&size=512">
  <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&display=swap" rel="stylesheet">
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }

    body {
      background: #000;
      overflow: hidden;
      font-family: 'Orbitron', sans-serif;
    }

    canvas {
      display: block;
    }

    .ui {
      position: fixed;
      top: 20px;
      left: 20px;
      color: #0ff;
      text-shadow: 0 0 10px #0ff, 0 0 20px #0ff;
      z-index: 100;
      pointer-events: none;
    }

    .score {
      font-size: 1.5rem;
      font-weight: 700;
    }

    .energy-bar {
      margin-top: 10px;
      width: 200px;
      height: 8px;
      background: rgba(0, 255, 255, 0.2);
      border: 1px solid #0ff;
      border-radius: 4px;
      overflow: hidden;
    }

    .energy-fill {
      height: 100%;
      background: linear-gradient(90deg, #0ff, #f0f);
      transition: width 0.2s;
      box-shadow: 0 0 10px #0ff;
    }

    .boost-label {
      font-size: 0.7rem;
      margin-top: 5px;
      opacity: 0.7;
    }

    .game-over {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      text-align: center;
      color: #f0f;
      text-shadow: 0 0 30px #f0f;
      z-index: 200;
      display: none;
    }

    .game-over h1 {
      font-size: 3rem;
      margin-bottom: 20px;
      animation: pulse 1s infinite;
    }

    .game-over p {
      font-size: 1.2rem;
      color: #0ff;
      margin-bottom: 30px;
    }

    .restart-btn {
      font-family: 'Orbitron', sans-serif;
      font-size: 1rem;
      padding: 15px 40px;
      background: transparent;
      border: 2px solid #0ff;
      color: #0ff;
      cursor: pointer;
      transition: all 0.3s;
      text-shadow: 0 0 10px #0ff;
      box-shadow: 0 0 20px rgba(0, 255, 255, 0.3);
    }

    .restart-btn:hover {
      background: #0ff;
      color: #000;
    }

    @keyframes pulse {
      0%, 100% { opacity: 1; transform: translate(-50%, -50%) scale(1); }
      50% { opacity: 0.8; transform: translate(-50%, -50%) scale(1.05); }
    }

    .start-screen {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: radial-gradient(ellipse at center, #0a0015 0%, #000 100%);
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      z-index: 300;
    }

    .start-screen h1 {
      font-size: 2.5rem;
      color: #f0f;
      text-shadow: 0 0 30px #f0f, 0 0 60px #f0f;
      margin-bottom: 10px;
    }

    .start-screen .subtitle {
      color: #0ff;
      font-size: 1rem;
      margin-bottom: 40px;
      opacity: 0.8;
    }

    .start-btn {
      font-family: 'Orbitron', sans-serif;
      font-size: 1.2rem;
      padding: 20px 60px;
      background: transparent;
      border: 2px solid #f0f;
      color: #f0f;
      cursor: pointer;
      transition: all 0.3s;
      text-shadow: 0 0 10px #f0f;
      box-shadow: 0 0 30px rgba(255, 0, 255, 0.3);
      animation: glow 2s infinite;
    }

    .start-btn:hover {
      background: #f0f;
      color: #000;
      box-shadow: 0 0 50px #f0f;
    }

    @keyframes glow {
      0%, 100% { box-shadow: 0 0 30px rgba(255, 0, 255, 0.3); }
      50% { box-shadow: 0 0 50px rgba(255, 0, 255, 0.6); }
    }

    .controls-hint {
      position: fixed;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      color: #666;
      font-size: 0.8rem;
      z-index: 100;
    }

    .backlink {
      position: fixed;
      bottom: 20px;
      right: 20px;
      color: #333;
      font-size: 0.7rem;
      text-decoration: none;
      z-index: 100;
    }

    .backlink:hover { color: #0ff; }

    @media (max-width: 600px) {
      .start-screen h1 { font-size: 1.8rem; }
      .score { font-size: 1.2rem; }
      .energy-bar { width: 150px; }
    }
  </style>
</head>
<body>
  <canvas id="game"></canvas>

  <div class="ui">
    <div class="score">SCORE: <span id="score">0</span></div>
    <div class="energy-bar">
      <div class="energy-fill" id="energy-fill" style="width: 100%"></div>
    </div>
    <div class="boost-label">BOOST [SPACE/TAP]</div>
  </div>

  <div class="game-over" id="game-over">
    <h1>CONSUMED</h1>
    <p>Score: <span id="final-score">0</span></p>
    <button class="restart-btn" id="restart-btn">ESCAPE AGAIN</button>
  </div>

  <div class="start-screen" id="start-screen">
    <h1>BLACK HOLE VORTEX</h1>
    <p class="subtitle">Survive the gravitational pull</p>
    <button class="start-btn" id="start-btn">ENTER THE VOID</button>
  </div>

  <div class="controls-hint">Arrow keys / WASD to move â€¢ Space to boost</div>
  <a href="https://sloppy.live" class="backlink">sloppy.live</a>

  <script>
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');

    let W, H, centerX, centerY;

    function resize() {
      W = canvas.width = window.innerWidth;
      H = canvas.height = window.innerHeight;
      centerX = W / 2;
      centerY = H / 2;
    }
    resize();
    window.addEventListener('resize', resize);

    // Game state
    let gameRunning = false;
    let score = 0;
    let energy = 100;

    // Black hole properties
    const blackHole = {
      x: 0,
      y: 0,
      radius: 40,
      eventHorizon: 60,
      gravitationalPull: 800,
      rotationAngle: 0
    };

    // Player ship
    const player = {
      x: 0,
      y: 0,
      vx: 0,
      vy: 0,
      angle: 0,
      radius: 12,
      thrust: 400,
      boostMultiplier: 3,
      boosting: false,
      trail: []
    };

    // Particles and debris
    let particles = [];
    let debris = [];
    let energyOrbs = [];
    let accretionParticles = [];

    // Input
    const keys = { up: false, down: false, left: false, right: false, boost: false };

    document.addEventListener('keydown', e => {
      if (e.key === 'ArrowUp' || e.key === 'w' || e.key === 'W') keys.up = true;
      if (e.key === 'ArrowDown' || e.key === 's' || e.key === 'S') keys.down = true;
      if (e.key === 'ArrowLeft' || e.key === 'a' || e.key === 'A') keys.left = true;
      if (e.key === 'ArrowRight' || e.key === 'd' || e.key === 'D') keys.right = true;
      if (e.key === ' ') { keys.boost = true; e.preventDefault(); }
    });

    document.addEventListener('keyup', e => {
      if (e.key === 'ArrowUp' || e.key === 'w' || e.key === 'W') keys.up = false;
      if (e.key === 'ArrowDown' || e.key === 's' || e.key === 'S') keys.down = false;
      if (e.key === 'ArrowLeft' || e.key === 'a' || e.key === 'A') keys.left = false;
      if (e.key === 'ArrowRight' || e.key === 'd' || e.key === 'D') keys.right = false;
      if (e.key === ' ') keys.boost = false;
    });

    // Touch controls
    let touchStart = null;
    canvas.addEventListener('touchstart', e => {
      e.preventDefault();
      touchStart = { x: e.touches[0].clientX, y: e.touches[0].clientY };
      keys.boost = true;
    });

    canvas.addEventListener('touchmove', e => {
      e.preventDefault();
      if (touchStart) {
        const dx = e.touches[0].clientX - touchStart.x;
        const dy = e.touches[0].clientY - touchStart.y;
        keys.left = dx < -30;
        keys.right = dx > 30;
        keys.up = dy < -30;
        keys.down = dy > 30;
      }
    });

    canvas.addEventListener('touchend', e => {
      keys.up = keys.down = keys.left = keys.right = keys.boost = false;
      touchStart = null;
    });

    function initGame() {
      score = 0;
      energy = 100;

      blackHole.x = centerX;
      blackHole.y = centerY;

      // Start player in orbit
      const orbitRadius = Math.min(W, H) * 0.35;
      const angle = Math.random() * Math.PI * 2;
      player.x = centerX + Math.cos(angle) * orbitRadius;
      player.y = centerY + Math.sin(angle) * orbitRadius;

      // Initial orbital velocity
      const orbitalSpeed = Math.sqrt(blackHole.gravitationalPull / orbitRadius) * 0.7;
      player.vx = -Math.sin(angle) * orbitalSpeed;
      player.vy = Math.cos(angle) * orbitalSpeed;
      player.trail = [];

      particles = [];
      debris = [];
      energyOrbs = [];
      accretionParticles = [];

      // Create initial debris
      for (let i = 0; i < 30; i++) {
        spawnDebris();
      }

      // Create accretion disk particles
      for (let i = 0; i < 200; i++) {
        spawnAccretionParticle();
      }

      // Spawn initial energy orbs
      for (let i = 0; i < 5; i++) {
        spawnEnergyOrb();
      }

      updateUI();
    }

    function spawnDebris() {
      const angle = Math.random() * Math.PI * 2;
      const dist = 100 + Math.random() * Math.min(W, H) * 0.4;
      const orbitalSpeed = Math.sqrt(blackHole.gravitationalPull / dist) * (0.5 + Math.random() * 0.5);

      debris.push({
        x: centerX + Math.cos(angle) * dist,
        y: centerY + Math.sin(angle) * dist,
        vx: -Math.sin(angle) * orbitalSpeed,
        vy: Math.cos(angle) * orbitalSpeed,
        size: 2 + Math.random() * 6,
        color: Math.random() > 0.5 ? '#0ff' : '#f0f',
        alpha: 0.3 + Math.random() * 0.7
      });
    }

    function spawnAccretionParticle() {
      const angle = Math.random() * Math.PI * 2;
      const dist = blackHole.eventHorizon + 20 + Math.random() * 80;

      accretionParticles.push({
        angle: angle,
        dist: dist,
        speed: 0.5 + Math.random() * 2,
        size: 1 + Math.random() * 3,
        hue: Math.random() > 0.5 ? 180 : 300 // cyan or magenta
      });
    }

    function spawnEnergyOrb() {
      const angle = Math.random() * Math.PI * 2;
      const dist = 150 + Math.random() * Math.min(W, H) * 0.3;
      const orbitalSpeed = Math.sqrt(blackHole.gravitationalPull / dist) * 0.6;

      energyOrbs.push({
        x: centerX + Math.cos(angle) * dist,
        y: centerY + Math.sin(angle) * dist,
        vx: -Math.sin(angle) * orbitalSpeed,
        vy: Math.cos(angle) * orbitalSpeed,
        radius: 8,
        pulse: Math.random() * Math.PI * 2
      });
    }

    function spawnParticle(x, y, color, speed = 50) {
      const angle = Math.random() * Math.PI * 2;
      particles.push({
        x, y,
        vx: Math.cos(angle) * speed * Math.random(),
        vy: Math.sin(angle) * speed * Math.random(),
        life: 1,
        decay: 0.02 + Math.random() * 0.03,
        color,
        size: 2 + Math.random() * 3
      });
    }

    function applyGravity(obj, dt) {
      const dx = blackHole.x - obj.x;
      const dy = blackHole.y - obj.y;
      const dist = Math.sqrt(dx * dx + dy * dy);

      if (dist > 10) {
        const force = blackHole.gravitationalPull / (dist * dist) * 1000;
        const ax = (dx / dist) * force;
        const ay = (dy / dist) * force;
        obj.vx += ax * dt;
        obj.vy += ay * dt;
      }

      return dist;
    }

    function update(dt) {
      if (!gameRunning) return;

      // Update black hole rotation
      blackHole.rotationAngle += dt * 0.5;

      // Player input
      let thrustX = 0, thrustY = 0;
      if (keys.up) thrustY -= 1;
      if (keys.down) thrustY += 1;
      if (keys.left) thrustX -= 1;
      if (keys.right) thrustX += 1;

      // Normalize thrust
      const thrustMag = Math.sqrt(thrustX * thrustX + thrustY * thrustY);
      if (thrustMag > 0) {
        thrustX /= thrustMag;
        thrustY /= thrustMag;
      }

      // Apply thrust
      let thrustPower = player.thrust;
      player.boosting = keys.boost && energy > 0;

      if (player.boosting) {
        thrustPower *= player.boostMultiplier;
        energy = Math.max(0, energy - 30 * dt);
      } else {
        energy = Math.min(100, energy + 5 * dt);
      }

      player.vx += thrustX * thrustPower * dt;
      player.vy += thrustY * thrustPower * dt;

      // Apply gravity to player
      const playerDist = applyGravity(player, dt);

      // Update player position
      player.x += player.vx * dt;
      player.y += player.vy * dt;

      // Player trail
      player.trail.push({ x: player.x, y: player.y, alpha: 1 });
      if (player.trail.length > 30) player.trail.shift();
      player.trail.forEach(t => t.alpha -= dt * 2);
      player.trail = player.trail.filter(t => t.alpha > 0);

      // Update player angle based on velocity
      if (Math.abs(player.vx) > 1 || Math.abs(player.vy) > 1) {
        player.angle = Math.atan2(player.vy, player.vx);
      }

      // Check collision with black hole
      if (playerDist < blackHole.eventHorizon) {
        gameOver();
        return;
      }

      // Score based on proximity (closer = more points but more dangerous)
      const proximityBonus = Math.max(0, 300 - playerDist) / 300;
      score += Math.floor((10 + proximityBonus * 50) * dt);

      // Update debris
      debris.forEach(d => {
        const dist = applyGravity(d, dt);
        d.x += d.vx * dt;
        d.y += d.vy * dt;

        // Remove if consumed
        if (dist < blackHole.eventHorizon) {
          d.consumed = true;
          for (let i = 0; i < 5; i++) {
            spawnParticle(d.x, d.y, d.color, 30);
          }
        }
      });
      debris = debris.filter(d => !d.consumed);

      // Spawn new debris
      while (debris.length < 30) spawnDebris();

      // Update energy orbs
      energyOrbs.forEach(orb => {
        const dist = applyGravity(orb, dt);
        orb.x += orb.vx * dt;
        orb.y += orb.vy * dt;
        orb.pulse += dt * 5;

        // Check player collection
        const pdx = player.x - orb.x;
        const pdy = player.y - orb.y;
        const pDist = Math.sqrt(pdx * pdx + pdy * pdy);

        if (pDist < player.radius + orb.radius) {
          orb.collected = true;
          energy = Math.min(100, energy + 30);
          score += 500;
          for (let i = 0; i < 10; i++) {
            spawnParticle(orb.x, orb.y, '#0f0', 100);
          }
        }

        // Remove if consumed by black hole
        if (dist < blackHole.eventHorizon) {
          orb.collected = true;
        }
      });
      energyOrbs = energyOrbs.filter(o => !o.collected);

      // Spawn new orbs
      while (energyOrbs.length < 5) spawnEnergyOrb();

      // Update accretion disk
      accretionParticles.forEach(p => {
        p.angle += p.speed * dt;
        p.dist -= dt * 5;
        if (p.dist < blackHole.eventHorizon) {
          p.dist = blackHole.eventHorizon + 20 + Math.random() * 80;
          p.angle = Math.random() * Math.PI * 2;
        }
      });

      // Update particles
      particles.forEach(p => {
        applyGravity(p, dt * 0.5);
        p.x += p.vx * dt;
        p.y += p.vy * dt;
        p.life -= p.decay;
      });
      particles = particles.filter(p => p.life > 0);

      // Spawn thruster particles
      if (thrustMag > 0) {
        const backAngle = player.angle + Math.PI;
        spawnParticle(
          player.x + Math.cos(backAngle) * 10,
          player.y + Math.sin(backAngle) * 10,
          player.boosting ? '#f0f' : '#0ff',
          50
        );
      }

      updateUI();
    }

    function draw() {
      // Clear with fade effect
      ctx.fillStyle = 'rgba(0, 0, 0, 0.2)';
      ctx.fillRect(0, 0, W, H);

      // Draw starfield (static)
      ctx.fillStyle = '#fff';
      for (let i = 0; i < 100; i++) {
        const x = (i * 137.5) % W;
        const y = (i * 73.3) % H;
        const size = (i % 3) + 1;
        ctx.globalAlpha = 0.3 + (i % 5) * 0.1;
        ctx.fillRect(x, y, size, size);
      }
      ctx.globalAlpha = 1;

      // Draw accretion disk
      accretionParticles.forEach(p => {
        const x = blackHole.x + Math.cos(p.angle) * p.dist;
        const y = blackHole.y + Math.sin(p.angle) * p.dist * 0.3; // Elliptical
        const intensity = 1 - (p.dist - blackHole.eventHorizon) / 100;

        ctx.beginPath();
        ctx.arc(x, y, p.size, 0, Math.PI * 2);
        ctx.fillStyle = `hsla(${p.hue}, 100%, 60%, ${intensity * 0.8})`;
        ctx.shadowBlur = 10;
        ctx.shadowColor = `hsl(${p.hue}, 100%, 50%)`;
        ctx.fill();
      });
      ctx.shadowBlur = 0;

      // Draw gravitational lensing effect
      const gradient = ctx.createRadialGradient(
        blackHole.x, blackHole.y, blackHole.radius,
        blackHole.x, blackHole.y, blackHole.eventHorizon + 50
      );
      gradient.addColorStop(0, 'rgba(0, 0, 0, 1)');
      gradient.addColorStop(0.5, 'rgba(20, 0, 40, 0.8)');
      gradient.addColorStop(1, 'rgba(0, 0, 0, 0)');

      ctx.beginPath();
      ctx.arc(blackHole.x, blackHole.y, blackHole.eventHorizon + 50, 0, Math.PI * 2);
      ctx.fillStyle = gradient;
      ctx.fill();

      // Draw black hole core
      ctx.beginPath();
      ctx.arc(blackHole.x, blackHole.y, blackHole.radius, 0, Math.PI * 2);
      ctx.fillStyle = '#000';
      ctx.fill();

      // Event horizon glow
      ctx.beginPath();
      ctx.arc(blackHole.x, blackHole.y, blackHole.eventHorizon, 0, Math.PI * 2);
      ctx.strokeStyle = '#f0f';
      ctx.lineWidth = 2;
      ctx.shadowBlur = 20;
      ctx.shadowColor = '#f0f';
      ctx.stroke();
      ctx.shadowBlur = 0;

      // Draw vortex spiral
      ctx.save();
      ctx.translate(blackHole.x, blackHole.y);
      ctx.rotate(blackHole.rotationAngle);

      for (let i = 0; i < 4; i++) {
        ctx.beginPath();
        ctx.rotate(Math.PI / 2);
        for (let t = 0; t < Math.PI * 4; t += 0.1) {
          const r = blackHole.eventHorizon + t * 15;
          const x = Math.cos(t) * r;
          const y = Math.sin(t) * r * 0.3;
          if (t === 0) ctx.moveTo(x, y);
          else ctx.lineTo(x, y);
        }
        ctx.strokeStyle = `hsla(${180 + i * 30}, 100%, 50%, 0.3)`;
        ctx.lineWidth = 2;
        ctx.stroke();
      }
      ctx.restore();

      // Draw debris
      debris.forEach(d => {
        ctx.beginPath();
        ctx.arc(d.x, d.y, d.size, 0, Math.PI * 2);
        ctx.fillStyle = d.color;
        ctx.globalAlpha = d.alpha;
        ctx.shadowBlur = 5;
        ctx.shadowColor = d.color;
        ctx.fill();
      });
      ctx.globalAlpha = 1;
      ctx.shadowBlur = 0;

      // Draw energy orbs
      energyOrbs.forEach(orb => {
        const pulseSize = Math.sin(orb.pulse) * 3;

        ctx.beginPath();
        ctx.arc(orb.x, orb.y, orb.radius + pulseSize, 0, Math.PI * 2);
        ctx.fillStyle = '#0f0';
        ctx.shadowBlur = 20;
        ctx.shadowColor = '#0f0';
        ctx.fill();

        ctx.beginPath();
        ctx.arc(orb.x, orb.y, orb.radius / 2, 0, Math.PI * 2);
        ctx.fillStyle = '#fff';
        ctx.fill();
      });
      ctx.shadowBlur = 0;

      // Draw particles
      particles.forEach(p => {
        ctx.beginPath();
        ctx.arc(p.x, p.y, p.size * p.life, 0, Math.PI * 2);
        ctx.fillStyle = p.color;
        ctx.globalAlpha = p.life;
        ctx.fill();
      });
      ctx.globalAlpha = 1;

      // Draw player trail
      player.trail.forEach((t, i) => {
        ctx.beginPath();
        ctx.arc(t.x, t.y, 3, 0, Math.PI * 2);
        ctx.fillStyle = player.boosting ? '#f0f' : '#0ff';
        ctx.globalAlpha = t.alpha * 0.5;
        ctx.fill();
      });
      ctx.globalAlpha = 1;

      // Draw player ship
      ctx.save();
      ctx.translate(player.x, player.y);
      ctx.rotate(player.angle);

      // Ship body
      ctx.beginPath();
      ctx.moveTo(15, 0);
      ctx.lineTo(-10, -8);
      ctx.lineTo(-5, 0);
      ctx.lineTo(-10, 8);
      ctx.closePath();

      const shipColor = player.boosting ? '#f0f' : '#0ff';
      ctx.fillStyle = shipColor;
      ctx.shadowBlur = 15;
      ctx.shadowColor = shipColor;
      ctx.fill();
      ctx.strokeStyle = '#fff';
      ctx.lineWidth = 1;
      ctx.stroke();

      ctx.restore();
      ctx.shadowBlur = 0;
    }

    function updateUI() {
      document.getElementById('score').textContent = score;
      document.getElementById('energy-fill').style.width = energy + '%';
    }

    function gameOver() {
      gameRunning = false;
      document.getElementById('final-score').textContent = score;
      document.getElementById('game-over').style.display = 'block';
    }

    function startGame() {
      document.getElementById('start-screen').style.display = 'none';
      document.getElementById('game-over').style.display = 'none';
      initGame();
      gameRunning = true;
    }

    document.getElementById('start-btn').addEventListener('click', startGame);
    document.getElementById('restart-btn').addEventListener('click', startGame);

    // Game loop
    let lastTime = 0;
    function gameLoop(time) {
      const dt = Math.min((time - lastTime) / 1000, 0.05);
      lastTime = time;

      update(dt);
      draw();

      requestAnimationFrame(gameLoop);
    }

    // Initial draw
    draw();
    requestAnimationFrame(gameLoop);
  </script>
</body>
</html>
