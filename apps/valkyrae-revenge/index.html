<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
  <title>Valkyrae's Revenge - Arena Survival</title>
  <link rel="icon" href="https://emojicdn.elk.sh/⚔️">
  <meta property="og:title" content="Valkyrae's Revenge">
  <meta property="og:description" content="High-stakes arena survival. Fight the undead horde or die trying.">
  <meta property="og:url" content="https://sloppy.live/valkyrae-revenge">
  <meta property="og:image" content="https://sloppy.live/valkyrae-revenge/og-image.png">
  <link href="https://fonts.googleapis.com/css2?family=Cinzel:wght@400;700&family=Uncial+Antiqua&display=swap" rel="stylesheet">
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      background: #0a0a0f;
      overflow: hidden;
      font-family: 'Cinzel', serif;
      display: flex;
      justify-content: center;
      align-items: center;
      min-height: 100vh;
    }
    #game-container {
      position: relative;
      max-width: 900px;
      width: 100%;
    }
    canvas {
      display: block;
      width: 100%;
      border: 3px solid #c9a227;
      box-shadow: 0 0 50px rgba(201, 162, 39, 0.3), inset 0 0 100px rgba(0,0,0,0.8);
    }
    #ui {
      position: absolute;
      top: 10px;
      left: 10px;
      right: 10px;
      display: flex;
      justify-content: space-between;
      pointer-events: none;
      z-index: 10;
    }
    .stat-box {
      background: rgba(10, 10, 15, 0.9);
      border: 2px solid #c9a227;
      padding: 10px 20px;
      color: #c9a227;
    }
    .stat-label {
      font-size: 10px;
      letter-spacing: 2px;
      opacity: 0.7;
    }
    .stat-value {
      font-size: 24px;
      font-weight: 700;
      text-shadow: 0 0 10px rgba(201, 162, 39, 0.5);
    }
    #health-bar {
      position: absolute;
      bottom: 60px;
      left: 50%;
      transform: translateX(-50%);
      width: 300px;
      height: 20px;
      background: rgba(0,0,0,0.7);
      border: 2px solid #8b0000;
    }
    #health-fill {
      height: 100%;
      width: 100%;
      background: linear-gradient(90deg, #8b0000, #dc143c, #ff4500);
      transition: width 0.2s;
      box-shadow: 0 0 10px rgba(220, 20, 60, 0.5);
    }
    #combo {
      position: absolute;
      top: 80px;
      right: 20px;
      font-size: 36px;
      color: #ff6b00;
      text-shadow: 0 0 20px #ff6b00;
      opacity: 0;
      transition: opacity 0.2s;
    }
    #combo.show { opacity: 1; }
    #wave-alert {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      font-size: 48px;
      color: #c9a227;
      text-shadow: 0 0 30px rgba(201, 162, 39, 0.8);
      opacity: 0;
      pointer-events: none;
      font-family: 'Uncial Antiqua', cursive;
    }
    #wave-alert.show {
      animation: waveIn 2s forwards;
    }
    @keyframes waveIn {
      0% { opacity: 0; transform: translate(-50%, -50%) scale(0.5); }
      20% { opacity: 1; transform: translate(-50%, -50%) scale(1.2); }
      80% { opacity: 1; transform: translate(-50%, -50%) scale(1); }
      100% { opacity: 0; transform: translate(-50%, -50%) scale(0.8); }
    }
    #game-over {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: rgba(10, 10, 15, 0.98);
      border: 3px solid #8b0000;
      padding: 50px;
      text-align: center;
      display: none;
      z-index: 100;
    }
    #game-over h1 {
      font-family: 'Uncial Antiqua', cursive;
      font-size: 42px;
      color: #8b0000;
      margin-bottom: 20px;
      text-shadow: 0 0 20px rgba(139, 0, 0, 0.5);
    }
    #game-over .stats {
      color: #c9a227;
      margin: 30px 0;
      font-size: 18px;
    }
    #game-over .stats div {
      margin: 10px 0;
    }
    #restart-btn {
      background: linear-gradient(135deg, #8b0000, #dc143c);
      border: 2px solid #c9a227;
      color: #c9a227;
      padding: 15px 50px;
      font-family: 'Cinzel', serif;
      font-size: 18px;
      cursor: pointer;
      transition: all 0.3s;
    }
    #restart-btn:hover {
      transform: scale(1.05);
      box-shadow: 0 0 30px rgba(220, 20, 60, 0.5);
    }
    #start-screen {
      position: absolute;
      top: 0; left: 0; right: 0; bottom: 0;
      background: rgba(10, 10, 15, 0.95);
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      z-index: 200;
    }
    #start-screen h1 {
      font-family: 'Uncial Antiqua', cursive;
      font-size: 56px;
      color: #c9a227;
      text-shadow: 0 0 30px rgba(201, 162, 39, 0.6);
      margin-bottom: 10px;
    }
    #start-screen .subtitle {
      color: #8b7355;
      font-size: 18px;
      margin-bottom: 40px;
      letter-spacing: 4px;
    }
    #start-btn {
      background: linear-gradient(135deg, #1a1a2e, #2a2a4e);
      border: 3px solid #c9a227;
      color: #c9a227;
      padding: 20px 60px;
      font-family: 'Uncial Antiqua', cursive;
      font-size: 24px;
      cursor: pointer;
      transition: all 0.3s;
    }
    #start-btn:hover {
      background: linear-gradient(135deg, #c9a227, #ffd700);
      color: #0a0a0f;
      box-shadow: 0 0 40px rgba(201, 162, 39, 0.6);
    }
    .controls-hint {
      color: #5c4a3a;
      font-size: 12px;
      margin-top: 30px;
      text-align: center;
    }
    #mobile-controls {
      display: none;
      position: absolute;
      bottom: 10px;
      left: 10px;
      right: 10px;
      justify-content: space-between;
      z-index: 50;
    }
    .mobile-btn {
      width: 70px;
      height: 70px;
      background: rgba(201, 162, 39, 0.2);
      border: 2px solid #c9a227;
      border-radius: 50%;
      color: #c9a227;
      font-size: 24px;
    }
    .attack-btn {
      width: 90px;
      height: 90px;
      background: rgba(139, 0, 0, 0.3);
      border-color: #dc143c;
      color: #dc143c;
    }
    @media (max-width: 768px) {
      #mobile-controls { display: flex; }
    }
    #backlink {
      position: fixed;
      bottom: 10px;
      right: 10px;
      color: #5c4a3a;
      text-decoration: none;
      font-size: 11px;
      z-index: 300;
    }
  </style>
</head>
<body>
  <div id="game-container">
    <canvas id="game" width="900" height="600"></canvas>

    <div id="ui">
      <div class="stat-box">
        <div class="stat-label">SOULS</div>
        <div class="stat-value" id="score">0</div>
      </div>
      <div class="stat-box">
        <div class="stat-label">WAVE</div>
        <div class="stat-value" id="wave">1</div>
      </div>
      <div class="stat-box">
        <div class="stat-label">SLAIN</div>
        <div class="stat-value" id="kills">0</div>
      </div>
    </div>

    <div id="health-bar">
      <div id="health-fill"></div>
    </div>

    <div id="combo">x1</div>
    <div id="wave-alert">WAVE 1</div>

    <div id="start-screen">
      <h1>Valkyrae's Revenge</h1>
      <div class="subtitle">HIGH-STAKES ARENA SURVIVAL</div>
      <button id="start-btn">ENTER VALHALLA</button>
      <div class="controls-hint">
        WASD / Arrows to move • SPACE / Click to strike<br>
        Survive the horde. Collect souls. Embrace death.
      </div>
    </div>

    <div id="game-over">
      <h1>FALLEN IN BATTLE</h1>
      <div class="stats">
        <div>Souls Collected: <span id="final-score">0</span></div>
        <div>Waves Survived: <span id="final-wave">0</span></div>
        <div>Enemies Slain: <span id="final-kills">0</span></div>
        <div>Highest Combo: <span id="final-combo">0</span></div>
      </div>
      <button id="restart-btn">RISE AGAIN</button>
    </div>

    <div id="mobile-controls">
      <div style="display: flex; flex-direction: column; gap: 5px;">
        <button class="mobile-btn" id="up-btn">↑</button>
        <div style="display: flex; gap: 5px;">
          <button class="mobile-btn" id="left-btn">←</button>
          <button class="mobile-btn" id="right-btn">→</button>
        </div>
        <button class="mobile-btn" id="down-btn">↓</button>
      </div>
      <button class="mobile-btn attack-btn" id="attack-btn">⚔</button>
    </div>
  </div>

  <a id="backlink" href="https://sloppy.live">sloppy.live</a>

  <script>
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');
    const W = 900, H = 600;

    let gameRunning = false;
    let score = 0;
    let wave = 1;
    let kills = 0;
    let combo = 0;
    let maxCombo = 0;
    let comboTimer = 0;
    let waveEnemies = 0;
    let enemiesRemaining = 0;

    const keys = {};
    let mouseDown = false;
    let attackCooldown = 0;

    // Valkyrie
    const valkyrie = {
      x: W / 2,
      y: H / 2,
      radius: 20,
      speed: 5,
      health: 100,
      maxHealth: 100,
      angle: 0,
      attacking: false,
      attackFrame: 0,
      invincible: 0,
      wingPhase: 0
    };

    let enemies = [];
    let particles = [];
    let souls = [];
    let powerups = [];
    let bloodSplats = [];

    // Enemy types
    const ENEMY_TYPES = {
      draugr: { health: 30, speed: 1.5, damage: 10, size: 18, color: '#2a4a3a', souls: 10 },
      berserker: { health: 60, speed: 2.5, damage: 20, size: 22, color: '#4a2a2a', souls: 25 },
      wraith: { health: 20, speed: 3, damage: 15, size: 15, color: '#3a3a5a', souls: 15 },
      jotun: { health: 150, speed: 0.8, damage: 35, size: 35, color: '#1a3a4a', souls: 50 }
    };

    function spawnWave() {
      const waveAlert = document.getElementById('wave-alert');
      waveAlert.textContent = `WAVE ${wave}`;
      waveAlert.classList.add('show');
      setTimeout(() => waveAlert.classList.remove('show'), 2000);

      const baseEnemies = 3 + wave * 2;
      waveEnemies = baseEnemies;
      enemiesRemaining = baseEnemies;

      for (let i = 0; i < baseEnemies; i++) {
        setTimeout(() => spawnEnemy(), i * 500);
      }

      // Boss every 5 waves
      if (wave % 5 === 0) {
        setTimeout(() => {
          spawnEnemy('jotun');
          enemiesRemaining++;
        }, baseEnemies * 500);
      }
    }

    function spawnEnemy(type = null) {
      if (!type) {
        const roll = Math.random();
        if (roll < 0.5) type = 'draugr';
        else if (roll < 0.75) type = 'berserker';
        else type = 'wraith';
      }

      const template = ENEMY_TYPES[type];
      const side = Math.floor(Math.random() * 4);
      let x, y;

      switch(side) {
        case 0: x = Math.random() * W; y = -30; break;
        case 1: x = W + 30; y = Math.random() * H; break;
        case 2: x = Math.random() * W; y = H + 30; break;
        case 3: x = -30; y = Math.random() * H; break;
      }

      enemies.push({
        x, y,
        type,
        health: template.health * (1 + wave * 0.1),
        maxHealth: template.health * (1 + wave * 0.1),
        speed: template.speed,
        damage: template.damage,
        size: template.size,
        color: template.color,
        souls: template.souls,
        angle: 0,
        hitFlash: 0
      });
    }

    function createParticles(x, y, color, count, speed = 5) {
      for (let i = 0; i < count; i++) {
        const angle = Math.random() * Math.PI * 2;
        const spd = speed * (0.5 + Math.random());
        particles.push({
          x, y,
          vx: Math.cos(angle) * spd,
          vy: Math.sin(angle) * spd,
          color,
          size: 2 + Math.random() * 4,
          life: 1
        });
      }
    }

    function createBloodSplat(x, y) {
      bloodSplats.push({
        x, y,
        size: 10 + Math.random() * 20,
        alpha: 0.6
      });
      if (bloodSplats.length > 50) bloodSplats.shift();
    }

    function spawnSoul(x, y, value) {
      souls.push({
        x, y,
        value,
        vy: -2,
        life: 3,
        collected: false
      });
    }

    function spawnPowerup(x, y) {
      if (Math.random() > 0.15) return;
      const types = ['health', 'speed', 'damage'];
      powerups.push({
        x, y,
        type: types[Math.floor(Math.random() * types.length)],
        life: 10
      });
    }

    function attack() {
      if (attackCooldown > 0 || !gameRunning) return;

      valkyrie.attacking = true;
      valkyrie.attackFrame = 0;
      attackCooldown = 20;

      // Check hits
      const attackRange = 60;
      const attackAngle = Math.PI / 2;

      enemies.forEach(enemy => {
        const dx = enemy.x - valkyrie.x;
        const dy = enemy.y - valkyrie.y;
        const dist = Math.sqrt(dx * dx + dy * dy);
        const angle = Math.atan2(dy, dx);
        const angleDiff = Math.abs(angle - valkyrie.angle);

        if (dist < attackRange + enemy.size &&
            (angleDiff < attackAngle / 2 || angleDiff > Math.PI * 2 - attackAngle / 2)) {
          const damage = 25 * (1 + combo * 0.1);
          enemy.health -= damage;
          enemy.hitFlash = 1;

          createParticles(enemy.x, enemy.y, '#8b0000', 8);
          createBloodSplat(enemy.x, enemy.y);

          // Knockback
          const knockback = 10;
          enemy.x += Math.cos(valkyrie.angle) * knockback;
          enemy.y += Math.sin(valkyrie.angle) * knockback;

          if (enemy.health <= 0) {
            kills++;
            combo++;
            comboTimer = 120;
            maxCombo = Math.max(maxCombo, combo);

            spawnSoul(enemy.x, enemy.y, enemy.souls * (1 + combo * 0.1));
            spawnPowerup(enemy.x, enemy.y);
            createParticles(enemy.x, enemy.y, enemy.color, 15);

            enemiesRemaining--;
          }
        }
      });

      enemies = enemies.filter(e => e.health > 0);
    }

    function update() {
      if (!gameRunning) return;

      // Movement
      let dx = 0, dy = 0;
      if (keys['KeyW'] || keys['ArrowUp']) dy -= 1;
      if (keys['KeyS'] || keys['ArrowDown']) dy += 1;
      if (keys['KeyA'] || keys['ArrowLeft']) dx -= 1;
      if (keys['KeyD'] || keys['ArrowRight']) dx += 1;

      if (dx !== 0 || dy !== 0) {
        const len = Math.sqrt(dx * dx + dy * dy);
        dx /= len; dy /= len;
        valkyrie.x += dx * valkyrie.speed;
        valkyrie.y += dy * valkyrie.speed;
        valkyrie.angle = Math.atan2(dy, dx);
      }

      // Bounds
      valkyrie.x = Math.max(valkyrie.radius, Math.min(W - valkyrie.radius, valkyrie.x));
      valkyrie.y = Math.max(valkyrie.radius, Math.min(H - valkyrie.radius, valkyrie.y));

      // Wing animation
      valkyrie.wingPhase += 0.15;

      // Attack cooldown
      if (attackCooldown > 0) attackCooldown--;
      if (valkyrie.attacking) {
        valkyrie.attackFrame++;
        if (valkyrie.attackFrame > 15) valkyrie.attacking = false;
      }

      // Invincibility
      if (valkyrie.invincible > 0) valkyrie.invincible--;

      // Combo timer
      if (comboTimer > 0) {
        comboTimer--;
        if (comboTimer <= 0) combo = 0;
      }

      // Update enemies
      enemies.forEach(enemy => {
        const dx = valkyrie.x - enemy.x;
        const dy = valkyrie.y - enemy.y;
        const dist = Math.sqrt(dx * dx + dy * dy);

        if (dist > 0) {
          enemy.x += (dx / dist) * enemy.speed;
          enemy.y += (dy / dist) * enemy.speed;
          enemy.angle = Math.atan2(dy, dx);
        }

        if (enemy.hitFlash > 0) enemy.hitFlash -= 0.1;

        // Damage player
        if (dist < valkyrie.radius + enemy.size && valkyrie.invincible <= 0) {
          valkyrie.health -= enemy.damage;
          valkyrie.invincible = 60;
          createParticles(valkyrie.x, valkyrie.y, '#c9a227', 10);

          // Knockback
          const kb = 20;
          valkyrie.x -= (dx / dist) * kb;
          valkyrie.y -= (dy / dist) * kb;

          if (valkyrie.health <= 0) {
            gameOver();
          }
        }
      });

      // Update particles
      particles = particles.filter(p => {
        p.x += p.vx;
        p.y += p.vy;
        p.vy += 0.1;
        p.life -= 0.03;
        return p.life > 0;
      });

      // Update souls
      souls.forEach(soul => {
        soul.vy *= 0.95;
        soul.y += soul.vy;
        soul.life -= 0.016;

        const dx = valkyrie.x - soul.x;
        const dy = valkyrie.y - soul.y;
        const dist = Math.sqrt(dx * dx + dy * dy);

        if (dist < 50 && !soul.collected) {
          soul.collected = true;
          score += Math.floor(soul.value);
          createParticles(soul.x, soul.y, '#c9a227', 5, 3);
        }
      });
      souls = souls.filter(s => s.life > 0 && !s.collected);

      // Update powerups
      powerups.forEach(p => {
        p.life -= 0.016;
        const dx = valkyrie.x - p.x;
        const dy = valkyrie.y - p.y;
        if (Math.sqrt(dx * dx + dy * dy) < 30) {
          switch(p.type) {
            case 'health':
              valkyrie.health = Math.min(valkyrie.maxHealth, valkyrie.health + 30);
              break;
            case 'speed':
              valkyrie.speed = Math.min(8, valkyrie.speed + 0.5);
              setTimeout(() => valkyrie.speed = Math.max(5, valkyrie.speed - 0.5), 5000);
              break;
            case 'damage':
              // Handled in attack
              break;
          }
          p.life = 0;
          createParticles(p.x, p.y, '#ffd700', 10);
        }
      });
      powerups = powerups.filter(p => p.life > 0);

      // Fade blood splats
      bloodSplats.forEach(b => b.alpha *= 0.998);
      bloodSplats = bloodSplats.filter(b => b.alpha > 0.05);

      // Check wave complete
      if (enemiesRemaining <= 0 && enemies.length === 0) {
        wave++;
        setTimeout(() => spawnWave(), 2000);
        enemiesRemaining = -1; // Prevent multiple triggers
      }

      updateUI();
    }

    function draw() {
      // Background
      const grad = ctx.createRadialGradient(W/2, H/2, 0, W/2, H/2, W);
      grad.addColorStop(0, '#1a1a25');
      grad.addColorStop(1, '#0a0a0f');
      ctx.fillStyle = grad;
      ctx.fillRect(0, 0, W, H);

      // Arena circle
      ctx.strokeStyle = 'rgba(201, 162, 39, 0.1)';
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.arc(W/2, H/2, 250, 0, Math.PI * 2);
      ctx.stroke();

      // Rune marks
      ctx.font = '20px serif';
      ctx.fillStyle = 'rgba(201, 162, 39, 0.1)';
      const runes = 'ᚠᚢᚦᚨᚱᚲᚷᚹᚺᚾᛁᛃᛇᛈᛉᛊᛏᛒᛖᛗᛚᛝᛟᛞ';
      for (let i = 0; i < 12; i++) {
        const angle = (i / 12) * Math.PI * 2;
        const x = W/2 + Math.cos(angle) * 270;
        const y = H/2 + Math.sin(angle) * 270;
        ctx.fillText(runes[i % runes.length], x, y);
      }

      // Blood splats
      bloodSplats.forEach(b => {
        ctx.fillStyle = `rgba(100, 20, 20, ${b.alpha})`;
        ctx.beginPath();
        ctx.arc(b.x, b.y, b.size, 0, Math.PI * 2);
        ctx.fill();
      });

      // Souls
      souls.forEach(soul => {
        ctx.save();
        ctx.translate(soul.x, soul.y);
        ctx.globalAlpha = soul.life / 3;

        ctx.fillStyle = '#c9a227';
        ctx.shadowColor = '#c9a227';
        ctx.shadowBlur = 15;
        ctx.beginPath();
        ctx.arc(0, 0, 8, 0, Math.PI * 2);
        ctx.fill();

        ctx.fillStyle = '#fff';
        ctx.beginPath();
        ctx.arc(-2, -2, 3, 0, Math.PI * 2);
        ctx.fill();

        ctx.restore();
      });

      // Powerups
      powerups.forEach(p => {
        ctx.save();
        ctx.translate(p.x, p.y);
        ctx.rotate(Date.now() * 0.003);

        const colors = { health: '#dc143c', speed: '#00bfff', damage: '#ff6b00' };
        ctx.fillStyle = colors[p.type];
        ctx.shadowColor = colors[p.type];
        ctx.shadowBlur = 15;

        // Diamond shape
        ctx.beginPath();
        ctx.moveTo(0, -12);
        ctx.lineTo(10, 0);
        ctx.lineTo(0, 12);
        ctx.lineTo(-10, 0);
        ctx.closePath();
        ctx.fill();

        ctx.restore();
      });

      // Enemies
      enemies.forEach(enemy => {
        ctx.save();
        ctx.translate(enemy.x, enemy.y);
        ctx.rotate(enemy.angle);

        // Flash on hit
        if (enemy.hitFlash > 0) {
          ctx.fillStyle = '#fff';
        } else {
          ctx.fillStyle = enemy.color;
        }

        ctx.shadowColor = enemy.color;
        ctx.shadowBlur = 10;

        // Body
        ctx.beginPath();
        ctx.arc(0, 0, enemy.size, 0, Math.PI * 2);
        ctx.fill();

        // Eyes
        ctx.fillStyle = enemy.type === 'wraith' ? '#6a6aff' : '#ff0000';
        ctx.beginPath();
        ctx.arc(enemy.size * 0.3, -enemy.size * 0.3, 3, 0, Math.PI * 2);
        ctx.arc(enemy.size * 0.3, enemy.size * 0.3, 3, 0, Math.PI * 2);
        ctx.fill();

        // Health bar
        if (enemy.health < enemy.maxHealth) {
          ctx.fillStyle = '#300';
          ctx.fillRect(-enemy.size, -enemy.size - 8, enemy.size * 2, 4);
          ctx.fillStyle = '#f00';
          ctx.fillRect(-enemy.size, -enemy.size - 8, enemy.size * 2 * (enemy.health / enemy.maxHealth), 4);
        }

        ctx.restore();
      });

      // Valkyrie
      ctx.save();
      ctx.translate(valkyrie.x, valkyrie.y);

      // Invincibility flash
      if (valkyrie.invincible > 0 && Math.floor(valkyrie.invincible / 5) % 2 === 0) {
        ctx.globalAlpha = 0.5;
      }

      // Wings
      ctx.fillStyle = '#c9a227';
      ctx.shadowColor = '#c9a227';
      ctx.shadowBlur = 20;

      const wingSpread = Math.sin(valkyrie.wingPhase) * 0.3 + 0.5;

      // Left wing
      ctx.save();
      ctx.rotate(-Math.PI / 2 - wingSpread);
      ctx.beginPath();
      ctx.moveTo(0, 0);
      ctx.quadraticCurveTo(-30, -20, -40, 0);
      ctx.quadraticCurveTo(-30, 10, 0, 0);
      ctx.fill();
      ctx.restore();

      // Right wing
      ctx.save();
      ctx.rotate(-Math.PI / 2 + wingSpread);
      ctx.beginPath();
      ctx.moveTo(0, 0);
      ctx.quadraticCurveTo(30, -20, 40, 0);
      ctx.quadraticCurveTo(30, 10, 0, 0);
      ctx.fill();
      ctx.restore();

      // Body
      ctx.fillStyle = '#d4af37';
      ctx.beginPath();
      ctx.arc(0, 0, valkyrie.radius, 0, Math.PI * 2);
      ctx.fill();

      // Armor details
      ctx.strokeStyle = '#8b7355';
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.arc(0, 0, valkyrie.radius - 5, 0, Math.PI * 2);
      ctx.stroke();

      // Direction indicator / Spear
      ctx.save();
      ctx.rotate(valkyrie.angle);

      ctx.fillStyle = '#8b7355';
      if (valkyrie.attacking) {
        // Attack swing
        const swingAngle = Math.sin(valkyrie.attackFrame / 15 * Math.PI) * 0.5;
        ctx.rotate(swingAngle);
        ctx.fillRect(valkyrie.radius - 5, -3, 50, 6);

        // Spear tip
        ctx.fillStyle = '#c9a227';
        ctx.beginPath();
        ctx.moveTo(valkyrie.radius + 45, 0);
        ctx.lineTo(valkyrie.radius + 60, -8);
        ctx.lineTo(valkyrie.radius + 60, 8);
        ctx.closePath();
        ctx.fill();
      } else {
        ctx.fillRect(valkyrie.radius - 5, -2, 40, 4);
        ctx.fillStyle = '#c9a227';
        ctx.beginPath();
        ctx.moveTo(valkyrie.radius + 35, 0);
        ctx.lineTo(valkyrie.radius + 50, -6);
        ctx.lineTo(valkyrie.radius + 50, 6);
        ctx.closePath();
        ctx.fill();
      }
      ctx.restore();

      // Helmet
      ctx.fillStyle = '#c9a227';
      ctx.beginPath();
      ctx.arc(0, -5, 8, Math.PI, 0);
      ctx.fill();

      ctx.restore();

      // Particles
      particles.forEach(p => {
        ctx.globalAlpha = p.life;
        ctx.fillStyle = p.color;
        ctx.beginPath();
        ctx.arc(p.x, p.y, p.size * p.life, 0, Math.PI * 2);
        ctx.fill();
      });
      ctx.globalAlpha = 1;
    }

    function updateUI() {
      document.getElementById('score').textContent = score;
      document.getElementById('wave').textContent = wave;
      document.getElementById('kills').textContent = kills;
      document.getElementById('health-fill').style.width = (valkyrie.health / valkyrie.maxHealth * 100) + '%';

      const comboEl = document.getElementById('combo');
      if (combo > 1) {
        comboEl.textContent = `x${combo}`;
        comboEl.classList.add('show');
      } else {
        comboEl.classList.remove('show');
      }
    }

    function gameOver() {
      gameRunning = false;
      document.getElementById('final-score').textContent = score;
      document.getElementById('final-wave').textContent = wave;
      document.getElementById('final-kills').textContent = kills;
      document.getElementById('final-combo').textContent = maxCombo;
      document.getElementById('game-over').style.display = 'block';
    }

    function startGame() {
      document.getElementById('start-screen').style.display = 'none';
      document.getElementById('game-over').style.display = 'none';

      valkyrie.x = W / 2;
      valkyrie.y = H / 2;
      valkyrie.health = valkyrie.maxHealth;
      valkyrie.speed = 5;

      score = 0;
      wave = 1;
      kills = 0;
      combo = 0;
      maxCombo = 0;

      enemies = [];
      particles = [];
      souls = [];
      powerups = [];
      bloodSplats = [];

      gameRunning = true;
      spawnWave();
    }

    function gameLoop() {
      update();
      draw();
      requestAnimationFrame(gameLoop);
    }

    // Controls
    document.addEventListener('keydown', e => {
      keys[e.code] = true;
      if (e.code === 'Space') {
        e.preventDefault();
        attack();
      }
    });
    document.addEventListener('keyup', e => keys[e.code] = false);

    canvas.addEventListener('click', () => {
      if (gameRunning) attack();
    });

    canvas.addEventListener('mousemove', e => {
      if (!gameRunning) return;
      const rect = canvas.getBoundingClientRect();
      const scaleX = W / rect.width;
      const scaleY = H / rect.height;
      const mx = (e.clientX - rect.left) * scaleX;
      const my = (e.clientY - rect.top) * scaleY;
      valkyrie.angle = Math.atan2(my - valkyrie.y, mx - valkyrie.x);
    });

    // Mobile controls
    ['up', 'down', 'left', 'right'].forEach(dir => {
      const btn = document.getElementById(`${dir}-btn`);
      if (btn) {
        btn.addEventListener('touchstart', e => {
          e.preventDefault();
          const keyMap = { up: 'KeyW', down: 'KeyS', left: 'KeyA', right: 'KeyD' };
          keys[keyMap[dir]] = true;
        });
        btn.addEventListener('touchend', e => {
          e.preventDefault();
          const keyMap = { up: 'KeyW', down: 'KeyS', left: 'KeyA', right: 'KeyD' };
          keys[keyMap[dir]] = false;
        });
      }
    });

    document.getElementById('attack-btn')?.addEventListener('touchstart', e => {
      e.preventDefault();
      attack();
    });

    document.getElementById('start-btn').addEventListener('click', startGame);
    document.getElementById('restart-btn').addEventListener('click', startGame);

    gameLoop();
  </script>
<script src="/sloppy-header/sloppy-bar.js"></script>
</body>
</html>
