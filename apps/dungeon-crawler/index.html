<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Dungeon Crawler - Retro First Person Adventure</title>
  <meta name="description" content="A retro first-person dungeon crawler with grid movement">
  <meta property="og:title" content="Dungeon Crawler">
  <meta property="og:description" content="Explore pixelated dungeons and battle monsters">
  <meta property="og:url" content="https://sloppy.live/dungeon-crawler">
  <meta property="og:image" content="https://sloppy.live/dungeon-crawler/og-image.png">
  <link rel="icon" href="https://emojicdn.elk.sh/üó°Ô∏è">
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      min-height: 100vh;
      background: #0a0a0a;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      font-family: monospace;
      color: #aaa;
      overflow: hidden;
    }

    .game-container {
      position: relative;
      background: #111;
      border: 4px solid #333;
      border-radius: 8px;
      overflow: hidden;
    }

    .viewport {
      width: 400px;
      height: 300px;
      position: relative;
      background: #000;
      image-rendering: pixelated;
    }

    canvas {
      display: block;
      width: 100%;
      height: 100%;
      image-rendering: pixelated;
    }

    .scanlines {
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: repeating-linear-gradient(
        0deg,
        transparent,
        transparent 2px,
        rgba(0, 0, 0, 0.2) 2px,
        rgba(0, 0, 0, 0.2) 4px
      );
      pointer-events: none;
    }

    .hud {
      display: flex;
      justify-content: space-between;
      padding: 10px 15px;
      background: #1a1a1a;
      border-top: 2px solid #333;
    }

    .stat {
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .stat-icon {
      font-size: 16px;
    }

    .stat-bar {
      width: 80px;
      height: 12px;
      background: #333;
      border: 1px solid #555;
    }

    .stat-fill {
      height: 100%;
      transition: width 0.3s;
    }

    .health-fill {
      background: linear-gradient(180deg, #f44, #a00);
    }

    .xp-fill {
      background: linear-gradient(180deg, #4f4, #0a0);
    }

    .stat-text {
      font-size: 11px;
      min-width: 50px;
    }

    .controls {
      display: grid;
      grid-template-columns: repeat(3, 50px);
      gap: 5px;
      padding: 15px;
      background: #1a1a1a;
      justify-content: center;
    }

    .ctrl-btn {
      width: 50px;
      height: 40px;
      background: #2a2a2a;
      border: 2px solid #444;
      border-radius: 4px;
      color: #888;
      font-size: 18px;
      cursor: pointer;
      transition: all 0.1s;
    }

    .ctrl-btn:hover {
      background: #3a3a3a;
      border-color: #666;
    }

    .ctrl-btn:active {
      background: #444;
      transform: scale(0.95);
    }

    .ctrl-btn.attack {
      background: #422;
      border-color: #744;
      color: #f88;
    }

    .ctrl-btn.attack:hover {
      background: #533;
    }

    .message {
      position: absolute;
      bottom: 10px;
      left: 10px;
      right: 10px;
      padding: 8px;
      background: rgba(0, 0, 0, 0.8);
      border: 1px solid #444;
      font-size: 11px;
      color: #8f8;
      text-align: center;
    }

    .compass {
      position: absolute;
      top: 10px;
      right: 10px;
      width: 40px;
      height: 40px;
      background: rgba(0, 0, 0, 0.7);
      border: 1px solid #444;
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 14px;
      color: #f84;
    }

    .level-display {
      position: absolute;
      top: 10px;
      left: 10px;
      padding: 5px 10px;
      background: rgba(0, 0, 0, 0.7);
      border: 1px solid #444;
      font-size: 11px;
    }

    .monster-popup {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      padding: 20px;
      background: rgba(20, 0, 0, 0.95);
      border: 2px solid #a00;
      text-align: center;
      display: none;
    }

    .monster-popup.active {
      display: block;
    }

    .monster-name {
      color: #f66;
      font-size: 14px;
      margin-bottom: 10px;
    }

    .monster-sprite {
      font-size: 48px;
      margin: 10px 0;
      animation: monsterBob 0.5s ease infinite alternate;
    }

    @keyframes monsterBob {
      from { transform: translateY(-3px); }
      to { transform: translateY(3px); }
    }

    .monster-hp {
      font-size: 11px;
      color: #888;
    }

    .game-over {
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0, 0, 0, 0.9);
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      display: none;
    }

    .game-over.active {
      display: flex;
    }

    .game-over h2 {
      color: #f44;
      font-size: 24px;
      margin-bottom: 10px;
    }

    .game-over p {
      margin-bottom: 20px;
    }

    .restart-btn {
      padding: 10px 30px;
      background: #333;
      border: 2px solid #666;
      color: #aaa;
      font-family: monospace;
      font-size: 14px;
      cursor: pointer;
    }

    .restart-btn:hover {
      background: #444;
      border-color: #888;
    }

    .back-link {
      margin-top: 15px;
      color: #555;
      text-decoration: none;
      font-size: 11px;
    }

    .back-link:hover {
      color: #888;
    }

    @media (max-width: 450px) {
      .viewport {
        width: 320px;
        height: 240px;
      }
    }
  </style>
</head>
<body>
  <div class="game-container">
    <div class="viewport">
      <canvas id="game"></canvas>
      <div class="scanlines"></div>
      <div class="compass" id="compass">N</div>
      <div class="level-display">Floor <span id="floor">1</span></div>
      <div class="message" id="message">Use WASD or arrows to move. Find the exit!</div>

      <div class="monster-popup" id="monsterPopup">
        <div class="monster-name" id="monsterName">Goblin</div>
        <div class="monster-sprite" id="monsterSprite">üëπ</div>
        <div class="monster-hp">HP: <span id="monsterHp">10</span></div>
      </div>

      <div class="game-over" id="gameOver">
        <h2>GAME OVER</h2>
        <p>You reached floor <span id="finalFloor">1</span></p>
        <button class="restart-btn" onclick="restartGame()">RESTART</button>
      </div>
    </div>

    <div class="hud">
      <div class="stat">
        <span class="stat-icon">‚ù§Ô∏è</span>
        <div class="stat-bar">
          <div class="stat-fill health-fill" id="healthBar" style="width: 100%"></div>
        </div>
        <span class="stat-text"><span id="hp">20</span>/20</span>
      </div>
      <div class="stat">
        <span class="stat-icon">‚≠ê</span>
        <div class="stat-bar">
          <div class="stat-fill xp-fill" id="xpBar" style="width: 0%"></div>
        </div>
        <span class="stat-text">Lv <span id="level">1</span></span>
      </div>
    </div>

    <div class="controls">
      <div></div>
      <button class="ctrl-btn" onclick="move('forward')">‚Üë</button>
      <div></div>
      <button class="ctrl-btn" onclick="move('left')">‚Üê</button>
      <button class="ctrl-btn attack" onclick="attack()">‚öîÔ∏è</button>
      <button class="ctrl-btn" onclick="move('right')">‚Üí</button>
      <div></div>
      <button class="ctrl-btn" onclick="move('backward')">‚Üì</button>
      <div></div>
    </div>
  </div>

  <a href="https://sloppy.live" class="back-link">sloppy.live</a>

  <script>
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');

    canvas.width = 400;
    canvas.height = 300;

    // Game state
    let player = { x: 1, y: 1, dir: 0, hp: 20, maxHp: 20, xp: 0, level: 1 };
    let currentFloor = 1;
    let inCombat = false;
    let currentMonster = null;

    // Directions: 0=N, 1=E, 2=S, 3=W
    const dirs = ['N', 'E', 'S', 'W'];
    const dx = [0, 1, 0, -1];
    const dy = [-1, 0, 1, 0];

    // Map (0=floor, 1=wall, 2=exit, 3=monster, 4=potion)
    let map = [];
    const mapSize = 12;

    // Monsters
    const monsterTypes = [
      { name: 'Rat', sprite: 'üêÄ', hp: 5, atk: 2, xp: 5 },
      { name: 'Goblin', sprite: 'üë∫', hp: 10, atk: 4, xp: 10 },
      { name: 'Skeleton', sprite: 'üíÄ', hp: 15, atk: 6, xp: 15 },
      { name: 'Orc', sprite: 'üëπ', hp: 20, atk: 8, xp: 25 },
      { name: 'Demon', sprite: 'üëø', hp: 30, atk: 12, xp: 40 },
    ];

    // Colors
    const colors = {
      ceiling: '#1a1a2e',
      floor: '#2d2d44',
      wallFar: '#3d3d5c',
      wallMid: '#4d4d6c',
      wallNear: '#5d5d7c',
      wallSide: '#2d2d44',
      exit: '#4a4',
      monster: '#a44',
      potion: '#44a'
    };

    function generateMap() {
      map = [];
      for (let y = 0; y < mapSize; y++) {
        map[y] = [];
        for (let x = 0; x < mapSize; x++) {
          if (x === 0 || y === 0 || x === mapSize-1 || y === mapSize-1) {
            map[y][x] = 1; // Border walls
          } else {
            map[y][x] = Math.random() > 0.7 ? 1 : 0;
          }
        }
      }

      // Clear starting area
      map[1][1] = 0;
      map[1][2] = 0;
      map[2][1] = 0;

      // Place exit
      let exitPlaced = false;
      while (!exitPlaced) {
        const ex = Math.floor(Math.random() * (mapSize - 4)) + 2;
        const ey = Math.floor(Math.random() * (mapSize - 4)) + 2;
        if (map[ey][ex] === 0 && (ex > 4 || ey > 4)) {
          map[ey][ex] = 2;
          exitPlaced = true;
        }
      }

      // Place monsters
      const numMonsters = 3 + currentFloor;
      for (let i = 0; i < numMonsters; i++) {
        let placed = false;
        while (!placed) {
          const mx = Math.floor(Math.random() * (mapSize - 2)) + 1;
          const my = Math.floor(Math.random() * (mapSize - 2)) + 1;
          if (map[my][mx] === 0 && (mx > 2 || my > 2)) {
            map[my][mx] = 3;
            placed = true;
          }
        }
      }

      // Place potions
      const numPotions = 2;
      for (let i = 0; i < numPotions; i++) {
        let placed = false;
        while (!placed) {
          const px = Math.floor(Math.random() * (mapSize - 2)) + 1;
          const py = Math.floor(Math.random() * (mapSize - 2)) + 1;
          if (map[py][px] === 0) {
            map[py][px] = 4;
            placed = true;
          }
        }
      }

      player.x = 1;
      player.y = 1;
      player.dir = 0;
    }

    function getTile(x, y) {
      if (x < 0 || y < 0 || x >= mapSize || y >= mapSize) return 1;
      return map[y][x];
    }

    function canMove(x, y) {
      const tile = getTile(x, y);
      return tile !== 1;
    }

    function move(direction) {
      if (inCombat) return;

      let newX = player.x;
      let newY = player.y;

      if (direction === 'forward') {
        newX += dx[player.dir];
        newY += dy[player.dir];
      } else if (direction === 'backward') {
        newX -= dx[player.dir];
        newY -= dy[player.dir];
      } else if (direction === 'left') {
        player.dir = (player.dir + 3) % 4;
        updateCompass();
        render();
        return;
      } else if (direction === 'right') {
        player.dir = (player.dir + 1) % 4;
        updateCompass();
        render();
        return;
      }

      if (canMove(newX, newY)) {
        player.x = newX;
        player.y = newY;

        const tile = getTile(newX, newY);

        if (tile === 2) {
          // Exit - next floor
          currentFloor++;
          showMessage('Descending to floor ' + currentFloor + '...');
          document.getElementById('floor').textContent = currentFloor;
          generateMap();
        } else if (tile === 3) {
          // Monster!
          startCombat();
        } else if (tile === 4) {
          // Potion
          const heal = 10;
          player.hp = Math.min(player.maxHp, player.hp + heal);
          map[newY][newX] = 0;
          showMessage('Found a potion! +' + heal + ' HP');
          updateHUD();
        }
      } else {
        showMessage("Can't go that way.");
      }

      render();
    }

    function startCombat() {
      inCombat = true;
      const typeIndex = Math.min(Math.floor(currentFloor / 2), monsterTypes.length - 1);
      const type = monsterTypes[typeIndex];
      currentMonster = {
        ...type,
        currentHp: type.hp + currentFloor * 2
      };

      document.getElementById('monsterName').textContent = currentMonster.name;
      document.getElementById('monsterSprite').textContent = currentMonster.sprite;
      document.getElementById('monsterHp').textContent = currentMonster.currentHp;
      document.getElementById('monsterPopup').classList.add('active');

      showMessage('A ' + currentMonster.name + ' attacks!');
    }

    function attack() {
      if (!inCombat || !currentMonster) return;

      // Player attacks
      const playerDmg = 5 + player.level * 2 + Math.floor(Math.random() * 3);
      currentMonster.currentHp -= playerDmg;
      showMessage('You deal ' + playerDmg + ' damage!');

      document.getElementById('monsterHp').textContent = Math.max(0, currentMonster.currentHp);

      if (currentMonster.currentHp <= 0) {
        // Victory!
        inCombat = false;
        document.getElementById('monsterPopup').classList.remove('active');
        map[player.y][player.x] = 0;

        player.xp += currentMonster.xp;
        showMessage('Defeated ' + currentMonster.name + '! +' + currentMonster.xp + ' XP');

        // Level up check
        const xpNeeded = player.level * 30;
        if (player.xp >= xpNeeded) {
          player.level++;
          player.xp -= xpNeeded;
          player.maxHp += 5;
          player.hp = player.maxHp;
          showMessage('LEVEL UP! Now level ' + player.level);
        }

        currentMonster = null;
        updateHUD();
        render();
        return;
      }

      // Monster attacks back
      setTimeout(() => {
        const monsterDmg = currentMonster.atk + Math.floor(Math.random() * 3);
        player.hp -= monsterDmg;
        showMessage(currentMonster.name + ' hits you for ' + monsterDmg + '!');
        updateHUD();

        if (player.hp <= 0) {
          gameOver();
        }
      }, 300);
    }

    function gameOver() {
      inCombat = false;
      document.getElementById('monsterPopup').classList.remove('active');
      document.getElementById('finalFloor').textContent = currentFloor;
      document.getElementById('gameOver').classList.add('active');
    }

    function restartGame() {
      player = { x: 1, y: 1, dir: 0, hp: 20, maxHp: 20, xp: 0, level: 1 };
      currentFloor = 1;
      inCombat = false;
      currentMonster = null;

      document.getElementById('gameOver').classList.remove('active');
      document.getElementById('floor').textContent = 1;
      generateMap();
      updateHUD();
      render();
      showMessage('A new adventure begins...');
    }

    function updateHUD() {
      document.getElementById('hp').textContent = Math.max(0, player.hp);
      document.getElementById('healthBar').style.width = (player.hp / player.maxHp * 100) + '%';
      document.getElementById('level').textContent = player.level;
      const xpNeeded = player.level * 30;
      document.getElementById('xpBar').style.width = (player.xp / xpNeeded * 100) + '%';
    }

    function updateCompass() {
      document.getElementById('compass').textContent = dirs[player.dir];
    }

    function showMessage(text) {
      document.getElementById('message').textContent = text;
    }

    function render() {
      // Clear
      ctx.fillStyle = colors.ceiling;
      ctx.fillRect(0, 0, canvas.width, canvas.height / 2);
      ctx.fillStyle = colors.floor;
      ctx.fillRect(0, canvas.height / 2, canvas.width, canvas.height / 2);

      // Draw 3D view
      draw3DView();
    }

    function draw3DView() {
      const lookX = player.x + dx[player.dir];
      const lookY = player.y + dy[player.dir];
      const look2X = player.x + dx[player.dir] * 2;
      const look2Y = player.y + dy[player.dir] * 2;
      const look3X = player.x + dx[player.dir] * 3;
      const look3Y = player.y + dy[player.dir] * 3;

      const leftDir = (player.dir + 3) % 4;
      const rightDir = (player.dir + 1) % 4;

      // Far walls (distance 3)
      const farLeft = getTile(look3X + dx[leftDir], look3Y + dy[leftDir]);
      const farCenter = getTile(look3X, look3Y);
      const farRight = getTile(look3X + dx[rightDir], look3Y + dy[rightDir]);

      if (farLeft === 1) drawWall(0, 3, 'left');
      if (farCenter === 1) drawWall(1, 3, 'center');
      else drawTileIndicator(look3X, look3Y, 3);
      if (farRight === 1) drawWall(2, 3, 'right');

      // Mid walls (distance 2)
      const midLeft = getTile(look2X + dx[leftDir], look2Y + dy[leftDir]);
      const midCenter = getTile(look2X, look2Y);
      const midRight = getTile(look2X + dx[rightDir], look2Y + dy[rightDir]);

      if (midLeft === 1) drawWall(0, 2, 'left');
      if (midCenter === 1) drawWall(1, 2, 'center');
      else drawTileIndicator(look2X, look2Y, 2);
      if (midRight === 1) drawWall(2, 2, 'right');

      // Near walls (distance 1)
      const nearLeft = getTile(lookX + dx[leftDir], lookY + dy[leftDir]);
      const nearCenter = getTile(lookX, lookY);
      const nearRight = getTile(lookX + dx[rightDir], lookY + dy[rightDir]);

      if (nearLeft === 1) drawWall(0, 1, 'left');
      if (nearCenter === 1) drawWall(1, 1, 'center');
      else drawTileIndicator(lookX, lookY, 1);
      if (nearRight === 1) drawWall(2, 1, 'right');

      // Side walls
      const sideLeft = getTile(player.x + dx[leftDir], player.y + dy[leftDir]);
      const sideRight = getTile(player.x + dx[rightDir], player.y + dy[rightDir]);

      if (sideLeft === 1) drawSideWall('left');
      if (sideRight === 1) drawSideWall('right');
    }

    function drawWall(pos, dist, side) {
      const depths = {
        3: { y: 100, h: 100, w: 80 },
        2: { y: 70, h: 160, w: 120 },
        1: { y: 30, h: 240, w: 180 }
      };

      const d = depths[dist];
      const baseX = pos === 0 ? 20 : (pos === 1 ? 140 : 260);
      const x = baseX + (3 - dist) * (pos === 0 ? 20 : (pos === 2 ? -20 : 0));

      const wallColors = { 3: colors.wallFar, 2: colors.wallMid, 1: colors.wallNear };
      ctx.fillStyle = wallColors[dist];
      ctx.fillRect(x, d.y, d.w - (3 - dist) * 20, d.h);

      // Add brick pattern
      ctx.strokeStyle = 'rgba(0,0,0,0.2)';
      ctx.lineWidth = 1;
      for (let row = 0; row < 4; row++) {
        const rowY = d.y + row * (d.h / 4);
        ctx.beginPath();
        ctx.moveTo(x, rowY);
        ctx.lineTo(x + d.w - (3 - dist) * 20, rowY);
        ctx.stroke();
      }
    }

    function drawSideWall(side) {
      ctx.fillStyle = colors.wallSide;
      if (side === 'left') {
        ctx.beginPath();
        ctx.moveTo(0, 0);
        ctx.lineTo(40, 50);
        ctx.lineTo(40, 250);
        ctx.lineTo(0, 300);
        ctx.fill();
      } else {
        ctx.beginPath();
        ctx.moveTo(400, 0);
        ctx.lineTo(360, 50);
        ctx.lineTo(360, 250);
        ctx.lineTo(400, 300);
        ctx.fill();
      }
    }

    function drawTileIndicator(x, y, dist) {
      const tile = getTile(x, y);
      if (tile === 0 || tile === 1) return;

      const sizes = { 3: 20, 2: 35, 1: 50 };
      const yPos = { 3: 140, 2: 130, 1: 120 };
      const size = sizes[dist];

      let icon = '';
      let color = '#fff';

      if (tile === 2) { icon = 'üö™'; color = colors.exit; }
      else if (tile === 3) { icon = 'üëπ'; color = colors.monster; }
      else if (tile === 4) { icon = 'üß™'; color = colors.potion; }

      ctx.font = size + 'px serif';
      ctx.textAlign = 'center';
      ctx.fillText(icon, 200, yPos[dist] + size/2);
    }

    // Keyboard controls
    document.addEventListener('keydown', (e) => {
      if (e.key === 'ArrowUp' || e.key === 'w' || e.key === 'W') {
        e.preventDefault();
        move('forward');
      } else if (e.key === 'ArrowDown' || e.key === 's' || e.key === 'S') {
        e.preventDefault();
        move('backward');
      } else if (e.key === 'ArrowLeft' || e.key === 'a' || e.key === 'A') {
        e.preventDefault();
        move('left');
      } else if (e.key === 'ArrowRight' || e.key === 'd' || e.key === 'D') {
        e.preventDefault();
        move('right');
      } else if (e.key === ' ' || e.key === 'Enter') {
        e.preventDefault();
        attack();
      }
    });

    // Initialize
    generateMap();
    render();
  </script>
</body>
</html>
