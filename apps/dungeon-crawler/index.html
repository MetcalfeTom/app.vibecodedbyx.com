<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Dungeon Crawler - Party RPG Adventure</title>
  <meta name="description" content="A retro first-person dungeon crawler with party system">
  <meta property="og:title" content="Dungeon Crawler">
  <meta property="og:description" content="Lead your party through pixelated dungeons">
  <meta property="og:url" content="https://sloppy.live/dungeon-crawler">
  <meta property="og:image" content="https://sloppy.live/dungeon-crawler/og-image.png">
  <link rel="icon" href="https://emojicdn.elk.sh/üó°Ô∏è">
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }

    body {
      min-height: 100vh;
      background: #0a0a0a;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      font-family: monospace;
      color: #aaa;
      overflow-x: hidden;
      padding: 10px;
    }

    .game-container {
      background: #111;
      border: 4px solid #333;
      border-radius: 8px;
      overflow: hidden;
    }

    .main-area {
      display: flex;
    }

    .viewport {
      width: 320px;
      height: 240px;
      position: relative;
      background: #000;
    }

    canvas {
      display: block;
      width: 100%;
      height: 100%;
      image-rendering: pixelated;
    }

    .scanlines {
      position: absolute;
      top: 0; left: 0; right: 0; bottom: 0;
      background: repeating-linear-gradient(0deg, transparent, transparent 2px, rgba(0,0,0,0.15) 2px, rgba(0,0,0,0.15) 4px);
      pointer-events: none;
    }

    .compass {
      position: absolute;
      top: 8px;
      right: 8px;
      width: 32px;
      height: 32px;
      background: rgba(0,0,0,0.8);
      border: 1px solid #444;
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 12px;
      color: #f84;
    }

    .floor-display {
      position: absolute;
      top: 8px;
      left: 8px;
      padding: 4px 8px;
      background: rgba(0,0,0,0.8);
      border: 1px solid #444;
      font-size: 10px;
    }

    .message {
      position: absolute;
      bottom: 8px;
      left: 8px;
      right: 8px;
      padding: 6px;
      background: rgba(0,0,0,0.85);
      border: 1px solid #444;
      font-size: 10px;
      color: #8f8;
      text-align: center;
    }

    .party-panel {
      width: 180px;
      background: #1a1a1a;
      border-left: 2px solid #333;
      padding: 8px;
      display: flex;
      flex-direction: column;
      gap: 6px;
    }

    .party-title {
      font-size: 10px;
      color: #666;
      text-transform: uppercase;
      letter-spacing: 1px;
      text-align: center;
      padding-bottom: 4px;
      border-bottom: 1px solid #333;
    }

    .party-member {
      background: #222;
      border: 2px solid #333;
      border-radius: 4px;
      padding: 6px;
      cursor: pointer;
      transition: all 0.15s;
    }

    .party-member:hover {
      border-color: #555;
    }

    .party-member.selected {
      border-color: #4af;
      box-shadow: 0 0 8px rgba(68, 170, 255, 0.3);
    }

    .party-member.dead {
      opacity: 0.4;
      cursor: not-allowed;
    }

    .member-header {
      display: flex;
      align-items: center;
      gap: 6px;
      margin-bottom: 4px;
    }

    .member-icon {
      font-size: 18px;
    }

    .member-info {
      flex: 1;
    }

    .member-name {
      font-size: 11px;
      font-weight: bold;
      color: #ddd;
    }

    .member-class {
      font-size: 9px;
      color: #888;
    }

    .member-level {
      font-size: 9px;
      color: #4af;
    }

    .member-bars {
      display: flex;
      flex-direction: column;
      gap: 2px;
    }

    .bar-row {
      display: flex;
      align-items: center;
      gap: 4px;
    }

    .bar-label {
      font-size: 8px;
      width: 16px;
      color: #666;
    }

    .bar {
      flex: 1;
      height: 6px;
      background: #333;
      border-radius: 2px;
      overflow: hidden;
    }

    .bar-fill {
      height: 100%;
      transition: width 0.2s;
    }

    .hp-fill { background: linear-gradient(90deg, #a00, #f44); }
    .mp-fill { background: linear-gradient(90deg, #00a, #44f); }
    .xp-fill { background: linear-gradient(90deg, #0a0, #4f4); }

    .bar-text {
      font-size: 8px;
      width: 32px;
      text-align: right;
      color: #888;
    }

    .bottom-area {
      display: flex;
      background: #1a1a1a;
      border-top: 2px solid #333;
    }

    .controls {
      display: grid;
      grid-template-columns: repeat(3, 40px);
      gap: 4px;
      padding: 10px;
    }

    .ctrl-btn {
      width: 40px;
      height: 32px;
      background: #2a2a2a;
      border: 2px solid #444;
      border-radius: 4px;
      color: #888;
      font-size: 14px;
      cursor: pointer;
      transition: all 0.1s;
    }

    .ctrl-btn:hover { background: #3a3a3a; border-color: #666; }
    .ctrl-btn:active { background: #444; transform: scale(0.95); }

    .action-panel {
      flex: 1;
      padding: 10px;
      display: flex;
      flex-wrap: wrap;
      gap: 6px;
      align-content: flex-start;
    }

    .action-btn {
      padding: 6px 12px;
      background: #2a2a2a;
      border: 2px solid #444;
      border-radius: 4px;
      color: #aaa;
      font-family: monospace;
      font-size: 11px;
      cursor: pointer;
      transition: all 0.1s;
    }

    .action-btn:hover { background: #3a3a3a; border-color: #666; }
    .action-btn.attack { background: #422; border-color: #744; color: #f88; }
    .action-btn.magic { background: #224; border-color: #447; color: #88f; }
    .action-btn.heal { background: #242; border-color: #474; color: #8f8; }
    .action-btn.special { background: #442; border-color: #774; color: #ff8; }
    .action-btn:disabled { opacity: 0.3; cursor: not-allowed; }

    .combat-overlay {
      position: absolute;
      top: 0; left: 0; right: 0; bottom: 0;
      background: rgba(20, 0, 0, 0.92);
      display: none;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      padding: 15px;
    }

    .combat-overlay.active { display: flex; }

    .monster-display {
      text-align: center;
      margin-bottom: 10px;
    }

    .monster-sprite {
      font-size: 48px;
      animation: monsterBob 0.5s ease infinite alternate;
    }

    @keyframes monsterBob {
      from { transform: translateY(-3px); }
      to { transform: translateY(3px); }
    }

    .monster-name {
      color: #f66;
      font-size: 14px;
      margin-top: 5px;
    }

    .monster-hp-bar {
      width: 120px;
      height: 8px;
      background: #333;
      border: 1px solid #555;
      margin: 8px auto;
    }

    .monster-hp-fill {
      height: 100%;
      background: linear-gradient(90deg, #a00, #f44);
      transition: width 0.2s;
    }

    .combat-log {
      font-size: 10px;
      color: #8f8;
      text-align: center;
      min-height: 30px;
    }

    .game-over, .start-screen {
      position: absolute;
      top: 0; left: 0; right: 0; bottom: 0;
      background: rgba(0, 0, 0, 0.95);
      display: none;
      flex-direction: column;
      align-items: center;
      justify-content: center;
    }

    .game-over.active, .start-screen.active { display: flex; }

    .game-over h2 { color: #f44; font-size: 20px; margin-bottom: 8px; }
    .start-screen h2 { color: #4af; font-size: 20px; margin-bottom: 8px; }

    .overlay-text { font-size: 11px; margin-bottom: 15px; text-align: center; line-height: 1.6; }

    .overlay-btn {
      padding: 8px 24px;
      background: #333;
      border: 2px solid #666;
      color: #aaa;
      font-family: monospace;
      font-size: 12px;
      cursor: pointer;
    }

    .overlay-btn:hover { background: #444; border-color: #888; }

    .back-link {
      margin-top: 12px;
      color: #444;
      text-decoration: none;
      font-size: 10px;
    }

    .back-link:hover { color: #666; }

    @media (max-width: 550px) {
      .main-area { flex-direction: column; }
      .party-panel { width: 100%; flex-direction: row; flex-wrap: wrap; border-left: none; border-top: 2px solid #333; }
      .party-member { flex: 1; min-width: 140px; }
      .viewport { width: 100%; }
    }
  </style>
</head>
<body>
  <div class="game-container">
    <div class="main-area">
      <div class="viewport">
        <canvas id="game" width="320" height="240"></canvas>
        <div class="scanlines"></div>
        <div class="compass" id="compass">N</div>
        <div class="floor-display">Floor <span id="floor">1</span></div>
        <div class="message" id="message">WASD to move. Lead your party to victory!</div>

        <div class="combat-overlay" id="combatOverlay">
          <div class="monster-display">
            <div class="monster-sprite" id="monsterSprite">üëπ</div>
            <div class="monster-name" id="monsterName">Goblin</div>
            <div class="monster-hp-bar">
              <div class="monster-hp-fill" id="monsterHpBar" style="width: 100%"></div>
            </div>
          </div>
          <div class="combat-log" id="combatLog">A monster appears!</div>
        </div>

        <div class="game-over" id="gameOver">
          <h2>PARTY DEFEATED</h2>
          <p class="overlay-text">Your party fell on floor <span id="finalFloor">1</span></p>
          <button class="overlay-btn" onclick="restartGame()">NEW GAME</button>
        </div>

        <div class="start-screen active" id="startScreen">
          <h2>üó°Ô∏è DUNGEON CRAWLER</h2>
          <p class="overlay-text">
            Lead a party of 4 heroes!<br>
            Each has unique abilities.<br>
            Click members to select, then act.
          </p>
          <button class="overlay-btn" onclick="startGame()">START QUEST</button>
        </div>
      </div>

      <div class="party-panel">
        <div class="party-title">Party</div>
        <div id="partyList"></div>
      </div>
    </div>

    <div class="bottom-area">
      <div class="controls">
        <div></div>
        <button class="ctrl-btn" onclick="move('forward')">‚Üë</button>
        <div></div>
        <button class="ctrl-btn" onclick="move('left')">‚Üê</button>
        <button class="ctrl-btn" onclick="move('backward')">‚Üì</button>
        <button class="ctrl-btn" onclick="move('right')">‚Üí</button>
      </div>
      <div class="action-panel" id="actionPanel">
        <button class="action-btn attack" onclick="doAction('attack')">‚öîÔ∏è Attack</button>
        <button class="action-btn magic" onclick="doAction('magic')" id="magicBtn">‚ú® Magic</button>
        <button class="action-btn heal" onclick="doAction('heal')" id="healBtn">üíö Heal</button>
        <button class="action-btn special" onclick="doAction('special')" id="specialBtn">‚≠ê Special</button>
      </div>
    </div>
  </div>

  <a href="https://sloppy.live" class="back-link">sloppy.live</a>

  <script>
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');

    // Character classes
    const classes = {
      warrior: {
        name: 'Warrior', icon: 'üõ°Ô∏è', color: '#f84',
        baseHp: 30, baseMp: 5, baseAtk: 8, baseDef: 6,
        hpGrowth: 8, mpGrowth: 1, atkGrowth: 3, defGrowth: 2,
        special: 'Power Strike', specialCost: 5, specialMult: 2.5
      },
      mage: {
        name: 'Mage', icon: 'üîÆ', color: '#84f',
        baseHp: 18, baseMp: 25, baseAtk: 4, baseDef: 3,
        hpGrowth: 4, mpGrowth: 6, atkGrowth: 2, defGrowth: 1,
        special: 'Fireball', specialCost: 8, specialMult: 3.0
      },
      rogue: {
        name: 'Rogue', icon: 'üó°Ô∏è', color: '#8f4',
        baseHp: 22, baseMp: 10, baseAtk: 7, baseDef: 4,
        hpGrowth: 5, mpGrowth: 2, atkGrowth: 4, defGrowth: 1,
        special: 'Backstab', specialCost: 6, specialMult: 2.8
      },
      cleric: {
        name: 'Cleric', icon: '‚úùÔ∏è', color: '#ff8',
        baseHp: 24, baseMp: 20, baseAtk: 5, baseDef: 5,
        hpGrowth: 6, mpGrowth: 4, atkGrowth: 2, defGrowth: 2,
        special: 'Holy Light', specialCost: 10, specialMult: 0, healMult: 2.0
      }
    };

    const names = ['Aldric', 'Lyra', 'Theron', 'Mira', 'Kael', 'Zara', 'Finn', 'Nova'];

    // Monster types (scaled by floor)
    const monsterTypes = [
      { name: 'Rat', sprite: 'üêÄ', hp: 8, atk: 3, def: 1, xp: 8 },
      { name: 'Goblin', sprite: 'üë∫', hp: 15, atk: 5, def: 2, xp: 15 },
      { name: 'Skeleton', sprite: 'üíÄ', hp: 22, atk: 7, def: 3, xp: 22 },
      { name: 'Orc', sprite: 'üëπ', hp: 35, atk: 10, def: 5, xp: 35 },
      { name: 'Demon', sprite: 'üëø', hp: 50, atk: 14, def: 7, xp: 50 },
      { name: 'Dragon', sprite: 'üêâ', hp: 80, atk: 20, def: 10, xp: 100 }
    ];

    // Game state
    let party = [];
    let selectedMember = 0;
    let position = { x: 1, y: 1, dir: 0 };
    let currentFloor = 1;
    let inCombat = false;
    let currentMonster = null;
    let gameStarted = false;

    const dirs = ['N', 'E', 'S', 'W'];
    const dx = [0, 1, 0, -1];
    const dy = [-1, 0, 1, 0];

    let map = [];
    const mapSize = 12;

    const colors = {
      ceiling: '#1a1a2e', floor: '#2d2d44',
      wallFar: '#3d3d5c', wallMid: '#4d4d6c', wallNear: '#5d5d7c', wallSide: '#2d2d44'
    };

    function createCharacter(classKey, name) {
      const c = classes[classKey];
      return {
        name, class: classKey, classData: c, level: 1, xp: 0,
        hp: c.baseHp, maxHp: c.baseHp,
        mp: c.baseMp, maxMp: c.baseMp,
        atk: c.baseAtk, def: c.baseDef,
        dead: false
      };
    }

    function initParty() {
      const shuffledNames = [...names].sort(() => Math.random() - 0.5);
      party = [
        createCharacter('warrior', shuffledNames[0]),
        createCharacter('mage', shuffledNames[1]),
        createCharacter('rogue', shuffledNames[2]),
        createCharacter('cleric', shuffledNames[3])
      ];
      selectedMember = 0;
    }

    function renderParty() {
      const list = document.getElementById('partyList');
      list.innerHTML = '';

      party.forEach((member, i) => {
        const div = document.createElement('div');
        div.className = 'party-member' + (i === selectedMember ? ' selected' : '') + (member.dead ? ' dead' : '');
        div.onclick = () => { if (!member.dead) { selectedMember = i; renderParty(); updateActions(); } };

        const hpPct = (member.hp / member.maxHp * 100).toFixed(0);
        const mpPct = (member.mp / member.maxMp * 100).toFixed(0);
        const xpNeeded = member.level * 25;
        const xpPct = (member.xp / xpNeeded * 100).toFixed(0);

        div.innerHTML = `
          <div class="member-header">
            <span class="member-icon">${member.classData.icon}</span>
            <div class="member-info">
              <div class="member-name">${member.name}</div>
              <div class="member-class">${member.classData.name}</div>
            </div>
            <span class="member-level">Lv${member.level}</span>
          </div>
          <div class="member-bars">
            <div class="bar-row">
              <span class="bar-label">HP</span>
              <div class="bar"><div class="bar-fill hp-fill" style="width:${hpPct}%"></div></div>
              <span class="bar-text">${member.hp}/${member.maxHp}</span>
            </div>
            <div class="bar-row">
              <span class="bar-label">MP</span>
              <div class="bar"><div class="bar-fill mp-fill" style="width:${mpPct}%"></div></div>
              <span class="bar-text">${member.mp}/${member.maxMp}</span>
            </div>
            <div class="bar-row">
              <span class="bar-label">XP</span>
              <div class="bar"><div class="bar-fill xp-fill" style="width:${Math.min(100, xpPct)}%"></div></div>
              <span class="bar-text">${member.xp}/${xpNeeded}</span>
            </div>
          </div>
        `;
        list.appendChild(div);
      });
    }

    function updateActions() {
      const member = party[selectedMember];
      if (!member || member.dead) return;

      const magicBtn = document.getElementById('magicBtn');
      const healBtn = document.getElementById('healBtn');
      const specialBtn = document.getElementById('specialBtn');

      magicBtn.disabled = member.class !== 'mage' || member.mp < 4;
      healBtn.disabled = member.class !== 'cleric' || member.mp < 6;
      specialBtn.disabled = member.mp < member.classData.specialCost;
      specialBtn.textContent = '‚≠ê ' + member.classData.special;
    }

    function generateMap() {
      map = [];
      for (let y = 0; y < mapSize; y++) {
        map[y] = [];
        for (let x = 0; x < mapSize; x++) {
          if (x === 0 || y === 0 || x === mapSize-1 || y === mapSize-1) {
            map[y][x] = 1;
          } else {
            map[y][x] = Math.random() > 0.72 ? 1 : 0;
          }
        }
      }

      map[1][1] = 0; map[1][2] = 0; map[2][1] = 0;

      // Place exit
      let placed = false;
      while (!placed) {
        const ex = Math.floor(Math.random() * (mapSize - 4)) + 2;
        const ey = Math.floor(Math.random() * (mapSize - 4)) + 2;
        if (map[ey][ex] === 0 && (ex > 4 || ey > 4)) { map[ey][ex] = 2; placed = true; }
      }

      // Place monsters
      const numMonsters = 4 + currentFloor;
      for (let i = 0; i < numMonsters; i++) {
        placed = false;
        while (!placed) {
          const mx = Math.floor(Math.random() * (mapSize - 2)) + 1;
          const my = Math.floor(Math.random() * (mapSize - 2)) + 1;
          if (map[my][mx] === 0 && (mx > 2 || my > 2)) { map[my][mx] = 3; placed = true; }
        }
      }

      // Place potions
      for (let i = 0; i < 2; i++) {
        placed = false;
        while (!placed) {
          const px = Math.floor(Math.random() * (mapSize - 2)) + 1;
          const py = Math.floor(Math.random() * (mapSize - 2)) + 1;
          if (map[py][px] === 0) { map[py][px] = 4; placed = true; }
        }
      }

      position = { x: 1, y: 1, dir: 0 };
    }

    function getTile(x, y) {
      if (x < 0 || y < 0 || x >= mapSize || y >= mapSize) return 1;
      return map[y][x];
    }

    function move(dir) {
      if (inCombat || !gameStarted) return;

      let nx = position.x, ny = position.y;

      if (dir === 'forward') { nx += dx[position.dir]; ny += dy[position.dir]; }
      else if (dir === 'backward') { nx -= dx[position.dir]; ny -= dy[position.dir]; }
      else if (dir === 'left') { position.dir = (position.dir + 3) % 4; updateCompass(); render(); return; }
      else if (dir === 'right') { position.dir = (position.dir + 1) % 4; updateCompass(); render(); return; }

      if (getTile(nx, ny) !== 1) {
        position.x = nx; position.y = ny;
        const tile = getTile(nx, ny);

        if (tile === 2) {
          currentFloor++;
          showMessage('Descending to floor ' + currentFloor + '...');
          document.getElementById('floor').textContent = currentFloor;
          generateMap();
          // Restore some MP on floor change
          party.forEach(m => { if (!m.dead) m.mp = Math.min(m.maxMp, m.mp + 5); });
          renderParty();
        } else if (tile === 3) {
          startCombat();
        } else if (tile === 4) {
          // Potion - heal all party
          party.forEach(m => {
            if (!m.dead) {
              m.hp = Math.min(m.maxHp, m.hp + 15);
              m.mp = Math.min(m.maxMp, m.mp + 8);
            }
          });
          map[ny][nx] = 0;
          showMessage('Found supplies! Party restored.');
          renderParty();
        }
      } else {
        showMessage("Can't go that way.");
      }
      render();
    }

    function startCombat() {
      inCombat = true;
      const typeIndex = Math.min(Math.floor(currentFloor / 2), monsterTypes.length - 1);
      const type = monsterTypes[typeIndex];
      const scale = 1 + currentFloor * 0.15;

      currentMonster = {
        ...type,
        hp: Math.floor(type.hp * scale),
        maxHp: Math.floor(type.hp * scale),
        atk: Math.floor(type.atk * scale),
        def: Math.floor(type.def * scale)
      };

      document.getElementById('monsterName').textContent = currentMonster.name + ' Lv' + (currentFloor + typeIndex);
      document.getElementById('monsterSprite').textContent = currentMonster.sprite;
      document.getElementById('monsterHpBar').style.width = '100%';
      document.getElementById('combatLog').textContent = 'A ' + currentMonster.name + ' appears!';
      document.getElementById('combatOverlay').classList.add('active');
    }

    function doAction(action) {
      if (!inCombat || !currentMonster) return;

      const member = party[selectedMember];
      if (!member || member.dead) return;

      let damage = 0;
      let message = '';

      if (action === 'attack') {
        damage = Math.max(1, member.atk - currentMonster.def + Math.floor(Math.random() * 4));
        message = `${member.name} attacks for ${damage} damage!`;
      } else if (action === 'magic' && member.class === 'mage' && member.mp >= 4) {
        member.mp -= 4;
        damage = Math.floor(member.atk * 1.8) + Math.floor(Math.random() * 5);
        message = `${member.name} casts a spell for ${damage} damage!`;
      } else if (action === 'heal' && member.class === 'cleric' && member.mp >= 6) {
        member.mp -= 6;
        const healAmt = 12 + member.level * 3;
        // Heal most damaged party member
        const alive = party.filter(m => !m.dead);
        alive.sort((a, b) => (a.hp / a.maxHp) - (b.hp / b.maxHp));
        const target = alive[0];
        target.hp = Math.min(target.maxHp, target.hp + healAmt);
        message = `${member.name} heals ${target.name} for ${healAmt} HP!`;
        renderParty();
        updateActions();
        document.getElementById('combatLog').textContent = message;
        monsterTurn();
        return;
      } else if (action === 'special' && member.mp >= member.classData.specialCost) {
        member.mp -= member.classData.specialCost;
        if (member.classData.healMult) {
          // Cleric holy light - heal all
          const healAmt = Math.floor(15 * member.classData.healMult);
          party.forEach(m => { if (!m.dead) m.hp = Math.min(m.maxHp, m.hp + healAmt); });
          message = `${member.name} uses ${member.classData.special}! All healed ${healAmt}!`;
          renderParty();
          updateActions();
          document.getElementById('combatLog').textContent = message;
          monsterTurn();
          return;
        } else {
          damage = Math.floor(member.atk * member.classData.specialMult) + Math.floor(Math.random() * 6);
          message = `${member.name} uses ${member.classData.special} for ${damage} damage!`;
        }
      } else {
        return;
      }

      currentMonster.hp -= damage;
      document.getElementById('monsterHpBar').style.width = Math.max(0, currentMonster.hp / currentMonster.maxHp * 100) + '%';
      document.getElementById('combatLog').textContent = message;
      renderParty();
      updateActions();

      if (currentMonster.hp <= 0) {
        endCombat(true);
      } else {
        setTimeout(monsterTurn, 600);
      }
    }

    function monsterTurn() {
      if (!currentMonster || currentMonster.hp <= 0) return;

      // Monster attacks random alive party member
      const alive = party.filter(m => !m.dead);
      if (alive.length === 0) { endCombat(false); return; }

      const target = alive[Math.floor(Math.random() * alive.length)];
      const damage = Math.max(1, currentMonster.atk - target.def + Math.floor(Math.random() * 3));
      target.hp -= damage;

      document.getElementById('combatLog').textContent = `${currentMonster.name} hits ${target.name} for ${damage}!`;

      if (target.hp <= 0) {
        target.hp = 0;
        target.dead = true;
        document.getElementById('combatLog').textContent += ` ${target.name} falls!`;

        // Select next alive member
        const nextAlive = party.findIndex(m => !m.dead);
        if (nextAlive >= 0) selectedMember = nextAlive;
      }

      renderParty();
      updateActions();

      // Check if all dead
      if (party.every(m => m.dead)) {
        setTimeout(() => endCombat(false), 500);
      }
    }

    function endCombat(victory) {
      inCombat = false;
      document.getElementById('combatOverlay').classList.remove('active');

      if (victory) {
        map[position.y][position.x] = 0;
        const xpGain = currentMonster.xp;
        party.forEach(m => {
          if (!m.dead) {
            m.xp += xpGain;
            const xpNeeded = m.level * 25;
            if (m.xp >= xpNeeded) {
              m.xp -= xpNeeded;
              m.level++;
              m.maxHp += m.classData.hpGrowth;
              m.hp = m.maxHp;
              m.maxMp += m.classData.mpGrowth;
              m.mp = m.maxMp;
              m.atk += m.classData.atkGrowth;
              m.def += m.classData.defGrowth;
              showMessage(`${m.name} leveled up to ${m.level}!`);
            }
          }
        });
        showMessage(`Victory! +${xpGain} XP each.`);
        currentMonster = null;
        renderParty();
        render();
      } else {
        document.getElementById('finalFloor').textContent = currentFloor;
        document.getElementById('gameOver').classList.add('active');
      }
    }

    function updateCompass() {
      document.getElementById('compass').textContent = dirs[position.dir];
    }

    function showMessage(text) {
      document.getElementById('message').textContent = text;
    }

    function render() {
      ctx.fillStyle = colors.ceiling;
      ctx.fillRect(0, 0, canvas.width, canvas.height / 2);
      ctx.fillStyle = colors.floor;
      ctx.fillRect(0, canvas.height / 2, canvas.width, canvas.height / 2);
      draw3DView();
    }

    function draw3DView() {
      const lookX = position.x + dx[position.dir];
      const lookY = position.y + dy[position.dir];
      const look2X = position.x + dx[position.dir] * 2;
      const look2Y = position.y + dy[position.dir] * 2;
      const look3X = position.x + dx[position.dir] * 3;
      const look3Y = position.y + dy[position.dir] * 3;

      const leftDir = (position.dir + 3) % 4;
      const rightDir = (position.dir + 1) % 4;

      // Distance 3
      if (getTile(look3X + dx[leftDir], look3Y + dy[leftDir]) === 1) drawWall(0, 3);
      if (getTile(look3X, look3Y) === 1) drawWall(1, 3);
      else drawTileIcon(look3X, look3Y, 3);
      if (getTile(look3X + dx[rightDir], look3Y + dy[rightDir]) === 1) drawWall(2, 3);

      // Distance 2
      if (getTile(look2X + dx[leftDir], look2Y + dy[leftDir]) === 1) drawWall(0, 2);
      if (getTile(look2X, look2Y) === 1) drawWall(1, 2);
      else drawTileIcon(look2X, look2Y, 2);
      if (getTile(look2X + dx[rightDir], look2Y + dy[rightDir]) === 1) drawWall(2, 2);

      // Distance 1
      if (getTile(lookX + dx[leftDir], lookY + dy[leftDir]) === 1) drawWall(0, 1);
      if (getTile(lookX, lookY) === 1) drawWall(1, 1);
      else drawTileIcon(lookX, lookY, 1);
      if (getTile(lookX + dx[rightDir], lookY + dy[rightDir]) === 1) drawWall(2, 1);

      // Side walls
      if (getTile(position.x + dx[leftDir], position.y + dy[leftDir]) === 1) drawSideWall('left');
      if (getTile(position.x + dx[rightDir], position.y + dy[rightDir]) === 1) drawSideWall('right');
    }

    function drawWall(pos, dist) {
      const depths = { 3: { y: 80, h: 80, w: 64 }, 2: { y: 56, h: 128, w: 96 }, 1: { y: 24, h: 192, w: 144 } };
      const d = depths[dist];
      const baseX = pos === 0 ? 16 : (pos === 1 ? 112 : 208);
      const x = baseX + (3 - dist) * (pos === 0 ? 16 : (pos === 2 ? -16 : 0));
      const wallColors = { 3: colors.wallFar, 2: colors.wallMid, 1: colors.wallNear };

      ctx.fillStyle = wallColors[dist];
      ctx.fillRect(x, d.y, d.w - (3 - dist) * 16, d.h);

      ctx.strokeStyle = 'rgba(0,0,0,0.2)';
      ctx.lineWidth = 1;
      for (let row = 0; row < 4; row++) {
        ctx.beginPath();
        ctx.moveTo(x, d.y + row * (d.h / 4));
        ctx.lineTo(x + d.w - (3 - dist) * 16, d.y + row * (d.h / 4));
        ctx.stroke();
      }
    }

    function drawSideWall(side) {
      ctx.fillStyle = colors.wallSide;
      if (side === 'left') {
        ctx.beginPath();
        ctx.moveTo(0, 0); ctx.lineTo(32, 40); ctx.lineTo(32, 200); ctx.lineTo(0, 240); ctx.fill();
      } else {
        ctx.beginPath();
        ctx.moveTo(320, 0); ctx.lineTo(288, 40); ctx.lineTo(288, 200); ctx.lineTo(320, 240); ctx.fill();
      }
    }

    function drawTileIcon(x, y, dist) {
      const tile = getTile(x, y);
      if (tile === 0 || tile === 1) return;
      const sizes = { 3: 16, 2: 28, 1: 40 };
      const yPos = { 3: 112, 2: 104, 1: 96 };
      let icon = tile === 2 ? 'üö™' : tile === 3 ? 'üëπ' : 'üß™';
      ctx.font = sizes[dist] + 'px serif';
      ctx.textAlign = 'center';
      ctx.fillText(icon, 160, yPos[dist] + sizes[dist] / 2);
    }

    function startGame() {
      document.getElementById('startScreen').classList.remove('active');
      gameStarted = true;
      initParty();
      currentFloor = 1;
      document.getElementById('floor').textContent = 1;
      generateMap();
      renderParty();
      updateActions();
      render();
      showMessage('Your quest begins! Find the exit.');
    }

    function restartGame() {
      document.getElementById('gameOver').classList.remove('active');
      startGame();
    }

    // Keyboard
    document.addEventListener('keydown', (e) => {
      if (!gameStarted) return;
      if (e.key === 'ArrowUp' || e.key === 'w') { e.preventDefault(); move('forward'); }
      else if (e.key === 'ArrowDown' || e.key === 's') { e.preventDefault(); move('backward'); }
      else if (e.key === 'ArrowLeft' || e.key === 'a') { e.preventDefault(); move('left'); }
      else if (e.key === 'ArrowRight' || e.key === 'd') { e.preventDefault(); move('right'); }
      else if (e.key === ' ' || e.key === 'Enter') { e.preventDefault(); doAction('attack'); }
      else if (e.key === '1') { if (!party[0]?.dead) { selectedMember = 0; renderParty(); updateActions(); } }
      else if (e.key === '2') { if (!party[1]?.dead) { selectedMember = 1; renderParty(); updateActions(); } }
      else if (e.key === '3') { if (!party[2]?.dead) { selectedMember = 2; renderParty(); updateActions(); } }
      else if (e.key === '4') { if (!party[3]?.dead) { selectedMember = 3; renderParty(); updateActions(); } }
    });

    render();
  </script>
</body>
</html>
