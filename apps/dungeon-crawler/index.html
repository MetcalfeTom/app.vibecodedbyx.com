<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Sunset Shores - Island Crawler</title>
  <meta name="description" content="Isometric tropical island crawler">
  <meta property="og:title" content="Sunset Shores - Island Crawler">
  <meta property="og:description" content="Tropical isometric RPG - explore paradise at sunset!">
  <meta property="og:url" content="https://sloppy.live/dungeon-crawler">
  <meta property="og:image" content="https://emojicdn.elk.sh/ðŸŒ´?style=apple&size=512">
  <link rel="icon" href="https://emojicdn.elk.sh/ðŸŒ…">
  <link href="https://fonts.googleapis.com/css2?family=Cinzel:wght@400;700&family=Crimson+Text:ital@0;1&display=swap" rel="stylesheet">
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      min-height: 100vh;
      background: linear-gradient(180deg, #ff6b35 0%, #ff8c42 30%, #ffa07a 60%, #dda0dd 100%);
      font-family: 'Crimson Text', serif;
      color: #5a3a2a;
      display: flex;
      flex-direction: column;
      align-items: center;
      overflow: hidden;
    }
    .game-container {
      position: relative;
      width: 100vw;
      height: 100vh;
      overflow: hidden;
    }
    #gameCanvas {
      display: block;
      cursor: pointer;
    }
    .hud {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      padding: 10px 15px;
      background: linear-gradient(180deg, rgba(0,0,0,0.9) 0%, transparent 100%);
      display: flex;
      justify-content: space-between;
      align-items: flex-start;
      pointer-events: none;
      z-index: 10;
    }
    .hud > * { pointer-events: auto; }
    .title {
      font-family: 'Cinzel', serif;
      font-size: 1.1rem;
      color: #ff6b35;
      letter-spacing: 0.15em;
      text-shadow: 0 0 10px rgba(255,107,53,0.5);
    }
    .title::before {
      content: "ðŸŒ´ ";
    }
    .title::after {
      content: " ðŸŒ…";
    }
    .floor-display {
      font-family: 'Cinzel', serif;
      font-size: 0.9rem;
      color: #ff8c42;
    }
    .stats-panel {
      position: fixed;
      bottom: 10px;
      left: 10px;
      background: rgba(255,248,240,0.95);
      border: 2px solid #ff8c42;
      border-radius: 8px;
      padding: 10px;
      min-width: 180px;
      z-index: 10;
      box-shadow: 0 4px 15px rgba(255,107,53,0.3);
    }
    .stat-row {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 6px;
    }
    .stat-label {
      font-size: 0.75rem;
      color: #8b4513;
      text-transform: uppercase;
      letter-spacing: 0.1em;
    }
    .stat-bar {
      width: 100px;
      height: 8px;
      background: #ffe4c4;
      border: 1px solid #deb887;
      border-radius: 4px;
      overflow: hidden;
    }
    .stat-fill {
      height: 100%;
      transition: width 0.3s;
    }
    .hp-fill { background: linear-gradient(90deg, #ff6b35, #ff8c42); }
    .mp-fill { background: linear-gradient(90deg, #4ecdc4, #26a69a); }
    .xp-fill { background: linear-gradient(90deg, #ffd700, #ffb347); }
    .stat-val {
      font-size: 0.7rem;
      color: #7a6a5a;
      min-width: 50px;
      text-align: right;
    }
    .char-name {
      font-family: 'Cinzel', serif;
      font-size: 0.85rem;
      color: #9a7a5a;
      margin-bottom: 8px;
      display: flex;
      justify-content: space-between;
    }
    .char-level { color: #6a5a4a; font-size: 0.75rem; }
    .inventory-panel {
      position: fixed;
      bottom: 10px;
      right: 10px;
      background: rgba(255,248,240,0.95);
      border: 2px solid #ff8c42;
      border-radius: 8px;
      padding: 10px;
      z-index: 10;
      box-shadow: 0 4px 15px rgba(255,107,53,0.3);
    }
    .inv-title {
      font-family: 'Cinzel', serif;
      font-size: 0.7rem;
      color: #ff6b35;
      text-transform: uppercase;
      letter-spacing: 0.15em;
      margin-bottom: 6px;
    }
    .inv-title::before {
      content: "ðŸ¥¥ ";
    }
    .inv-grid {
      display: grid;
      grid-template-columns: repeat(4, 36px);
      gap: 3px;
    }
    .inv-slot {
      width: 36px;
      height: 36px;
      background: #ffe4c4;
      border: 1px solid #deb887;
      border-radius: 4px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 18px;
      cursor: pointer;
      position: relative;
    }
    .inv-slot:hover { border-color: #ff8c42; }
    .inv-slot.empty { opacity: 0.4; }
    .inv-qty {
      position: absolute;
      bottom: 1px;
      right: 2px;
      font-size: 9px;
      color: #9a8a7a;
      text-shadow: 0 0 2px #000;
    }
    .combat-log {
      position: fixed;
      bottom: 140px;
      left: 10px;
      width: 200px;
      max-height: 120px;
      overflow-y: auto;
      background: rgba(10,8,8,0.8);
      border: 1px solid #2a1a1a;
      border-radius: 4px;
      padding: 8px;
      font-size: 0.7rem;
      z-index: 10;
    }
    .log-entry {
      margin-bottom: 4px;
      padding-bottom: 4px;
      border-bottom: 1px solid #1a1212;
    }
    .log-entry:last-child { border-bottom: none; }
    .log-damage { color: #a04040; }
    .log-heal { color: #40a040; }
    .log-loot { color: #a0a040; }
    .log-info { color: #6a5a4a; }
    .overlay {
      position: fixed;
      inset: 0;
      background: rgba(5,3,3,0.97);
      display: none;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      z-index: 100;
    }
    .overlay.show { display: flex; }
    .overlay-title {
      font-family: 'Cinzel', serif;
      font-size: 2rem;
      color: #6a3a2a;
      letter-spacing: 0.2em;
      text-shadow: 0 0 20px rgba(100,40,20,0.5);
      margin-bottom: 20px;
    }
    .overlay-text {
      font-size: 1rem;
      color: #5a4a3a;
      text-align: center;
      line-height: 1.8;
      margin-bottom: 30px;
    }
    .overlay-btn {
      font-family: 'Cinzel', serif;
      font-size: 0.9rem;
      padding: 12px 40px;
      background: transparent;
      border: 1px solid #4a2a1a;
      color: #8a5a3a;
      cursor: pointer;
      letter-spacing: 0.15em;
      transition: all 0.3s;
    }
    .overlay-btn:hover {
      background: #2a1510;
      border-color: #6a3a2a;
      color: #aa7a5a;
    }
    .enemy-health {
      position: fixed;
      top: 60px;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(10,8,8,0.9);
      border: 1px solid #3a1a1a;
      border-radius: 4px;
      padding: 8px 15px;
      display: none;
      align-items: center;
      gap: 10px;
      z-index: 10;
    }
    .enemy-health.show { display: flex; }
    .enemy-name {
      font-family: 'Cinzel', serif;
      font-size: 0.8rem;
      color: #a05040;
    }
    .enemy-bar {
      width: 120px;
      height: 6px;
      background: #1a0a0a;
      border: 1px solid #3a1a1a;
      border-radius: 2px;
      overflow: hidden;
    }
    .enemy-hp-fill {
      height: 100%;
      background: linear-gradient(90deg, #5a1010, #a02020);
      transition: width 0.2s;
    }
    .back-link {
      position: fixed;
      bottom: 5px;
      left: 50%;
      transform: translateX(-50%);
      color: #2a2020;
      font-size: 0.6rem;
      text-decoration: none;
      z-index: 5;
    }
    .back-link:hover { color: #4a3a3a; }
    .controls-hint {
      position: fixed;
      top: 50px;
      right: 10px;
      font-size: 0.65rem;
      color: #3a2a2a;
      text-align: right;
      z-index: 10;
    }
  </style>
</head>
<body>
  <div class="game-container">
    <canvas id="gameCanvas"></canvas>
  </div>

  <div class="hud">
    <div class="title">DUNGEON CRAWLER</div>
    <div class="floor-display">Depth: <span id="floorNum">1</span></div>
  </div>

  <div class="controls-hint">
    Click to move<br>
    Click enemies to attack<br>
    1-4: Use potions
  </div>

  <div class="stats-panel">
    <div class="char-name">
      <span id="charName">Hero</span>
      <span class="char-level">Lv <span id="charLevel">1</span></span>
    </div>
    <div class="stat-row">
      <span class="stat-label">HP</span>
      <div class="stat-bar"><div class="stat-fill hp-fill" id="hpBar"></div></div>
      <span class="stat-val" id="hpVal">50/50</span>
    </div>
    <div class="stat-row">
      <span class="stat-label">MP</span>
      <div class="stat-bar"><div class="stat-fill mp-fill" id="mpBar"></div></div>
      <span class="stat-val" id="mpVal">20/20</span>
    </div>
    <div class="stat-row">
      <span class="stat-label">XP</span>
      <div class="stat-bar"><div class="stat-fill xp-fill" id="xpBar"></div></div>
      <span class="stat-val" id="xpVal">0/30</span>
    </div>
  </div>

  <div class="combat-log" id="combatLog"></div>

  <div class="inventory-panel">
    <div class="inv-title">Inventory</div>
    <div class="inv-grid" id="invGrid"></div>
  </div>

  <div class="enemy-health" id="enemyHealth">
    <span class="enemy-name" id="enemyName">Skeleton</span>
    <div class="enemy-bar"><div class="enemy-hp-fill" id="enemyHpBar"></div></div>
  </div>

  <div class="overlay show" id="startOverlay">
    <div class="overlay-title">âš” DUNGEON CRAWLER âš”</div>
    <div class="overlay-text">
      Descend into darkness.<br>
      Click to move. Click enemies to strike.<br>
      Find the stairs to go deeper.
    </div>
    <button class="overlay-btn" onclick="startGame()">Enter the Depths</button>
  </div>

  <div class="overlay" id="deathOverlay">
    <div class="overlay-title">YOU HAVE FALLEN</div>
    <div class="overlay-text">
      Reached Depth <span id="finalDepth">1</span><br>
      Slain <span id="killCount">0</span> foes
    </div>
    <button class="overlay-btn" onclick="startGame()">Rise Again</button>
  </div>

  <a href="https://sloppy.live" class="back-link">sloppy.live</a>

<script>
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');

// Isometric settings
const TILE_W = 64;
const TILE_H = 32;
const MAP_SIZE = 16;

// Game state
let player = null;
let enemies = [];
let items = [];
let floor = 1;
let map = [];
let stairPos = null;
let targetPos = null;
let path = [];
let gameStarted = false;
let kills = 0;
let inventory = [];
let combatTarget = null;
let lastAttackTime = 0;

// Camera
let camX = 0, camY = 0;

// Screen shake
let shakeIntensity = 0;
let shakeDecay = 0.9;
let shakeOffsetX = 0;
let shakeOffsetY = 0;

// Floating damage numbers
const floatingNumbers = [];

// Blood particles
const bloodParticles = [];

function triggerShake(intensity) {
  shakeIntensity = Math.max(shakeIntensity, intensity);
}

function updateShake() {
  if (shakeIntensity > 0.5) {
    shakeOffsetX = (Math.random() - 0.5) * shakeIntensity;
    shakeOffsetY = (Math.random() - 0.5) * shakeIntensity;
    shakeIntensity *= shakeDecay;
  } else {
    shakeIntensity = 0;
    shakeOffsetX = 0;
    shakeOffsetY = 0;
  }
}

function spawnFloatingNumber(x, y, value, isHeal = false) {
  const pos = isoToScreen(x, y);
  floatingNumbers.push({
    x: pos.x + (Math.random() - 0.5) * 20,
    y: pos.y - 10,
    value: value,
    vy: -2,
    alpha: 1,
    isHeal: isHeal,
    scale: 1.5
  });
}

function updateFloatingNumbers() {
  for (let i = floatingNumbers.length - 1; i >= 0; i--) {
    const fn = floatingNumbers[i];
    fn.y += fn.vy;
    fn.vy *= 0.95;
    fn.alpha -= 0.02;
    fn.scale *= 0.98;
    if (fn.alpha <= 0) {
      floatingNumbers.splice(i, 1);
    }
  }
}

function renderFloatingNumbers() {
  for (const fn of floatingNumbers) {
    ctx.save();
    ctx.globalAlpha = fn.alpha;
    ctx.font = `bold ${Math.floor(14 * fn.scale)}px Cinzel`;
    ctx.textAlign = 'center';

    // Outline
    ctx.strokeStyle = '#000';
    ctx.lineWidth = 3;
    ctx.strokeText(fn.value, fn.x + shakeOffsetX, fn.y + shakeOffsetY);

    // Fill
    ctx.fillStyle = fn.isHeal ? '#4a4' : '#a44';
    ctx.fillText(fn.value, fn.x + shakeOffsetX, fn.y + shakeOffsetY);
    ctx.restore();
  }
}

function spawnBlood(x, y, amount = 8) {
  const pos = isoToScreen(x, y);
  for (let i = 0; i < amount; i++) {
    const angle = Math.random() * Math.PI * 2;
    const speed = 1 + Math.random() * 3;
    bloodParticles.push({
      x: pos.x,
      y: pos.y,
      vx: Math.cos(angle) * speed,
      vy: Math.sin(angle) * speed - 2,
      size: 2 + Math.random() * 3,
      alpha: 1,
      gravity: 0.15,
      color: Math.random() > 0.3 ? '#6a1010' : '#8a2020'
    });
  }
}

function updateBloodParticles() {
  for (let i = bloodParticles.length - 1; i >= 0; i--) {
    const p = bloodParticles[i];
    p.x += p.vx;
    p.y += p.vy;
    p.vy += p.gravity;
    p.vx *= 0.98;
    p.alpha -= 0.015;
    p.size *= 0.99;
    if (p.alpha <= 0 || p.size < 0.5) {
      bloodParticles.splice(i, 1);
    }
  }
}

function renderBloodParticles() {
  for (const p of bloodParticles) {
    ctx.save();
    ctx.globalAlpha = p.alpha;
    ctx.fillStyle = p.color;
    ctx.beginPath();
    ctx.arc(p.x + shakeOffsetX, p.y + shakeOffsetY, p.size, 0, Math.PI * 2);
    ctx.fill();
    ctx.restore();
  }
}

// Colors - gothic palette
const COLORS = {
  void: '#050303',
  floor1: '#1a1515',
  floor2: '#151212',
  wall: '#2a2020',
  wallDark: '#1a1515',
  wallLight: '#3a2a2a',
  player: '#8a6a4a',
  enemy: '#6a2020',
  item: '#6a6a2a',
  stairs: '#4a3a5a',
  blood: '#3a1515',
  torch: '#a06020'
};

// Pixel art sprites (each row is a line, 0=transparent)
const SPRITES = {
  player: {
    width: 12, height: 16,
    data: [
      '000011110000',
      '000122221000',
      '001222222100',
      '001233332100',
      '000133331000',
      '000013310000',
      '001144441100',
      '011444444110',
      '114444444411',
      '114445444411',
      '011444444110',
      '001144441100',
      '000144441000',
      '000166661000',
      '001160061100',
      '001100001100',
    ],
    palette: {0:null, 1:'#1a1515', 2:'#3a2a2a', 3:'#8a7a6a', 4:'#4a3a2a', 5:'#6a5040', 6:'#2a2020'}
  },
  rat: {
    width: 10, height: 8,
    data: [
      '0000110000',
      '0001111000',
      '0011221100',
      '0112222110',
      '1122222211',
      '0112222110',
      '0011001100',
      '0010000100',
    ],
    palette: {0:null, 1:'#2a2020', 2:'#4a3a3a'}
  },
  skeleton: {
    width: 12, height: 16,
    data: [
      '000011110000',
      '000122221000',
      '001212212100',
      '001222222100',
      '000122221000',
      '000012210000',
      '000011110000',
      '000122221000',
      '001122221100',
      '011022220110',
      '001122221100',
      '000122221000',
      '000012210000',
      '000012210000',
      '000110011000',
      '000100001000',
    ],
    palette: {0:null, 1:'#3a3a3a', 2:'#8a8a7a'}
  },
  ghoul: {
    width: 12, height: 14,
    data: [
      '000011110000',
      '000122221000',
      '001232232100',
      '001222222100',
      '000122221000',
      '000111111000',
      '001111111100',
      '011111111110',
      '011131131110',
      '001111111100',
      '000111111000',
      '000011110000',
      '000110011000',
      '000100001000',
    ],
    palette: {0:null, 1:'#2a3a2a', 2:'#4a5a4a', 3:'#1a1a1a'}
  },
  demon: {
    width: 14, height: 16,
    data: [
      '01000000000010',
      '01100000000110',
      '00110011001100',
      '00011122110000',
      '00012233210000',
      '00122232221000',
      '00122222221000',
      '00012222210000',
      '00001221100000',
      '00011441100000',
      '00114444110000',
      '01144444411000',
      '01144444411000',
      '00114444110000',
      '00011001100000',
      '00010000100000',
    ],
    palette: {0:null, 1:'#3a1515', 2:'#6a2020', 3:'#aa3030', 4:'#4a2020'}
  },
  wraith: {
    width: 12, height: 16,
    data: [
      '000011110000',
      '000122221000',
      '001213312100',
      '001222222100',
      '000122221000',
      '000122221000',
      '001122221100',
      '011222222110',
      '012222222210',
      '012222222210',
      '011222222110',
      '001122221100',
      '000112211000',
      '000011110000',
      '000001100000',
      '000000000000',
    ],
    palette: {0:null, 1:'#252535', 2:'#3a3a5a', 3:'#1a1a2a'}
  },
  dragon: {
    width: 18, height: 18,
    data: [
      '000011000000110000',
      '000111100001111000',
      '001111110011111100',
      '000011111111110000',
      '000001122211000000',
      '000012233221000000',
      '000122232222100000',
      '001222222222210000',
      '011222222222211000',
      '111122222222111100',
      '011112222221111000',
      '001111222211110000',
      '000111122111100000',
      '000011111111000000',
      '000001100110000000',
      '000011000011000000',
      '000010000001000000',
      '000000000000000000',
    ],
    palette: {0:null, 1:'#1a1515', 2:'#3a2020', 3:'#5a2525'}
  }
};

// Pre-render sprites to offscreen canvases for performance
const spriteCanvases = {};
function prerenderSprites() {
  for (const [name, sprite] of Object.entries(SPRITES)) {
    const canvas = document.createElement('canvas');
    canvas.width = sprite.width * 2;
    canvas.height = sprite.height * 2;
    const ctx = canvas.getContext('2d');

    for (let y = 0; y < sprite.height; y++) {
      for (let x = 0; x < sprite.width; x++) {
        const c = sprite.data[y][x];
        const color = sprite.palette[c];
        if (color) {
          ctx.fillStyle = color;
          ctx.fillRect(x * 2, y * 2, 2, 2);
        }
      }
    }
    spriteCanvases[name] = canvas;
  }
}

// Monster types
const MONSTERS = [
  { name: 'Rat', hp: 12, atk: 4, def: 1, xp: 10, sprite: 'rat', size: 0.8 },
  { name: 'Skeleton', hp: 20, atk: 7, def: 2, xp: 18, sprite: 'skeleton', size: 1 },
  { name: 'Ghoul', hp: 30, atk: 10, def: 3, xp: 28, sprite: 'ghoul', size: 1 },
  { name: 'Demon', hp: 45, atk: 14, def: 5, xp: 45, sprite: 'demon', size: 1.1 },
  { name: 'Wraith', hp: 55, atk: 18, def: 4, xp: 60, sprite: 'wraith', size: 1 },
  { name: 'Dragon', hp: 100, atk: 25, def: 8, xp: 150, sprite: 'dragon', size: 1.3 }
];

// Item types
const ITEMS = {
  hpot: { name: 'Health Potion', icon: 'â¤ï¸', effect: 'hp', val: 25 },
  mpot: { name: 'Mana Potion', icon: 'ðŸ’™', effect: 'mp', val: 15 },
  gold: { name: 'Gold', icon: 'ðŸ’°', effect: 'gold', val: 10 },
  sword: { name: 'Rusty Sword', icon: 'ðŸ—¡ï¸', effect: 'atk', val: 2 }
};

function resize() {
  canvas.width = window.innerWidth;
  canvas.height = window.innerHeight;
}

function isoToScreen(x, y) {
  const screenX = (x - y) * (TILE_W / 2) + canvas.width / 2 - camX;
  const screenY = (x + y) * (TILE_H / 2) + 100 - camY;
  return { x: screenX, y: screenY };
}

function screenToIso(sx, sy) {
  const adjX = sx - canvas.width / 2 + camX;
  const adjY = sy - 100 + camY;
  const x = (adjX / (TILE_W / 2) + adjY / (TILE_H / 2)) / 2;
  const y = (adjY / (TILE_H / 2) - adjX / (TILE_W / 2)) / 2;
  return { x: Math.floor(x), y: Math.floor(y) };
}

function generateMap() {
  map = [];
  for (let y = 0; y < MAP_SIZE; y++) {
    map[y] = [];
    for (let x = 0; x < MAP_SIZE; x++) {
      // Border walls
      if (x === 0 || y === 0 || x === MAP_SIZE - 1 || y === MAP_SIZE - 1) {
        map[y][x] = 1;
      } else {
        // Random walls with some structure
        map[y][x] = Math.random() > 0.78 ? 1 : 0;
      }
    }
  }

  // Clear starting area
  for (let y = 1; y < 4; y++) {
    for (let x = 1; x < 4; x++) {
      map[y][x] = 0;
    }
  }

  // Place stairs
  let placed = false;
  while (!placed) {
    const x = 5 + Math.floor(Math.random() * (MAP_SIZE - 7));
    const y = 5 + Math.floor(Math.random() * (MAP_SIZE - 7));
    if (map[y][x] === 0) {
      stairPos = { x, y };
      placed = true;
    }
  }

  // Place enemies
  enemies = [];
  const enemyCount = 4 + floor * 2;
  for (let i = 0; i < enemyCount; i++) {
    let ex, ey;
    let attempts = 0;
    do {
      ex = 1 + Math.floor(Math.random() * (MAP_SIZE - 2));
      ey = 1 + Math.floor(Math.random() * (MAP_SIZE - 2));
      attempts++;
    } while ((map[ey][ex] !== 0 || (ex < 4 && ey < 4) ||
              enemies.some(e => e.x === ex && e.y === ey)) && attempts < 50);

    if (attempts < 50) {
      const tier = Math.min(Math.floor(floor / 2), MONSTERS.length - 1);
      const monsterType = MONSTERS[Math.floor(Math.random() * (tier + 1))];
      const scale = 1 + floor * 0.1;
      enemies.push({
        x: ex, y: ey,
        ...monsterType,
        hp: Math.floor(monsterType.hp * scale),
        maxHp: Math.floor(monsterType.hp * scale),
        atk: Math.floor(monsterType.atk * scale),
        def: Math.floor(monsterType.def * scale)
      });
    }
  }

  // Place items
  items = [];
  const itemCount = 3 + Math.floor(floor / 2);
  for (let i = 0; i < itemCount; i++) {
    let ix, iy;
    let attempts = 0;
    do {
      ix = 1 + Math.floor(Math.random() * (MAP_SIZE - 2));
      iy = 1 + Math.floor(Math.random() * (MAP_SIZE - 2));
      attempts++;
    } while ((map[iy][ix] !== 0 || items.some(it => it.x === ix && it.y === iy)) && attempts < 50);

    if (attempts < 50) {
      const types = ['hpot', 'hpot', 'mpot', 'gold', 'gold', 'gold'];
      if (floor > 2) types.push('sword');
      const type = types[Math.floor(Math.random() * types.length)];
      items.push({ x: ix, y: iy, type });
    }
  }
}

function isWalkable(x, y) {
  if (x < 0 || y < 0 || x >= MAP_SIZE || y >= MAP_SIZE) return false;
  return map[y][x] === 0;
}

function findPath(sx, sy, ex, ey) {
  if (!isWalkable(ex, ey)) return [];

  const open = [{ x: sx, y: sy, g: 0, h: 0, f: 0, parent: null }];
  const closed = new Set();

  while (open.length > 0) {
    open.sort((a, b) => a.f - b.f);
    const current = open.shift();
    const key = `${current.x},${current.y}`;

    if (current.x === ex && current.y === ey) {
      const path = [];
      let node = current;
      while (node.parent) {
        path.unshift({ x: node.x, y: node.y });
        node = node.parent;
      }
      return path;
    }

    closed.add(key);

    const neighbors = [
      { x: current.x + 1, y: current.y },
      { x: current.x - 1, y: current.y },
      { x: current.x, y: current.y + 1 },
      { x: current.x, y: current.y - 1 }
    ];

    for (const n of neighbors) {
      const nKey = `${n.x},${n.y}`;
      if (closed.has(nKey) || !isWalkable(n.x, n.y)) continue;
      if (enemies.some(e => e.x === n.x && e.y === n.y && e.hp > 0)) continue;

      const g = current.g + 1;
      const h = Math.abs(n.x - ex) + Math.abs(n.y - ey);
      const existing = open.find(o => o.x === n.x && o.y === n.y);

      if (!existing) {
        open.push({ x: n.x, y: n.y, g, h, f: g + h, parent: current });
      } else if (g < existing.g) {
        existing.g = g;
        existing.f = g + existing.h;
        existing.parent = current;
      }
    }
  }

  return [];
}

function drawTile(x, y, color, height = 0) {
  const pos = isoToScreen(x, y);

  ctx.fillStyle = color;
  ctx.beginPath();
  ctx.moveTo(pos.x, pos.y - height);
  ctx.lineTo(pos.x + TILE_W / 2, pos.y + TILE_H / 2 - height);
  ctx.lineTo(pos.x, pos.y + TILE_H - height);
  ctx.lineTo(pos.x - TILE_W / 2, pos.y + TILE_H / 2 - height);
  ctx.closePath();
  ctx.fill();
}

function drawWall(x, y) {
  const pos = isoToScreen(x, y);
  const h = 24;

  // Top
  ctx.fillStyle = COLORS.wallLight;
  ctx.beginPath();
  ctx.moveTo(pos.x, pos.y - h);
  ctx.lineTo(pos.x + TILE_W / 2, pos.y + TILE_H / 2 - h);
  ctx.lineTo(pos.x, pos.y + TILE_H - h);
  ctx.lineTo(pos.x - TILE_W / 2, pos.y + TILE_H / 2 - h);
  ctx.closePath();
  ctx.fill();

  // Left side
  ctx.fillStyle = COLORS.wallDark;
  ctx.beginPath();
  ctx.moveTo(pos.x - TILE_W / 2, pos.y + TILE_H / 2 - h);
  ctx.lineTo(pos.x, pos.y + TILE_H - h);
  ctx.lineTo(pos.x, pos.y + TILE_H);
  ctx.lineTo(pos.x - TILE_W / 2, pos.y + TILE_H / 2);
  ctx.closePath();
  ctx.fill();

  // Right side
  ctx.fillStyle = COLORS.wall;
  ctx.beginPath();
  ctx.moveTo(pos.x + TILE_W / 2, pos.y + TILE_H / 2 - h);
  ctx.lineTo(pos.x, pos.y + TILE_H - h);
  ctx.lineTo(pos.x, pos.y + TILE_H);
  ctx.lineTo(pos.x + TILE_W / 2, pos.y + TILE_H / 2);
  ctx.closePath();
  ctx.fill();
}

function drawSprite(x, y, spriteName, size = 1) {
  const pos = isoToScreen(x, y);
  const spriteCanvas = spriteCanvases[spriteName];
  if (!spriteCanvas) return;

  const w = spriteCanvas.width * size;
  const h = spriteCanvas.height * size;

  // Shadow
  ctx.fillStyle = 'rgba(0,0,0,0.5)';
  ctx.beginPath();
  ctx.ellipse(pos.x, pos.y + TILE_H / 2 + 2, w / 3, h / 8, 0, 0, Math.PI * 2);
  ctx.fill();

  // Draw sprite centered above the tile
  ctx.drawImage(
    spriteCanvas,
    pos.x - w / 2,
    pos.y - h + TILE_H / 2,
    w,
    h
  );
}

function drawEntity(x, y, color, size = 1, isPlayer = false) {
  // Legacy fallback - use sprite system instead
  const pos = isoToScreen(x, y);
  const radius = 10 * size;

  ctx.fillStyle = 'rgba(0,0,0,0.4)';
  ctx.beginPath();
  ctx.ellipse(pos.x, pos.y + TILE_H / 2, radius * 1.2, radius * 0.5, 0, 0, Math.PI * 2);
  ctx.fill();

  const grad = ctx.createRadialGradient(pos.x, pos.y, 0, pos.x, pos.y, radius * 1.5);
  grad.addColorStop(0, color);
  grad.addColorStop(1, COLORS.void);

  ctx.fillStyle = grad;
  ctx.beginPath();
  ctx.arc(pos.x, pos.y, radius, 0, Math.PI * 2);
  ctx.fill();

  if (isPlayer) {
    ctx.strokeStyle = '#6a5a4a';
    ctx.lineWidth = 2;
    ctx.stroke();
  }
}

function drawItem(x, y, type) {
  const pos = isoToScreen(x, y);
  const item = ITEMS[type];

  // Glow
  ctx.fillStyle = 'rgba(100,100,50,0.3)';
  ctx.beginPath();
  ctx.arc(pos.x, pos.y + 5, 12, 0, Math.PI * 2);
  ctx.fill();

  ctx.font = '16px serif';
  ctx.textAlign = 'center';
  ctx.fillText(item.icon, pos.x, pos.y + 8);
}

function drawStairs(x, y) {
  const pos = isoToScreen(x, y);

  // Dark hole
  ctx.fillStyle = '#0a0505';
  ctx.beginPath();
  ctx.ellipse(pos.x, pos.y + TILE_H / 2, TILE_W / 3, TILE_H / 3, 0, 0, Math.PI * 2);
  ctx.fill();

  // Glow
  ctx.strokeStyle = COLORS.stairs;
  ctx.lineWidth = 2;
  ctx.stroke();

  ctx.font = '14px Cinzel';
  ctx.fillStyle = COLORS.stairs;
  ctx.textAlign = 'center';
  ctx.fillText('â–¼', pos.x, pos.y + TILE_H / 2 + 5);
}

function render() {
  ctx.fillStyle = COLORS.void;
  ctx.fillRect(0, 0, canvas.width, canvas.height);

  if (!gameStarted) return;

  // Update effects
  updateShake();
  updateFloatingNumbers();
  updateBloodParticles();

  // Update camera to follow player (with shake)
  const targetCamX = (player.x - player.y) * (TILE_W / 2);
  const targetCamY = (player.x + player.y) * (TILE_H / 2) - canvas.height / 3;
  camX += (targetCamX - camX) * 0.1 + shakeOffsetX;
  camY += (targetCamY - camY) * 0.1 + shakeOffsetY;

  // Draw tiles in correct order (back to front)
  for (let sum = 0; sum < MAP_SIZE * 2; sum++) {
    for (let x = 0; x <= sum; x++) {
      const y = sum - x;
      if (x >= MAP_SIZE || y >= MAP_SIZE || x < 0 || y < 0) continue;

      if (map[y][x] === 0) {
        // Floor tile with checker pattern
        const checker = (x + y) % 2 === 0;
        drawTile(x, y, checker ? COLORS.floor1 : COLORS.floor2);

        // Stairs
        if (stairPos && x === stairPos.x && y === stairPos.y) {
          drawStairs(x, y);
        }

        // Items
        const item = items.find(i => i.x === x && i.y === y);
        if (item) drawItem(x, y, item.type);

        // Enemies
        const enemy = enemies.find(e => e.x === x && e.y === y && e.hp > 0);
        if (enemy) {
          drawSprite(x, y, enemy.sprite, enemy.size);
        }

        // Player
        if (player.x === x && player.y === y) {
          drawSprite(x, y, 'player', 1.2);
        }
      } else {
        // Wall
        drawWall(x, y);
      }
    }
  }

  // Draw path preview
  if (path.length > 0) {
    ctx.strokeStyle = 'rgba(100,80,60,0.3)';
    ctx.lineWidth = 2;
    ctx.beginPath();
    let first = true;
    for (const p of path) {
      const pos = isoToScreen(p.x, p.y);
      if (first) {
        ctx.moveTo(pos.x, pos.y + TILE_H / 2);
        first = false;
      } else {
        ctx.lineTo(pos.x, pos.y + TILE_H / 2);
      }
    }
    ctx.stroke();
  }

  // Render effects on top
  renderBloodParticles();
  renderFloatingNumbers();
}

function updateStats() {
  document.getElementById('charName').textContent = player.name;
  document.getElementById('charLevel').textContent = player.level;
  document.getElementById('hpBar').style.width = (player.hp / player.maxHp * 100) + '%';
  document.getElementById('mpBar').style.width = (player.mp / player.maxMp * 100) + '%';
  document.getElementById('xpBar').style.width = (player.xp / player.xpNeeded * 100) + '%';
  document.getElementById('hpVal').textContent = `${player.hp}/${player.maxHp}`;
  document.getElementById('mpVal').textContent = `${player.mp}/${player.maxMp}`;
  document.getElementById('xpVal').textContent = `${player.xp}/${player.xpNeeded}`;
  document.getElementById('floorNum').textContent = floor;
}

function updateInventory() {
  const grid = document.getElementById('invGrid');
  grid.innerHTML = '';
  for (let i = 0; i < 8; i++) {
    const slot = document.createElement('div');
    slot.className = 'inv-slot' + (i >= inventory.length ? ' empty' : '');
    if (i < inventory.length) {
      const item = inventory[i];
      const def = ITEMS[item.type];
      slot.innerHTML = def.icon + (item.qty > 1 ? `<span class="inv-qty">${item.qty}</span>` : '');
      slot.onclick = () => useItem(i);
      slot.title = def.name;
    }
    grid.appendChild(slot);
  }
}

function addLog(msg, type = 'info') {
  const log = document.getElementById('combatLog');
  const entry = document.createElement('div');
  entry.className = `log-entry log-${type}`;
  entry.textContent = msg;
  log.insertBefore(entry, log.firstChild);
  while (log.children.length > 15) {
    log.removeChild(log.lastChild);
  }
}

function useItem(idx) {
  if (idx >= inventory.length) return;
  const item = inventory[idx];
  const def = ITEMS[item.type];

  if (def.effect === 'hp') {
    player.hp = Math.min(player.maxHp, player.hp + def.val);
    addLog(`Used ${def.name}. +${def.val} HP`, 'heal');
    spawnFloatingNumber(player.x, player.y, `+${def.val}`, true);
  } else if (def.effect === 'mp') {
    player.mp = Math.min(player.maxMp, player.mp + def.val);
    addLog(`Used ${def.name}. +${def.val} MP`, 'heal');
    spawnFloatingNumber(player.x, player.y, `+${def.val}`, true);
  }

  item.qty--;
  if (item.qty <= 0) inventory.splice(idx, 1);
  updateStats();
  updateInventory();
}

function pickupItem(x, y) {
  const idx = items.findIndex(i => i.x === x && i.y === y);
  if (idx === -1) return;

  const item = items[idx];
  const def = ITEMS[item.type];

  if (def.effect === 'gold') {
    player.gold += def.val + floor * 5;
    addLog(`Found ${def.val + floor * 5} gold!`, 'loot');
  } else if (def.effect === 'atk') {
    player.atk += def.val;
    addLog(`Found ${def.name}! +${def.val} ATK`, 'loot');
  } else {
    const existing = inventory.find(i => i.type === item.type);
    if (existing) {
      existing.qty++;
    } else if (inventory.length < 8) {
      inventory.push({ type: item.type, qty: 1 });
    } else {
      addLog('Inventory full!', 'info');
      return;
    }
    addLog(`Picked up ${def.name}`, 'loot');
  }

  items.splice(idx, 1);
  updateInventory();
}

function attack(enemy) {
  const now = Date.now();
  if (now - lastAttackTime < 500) return;
  lastAttackTime = now;

  // Player attacks
  const dmg = Math.max(1, player.atk - enemy.def + Math.floor(Math.random() * 4));
  enemy.hp -= dmg;
  addLog(`You hit ${enemy.name} for ${dmg}`, 'damage');

  // JUICE: Effects on hit
  spawnFloatingNumber(enemy.x, enemy.y, `-${dmg}`);
  spawnBlood(enemy.x, enemy.y, 6 + Math.floor(dmg / 3));
  triggerShake(8 + dmg / 2);

  // Update enemy health bar
  const healthBar = document.getElementById('enemyHealth');
  healthBar.classList.add('show');
  document.getElementById('enemyName').textContent = enemy.name;
  document.getElementById('enemyHpBar').style.width = Math.max(0, enemy.hp / enemy.maxHp * 100) + '%';

  if (enemy.hp <= 0) {
    addLog(`${enemy.name} defeated! +${enemy.xp} XP`, 'loot');
    player.xp += enemy.xp;
    kills++;

    // JUICE: Big death effect
    spawnBlood(enemy.x, enemy.y, 15);
    triggerShake(15);
    spawnFloatingNumber(enemy.x, enemy.y, `+${enemy.xp} XP`, true);

    // Level up
    while (player.xp >= player.xpNeeded) {
      player.xp -= player.xpNeeded;
      player.level++;
      player.maxHp += 8;
      player.maxMp += 4;
      player.hp = player.maxHp;
      player.mp = player.maxMp;
      player.atk += 2;
      player.def += 1;
      player.xpNeeded = player.level * 30;
      addLog(`Level up! Now level ${player.level}`, 'heal');
    }

    healthBar.classList.remove('show');
    combatTarget = null;
    updateStats();
    return;
  }

  // Enemy counter-attacks
  setTimeout(() => {
    if (enemy.hp <= 0) return;
    const eDmg = Math.max(1, enemy.atk - player.def + Math.floor(Math.random() * 3));
    player.hp -= eDmg;
    addLog(`${enemy.name} hits you for ${eDmg}`, 'damage');

    // JUICE: Effects when player hit
    spawnFloatingNumber(player.x, player.y, `-${eDmg}`);
    spawnBlood(player.x, player.y, 4 + Math.floor(eDmg / 4));
    triggerShake(12 + eDmg);

    if (player.hp <= 0) {
      triggerShake(30); // Big shake on death
      gameOver();
    }
    updateStats();
  }, 300);
}

function gameOver() {
  gameStarted = false;
  document.getElementById('finalDepth').textContent = floor;
  document.getElementById('killCount').textContent = kills;
  document.getElementById('deathOverlay').classList.add('show');
  document.getElementById('enemyHealth').classList.remove('show');
}

function movePlayer() {
  if (path.length === 0) return;

  const next = path.shift();
  player.x = next.x;
  player.y = next.y;

  // Check for item pickup
  pickupItem(player.x, player.y);

  // Check for stairs
  if (stairPos && player.x === stairPos.x && player.y === stairPos.y) {
    floor++;
    addLog(`Descending to depth ${floor}...`, 'info');
    generateMap();
    player.x = 2;
    player.y = 2;
    player.mp = Math.min(player.maxMp, player.mp + 5);
    path = [];
    updateStats();
  }
}

function handleClick(e) {
  if (!gameStarted) return;

  const rect = canvas.getBoundingClientRect();
  const iso = screenToIso(e.clientX - rect.left, e.clientY - rect.top);

  // Check if clicking enemy
  const enemy = enemies.find(en => en.x === iso.x && en.y === iso.y && en.hp > 0);
  if (enemy) {
    // Check if adjacent
    const dx = Math.abs(player.x - enemy.x);
    const dy = Math.abs(player.y - enemy.y);
    if (dx + dy === 1) {
      attack(enemy);
      return;
    } else {
      // Path to adjacent tile
      const adjacent = [
        { x: enemy.x + 1, y: enemy.y },
        { x: enemy.x - 1, y: enemy.y },
        { x: enemy.x, y: enemy.y + 1 },
        { x: enemy.x, y: enemy.y - 1 }
      ].filter(p => isWalkable(p.x, p.y) && !enemies.some(e => e.x === p.x && e.y === p.y && e.hp > 0));

      if (adjacent.length > 0) {
        adjacent.sort((a, b) => {
          const da = Math.abs(a.x - player.x) + Math.abs(a.y - player.y);
          const db = Math.abs(b.x - player.x) + Math.abs(b.y - player.y);
          return da - db;
        });
        path = findPath(player.x, player.y, adjacent[0].x, adjacent[0].y);
        combatTarget = enemy;
      }
      return;
    }
  }

  // Regular movement
  if (isWalkable(iso.x, iso.y)) {
    path = findPath(player.x, player.y, iso.x, iso.y);
    combatTarget = null;
  }
}

function startGame() {
  document.getElementById('startOverlay').classList.remove('show');
  document.getElementById('deathOverlay').classList.remove('show');

  floor = 1;
  kills = 0;
  inventory = [{ type: 'hpot', qty: 3 }];

  player = {
    x: 2, y: 2,
    name: 'Wanderer',
    level: 1,
    hp: 50, maxHp: 50,
    mp: 20, maxMp: 20,
    xp: 0, xpNeeded: 30,
    atk: 8, def: 3,
    gold: 0
  };

  generateMap();
  updateStats();
  updateInventory();
  document.getElementById('combatLog').innerHTML = '';
  addLog('You enter the dungeon...', 'info');

  gameStarted = true;
}

let lastTime = 0;
let moveTimer = 0;

function gameLoop(time) {
  const dt = time - lastTime;
  lastTime = time;

  if (gameStarted) {
    moveTimer += dt;
    if (moveTimer > 150 && path.length > 0) {
      movePlayer();
      moveTimer = 0;

      // Auto-attack if reached combat target
      if (path.length === 0 && combatTarget && combatTarget.hp > 0) {
        const dx = Math.abs(player.x - combatTarget.x);
        const dy = Math.abs(player.y - combatTarget.y);
        if (dx + dy === 1) {
          attack(combatTarget);
        }
      }
    }
  }

  render();
  requestAnimationFrame(gameLoop);
}

// Event listeners
window.addEventListener('resize', resize);
canvas.addEventListener('click', handleClick);

document.addEventListener('keydown', e => {
  if (!gameStarted) return;

  // Number keys for inventory
  if (e.key >= '1' && e.key <= '4') {
    const idx = parseInt(e.key) - 1;
    if (idx < inventory.length) {
      useItem(idx);
    }
  }
});

// Initialize
resize();
prerenderSprites();
requestAnimationFrame(gameLoop);
</script>
</body>
</html>
