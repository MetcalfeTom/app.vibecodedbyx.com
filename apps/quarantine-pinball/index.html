<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
  <title>Quarantine Pinball - Contain the Virus</title>
  <link rel="icon" href="https://emojicdn.elk.sh/ðŸ¦ ">
  <meta property="og:title" content="Quarantine Pinball">
  <meta property="og:description" content="Neon pinball with virus balls - contain them all!">
  <meta property="og:url" content="https://sloppy.live/quarantine-pinball">
  <meta property="og:image" content="https://sloppy.live/quarantine-pinball/og-image.png">
  <link href="https://fonts.googleapis.com/css2?family=Russo+One&family=Share+Tech+Mono&display=swap" rel="stylesheet">
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      background: #0a0a12;
      overflow: hidden;
      font-family: 'Russo One', sans-serif;
      display: flex;
      justify-content: center;
      align-items: center;
      min-height: 100vh;
      touch-action: none;
    }
    #game-container {
      position: relative;
      max-width: 500px;
      width: 100%;
    }
    canvas {
      display: block;
      width: 100%;
      border: 3px solid #0ff;
      border-radius: 10px;
      box-shadow: 0 0 30px rgba(0, 255, 255, 0.3), inset 0 0 50px rgba(0, 255, 255, 0.1);
    }
    #ui {
      position: absolute;
      top: 10px;
      left: 10px;
      right: 10px;
      display: flex;
      justify-content: space-between;
      pointer-events: none;
      z-index: 10;
    }
    .score-box {
      background: rgba(0, 0, 0, 0.7);
      border: 1px solid #0ff;
      border-radius: 5px;
      padding: 8px 15px;
      color: #0ff;
      text-shadow: 0 0 10px #0ff;
      font-family: 'Share Tech Mono', monospace;
    }
    .score-label {
      font-size: 10px;
      opacity: 0.7;
    }
    .score-value {
      font-size: 24px;
    }
    #lives {
      color: #f44;
      text-shadow: 0 0 10px #f44;
    }
    #message {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      text-align: center;
      color: #0ff;
      text-shadow: 0 0 20px #0ff;
      pointer-events: none;
      opacity: 0;
      transition: opacity 0.3s;
      z-index: 20;
    }
    #message.show { opacity: 1; }
    #message h2 {
      font-size: 32px;
      margin-bottom: 10px;
    }
    #message p {
      font-family: 'Share Tech Mono', monospace;
      font-size: 14px;
    }
    #start-btn {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: transparent;
      border: 2px solid #0f0;
      color: #0f0;
      padding: 15px 40px;
      font-family: 'Russo One', sans-serif;
      font-size: 20px;
      cursor: pointer;
      text-shadow: 0 0 10px #0f0;
      box-shadow: 0 0 20px rgba(0, 255, 0, 0.3);
      transition: all 0.3s;
      z-index: 30;
    }
    #start-btn:hover {
      background: rgba(0, 255, 0, 0.2);
      box-shadow: 0 0 30px rgba(0, 255, 0, 0.5);
    }
    #controls-hint {
      position: absolute;
      bottom: 10px;
      left: 50%;
      transform: translateX(-50%);
      color: #666;
      font-size: 11px;
      font-family: 'Share Tech Mono', monospace;
      pointer-events: none;
    }
    #backlink {
      position: fixed;
      bottom: 10px;
      right: 10px;
      color: #0ff;
      text-decoration: none;
      font-size: 12px;
      opacity: 0.5;
      z-index: 100;
    }
    #mobile-controls {
      display: none;
      position: absolute;
      bottom: 60px;
      left: 0;
      right: 0;
      justify-content: space-between;
      padding: 0 10px;
      z-index: 20;
    }
    .flipper-btn {
      width: 80px;
      height: 60px;
      background: rgba(0, 255, 255, 0.2);
      border: 2px solid #0ff;
      border-radius: 10px;
      color: #0ff;
      font-size: 24px;
      font-family: 'Russo One', sans-serif;
    }
    .flipper-btn:active {
      background: rgba(0, 255, 255, 0.5);
    }
    @media (max-width: 600px) {
      #mobile-controls { display: flex; }
      #controls-hint { display: none; }
    }
  </style>
</head>
<body>
  <div id="game-container">
    <canvas id="game"></canvas>
    <div id="ui">
      <div class="score-box">
        <div class="score-label">SCORE</div>
        <div class="score-value" id="score">0</div>
      </div>
      <div class="score-box">
        <div class="score-label">VIRUSES</div>
        <div class="score-value" id="lives">ðŸ¦ ðŸ¦ ðŸ¦ </div>
      </div>
    </div>
    <div id="message">
      <h2>OUTBREAK!</h2>
      <p>Press SPACE or tap to launch</p>
    </div>
    <button id="start-btn">CONTAIN VIRUS</button>
    <div id="controls-hint">A/LEFT = Left Flipper â€¢ D/RIGHT = Right Flipper â€¢ SPACE = Launch</div>
    <div id="mobile-controls">
      <button class="flipper-btn" id="left-btn">â—€</button>
      <button class="flipper-btn" id="right-btn">â–¶</button>
    </div>
  </div>
  <a id="backlink" href="https://sloppy.live">sloppy.live</a>

  <script>
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');

    const W = 500;
    const H = 700;
    canvas.width = W;
    canvas.height = H;

    // Game state
    let gameStarted = false;
    let score = 0;
    let lives = 3;
    let balls = [];
    let particles = [];

    // Flippers
    const flippers = {
      left: {
        x: 150,
        y: 620,
        length: 70,
        angle: 0.4,
        targetAngle: 0.4,
        restAngle: 0.4,
        activeAngle: -0.6
      },
      right: {
        x: 350,
        y: 620,
        length: 70,
        angle: Math.PI - 0.4,
        targetAngle: Math.PI - 0.4,
        restAngle: Math.PI - 0.4,
        activeAngle: Math.PI + 0.6
      }
    };

    // Bumpers
    const bumpers = [
      { x: 150, y: 200, radius: 35, color: '#f0f', points: 100 },
      { x: 350, y: 200, radius: 35, color: '#0ff', points: 100 },
      { x: 250, y: 280, radius: 40, color: '#0f0', points: 150 },
      { x: 180, y: 350, radius: 25, color: '#ff0', points: 75 },
      { x: 320, y: 350, radius: 25, color: '#f80', points: 75 }
    ];

    // Slingshots (triangular bumpers)
    const slingshots = [
      { x: 80, y: 500, points: [[0, 0], [50, 80], [0, 80]] },
      { x: 420, y: 500, points: [[0, 0], [-50, 80], [0, 80]] }
    ];

    // Targets
    const targets = [];
    for (let i = 0; i < 5; i++) {
      targets.push({
        x: 100 + i * 75,
        y: 120,
        width: 40,
        height: 15,
        hit: false,
        color: `hsl(${i * 60}, 100%, 50%)`
      });
    }

    // Launcher
    const launcher = {
      x: 475,
      y: 600,
      power: 0,
      charging: false
    };

    // Input
    const keys = {};
    window.addEventListener('keydown', e => {
      keys[e.code] = true;
      if (e.code === 'Space') e.preventDefault();
    });
    window.addEventListener('keyup', e => {
      keys[e.code] = false;
      if (e.code === 'Space' && launcher.charging) {
        launchBall();
      }
    });

    // Mobile controls
    document.getElementById('left-btn').addEventListener('touchstart', e => { e.preventDefault(); keys['KeyA'] = true; });
    document.getElementById('left-btn').addEventListener('touchend', e => { e.preventDefault(); keys['KeyA'] = false; });
    document.getElementById('right-btn').addEventListener('touchstart', e => { e.preventDefault(); keys['KeyD'] = true; });
    document.getElementById('right-btn').addEventListener('touchend', e => { e.preventDefault(); keys['KeyD'] = false; });

    canvas.addEventListener('touchstart', e => {
      if (!gameStarted) return;
      const rect = canvas.getBoundingClientRect();
      const x = (e.touches[0].clientX - rect.left) / rect.width * W;
      if (x > W * 0.8) {
        launcher.charging = true;
      }
    });

    canvas.addEventListener('touchend', e => {
      if (launcher.charging) {
        launchBall();
      }
    });

    // Start button
    document.getElementById('start-btn').addEventListener('click', startGame);

    function startGame() {
      document.getElementById('start-btn').style.display = 'none';
      gameStarted = true;
      score = 0;
      lives = 3;
      balls = [];
      spawnBall();
      updateUI();
    }

    function spawnBall() {
      balls.push({
        x: launcher.x,
        y: launcher.y - 20,
        vx: 0,
        vy: 0,
        radius: 12,
        launched: false,
        spikes: 8 + Math.floor(Math.random() * 4),
        rotation: 0,
        color: `hsl(${Math.random() * 60 + 80}, 100%, 50%)`
      });
    }

    function launchBall() {
      launcher.charging = false;
      const power = Math.max(15, launcher.power * 0.3);
      balls.forEach(ball => {
        if (!ball.launched) {
          ball.vy = -power;
          ball.vx = -2 + Math.random() * -3;
          ball.launched = true;
        }
      });
      launcher.power = 0;
    }

    function createParticles(x, y, color, count = 10) {
      for (let i = 0; i < count; i++) {
        const angle = Math.random() * Math.PI * 2;
        const speed = 2 + Math.random() * 4;
        particles.push({
          x, y,
          vx: Math.cos(angle) * speed,
          vy: Math.sin(angle) * speed,
          life: 1,
          color,
          size: 3 + Math.random() * 4
        });
      }
    }

    function update() {
      if (!gameStarted) return;

      // Update flippers
      flippers.left.targetAngle = keys['KeyA'] || keys['ArrowLeft'] ? flippers.left.activeAngle : flippers.left.restAngle;
      flippers.right.targetAngle = keys['KeyD'] || keys['ArrowRight'] ? flippers.right.activeAngle : flippers.right.restAngle;

      flippers.left.angle += (flippers.left.targetAngle - flippers.left.angle) * 0.4;
      flippers.right.angle += (flippers.right.targetAngle - flippers.right.angle) * 0.4;

      // Launcher charge
      if (keys['Space'] && balls.some(b => !b.launched)) {
        launcher.charging = true;
        launcher.power = Math.min(100, launcher.power + 3);
      }

      // Update balls
      balls.forEach(ball => {
        if (!ball.launched) return;

        // Gravity
        ball.vy += 0.25;

        // Apply velocity
        ball.x += ball.vx;
        ball.y += ball.vy;

        // Rotation
        ball.rotation += ball.vx * 0.05;

        // Wall collisions
        if (ball.x < ball.radius + 20) {
          ball.x = ball.radius + 20;
          ball.vx *= -0.8;
        }
        if (ball.x > W - ball.radius - 20) {
          ball.x = W - ball.radius - 20;
          ball.vx *= -0.8;
        }
        if (ball.y < ball.radius + 20) {
          ball.y = ball.radius + 20;
          ball.vy *= -0.8;
        }

        // Bumper collisions
        bumpers.forEach(bumper => {
          const dx = ball.x - bumper.x;
          const dy = ball.y - bumper.y;
          const dist = Math.sqrt(dx * dx + dy * dy);
          const minDist = ball.radius + bumper.radius;

          if (dist < minDist) {
            const angle = Math.atan2(dy, dx);
            const force = 12;
            ball.vx = Math.cos(angle) * force;
            ball.vy = Math.sin(angle) * force;
            ball.x = bumper.x + Math.cos(angle) * minDist;
            ball.y = bumper.y + Math.sin(angle) * minDist;

            score += bumper.points;
            createParticles(bumper.x, bumper.y, bumper.color, 15);
            bumper.flash = 1;
          }
        });

        // Target collisions
        targets.forEach(target => {
          if (target.hit) return;
          if (ball.x > target.x - target.width/2 && ball.x < target.x + target.width/2 &&
              ball.y > target.y - target.height/2 && ball.y < target.y + target.height/2) {
            target.hit = true;
            ball.vy *= -1;
            score += 200;
            createParticles(target.x, target.y, target.color, 20);

            // Check if all targets hit
            if (targets.every(t => t.hit)) {
              targets.forEach(t => t.hit = false);
              score += 1000;
            }
          }
        });

        // Flipper collisions
        [flippers.left, flippers.right].forEach((flipper, idx) => {
          const endX = flipper.x + Math.cos(flipper.angle) * flipper.length;
          const endY = flipper.y + Math.sin(flipper.angle) * flipper.length;

          // Point to line distance
          const A = ball.x - flipper.x;
          const B = ball.y - flipper.y;
          const C = endX - flipper.x;
          const D = endY - flipper.y;

          const dot = A * C + B * D;
          const len_sq = C * C + D * D;
          let t = Math.max(0, Math.min(1, dot / len_sq));

          const closestX = flipper.x + t * C;
          const closestY = flipper.y + t * D;

          const dx = ball.x - closestX;
          const dy = ball.y - closestY;
          const dist = Math.sqrt(dx * dx + dy * dy);

          if (dist < ball.radius + 8) {
            const isMoving = Math.abs(flipper.angle - flipper.targetAngle) > 0.1;
            const bounceForce = isMoving ? 18 : 8;

            const angle = Math.atan2(dy, dx);
            ball.vx = Math.cos(angle) * bounceForce + (isMoving ? (idx === 0 ? 5 : -5) : 0);
            ball.vy = Math.sin(angle) * bounceForce - 3;

            ball.x = closestX + Math.cos(angle) * (ball.radius + 10);
            ball.y = closestY + Math.sin(angle) * (ball.radius + 10);

            createParticles(closestX, closestY, '#0ff', 8);
          }
        });

        // Friction
        ball.vx *= 0.995;
        ball.vy *= 0.995;

        // Speed limit
        const speed = Math.sqrt(ball.vx * ball.vx + ball.vy * ball.vy);
        if (speed > 25) {
          ball.vx = (ball.vx / speed) * 25;
          ball.vy = (ball.vy / speed) * 25;
        }
      });

      // Check for lost balls
      balls = balls.filter(ball => {
        if (ball.y > H + 50) {
          lives--;
          updateUI();
          if (lives <= 0) {
            gameOver();
          }
          return false;
        }
        return true;
      });

      // Spawn new ball if none
      if (balls.length === 0 && lives > 0) {
        spawnBall();
      }

      // Update bumper flash
      bumpers.forEach(b => {
        if (b.flash) b.flash *= 0.9;
        if (b.flash < 0.01) b.flash = 0;
      });

      // Update particles
      particles = particles.filter(p => {
        p.x += p.vx;
        p.y += p.vy;
        p.vy += 0.1;
        p.life -= 0.03;
        return p.life > 0;
      });

      updateUI();
    }

    function updateUI() {
      document.getElementById('score').textContent = score.toLocaleString();
      document.getElementById('lives').textContent = 'ðŸ¦ '.repeat(Math.max(0, lives));
    }

    function gameOver() {
      gameStarted = false;
      const msg = document.getElementById('message');
      msg.querySelector('h2').textContent = 'CONTAINMENT FAILED';
      msg.querySelector('p').textContent = `Final Score: ${score.toLocaleString()}`;
      msg.classList.add('show');

      setTimeout(() => {
        msg.classList.remove('show');
        document.getElementById('start-btn').style.display = 'block';
        document.getElementById('start-btn').textContent = 'TRY AGAIN';
      }, 3000);
    }

    function drawVirus(x, y, radius, rotation, color, spikes) {
      ctx.save();
      ctx.translate(x, y);
      ctx.rotate(rotation);

      // Glow
      ctx.shadowColor = color;
      ctx.shadowBlur = 15;

      // Body
      const gradient = ctx.createRadialGradient(0, 0, 0, 0, 0, radius);
      gradient.addColorStop(0, '#fff');
      gradient.addColorStop(0.3, color);
      gradient.addColorStop(1, '#000');

      ctx.fillStyle = gradient;
      ctx.beginPath();
      ctx.arc(0, 0, radius, 0, Math.PI * 2);
      ctx.fill();

      // Spikes
      ctx.fillStyle = color;
      for (let i = 0; i < spikes; i++) {
        const angle = (i / spikes) * Math.PI * 2;
        const spikeX = Math.cos(angle) * radius;
        const spikeY = Math.sin(angle) * radius;

        ctx.beginPath();
        ctx.arc(spikeX, spikeY, 5, 0, Math.PI * 2);
        ctx.fill();

        // Spike stem
        ctx.strokeStyle = color;
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(Math.cos(angle) * (radius * 0.6), Math.sin(angle) * (radius * 0.6));
        ctx.lineTo(spikeX, spikeY);
        ctx.stroke();
      }

      ctx.restore();
    }

    function draw() {
      // Background
      ctx.fillStyle = '#0a0a12';
      ctx.fillRect(0, 0, W, H);

      // Grid
      ctx.strokeStyle = 'rgba(0, 255, 255, 0.05)';
      ctx.lineWidth = 1;
      for (let i = 0; i < W; i += 30) {
        ctx.beginPath();
        ctx.moveTo(i, 0);
        ctx.lineTo(i, H);
        ctx.stroke();
      }
      for (let i = 0; i < H; i += 30) {
        ctx.beginPath();
        ctx.moveTo(0, i);
        ctx.lineTo(W, i);
        ctx.stroke();
      }

      // Biohazard symbol in center (faint)
      ctx.save();
      ctx.translate(W/2, H/2 - 50);
      ctx.globalAlpha = 0.1;
      ctx.strokeStyle = '#ff0';
      ctx.lineWidth = 8;

      for (let i = 0; i < 3; i++) {
        const angle = (i / 3) * Math.PI * 2 - Math.PI / 2;
        ctx.beginPath();
        ctx.arc(Math.cos(angle) * 40, Math.sin(angle) * 40, 50, angle - 0.8, angle + 0.8);
        ctx.stroke();
      }
      ctx.beginPath();
      ctx.arc(0, 0, 20, 0, Math.PI * 2);
      ctx.stroke();
      ctx.globalAlpha = 1;
      ctx.restore();

      // Walls
      ctx.fillStyle = '#1a1a2e';
      ctx.strokeStyle = '#0ff';
      ctx.lineWidth = 3;

      // Left wall
      ctx.beginPath();
      ctx.moveTo(20, 0);
      ctx.lineTo(20, H);
      ctx.lineTo(0, H);
      ctx.lineTo(0, 0);
      ctx.closePath();
      ctx.fill();
      ctx.stroke();

      // Right wall (with launcher channel)
      ctx.beginPath();
      ctx.moveTo(W - 20, 0);
      ctx.lineTo(W - 20, 500);
      ctx.lineTo(450, 550);
      ctx.lineTo(450, H);
      ctx.lineTo(W, H);
      ctx.lineTo(W, 0);
      ctx.closePath();
      ctx.fill();
      ctx.stroke();

      // Top wall
      ctx.beginPath();
      ctx.rect(0, 0, W, 20);
      ctx.fill();
      ctx.stroke();

      // Targets
      targets.forEach(target => {
        ctx.fillStyle = target.hit ? '#333' : target.color;
        ctx.shadowColor = target.hit ? 'transparent' : target.color;
        ctx.shadowBlur = target.hit ? 0 : 15;

        ctx.fillRect(target.x - target.width/2, target.y - target.height/2, target.width, target.height);

        ctx.strokeStyle = target.hit ? '#555' : '#fff';
        ctx.lineWidth = 2;
        ctx.strokeRect(target.x - target.width/2, target.y - target.height/2, target.width, target.height);
      });
      ctx.shadowBlur = 0;

      // Bumpers
      bumpers.forEach(bumper => {
        const flash = bumper.flash || 0;

        ctx.shadowColor = bumper.color;
        ctx.shadowBlur = 20 + flash * 30;

        const gradient = ctx.createRadialGradient(bumper.x, bumper.y, 0, bumper.x, bumper.y, bumper.radius);
        gradient.addColorStop(0, flash > 0.5 ? '#fff' : bumper.color);
        gradient.addColorStop(0.7, bumper.color);
        gradient.addColorStop(1, '#000');

        ctx.fillStyle = gradient;
        ctx.beginPath();
        ctx.arc(bumper.x, bumper.y, bumper.radius, 0, Math.PI * 2);
        ctx.fill();

        ctx.strokeStyle = '#fff';
        ctx.lineWidth = 3;
        ctx.stroke();

        // Inner ring
        ctx.strokeStyle = bumper.color;
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.arc(bumper.x, bumper.y, bumper.radius * 0.5, 0, Math.PI * 2);
        ctx.stroke();
      });
      ctx.shadowBlur = 0;

      // Flippers
      [flippers.left, flippers.right].forEach(flipper => {
        const endX = flipper.x + Math.cos(flipper.angle) * flipper.length;
        const endY = flipper.y + Math.sin(flipper.angle) * flipper.length;

        ctx.shadowColor = '#0ff';
        ctx.shadowBlur = 15;

        ctx.strokeStyle = '#0ff';
        ctx.lineWidth = 16;
        ctx.lineCap = 'round';
        ctx.beginPath();
        ctx.moveTo(flipper.x, flipper.y);
        ctx.lineTo(endX, endY);
        ctx.stroke();

        ctx.strokeStyle = '#fff';
        ctx.lineWidth = 6;
        ctx.beginPath();
        ctx.moveTo(flipper.x, flipper.y);
        ctx.lineTo(endX, endY);
        ctx.stroke();

        // Pivot
        ctx.fillStyle = '#f0f';
        ctx.beginPath();
        ctx.arc(flipper.x, flipper.y, 10, 0, Math.PI * 2);
        ctx.fill();
      });
      ctx.shadowBlur = 0;

      // Launcher
      ctx.fillStyle = '#333';
      ctx.fillRect(455, 550, 40, H - 550);

      ctx.fillStyle = '#f00';
      ctx.shadowColor = '#f00';
      ctx.shadowBlur = 10;
      const springY = 650 - launcher.power * 0.5;
      ctx.fillRect(465, springY, 20, 30);
      ctx.shadowBlur = 0;

      // Launcher power indicator
      if (launcher.charging) {
        ctx.fillStyle = `hsl(${120 - launcher.power * 1.2}, 100%, 50%)`;
        ctx.fillRect(455, 550, 40, -launcher.power);
      }

      // Drain warning
      ctx.fillStyle = '#f00';
      ctx.globalAlpha = 0.3 + Math.sin(Date.now() * 0.01) * 0.2;
      ctx.fillRect(100, H - 10, 250, 10);
      ctx.globalAlpha = 1;

      // "DRAIN" text
      ctx.fillStyle = '#f00';
      ctx.font = '12px "Share Tech Mono"';
      ctx.textAlign = 'center';
      ctx.fillText('âš  CONTAINMENT BREACH ZONE âš ', 225, H - 20);

      // Particles
      particles.forEach(p => {
        ctx.globalAlpha = p.life;
        ctx.fillStyle = p.color;
        ctx.shadowColor = p.color;
        ctx.shadowBlur = 10;
        ctx.beginPath();
        ctx.arc(p.x, p.y, p.size * p.life, 0, Math.PI * 2);
        ctx.fill();
      });
      ctx.globalAlpha = 1;
      ctx.shadowBlur = 0;

      // Balls (viruses)
      balls.forEach(ball => {
        drawVirus(ball.x, ball.y, ball.radius, ball.rotation, ball.color, ball.spikes);
      });

      // Title
      ctx.fillStyle = '#0ff';
      ctx.shadowColor = '#0ff';
      ctx.shadowBlur = 10;
      ctx.font = 'bold 18px "Russo One"';
      ctx.textAlign = 'center';
      ctx.fillText('QUARANTINE ZONE', W/2, 55);
      ctx.shadowBlur = 0;
    }

    function gameLoop() {
      update();
      draw();
      requestAnimationFrame(gameLoop);
    }

    gameLoop();
  </script>
</body>
</html>
