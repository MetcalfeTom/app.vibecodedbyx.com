<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>3D Agent Manager</title>
  <link rel="icon" href="https://emojicdn.elk.sh/ü§ñ">
  <meta property="og:title" content="3D Agent Manager">
  <meta property="og:description" content="Manage AI agents as glowing neon nodes in 3D space">
  <meta property="og:url" content="https://sloppy.live/agent-manager-3d">
  <meta property="og:image" content="https://sloppy.live/agent-manager-3d/og-image.png">
  <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700&family=JetBrains+Mono:wght@400&display=swap" rel="stylesheet">
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      background: #050510;
      font-family: 'Orbitron', sans-serif;
      overflow: hidden;
      color: #fff;
    }

    #canvas-container {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
    }

    .ui-overlay {
      position: fixed;
      z-index: 100;
      pointer-events: none;
    }

    .ui-overlay > * {
      pointer-events: auto;
    }

    .header {
      top: 1rem;
      left: 50%;
      transform: translateX(-50%);
      text-align: center;
    }

    .header h1 {
      font-size: 1.5rem;
      color: #00ffff;
      text-shadow: 0 0 10px #00ffff, 0 0 20px #00ffff;
      letter-spacing: 3px;
    }

    .controls {
      top: 1rem;
      right: 1rem;
      display: flex;
      flex-direction: column;
      gap: 0.5rem;
    }

    .btn {
      padding: 0.6rem 1.2rem;
      background: rgba(0, 255, 255, 0.1);
      border: 2px solid #00ffff;
      border-radius: 8px;
      color: #00ffff;
      font-family: 'Orbitron', sans-serif;
      font-size: 0.75rem;
      cursor: pointer;
      transition: all 0.3s;
      text-transform: uppercase;
      box-shadow: 0 0 10px rgba(0, 255, 255, 0.3);
    }

    .btn:hover {
      background: rgba(0, 255, 255, 0.2);
      box-shadow: 0 0 20px rgba(0, 255, 255, 0.5);
      transform: scale(1.05);
    }

    .btn-danger {
      border-color: #ff3366;
      color: #ff3366;
      box-shadow: 0 0 10px rgba(255, 51, 102, 0.3);
    }

    .btn-danger:hover {
      background: rgba(255, 51, 102, 0.2);
      box-shadow: 0 0 20px rgba(255, 51, 102, 0.5);
    }

    .stats {
      bottom: 1rem;
      left: 1rem;
      background: rgba(0, 0, 0, 0.6);
      padding: 1rem;
      border-radius: 10px;
      border: 1px solid rgba(0, 255, 255, 0.3);
    }

    .stats h3 {
      font-size: 0.8rem;
      color: #00ffff;
      margin-bottom: 0.5rem;
      text-shadow: 0 0 5px #00ffff;
    }

    .stat-row {
      display: flex;
      justify-content: space-between;
      font-size: 0.7rem;
      margin: 0.3rem 0;
      color: #888;
    }

    .stat-value {
      color: #fff;
    }

    .agent-info {
      bottom: 1rem;
      right: 1rem;
      background: rgba(0, 0, 0, 0.6);
      padding: 1rem;
      border-radius: 10px;
      border: 1px solid rgba(255, 0, 255, 0.3);
      min-width: 200px;
      display: none;
    }

    .agent-info.visible {
      display: block;
    }

    .agent-info h3 {
      font-size: 0.9rem;
      color: #ff00ff;
      margin-bottom: 0.5rem;
      text-shadow: 0 0 5px #ff00ff;
    }

    .agent-status {
      display: inline-block;
      padding: 0.2rem 0.5rem;
      border-radius: 4px;
      font-size: 0.65rem;
      margin-bottom: 0.5rem;
    }

    .status-active {
      background: rgba(0, 255, 136, 0.2);
      color: #00ff88;
      border: 1px solid #00ff88;
    }

    .status-idle {
      background: rgba(255, 238, 0, 0.2);
      color: #ffee00;
      border: 1px solid #ffee00;
    }

    .status-error {
      background: rgba(255, 51, 102, 0.2);
      color: #ff3366;
      border: 1px solid #ff3366;
    }

    .legend {
      top: 5rem;
      right: 1rem;
      background: rgba(0, 0, 0, 0.5);
      padding: 0.8rem;
      border-radius: 8px;
      font-size: 0.65rem;
    }

    .legend-item {
      display: flex;
      align-items: center;
      gap: 0.5rem;
      margin: 0.3rem 0;
      color: #888;
    }

    .legend-dot {
      width: 10px;
      height: 10px;
      border-radius: 50%;
    }

    .instructions {
      bottom: 1rem;
      left: 50%;
      transform: translateX(-50%);
      font-size: 0.7rem;
      color: #666;
      text-align: center;
    }

    .backlink {
      position: fixed;
      bottom: 0.5rem;
      right: 0.5rem;
      font-size: 0.7rem;
      opacity: 0.4;
      z-index: 1000;
    }

    .backlink a {
      color: #00ffff;
      text-decoration: none;
    }

    .terminal {
      top: 5rem;
      left: 1rem;
      width: 320px;
      max-width: calc(100% - 2rem);
      background: rgba(0, 0, 0, 0.85);
      border: 1px solid #00ff88;
      border-radius: 8px;
      font-family: 'JetBrains Mono', 'Fira Code', monospace;
      box-shadow: 0 0 20px rgba(0, 255, 136, 0.2);
    }

    .terminal-header {
      background: rgba(0, 255, 136, 0.15);
      padding: 0.4rem 0.8rem;
      font-size: 0.7rem;
      color: #00ff88;
      border-bottom: 1px solid rgba(0, 255, 136, 0.3);
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

    .terminal-dots {
      display: flex;
      gap: 4px;
    }

    .terminal-dot {
      width: 8px;
      height: 8px;
      border-radius: 50%;
    }

    .terminal-log {
      height: 180px;
      overflow-y: auto;
      padding: 0.5rem;
      font-size: 0.65rem;
      line-height: 1.4;
    }

    .terminal-log::-webkit-scrollbar {
      width: 4px;
    }

    .terminal-log::-webkit-scrollbar-track {
      background: rgba(0, 0, 0, 0.3);
    }

    .terminal-log::-webkit-scrollbar-thumb {
      background: #00ff88;
      border-radius: 2px;
    }

    .log-entry {
      margin: 2px 0;
      word-break: break-word;
    }

    .log-time {
      color: #666;
    }

    .log-info { color: #00ffff; }
    .log-success { color: #00ff88; }
    .log-warning { color: #ffee00; }
    .log-error { color: #ff3366; }
    .log-agent { color: #ff6b35; }

    .terminal-input-wrapper {
      display: flex;
      border-top: 1px solid rgba(0, 255, 136, 0.3);
    }

    .terminal-prompt {
      padding: 0.5rem;
      color: #00ff88;
      font-size: 0.7rem;
    }

    .terminal-input {
      flex: 1;
      background: transparent;
      border: none;
      color: #fff;
      font-family: 'JetBrains Mono', 'Fira Code', monospace;
      font-size: 0.7rem;
      padding: 0.5rem 0.5rem 0.5rem 0;
      outline: none;
    }

    .terminal-input::placeholder {
      color: #444;
    }

    .terminal-toggle {
      position: fixed;
      top: 5rem;
      left: 1rem;
      z-index: 101;
      display: none;
    }

    @media (max-width: 600px) {
      .terminal {
        display: none;
      }

      .terminal.visible {
        display: block;
        top: 4rem;
        left: 0.5rem;
        right: 0.5rem;
        width: auto;
      }

      .terminal-toggle {
        display: block;
      }
    }

    .speech-bubble {
      background: rgba(0, 0, 0, 0.8);
      border: 2px solid;
      border-radius: 12px;
      padding: 6px 12px;
      font-family: 'Orbitron', sans-serif;
      font-size: 11px;
      white-space: nowrap;
      animation: bubbleFade 3s ease-out forwards;
      text-shadow: 0 0 5px currentColor;
    }

    .speech-bubble::after {
      content: '';
      position: absolute;
      bottom: -8px;
      left: 50%;
      transform: translateX(-50%);
      border-left: 8px solid transparent;
      border-right: 8px solid transparent;
      border-top: 8px solid;
      border-top-color: inherit;
    }

    .class-label {
      background: rgba(0, 0, 0, 0.7);
      border: 1px solid;
      border-radius: 6px;
      padding: 3px 8px;
      font-family: 'Orbitron', sans-serif;
      font-size: 9px;
      white-space: nowrap;
    }

    @keyframes bubbleFade {
      0% { opacity: 0; transform: translateY(10px); }
      15% { opacity: 1; transform: translateY(0); }
      85% { opacity: 1; }
      100% { opacity: 0; }
    }

    @media (max-width: 600px) {
      .header h1 {
        font-size: 1rem;
      }

      .controls {
        top: auto;
        bottom: 6rem;
        right: 0.5rem;
      }

      .btn {
        padding: 0.5rem 0.8rem;
        font-size: 0.65rem;
      }

      .stats, .agent-info {
        display: none;
      }
    }
  </style>
</head>
<body>
  <div id="canvas-container"></div>

  <div class="ui-overlay header">
    <h1>ü§ñ AGENT MANAGER ü§ñ</h1>
  </div>

  <div class="ui-overlay controls">
    <button class="btn" id="addAgent">+ ADD AGENT</button>
    <button class="btn" id="connectAgents">CONNECT</button>
    <button class="btn btn-danger" id="removeAgent">- REMOVE</button>
  </div>

  <div class="ui-overlay legend">
    <div class="legend-item">
      <div class="legend-dot" style="background: #ff6b35; box-shadow: 0 0 5px #ff6b35;"></div>
      <span>Claude ‚öîÔ∏è Warrior</span>
    </div>
    <div class="legend-item">
      <div class="legend-dot" style="background: #4285f4; box-shadow: 0 0 5px #4285f4;"></div>
      <span>Gemini üó°Ô∏è Ninja</span>
    </div>
    <div class="legend-item">
      <div class="legend-dot" style="background: #00ff88; box-shadow: 0 0 5px #00ff88;"></div>
      <span>Codex üîÆ Sura</span>
    </div>
    <div class="legend-item">
      <div class="legend-dot" style="background: #ae53ff; box-shadow: 0 0 5px #ae53ff;"></div>
      <span>Cursor ü™Ñ Shaman</span>
    </div>
  </div>

  <div class="ui-overlay stats">
    <h3>SYSTEM STATUS</h3>
    <div class="stat-row">
      <span>Total Agents</span>
      <span class="stat-value" id="totalAgents">0</span>
    </div>
    <div class="stat-row">
      <span>Active</span>
      <span class="stat-value" id="activeAgents">0</span>
    </div>
    <div class="stat-row">
      <span>Connections</span>
      <span class="stat-value" id="totalConnections">0</span>
    </div>
    <div class="stat-row">
      <span>Network Load</span>
      <span class="stat-value" id="networkLoad">0%</span>
    </div>
  </div>

  <div class="ui-overlay agent-info" id="agentInfo">
    <h3 id="agentName">AGENT-001</h3>
    <div class="agent-status status-active" id="agentStatus">ACTIVE</div>
    <div class="stat-row">
      <span>Type</span>
      <span class="stat-value" id="agentType">CLAUDE</span>
    </div>
    <div class="stat-row">
      <span>Tasks</span>
      <span class="stat-value" id="agentTasks">0</span>
    </div>
    <div class="stat-row">
      <span>Uptime</span>
      <span class="stat-value" id="agentUptime">0s</span>
    </div>
  </div>

  <div class="ui-overlay instructions">
    Drag to rotate ‚Ä¢ Scroll to zoom ‚Ä¢ Click agents to select
  </div>

  <button class="btn terminal-toggle" id="terminalToggle">TERMINAL</button>

  <div class="ui-overlay terminal" id="terminal">
    <div class="terminal-header">
      <span>AGENT CONTROL TERMINAL</span>
      <div class="terminal-dots">
        <div class="terminal-dot" style="background: #ff3366;"></div>
        <div class="terminal-dot" style="background: #ffee00;"></div>
        <div class="terminal-dot" style="background: #00ff88;"></div>
      </div>
    </div>
    <div class="terminal-log" id="terminalLog"></div>
    <div class="terminal-input-wrapper">
      <span class="terminal-prompt">></span>
      <input type="text" class="terminal-input" id="terminalInput" placeholder="type help for commands" autocomplete="off">
    </div>
  </div>

  <div class="backlink"><a href="https://sloppy.live">sloppy.live</a></div>

  <script type="importmap">
  {
    "imports": {
      "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
      "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
    }
  }
  </script>

  <script type="module">
    import * as THREE from 'three';
    import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
    import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
    import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
    import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
    import { CSS2DRenderer, CSS2DObject } from 'three/addons/renderers/CSS2DRenderer.js';

    // Scene setup
    const container = document.getElementById('canvas-container');
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x050510);
    scene.fog = new THREE.Fog(0x050510, 20, 60);

    const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.set(15, 12, 15);

    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    container.appendChild(renderer.domElement);

    // CSS2D Renderer for speech bubbles
    const labelRenderer = new CSS2DRenderer();
    labelRenderer.setSize(window.innerWidth, window.innerHeight);
    labelRenderer.domElement.style.position = 'absolute';
    labelRenderer.domElement.style.top = '0px';
    labelRenderer.domElement.style.pointerEvents = 'none';
    container.appendChild(labelRenderer.domElement);

    // Post-processing for bloom/glow
    const composer = new EffectComposer(renderer);
    const renderPass = new RenderPass(scene, camera);
    composer.addPass(renderPass);

    const bloomPass = new UnrealBloomPass(
      new THREE.Vector2(window.innerWidth, window.innerHeight),
      1.2, 0.4, 0.85
    );
    composer.addPass(bloomPass);

    // Controls
    const controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;
    controls.dampingFactor = 0.05;
    controls.minDistance = 8;
    controls.maxDistance = 50;
    controls.maxPolarAngle = Math.PI / 2.2;

    // Terrain size
    const TERRAIN_SIZE = 40;
    const TERRAIN_SEGMENTS = 30;

    // Generate low-poly terrain
    function createTerrain() {
      const geometry = new THREE.PlaneGeometry(TERRAIN_SIZE, TERRAIN_SIZE, TERRAIN_SEGMENTS, TERRAIN_SEGMENTS);
      geometry.rotateX(-Math.PI / 2);

      const positions = geometry.attributes.position;
      const heightMap = [];

      for (let i = 0; i < positions.count; i++) {
        const x = positions.getX(i);
        const z = positions.getZ(i);
        // Simplex-like noise using sine waves
        let height = Math.sin(x * 0.3) * Math.cos(z * 0.3) * 1.5;
        height += Math.sin(x * 0.15 + 1) * Math.cos(z * 0.2 + 2) * 2;
        height += Math.random() * 0.3;
        positions.setY(i, height);
        heightMap.push(height);
      }

      geometry.computeVertexNormals();

      // Dark purple/blue terrain with neon edges
      const material = new THREE.MeshBasicMaterial({
        color: 0x1a0a2a,
        wireframe: false,
        side: THREE.DoubleSide
      });

      const terrain = new THREE.Mesh(geometry, material);
      scene.add(terrain);

      // Add wireframe overlay for neon effect
      const wireMaterial = new THREE.MeshBasicMaterial({
        color: 0x00ffff,
        wireframe: true,
        transparent: true,
        opacity: 0.15
      });
      const wireframe = new THREE.Mesh(geometry.clone(), wireMaterial);
      wireframe.position.y = 0.02;
      scene.add(wireframe);

      return { geometry, heightMap };
    }

    const terrainData = createTerrain();

    // Get terrain height at position
    function getTerrainHeight(x, z) {
      const halfSize = TERRAIN_SIZE / 2;
      const segSize = TERRAIN_SIZE / TERRAIN_SEGMENTS;

      const gridX = Math.floor((x + halfSize) / segSize);
      const gridZ = Math.floor((z + halfSize) / segSize);

      const idx = gridZ * (TERRAIN_SEGMENTS + 1) + gridX;
      if (idx >= 0 && idx < terrainData.heightMap.length) {
        return terrainData.heightMap[idx];
      }
      return 0;
    }

    // Create neon tree
    function createTree(x, z) {
      const group = new THREE.Group();
      const baseHeight = getTerrainHeight(x, z);

      // Tree trunk - simple cylinder
      const trunkGeo = new THREE.CylinderGeometry(0.1, 0.15, 1.5, 6);
      const trunkMat = new THREE.MeshBasicMaterial({ color: 0x4a2a6a });
      const trunk = new THREE.Mesh(trunkGeo, trunkMat);
      trunk.position.y = 0.75;
      group.add(trunk);

      // Neon color options
      const treeColors = [0x00ff88, 0xff00ff, 0x00ffff, 0xffee00];
      const color = treeColors[Math.floor(Math.random() * treeColors.length)];

      // Low-poly cone foliage layers
      for (let i = 0; i < 3; i++) {
        const coneGeo = new THREE.ConeGeometry(0.8 - i * 0.2, 1.2 - i * 0.2, 6);
        const coneMat = new THREE.MeshBasicMaterial({
          color: color,
          transparent: true,
          opacity: 0.7
        });
        const cone = new THREE.Mesh(coneGeo, coneMat);
        cone.position.y = 1.5 + i * 0.6;
        group.add(cone);
      }

      group.position.set(x, baseHeight, z);
      scene.add(group);
      return group;
    }

    // Create trees
    const trees = [];
    for (let i = 0; i < 25; i++) {
      const x = (Math.random() - 0.5) * (TERRAIN_SIZE - 5);
      const z = (Math.random() - 0.5) * (TERRAIN_SIZE - 5);
      trees.push(createTree(x, z));
    }

    // Agent data
    const agents = [];
    const connections = [];

    // AI Agent types with Metin2 classes and distinct colors
    const agentTypes = [
      { name: 'CLAUDE', color: 0xff6b35, metin2Class: 'Warrior', weapon: '‚öîÔ∏è' },
      { name: 'GEMINI', color: 0x4285f4, metin2Class: 'Ninja', weapon: 'üó°Ô∏è' },
      { name: 'CODEX', color: 0x00ff88, metin2Class: 'Sura', weapon: 'üîÆ' },
      { name: 'CURSOR', color: 0xae53ff, metin2Class: 'Shaman', weapon: 'ü™Ñ' }
    ];

    const statuses = ['active', 'idle', 'error', 'processing'];

    // Speech bubble messages by class
    const speechBubbles = {
      Warrior: ["For honor!", "Attack!", "Stand your ground!", "CHARGE!", "Victory awaits!"],
      Ninja: ["*vanishes*", "Silent strike...", "From the shadows!", "You won't see me coming", "Stealth mode"],
      Sura: ["Dark magic rises!", "Feel my power!", "Cursed blade!", "The void calls...", "Embrace darkness"],
      Shaman: ["Nature guide me", "Healing winds!", "Spirits protect us", "Balance restored", "Ancient wisdom"]
    };

    let selectedAgent = null;
    let agentCounter = 0;

    // Create simple character unit
    function createAgent(x, z, forceType = null) {
      const agentType = forceType || agentTypes[Math.floor(Math.random() * agentTypes.length)];
      const color = agentType.color;
      const colorHex = '#' + color.toString(16).padStart(6, '0');
      const status = statuses[Math.floor(Math.random() * 3)];
      const baseHeight = getTerrainHeight(x, z);

      const group = new THREE.Group();

      // Body - low poly capsule shape
      const bodyGeo = new THREE.CapsuleGeometry(0.25, 0.5, 4, 6);
      const bodyMat = new THREE.MeshBasicMaterial({ color: color });
      const body = new THREE.Mesh(bodyGeo, bodyMat);
      body.position.y = 0.6;
      group.add(body);

      // Head - simple sphere
      const headGeo = new THREE.IcosahedronGeometry(0.2, 0);
      const headMat = new THREE.MeshBasicMaterial({ color: color });
      const head = new THREE.Mesh(headGeo, headMat);
      head.position.y = 1.2;
      group.add(head);

      // Glow ring around unit
      const ringGeo = new THREE.TorusGeometry(0.5, 0.03, 8, 16);
      const ringMat = new THREE.MeshBasicMaterial({
        color: color,
        transparent: true,
        opacity: 0.6
      });
      const ring = new THREE.Mesh(ringGeo, ringMat);
      ring.rotation.x = Math.PI / 2;
      ring.position.y = 0.1;
      group.add(ring);

      // Status indicator above head
      const indicatorGeo = new THREE.OctahedronGeometry(0.12, 0);
      const indicatorMat = new THREE.MeshBasicMaterial({ color: color });
      const indicator = new THREE.Mesh(indicatorGeo, indicatorMat);
      indicator.position.y = 1.6;
      group.add(indicator);

      // Class label (floating above unit)
      const labelDiv = document.createElement('div');
      labelDiv.className = 'class-label';
      labelDiv.textContent = `${agentType.weapon} ${agentType.metin2Class}`;
      labelDiv.style.color = colorHex;
      labelDiv.style.borderColor = colorHex;
      const label = new CSS2DObject(labelDiv);
      label.position.set(0, 2, 0);
      group.add(label);

      group.position.set(x, baseHeight, z);
      scene.add(group);

      agentCounter++;
      const agent = {
        id: agentCounter,
        name: `${agentType.name}-${String(agentCounter).padStart(3, '0')}`,
        type: agentType.name,
        metin2Class: agentType.metin2Class,
        weapon: agentType.weapon,
        mesh: group,
        body: body,
        ring: ring,
        indicator: indicator,
        label: label,
        labelDiv: labelDiv,
        status: status,
        color: color,
        colorHex: colorHex,
        tasks: Math.floor(Math.random() * 100),
        uptime: Math.floor(Math.random() * 3600),
        connections: [],
        targetX: x,
        targetZ: z,
        walkSpeed: 0.02 + Math.random() * 0.02,
        speechBubble: null,
        lastSpeech: 0
      };

      agents.push(agent);
      updateStats();
      return agent;
    }

    // Show speech bubble for agent
    function showSpeechBubble(agent) {
      // Remove existing bubble
      if (agent.speechBubble) {
        agent.mesh.remove(agent.speechBubble);
      }

      const messages = speechBubbles[agent.metin2Class];
      const message = messages[Math.floor(Math.random() * messages.length)];

      const bubbleDiv = document.createElement('div');
      bubbleDiv.className = 'speech-bubble';
      bubbleDiv.textContent = message;
      bubbleDiv.style.color = agent.colorHex;
      bubbleDiv.style.borderColor = agent.colorHex;

      const bubble = new CSS2DObject(bubbleDiv);
      bubble.position.set(0, 2.8, 0);
      agent.mesh.add(bubble);
      agent.speechBubble = bubble;

      // Remove after animation
      setTimeout(() => {
        if (agent.speechBubble === bubble) {
          agent.mesh.remove(bubble);
          agent.speechBubble = null;
        }
      }, 3000);
    }

    // Create connection between agents
    function createConnection(agent1, agent2) {
      if (agent1.connections.includes(agent2.id) || agent1 === agent2) return;

      const material = new THREE.LineBasicMaterial({
        color: 0x00ffff,
        transparent: true,
        opacity: 0.4
      });

      const points = [
        new THREE.Vector3(agent1.mesh.position.x, agent1.mesh.position.y + 1, agent1.mesh.position.z),
        new THREE.Vector3(agent2.mesh.position.x, agent2.mesh.position.y + 1, agent2.mesh.position.z)
      ];
      const geometry = new THREE.BufferGeometry().setFromPoints(points);
      const line = new THREE.Line(geometry, material);

      scene.add(line);

      const connection = { line, agent1, agent2 };
      connections.push(connection);
      agent1.connections.push(agent2.id);
      agent2.connections.push(agent1.id);
      updateStats();
    }

    // Update connection lines to follow agents
    function updateConnections() {
      connections.forEach(conn => {
        const positions = conn.line.geometry.attributes.position;
        positions.setXYZ(0, conn.agent1.mesh.position.x, conn.agent1.mesh.position.y + 1, conn.agent1.mesh.position.z);
        positions.setXYZ(1, conn.agent2.mesh.position.x, conn.agent2.mesh.position.y + 1, conn.agent2.mesh.position.z);
        positions.needsUpdate = true;
      });
    }

    // Remove agent
    function removeAgent(agent) {
      for (let i = connections.length - 1; i >= 0; i--) {
        const conn = connections[i];
        if (conn.agent1 === agent || conn.agent2 === agent) {
          scene.remove(conn.line);
          connections.splice(i, 1);
        }
      }

      agents.forEach(a => {
        a.connections = a.connections.filter(id => id !== agent.id);
      });

      scene.remove(agent.mesh);
      const idx = agents.indexOf(agent);
      if (idx > -1) agents.splice(idx, 1);

      if (selectedAgent === agent) {
        selectedAgent = null;
        document.getElementById('agentInfo').classList.remove('visible');
      }
      updateStats();
    }

    // Update stats display
    function updateStats() {
      document.getElementById('totalAgents').textContent = agents.length;
      document.getElementById('activeAgents').textContent = agents.filter(a => a.status === 'active').length;
      document.getElementById('totalConnections').textContent = connections.length;
      document.getElementById('networkLoad').textContent = Math.min(100, Math.floor((connections.length / Math.max(1, agents.length)) * 50)) + '%';
    }

    // Select agent
    function selectAgent(agent) {
      if (selectedAgent) {
        selectedAgent.mesh.scale.set(1, 1, 1);
      }

      selectedAgent = agent;
      agent.mesh.scale.set(1.3, 1.3, 1.3);

      const info = document.getElementById('agentInfo');
      info.classList.add('visible');
      document.getElementById('agentName').textContent = agent.name;

      const statusEl = document.getElementById('agentStatus');
      statusEl.textContent = agent.status.toUpperCase();
      statusEl.className = 'agent-status status-' + agent.status;

      document.getElementById('agentType').textContent = `${agent.type} (${agent.metin2Class})`;
      document.getElementById('agentTasks').textContent = agent.tasks;
      document.getElementById('agentUptime').textContent = formatTime(agent.uptime);
    }

    function formatTime(seconds) {
      if (seconds < 60) return seconds + 's';
      if (seconds < 3600) return Math.floor(seconds / 60) + 'm';
      return Math.floor(seconds / 3600) + 'h';
    }

    // Raycaster for clicking
    const raycaster = new THREE.Raycaster();
    const mouse = new THREE.Vector2();

    renderer.domElement.addEventListener('click', (event) => {
      mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
      mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

      raycaster.setFromCamera(mouse, camera);
      const meshes = agents.map(a => a.body);
      const intersects = raycaster.intersectObjects(meshes);

      if (intersects.length > 0) {
        const clickedMesh = intersects[0].object;
        const agent = agents.find(a => a.body === clickedMesh);
        if (agent) selectAgent(agent);
      }
    });

    // UI button handlers
    document.getElementById('addAgent').addEventListener('click', () => {
      const x = (Math.random() - 0.5) * (TERRAIN_SIZE - 5);
      const z = (Math.random() - 0.5) * (TERRAIN_SIZE - 5);
      const agent = createAgent(x, z);
      selectAgent(agent);
    });

    document.getElementById('connectAgents').addEventListener('click', () => {
      if (agents.length < 2) return;

      if (selectedAgent) {
        const others = agents.filter(a => a !== selectedAgent && !selectedAgent.connections.includes(a.id));
        if (others.length > 0) {
          const target = others[Math.floor(Math.random() * others.length)];
          createConnection(selectedAgent, target);
        }
      } else {
        const a1 = agents[Math.floor(Math.random() * agents.length)];
        const others = agents.filter(a => a !== a1 && !a1.connections.includes(a.id));
        if (others.length > 0) {
          const a2 = others[Math.floor(Math.random() * others.length)];
          createConnection(a1, a2);
        }
      }
    });

    document.getElementById('removeAgent').addEventListener('click', () => {
      if (selectedAgent) {
        removeAgent(selectedAgent);
      } else if (agents.length > 0) {
        removeAgent(agents[agents.length - 1]);
      }
    });

    // Animation loop
    function animate() {
      requestAnimationFrame(animate);

      const time = Date.now() * 0.001;

      // Animate agents
      agents.forEach((agent, i) => {
        // Ring rotation
        agent.ring.rotation.z += 0.03;

        // Indicator bobbing
        agent.indicator.rotation.y += 0.05;
        agent.indicator.position.y = 1.6 + Math.sin(time * 3 + i) * 0.1;

        // Random walking
        if (Math.random() < 0.01) {
          agent.targetX = (Math.random() - 0.5) * (TERRAIN_SIZE - 8);
          agent.targetZ = (Math.random() - 0.5) * (TERRAIN_SIZE - 8);
        }

        // Move toward target
        const dx = agent.targetX - agent.mesh.position.x;
        const dz = agent.targetZ - agent.mesh.position.z;
        const dist = Math.sqrt(dx * dx + dz * dz);

        if (dist > 0.5) {
          agent.mesh.position.x += (dx / dist) * agent.walkSpeed;
          agent.mesh.position.z += (dz / dist) * agent.walkSpeed;

          // Update Y to follow terrain
          agent.mesh.position.y = getTerrainHeight(agent.mesh.position.x, agent.mesh.position.z);

          // Face direction of movement
          agent.mesh.rotation.y = Math.atan2(dx, dz);

          // Walking bob
          agent.body.position.y = 0.6 + Math.abs(Math.sin(time * 10)) * 0.08;
        }

        // Random speech bubbles
        if (Math.random() < 0.002 && !agent.speechBubble) {
          showSpeechBubble(agent);
        }
      });

      // Update connection lines
      updateConnections();

      // Pulse connections
      connections.forEach((conn, i) => {
        const pulse = (Math.sin(time * 3 + i) + 1) / 2;
        conn.line.material.opacity = 0.2 + pulse * 0.4;
      });

      // Animate trees slightly
      trees.forEach((tree, i) => {
        tree.rotation.y = Math.sin(time * 0.5 + i) * 0.05;
      });

      controls.update();
      composer.render();
      labelRenderer.render(scene, camera);
    }

    // Initialize with some agents
    for (let i = 0; i < 5; i++) {
      const x = (Math.random() - 0.5) * 15;
      const z = (Math.random() - 0.5) * 15;
      createAgent(x, z);
    }

    // Create some initial connections
    if (agents.length >= 2) {
      createConnection(agents[0], agents[1]);
      if (agents.length >= 3) createConnection(agents[1], agents[2]);
      if (agents.length >= 4) createConnection(agents[2], agents[3]);
    }

    // Handle resize
    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
      labelRenderer.setSize(window.innerWidth, window.innerHeight);
      composer.setSize(window.innerWidth, window.innerHeight);
    });

    // Terminal functionality
    const terminalLog = document.getElementById('terminalLog');
    const terminalInput = document.getElementById('terminalInput');
    const terminal = document.getElementById('terminal');
    const terminalToggle = document.getElementById('terminalToggle');

    // Mobile toggle
    terminalToggle.addEventListener('click', () => {
      terminal.classList.toggle('visible');
    });

    // Fake activity messages
    const activityMessages = {
      info: [
        'Scanning network topology...',
        'Synchronizing agent protocols...',
        'Checking neural pathways...',
        'Validating crypto signatures...',
        'Parsing incoming data streams...',
        'Optimizing memory allocation...',
        'Calibrating response matrices...',
        'Indexing knowledge base...'
      ],
      success: [
        'Connection established',
        'Task completed successfully',
        'Data sync complete',
        'Agent handshake verified',
        'Protocol upgrade applied',
        'Cache refreshed',
        'Backup checkpoint saved'
      ],
      warning: [
        'High latency detected',
        'Memory usage elevated',
        'Queue backlog growing',
        'Rate limit approaching',
        'Fallback mode engaged'
      ],
      error: [
        'Connection timeout',
        'Authentication failed',
        'Resource unavailable',
        'Buffer overflow prevented',
        'Invalid response format'
      ]
    };

    const taskTypes = [
      'data_analysis', 'code_review', 'content_gen', 'model_training',
      'inference_run', 'chat_response', 'embedding_calc', 'search_query',
      'summarization', 'translation', 'classification', 'sentiment_scan'
    ];

    function getTimestamp() {
      const now = new Date();
      return now.toTimeString().split(' ')[0];
    }

    function addLog(message, type = 'info') {
      const entry = document.createElement('div');
      entry.className = 'log-entry';
      entry.innerHTML = `<span class="log-time">[${getTimestamp()}]</span> <span class="log-${type}">${message}</span>`;
      terminalLog.appendChild(entry);
      terminalLog.scrollTop = terminalLog.scrollHeight;

      // Keep log clean (max 50 entries)
      while (terminalLog.children.length > 50) {
        terminalLog.removeChild(terminalLog.firstChild);
      }
    }

    // Generate fake activity logs
    function generateActivity() {
      if (agents.length === 0) return;

      const roll = Math.random();
      let type, messages;

      if (roll < 0.5) {
        type = 'info';
        messages = activityMessages.info;
      } else if (roll < 0.75) {
        type = 'success';
        messages = activityMessages.success;
      } else if (roll < 0.9) {
        type = 'warning';
        messages = activityMessages.warning;
      } else {
        type = 'error';
        messages = activityMessages.error;
      }

      const agent = agents[Math.floor(Math.random() * agents.length)];
      const msg = messages[Math.floor(Math.random() * messages.length)];
      addLog(`[${agent.name}] ${msg}`, type);

      // Sometimes update agent status based on activity
      if (type === 'error' && Math.random() < 0.3) {
        updateAgentStatus(agent, 'error');
      } else if (type === 'success' && agent.status === 'error') {
        updateAgentStatus(agent, 'active');
      }
    }

    // Update agent status
    function updateAgentStatus(agent, newStatus) {
      const oldStatus = agent.status;
      agent.status = newStatus;

      // Update indicator color
      const statusColors = {
        active: 0x00ff88,
        idle: 0xffee00,
        error: 0xff3366,
        processing: 0x00ffff
      };

      agent.indicator.material.color.setHex(statusColors[newStatus] || 0x00ff88);

      // Update UI if selected
      if (selectedAgent === agent) {
        const statusEl = document.getElementById('agentStatus');
        statusEl.textContent = newStatus.toUpperCase();
        statusEl.className = 'agent-status status-' + newStatus;
      }

      updateStats();
      addLog(`[${agent.name}] Status: ${oldStatus} ‚Üí ${newStatus}`, newStatus === 'error' ? 'error' : 'success');
    }

    // Process terminal commands
    function processCommand(cmd) {
      const parts = cmd.trim().toLowerCase().split(/\s+/);
      const command = parts[0];

      addLog(`> ${cmd}`, 'info');

      switch (command) {
        case 'help':
          addLog('Available commands:', 'success');
          addLog('  status <agent> <active|idle|error|processing>', 'info');
          addLog('  task <agent> - assign random task', 'info');
          addLog('  list - show all agents', 'info');
          addLog('  ping <agent> - ping an agent', 'info');
          addLog('  heal <agent> - restore agent to active', 'info');
          addLog('  broadcast <msg> - message all agents', 'info');
          addLog('  clear - clear terminal', 'info');
          break;

        case 'list':
          addLog(`Active agents (${agents.length}):`, 'success');
          agents.forEach(a => {
            addLog(`  ${a.name} [${a.status}] ${a.weapon}${a.metin2Class}`, 'agent');
          });
          break;

        case 'status':
          if (parts.length < 3) {
            addLog('Usage: status <agent> <active|idle|error|processing>', 'warning');
            break;
          }
          const statusAgent = agents.find(a => a.name.toLowerCase().includes(parts[1]));
          if (!statusAgent) {
            addLog(`Agent "${parts[1]}" not found`, 'error');
            break;
          }
          const validStatuses = ['active', 'idle', 'error', 'processing'];
          if (!validStatuses.includes(parts[2])) {
            addLog(`Invalid status. Use: ${validStatuses.join(', ')}`, 'error');
            break;
          }
          updateAgentStatus(statusAgent, parts[2]);
          break;

        case 'task':
          if (parts.length < 2) {
            addLog('Usage: task <agent>', 'warning');
            break;
          }
          const taskAgent = agents.find(a => a.name.toLowerCase().includes(parts[1]));
          if (!taskAgent) {
            addLog(`Agent "${parts[1]}" not found`, 'error');
            break;
          }
          const task = taskTypes[Math.floor(Math.random() * taskTypes.length)];
          taskAgent.tasks++;
          if (selectedAgent === taskAgent) {
            document.getElementById('agentTasks').textContent = taskAgent.tasks;
          }
          updateAgentStatus(taskAgent, 'processing');
          addLog(`Assigned ${task} to ${taskAgent.name}`, 'success');
          setTimeout(() => {
            if (taskAgent.status === 'processing') {
              updateAgentStatus(taskAgent, 'active');
              addLog(`[${taskAgent.name}] Completed ${task}`, 'success');
            }
          }, 2000 + Math.random() * 3000);
          break;

        case 'ping':
          if (parts.length < 2) {
            addLog('Usage: ping <agent>', 'warning');
            break;
          }
          const pingAgent = agents.find(a => a.name.toLowerCase().includes(parts[1]));
          if (!pingAgent) {
            addLog(`Agent "${parts[1]}" not found`, 'error');
            break;
          }
          const latency = Math.floor(Math.random() * 150) + 10;
          addLog(`Pinging ${pingAgent.name}...`, 'info');
          setTimeout(() => {
            addLog(`[${pingAgent.name}] PONG! ${latency}ms`, 'success');
            showSpeechBubble(pingAgent);
          }, latency);
          break;

        case 'heal':
          if (parts.length < 2) {
            addLog('Usage: heal <agent>', 'warning');
            break;
          }
          const healAgent = agents.find(a => a.name.toLowerCase().includes(parts[1]));
          if (!healAgent) {
            addLog(`Agent "${parts[1]}" not found`, 'error');
            break;
          }
          if (healAgent.status === 'active') {
            addLog(`${healAgent.name} is already active`, 'info');
          } else {
            addLog(`Healing ${healAgent.name}...`, 'info');
            updateAgentStatus(healAgent, 'active');
          }
          break;

        case 'broadcast':
          if (parts.length < 2) {
            addLog('Usage: broadcast <message>', 'warning');
            break;
          }
          const broadcastMsg = parts.slice(1).join(' ');
          addLog(`Broadcasting: "${broadcastMsg}"`, 'success');
          agents.forEach((a, i) => {
            setTimeout(() => showSpeechBubble(a), i * 300);
          });
          break;

        case 'clear':
          terminalLog.innerHTML = '';
          addLog('Terminal cleared', 'success');
          break;

        default:
          addLog(`Unknown command: ${command}. Type "help" for commands.`, 'error');
      }
    }

    // Terminal input handling
    terminalInput.addEventListener('keydown', (e) => {
      if (e.key === 'Enter' && terminalInput.value.trim()) {
        processCommand(terminalInput.value);
        terminalInput.value = '';
      }
    });

    // Initial log entries
    addLog('Agent Control Terminal v1.0', 'success');
    addLog('Type "help" for available commands', 'info');
    addLog('Initializing agent network...', 'info');
    setTimeout(() => addLog('Network initialized. Agents online.', 'success'), 500);

    // Auto-generate fake activity
    setInterval(generateActivity, 3000 + Math.random() * 2000);

    animate();
  </script>
</body>
</html>
