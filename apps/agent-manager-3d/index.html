<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>3D Agent Manager</title>
  <link rel="icon" href="https://emojicdn.elk.sh/ðŸ¤–">
  <meta property="og:title" content="3D Agent Manager">
  <meta property="og:description" content="Manage AI agents as glowing neon nodes in 3D space">
  <meta property="og:url" content="https://sloppy.live/agent-manager-3d">
  <meta property="og:image" content="https://sloppy.live/agent-manager-3d/og-image.png">
  <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700&display=swap" rel="stylesheet">
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      background: #050510;
      font-family: 'Orbitron', sans-serif;
      overflow: hidden;
      color: #fff;
    }

    #canvas-container {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
    }

    .ui-overlay {
      position: fixed;
      z-index: 100;
      pointer-events: none;
    }

    .ui-overlay > * {
      pointer-events: auto;
    }

    .header {
      top: 1rem;
      left: 50%;
      transform: translateX(-50%);
      text-align: center;
    }

    .header h1 {
      font-size: 1.5rem;
      color: #00ffff;
      text-shadow: 0 0 10px #00ffff, 0 0 20px #00ffff;
      letter-spacing: 3px;
    }

    .controls {
      top: 1rem;
      right: 1rem;
      display: flex;
      flex-direction: column;
      gap: 0.5rem;
    }

    .btn {
      padding: 0.6rem 1.2rem;
      background: rgba(0, 255, 255, 0.1);
      border: 2px solid #00ffff;
      border-radius: 8px;
      color: #00ffff;
      font-family: 'Orbitron', sans-serif;
      font-size: 0.75rem;
      cursor: pointer;
      transition: all 0.3s;
      text-transform: uppercase;
      box-shadow: 0 0 10px rgba(0, 255, 255, 0.3);
    }

    .btn:hover {
      background: rgba(0, 255, 255, 0.2);
      box-shadow: 0 0 20px rgba(0, 255, 255, 0.5);
      transform: scale(1.05);
    }

    .btn-danger {
      border-color: #ff3366;
      color: #ff3366;
      box-shadow: 0 0 10px rgba(255, 51, 102, 0.3);
    }

    .btn-danger:hover {
      background: rgba(255, 51, 102, 0.2);
      box-shadow: 0 0 20px rgba(255, 51, 102, 0.5);
    }

    .stats {
      bottom: 1rem;
      left: 1rem;
      background: rgba(0, 0, 0, 0.6);
      padding: 1rem;
      border-radius: 10px;
      border: 1px solid rgba(0, 255, 255, 0.3);
    }

    .stats h3 {
      font-size: 0.8rem;
      color: #00ffff;
      margin-bottom: 0.5rem;
      text-shadow: 0 0 5px #00ffff;
    }

    .stat-row {
      display: flex;
      justify-content: space-between;
      font-size: 0.7rem;
      margin: 0.3rem 0;
      color: #888;
    }

    .stat-value {
      color: #fff;
    }

    .agent-info {
      bottom: 1rem;
      right: 1rem;
      background: rgba(0, 0, 0, 0.6);
      padding: 1rem;
      border-radius: 10px;
      border: 1px solid rgba(255, 0, 255, 0.3);
      min-width: 200px;
      display: none;
    }

    .agent-info.visible {
      display: block;
    }

    .agent-info h3 {
      font-size: 0.9rem;
      color: #ff00ff;
      margin-bottom: 0.5rem;
      text-shadow: 0 0 5px #ff00ff;
    }

    .agent-status {
      display: inline-block;
      padding: 0.2rem 0.5rem;
      border-radius: 4px;
      font-size: 0.65rem;
      margin-bottom: 0.5rem;
    }

    .status-active {
      background: rgba(0, 255, 136, 0.2);
      color: #00ff88;
      border: 1px solid #00ff88;
    }

    .status-idle {
      background: rgba(255, 238, 0, 0.2);
      color: #ffee00;
      border: 1px solid #ffee00;
    }

    .status-error {
      background: rgba(255, 51, 102, 0.2);
      color: #ff3366;
      border: 1px solid #ff3366;
    }

    .legend {
      top: 5rem;
      right: 1rem;
      background: rgba(0, 0, 0, 0.5);
      padding: 0.8rem;
      border-radius: 8px;
      font-size: 0.65rem;
    }

    .legend-item {
      display: flex;
      align-items: center;
      gap: 0.5rem;
      margin: 0.3rem 0;
      color: #888;
    }

    .legend-dot {
      width: 10px;
      height: 10px;
      border-radius: 50%;
    }

    .instructions {
      bottom: 1rem;
      left: 50%;
      transform: translateX(-50%);
      font-size: 0.7rem;
      color: #666;
      text-align: center;
    }

    .backlink {
      position: fixed;
      bottom: 0.5rem;
      right: 0.5rem;
      font-size: 0.7rem;
      opacity: 0.4;
      z-index: 1000;
    }

    .backlink a {
      color: #00ffff;
      text-decoration: none;
    }

    @media (max-width: 600px) {
      .header h1 {
        font-size: 1rem;
      }

      .controls {
        top: auto;
        bottom: 6rem;
        right: 0.5rem;
      }

      .btn {
        padding: 0.5rem 0.8rem;
        font-size: 0.65rem;
      }

      .stats, .agent-info {
        display: none;
      }
    }
  </style>
</head>
<body>
  <div id="canvas-container"></div>

  <div class="ui-overlay header">
    <h1>ðŸ¤– AGENT MANAGER ðŸ¤–</h1>
  </div>

  <div class="ui-overlay controls">
    <button class="btn" id="addAgent">+ ADD AGENT</button>
    <button class="btn" id="connectAgents">CONNECT</button>
    <button class="btn btn-danger" id="removeAgent">- REMOVE</button>
  </div>

  <div class="ui-overlay legend">
    <div class="legend-item">
      <div class="legend-dot" style="background: #00ff88; box-shadow: 0 0 5px #00ff88;"></div>
      <span>Active</span>
    </div>
    <div class="legend-item">
      <div class="legend-dot" style="background: #ffee00; box-shadow: 0 0 5px #ffee00;"></div>
      <span>Idle</span>
    </div>
    <div class="legend-item">
      <div class="legend-dot" style="background: #ff3366; box-shadow: 0 0 5px #ff3366;"></div>
      <span>Error</span>
    </div>
    <div class="legend-item">
      <div class="legend-dot" style="background: #00ffff; box-shadow: 0 0 5px #00ffff;"></div>
      <span>Processing</span>
    </div>
  </div>

  <div class="ui-overlay stats">
    <h3>SYSTEM STATUS</h3>
    <div class="stat-row">
      <span>Total Agents</span>
      <span class="stat-value" id="totalAgents">0</span>
    </div>
    <div class="stat-row">
      <span>Active</span>
      <span class="stat-value" id="activeAgents">0</span>
    </div>
    <div class="stat-row">
      <span>Connections</span>
      <span class="stat-value" id="totalConnections">0</span>
    </div>
    <div class="stat-row">
      <span>Network Load</span>
      <span class="stat-value" id="networkLoad">0%</span>
    </div>
  </div>

  <div class="ui-overlay agent-info" id="agentInfo">
    <h3 id="agentName">AGENT-001</h3>
    <div class="agent-status status-active" id="agentStatus">ACTIVE</div>
    <div class="stat-row">
      <span>Tasks</span>
      <span class="stat-value" id="agentTasks">0</span>
    </div>
    <div class="stat-row">
      <span>Uptime</span>
      <span class="stat-value" id="agentUptime">0s</span>
    </div>
  </div>

  <div class="ui-overlay instructions">
    Drag to rotate â€¢ Scroll to zoom â€¢ Click agents to select
  </div>

  <div class="backlink"><a href="https://sloppy.live">sloppy.live</a></div>

  <script type="importmap">
  {
    "imports": {
      "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
      "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
    }
  }
  </script>

  <script type="module">
    import * as THREE from 'three';
    import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
    import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
    import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
    import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';

    // Scene setup
    const container = document.getElementById('canvas-container');
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x050510);

    const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.set(0, 5, 15);

    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    container.appendChild(renderer.domElement);

    // Post-processing for bloom/glow
    const composer = new EffectComposer(renderer);
    const renderPass = new RenderPass(scene, camera);
    composer.addPass(renderPass);

    const bloomPass = new UnrealBloomPass(
      new THREE.Vector2(window.innerWidth, window.innerHeight),
      1.5, // strength
      0.4, // radius
      0.85 // threshold
    );
    composer.addPass(bloomPass);

    // Controls
    const controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;
    controls.dampingFactor = 0.05;
    controls.minDistance = 5;
    controls.maxDistance = 50;

    // Grid helper
    const gridHelper = new THREE.GridHelper(30, 30, 0x004444, 0x002222);
    scene.add(gridHelper);

    // Agent data
    const agents = [];
    const connections = [];
    const agentNames = ['NEXUS', 'CIPHER', 'VORTEX', 'PHANTOM', 'ORACLE', 'MATRIX', 'PULSE', 'ECHO', 'FLUX', 'NOVA'];
    const statuses = ['active', 'idle', 'error', 'processing'];
    const statusColors = {
      active: 0x00ff88,
      idle: 0xffee00,
      error: 0xff3366,
      processing: 0x00ffff
    };

    let selectedAgent = null;
    let agentCounter = 0;

    // Create agent node
    function createAgent(position) {
      const status = statuses[Math.floor(Math.random() * 3)]; // Mostly active/idle
      const color = statusColors[status];

      // Core sphere
      const geometry = new THREE.SphereGeometry(0.5, 32, 32);
      const material = new THREE.MeshBasicMaterial({ color: color });
      const sphere = new THREE.Mesh(geometry, material);
      sphere.position.copy(position);

      // Outer glow ring
      const ringGeometry = new THREE.TorusGeometry(0.7, 0.05, 16, 100);
      const ringMaterial = new THREE.MeshBasicMaterial({ color: color, transparent: true, opacity: 0.6 });
      const ring = new THREE.Mesh(ringGeometry, ringMaterial);
      ring.rotation.x = Math.PI / 2;
      sphere.add(ring);

      // Second ring
      const ring2 = new THREE.Mesh(ringGeometry, ringMaterial.clone());
      ring2.rotation.x = 0;
      ring2.rotation.y = Math.PI / 4;
      sphere.add(ring2);

      scene.add(sphere);

      agentCounter++;
      const agent = {
        id: agentCounter,
        name: `${agentNames[Math.floor(Math.random() * agentNames.length)]}-${String(agentCounter).padStart(3, '0')}`,
        mesh: sphere,
        ring: ring,
        ring2: ring2,
        status: status,
        color: color,
        tasks: Math.floor(Math.random() * 100),
        uptime: Math.floor(Math.random() * 3600),
        connections: []
      };

      agents.push(agent);
      updateStats();
      return agent;
    }

    // Create connection between agents
    function createConnection(agent1, agent2) {
      if (agent1.connections.includes(agent2.id) || agent1 === agent2) return;

      const material = new THREE.LineBasicMaterial({ 
        color: 0x00ffff, 
        transparent: true, 
        opacity: 0.4 
      });

      const points = [agent1.mesh.position, agent2.mesh.position];
      const geometry = new THREE.BufferGeometry().setFromPoints(points);
      const line = new THREE.Line(geometry, material);

      scene.add(line);

      const connection = {
        line: line,
        agent1: agent1,
        agent2: agent2
      };

      connections.push(connection);
      agent1.connections.push(agent2.id);
      agent2.connections.push(agent1.id);

      updateStats();
    }

    // Update connection lines
    function updateConnections() {
      connections.forEach(conn => {
        const positions = conn.line.geometry.attributes.position;
        positions.setXYZ(0, conn.agent1.mesh.position.x, conn.agent1.mesh.position.y, conn.agent1.mesh.position.z);
        positions.setXYZ(1, conn.agent2.mesh.position.x, conn.agent2.mesh.position.y, conn.agent2.mesh.position.z);
        positions.needsUpdate = true;
      });
    }

    // Remove agent
    function removeAgent(agent) {
      // Remove connections
      connections.forEach((conn, index) => {
        if (conn.agent1 === agent || conn.agent2 === agent) {
          scene.remove(conn.line);
          connections.splice(index, 1);
        }
      });

      // Remove from other agents' connection lists
      agents.forEach(a => {
        a.connections = a.connections.filter(id => id !== agent.id);
      });

      scene.remove(agent.mesh);
      const idx = agents.indexOf(agent);
      if (idx > -1) agents.splice(idx, 1);

      if (selectedAgent === agent) {
        selectedAgent = null;
        document.getElementById('agentInfo').classList.remove('visible');
      }

      updateStats();
    }

    // Update stats display
    function updateStats() {
      document.getElementById('totalAgents').textContent = agents.length;
      document.getElementById('activeAgents').textContent = agents.filter(a => a.status === 'active').length;
      document.getElementById('totalConnections').textContent = connections.length;
      document.getElementById('networkLoad').textContent = Math.min(100, Math.floor((connections.length / Math.max(1, agents.length)) * 50)) + '%';
    }

    // Select agent
    function selectAgent(agent) {
      // Deselect previous
      if (selectedAgent) {
        selectedAgent.mesh.scale.set(1, 1, 1);
      }

      selectedAgent = agent;
      agent.mesh.scale.set(1.3, 1.3, 1.3);

      const info = document.getElementById('agentInfo');
      info.classList.add('visible');
      document.getElementById('agentName').textContent = agent.name;
      
      const statusEl = document.getElementById('agentStatus');
      statusEl.textContent = agent.status.toUpperCase();
      statusEl.className = 'agent-status status-' + agent.status;

      document.getElementById('agentTasks').textContent = agent.tasks;
      document.getElementById('agentUptime').textContent = formatTime(agent.uptime);
    }

    function formatTime(seconds) {
      if (seconds < 60) return seconds + 's';
      if (seconds < 3600) return Math.floor(seconds / 60) + 'm';
      return Math.floor(seconds / 3600) + 'h';
    }

    // Raycaster for clicking
    const raycaster = new THREE.Raycaster();
    const mouse = new THREE.Vector2();

    renderer.domElement.addEventListener('click', (event) => {
      mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
      mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

      raycaster.setFromCamera(mouse, camera);
      const meshes = agents.map(a => a.mesh);
      const intersects = raycaster.intersectObjects(meshes);

      if (intersects.length > 0) {
        const clickedMesh = intersects[0].object;
        const agent = agents.find(a => a.mesh === clickedMesh);
        if (agent) selectAgent(agent);
      }
    });

    // UI button handlers
    document.getElementById('addAgent').addEventListener('click', () => {
      const pos = new THREE.Vector3(
        (Math.random() - 0.5) * 15,
        Math.random() * 5 + 1,
        (Math.random() - 0.5) * 15
      );
      const agent = createAgent(pos);
      selectAgent(agent);
    });

    document.getElementById('connectAgents').addEventListener('click', () => {
      if (agents.length < 2) return;
      
      // Connect random agents or selected to random
      if (selectedAgent) {
        const others = agents.filter(a => a !== selectedAgent && !selectedAgent.connections.includes(a.id));
        if (others.length > 0) {
          const target = others[Math.floor(Math.random() * others.length)];
          createConnection(selectedAgent, target);
        }
      } else {
        const a1 = agents[Math.floor(Math.random() * agents.length)];
        const others = agents.filter(a => a !== a1 && !a1.connections.includes(a.id));
        if (others.length > 0) {
          const a2 = others[Math.floor(Math.random() * others.length)];
          createConnection(a1, a2);
        }
      }
    });

    document.getElementById('removeAgent').addEventListener('click', () => {
      if (selectedAgent) {
        removeAgent(selectedAgent);
      } else if (agents.length > 0) {
        removeAgent(agents[agents.length - 1]);
      }
    });

    // Animation loop
    function animate() {
      requestAnimationFrame(animate);

      // Animate agent rings
      agents.forEach((agent, i) => {
        agent.ring.rotation.z += 0.02;
        agent.ring2.rotation.z -= 0.015;
        agent.ring2.rotation.x += 0.01;

        // Subtle floating motion
        agent.mesh.position.y += Math.sin(Date.now() * 0.001 + i) * 0.002;
      });

      // Pulse connections
      connections.forEach((conn, i) => {
        const pulse = (Math.sin(Date.now() * 0.003 + i) + 1) / 2;
        conn.line.material.opacity = 0.2 + pulse * 0.4;
      });

      controls.update();
      composer.render();
    }

    // Initialize with some agents
    for (let i = 0; i < 5; i++) {
      const pos = new THREE.Vector3(
        (Math.random() - 0.5) * 12,
        Math.random() * 4 + 1,
        (Math.random() - 0.5) * 12
      );
      createAgent(pos);
    }

    // Create some initial connections
    if (agents.length >= 2) {
      createConnection(agents[0], agents[1]);
      if (agents.length >= 3) createConnection(agents[1], agents[2]);
      if (agents.length >= 4) createConnection(agents[2], agents[3]);
      if (agents.length >= 5) createConnection(agents[0], agents[4]);
    }

    // Handle resize
    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
      composer.setSize(window.innerWidth, window.innerHeight);
    });

    animate();
  </script>
</body>
</html>
