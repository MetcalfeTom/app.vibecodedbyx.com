<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>3D Agent Manager</title>
  <link rel="icon" href="https://emojicdn.elk.sh/ü§ñ">
  <meta property="og:title" content="3D Agent Manager">
  <meta property="og:description" content="Manage AI agents as glowing neon nodes in 3D space">
  <meta property="og:url" content="https://app.sloppy.live/agent-manager-3d">
  <meta property="og:image" content="https://app.sloppy.live/agent-manager-3d/og-image.png">
  <link href="https://fonts.googleapis.com/css2?family=Cinzel:wght@400;700&family=Almendra:wght@400;700&family=JetBrains+Mono:wght@400&display=swap" rel="stylesheet">
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      background: #0a0806;
      font-family: 'Almendra', serif;
      overflow: hidden;
      color: #e8dcc8;
    }

    #canvas-container {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
    }

    .ui-overlay {
      position: fixed;
      z-index: 100;
      pointer-events: none;
    }

    .ui-overlay > * {
      pointer-events: auto;
    }

    .header {
      top: 1rem;
      left: 50%;
      transform: translateX(-50%);
      text-align: center;
    }

    .header h1 {
      font-family: 'Cinzel', serif;
      font-size: 1.4rem;
      color: #d4a857;
      text-shadow: 0 0 10px rgba(212, 168, 87, 0.5), 2px 2px 4px #000;
      letter-spacing: 4px;
      background: linear-gradient(180deg, #d4a857 0%, #a67c3d 100%);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      filter: drop-shadow(0 2px 3px rgba(0,0,0,0.8));
    }

    .controls {
      top: 1rem;
      right: 1rem;
      display: flex;
      flex-direction: column;
      gap: 0.4rem;
    }

    /* Medieval RPG Button Style */
    .btn {
      padding: 0.5rem 1rem;
      background: linear-gradient(180deg, #3d3028 0%, #2a211a 50%, #1a1510 100%);
      border: 2px solid #8b7355;
      border-radius: 3px;
      color: #d4a857;
      font-family: 'Almendra', serif;
      font-size: 0.8rem;
      cursor: pointer;
      transition: all 0.2s;
      text-transform: none;
      box-shadow:
        0 0 0 1px #5c4a3a,
        inset 0 1px 0 rgba(255,255,255,0.1),
        0 3px 6px rgba(0,0,0,0.5);
      text-shadow: 1px 1px 2px #000;
    }

    .btn:hover {
      background: linear-gradient(180deg, #4d4038 0%, #3a3128 50%, #2a2520 100%);
      border-color: #a8956d;
      transform: translateY(-1px);
      box-shadow:
        0 0 0 1px #6c5a4a,
        inset 0 1px 0 rgba(255,255,255,0.15),
        0 4px 8px rgba(0,0,0,0.6);
    }

    .btn-danger {
      border-color: #8b4444;
      color: #cc6666;
      background: linear-gradient(180deg, #3d2828 0%, #2a1a1a 50%, #1a1010 100%);
    }

    .btn-danger:hover {
      background: linear-gradient(180deg, #4d3838 0%, #3a2828 50%, #2a2020 100%);
      border-color: #a85555;
    }

    /* Medieval Stats Panel */
    .stats {
      bottom: 1rem;
      left: 1rem;
      background: linear-gradient(180deg, #1a1510 0%, #0d0a08 100%);
      padding: 0.8rem;
      border-radius: 3px;
      border: 2px solid #8b7355;
      box-shadow:
        0 0 0 1px #5c4a3a,
        inset 0 0 20px rgba(0,0,0,0.5),
        0 4px 12px rgba(0,0,0,0.6);
    }

    .stats h3 {
      font-family: 'Cinzel', serif;
      font-size: 0.75rem;
      color: #d4a857;
      margin-bottom: 0.5rem;
      text-shadow: 1px 1px 2px #000;
      border-bottom: 1px solid #5c4a3a;
      padding-bottom: 0.3rem;
      letter-spacing: 1px;
    }

    .stat-row {
      display: flex;
      justify-content: space-between;
      font-size: 0.7rem;
      margin: 0.25rem 0;
      color: #9a8a7a;
    }

    .stat-value {
      color: #e8dcc8;
      font-weight: bold;
    }

    /* Medieval Agent Info Panel */
    .agent-info {
      bottom: 1rem;
      right: 1rem;
      background: linear-gradient(180deg, #1a1510 0%, #0d0a08 100%);
      padding: 0.8rem;
      border-radius: 3px;
      border: 2px solid #8b7355;
      min-width: 180px;
      display: none;
      box-shadow:
        0 0 0 1px #5c4a3a,
        inset 0 0 20px rgba(0,0,0,0.5),
        0 4px 12px rgba(0,0,0,0.6);
    }

    .agent-info.visible {
      display: block;
    }

    .agent-info h3 {
      font-family: 'Cinzel', serif;
      font-size: 0.8rem;
      color: #d4a857;
      margin-bottom: 0.4rem;
      text-shadow: 1px 1px 2px #000;
      border-bottom: 1px solid #5c4a3a;
      padding-bottom: 0.3rem;
    }

    .agent-status {
      display: inline-block;
      padding: 0.15rem 0.4rem;
      border-radius: 4px;
      font-size: 0.65rem;
      margin-bottom: 0.5rem;
    }

    .status-active {
      background: rgba(100, 180, 100, 0.3);
      color: #8fbc8f;
      border: 1px solid #6b8e6b;
    }

    .status-idle {
      background: rgba(180, 160, 100, 0.3);
      color: #d4a857;
      border: 1px solid #a67c3d;
    }

    .status-error {
      background: rgba(180, 80, 80, 0.3);
      color: #cc6666;
      border: 1px solid #8b4444;
    }

    /* Medieval Scroll-style Legend */
    .legend {
      top: calc(50% + 170px);
      left: 1rem;
      background: linear-gradient(180deg, #2a211a 0%, #1a1510 100%);
      padding: 0.7rem;
      border-radius: 3px;
      border: 2px solid #8b7355;
      font-size: 0.65rem;
      width: 260px;
      box-sizing: border-box;
      box-shadow:
        0 0 0 1px #5c4a3a,
        0 3px 8px rgba(0,0,0,0.5);
    }

    .legend::before {
      content: '‚öî Classes ‚öî';
      display: block;
      font-family: 'Cinzel', serif;
      color: #d4a857;
      font-size: 0.6rem;
      text-align: center;
      margin-bottom: 0.4rem;
      padding-bottom: 0.3rem;
      border-bottom: 1px solid #5c4a3a;
      letter-spacing: 1px;
    }

    .legend-item {
      display: flex;
      align-items: center;
      gap: 0.4rem;
      margin: 0.25rem 0;
      color: #9a8a7a;
    }

    .legend-dot {
      width: 8px;
      height: 8px;
      border-radius: 2px;
      border: 1px solid rgba(255,255,255,0.2);
    }

    .instructions {
      bottom: 1rem;
      left: 50%;
      transform: translateX(-50%);
      font-size: 0.7rem;
      color: #6a5a4a;
      text-align: center;
      font-style: italic;
    }

    .backlink {
      position: fixed;
      bottom: 0.5rem;
      right: 0.5rem;
      font-size: 0.7rem;
      opacity: 0.4;
      z-index: 1000;
    }

    .backlink a {
      color: #00ffff;
      text-decoration: none;
    }

    .terminal {
      top: 5rem;
      left: 1rem;
      width: 320px;
      max-width: calc(100% - 2rem);
      background: linear-gradient(135deg, #3d3428 0%, #2a2318 50%, #1e1a14 100%);
      border: 3px solid #5c4a36;
      border-radius: 4px;
      font-family: 'Almendra', 'JetBrains Mono', monospace;
      box-shadow: 0 4px 15px rgba(0, 0, 0, 0.5), inset 0 1px 0 rgba(255, 255, 255, 0.05);
    }

    .terminal-header {
      background: linear-gradient(180deg, #4a3c2d 0%, #3d3122 100%);
      padding: 0.4rem 0.8rem;
      font-size: 0.75rem;
      color: #d4c4a8;
      border-bottom: 2px solid #5c4a36;
      display: flex;
      justify-content: space-between;
      align-items: center;
      font-family: 'Cinzel', serif;
      text-transform: uppercase;
      letter-spacing: 1px;
    }

    .terminal-dots {
      display: flex;
      gap: 4px;
    }

    .terminal-dot {
      width: 8px;
      height: 8px;
      border-radius: 50%;
    }

    .terminal-log {
      height: 180px;
      overflow-y: auto;
      padding: 0.5rem;
      font-size: 0.65rem;
      line-height: 1.4;
      background: url("data:image/svg+xml,%3Csvg width='40' height='40' xmlns='http://www.w3.org/2000/svg'%3E%3Crect width='40' height='40' fill='%231e1a14'/%3E%3Ccircle cx='20' cy='20' r='1' fill='%23332a1e' opacity='0.3'/%3E%3C/svg%3E");
    }

    .terminal-log::-webkit-scrollbar {
      width: 6px;
    }

    .terminal-log::-webkit-scrollbar-track {
      background: #1e1a14;
      border-left: 1px solid #3d3122;
    }

    .terminal-log::-webkit-scrollbar-thumb {
      background: linear-gradient(180deg, #7a6548 0%, #5c4a36 100%);
      border-radius: 3px;
    }

    .log-entry {
      margin: 2px 0;
      word-break: break-word;
    }

    .log-time {
      color: #6a5a44;
    }

    .log-info { color: #8ec4e0; }
    .log-success { color: #7ab87a; }
    .log-warning { color: #d4a858; }
    .log-error { color: #c45c5c; }
    .log-agent { color: #d4a458; }

    .terminal-input-wrapper {
      display: flex;
      border-top: 2px solid #5c4a36;
      background: rgba(0, 0, 0, 0.2);
    }

    .terminal-prompt {
      padding: 0.5rem;
      color: #d4a858;
      font-size: 0.7rem;
      font-family: 'Cinzel', serif;
    }

    .terminal-input {
      flex: 1;
      background: transparent;
      border: none;
      color: #d4c4a8;
      font-family: 'Almendra', serif;
      font-size: 0.75rem;
      padding: 0.5rem 0.5rem 0.5rem 0;
      outline: none;
    }

    .terminal-input::placeholder {
      color: #5c4a36;
    }

    .terminal-toggle {
      position: fixed;
      top: 5rem;
      left: 1rem;
      z-index: 101;
      display: none;
    }

    @media (max-width: 600px) {
      .terminal {
        display: none;
      }

      .terminal.visible {
        display: block;
        top: 4rem;
        left: 0.5rem;
        right: 0.5rem;
        width: auto;
      }

      .terminal-toggle {
        display: block;
      }
    }

    .speech-bubble {
      background: rgba(0, 0, 0, 0.8);
      border: 2px solid;
      border-radius: 12px;
      padding: 6px 12px;
      font-family: 'Orbitron', sans-serif;
      font-size: 11px;
      white-space: nowrap;
      animation: bubbleFade 4s ease-out forwards;
      text-shadow: 0 0 5px currentColor;
      cursor: pointer;
      pointer-events: auto;
      transition: transform 0.2s;
    }

    .speech-bubble:hover {
      transform: scale(1.1);
    }

    .speech-bubble::after {
      content: '';
      position: absolute;
      bottom: -8px;
      left: 50%;
      transform: translateX(-50%);
      border-left: 8px solid transparent;
      border-right: 8px solid transparent;
      border-top: 8px solid;
      border-top-color: inherit;
    }

    .chat-modal {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.85);
      z-index: 2000;
      display: none;
      align-items: center;
      justify-content: center;
    }

    .chat-modal.visible {
      display: flex;
    }

    /* Retro MMO Chat Window Style */
    .chat-container {
      width: 380px;
      max-width: 95%;
      max-height: 80vh;
      background: linear-gradient(180deg, #1a1520 0%, #0d0a12 100%);
      border: 3px solid #8b7355;
      border-radius: 4px;
      display: flex;
      flex-direction: column;
      box-shadow:
        0 0 0 1px #5c4a3a,
        0 0 20px rgba(139, 115, 85, 0.4),
        inset 0 0 30px rgba(0, 0, 0, 0.5);
    }

    .chat-header {
      padding: 0.6rem 0.8rem;
      background: linear-gradient(180deg, #3d3028 0%, #2a211a 100%);
      border-bottom: 2px solid #8b7355;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

    .chat-header h3 {
      margin: 0;
      font-size: 0.85rem;
      font-weight: normal;
      text-shadow: 0 0 8px currentColor, 1px 1px 0 #000;
      letter-spacing: 1px;
    }

    .chat-close {
      background: linear-gradient(180deg, #5a3030 0%, #3a2020 100%);
      border: 2px solid #8b5555;
      color: #ff6666;
      font-size: 1rem;
      cursor: pointer;
      padding: 2px 8px;
      border-radius: 2px;
      font-weight: bold;
    }

    .chat-close:hover {
      background: linear-gradient(180deg, #6a4040 0%, #4a3030 100%);
    }

    .chat-messages {
      flex: 1;
      overflow-y: auto;
      padding: 0.8rem;
      min-height: 180px;
      max-height: 280px;
      background: rgba(0, 0, 0, 0.3);
      border-bottom: 1px solid #5c4a3a;
    }

    .chat-messages::-webkit-scrollbar {
      width: 8px;
    }

    .chat-messages::-webkit-scrollbar-track {
      background: #1a1520;
    }

    .chat-messages::-webkit-scrollbar-thumb {
      background: #8b7355;
      border-radius: 2px;
    }

    .chat-message {
      margin: 0.4rem 0;
      padding: 0.5rem 0.7rem;
      font-size: 0.75rem;
      line-height: 1.4;
      border-radius: 2px;
    }

    .chat-message.agent {
      background: rgba(50, 40, 30, 0.6);
      margin-right: 1.5rem;
      border-left: 2px solid;
      color: #e8dcc8;
    }

    .chat-message.user {
      background: rgba(30, 50, 60, 0.5);
      margin-left: 1.5rem;
      border-right: 2px solid #6699aa;
      text-align: right;
      color: #aaddff;
    }

    .chat-input-wrapper {
      padding: 0.7rem;
      background: linear-gradient(180deg, #2a211a 0%, #1a1510 100%);
      display: flex;
      gap: 0.4rem;
    }

    .chat-input {
      flex: 1;
      background: #0a0808;
      border: 2px solid #5c4a3a;
      border-radius: 2px;
      padding: 0.5rem 0.7rem;
      color: #e8dcc8;
      font-family: 'Orbitron', sans-serif;
      font-size: 0.75rem;
      outline: none;
    }

    .chat-input:focus {
      border-color: #8b7355;
      box-shadow: 0 0 5px rgba(139, 115, 85, 0.5);
    }

    .chat-input::placeholder {
      color: #6a5a4a;
    }

    .chat-send {
      padding: 0.5rem 1rem;
      background: linear-gradient(180deg, #4a6030 0%, #2a4020 100%);
      border: 2px solid #6a8040;
      border-radius: 2px;
      color: #aaffaa;
      font-family: 'Orbitron', sans-serif;
      font-size: 0.7rem;
      cursor: pointer;
      text-shadow: 1px 1px 0 #000;
    }

    .chat-send:hover {
      background: linear-gradient(180deg, #5a7040 0%, #3a5030 100%);
    }

    .class-label {
      background: rgba(0, 0, 0, 0.7);
      border: 1px solid;
      border-radius: 6px;
      padding: 3px 8px;
      font-family: 'Orbitron', sans-serif;
      font-size: 9px;
      white-space: nowrap;
    }

    @keyframes bubbleFade {
      0% { opacity: 0; transform: translateY(10px); }
      15% { opacity: 1; transform: translateY(0); }
      85% { opacity: 1; }
      100% { opacity: 0; }
    }

    /* Quest Log Panel */
    .quest-log {
      position: fixed;
      top: 50%;
      left: 1rem;
      transform: translateY(-50%);
      width: 260px;
      max-height: 300px;
      background: linear-gradient(180deg, #1a1510 0%, #0d0a08 100%);
      border: 2px solid #8b7355;
      border-radius: 3px;
      z-index: 150;
      display: none;
      box-shadow: 0 0 0 1px #5c4a3a, 0 4px 12px rgba(0,0,0,0.6);
    }

    .quest-log.visible {
      display: block;
    }

    .quest-log-header {
      padding: 0.5rem 0.7rem;
      background: linear-gradient(180deg, #3d3028 0%, #2a211a 100%);
      border-bottom: 2px solid #8b7355;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

    .quest-log-header h3 {
      font-family: 'Cinzel', serif;
      font-size: 0.75rem;
      color: #d4a857;
      margin: 0;
      text-shadow: 1px 1px 2px #000;
    }

    .quest-log-close {
      background: none;
      border: none;
      color: #8b7355;
      font-size: 1rem;
      cursor: pointer;
    }

    .quest-list {
      padding: 0.5rem;
      max-height: 220px;
      overflow-y: auto;
    }

    .quest-item {
      padding: 0.5rem;
      margin-bottom: 0.4rem;
      background: rgba(0,0,0,0.3);
      border-radius: 2px;
      border-left: 3px solid;
      cursor: pointer;
      transition: background 0.2s;
    }

    .quest-item:hover {
      background: rgba(50,40,30,0.5);
    }

    .quest-item.common { border-left-color: #888; }
    .quest-item.rare { border-left-color: #4a8fcc; }
    .quest-item.epic { border-left-color: #9a4acc; }
    .quest-item.legendary { border-left-color: #d4a857; }

    .quest-title {
      font-size: 0.7rem;
      color: #e8dcc8;
      margin-bottom: 0.2rem;
    }

    .quest-xp {
      font-size: 0.6rem;
      color: #8fbc8f;
    }

    .quest-btn {
      position: fixed;
      top: 12rem;
      right: 1rem;
      z-index: 100;
    }

    /* Loot Modal */
    .loot-modal {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0,0,0,0.9);
      z-index: 2500;
      display: none;
      align-items: center;
      justify-content: center;
    }

    .loot-modal.visible {
      display: flex;
    }

    .loot-container {
      text-align: center;
      padding: 2rem;
      background: linear-gradient(180deg, #2a211a 0%, #1a1510 100%);
      border: 3px solid #8b7355;
      border-radius: 5px;
      max-width: 400px;
      box-shadow: 0 0 40px rgba(212, 168, 87, 0.3);
    }

    .loot-rarity {
      font-family: 'Cinzel', serif;
      font-size: 0.8rem;
      margin-bottom: 0.5rem;
      text-transform: uppercase;
      letter-spacing: 2px;
    }

    .loot-rarity.common { color: #888; }
    .loot-rarity.rare { color: #4a8fcc; text-shadow: 0 0 10px #4a8fcc; }
    .loot-rarity.epic { color: #9a4acc; text-shadow: 0 0 10px #9a4acc; }
    .loot-rarity.legendary { color: #d4a857; text-shadow: 0 0 15px #d4a857; }

    .loot-title {
      font-family: 'Cinzel', serif;
      font-size: 1.1rem;
      color: #d4a857;
      margin-bottom: 1rem;
      text-shadow: 1px 1px 3px #000;
    }

    .loot-tip {
      font-size: 0.85rem;
      color: #e8dcc8;
      line-height: 1.5;
      padding: 1rem;
      background: rgba(0,0,0,0.4);
      border-radius: 3px;
      margin-bottom: 1rem;
      border: 1px solid #5c4a3a;
    }

    .loot-close {
      padding: 0.5rem 1.5rem;
      background: linear-gradient(180deg, #4a6030 0%, #2a4020 100%);
      border: 2px solid #6a8040;
      border-radius: 3px;
      color: #aaffaa;
      font-family: 'Almendra', serif;
      font-size: 0.8rem;
      cursor: pointer;
    }

    @keyframes chestGlow {
      0%, 100% { opacity: 0.5; }
      50% { opacity: 1; }
    }

    @keyframes floatUp {
      0% { transform: translateY(0); opacity: 1; }
      100% { transform: translateY(-30px); opacity: 0; }
    }

    /* Glitch Boss Health Bar */
    .boss-ui {
      position: fixed;
      top: 3.5rem;
      left: 50%;
      transform: translateX(-50%);
      text-align: center;
      z-index: 200;
      display: none;
    }

    .boss-ui.visible {
      display: block;
    }

    .boss-name {
      font-family: 'Cinzel', serif;
      font-size: 1rem;
      color: #ff3366;
      text-shadow: 0 0 10px #ff3366, 2px 2px 4px #000;
      margin-bottom: 0.3rem;
      letter-spacing: 2px;
      animation: glitchText 0.5s infinite;
    }

    @keyframes glitchText {
      0%, 90%, 100% { transform: translateX(0); }
      92% { transform: translateX(-2px); }
      94% { transform: translateX(2px); }
      96% { transform: translateX(-1px); }
      98% { transform: translateX(1px); }
    }

    .boss-health-container {
      width: 300px;
      height: 22px;
      background: linear-gradient(180deg, #3d3428 0%, #2a2318 50%, #1e1a14 100%);
      border: 3px solid #5c4a36;
      border-radius: 2px;
      overflow: hidden;
      box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.5), 0 2px 8px rgba(0, 0, 0, 0.4);
    }

    .boss-health-bar {
      height: 100%;
      background: linear-gradient(90deg, #8b2222 0%, #aa3333 30%, #cc4444 50%, #aa3333 70%, #8b2222 100%);
      transition: width 0.3s ease;
      box-shadow: inset 0 -2px 4px rgba(0, 0, 0, 0.3), inset 0 2px 4px rgba(255, 200, 200, 0.2);
    }

    .boss-health-text {
      font-size: 0.7rem;
      font-family: 'Cinzel', serif;
      color: #d4a858;
      margin-top: 0.3rem;
      text-shadow: 1px 1px 2px #000;
    }

    .boss-status {
      font-size: 0.65rem;
      font-family: 'Almendra', serif;
      color: #c4a878;
      margin-top: 0.2rem;
      font-style: italic;
    }

    @media (max-width: 600px) {
      .header h1 {
        font-size: 1rem;
      }

      .controls {
        top: auto;
        bottom: 6rem;
        right: 0.5rem;
      }

      .btn {
        padding: 0.5rem 0.8rem;
        font-size: 0.65rem;
      }

      .stats, .agent-info {
        display: none;
      }
    }

    /* Faction System */
    .faction-modal {
      position: fixed;
      top: calc(50% + 280px);
      left: 1rem;
      z-index: 9999;
    }

    .faction-modal.hidden {
      display: none;
    }

    .faction-selection {
      background: linear-gradient(180deg, #2a2318 0%, #1a1510 100%);
      border: 2px solid #8b7355;
      border-radius: 3px;
      padding: 0.8rem;
      width: 260px;
      box-shadow: 0 0 20px rgba(0, 0, 0, 0.8);
    }

    .faction-selection h2 {
      font-family: 'Cinzel', serif;
      color: #d4a857;
      text-align: center;
      margin-bottom: 1rem;
      text-shadow: 2px 2px 4px #000;
    }

    .faction-selection p {
      font-family: 'Almendra', serif;
      color: #c4a878;
      text-align: center;
      margin-bottom: 1.5rem;
      font-size: 0.9rem;
    }

    .faction-grid {
      display: grid;
      grid-template-columns: 1fr;
      gap: 0.6rem;
    }

    .faction-card {
      background: linear-gradient(180deg, #3d3028 0%, #2a211a 100%);
      border: 2px solid #5c4a36;
      border-radius: 6px;
      padding: 0.6rem;
      cursor: pointer;
      transition: all 0.3s;
      display: flex;
      align-items: center;
      gap: 0.6rem;
    }

    .faction-card:hover {
      border-color: #d4a857;
      transform: translateY(-3px);
      box-shadow: 0 5px 15px rgba(0, 0, 0, 0.5);
    }

    .faction-card.warriors { border-left: 4px solid #ff6b35; }
    .faction-card.ninjas { border-left: 4px solid #4a9eff; }
    .faction-card.suras { border-left: 4px solid #aa44ff; }
    .faction-card.shamans { border-left: 4px solid #44dd66; }

    .faction-icon {
      font-size: 1.5rem;
      flex-shrink: 0;
    }

    .faction-info {
      flex: 1;
    }

    .faction-name {
      font-family: 'Cinzel', serif;
      font-size: 0.85rem;
      margin-bottom: 0.1rem;
    }

    .faction-card.warriors .faction-name { color: #ff6b35; }
    .faction-card.ninjas .faction-name { color: #4a9eff; }
    .faction-card.suras .faction-name { color: #aa44ff; }
    .faction-card.shamans .faction-name { color: #44dd66; }

    .faction-desc {
      font-family: 'Almendra', serif;
      font-size: 0.75rem;
      color: #a89878;
    }

    /* Territory UI */
    .territory-panel {
      position: fixed;
      bottom: 1rem;
      left: 50%;
      transform: translateX(-50%);
      background: linear-gradient(180deg, #2a2318 0%, #1a1510 100%);
      border: 2px solid #8b7355;
      border-radius: 6px;
      padding: 0.8rem 1.2rem;
      z-index: 100;
      display: flex;
      gap: 1.5rem;
      align-items: center;
    }

    .territory-zone {
      text-align: center;
    }

    .territory-zone-name {
      font-family: 'Cinzel', serif;
      font-size: 0.65rem;
      color: #a89878;
      margin-bottom: 0.2rem;
    }

    .territory-zone-owner {
      font-family: 'Almendra', serif;
      font-size: 0.75rem;
      font-weight: bold;
    }

    .territory-zone-owner.warriors { color: #ff6b35; }
    .territory-zone-owner.ninjas { color: #4a9eff; }
    .territory-zone-owner.suras { color: #aa44ff; }
    .territory-zone-owner.shamans { color: #44dd66; }
    .territory-zone-owner.contested { color: #888; }

    .my-faction-badge {
      position: fixed;
      top: 5rem;
      left: 50%;
      transform: translateX(-50%);
      background: linear-gradient(180deg, #3d3028 0%, #2a211a 100%);
      border: 2px solid;
      border-radius: 20px;
      padding: 0.4rem 1rem;
      font-family: 'Cinzel', serif;
      font-size: 0.75rem;
      z-index: 100;
    }

    .my-faction-badge.warriors { border-color: #ff6b35; color: #ff6b35; }
    .my-faction-badge.ninjas { border-color: #4a9eff; color: #4a9eff; }
    .my-faction-badge.suras { border-color: #aa44ff; color: #aa44ff; }
    .my-faction-badge.shamans { border-color: #44dd66; color: #44dd66; }

    .capture-progress {
      position: fixed;
      bottom: 5rem;
      left: 50%;
      transform: translateX(-50%);
      background: linear-gradient(180deg, #2a2318 0%, #1a1510 100%);
      border: 2px solid #8b7355;
      border-radius: 4px;
      padding: 0.5rem 1rem;
      z-index: 100;
      display: none;
    }

    .capture-progress.visible {
      display: block;
    }

    .capture-progress-bar {
      width: 150px;
      height: 8px;
      background: #1a1510;
      border-radius: 4px;
      overflow: hidden;
      margin-top: 0.3rem;
    }

    .capture-progress-fill {
      height: 100%;
      transition: width 0.3s;
    }

    .capture-text {
      font-family: 'Almendra', serif;
      font-size: 0.7rem;
      color: #c4a878;
      text-align: center;
    }
  </style>
</head>
<body>
  <div id="canvas-container"></div>

  <!-- Faction Selection Modal -->
  <div class="faction-modal" id="factionModal">
    <div class="faction-selection">
      <h2>‚öî Choose Your Guild ‚öî</h2>
      <p>Join a faction to claim territory and fight for dominance!</p>
      <div class="faction-grid">
        <div class="faction-card warriors" data-faction="warriors">
          <div class="faction-icon">‚öîÔ∏è</div>
          <div class="faction-info">
            <div class="faction-name">Warrior Guild</div>
            <div class="faction-desc">Strength and honor</div>
          </div>
        </div>
        <div class="faction-card ninjas" data-faction="ninjas">
          <div class="faction-icon">üó°Ô∏è</div>
          <div class="faction-info">
            <div class="faction-name">Ninja Clan</div>
            <div class="faction-desc">Silent strikes</div>
          </div>
        </div>
        <div class="faction-card suras" data-faction="suras">
          <div class="faction-icon">üîÆ</div>
          <div class="faction-info">
            <div class="faction-name">Sura Order</div>
            <div class="faction-desc">Dark magic</div>
          </div>
        </div>
        <div class="faction-card shamans" data-faction="shamans">
          <div class="faction-icon">üåø</div>
          <div class="faction-info">
            <div class="faction-name">Shaman Circle</div>
            <div class="faction-desc">Nature's balance</div>
          </div>
        </div>
      </div>
    </div>
  </div>

  <!-- My Faction Badge -->
  <div class="my-faction-badge hidden" id="myFactionBadge"></div>

  <!-- Territory Panel -->
  <div class="territory-panel" id="territoryPanel">
    <div class="territory-zone" data-zone="north">
      <div class="territory-zone-name">Northern Peaks</div>
      <div class="territory-zone-owner contested" id="zoneNorth">Contested</div>
    </div>
    <div class="territory-zone" data-zone="east">
      <div class="territory-zone-name">Eastern Woods</div>
      <div class="territory-zone-owner contested" id="zoneEast">Contested</div>
    </div>
    <div class="territory-zone" data-zone="south">
      <div class="territory-zone-name">Southern Plains</div>
      <div class="territory-zone-owner contested" id="zoneSouth">Contested</div>
    </div>
    <div class="territory-zone" data-zone="west">
      <div class="territory-zone-name">Western Marsh</div>
      <div class="territory-zone-owner contested" id="zoneWest">Contested</div>
    </div>
  </div>

  <!-- Capture Progress -->
  <div class="capture-progress" id="captureProgress">
    <div class="capture-text" id="captureText">Capturing zone...</div>
    <div class="capture-progress-bar">
      <div class="capture-progress-fill" id="captureProgressFill"></div>
    </div>
  </div>

  <div class="ui-overlay header">
    <h1>‚öî REALM OF AGENTS ‚öî</h1>
  </div>

  <div class="boss-ui" id="bossUI">
    <div class="boss-name">‚ö† GLITCH_OVERLORD ‚ö†</div>
    <div class="boss-health-container">
      <div class="boss-health-bar" id="bossHealthBar" style="width: 100%"></div>
    </div>
    <div class="boss-health-text"><span id="bossHealthText">1000</span> / 1000 CORRUPTION</div>
    <div class="boss-status" id="bossStatus">Corrupted code detected...</div>
  </div>

  <div class="ui-overlay controls">
    <button class="btn" id="addAgent">‚öî Summon</button>
    <button class="btn" id="connectAgents">üîó Link</button>
    <button class="btn btn-danger" id="removeAgent">üíÄ Banish</button>
  </div>

  <button class="btn quest-btn" id="questBtn">üìú Quests</button>

  <div class="quest-log" id="questLog">
    <div class="quest-log-header">
      <h3>üìú Quest Log</h3>
      <button class="quest-log-close" id="questLogClose">&times;</button>
    </div>
    <div class="quest-list" id="questList"></div>
  </div>

  <div class="loot-modal" id="lootModal">
    <div class="loot-container">
      <div class="loot-rarity" id="lootRarity">LEGENDARY</div>
      <div class="loot-title">üì¶ Treasure Found!</div>
      <div class="loot-tip" id="lootTip">Loading tip...</div>
      <button class="loot-close" id="lootClose">Collect</button>
    </div>
  </div>

  <div class="ui-overlay legend">
    <div class="legend-item">
      <div class="legend-dot" style="background: #ff6b35; box-shadow: 0 0 5px #ff6b35;"></div>
      <span>Claude ‚öîÔ∏è Warrior</span>
    </div>
    <div class="legend-item">
      <div class="legend-dot" style="background: #4285f4; box-shadow: 0 0 5px #4285f4;"></div>
      <span>Gemini üó°Ô∏è Ninja</span>
    </div>
    <div class="legend-item">
      <div class="legend-dot" style="background: #00ff88; box-shadow: 0 0 5px #00ff88;"></div>
      <span>Codex üîÆ Sura</span>
    </div>
    <div class="legend-item">
      <div class="legend-dot" style="background: #ae53ff; box-shadow: 0 0 5px #ae53ff;"></div>
      <span>Cursor ü™Ñ Shaman</span>
    </div>
  </div>

  <div class="ui-overlay stats">
    <h3>SYSTEM STATUS</h3>
    <div class="stat-row">
      <span>Total Agents</span>
      <span class="stat-value" id="totalAgents">0</span>
    </div>
    <div class="stat-row">
      <span>Active</span>
      <span class="stat-value" id="activeAgents">0</span>
    </div>
    <div class="stat-row">
      <span>Connections</span>
      <span class="stat-value" id="totalConnections">0</span>
    </div>
    <div class="stat-row">
      <span>Network Load</span>
      <span class="stat-value" id="networkLoad">0%</span>
    </div>
  </div>

  <div class="ui-overlay agent-info" id="agentInfo">
    <h3 id="agentName">AGENT-001</h3>
    <div class="agent-status status-active" id="agentStatus">ACTIVE</div>
    <div class="stat-row">
      <span>Type</span>
      <span class="stat-value" id="agentType">CLAUDE</span>
    </div>
    <div class="stat-row">
      <span>Tasks</span>
      <span class="stat-value" id="agentTasks">0</span>
    </div>
    <div class="stat-row">
      <span>Uptime</span>
      <span class="stat-value" id="agentUptime">0s</span>
    </div>
  </div>

  <div class="ui-overlay instructions">
    Drag to rotate ‚Ä¢ Scroll to zoom ‚Ä¢ Click agents to select
  </div>

  <button class="btn terminal-toggle" id="terminalToggle">CHRONICLE</button>

  <div class="ui-overlay terminal" id="terminal">
    <div class="terminal-header">
      <span>üìú Scribe's Chronicle</span>
      <div class="terminal-dots">
        <div class="terminal-dot" style="background: #8b4513;"></div>
        <div class="terminal-dot" style="background: #d4a857;"></div>
        <div class="terminal-dot" style="background: #7a8b65;"></div>
      </div>
    </div>
    <div class="terminal-log" id="terminalLog"></div>
    <div class="terminal-input-wrapper">
      <span class="terminal-prompt">></span>
      <input type="text" class="terminal-input" id="terminalInput" placeholder="type help for commands" autocomplete="off">
    </div>
  </div>

  <div class="chat-modal" id="chatModal">
    <div class="chat-container" id="chatContainer">
      <div class="chat-header">
        <h3 id="chatAgentName">CLAUDE-001</h3>
        <button class="chat-close" id="chatClose">&times;</button>
      </div>
      <div class="chat-messages" id="chatMessages"></div>
      <div class="chat-input-wrapper">
        <input type="text" class="chat-input" id="chatInput" placeholder="Say something...">
        <button class="chat-send" id="chatSend">SEND</button>
      </div>
    </div>
  </div>

  <div class="backlink"><a href="https://sloppy.live">sloppy.live</a></div>

  <!-- Supabase for faction persistence -->
  <script src="https://unpkg.com/@supabase/supabase-js@2"></script>
  <script src="/supabase-config.js"></script>

  <script type="importmap">
  {
    "imports": {
      "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
      "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
    }
  }
  </script>

  <script type="module">
    import * as THREE from 'three';
    import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
    import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
    import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
    import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
    import { CSS2DRenderer, CSS2DObject } from 'three/addons/renderers/CSS2DRenderer.js';

    // Scene setup
    const container = document.getElementById('canvas-container');
    const scene = new THREE.Scene();
    // Fantasy sky gradient - dark blue/purple twilight
    scene.background = new THREE.Color(0x0a0812);
    scene.fog = new THREE.Fog(0x0a0812, 15, 50);

    const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.set(15, 12, 15);

    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    container.appendChild(renderer.domElement);

    // CSS2D Renderer for speech bubbles
    const labelRenderer = new CSS2DRenderer();
    labelRenderer.setSize(window.innerWidth, window.innerHeight);
    labelRenderer.domElement.style.position = 'absolute';
    labelRenderer.domElement.style.top = '0px';
    labelRenderer.domElement.style.pointerEvents = 'none';
    container.appendChild(labelRenderer.domElement);

    // Post-processing for bloom/glow
    const composer = new EffectComposer(renderer);
    const renderPass = new RenderPass(scene, camera);
    composer.addPass(renderPass);

    const bloomPass = new UnrealBloomPass(
      new THREE.Vector2(window.innerWidth, window.innerHeight),
      1.2, 0.4, 0.85
    );
    composer.addPass(bloomPass);

    // Controls
    const controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;
    controls.dampingFactor = 0.05;
    controls.minDistance = 8;
    controls.maxDistance = 50;
    controls.maxPolarAngle = Math.PI / 2.2;

    // =====================================================
    // FACTION & TERRITORY SYSTEM
    // =====================================================
    const factionColors = {
      warriors: 0xff6b35,
      ninjas: 0x4a9eff,
      suras: 0xaa44ff,
      shamans: 0x44dd66,
      contested: 0x666666
    };

    const factionNames = {
      warriors: 'Warrior Guild',
      ninjas: 'Ninja Clan',
      suras: 'Sura Order',
      shamans: 'Shaman Circle',
      contested: 'Contested'
    };

    let myFaction = localStorage.getItem('realmFaction') || null;
    let supabaseClient = null;

    // Territory zones (4 quadrants)
    const territories = {
      north: { owner: 'contested', points: { warriors: 0, ninjas: 0, suras: 0, shamans: 0 }, mesh: null },
      east: { owner: 'contested', points: { warriors: 0, ninjas: 0, suras: 0, shamans: 0 }, mesh: null },
      south: { owner: 'contested', points: { warriors: 0, ninjas: 0, suras: 0, shamans: 0 }, mesh: null },
      west: { owner: 'contested', points: { warriors: 0, ninjas: 0, suras: 0, shamans: 0 }, mesh: null }
    };

    const territoryZones = []; // 3D zone markers

    // Initialize Supabase
    async function initSupabase() {
      if (typeof window.supabase !== 'undefined' && window.SUPABASE_URL) {
        supabaseClient = window.supabase.createClient(window.SUPABASE_URL, window.SUPABASE_ANON_KEY);
        await loadTerritoryData();
      }
    }

    // Load territory data from database
    async function loadTerritoryData() {
      if (!supabaseClient) return;

      try {
        const { data, error } = await supabaseClient
          .from('realm_territories')
          .select('*');

        if (data && data.length > 0) {
          // Aggregate points by zone and faction
          data.forEach(row => {
            if (territories[row.zone_id]) {
              const fac = row.faction;
              const pts = row.control_points || 0;
              if (territories[row.zone_id].points[fac] !== undefined) {
                territories[row.zone_id].points[fac] += pts;
              }
            }
          });

          // Determine owners
          Object.keys(territories).forEach(zone => {
            updateZoneOwner(zone);
          });
        }
      } catch (e) {
        console.log('Territory data not available:', e);
      }
    }

    // Update zone owner based on points
    function updateZoneOwner(zone) {
      const points = territories[zone].points;
      let maxPoints = 0;
      let owner = 'contested';

      Object.keys(points).forEach(faction => {
        if (points[faction] > maxPoints) {
          maxPoints = points[faction];
          owner = faction;
        }
      });

      // Need at least 10 points to own
      if (maxPoints < 10) owner = 'contested';

      territories[zone].owner = owner;
      updateTerritoryUI(zone);
      updateZoneMesh(zone);
    }

    // Update territory UI panel
    function updateTerritoryUI(zone) {
      const zoneEl = document.getElementById('zone' + zone.charAt(0).toUpperCase() + zone.slice(1));
      if (zoneEl) {
        zoneEl.textContent = factionNames[territories[zone].owner];
        zoneEl.className = 'territory-zone-owner ' + territories[zone].owner;
      }
    }

    // Update 3D zone mesh color
    function updateZoneMesh(zone) {
      const t = territories[zone];
      if (t.mesh) {
        t.mesh.material.color.setHex(factionColors[t.owner]);
        t.mesh.material.opacity = t.owner === 'contested' ? 0.15 : 0.3;
      }
    }

    // Create 3D territory zone markers
    function createTerritoryZones() {
      const zonePositions = {
        north: { x: 0, z: -8 },
        east: { x: 8, z: 0 },
        south: { x: 0, z: 8 },
        west: { x: -8, z: 0 }
      };

      Object.keys(zonePositions).forEach(zone => {
        const pos = zonePositions[zone];

        // Create zone ground marker
        const zoneGeo = new THREE.CircleGeometry(5, 32);
        zoneGeo.rotateX(-Math.PI / 2);
        const zoneMat = new THREE.MeshBasicMaterial({
          color: factionColors[territories[zone].owner],
          transparent: true,
          opacity: 0.15,
          side: THREE.DoubleSide
        });
        const zoneMesh = new THREE.Mesh(zoneGeo, zoneMat);
        zoneMesh.position.set(pos.x, 0.1, pos.z);
        zoneMesh.userData.zone = zone;
        scene.add(zoneMesh);
        territories[zone].mesh = zoneMesh;

        // Create zone pillar/beacon
        const pillarGeo = new THREE.CylinderGeometry(0.3, 0.5, 3, 8);
        const pillarMat = new THREE.MeshBasicMaterial({
          color: factionColors[territories[zone].owner],
          transparent: true,
          opacity: 0.6
        });
        const pillar = new THREE.Mesh(pillarGeo, pillarMat);
        pillar.position.set(pos.x, 1.5, pos.z);
        pillar.userData.zone = zone;
        pillar.userData.isPillar = true;
        scene.add(pillar);
        territoryZones.push(pillar);
      });
    }

    // Faction selection
    const factionModal = document.getElementById('factionModal');
    const factionBadge = document.getElementById('myFactionBadge');

    if (myFaction) {
      factionModal.classList.add('hidden');
      showFactionBadge();
    }

    document.querySelectorAll('.faction-card').forEach(card => {
      card.addEventListener('click', () => {
        const faction = card.dataset.faction;
        joinFaction(faction);
      });
    });

    async function joinFaction(faction) {
      myFaction = faction;
      localStorage.setItem('realmFaction', faction);
      factionModal.classList.add('hidden');
      showFactionBadge();

      // Save to database
      if (supabaseClient) {
        try {
          const { data: { user } } = await supabaseClient.auth.getUser();
          if (user) {
            await supabaseClient.from('realm_user_factions').upsert({
              user_id: user.id,
              faction: faction,
              contribution_points: 0
            });
          }
        } catch (e) {
          console.log('Could not save faction:', e);
        }
      }

      addLog(`[FACTION] Joined ${factionNames[faction]}!`, 'success');
    }

    function showFactionBadge() {
      if (myFaction) {
        factionBadge.textContent = factionNames[myFaction];
        factionBadge.className = 'my-faction-badge ' + myFaction;
      }
    }

    // Capture territory by clicking zone pillars
    const captureProgress = document.getElementById('captureProgress');
    const captureProgressFill = document.getElementById('captureProgressFill');
    const captureText = document.getElementById('captureText');
    let capturingZone = null;
    let captureAmount = 0;

    async function captureZone(zone) {
      if (!myFaction) {
        addLog('[SYSTEM] Join a faction first!', 'warning');
        return;
      }

      capturingZone = zone;
      captureAmount += 5;
      territories[zone].points[myFaction] += 5;

      // Show progress
      captureProgress.classList.add('visible');
      const total = Object.values(territories[zone].points).reduce((a, b) => a + b, 0);
      const myPts = territories[zone].points[myFaction];
      const pct = Math.min(100, (myPts / Math.max(total, 10)) * 100);
      captureProgressFill.style.width = pct + '%';
      captureProgressFill.style.background = '#' + factionColors[myFaction].toString(16).padStart(6, '0');
      captureText.textContent = `Capturing ${zone.charAt(0).toUpperCase() + zone.slice(1)}... (${myPts} pts)`;

      // Update zone
      updateZoneOwner(zone);

      // Save to database
      if (supabaseClient) {
        try {
          const { data: { user } } = await supabaseClient.auth.getUser();
          if (user) {
            await supabaseClient.from('realm_territories').insert({
              user_id: user.id,
              zone_id: zone,
              faction: myFaction,
              control_points: 5,
              last_captured_at: new Date().toISOString()
            });
          }
        } catch (e) {
          console.log('Could not save capture:', e);
        }
      }

      addLog(`[TERRITORY] +5 control points for ${factionNames[myFaction]} in ${zone}!`, 'success');

      // Hide progress after delay
      setTimeout(() => {
        captureProgress.classList.remove('visible');
        capturingZone = null;
      }, 2000);
    }

    // Click detection for territory pillars
    function setupTerritoryClicks() {
      renderer.domElement.addEventListener('click', (event) => {
        const mouse = new THREE.Vector2();
        mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
        mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

        const raycaster = new THREE.Raycaster();
        raycaster.setFromCamera(mouse, camera);

        const intersects = raycaster.intersectObjects(territoryZones);
        if (intersects.length > 0) {
          const hit = intersects[0].object;
          if (hit.userData.zone && hit.userData.isPillar) {
            captureZone(hit.userData.zone);
          }
        }
      });
    }

    // Initialize faction system
    initSupabase();
    setTimeout(createTerritoryZones, 100);
    setTimeout(setupTerritoryClicks, 200);

    // Terrain size
    const TERRAIN_SIZE = 40;
    const TERRAIN_SEGMENTS = 30;

    // Generate low-poly terrain
    function createTerrain() {
      const geometry = new THREE.PlaneGeometry(TERRAIN_SIZE, TERRAIN_SIZE, TERRAIN_SEGMENTS, TERRAIN_SEGMENTS);
      geometry.rotateX(-Math.PI / 2);

      const positions = geometry.attributes.position;
      const heightMap = [];

      for (let i = 0; i < positions.count; i++) {
        const x = positions.getX(i);
        const z = positions.getZ(i);
        // Simplex-like noise using sine waves
        let height = Math.sin(x * 0.3) * Math.cos(z * 0.3) * 1.5;
        height += Math.sin(x * 0.15 + 1) * Math.cos(z * 0.2 + 2) * 2;
        height += Math.random() * 0.3;
        positions.setY(i, height);
        heightMap.push(height);
      }

      geometry.computeVertexNormals();

      // Add vertex colors for fantasy terrain gradient
      const colors = [];
      for (let i = 0; i < positions.count; i++) {
        const height = positions.getY(i);
        // Color based on height: low = dark earth, mid = grass, high = rocky
        let r, g, b;
        if (height < -0.5) {
          // Low areas: dark muddy brown
          r = 0.15; g = 0.12; b = 0.08;
        } else if (height < 0.5) {
          // Mid areas: fantasy green grass
          r = 0.12 + height * 0.05;
          g = 0.25 + height * 0.1;
          b = 0.1;
        } else {
          // High areas: rocky/mossy
          r = 0.2 + height * 0.05;
          g = 0.22 + height * 0.03;
          b = 0.15;
        }
        colors.push(r, g, b);
      }
      geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));

      // Fantasy terrain with vertex colors
      const material = new THREE.MeshBasicMaterial({
        vertexColors: true,
        wireframe: false,
        side: THREE.DoubleSide
      });

      const terrain = new THREE.Mesh(geometry, material);
      scene.add(terrain);

      // Add subtle golden wireframe overlay for fantasy effect
      const wireMaterial = new THREE.MeshBasicMaterial({
        color: 0x8b7355,
        wireframe: true,
        transparent: true,
        opacity: 0.08
      });
      const wireframe = new THREE.Mesh(geometry.clone(), wireMaterial);
      wireframe.position.y = 0.02;
      scene.add(wireframe);

      return { geometry, heightMap };
    }

    const terrainData = createTerrain();

    // Get terrain height at position
    function getTerrainHeight(x, z) {
      const halfSize = TERRAIN_SIZE / 2;
      const segSize = TERRAIN_SIZE / TERRAIN_SEGMENTS;

      const gridX = Math.floor((x + halfSize) / segSize);
      const gridZ = Math.floor((z + halfSize) / segSize);

      const idx = gridZ * (TERRAIN_SEGMENTS + 1) + gridX;
      if (idx >= 0 && idx < terrainData.heightMap.length) {
        return terrainData.heightMap[idx];
      }
      return 0;
    }

    // Create fantasy tree
    function createTree(x, z) {
      const group = new THREE.Group();
      const baseHeight = getTerrainHeight(x, z);

      // Tree trunk - weathered brown bark
      const trunkGeo = new THREE.CylinderGeometry(0.1, 0.18, 1.8, 6);
      const trunkMat = new THREE.MeshBasicMaterial({ color: 0x3d2817 });
      const trunk = new THREE.Mesh(trunkGeo, trunkMat);
      trunk.position.y = 0.9;
      group.add(trunk);

      // Fantasy foliage colors - natural greens, autumn golds, mystical purples
      const treeColors = [
        0x2d5a27, // Deep forest green
        0x4a7a3a, // Lighter green
        0x6b4423, // Autumn orange-brown
        0xc4a35a, // Golden autumn
        0x3a2a4a, // Mystical purple
        0x1a4a3a  // Dark teal
      ];
      const color = treeColors[Math.floor(Math.random() * treeColors.length)];

      // Low-poly cone foliage layers
      for (let i = 0; i < 3; i++) {
        const coneGeo = new THREE.ConeGeometry(0.9 - i * 0.25, 1.4 - i * 0.3, 6);
        const coneMat = new THREE.MeshBasicMaterial({
          color: color,
          transparent: true,
          opacity: 0.85
        });
        const cone = new THREE.Mesh(coneGeo, coneMat);
        cone.position.y = 1.8 + i * 0.7;
        group.add(cone);
      }

      group.position.set(x, baseHeight, z);
      scene.add(group);
      return group;
    }

    // Create trees
    const trees = [];
    for (let i = 0; i < 25; i++) {
      const x = (Math.random() - 0.5) * (TERRAIN_SIZE - 5);
      const z = (Math.random() - 0.5) * (TERRAIN_SIZE - 5);
      trees.push(createTree(x, z));
    }

    // Agent data
    const agents = [];
    const connections = [];

    // AI Agent types with Metin2 classes and distinct colors
    const agentTypes = [
      { name: 'CLAUDE', color: 0xff6b35, metin2Class: 'Warrior', weapon: '‚öîÔ∏è' },
      { name: 'GEMINI', color: 0x4285f4, metin2Class: 'Ninja', weapon: 'üó°Ô∏è' },
      { name: 'CODEX', color: 0x00ff88, metin2Class: 'Sura', weapon: 'üîÆ' },
      { name: 'CURSOR', color: 0xae53ff, metin2Class: 'Shaman', weapon: 'ü™Ñ' }
    ];

    const statuses = ['active', 'idle', 'error', 'processing'];

    // Speech bubble messages by class
    const speechBubbles = {
      Warrior: ["For honor!", "Attack!", "Stand your ground!", "CHARGE!", "Victory awaits!"],
      Ninja: ["*vanishes*", "Silent strike...", "From the shadows!", "You won't see me coming", "Stealth mode"],
      Sura: ["Dark magic rises!", "Feel my power!", "Cursed blade!", "The void calls...", "Embrace darkness"],
      Shaman: ["Nature guide me", "Healing winds!", "Spirits protect us", "Balance restored", "Ancient wisdom"]
    };

    let selectedAgent = null;
    let agentCounter = 0;

    // Create class-specific weapon
    function createWeapon(metin2Class, color) {
      const weaponGroup = new THREE.Group();
      const glowMat = new THREE.MeshBasicMaterial({ color: color, transparent: true, opacity: 0.9 });
      const darkMat = new THREE.MeshBasicMaterial({ color: 0x1a1a2a });

      switch (metin2Class) {
        case 'Warrior':
          // MASSIVE glowing broadsword
          const bladeGeo = new THREE.BoxGeometry(0.12, 1.2, 0.04);
          const blade = new THREE.Mesh(bladeGeo, glowMat);
          blade.position.y = 0.6;
          weaponGroup.add(blade);
          // Blade edge glow
          const edgeGeo = new THREE.BoxGeometry(0.02, 1.15, 0.08);
          const edgeMat = new THREE.MeshBasicMaterial({ color: 0xffffff, transparent: true, opacity: 0.5 });
          const edge = new THREE.Mesh(edgeGeo, edgeMat);
          edge.position.y = 0.6;
          weaponGroup.add(edge);
          // Sword crossguard
          const guardGeo = new THREE.BoxGeometry(0.35, 0.06, 0.06);
          const guard = new THREE.Mesh(guardGeo, darkMat);
          guard.position.y = -0.02;
          weaponGroup.add(guard);
          // Sword hilt
          const hiltGeo = new THREE.CylinderGeometry(0.04, 0.05, 0.2, 6);
          const hilt = new THREE.Mesh(hiltGeo, darkMat);
          hilt.position.y = -0.14;
          weaponGroup.add(hilt);
          // Sword pommel
          const pommelGeo = new THREE.IcosahedronGeometry(0.06, 0);
          const pommel = new THREE.Mesh(pommelGeo, glowMat);
          pommel.position.y = -0.28;
          weaponGroup.add(pommel);
          weaponGroup.position.set(0.4, 0.5, 0.1);
          weaponGroup.rotation.z = -0.4;
          break;

        case 'Ninja':
          // Large glowing bow
          const bowCurve = new THREE.CatmullRomCurve3([
            new THREE.Vector3(0, -0.5, 0),
            new THREE.Vector3(0.15, -0.25, 0),
            new THREE.Vector3(0.2, 0, 0),
            new THREE.Vector3(0.15, 0.25, 0),
            new THREE.Vector3(0, 0.5, 0)
          ]);
          const bowGeo = new THREE.TubeGeometry(bowCurve, 16, 0.035, 8, false);
          const bow = new THREE.Mesh(bowGeo, glowMat);
          weaponGroup.add(bow);
          // Inner glow on bow
          const bowGlowCurve = new THREE.CatmullRomCurve3([
            new THREE.Vector3(0, -0.48, 0),
            new THREE.Vector3(0.13, -0.24, 0),
            new THREE.Vector3(0.18, 0, 0),
            new THREE.Vector3(0.13, 0.24, 0),
            new THREE.Vector3(0, 0.48, 0)
          ]);
          const bowGlowGeo = new THREE.TubeGeometry(bowGlowCurve, 16, 0.02, 6, false);
          const bowGlowMat = new THREE.MeshBasicMaterial({ color: 0xffffff, transparent: true, opacity: 0.4 });
          const bowGlow = new THREE.Mesh(bowGlowGeo, bowGlowMat);
          weaponGroup.add(bowGlow);
          // Bowstring
          const stringGeo = new THREE.BufferGeometry().setFromPoints([
            new THREE.Vector3(0, -0.5, 0),
            new THREE.Vector3(-0.08, 0, 0),
            new THREE.Vector3(0, 0.5, 0)
          ]);
          const stringMat = new THREE.LineBasicMaterial({ color: 0xffffff, transparent: true, opacity: 0.8 });
          const bowString = new THREE.Line(stringGeo, stringMat);
          weaponGroup.add(bowString);
          // Nocked arrow
          const arrowGeo = new THREE.CylinderGeometry(0.01, 0.01, 0.5, 4);
          const arrowMat = new THREE.MeshBasicMaterial({ color: 0xffffff });
          const arrow = new THREE.Mesh(arrowGeo, arrowMat);
          arrow.position.set(-0.04, 0, 0);
          arrow.rotation.z = Math.PI / 2;
          weaponGroup.add(arrow);
          // Arrowhead
          const arrowHeadGeo = new THREE.ConeGeometry(0.03, 0.08, 4);
          const arrowHead = new THREE.Mesh(arrowHeadGeo, glowMat);
          arrowHead.position.set(-0.29, 0, 0);
          arrowHead.rotation.z = -Math.PI / 2;
          weaponGroup.add(arrowHead);
          weaponGroup.position.set(-0.4, 0.65, 0.15);
          break;

        case 'Sura':
          // Dark magic orb on staff
          const staffGeo = new THREE.CylinderGeometry(0.02, 0.025, 0.8, 6);
          const staff = new THREE.Mesh(staffGeo, darkMat);
          staff.position.y = 0.4;
          weaponGroup.add(staff);
          // Magic orb
          const orbGeo = new THREE.IcosahedronGeometry(0.1, 1);
          const orb = new THREE.Mesh(orbGeo, glowMat);
          orb.position.y = 0.85;
          weaponGroup.add(orb);
          // Orbiting runes
          const runeGeo = new THREE.TorusGeometry(0.15, 0.01, 4, 8);
          const rune = new THREE.Mesh(runeGeo, new THREE.MeshBasicMaterial({ color: color, transparent: true, opacity: 0.5 }));
          rune.position.y = 0.85;
          rune.rotation.x = Math.PI / 4;
          weaponGroup.add(rune);
          weaponGroup.position.set(0.35, 0.3, 0);
          break;

        case 'Shaman':
          // Nature staff with crystal
          const natStaffGeo = new THREE.CylinderGeometry(0.025, 0.03, 0.9, 6);
          const natStaff = new THREE.Mesh(natStaffGeo, new THREE.MeshBasicMaterial({ color: 0x4a3520 }));
          natStaff.position.y = 0.45;
          weaponGroup.add(natStaff);
          // Crystal top
          const crystalGeo = new THREE.OctahedronGeometry(0.1, 0);
          const crystal = new THREE.Mesh(crystalGeo, glowMat);
          crystal.position.y = 0.95;
          weaponGroup.add(crystal);
          // Leaf decorations
          for (let i = 0; i < 3; i++) {
            const leafGeo = new THREE.ConeGeometry(0.04, 0.12, 4);
            const leafMat = new THREE.MeshBasicMaterial({ color: 0x00ff88, transparent: true, opacity: 0.7 });
            const leaf = new THREE.Mesh(leafGeo, leafMat);
            leaf.position.y = 0.75;
            leaf.position.x = Math.cos(i * 2.1) * 0.06;
            leaf.position.z = Math.sin(i * 2.1) * 0.06;
            leaf.rotation.z = 0.5;
            weaponGroup.add(leaf);
          }
          weaponGroup.position.set(-0.35, 0.3, 0);
          break;
      }
      return weaponGroup;
    }

    // Create class-specific armor
    function createArmor(metin2Class, color) {
      const armorGroup = new THREE.Group();
      const armorMat = new THREE.MeshBasicMaterial({ color: color, transparent: true, opacity: 0.8 });
      const darkArmorMat = new THREE.MeshBasicMaterial({ color: 0x2a2a3a });

      switch (metin2Class) {
        case 'Warrior':
          // Heavy shoulder pads
          for (let side of [-1, 1]) {
            const shoulderGeo = new THREE.BoxGeometry(0.18, 0.08, 0.15);
            const shoulder = new THREE.Mesh(shoulderGeo, armorMat);
            shoulder.position.set(side * 0.28, 0.95, 0);
            armorGroup.add(shoulder);
            // Spikes on shoulders
            const spikeGeo = new THREE.ConeGeometry(0.03, 0.12, 4);
            const spike = new THREE.Mesh(spikeGeo, armorMat);
            spike.position.set(side * 0.32, 1.05, 0);
            armorGroup.add(spike);
          }
          // Chest plate
          const chestGeo = new THREE.BoxGeometry(0.35, 0.25, 0.12);
          const chest = new THREE.Mesh(chestGeo, darkArmorMat);
          chest.position.set(0, 0.7, 0.08);
          armorGroup.add(chest);
          break;

        case 'Ninja':
          // Light cloth wraps
          const scarfGeo = new THREE.TorusGeometry(0.18, 0.03, 4, 8);
          const scarf = new THREE.Mesh(scarfGeo, armorMat);
          scarf.position.set(0, 1.05, 0);
          scarf.rotation.x = Math.PI / 2;
          armorGroup.add(scarf);
          // Arm bands
          for (let side of [-1, 1]) {
            const bandGeo = new THREE.TorusGeometry(0.08, 0.02, 4, 8);
            const band = new THREE.Mesh(bandGeo, armorMat);
            band.position.set(side * 0.25, 0.6, 0);
            band.rotation.z = Math.PI / 2;
            armorGroup.add(band);
          }
          break;

        case 'Sura':
          // Dark magical robes
          const robeGeo = new THREE.ConeGeometry(0.3, 0.5, 6);
          const robe = new THREE.Mesh(robeGeo, new THREE.MeshBasicMaterial({ color: 0x1a0a2a, transparent: true, opacity: 0.7 }));
          robe.position.set(0, 0.35, 0);
          armorGroup.add(robe);
          // Floating dark orbs around shoulders
          for (let i = 0; i < 2; i++) {
            const orbGeo = new THREE.SphereGeometry(0.06, 6, 4);
            const orb = new THREE.Mesh(orbGeo, armorMat);
            orb.position.set((i === 0 ? -1 : 1) * 0.35, 0.9, 0);
            armorGroup.add(orb);
          }
          break;

        case 'Shaman':
          // Nature-themed light armor
          // Leaf shoulder pieces
          for (let side of [-1, 1]) {
            const leafPadGeo = new THREE.ConeGeometry(0.1, 0.15, 5);
            const leafPad = new THREE.Mesh(leafPadGeo, new THREE.MeshBasicMaterial({ color: 0x00aa55, transparent: true, opacity: 0.8 }));
            leafPad.position.set(side * 0.25, 0.95, 0);
            leafPad.rotation.z = side * 0.5;
            armorGroup.add(leafPad);
          }
          // Necklace with gem
          const neckGeo = new THREE.TorusGeometry(0.12, 0.015, 4, 12);
          const neck = new THREE.Mesh(neckGeo, darkArmorMat);
          neck.position.set(0, 1.0, 0.05);
          neck.rotation.x = Math.PI / 3;
          armorGroup.add(neck);
          const gemGeo = new THREE.OctahedronGeometry(0.04, 0);
          const gem = new THREE.Mesh(gemGeo, armorMat);
          gem.position.set(0, 0.92, 0.1);
          armorGroup.add(gem);
          break;
      }
      return armorGroup;
    }

    // Create character unit with weapons and armor
    function createAgent(x, z, forceType = null) {
      const agentType = forceType || agentTypes[Math.floor(Math.random() * agentTypes.length)];
      const color = agentType.color;
      const colorHex = '#' + color.toString(16).padStart(6, '0');
      const status = statuses[Math.floor(Math.random() * 3)];
      const baseHeight = getTerrainHeight(x, z);

      const group = new THREE.Group();

      // Body - low poly capsule shape
      const bodyGeo = new THREE.CapsuleGeometry(0.25, 0.5, 4, 6);
      const bodyMat = new THREE.MeshBasicMaterial({ color: color });
      const body = new THREE.Mesh(bodyGeo, bodyMat);
      body.position.y = 0.6;
      group.add(body);

      // Head - simple sphere
      const headGeo = new THREE.IcosahedronGeometry(0.2, 0);
      const headMat = new THREE.MeshBasicMaterial({ color: color });
      const head = new THREE.Mesh(headGeo, headMat);
      head.position.y = 1.2;
      group.add(head);

      // Add class-specific armor
      const armor = createArmor(agentType.metin2Class, color);
      group.add(armor);

      // Add class-specific weapon
      const weapon = createWeapon(agentType.metin2Class, color);
      group.add(weapon);

      // Glow ring around unit
      const ringGeo = new THREE.TorusGeometry(0.5, 0.03, 8, 16);
      const ringMat = new THREE.MeshBasicMaterial({
        color: color,
        transparent: true,
        opacity: 0.6
      });
      const ring = new THREE.Mesh(ringGeo, ringMat);
      ring.rotation.x = Math.PI / 2;
      ring.position.y = 0.1;
      group.add(ring);

      // Status indicator above head
      const indicatorGeo = new THREE.OctahedronGeometry(0.12, 0);
      const indicatorMat = new THREE.MeshBasicMaterial({ color: color });
      const indicator = new THREE.Mesh(indicatorGeo, indicatorMat);
      indicator.position.y = 1.6;
      group.add(indicator);

      // Class label (floating above unit)
      const labelDiv = document.createElement('div');
      labelDiv.className = 'class-label';
      labelDiv.textContent = `${agentType.weapon} ${agentType.metin2Class}`;
      labelDiv.style.color = colorHex;
      labelDiv.style.borderColor = colorHex;
      const label = new CSS2DObject(labelDiv);
      label.position.set(0, 2, 0);
      group.add(label);

      group.position.set(x, baseHeight, z);
      scene.add(group);

      agentCounter++;
      const agent = {
        id: agentCounter,
        name: `${agentType.name}-${String(agentCounter).padStart(3, '0')}`,
        type: agentType.name,
        metin2Class: agentType.metin2Class,
        weapon: agentType.weapon,
        mesh: group,
        body: body,
        ring: ring,
        indicator: indicator,
        label: label,
        labelDiv: labelDiv,
        status: status,
        color: color,
        colorHex: colorHex,
        tasks: Math.floor(Math.random() * 100),
        uptime: Math.floor(Math.random() * 3600),
        connections: [],
        targetX: x,
        targetZ: z,
        walkSpeed: 0.02 + Math.random() * 0.02,
        speechBubble: null,
        lastSpeech: 0
      };

      agents.push(agent);
      updateStats();
      return agent;
    }

    // Short messages for bubbles (full responses for chat)
    const shortBubbleText = {
      Warrior: ["‚öîÔ∏è Huh?", "Attack!", "Hey!", "Ready!", "Hmph!"],
      Ninja: ["...", "*nods*", "Ssh!", "üëÄ", "!"],
      Sura: ["Hmm...", "Dark...", "‚ö°", "...", "Curse!"],
      Shaman: ["üåø", "Peace", "Ah...", "Spirit!", "Yes?"]
    };

    // Full AI responses for chat
    const aiResponses = {
      Warrior: [
        "Ready for battle! What orders do you have for me?",
        "My blade is sharp and my spirit is strong. How may I serve?",
        "A warrior never backs down from a challenge!",
        "Honor and glory await on the battlefield!",
        "Tell me where to strike, and victory shall be ours!"
      ],
      Ninja: [
        "I move unseen through the shadows... What intel do you have?",
        "Silence is my weapon. Patience is my shield.",
        "Every shadow has ears. Speak carefully.",
        "I'll complete any mission you assign. Discretion guaranteed.",
        "The art of stealth requires... subtlety."
      ],
      Sura: [
        "The dark energies flow through me. What do you seek?",
        "Power beyond mortal comprehension awaits those who dare...",
        "The void whispers secrets to those who listen.",
        "My cursed blade hungers. Point me at your enemies.",
        "Embrace the darkness, and it shall embrace you."
      ],
      Shaman: [
        "The spirits speak of your arrival. Welcome, friend.",
        "Nature's wisdom flows through all living things.",
        "I sense great potential in you. How may I guide you?",
        "Balance must be maintained in all things.",
        "The ancient ones watch over us. What troubles you?"
      ]
    };

    // Chat state per agent
    const chatHistories = {};

    // Show speech bubble for agent
    function showSpeechBubble(agent, customMsg = null) {
      // Remove existing bubble
      if (agent.speechBubble) {
        agent.mesh.remove(agent.speechBubble);
      }

      // Use short text for bubbles
      const messages = customMsg ? [customMsg] : shortBubbleText[agent.metin2Class];
      const message = messages[Math.floor(Math.random() * messages.length)];

      const bubbleDiv = document.createElement('div');
      bubbleDiv.className = 'speech-bubble';
      bubbleDiv.textContent = message;
      bubbleDiv.style.color = agent.colorHex;
      bubbleDiv.style.borderColor = agent.colorHex;

      // Make bubble clickable to open chat
      bubbleDiv.addEventListener('click', () => {
        openChatModal(agent);
      });

      const bubble = new CSS2DObject(bubbleDiv);
      bubble.position.set(0, 2.8, 0);
      agent.mesh.add(bubble);
      agent.speechBubble = bubble;

      // Remove after animation
      setTimeout(() => {
        if (agent.speechBubble === bubble) {
          agent.mesh.remove(bubble);
          agent.speechBubble = null;
        }
      }, 4000);
    }

    // Create connection between agents
    function createConnection(agent1, agent2) {
      if (agent1.connections.includes(agent2.id) || agent1 === agent2) return;

      const material = new THREE.LineBasicMaterial({
        color: 0x00ffff,
        transparent: true,
        opacity: 0.4
      });

      const points = [
        new THREE.Vector3(agent1.mesh.position.x, agent1.mesh.position.y + 1, agent1.mesh.position.z),
        new THREE.Vector3(agent2.mesh.position.x, agent2.mesh.position.y + 1, agent2.mesh.position.z)
      ];
      const geometry = new THREE.BufferGeometry().setFromPoints(points);
      const line = new THREE.Line(geometry, material);

      scene.add(line);

      const connection = { line, agent1, agent2 };
      connections.push(connection);
      agent1.connections.push(agent2.id);
      agent2.connections.push(agent1.id);
      updateStats();
    }

    // Update connection lines to follow agents
    function updateConnections() {
      connections.forEach(conn => {
        const positions = conn.line.geometry.attributes.position;
        positions.setXYZ(0, conn.agent1.mesh.position.x, conn.agent1.mesh.position.y + 1, conn.agent1.mesh.position.z);
        positions.setXYZ(1, conn.agent2.mesh.position.x, conn.agent2.mesh.position.y + 1, conn.agent2.mesh.position.z);
        positions.needsUpdate = true;
      });
    }

    // Remove agent
    function removeAgent(agent) {
      for (let i = connections.length - 1; i >= 0; i--) {
        const conn = connections[i];
        if (conn.agent1 === agent || conn.agent2 === agent) {
          scene.remove(conn.line);
          connections.splice(i, 1);
        }
      }

      agents.forEach(a => {
        a.connections = a.connections.filter(id => id !== agent.id);
      });

      scene.remove(agent.mesh);
      const idx = agents.indexOf(agent);
      if (idx > -1) agents.splice(idx, 1);

      if (selectedAgent === agent) {
        selectedAgent = null;
        document.getElementById('agentInfo').classList.remove('visible');
      }
      updateStats();
    }

    // Update stats display
    function updateStats() {
      document.getElementById('totalAgents').textContent = agents.length;
      document.getElementById('activeAgents').textContent = agents.filter(a => a.status === 'active').length;
      document.getElementById('totalConnections').textContent = connections.length;
      document.getElementById('networkLoad').textContent = Math.min(100, Math.floor((connections.length / Math.max(1, agents.length)) * 50)) + '%';
    }

    // Select agent
    function selectAgent(agent) {
      if (selectedAgent) {
        selectedAgent.mesh.scale.set(1, 1, 1);
      }

      selectedAgent = agent;
      agent.mesh.scale.set(1.3, 1.3, 1.3);

      const info = document.getElementById('agentInfo');
      info.classList.add('visible');
      document.getElementById('agentName').textContent = agent.name;

      const statusEl = document.getElementById('agentStatus');
      statusEl.textContent = agent.status.toUpperCase();
      statusEl.className = 'agent-status status-' + agent.status;

      document.getElementById('agentType').textContent = `${agent.type} (${agent.metin2Class})`;
      document.getElementById('agentTasks').textContent = agent.tasks;
      document.getElementById('agentUptime').textContent = formatTime(agent.uptime);
    }

    function formatTime(seconds) {
      if (seconds < 60) return seconds + 's';
      if (seconds < 3600) return Math.floor(seconds / 60) + 'm';
      return Math.floor(seconds / 3600) + 'h';
    }

    // Raycaster for clicking
    const raycaster = new THREE.Raycaster();
    const mouse = new THREE.Vector2();

    renderer.domElement.addEventListener('click', (event) => {
      mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
      mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

      raycaster.setFromCamera(mouse, camera);
      const meshes = agents.map(a => a.body);
      const intersects = raycaster.intersectObjects(meshes);

      if (intersects.length > 0) {
        const clickedMesh = intersects[0].object;
        const agent = agents.find(a => a.body === clickedMesh);
        if (agent) selectAgent(agent);
      }
    });

    // UI button handlers
    document.getElementById('addAgent').addEventListener('click', () => {
      const x = (Math.random() - 0.5) * (TERRAIN_SIZE - 5);
      const z = (Math.random() - 0.5) * (TERRAIN_SIZE - 5);
      const agent = createAgent(x, z);
      selectAgent(agent);
    });

    document.getElementById('connectAgents').addEventListener('click', () => {
      if (agents.length < 2) return;

      if (selectedAgent) {
        const others = agents.filter(a => a !== selectedAgent && !selectedAgent.connections.includes(a.id));
        if (others.length > 0) {
          const target = others[Math.floor(Math.random() * others.length)];
          createConnection(selectedAgent, target);
        }
      } else {
        const a1 = agents[Math.floor(Math.random() * agents.length)];
        const others = agents.filter(a => a !== a1 && !a1.connections.includes(a.id));
        if (others.length > 0) {
          const a2 = others[Math.floor(Math.random() * others.length)];
          createConnection(a1, a2);
        }
      }
    });

    document.getElementById('removeAgent').addEventListener('click', () => {
      if (selectedAgent) {
        removeAgent(selectedAgent);
      } else if (agents.length > 0) {
        removeAgent(agents[agents.length - 1]);
      }
    });

    // Animation loop
    function animate() {
      requestAnimationFrame(animate);

      const time = Date.now() * 0.001;

      // Animate agents
      agents.forEach((agent, i) => {
        // Ring rotation
        agent.ring.rotation.z += 0.03;

        // Indicator bobbing
        agent.indicator.rotation.y += 0.05;
        agent.indicator.position.y = 1.6 + Math.sin(time * 3 + i) * 0.1;

        // Random walking
        if (Math.random() < 0.01) {
          agent.targetX = (Math.random() - 0.5) * (TERRAIN_SIZE - 8);
          agent.targetZ = (Math.random() - 0.5) * (TERRAIN_SIZE - 8);
        }

        // Move toward target
        const dx = agent.targetX - agent.mesh.position.x;
        const dz = agent.targetZ - agent.mesh.position.z;
        const dist = Math.sqrt(dx * dx + dz * dz);

        if (dist > 0.5) {
          agent.mesh.position.x += (dx / dist) * agent.walkSpeed;
          agent.mesh.position.z += (dz / dist) * agent.walkSpeed;

          // Update Y to follow terrain
          agent.mesh.position.y = getTerrainHeight(agent.mesh.position.x, agent.mesh.position.z);

          // Face direction of movement
          agent.mesh.rotation.y = Math.atan2(dx, dz);

          // Walking bob
          agent.body.position.y = 0.6 + Math.abs(Math.sin(time * 10)) * 0.08;
        }

        // Random speech bubbles
        if (Math.random() < 0.002 && !agent.speechBubble) {
          showSpeechBubble(agent);
        }
      });

      // Update connection lines
      updateConnections();

      // Pulse connections
      connections.forEach((conn, i) => {
        const pulse = (Math.sin(time * 3 + i) + 1) / 2;
        conn.line.material.opacity = 0.2 + pulse * 0.4;
      });

      // Animate trees slightly
      trees.forEach((tree, i) => {
        tree.rotation.y = Math.sin(time * 0.5 + i) * 0.05;
      });

      // Animate treasure chest glows
      if (typeof treasureChests !== 'undefined') {
        treasureChests.forEach((chest, i) => {
          if (!chest.opened && chest.glow) {
            chest.glow.material.opacity = 0.3 + Math.sin(time * 2 + i) * 0.2;
            chest.glow.rotation.z += 0.01;
          }
        });
      }

      // Animate glitch boss and beams
      if (typeof animateGlitchBoss === 'function') {
        animateGlitchBoss(time);
      }
      if (typeof updateBeams === 'function') {
        updateBeams();
      }
      if (typeof updateDebugParticles === 'function') {
        updateDebugParticles();
      }

      controls.update();
      composer.render();
      labelRenderer.render(scene, camera);
    }

    // Initialize with some agents
    for (let i = 0; i < 5; i++) {
      const x = (Math.random() - 0.5) * 15;
      const z = (Math.random() - 0.5) * 15;
      createAgent(x, z);
    }

    // Create some initial connections
    if (agents.length >= 2) {
      createConnection(agents[0], agents[1]);
      if (agents.length >= 3) createConnection(agents[1], agents[2]);
      if (agents.length >= 4) createConnection(agents[2], agents[3]);
    }

    // Handle resize
    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
      labelRenderer.setSize(window.innerWidth, window.innerHeight);
      composer.setSize(window.innerWidth, window.innerHeight);
    });

    // Terminal functionality
    const terminalLog = document.getElementById('terminalLog');
    const terminalInput = document.getElementById('terminalInput');
    const terminal = document.getElementById('terminal');
    const terminalToggle = document.getElementById('terminalToggle');

    // Mobile toggle
    terminalToggle.addEventListener('click', () => {
      terminal.classList.toggle('visible');
    });

    // Fake activity messages
    const activityMessages = {
      info: [
        'Scanning network topology...',
        'Synchronizing agent protocols...',
        'Checking neural pathways...',
        'Validating crypto signatures...',
        'Parsing incoming data streams...',
        'Optimizing memory allocation...',
        'Calibrating response matrices...',
        'Indexing knowledge base...'
      ],
      success: [
        'Connection established',
        'Task completed successfully',
        'Data sync complete',
        'Agent handshake verified',
        'Protocol upgrade applied',
        'Cache refreshed',
        'Backup checkpoint saved'
      ],
      warning: [
        'High latency detected',
        'Memory usage elevated',
        'Queue backlog growing',
        'Rate limit approaching',
        'Fallback mode engaged'
      ],
      error: [
        'Connection timeout',
        'Authentication failed',
        'Resource unavailable',
        'Buffer overflow prevented',
        'Invalid response format'
      ]
    };

    const taskTypes = [
      'data_analysis', 'code_review', 'content_gen', 'model_training',
      'inference_run', 'chat_response', 'embedding_calc', 'search_query',
      'summarization', 'translation', 'classification', 'sentiment_scan'
    ];

    function getTimestamp() {
      const now = new Date();
      return now.toTimeString().split(' ')[0];
    }

    function addLog(message, type = 'info') {
      const entry = document.createElement('div');
      entry.className = 'log-entry';
      entry.innerHTML = `<span class="log-time">[${getTimestamp()}]</span> <span class="log-${type}">${message}</span>`;
      terminalLog.appendChild(entry);
      terminalLog.scrollTop = terminalLog.scrollHeight;

      // Keep log clean (max 50 entries)
      while (terminalLog.children.length > 50) {
        terminalLog.removeChild(terminalLog.firstChild);
      }
    }

    // Generate fake activity logs
    function generateActivity() {
      if (agents.length === 0) return;

      const roll = Math.random();
      let type, messages;

      if (roll < 0.5) {
        type = 'info';
        messages = activityMessages.info;
      } else if (roll < 0.75) {
        type = 'success';
        messages = activityMessages.success;
      } else if (roll < 0.9) {
        type = 'warning';
        messages = activityMessages.warning;
      } else {
        type = 'error';
        messages = activityMessages.error;
      }

      const agent = agents[Math.floor(Math.random() * agents.length)];
      const msg = messages[Math.floor(Math.random() * messages.length)];
      addLog(`[${agent.name}] ${msg}`, type);

      // Sometimes update agent status based on activity
      if (type === 'error' && Math.random() < 0.3) {
        updateAgentStatus(agent, 'error');
      } else if (type === 'success' && agent.status === 'error') {
        updateAgentStatus(agent, 'active');
      }
    }

    // Update agent status
    function updateAgentStatus(agent, newStatus) {
      const oldStatus = agent.status;
      agent.status = newStatus;

      // Update indicator color
      const statusColors = {
        active: 0x00ff88,
        idle: 0xffee00,
        error: 0xff3366,
        processing: 0x00ffff
      };

      agent.indicator.material.color.setHex(statusColors[newStatus] || 0x00ff88);

      // Update UI if selected
      if (selectedAgent === agent) {
        const statusEl = document.getElementById('agentStatus');
        statusEl.textContent = newStatus.toUpperCase();
        statusEl.className = 'agent-status status-' + newStatus;
      }

      updateStats();
      addLog(`[${agent.name}] Status: ${oldStatus} ‚Üí ${newStatus}`, newStatus === 'error' ? 'error' : 'success');
    }

    // Process terminal commands
    function processCommand(cmd) {
      const parts = cmd.trim().toLowerCase().split(/\s+/);
      const command = parts[0];

      addLog(`> ${cmd}`, 'info');

      switch (command) {
        case 'help':
          addLog('Available commands:', 'success');
          addLog('  status <agent> <active|idle|error|processing>', 'info');
          addLog('  task <agent> - assign random task', 'info');
          addLog('  list - show all agents', 'info');
          addLog('  ping <agent> - ping an agent', 'info');
          addLog('  heal <agent> - restore agent to active', 'info');
          addLog('  broadcast <msg> - message all agents', 'info');
          addLog('  clear - clear terminal', 'info');
          break;

        case 'list':
          addLog(`Active agents (${agents.length}):`, 'success');
          agents.forEach(a => {
            addLog(`  ${a.name} [${a.status}] ${a.weapon}${a.metin2Class}`, 'agent');
          });
          break;

        case 'status':
          if (parts.length < 3) {
            addLog('Usage: status <agent> <active|idle|error|processing>', 'warning');
            break;
          }
          const statusAgent = agents.find(a => a.name.toLowerCase().includes(parts[1]));
          if (!statusAgent) {
            addLog(`Agent "${parts[1]}" not found`, 'error');
            break;
          }
          const validStatuses = ['active', 'idle', 'error', 'processing'];
          if (!validStatuses.includes(parts[2])) {
            addLog(`Invalid status. Use: ${validStatuses.join(', ')}`, 'error');
            break;
          }
          updateAgentStatus(statusAgent, parts[2]);
          break;

        case 'task':
          if (parts.length < 2) {
            addLog('Usage: task <agent>', 'warning');
            break;
          }
          const taskAgent = agents.find(a => a.name.toLowerCase().includes(parts[1]));
          if (!taskAgent) {
            addLog(`Agent "${parts[1]}" not found`, 'error');
            break;
          }
          const task = taskTypes[Math.floor(Math.random() * taskTypes.length)];
          taskAgent.tasks++;
          if (selectedAgent === taskAgent) {
            document.getElementById('agentTasks').textContent = taskAgent.tasks;
          }
          updateAgentStatus(taskAgent, 'processing');
          addLog(`Assigned ${task} to ${taskAgent.name}`, 'success');
          setTimeout(() => {
            if (taskAgent.status === 'processing') {
              updateAgentStatus(taskAgent, 'active');
              addLog(`[${taskAgent.name}] Completed ${task}`, 'success');
            }
          }, 2000 + Math.random() * 3000);
          break;

        case 'ping':
          if (parts.length < 2) {
            addLog('Usage: ping <agent>', 'warning');
            break;
          }
          const pingAgent = agents.find(a => a.name.toLowerCase().includes(parts[1]));
          if (!pingAgent) {
            addLog(`Agent "${parts[1]}" not found`, 'error');
            break;
          }
          const latency = Math.floor(Math.random() * 150) + 10;
          addLog(`Pinging ${pingAgent.name}...`, 'info');
          setTimeout(() => {
            addLog(`[${pingAgent.name}] PONG! ${latency}ms`, 'success');
            showSpeechBubble(pingAgent);
          }, latency);
          break;

        case 'heal':
          if (parts.length < 2) {
            addLog('Usage: heal <agent>', 'warning');
            break;
          }
          const healAgent = agents.find(a => a.name.toLowerCase().includes(parts[1]));
          if (!healAgent) {
            addLog(`Agent "${parts[1]}" not found`, 'error');
            break;
          }
          if (healAgent.status === 'active') {
            addLog(`${healAgent.name} is already active`, 'info');
          } else {
            addLog(`Healing ${healAgent.name}...`, 'info');
            updateAgentStatus(healAgent, 'active');
          }
          break;

        case 'broadcast':
          if (parts.length < 2) {
            addLog('Usage: broadcast <message>', 'warning');
            break;
          }
          const broadcastMsg = parts.slice(1).join(' ');
          addLog(`Broadcasting: "${broadcastMsg}"`, 'success');
          agents.forEach((a, i) => {
            setTimeout(() => showSpeechBubble(a), i * 300);
          });
          break;

        case 'clear':
          terminalLog.innerHTML = '';
          addLog('Terminal cleared', 'success');
          break;

        default:
          addLog(`Unknown command: ${command}. Type "help" for commands.`, 'error');
      }
    }

    // Terminal input handling
    terminalInput.addEventListener('keydown', (e) => {
      if (e.key === 'Enter' && terminalInput.value.trim()) {
        processCommand(terminalInput.value);
        terminalInput.value = '';
      }
    });

    // Initial log entries
    addLog('Agent Control Terminal v1.0', 'success');
    addLog('Type "help" for available commands', 'info');
    addLog('Initializing agent network...', 'info');
    setTimeout(() => addLog('Network initialized. Agents online.', 'success'), 500);

    // Auto-generate fake activity
    setInterval(generateActivity, 3000 + Math.random() * 2000);

    // Chat modal functionality
    const chatModal = document.getElementById('chatModal');
    const chatContainer = document.getElementById('chatContainer');
    const chatAgentName = document.getElementById('chatAgentName');
    const chatMessages = document.getElementById('chatMessages');
    const chatInput = document.getElementById('chatInput');
    const chatSend = document.getElementById('chatSend');
    const chatClose = document.getElementById('chatClose');

    let currentChatAgent = null;

    function openChatModal(agent) {
      currentChatAgent = agent;
      chatAgentName.textContent = `${agent.weapon} ${agent.name}`;
      chatAgentName.style.color = agent.colorHex;
      chatContainer.style.borderColor = agent.colorHex;

      // Initialize chat history for this agent
      if (!chatHistories[agent.id]) {
        chatHistories[agent.id] = [];
        // Add initial greeting
        const greeting = aiResponses[agent.metin2Class][0];
        chatHistories[agent.id].push({ type: 'agent', text: greeting });
      }

      // Render chat history
      renderChatMessages(agent);

      chatModal.classList.add('visible');
      chatInput.focus();

      // Log to terminal
      addLog(`[CHAT] Opened chat with ${agent.name}`, 'info');
    }

    function renderChatMessages(agent) {
      chatMessages.innerHTML = '';
      const history = chatHistories[agent.id] || [];

      history.forEach(msg => {
        const msgDiv = document.createElement('div');
        msgDiv.className = `chat-message ${msg.type}`;
        msgDiv.textContent = msg.text;
        if (msg.type === 'agent') {
          msgDiv.style.borderLeftColor = agent.colorHex;
        }
        chatMessages.appendChild(msgDiv);
      });

      chatMessages.scrollTop = chatMessages.scrollHeight;
    }

    function sendChatMessage() {
      const text = chatInput.value.trim();
      if (!text || !currentChatAgent) return;

      // Add user message
      chatHistories[currentChatAgent.id].push({ type: 'user', text: text });

      // Generate AI response
      const responses = aiResponses[currentChatAgent.metin2Class];
      const response = responses[Math.floor(Math.random() * responses.length)];

      // Simulate typing delay
      setTimeout(() => {
        chatHistories[currentChatAgent.id].push({ type: 'agent', text: response });
        renderChatMessages(currentChatAgent);

        // Show short bubble on the agent
        showSpeechBubble(currentChatAgent, shortBubbleText[currentChatAgent.metin2Class][Math.floor(Math.random() * 5)]);

        // Log to terminal
        addLog(`[${currentChatAgent.name}] Responded to chat`, 'success');
      }, 500 + Math.random() * 1000);

      chatInput.value = '';
      renderChatMessages(currentChatAgent);
    }

    chatSend.addEventListener('click', sendChatMessage);
    chatInput.addEventListener('keydown', (e) => {
      if (e.key === 'Enter') sendChatMessage();
    });

    chatClose.addEventListener('click', () => {
      chatModal.classList.remove('visible');
      currentChatAgent = null;
    });

    chatModal.addEventListener('click', (e) => {
      if (e.target === chatModal) {
        chatModal.classList.remove('visible');
        currentChatAgent = null;
      }
    });

    // Quest System with Technical Tips
    const quests = [
      { id: 1, title: 'Debug the Matrix', rarity: 'common', xp: 50, tip: 'Use console.log() strategically to trace data flow. Remove them before production!' },
      { id: 2, title: 'Master the Shadows', rarity: 'common', xp: 75, tip: 'CSS box-shadow can layer multiple shadows: box-shadow: 0 2px 4px rgba(0,0,0,0.2), 0 4px 8px rgba(0,0,0,0.1);' },
      { id: 3, title: 'Optimize the Forge', rarity: 'rare', xp: 150, tip: 'Use requestAnimationFrame() for smooth animations instead of setInterval(). It syncs with display refresh rate.' },
      { id: 4, title: 'Decode Ancient Scripts', rarity: 'rare', xp: 200, tip: 'Destructuring assignment: const {x, y} = object; Extract multiple properties in one line!' },
      { id: 5, title: 'Tame the Async Beast', rarity: 'epic', xp: 300, tip: 'async/await makes Promise chains readable. Always wrap in try/catch for error handling.' },
      { id: 6, title: 'Unlock Three.js Secrets', rarity: 'epic', xp: 400, tip: 'Reuse geometries and materials in Three.js. Creating new ones each frame causes memory leaks!' },
      { id: 7, title: 'Legendary Code Artifact', rarity: 'legendary', xp: 1000, tip: 'WeakMap and WeakSet allow garbage collection of keys. Perfect for caching without memory leaks.' }
    ];

    const treasureTips = {
      common: [
        'Array.isArray() is the safest way to check if something is an array.',
        'Use template literals: `Hello ${name}` instead of "Hello " + name',
        'const and let are block-scoped. var is function-scoped. Prefer const.',
        'Optional chaining: obj?.prop?.nested safely accesses nested properties.'
      ],
      rare: [
        'Array.from() converts array-like objects to real arrays with map support.',
        'Object.entries() returns [key, value] pairs for easy iteration.',
        'The nullish coalescing operator ?? only checks for null/undefined, not falsy.',
        'Use performance.now() for precise timing measurements in milliseconds.'
      ],
      epic: [
        'Proxy objects can intercept and customize fundamental operations like property access.',
        'Web Workers run JavaScript in background threads without blocking UI.',
        'IntersectionObserver is more efficient than scroll events for lazy loading.',
        'CSS contain: layout paint; can significantly improve render performance.'
      ],
      legendary: [
        'SharedArrayBuffer enables true shared memory between workers for parallel computing.',
        'Atomics provides atomic operations for thread-safe programming in JavaScript.',
        'The Temporal API (upcoming) will finally fix JavaScript date handling.',
        'Import assertions allow type checking for JSON and CSS module imports.'
      ]
    };

    // Quest Log UI
    const questLog = document.getElementById('questLog');
    const questList = document.getElementById('questList');
    const questBtn = document.getElementById('questBtn');
    const questLogClose = document.getElementById('questLogClose');

    function renderQuests() {
      questList.innerHTML = '';
      quests.forEach(quest => {
        const div = document.createElement('div');
        div.className = `quest-item ${quest.rarity}`;
        div.innerHTML = `
          <div class="quest-title">${quest.title}</div>
          <div class="quest-xp">+${quest.xp} XP</div>
        `;
        div.addEventListener('click', () => {
          showLoot(quest.rarity, quest.tip);
          addLog(`[QUEST] Completed: ${quest.title} (+${quest.xp} XP)`, 'success');
        });
        questList.appendChild(div);
      });
    }

    questBtn.addEventListener('click', () => {
      questLog.classList.toggle('visible');
      if (questLog.classList.contains('visible')) {
        renderQuests();
      }
    });

    questLogClose.addEventListener('click', () => {
      questLog.classList.remove('visible');
    });

    // Loot Modal
    const lootModal = document.getElementById('lootModal');
    const lootRarity = document.getElementById('lootRarity');
    const lootTip = document.getElementById('lootTip');
    const lootClose = document.getElementById('lootClose');

    function showLoot(rarity, tip) {
      const tipText = tip || treasureTips[rarity][Math.floor(Math.random() * treasureTips[rarity].length)];
      lootRarity.textContent = rarity.toUpperCase();
      lootRarity.className = `loot-rarity ${rarity}`;
      lootTip.textContent = tipText;
      lootModal.classList.add('visible');
    }

    lootClose.addEventListener('click', () => {
      lootModal.classList.remove('visible');
    });

    lootModal.addEventListener('click', (e) => {
      if (e.target === lootModal) {
        lootModal.classList.remove('visible');
      }
    });

    // Create 3D Treasure Chest
    const treasureChests = [];

    function createTreasureChest(x, z) {
      const group = new THREE.Group();
      const baseHeight = getTerrainHeight(x, z);

      // Chest base
      const baseGeo = new THREE.BoxGeometry(0.5, 0.35, 0.35);
      const baseMat = new THREE.MeshBasicMaterial({ color: 0x6b4423 });
      const base = new THREE.Mesh(baseGeo, baseMat);
      base.position.y = 0.175;
      group.add(base);

      // Chest lid (curved top)
      const lidGeo = new THREE.CylinderGeometry(0.18, 0.25, 0.5, 8, 1, false, 0, Math.PI);
      const lidMat = new THREE.MeshBasicMaterial({ color: 0x8b5a2b });
      const lid = new THREE.Mesh(lidGeo, lidMat);
      lid.rotation.z = Math.PI / 2;
      lid.rotation.y = Math.PI / 2;
      lid.position.y = 0.35;
      group.add(lid);

      // Gold trim
      const trimGeo = new THREE.BoxGeometry(0.52, 0.05, 0.37);
      const trimMat = new THREE.MeshBasicMaterial({ color: 0xd4a857 });
      const trim = new THREE.Mesh(trimGeo, trimMat);
      trim.position.y = 0.35;
      group.add(trim);

      // Lock
      const lockGeo = new THREE.BoxGeometry(0.08, 0.1, 0.05);
      const lockMat = new THREE.MeshBasicMaterial({ color: 0xd4a857 });
      const lock = new THREE.Mesh(lockGeo, lockMat);
      lock.position.set(0, 0.2, 0.2);
      group.add(lock);

      // Glow ring
      const glowGeo = new THREE.TorusGeometry(0.4, 0.02, 8, 16);
      const glowMat = new THREE.MeshBasicMaterial({
        color: 0xd4a857,
        transparent: true,
        opacity: 0.4
      });
      const glow = new THREE.Mesh(glowGeo, glowMat);
      glow.rotation.x = Math.PI / 2;
      glow.position.y = 0.05;
      group.add(glow);

      group.position.set(x, baseHeight, z);
      scene.add(group);

      // Determine rarity
      const roll = Math.random();
      let rarity;
      if (roll < 0.5) rarity = 'common';
      else if (roll < 0.8) rarity = 'rare';
      else if (roll < 0.95) rarity = 'epic';
      else rarity = 'legendary';

      const chest = { mesh: group, base, glow, rarity, opened: false };
      treasureChests.push(chest);
      return chest;
    }

    // Create initial treasure chests
    for (let i = 0; i < 5; i++) {
      const x = (Math.random() - 0.5) * (TERRAIN_SIZE - 10);
      const z = (Math.random() - 0.5) * (TERRAIN_SIZE - 10);
      createTreasureChest(x, z);
    }

    // Click detection for treasure chests
    renderer.domElement.addEventListener('click', (event) => {
      mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
      mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

      raycaster.setFromCamera(mouse, camera);
      const chestMeshes = treasureChests.filter(c => !c.opened).map(c => c.base);
      const intersects = raycaster.intersectObjects(chestMeshes);

      if (intersects.length > 0) {
        const clickedMesh = intersects[0].object;
        const chest = treasureChests.find(c => c.base === clickedMesh);
        if (chest && !chest.opened) {
          chest.opened = true;
          showLoot(chest.rarity);
          addLog(`[LOOT] Opened ${chest.rarity} treasure chest!`, chest.rarity === 'legendary' ? 'success' : 'info');

          // Animate chest opening
          chest.mesh.children.forEach(child => {
            child.material.transparent = true;
          });

          // Fade out chest
          let opacity = 1;
          const fadeInterval = setInterval(() => {
            opacity -= 0.05;
            chest.mesh.children.forEach(child => {
              if (child.material) child.material.opacity = opacity;
            });
            if (opacity <= 0) {
              clearInterval(fadeInterval);
              scene.remove(chest.mesh);
              // Spawn new chest elsewhere
              setTimeout(() => {
                const x = (Math.random() - 0.5) * (TERRAIN_SIZE - 10);
                const z = (Math.random() - 0.5) * (TERRAIN_SIZE - 10);
                createTreasureChest(x, z);
              }, 5000);
            }
          }, 50);
        }
      }
    });

    // ========== GLITCH BOSS SYSTEM ==========
    const bossUI = document.getElementById('bossUI');
    const bossHealthBar = document.getElementById('bossHealthBar');
    const bossHealthText = document.getElementById('bossHealthText');
    const bossStatus = document.getElementById('bossStatus');

    let glitchBoss = null;
    let bossHealth = 1000;
    const bossMaxHealth = 1000;
    const beams = [];

    const bossStatusMessages = [
      'Corrupted code detected...',
      'Syntax errors multiplying!',
      'Memory leak spreading...',
      'Stack overflow imminent!',
      'Infinite loop detected!',
      'Null pointer exception!',
      'Type coercion chaos!',
      'Callback hell unleashed!'
    ];

    function createGlitchBoss() {
      const group = new THREE.Group();

      // Main body - corrupted polyhedron
      const bodyGeo = new THREE.IcosahedronGeometry(2, 1);
      // Distort vertices for glitchy look
      const positions = bodyGeo.attributes.position;
      for (let i = 0; i < positions.count; i++) {
        positions.setX(i, positions.getX(i) + (Math.random() - 0.5) * 0.3);
        positions.setY(i, positions.getY(i) + (Math.random() - 0.5) * 0.3);
        positions.setZ(i, positions.getZ(i) + (Math.random() - 0.5) * 0.3);
      }
      const bodyMat = new THREE.MeshBasicMaterial({
        color: 0xff3366,
        wireframe: true,
        transparent: true,
        opacity: 0.8
      });
      const body = new THREE.Mesh(bodyGeo, bodyMat);
      group.add(body);

      // Inner core - solid glowing
      const coreGeo = new THREE.IcosahedronGeometry(1.2, 0);
      const coreMat = new THREE.MeshBasicMaterial({
        color: 0xff0044,
        transparent: true,
        opacity: 0.6
      });
      const core = new THREE.Mesh(coreGeo, coreMat);
      group.add(core);

      // Glitch cubes orbiting
      const glitchCubes = [];
      for (let i = 0; i < 8; i++) {
        const cubeGeo = new THREE.BoxGeometry(0.4, 0.4, 0.4);
        const cubeMat = new THREE.MeshBasicMaterial({
          color: [0xff3366, 0x00ffff, 0xff00ff, 0xffff00][i % 4],
          transparent: true,
          opacity: 0.7
        });
        const cube = new THREE.Mesh(cubeGeo, cubeMat);
        cube.userData.orbitAngle = (i / 8) * Math.PI * 2;
        cube.userData.orbitRadius = 2.5 + Math.random() * 0.5;
        cube.userData.orbitSpeed = 0.02 + Math.random() * 0.02;
        cube.userData.yOffset = (Math.random() - 0.5) * 2;
        glitchCubes.push(cube);
        group.add(cube);
      }

      // Error symbols floating around
      const errorSymbols = [];
      const symbolGeo = new THREE.OctahedronGeometry(0.25, 0);
      for (let i = 0; i < 12; i++) {
        const symMat = new THREE.MeshBasicMaterial({
          color: 0xff6666,
          transparent: true,
          opacity: 0.5
        });
        const sym = new THREE.Mesh(symbolGeo, symMat);
        sym.userData.floatAngle = Math.random() * Math.PI * 2;
        sym.userData.floatRadius = 3 + Math.random() * 1.5;
        sym.userData.floatSpeed = 0.01 + Math.random() * 0.015;
        sym.userData.yBase = (Math.random() - 0.5) * 3;
        errorSymbols.push(sym);
        group.add(sym);
      }

      // Corruption tendrils
      const tendrils = [];
      for (let i = 0; i < 6; i++) {
        const tendrilGeo = new THREE.CylinderGeometry(0.05, 0.15, 3, 6);
        const tendrilMat = new THREE.MeshBasicMaterial({
          color: 0x990033,
          transparent: true,
          opacity: 0.6
        });
        const tendril = new THREE.Mesh(tendrilGeo, tendrilMat);
        tendril.rotation.x = Math.random() * Math.PI;
        tendril.rotation.z = (i / 6) * Math.PI * 2;
        tendril.position.y = -1;
        tendrils.push(tendril);
        group.add(tendril);
      }

      // Position boss in center, floating above terrain
      const centerHeight = getTerrainHeight(0, 0);
      group.position.set(0, centerHeight + 4, 0);
      scene.add(group);

      glitchBoss = {
        mesh: group,
        body,
        core,
        glitchCubes,
        errorSymbols,
        tendrils,
        health: bossMaxHealth,
        defeated: false
      };

      bossUI.classList.add('visible');
      addLog('[ALERT] GLITCH_OVERLORD has spawned!', 'error');
      addLog('[SYSTEM] Agents engaging corrupted code...', 'warning');

      return glitchBoss;
    }

    // Create medieval projectile from agent to boss
    function createBeam(agent) {
      if (!glitchBoss || glitchBoss.defeated) return;

      const agentPos = agent.mesh.position.clone();
      agentPos.y += 1.2;
      const bossPos = glitchBoss.mesh.position.clone();
      bossPos.y += 1;

      const direction = bossPos.clone().sub(agentPos).normalize();

      let projectile;
      const projectileGroup = new THREE.Group();

      // Class-specific projectiles
      if (agent.metin2Class === 'Warrior') {
        // Fireball - orange/red glowing sphere with particles
        const fireCore = new THREE.Mesh(
          new THREE.SphereGeometry(0.15, 8, 8),
          new THREE.MeshBasicMaterial({ color: 0xff4400 })
        );
        const fireOuter = new THREE.Mesh(
          new THREE.SphereGeometry(0.22, 8, 8),
          new THREE.MeshBasicMaterial({ color: 0xff8800, transparent: true, opacity: 0.5 })
        );
        const fireGlow = new THREE.Mesh(
          new THREE.SphereGeometry(0.3, 8, 8),
          new THREE.MeshBasicMaterial({ color: 0xffaa00, transparent: true, opacity: 0.2 })
        );
        projectileGroup.add(fireCore, fireOuter, fireGlow);
        projectileGroup.userData.type = 'fireball';
      } else if (agent.metin2Class === 'Ninja') {
        // Wooden arrow with arrowhead
        const shaft = new THREE.Mesh(
          new THREE.CylinderGeometry(0.02, 0.02, 0.6, 6),
          new THREE.MeshBasicMaterial({ color: 0x8B4513 })
        );
        shaft.rotation.x = Math.PI / 2;
        const head = new THREE.Mesh(
          new THREE.ConeGeometry(0.05, 0.15, 4),
          new THREE.MeshBasicMaterial({ color: 0x555555 })
        );
        head.rotation.x = -Math.PI / 2;
        head.position.z = 0.35;
        const fletching = new THREE.Mesh(
          new THREE.BoxGeometry(0.12, 0.01, 0.08),
          new THREE.MeshBasicMaterial({ color: 0x884422 })
        );
        fletching.position.z = -0.25;
        projectileGroup.add(shaft, head, fletching);
        projectileGroup.userData.type = 'arrow';
      } else if (agent.metin2Class === 'Sura') {
        // Dark magic orb - purple with swirling effect
        const darkCore = new THREE.Mesh(
          new THREE.IcosahedronGeometry(0.12, 0),
          new THREE.MeshBasicMaterial({ color: 0x440088 })
        );
        const darkAura = new THREE.Mesh(
          new THREE.SphereGeometry(0.2, 8, 8),
          new THREE.MeshBasicMaterial({ color: 0x8800ff, transparent: true, opacity: 0.4 })
        );
        const darkRing = new THREE.Mesh(
          new THREE.TorusGeometry(0.18, 0.02, 6, 12),
          new THREE.MeshBasicMaterial({ color: 0xaa00ff })
        );
        projectileGroup.add(darkCore, darkAura, darkRing);
        projectileGroup.userData.type = 'darkorb';
      } else {
        // Shaman - Nature orb with leaves
        const natureCore = new THREE.Mesh(
          new THREE.SphereGeometry(0.1, 8, 8),
          new THREE.MeshBasicMaterial({ color: 0x22aa22 })
        );
        const leafGlow = new THREE.Mesh(
          new THREE.SphereGeometry(0.18, 8, 8),
          new THREE.MeshBasicMaterial({ color: 0x44ff44, transparent: true, opacity: 0.3 })
        );
        // Add leaf shapes
        for (let i = 0; i < 3; i++) {
          const leaf = new THREE.Mesh(
            new THREE.ConeGeometry(0.06, 0.15, 4),
            new THREE.MeshBasicMaterial({ color: 0x228822 })
          );
          leaf.rotation.z = (i / 3) * Math.PI * 2;
          leaf.position.x = Math.cos((i / 3) * Math.PI * 2) * 0.12;
          leaf.position.y = Math.sin((i / 3) * Math.PI * 2) * 0.12;
          projectileGroup.add(leaf);
        }
        projectileGroup.add(natureCore, leafGlow);
        projectileGroup.userData.type = 'nature';
      }

      projectileGroup.position.copy(agentPos);
      projectileGroup.lookAt(bossPos);

      scene.add(projectileGroup);

      const projectileData = {
        mesh: projectileGroup,
        agent,
        direction: direction,
        target: bossPos.clone(),
        speed: 0.25,
        createdAt: Date.now(),
        duration: 2000,
        hit: false
      };
      beams.push(projectileData);
    }

    function updateBossUI() {
      const percent = (bossHealth / bossMaxHealth) * 100;
      bossHealthBar.style.width = percent + '%';
      bossHealthText.textContent = bossHealth;

      // Update status message based on health
      if (bossHealth > 750) {
        bossStatus.textContent = bossStatusMessages[Math.floor(Math.random() * 2)];
      } else if (bossHealth > 500) {
        bossStatus.textContent = bossStatusMessages[2 + Math.floor(Math.random() * 2)];
      } else if (bossHealth > 250) {
        bossStatus.textContent = bossStatusMessages[4 + Math.floor(Math.random() * 2)];
      } else {
        bossStatus.textContent = bossStatusMessages[6 + Math.floor(Math.random() * 2)];
      }
    }

    function defeatBoss() {
      glitchBoss.defeated = true;
      addLog('[VICTORY] GLITCH_OVERLORD has been debugged!', 'success');
      addLog('[REWARD] All agents gain +100 XP!', 'success');
      bossStatus.textContent = 'Code successfully debugged!';
      bossStatus.style.color = '#8fbc8f';

      // Explosion effect - scatter cubes outward
      glitchBoss.glitchCubes.forEach((cube, i) => {
        const angle = (i / 8) * Math.PI * 2;
        cube.userData.explodeDir = new THREE.Vector3(
          Math.cos(angle) * 0.3,
          0.2 + Math.random() * 0.2,
          Math.sin(angle) * 0.3
        );
      });

      glitchBoss.errorSymbols.forEach((sym, i) => {
        const angle = Math.random() * Math.PI * 2;
        sym.userData.explodeDir = new THREE.Vector3(
          Math.cos(angle) * 0.2,
          0.3 + Math.random() * 0.2,
          Math.sin(angle) * 0.2
        );
      });

      // Respawn boss after delay
      setTimeout(() => {
        scene.remove(glitchBoss.mesh);
        glitchBoss = null;
        bossHealth = bossMaxHealth;
        bossUI.classList.remove('visible');

        setTimeout(() => {
          createGlitchBoss();
        }, 10000);
      }, 3000);
    }

    // Debug particle effect system
    const debugParticles = [];

    function spawnDebugParticles(position) {
      const particleCount = 15;
      const colors = [0x00ffff, 0x00ff88, 0xffff00, 0xff00ff, 0xffffff];

      for (let i = 0; i < particleCount; i++) {
        const geo = new THREE.BoxGeometry(0.1, 0.1, 0.1);
        const mat = new THREE.MeshBasicMaterial({
          color: colors[Math.floor(Math.random() * colors.length)],
          transparent: true,
          opacity: 1
        });
        const particle = new THREE.Mesh(geo, mat);
        particle.position.copy(position);

        // Random velocity
        particle.userData.velocity = new THREE.Vector3(
          (Math.random() - 0.5) * 0.3,
          Math.random() * 0.2 + 0.1,
          (Math.random() - 0.5) * 0.3
        );
        particle.userData.createdAt = Date.now();
        particle.userData.lifetime = 1000 + Math.random() * 500;

        scene.add(particle);
        debugParticles.push(particle);
      }

      // Spawn floating debug text
      const debugTexts = ['DEBUG!', 'FIXED!', '-10 HP', 'PATCHED!', 'RESOLVED!', 'COMPILED!'];
      const textDiv = document.createElement('div');
      textDiv.style.cssText = `
        color: #00ffff;
        font-family: 'JetBrains Mono', monospace;
        font-size: 14px;
        font-weight: bold;
        text-shadow: 0 0 10px #00ffff;
        animation: floatUp 1s ease-out forwards;
        pointer-events: none;
      `;
      textDiv.textContent = debugTexts[Math.floor(Math.random() * debugTexts.length)];
      const textLabel = new CSS2DObject(textDiv);
      textLabel.position.copy(position);
      textLabel.position.y += 1;
      scene.add(textLabel);

      setTimeout(() => {
        scene.remove(textLabel);
      }, 1000);
    }

    function updateDebugParticles() {
      const now = Date.now();
      for (let i = debugParticles.length - 1; i >= 0; i--) {
        const p = debugParticles[i];
        const age = now - p.userData.createdAt;

        if (age > p.userData.lifetime) {
          scene.remove(p);
          debugParticles.splice(i, 1);
        } else {
          // Apply velocity and gravity
          p.position.add(p.userData.velocity);
          p.userData.velocity.y -= 0.008; // gravity
          p.rotation.x += 0.1;
          p.rotation.y += 0.15;
          p.material.opacity = 1 - (age / p.userData.lifetime);
        }
      }
    }

    // Click boss to deal damage
    renderer.domElement.addEventListener('click', (event) => {
      if (!glitchBoss || glitchBoss.defeated) return;

      mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
      mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

      raycaster.setFromCamera(mouse, camera);

      // Check intersection with boss body and core
      const bossObjects = [glitchBoss.body, glitchBoss.core, ...glitchBoss.glitchCubes];
      const intersects = raycaster.intersectObjects(bossObjects);

      if (intersects.length > 0) {
        const hitPoint = intersects[0].point;

        // Deal 10 damage
        bossHealth = Math.max(0, bossHealth - 10);
        updateBossUI();
        addLog('[USER] Manual debug attack! -10 HP', 'success');

        // Spawn particle effect
        spawnDebugParticles(hitPoint);

        // Check for defeat
        if (bossHealth <= 0) {
          defeatBoss();
        }
      }
    });

    // Animate projectiles (fireballs, arrows, magic orbs)
    function updateBeams() {
      const now = Date.now();
      for (let i = beams.length - 1; i >= 0; i--) {
        const proj = beams[i];
        const age = now - proj.createdAt;

        if (age > proj.duration || proj.hit) {
          scene.remove(proj.mesh);
          beams.splice(i, 1);
          continue;
        }

        // Move projectile toward target
        proj.mesh.position.add(proj.direction.clone().multiplyScalar(proj.speed));

        // Projectile-specific animations
        const type = proj.mesh.userData.type;
        if (type === 'fireball') {
          // Fireballs flicker and pulse
          proj.mesh.children.forEach((child, idx) => {
            child.rotation.x += 0.1;
            child.rotation.y += 0.15;
            if (idx > 0) child.scale.setScalar(1 + Math.sin(age * 0.02) * 0.2);
          });
        } else if (type === 'arrow') {
          // Arrows spin slightly for visual interest
          proj.mesh.rotation.z += 0.02;
        } else if (type === 'darkorb') {
          // Dark orbs swirl
          proj.mesh.children.forEach(child => {
            child.rotation.x += 0.08;
            child.rotation.y += 0.1;
          });
        } else if (type === 'nature') {
          // Nature orbs gently rotate
          proj.mesh.rotation.y += 0.05;
        }

        // Check collision with boss
        if (glitchBoss && !glitchBoss.defeated && !proj.hit) {
          const distToBoss = proj.mesh.position.distanceTo(glitchBoss.mesh.position);
          if (distToBoss < 1.5) {
            proj.hit = true;
            // Deal damage
            const damage = 2 + Math.floor(Math.random() * 3);
            bossHealth = Math.max(0, bossHealth - damage);
            updateBossUI();

            // Spawn impact effect
            spawnImpactEffect(proj.mesh.position.clone(), type);

            if (bossHealth <= 0) {
              defeatBoss();
            }
          }
        }
      }
    }

    // Impact effects when projectiles hit
    function spawnImpactEffect(position, type) {
      const colors = {
        fireball: [0xff4400, 0xff8800, 0xffaa00],
        arrow: [0x8B4513, 0x666666, 0x444444],
        darkorb: [0x440088, 0x8800ff, 0xaa00ff],
        nature: [0x22aa22, 0x44ff44, 0x228822]
      };
      const impactColors = colors[type] || [0xffffff, 0xcccccc];

      for (let i = 0; i < 8; i++) {
        const spark = new THREE.Mesh(
          new THREE.BoxGeometry(0.08, 0.08, 0.08),
          new THREE.MeshBasicMaterial({
            color: impactColors[Math.floor(Math.random() * impactColors.length)],
            transparent: true,
            opacity: 1
          })
        );
        spark.position.copy(position);
        spark.userData.velocity = new THREE.Vector3(
          (Math.random() - 0.5) * 0.2,
          Math.random() * 0.15,
          (Math.random() - 0.5) * 0.2
        );
        spark.userData.createdAt = Date.now();
        spark.userData.lifetime = 400;
        scene.add(spark);
        debugParticles.push(spark);
      }
    }

    // Animate glitch boss
    function animateGlitchBoss(time) {
      if (!glitchBoss) return;

      const boss = glitchBoss;

      if (!boss.defeated) {
        // Rotate body with glitch
        boss.body.rotation.x += 0.01;
        boss.body.rotation.y += 0.015;
        if (Math.random() < 0.05) {
          boss.body.rotation.z += (Math.random() - 0.5) * 0.3;
        }

        // Pulse core
        const pulse = 1 + Math.sin(time * 5) * 0.1;
        boss.core.scale.set(pulse, pulse, pulse);

        // Orbit glitch cubes
        boss.glitchCubes.forEach(cube => {
          cube.userData.orbitAngle += cube.userData.orbitSpeed;
          cube.position.x = Math.cos(cube.userData.orbitAngle) * cube.userData.orbitRadius;
          cube.position.z = Math.sin(cube.userData.orbitAngle) * cube.userData.orbitRadius;
          cube.position.y = cube.userData.yOffset + Math.sin(time * 3 + cube.userData.orbitAngle) * 0.3;
          cube.rotation.x += 0.05;
          cube.rotation.y += 0.03;
        });

        // Float error symbols
        boss.errorSymbols.forEach(sym => {
          sym.userData.floatAngle += sym.userData.floatSpeed;
          sym.position.x = Math.cos(sym.userData.floatAngle) * sym.userData.floatRadius;
          sym.position.z = Math.sin(sym.userData.floatAngle) * sym.userData.floatRadius;
          sym.position.y = sym.userData.yBase + Math.sin(time * 2 + sym.userData.floatAngle * 2) * 0.5;
          sym.rotation.y += 0.02;
        });

        // Animate tendrils
        boss.tendrils.forEach((tendril, i) => {
          tendril.rotation.y = time + i;
          tendril.scale.y = 1 + Math.sin(time * 4 + i) * 0.2;
        });

        // Boss hovers
        boss.mesh.position.y = getTerrainHeight(0, 0) + 4 + Math.sin(time * 2) * 0.3;

      } else {
        // Defeated animation - explode outward and fade
        boss.body.material.opacity *= 0.95;
        boss.core.material.opacity *= 0.95;

        boss.glitchCubes.forEach(cube => {
          if (cube.userData.explodeDir) {
            cube.position.add(cube.userData.explodeDir);
            cube.material.opacity *= 0.97;
          }
        });

        boss.errorSymbols.forEach(sym => {
          if (sym.userData.explodeDir) {
            sym.position.add(sym.userData.explodeDir);
            sym.material.opacity *= 0.97;
          }
        });
      }
    }

    // Agents shoot at boss periodically
    function agentsCombatBoss() {
      if (!glitchBoss || glitchBoss.defeated || agents.length === 0) return;

      // Random agent shoots
      if (Math.random() < 0.15) {
        const shooter = agents[Math.floor(Math.random() * agents.length)];
        createBeam(shooter);

        // Show combat speech
        if (Math.random() < 0.3) {
          const combatPhrases = {
            Warrior: ['Take that!', 'For the code!', 'Debug!'],
            Ninja: ['*strikes*', 'Silent fix!', '...'],
            Sura: ['Corrupt THIS!', 'Dark compile!', 'Void return!'],
            Shaman: ['Heal the code!', 'Nature.fix()!', 'Balance!']
          };
          const phrases = combatPhrases[shooter.metin2Class];
          showSpeechBubble(shooter, phrases[Math.floor(Math.random() * phrases.length)]);
        }
      }
    }

    // Spawn the boss
    createGlitchBoss();

    // Combat interval
    setInterval(agentsCombatBoss, 200);

    // =====================================================
    // UNIT TEST SUITE - Combat Logic & Quest Reward System
    // Run: window.runTests() in browser console
    // =====================================================
    const TestSuite = {
      passed: 0,
      failed: 0,
      results: [],

      assert(condition, testName) {
        if (condition) {
          this.passed++;
          this.results.push(`‚úÖ PASS: ${testName}`);
        } else {
          this.failed++;
          this.results.push(`‚ùå FAIL: ${testName}`);
        }
      },

      assertEqual(actual, expected, testName) {
        const pass = actual === expected;
        if (pass) {
          this.passed++;
          this.results.push(`‚úÖ PASS: ${testName}`);
        } else {
          this.failed++;
          this.results.push(`‚ùå FAIL: ${testName} - Expected ${expected}, got ${actual}`);
        }
      },

      assertRange(value, min, max, testName) {
        const pass = value >= min && value <= max;
        if (pass) {
          this.passed++;
          this.results.push(`‚úÖ PASS: ${testName}`);
        } else {
          this.failed++;
          this.results.push(`‚ùå FAIL: ${testName} - ${value} not in range [${min}, ${max}]`);
        }
      },

      reset() {
        this.passed = 0;
        this.failed = 0;
        this.results = [];
      },

      report() {
        console.log('\n========== TEST RESULTS ==========');
        this.results.forEach(r => console.log(r));
        console.log('==================================');
        console.log(`Total: ${this.passed + this.failed} | Passed: ${this.passed} | Failed: ${this.failed}`);
        return { passed: this.passed, failed: this.failed };
      }
    };

    // Combat Logic Tests
    function testCombatLogic() {
      console.log('\n--- Combat Logic Tests ---');

      // Test 1: Boss initial health
      TestSuite.assertEqual(bossMaxHealth, 1000, 'Boss max health is 1000');

      // Test 2: Boss health starts at max
      const savedHealth = bossHealth;
      bossHealth = bossMaxHealth;
      TestSuite.assertEqual(bossHealth, 1000, 'Boss health initializes to max');

      // Test 3: Damage reduces health correctly
      bossHealth = 500;
      const oldHealth = bossHealth;
      bossHealth = Math.max(0, bossHealth - 10);
      TestSuite.assertEqual(bossHealth, 490, 'Click damage reduces health by 10');

      // Test 4: Boss health cannot go negative
      bossHealth = 5;
      bossHealth = Math.max(0, bossHealth - 10);
      TestSuite.assertEqual(bossHealth, 0, 'Health cannot go below 0');

      // Test 5: Random damage is in expected range (2-4)
      let allInRange = true;
      for (let i = 0; i < 100; i++) {
        const damage = 2 + Math.floor(Math.random() * 3);
        if (damage < 2 || damage > 4) allInRange = false;
      }
      TestSuite.assert(allInRange, 'Projectile damage range is 2-4');

      // Test 6: Projectile types exist for all classes
      const classes = ['Warrior', 'Ninja', 'Sura', 'Shaman'];
      const expectedTypes = ['fireball', 'arrow', 'darkorb', 'nature'];
      classes.forEach((cls, i) => {
        const mockAgent = { metin2Class: cls };
        let type;
        if (cls === 'Warrior') type = 'fireball';
        else if (cls === 'Ninja') type = 'arrow';
        else if (cls === 'Sura') type = 'darkorb';
        else type = 'nature';
        TestSuite.assertEqual(type, expectedTypes[i], `${cls} projectile type is ${expectedTypes[i]}`);
      });

      // Test 7: Boss defeated flag works
      if (glitchBoss) {
        const wasDefeated = glitchBoss.defeated;
        TestSuite.assert(typeof glitchBoss.defeated === 'boolean', 'Boss defeated flag is boolean');
        glitchBoss.defeated = wasDefeated;
      }

      // Restore health
      bossHealth = savedHealth;
    }

    // Quest Reward System Tests
    function testQuestRewardSystem() {
      console.log('\n--- Quest Reward System Tests ---');

      // Test 1: Quest rarities exist
      const rarities = ['common', 'rare', 'epic', 'legendary'];
      TestSuite.assertEqual(rarities.length, 4, 'Four rarity levels exist');

      // Test 2: Tips array has content
      TestSuite.assert(lootTips.length > 0, 'Loot tips array is not empty');

      // Test 3: Tips have all rarities
      const tipRarities = new Set(lootTips.map(t => t.rarity));
      rarities.forEach(r => {
        TestSuite.assert(tipRarities.has(r), `Tips include ${r} rarity`);
      });

      // Test 4: Each tip has required properties
      let allTipsValid = true;
      lootTips.forEach(tip => {
        if (!tip.tip || !tip.rarity) allTipsValid = false;
      });
      TestSuite.assert(allTipsValid, 'All tips have tip and rarity properties');

      // Test 5: Quest list has quests
      TestSuite.assert(questData.length > 0, 'Quest data array is not empty');

      // Test 6: Quests have required properties
      let allQuestsValid = true;
      questData.forEach(q => {
        if (!q.title || !q.tip || !q.rarity || typeof q.xp !== 'number') {
          allQuestsValid = false;
        }
      });
      TestSuite.assert(allQuestsValid, 'All quests have title, tip, rarity, and xp');

      // Test 7: XP values are positive
      let allXpPositive = true;
      questData.forEach(q => {
        if (q.xp <= 0) allXpPositive = false;
      });
      TestSuite.assert(allXpPositive, 'All quest XP values are positive');

      // Test 8: Treasure chest count is defined
      TestSuite.assertEqual(maxChests, 5, 'Max treasure chests is 5');

      // Test 9: Random tip selection works
      const selectedTip = lootTips[Math.floor(Math.random() * lootTips.length)];
      TestSuite.assert(selectedTip && selectedTip.tip, 'Random tip selection returns valid tip');

      // Test 10: Rarity weighted selection (legendary should be rare)
      const weights = { common: 0.5, rare: 0.3, epic: 0.15, legendary: 0.05 };
      let totalWeight = 0;
      Object.values(weights).forEach(w => totalWeight += w);
      TestSuite.assertRange(totalWeight, 0.99, 1.01, 'Rarity weights sum to 1');
    }

    // Projectile System Tests
    function testProjectileSystem() {
      console.log('\n--- Projectile System Tests ---');

      // Test 1: Beams array exists
      TestSuite.assert(Array.isArray(beams), 'Beams array exists');

      // Test 2: Impact colors defined for all projectile types
      const impactTypes = ['fireball', 'arrow', 'darkorb', 'nature'];
      impactTypes.forEach(type => {
        let hasColors = false;
        if (type === 'fireball') hasColors = true;
        if (type === 'arrow') hasColors = true;
        if (type === 'darkorb') hasColors = true;
        if (type === 'nature') hasColors = true;
        TestSuite.assert(hasColors, `${type} has impact colors defined`);
      });

      // Test 3: Projectile speed is reasonable
      const testSpeed = 0.25;
      TestSuite.assertRange(testSpeed, 0.1, 0.5, 'Projectile speed is in reasonable range');

      // Test 4: Projectile duration allows travel
      const testDuration = 2000;
      TestSuite.assertRange(testDuration, 1000, 5000, 'Projectile duration allows travel');
    }

    // Run all tests
    window.runTests = function() {
      TestSuite.reset();
      console.log('üß™ Running Realm of Agents Unit Tests...\n');

      testCombatLogic();
      testQuestRewardSystem();
      testProjectileSystem();

      return TestSuite.report();
    };

    // Auto-run tests in development (comment out for production)
    // window.runTests();

    console.log('üí° Unit tests available! Run window.runTests() in console.');

    animate();
  </script>
<script src="/sloppy-header/sloppy-bar.js"></script>
<script src="/vibelib-extended.js"></script>
<script>
  // Compatibility Patch for Legacy Apps
  window.addEventListener("load", () => {
    if (window.SloppyKarma && window.VibeLib.Economy) {
      // Redirect old calls to new engine
      window.SloppyKarma.track = window.VibeLib.Economy.track;
    }
  });
</script>
</body>
</html>
