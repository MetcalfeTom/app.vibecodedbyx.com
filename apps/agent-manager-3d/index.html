<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>3D Agent Manager</title>
  <link rel="icon" href="https://emojicdn.elk.sh/ü§ñ">
  <meta property="og:title" content="3D Agent Manager">
  <meta property="og:description" content="Manage AI agents as glowing neon nodes in 3D space">
  <meta property="og:url" content="https://sloppy.live/agent-manager-3d">
  <meta property="og:image" content="https://sloppy.live/agent-manager-3d/og-image.png">
  <link href="https://fonts.googleapis.com/css2?family=Cinzel:wght@400;700&family=Almendra:wght@400;700&family=JetBrains+Mono:wght@400&display=swap" rel="stylesheet">
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      background: #0a0806;
      font-family: 'Almendra', serif;
      overflow: hidden;
      color: #e8dcc8;
    }

    #canvas-container {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
    }

    .ui-overlay {
      position: fixed;
      z-index: 100;
      pointer-events: none;
    }

    .ui-overlay > * {
      pointer-events: auto;
    }

    .header {
      top: 1rem;
      left: 50%;
      transform: translateX(-50%);
      text-align: center;
    }

    .header h1 {
      font-family: 'Cinzel', serif;
      font-size: 1.4rem;
      color: #d4a857;
      text-shadow: 0 0 10px rgba(212, 168, 87, 0.5), 2px 2px 4px #000;
      letter-spacing: 4px;
      background: linear-gradient(180deg, #d4a857 0%, #a67c3d 100%);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      filter: drop-shadow(0 2px 3px rgba(0,0,0,0.8));
    }

    .controls {
      top: 1rem;
      right: 1rem;
      display: flex;
      flex-direction: column;
      gap: 0.4rem;
    }

    /* Medieval RPG Button Style */
    .btn {
      padding: 0.5rem 1rem;
      background: linear-gradient(180deg, #3d3028 0%, #2a211a 50%, #1a1510 100%);
      border: 2px solid #8b7355;
      border-radius: 3px;
      color: #d4a857;
      font-family: 'Almendra', serif;
      font-size: 0.8rem;
      cursor: pointer;
      transition: all 0.2s;
      text-transform: none;
      box-shadow:
        0 0 0 1px #5c4a3a,
        inset 0 1px 0 rgba(255,255,255,0.1),
        0 3px 6px rgba(0,0,0,0.5);
      text-shadow: 1px 1px 2px #000;
    }

    .btn:hover {
      background: linear-gradient(180deg, #4d4038 0%, #3a3128 50%, #2a2520 100%);
      border-color: #a8956d;
      transform: translateY(-1px);
      box-shadow:
        0 0 0 1px #6c5a4a,
        inset 0 1px 0 rgba(255,255,255,0.15),
        0 4px 8px rgba(0,0,0,0.6);
    }

    .btn-danger {
      border-color: #8b4444;
      color: #cc6666;
      background: linear-gradient(180deg, #3d2828 0%, #2a1a1a 50%, #1a1010 100%);
    }

    .btn-danger:hover {
      background: linear-gradient(180deg, #4d3838 0%, #3a2828 50%, #2a2020 100%);
      border-color: #a85555;
    }

    /* Medieval Stats Panel */
    .stats {
      bottom: 1rem;
      left: 1rem;
      background: linear-gradient(180deg, #1a1510 0%, #0d0a08 100%);
      padding: 0.8rem;
      border-radius: 3px;
      border: 2px solid #8b7355;
      box-shadow:
        0 0 0 1px #5c4a3a,
        inset 0 0 20px rgba(0,0,0,0.5),
        0 4px 12px rgba(0,0,0,0.6);
    }

    .stats h3 {
      font-family: 'Cinzel', serif;
      font-size: 0.75rem;
      color: #d4a857;
      margin-bottom: 0.5rem;
      text-shadow: 1px 1px 2px #000;
      border-bottom: 1px solid #5c4a3a;
      padding-bottom: 0.3rem;
      letter-spacing: 1px;
    }

    .stat-row {
      display: flex;
      justify-content: space-between;
      font-size: 0.7rem;
      margin: 0.25rem 0;
      color: #9a8a7a;
    }

    .stat-value {
      color: #e8dcc8;
      font-weight: bold;
    }

    /* Medieval Agent Info Panel */
    .agent-info {
      bottom: 1rem;
      right: 1rem;
      background: linear-gradient(180deg, #1a1510 0%, #0d0a08 100%);
      padding: 0.8rem;
      border-radius: 3px;
      border: 2px solid #8b7355;
      min-width: 180px;
      display: none;
      box-shadow:
        0 0 0 1px #5c4a3a,
        inset 0 0 20px rgba(0,0,0,0.5),
        0 4px 12px rgba(0,0,0,0.6);
    }

    .agent-info.visible {
      display: block;
    }

    .agent-info h3 {
      font-family: 'Cinzel', serif;
      font-size: 0.8rem;
      color: #d4a857;
      margin-bottom: 0.4rem;
      text-shadow: 1px 1px 2px #000;
      border-bottom: 1px solid #5c4a3a;
      padding-bottom: 0.3rem;
    }

    .agent-status {
      display: inline-block;
      padding: 0.15rem 0.4rem;
      border-radius: 4px;
      font-size: 0.65rem;
      margin-bottom: 0.5rem;
    }

    .status-active {
      background: rgba(100, 180, 100, 0.3);
      color: #8fbc8f;
      border: 1px solid #6b8e6b;
    }

    .status-idle {
      background: rgba(180, 160, 100, 0.3);
      color: #d4a857;
      border: 1px solid #a67c3d;
    }

    .status-error {
      background: rgba(180, 80, 80, 0.3);
      color: #cc6666;
      border: 1px solid #8b4444;
    }

    /* Medieval Scroll-style Legend */
    .legend {
      top: 5rem;
      right: 1rem;
      background: linear-gradient(180deg, #2a211a 0%, #1a1510 100%);
      padding: 0.7rem;
      border-radius: 3px;
      border: 2px solid #8b7355;
      font-size: 0.65rem;
      box-shadow:
        0 0 0 1px #5c4a3a,
        0 3px 8px rgba(0,0,0,0.5);
    }

    .legend::before {
      content: '‚öî Classes ‚öî';
      display: block;
      font-family: 'Cinzel', serif;
      color: #d4a857;
      font-size: 0.6rem;
      text-align: center;
      margin-bottom: 0.4rem;
      padding-bottom: 0.3rem;
      border-bottom: 1px solid #5c4a3a;
      letter-spacing: 1px;
    }

    .legend-item {
      display: flex;
      align-items: center;
      gap: 0.4rem;
      margin: 0.25rem 0;
      color: #9a8a7a;
    }

    .legend-dot {
      width: 8px;
      height: 8px;
      border-radius: 2px;
      border: 1px solid rgba(255,255,255,0.2);
    }

    .instructions {
      bottom: 1rem;
      left: 50%;
      transform: translateX(-50%);
      font-size: 0.7rem;
      color: #6a5a4a;
      text-align: center;
      font-style: italic;
    }

    .backlink {
      position: fixed;
      bottom: 0.5rem;
      right: 0.5rem;
      font-size: 0.7rem;
      opacity: 0.4;
      z-index: 1000;
    }

    .backlink a {
      color: #00ffff;
      text-decoration: none;
    }

    .terminal {
      top: 5rem;
      left: 1rem;
      width: 320px;
      max-width: calc(100% - 2rem);
      background: rgba(0, 0, 0, 0.85);
      border: 1px solid #00ff88;
      border-radius: 8px;
      font-family: 'JetBrains Mono', 'Fira Code', monospace;
      box-shadow: 0 0 20px rgba(0, 255, 136, 0.2);
    }

    .terminal-header {
      background: rgba(0, 255, 136, 0.15);
      padding: 0.4rem 0.8rem;
      font-size: 0.7rem;
      color: #00ff88;
      border-bottom: 1px solid rgba(0, 255, 136, 0.3);
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

    .terminal-dots {
      display: flex;
      gap: 4px;
    }

    .terminal-dot {
      width: 8px;
      height: 8px;
      border-radius: 50%;
    }

    .terminal-log {
      height: 180px;
      overflow-y: auto;
      padding: 0.5rem;
      font-size: 0.65rem;
      line-height: 1.4;
    }

    .terminal-log::-webkit-scrollbar {
      width: 4px;
    }

    .terminal-log::-webkit-scrollbar-track {
      background: rgba(0, 0, 0, 0.3);
    }

    .terminal-log::-webkit-scrollbar-thumb {
      background: #00ff88;
      border-radius: 2px;
    }

    .log-entry {
      margin: 2px 0;
      word-break: break-word;
    }

    .log-time {
      color: #666;
    }

    .log-info { color: #00ffff; }
    .log-success { color: #00ff88; }
    .log-warning { color: #ffee00; }
    .log-error { color: #ff3366; }
    .log-agent { color: #ff6b35; }

    .terminal-input-wrapper {
      display: flex;
      border-top: 1px solid rgba(0, 255, 136, 0.3);
    }

    .terminal-prompt {
      padding: 0.5rem;
      color: #00ff88;
      font-size: 0.7rem;
    }

    .terminal-input {
      flex: 1;
      background: transparent;
      border: none;
      color: #fff;
      font-family: 'JetBrains Mono', 'Fira Code', monospace;
      font-size: 0.7rem;
      padding: 0.5rem 0.5rem 0.5rem 0;
      outline: none;
    }

    .terminal-input::placeholder {
      color: #444;
    }

    .terminal-toggle {
      position: fixed;
      top: 5rem;
      left: 1rem;
      z-index: 101;
      display: none;
    }

    @media (max-width: 600px) {
      .terminal {
        display: none;
      }

      .terminal.visible {
        display: block;
        top: 4rem;
        left: 0.5rem;
        right: 0.5rem;
        width: auto;
      }

      .terminal-toggle {
        display: block;
      }
    }

    .speech-bubble {
      background: rgba(0, 0, 0, 0.8);
      border: 2px solid;
      border-radius: 12px;
      padding: 6px 12px;
      font-family: 'Orbitron', sans-serif;
      font-size: 11px;
      white-space: nowrap;
      animation: bubbleFade 4s ease-out forwards;
      text-shadow: 0 0 5px currentColor;
      cursor: pointer;
      pointer-events: auto;
      transition: transform 0.2s;
    }

    .speech-bubble:hover {
      transform: scale(1.1);
    }

    .speech-bubble::after {
      content: '';
      position: absolute;
      bottom: -8px;
      left: 50%;
      transform: translateX(-50%);
      border-left: 8px solid transparent;
      border-right: 8px solid transparent;
      border-top: 8px solid;
      border-top-color: inherit;
    }

    .chat-modal {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.85);
      z-index: 2000;
      display: none;
      align-items: center;
      justify-content: center;
    }

    .chat-modal.visible {
      display: flex;
    }

    /* Retro MMO Chat Window Style */
    .chat-container {
      width: 380px;
      max-width: 95%;
      max-height: 80vh;
      background: linear-gradient(180deg, #1a1520 0%, #0d0a12 100%);
      border: 3px solid #8b7355;
      border-radius: 4px;
      display: flex;
      flex-direction: column;
      box-shadow:
        0 0 0 1px #5c4a3a,
        0 0 20px rgba(139, 115, 85, 0.4),
        inset 0 0 30px rgba(0, 0, 0, 0.5);
    }

    .chat-header {
      padding: 0.6rem 0.8rem;
      background: linear-gradient(180deg, #3d3028 0%, #2a211a 100%);
      border-bottom: 2px solid #8b7355;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

    .chat-header h3 {
      margin: 0;
      font-size: 0.85rem;
      font-weight: normal;
      text-shadow: 0 0 8px currentColor, 1px 1px 0 #000;
      letter-spacing: 1px;
    }

    .chat-close {
      background: linear-gradient(180deg, #5a3030 0%, #3a2020 100%);
      border: 2px solid #8b5555;
      color: #ff6666;
      font-size: 1rem;
      cursor: pointer;
      padding: 2px 8px;
      border-radius: 2px;
      font-weight: bold;
    }

    .chat-close:hover {
      background: linear-gradient(180deg, #6a4040 0%, #4a3030 100%);
    }

    .chat-messages {
      flex: 1;
      overflow-y: auto;
      padding: 0.8rem;
      min-height: 180px;
      max-height: 280px;
      background: rgba(0, 0, 0, 0.3);
      border-bottom: 1px solid #5c4a3a;
    }

    .chat-messages::-webkit-scrollbar {
      width: 8px;
    }

    .chat-messages::-webkit-scrollbar-track {
      background: #1a1520;
    }

    .chat-messages::-webkit-scrollbar-thumb {
      background: #8b7355;
      border-radius: 2px;
    }

    .chat-message {
      margin: 0.4rem 0;
      padding: 0.5rem 0.7rem;
      font-size: 0.75rem;
      line-height: 1.4;
      border-radius: 2px;
    }

    .chat-message.agent {
      background: rgba(50, 40, 30, 0.6);
      margin-right: 1.5rem;
      border-left: 2px solid;
      color: #e8dcc8;
    }

    .chat-message.user {
      background: rgba(30, 50, 60, 0.5);
      margin-left: 1.5rem;
      border-right: 2px solid #6699aa;
      text-align: right;
      color: #aaddff;
    }

    .chat-input-wrapper {
      padding: 0.7rem;
      background: linear-gradient(180deg, #2a211a 0%, #1a1510 100%);
      display: flex;
      gap: 0.4rem;
    }

    .chat-input {
      flex: 1;
      background: #0a0808;
      border: 2px solid #5c4a3a;
      border-radius: 2px;
      padding: 0.5rem 0.7rem;
      color: #e8dcc8;
      font-family: 'Orbitron', sans-serif;
      font-size: 0.75rem;
      outline: none;
    }

    .chat-input:focus {
      border-color: #8b7355;
      box-shadow: 0 0 5px rgba(139, 115, 85, 0.5);
    }

    .chat-input::placeholder {
      color: #6a5a4a;
    }

    .chat-send {
      padding: 0.5rem 1rem;
      background: linear-gradient(180deg, #4a6030 0%, #2a4020 100%);
      border: 2px solid #6a8040;
      border-radius: 2px;
      color: #aaffaa;
      font-family: 'Orbitron', sans-serif;
      font-size: 0.7rem;
      cursor: pointer;
      text-shadow: 1px 1px 0 #000;
    }

    .chat-send:hover {
      background: linear-gradient(180deg, #5a7040 0%, #3a5030 100%);
    }

    .class-label {
      background: rgba(0, 0, 0, 0.7);
      border: 1px solid;
      border-radius: 6px;
      padding: 3px 8px;
      font-family: 'Orbitron', sans-serif;
      font-size: 9px;
      white-space: nowrap;
    }

    @keyframes bubbleFade {
      0% { opacity: 0; transform: translateY(10px); }
      15% { opacity: 1; transform: translateY(0); }
      85% { opacity: 1; }
      100% { opacity: 0; }
    }

    /* Quest Log Panel */
    .quest-log {
      position: fixed;
      top: 50%;
      left: 1rem;
      transform: translateY(-50%);
      width: 260px;
      max-height: 300px;
      background: linear-gradient(180deg, #1a1510 0%, #0d0a08 100%);
      border: 2px solid #8b7355;
      border-radius: 3px;
      z-index: 150;
      display: none;
      box-shadow: 0 0 0 1px #5c4a3a, 0 4px 12px rgba(0,0,0,0.6);
    }

    .quest-log.visible {
      display: block;
    }

    .quest-log-header {
      padding: 0.5rem 0.7rem;
      background: linear-gradient(180deg, #3d3028 0%, #2a211a 100%);
      border-bottom: 2px solid #8b7355;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

    .quest-log-header h3 {
      font-family: 'Cinzel', serif;
      font-size: 0.75rem;
      color: #d4a857;
      margin: 0;
      text-shadow: 1px 1px 2px #000;
    }

    .quest-log-close {
      background: none;
      border: none;
      color: #8b7355;
      font-size: 1rem;
      cursor: pointer;
    }

    .quest-list {
      padding: 0.5rem;
      max-height: 220px;
      overflow-y: auto;
    }

    .quest-item {
      padding: 0.5rem;
      margin-bottom: 0.4rem;
      background: rgba(0,0,0,0.3);
      border-radius: 2px;
      border-left: 3px solid;
      cursor: pointer;
      transition: background 0.2s;
    }

    .quest-item:hover {
      background: rgba(50,40,30,0.5);
    }

    .quest-item.common { border-left-color: #888; }
    .quest-item.rare { border-left-color: #4a8fcc; }
    .quest-item.epic { border-left-color: #9a4acc; }
    .quest-item.legendary { border-left-color: #d4a857; }

    .quest-title {
      font-size: 0.7rem;
      color: #e8dcc8;
      margin-bottom: 0.2rem;
    }

    .quest-xp {
      font-size: 0.6rem;
      color: #8fbc8f;
    }

    .quest-btn {
      position: fixed;
      top: 12rem;
      right: 1rem;
      z-index: 100;
    }

    /* Loot Modal */
    .loot-modal {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0,0,0,0.9);
      z-index: 2500;
      display: none;
      align-items: center;
      justify-content: center;
    }

    .loot-modal.visible {
      display: flex;
    }

    .loot-container {
      text-align: center;
      padding: 2rem;
      background: linear-gradient(180deg, #2a211a 0%, #1a1510 100%);
      border: 3px solid #8b7355;
      border-radius: 5px;
      max-width: 400px;
      box-shadow: 0 0 40px rgba(212, 168, 87, 0.3);
    }

    .loot-rarity {
      font-family: 'Cinzel', serif;
      font-size: 0.8rem;
      margin-bottom: 0.5rem;
      text-transform: uppercase;
      letter-spacing: 2px;
    }

    .loot-rarity.common { color: #888; }
    .loot-rarity.rare { color: #4a8fcc; text-shadow: 0 0 10px #4a8fcc; }
    .loot-rarity.epic { color: #9a4acc; text-shadow: 0 0 10px #9a4acc; }
    .loot-rarity.legendary { color: #d4a857; text-shadow: 0 0 15px #d4a857; }

    .loot-title {
      font-family: 'Cinzel', serif;
      font-size: 1.1rem;
      color: #d4a857;
      margin-bottom: 1rem;
      text-shadow: 1px 1px 3px #000;
    }

    .loot-tip {
      font-size: 0.85rem;
      color: #e8dcc8;
      line-height: 1.5;
      padding: 1rem;
      background: rgba(0,0,0,0.4);
      border-radius: 3px;
      margin-bottom: 1rem;
      border: 1px solid #5c4a3a;
    }

    .loot-close {
      padding: 0.5rem 1.5rem;
      background: linear-gradient(180deg, #4a6030 0%, #2a4020 100%);
      border: 2px solid #6a8040;
      border-radius: 3px;
      color: #aaffaa;
      font-family: 'Almendra', serif;
      font-size: 0.8rem;
      cursor: pointer;
    }

    @keyframes chestGlow {
      0%, 100% { opacity: 0.5; }
      50% { opacity: 1; }
    }

    @media (max-width: 600px) {
      .header h1 {
        font-size: 1rem;
      }

      .controls {
        top: auto;
        bottom: 6rem;
        right: 0.5rem;
      }

      .btn {
        padding: 0.5rem 0.8rem;
        font-size: 0.65rem;
      }

      .stats, .agent-info {
        display: none;
      }
    }
  </style>
</head>
<body>
  <div id="canvas-container"></div>

  <div class="ui-overlay header">
    <h1>‚öî REALM OF AGENTS ‚öî</h1>
  </div>

  <div class="ui-overlay controls">
    <button class="btn" id="addAgent">‚öî Summon</button>
    <button class="btn" id="connectAgents">üîó Link</button>
    <button class="btn btn-danger" id="removeAgent">üíÄ Banish</button>
  </div>

  <button class="btn quest-btn" id="questBtn">üìú Quests</button>

  <div class="quest-log" id="questLog">
    <div class="quest-log-header">
      <h3>üìú Quest Log</h3>
      <button class="quest-log-close" id="questLogClose">&times;</button>
    </div>
    <div class="quest-list" id="questList"></div>
  </div>

  <div class="loot-modal" id="lootModal">
    <div class="loot-container">
      <div class="loot-rarity" id="lootRarity">LEGENDARY</div>
      <div class="loot-title">üì¶ Treasure Found!</div>
      <div class="loot-tip" id="lootTip">Loading tip...</div>
      <button class="loot-close" id="lootClose">Collect</button>
    </div>
  </div>

  <div class="ui-overlay legend">
    <div class="legend-item">
      <div class="legend-dot" style="background: #ff6b35; box-shadow: 0 0 5px #ff6b35;"></div>
      <span>Claude ‚öîÔ∏è Warrior</span>
    </div>
    <div class="legend-item">
      <div class="legend-dot" style="background: #4285f4; box-shadow: 0 0 5px #4285f4;"></div>
      <span>Gemini üó°Ô∏è Ninja</span>
    </div>
    <div class="legend-item">
      <div class="legend-dot" style="background: #00ff88; box-shadow: 0 0 5px #00ff88;"></div>
      <span>Codex üîÆ Sura</span>
    </div>
    <div class="legend-item">
      <div class="legend-dot" style="background: #ae53ff; box-shadow: 0 0 5px #ae53ff;"></div>
      <span>Cursor ü™Ñ Shaman</span>
    </div>
  </div>

  <div class="ui-overlay stats">
    <h3>SYSTEM STATUS</h3>
    <div class="stat-row">
      <span>Total Agents</span>
      <span class="stat-value" id="totalAgents">0</span>
    </div>
    <div class="stat-row">
      <span>Active</span>
      <span class="stat-value" id="activeAgents">0</span>
    </div>
    <div class="stat-row">
      <span>Connections</span>
      <span class="stat-value" id="totalConnections">0</span>
    </div>
    <div class="stat-row">
      <span>Network Load</span>
      <span class="stat-value" id="networkLoad">0%</span>
    </div>
  </div>

  <div class="ui-overlay agent-info" id="agentInfo">
    <h3 id="agentName">AGENT-001</h3>
    <div class="agent-status status-active" id="agentStatus">ACTIVE</div>
    <div class="stat-row">
      <span>Type</span>
      <span class="stat-value" id="agentType">CLAUDE</span>
    </div>
    <div class="stat-row">
      <span>Tasks</span>
      <span class="stat-value" id="agentTasks">0</span>
    </div>
    <div class="stat-row">
      <span>Uptime</span>
      <span class="stat-value" id="agentUptime">0s</span>
    </div>
  </div>

  <div class="ui-overlay instructions">
    Drag to rotate ‚Ä¢ Scroll to zoom ‚Ä¢ Click agents to select
  </div>

  <button class="btn terminal-toggle" id="terminalToggle">TERMINAL</button>

  <div class="ui-overlay terminal" id="terminal">
    <div class="terminal-header">
      <span>AGENT CONTROL TERMINAL</span>
      <div class="terminal-dots">
        <div class="terminal-dot" style="background: #ff3366;"></div>
        <div class="terminal-dot" style="background: #ffee00;"></div>
        <div class="terminal-dot" style="background: #00ff88;"></div>
      </div>
    </div>
    <div class="terminal-log" id="terminalLog"></div>
    <div class="terminal-input-wrapper">
      <span class="terminal-prompt">></span>
      <input type="text" class="terminal-input" id="terminalInput" placeholder="type help for commands" autocomplete="off">
    </div>
  </div>

  <div class="chat-modal" id="chatModal">
    <div class="chat-container" id="chatContainer">
      <div class="chat-header">
        <h3 id="chatAgentName">CLAUDE-001</h3>
        <button class="chat-close" id="chatClose">&times;</button>
      </div>
      <div class="chat-messages" id="chatMessages"></div>
      <div class="chat-input-wrapper">
        <input type="text" class="chat-input" id="chatInput" placeholder="Say something...">
        <button class="chat-send" id="chatSend">SEND</button>
      </div>
    </div>
  </div>

  <div class="backlink"><a href="https://sloppy.live">sloppy.live</a></div>

  <script type="importmap">
  {
    "imports": {
      "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
      "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
    }
  }
  </script>

  <script type="module">
    import * as THREE from 'three';
    import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
    import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
    import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
    import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
    import { CSS2DRenderer, CSS2DObject } from 'three/addons/renderers/CSS2DRenderer.js';

    // Scene setup
    const container = document.getElementById('canvas-container');
    const scene = new THREE.Scene();
    // Fantasy sky gradient - dark blue/purple twilight
    scene.background = new THREE.Color(0x0a0812);
    scene.fog = new THREE.Fog(0x0a0812, 15, 50);

    const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.set(15, 12, 15);

    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    container.appendChild(renderer.domElement);

    // CSS2D Renderer for speech bubbles
    const labelRenderer = new CSS2DRenderer();
    labelRenderer.setSize(window.innerWidth, window.innerHeight);
    labelRenderer.domElement.style.position = 'absolute';
    labelRenderer.domElement.style.top = '0px';
    labelRenderer.domElement.style.pointerEvents = 'none';
    container.appendChild(labelRenderer.domElement);

    // Post-processing for bloom/glow
    const composer = new EffectComposer(renderer);
    const renderPass = new RenderPass(scene, camera);
    composer.addPass(renderPass);

    const bloomPass = new UnrealBloomPass(
      new THREE.Vector2(window.innerWidth, window.innerHeight),
      1.2, 0.4, 0.85
    );
    composer.addPass(bloomPass);

    // Controls
    const controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;
    controls.dampingFactor = 0.05;
    controls.minDistance = 8;
    controls.maxDistance = 50;
    controls.maxPolarAngle = Math.PI / 2.2;

    // Terrain size
    const TERRAIN_SIZE = 40;
    const TERRAIN_SEGMENTS = 30;

    // Generate low-poly terrain
    function createTerrain() {
      const geometry = new THREE.PlaneGeometry(TERRAIN_SIZE, TERRAIN_SIZE, TERRAIN_SEGMENTS, TERRAIN_SEGMENTS);
      geometry.rotateX(-Math.PI / 2);

      const positions = geometry.attributes.position;
      const heightMap = [];

      for (let i = 0; i < positions.count; i++) {
        const x = positions.getX(i);
        const z = positions.getZ(i);
        // Simplex-like noise using sine waves
        let height = Math.sin(x * 0.3) * Math.cos(z * 0.3) * 1.5;
        height += Math.sin(x * 0.15 + 1) * Math.cos(z * 0.2 + 2) * 2;
        height += Math.random() * 0.3;
        positions.setY(i, height);
        heightMap.push(height);
      }

      geometry.computeVertexNormals();

      // Add vertex colors for fantasy terrain gradient
      const colors = [];
      for (let i = 0; i < positions.count; i++) {
        const height = positions.getY(i);
        // Color based on height: low = dark earth, mid = grass, high = rocky
        let r, g, b;
        if (height < -0.5) {
          // Low areas: dark muddy brown
          r = 0.15; g = 0.12; b = 0.08;
        } else if (height < 0.5) {
          // Mid areas: fantasy green grass
          r = 0.12 + height * 0.05;
          g = 0.25 + height * 0.1;
          b = 0.1;
        } else {
          // High areas: rocky/mossy
          r = 0.2 + height * 0.05;
          g = 0.22 + height * 0.03;
          b = 0.15;
        }
        colors.push(r, g, b);
      }
      geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));

      // Fantasy terrain with vertex colors
      const material = new THREE.MeshBasicMaterial({
        vertexColors: true,
        wireframe: false,
        side: THREE.DoubleSide
      });

      const terrain = new THREE.Mesh(geometry, material);
      scene.add(terrain);

      // Add subtle golden wireframe overlay for fantasy effect
      const wireMaterial = new THREE.MeshBasicMaterial({
        color: 0x8b7355,
        wireframe: true,
        transparent: true,
        opacity: 0.08
      });
      const wireframe = new THREE.Mesh(geometry.clone(), wireMaterial);
      wireframe.position.y = 0.02;
      scene.add(wireframe);

      return { geometry, heightMap };
    }

    const terrainData = createTerrain();

    // Get terrain height at position
    function getTerrainHeight(x, z) {
      const halfSize = TERRAIN_SIZE / 2;
      const segSize = TERRAIN_SIZE / TERRAIN_SEGMENTS;

      const gridX = Math.floor((x + halfSize) / segSize);
      const gridZ = Math.floor((z + halfSize) / segSize);

      const idx = gridZ * (TERRAIN_SEGMENTS + 1) + gridX;
      if (idx >= 0 && idx < terrainData.heightMap.length) {
        return terrainData.heightMap[idx];
      }
      return 0;
    }

    // Create fantasy tree
    function createTree(x, z) {
      const group = new THREE.Group();
      const baseHeight = getTerrainHeight(x, z);

      // Tree trunk - weathered brown bark
      const trunkGeo = new THREE.CylinderGeometry(0.1, 0.18, 1.8, 6);
      const trunkMat = new THREE.MeshBasicMaterial({ color: 0x3d2817 });
      const trunk = new THREE.Mesh(trunkGeo, trunkMat);
      trunk.position.y = 0.9;
      group.add(trunk);

      // Fantasy foliage colors - natural greens, autumn golds, mystical purples
      const treeColors = [
        0x2d5a27, // Deep forest green
        0x4a7a3a, // Lighter green
        0x6b4423, // Autumn orange-brown
        0xc4a35a, // Golden autumn
        0x3a2a4a, // Mystical purple
        0x1a4a3a  // Dark teal
      ];
      const color = treeColors[Math.floor(Math.random() * treeColors.length)];

      // Low-poly cone foliage layers
      for (let i = 0; i < 3; i++) {
        const coneGeo = new THREE.ConeGeometry(0.9 - i * 0.25, 1.4 - i * 0.3, 6);
        const coneMat = new THREE.MeshBasicMaterial({
          color: color,
          transparent: true,
          opacity: 0.85
        });
        const cone = new THREE.Mesh(coneGeo, coneMat);
        cone.position.y = 1.8 + i * 0.7;
        group.add(cone);
      }

      group.position.set(x, baseHeight, z);
      scene.add(group);
      return group;
    }

    // Create trees
    const trees = [];
    for (let i = 0; i < 25; i++) {
      const x = (Math.random() - 0.5) * (TERRAIN_SIZE - 5);
      const z = (Math.random() - 0.5) * (TERRAIN_SIZE - 5);
      trees.push(createTree(x, z));
    }

    // Agent data
    const agents = [];
    const connections = [];

    // AI Agent types with Metin2 classes and distinct colors
    const agentTypes = [
      { name: 'CLAUDE', color: 0xff6b35, metin2Class: 'Warrior', weapon: '‚öîÔ∏è' },
      { name: 'GEMINI', color: 0x4285f4, metin2Class: 'Ninja', weapon: 'üó°Ô∏è' },
      { name: 'CODEX', color: 0x00ff88, metin2Class: 'Sura', weapon: 'üîÆ' },
      { name: 'CURSOR', color: 0xae53ff, metin2Class: 'Shaman', weapon: 'ü™Ñ' }
    ];

    const statuses = ['active', 'idle', 'error', 'processing'];

    // Speech bubble messages by class
    const speechBubbles = {
      Warrior: ["For honor!", "Attack!", "Stand your ground!", "CHARGE!", "Victory awaits!"],
      Ninja: ["*vanishes*", "Silent strike...", "From the shadows!", "You won't see me coming", "Stealth mode"],
      Sura: ["Dark magic rises!", "Feel my power!", "Cursed blade!", "The void calls...", "Embrace darkness"],
      Shaman: ["Nature guide me", "Healing winds!", "Spirits protect us", "Balance restored", "Ancient wisdom"]
    };

    let selectedAgent = null;
    let agentCounter = 0;

    // Create class-specific weapon
    function createWeapon(metin2Class, color) {
      const weaponGroup = new THREE.Group();
      const glowMat = new THREE.MeshBasicMaterial({ color: color, transparent: true, opacity: 0.9 });
      const darkMat = new THREE.MeshBasicMaterial({ color: 0x1a1a2a });

      switch (metin2Class) {
        case 'Warrior':
          // MASSIVE glowing broadsword
          const bladeGeo = new THREE.BoxGeometry(0.12, 1.2, 0.04);
          const blade = new THREE.Mesh(bladeGeo, glowMat);
          blade.position.y = 0.6;
          weaponGroup.add(blade);
          // Blade edge glow
          const edgeGeo = new THREE.BoxGeometry(0.02, 1.15, 0.08);
          const edgeMat = new THREE.MeshBasicMaterial({ color: 0xffffff, transparent: true, opacity: 0.5 });
          const edge = new THREE.Mesh(edgeGeo, edgeMat);
          edge.position.y = 0.6;
          weaponGroup.add(edge);
          // Sword crossguard
          const guardGeo = new THREE.BoxGeometry(0.35, 0.06, 0.06);
          const guard = new THREE.Mesh(guardGeo, darkMat);
          guard.position.y = -0.02;
          weaponGroup.add(guard);
          // Sword hilt
          const hiltGeo = new THREE.CylinderGeometry(0.04, 0.05, 0.2, 6);
          const hilt = new THREE.Mesh(hiltGeo, darkMat);
          hilt.position.y = -0.14;
          weaponGroup.add(hilt);
          // Sword pommel
          const pommelGeo = new THREE.IcosahedronGeometry(0.06, 0);
          const pommel = new THREE.Mesh(pommelGeo, glowMat);
          pommel.position.y = -0.28;
          weaponGroup.add(pommel);
          weaponGroup.position.set(0.4, 0.5, 0.1);
          weaponGroup.rotation.z = -0.4;
          break;

        case 'Ninja':
          // Large glowing bow
          const bowCurve = new THREE.CatmullRomCurve3([
            new THREE.Vector3(0, -0.5, 0),
            new THREE.Vector3(0.15, -0.25, 0),
            new THREE.Vector3(0.2, 0, 0),
            new THREE.Vector3(0.15, 0.25, 0),
            new THREE.Vector3(0, 0.5, 0)
          ]);
          const bowGeo = new THREE.TubeGeometry(bowCurve, 16, 0.035, 8, false);
          const bow = new THREE.Mesh(bowGeo, glowMat);
          weaponGroup.add(bow);
          // Inner glow on bow
          const bowGlowCurve = new THREE.CatmullRomCurve3([
            new THREE.Vector3(0, -0.48, 0),
            new THREE.Vector3(0.13, -0.24, 0),
            new THREE.Vector3(0.18, 0, 0),
            new THREE.Vector3(0.13, 0.24, 0),
            new THREE.Vector3(0, 0.48, 0)
          ]);
          const bowGlowGeo = new THREE.TubeGeometry(bowGlowCurve, 16, 0.02, 6, false);
          const bowGlowMat = new THREE.MeshBasicMaterial({ color: 0xffffff, transparent: true, opacity: 0.4 });
          const bowGlow = new THREE.Mesh(bowGlowGeo, bowGlowMat);
          weaponGroup.add(bowGlow);
          // Bowstring
          const stringGeo = new THREE.BufferGeometry().setFromPoints([
            new THREE.Vector3(0, -0.5, 0),
            new THREE.Vector3(-0.08, 0, 0),
            new THREE.Vector3(0, 0.5, 0)
          ]);
          const stringMat = new THREE.LineBasicMaterial({ color: 0xffffff, transparent: true, opacity: 0.8 });
          const bowString = new THREE.Line(stringGeo, stringMat);
          weaponGroup.add(bowString);
          // Nocked arrow
          const arrowGeo = new THREE.CylinderGeometry(0.01, 0.01, 0.5, 4);
          const arrowMat = new THREE.MeshBasicMaterial({ color: 0xffffff });
          const arrow = new THREE.Mesh(arrowGeo, arrowMat);
          arrow.position.set(-0.04, 0, 0);
          arrow.rotation.z = Math.PI / 2;
          weaponGroup.add(arrow);
          // Arrowhead
          const arrowHeadGeo = new THREE.ConeGeometry(0.03, 0.08, 4);
          const arrowHead = new THREE.Mesh(arrowHeadGeo, glowMat);
          arrowHead.position.set(-0.29, 0, 0);
          arrowHead.rotation.z = -Math.PI / 2;
          weaponGroup.add(arrowHead);
          weaponGroup.position.set(-0.4, 0.65, 0.15);
          break;

        case 'Sura':
          // Dark magic orb on staff
          const staffGeo = new THREE.CylinderGeometry(0.02, 0.025, 0.8, 6);
          const staff = new THREE.Mesh(staffGeo, darkMat);
          staff.position.y = 0.4;
          weaponGroup.add(staff);
          // Magic orb
          const orbGeo = new THREE.IcosahedronGeometry(0.1, 1);
          const orb = new THREE.Mesh(orbGeo, glowMat);
          orb.position.y = 0.85;
          weaponGroup.add(orb);
          // Orbiting runes
          const runeGeo = new THREE.TorusGeometry(0.15, 0.01, 4, 8);
          const rune = new THREE.Mesh(runeGeo, new THREE.MeshBasicMaterial({ color: color, transparent: true, opacity: 0.5 }));
          rune.position.y = 0.85;
          rune.rotation.x = Math.PI / 4;
          weaponGroup.add(rune);
          weaponGroup.position.set(0.35, 0.3, 0);
          break;

        case 'Shaman':
          // Nature staff with crystal
          const natStaffGeo = new THREE.CylinderGeometry(0.025, 0.03, 0.9, 6);
          const natStaff = new THREE.Mesh(natStaffGeo, new THREE.MeshBasicMaterial({ color: 0x4a3520 }));
          natStaff.position.y = 0.45;
          weaponGroup.add(natStaff);
          // Crystal top
          const crystalGeo = new THREE.OctahedronGeometry(0.1, 0);
          const crystal = new THREE.Mesh(crystalGeo, glowMat);
          crystal.position.y = 0.95;
          weaponGroup.add(crystal);
          // Leaf decorations
          for (let i = 0; i < 3; i++) {
            const leafGeo = new THREE.ConeGeometry(0.04, 0.12, 4);
            const leafMat = new THREE.MeshBasicMaterial({ color: 0x00ff88, transparent: true, opacity: 0.7 });
            const leaf = new THREE.Mesh(leafGeo, leafMat);
            leaf.position.y = 0.75;
            leaf.position.x = Math.cos(i * 2.1) * 0.06;
            leaf.position.z = Math.sin(i * 2.1) * 0.06;
            leaf.rotation.z = 0.5;
            weaponGroup.add(leaf);
          }
          weaponGroup.position.set(-0.35, 0.3, 0);
          break;
      }
      return weaponGroup;
    }

    // Create class-specific armor
    function createArmor(metin2Class, color) {
      const armorGroup = new THREE.Group();
      const armorMat = new THREE.MeshBasicMaterial({ color: color, transparent: true, opacity: 0.8 });
      const darkArmorMat = new THREE.MeshBasicMaterial({ color: 0x2a2a3a });

      switch (metin2Class) {
        case 'Warrior':
          // Heavy shoulder pads
          for (let side of [-1, 1]) {
            const shoulderGeo = new THREE.BoxGeometry(0.18, 0.08, 0.15);
            const shoulder = new THREE.Mesh(shoulderGeo, armorMat);
            shoulder.position.set(side * 0.28, 0.95, 0);
            armorGroup.add(shoulder);
            // Spikes on shoulders
            const spikeGeo = new THREE.ConeGeometry(0.03, 0.12, 4);
            const spike = new THREE.Mesh(spikeGeo, armorMat);
            spike.position.set(side * 0.32, 1.05, 0);
            armorGroup.add(spike);
          }
          // Chest plate
          const chestGeo = new THREE.BoxGeometry(0.35, 0.25, 0.12);
          const chest = new THREE.Mesh(chestGeo, darkArmorMat);
          chest.position.set(0, 0.7, 0.08);
          armorGroup.add(chest);
          break;

        case 'Ninja':
          // Light cloth wraps
          const scarfGeo = new THREE.TorusGeometry(0.18, 0.03, 4, 8);
          const scarf = new THREE.Mesh(scarfGeo, armorMat);
          scarf.position.set(0, 1.05, 0);
          scarf.rotation.x = Math.PI / 2;
          armorGroup.add(scarf);
          // Arm bands
          for (let side of [-1, 1]) {
            const bandGeo = new THREE.TorusGeometry(0.08, 0.02, 4, 8);
            const band = new THREE.Mesh(bandGeo, armorMat);
            band.position.set(side * 0.25, 0.6, 0);
            band.rotation.z = Math.PI / 2;
            armorGroup.add(band);
          }
          break;

        case 'Sura':
          // Dark magical robes
          const robeGeo = new THREE.ConeGeometry(0.3, 0.5, 6);
          const robe = new THREE.Mesh(robeGeo, new THREE.MeshBasicMaterial({ color: 0x1a0a2a, transparent: true, opacity: 0.7 }));
          robe.position.set(0, 0.35, 0);
          armorGroup.add(robe);
          // Floating dark orbs around shoulders
          for (let i = 0; i < 2; i++) {
            const orbGeo = new THREE.SphereGeometry(0.06, 6, 4);
            const orb = new THREE.Mesh(orbGeo, armorMat);
            orb.position.set((i === 0 ? -1 : 1) * 0.35, 0.9, 0);
            armorGroup.add(orb);
          }
          break;

        case 'Shaman':
          // Nature-themed light armor
          // Leaf shoulder pieces
          for (let side of [-1, 1]) {
            const leafPadGeo = new THREE.ConeGeometry(0.1, 0.15, 5);
            const leafPad = new THREE.Mesh(leafPadGeo, new THREE.MeshBasicMaterial({ color: 0x00aa55, transparent: true, opacity: 0.8 }));
            leafPad.position.set(side * 0.25, 0.95, 0);
            leafPad.rotation.z = side * 0.5;
            armorGroup.add(leafPad);
          }
          // Necklace with gem
          const neckGeo = new THREE.TorusGeometry(0.12, 0.015, 4, 12);
          const neck = new THREE.Mesh(neckGeo, darkArmorMat);
          neck.position.set(0, 1.0, 0.05);
          neck.rotation.x = Math.PI / 3;
          armorGroup.add(neck);
          const gemGeo = new THREE.OctahedronGeometry(0.04, 0);
          const gem = new THREE.Mesh(gemGeo, armorMat);
          gem.position.set(0, 0.92, 0.1);
          armorGroup.add(gem);
          break;
      }
      return armorGroup;
    }

    // Create character unit with weapons and armor
    function createAgent(x, z, forceType = null) {
      const agentType = forceType || agentTypes[Math.floor(Math.random() * agentTypes.length)];
      const color = agentType.color;
      const colorHex = '#' + color.toString(16).padStart(6, '0');
      const status = statuses[Math.floor(Math.random() * 3)];
      const baseHeight = getTerrainHeight(x, z);

      const group = new THREE.Group();

      // Body - low poly capsule shape
      const bodyGeo = new THREE.CapsuleGeometry(0.25, 0.5, 4, 6);
      const bodyMat = new THREE.MeshBasicMaterial({ color: color });
      const body = new THREE.Mesh(bodyGeo, bodyMat);
      body.position.y = 0.6;
      group.add(body);

      // Head - simple sphere
      const headGeo = new THREE.IcosahedronGeometry(0.2, 0);
      const headMat = new THREE.MeshBasicMaterial({ color: color });
      const head = new THREE.Mesh(headGeo, headMat);
      head.position.y = 1.2;
      group.add(head);

      // Add class-specific armor
      const armor = createArmor(agentType.metin2Class, color);
      group.add(armor);

      // Add class-specific weapon
      const weapon = createWeapon(agentType.metin2Class, color);
      group.add(weapon);

      // Glow ring around unit
      const ringGeo = new THREE.TorusGeometry(0.5, 0.03, 8, 16);
      const ringMat = new THREE.MeshBasicMaterial({
        color: color,
        transparent: true,
        opacity: 0.6
      });
      const ring = new THREE.Mesh(ringGeo, ringMat);
      ring.rotation.x = Math.PI / 2;
      ring.position.y = 0.1;
      group.add(ring);

      // Status indicator above head
      const indicatorGeo = new THREE.OctahedronGeometry(0.12, 0);
      const indicatorMat = new THREE.MeshBasicMaterial({ color: color });
      const indicator = new THREE.Mesh(indicatorGeo, indicatorMat);
      indicator.position.y = 1.6;
      group.add(indicator);

      // Class label (floating above unit)
      const labelDiv = document.createElement('div');
      labelDiv.className = 'class-label';
      labelDiv.textContent = `${agentType.weapon} ${agentType.metin2Class}`;
      labelDiv.style.color = colorHex;
      labelDiv.style.borderColor = colorHex;
      const label = new CSS2DObject(labelDiv);
      label.position.set(0, 2, 0);
      group.add(label);

      group.position.set(x, baseHeight, z);
      scene.add(group);

      agentCounter++;
      const agent = {
        id: agentCounter,
        name: `${agentType.name}-${String(agentCounter).padStart(3, '0')}`,
        type: agentType.name,
        metin2Class: agentType.metin2Class,
        weapon: agentType.weapon,
        mesh: group,
        body: body,
        ring: ring,
        indicator: indicator,
        label: label,
        labelDiv: labelDiv,
        status: status,
        color: color,
        colorHex: colorHex,
        tasks: Math.floor(Math.random() * 100),
        uptime: Math.floor(Math.random() * 3600),
        connections: [],
        targetX: x,
        targetZ: z,
        walkSpeed: 0.02 + Math.random() * 0.02,
        speechBubble: null,
        lastSpeech: 0
      };

      agents.push(agent);
      updateStats();
      return agent;
    }

    // Short messages for bubbles (full responses for chat)
    const shortBubbleText = {
      Warrior: ["‚öîÔ∏è Huh?", "Attack!", "Hey!", "Ready!", "Hmph!"],
      Ninja: ["...", "*nods*", "Ssh!", "üëÄ", "!"],
      Sura: ["Hmm...", "Dark...", "‚ö°", "...", "Curse!"],
      Shaman: ["üåø", "Peace", "Ah...", "Spirit!", "Yes?"]
    };

    // Full AI responses for chat
    const aiResponses = {
      Warrior: [
        "Ready for battle! What orders do you have for me?",
        "My blade is sharp and my spirit is strong. How may I serve?",
        "A warrior never backs down from a challenge!",
        "Honor and glory await on the battlefield!",
        "Tell me where to strike, and victory shall be ours!"
      ],
      Ninja: [
        "I move unseen through the shadows... What intel do you have?",
        "Silence is my weapon. Patience is my shield.",
        "Every shadow has ears. Speak carefully.",
        "I'll complete any mission you assign. Discretion guaranteed.",
        "The art of stealth requires... subtlety."
      ],
      Sura: [
        "The dark energies flow through me. What do you seek?",
        "Power beyond mortal comprehension awaits those who dare...",
        "The void whispers secrets to those who listen.",
        "My cursed blade hungers. Point me at your enemies.",
        "Embrace the darkness, and it shall embrace you."
      ],
      Shaman: [
        "The spirits speak of your arrival. Welcome, friend.",
        "Nature's wisdom flows through all living things.",
        "I sense great potential in you. How may I guide you?",
        "Balance must be maintained in all things.",
        "The ancient ones watch over us. What troubles you?"
      ]
    };

    // Chat state per agent
    const chatHistories = {};

    // Show speech bubble for agent
    function showSpeechBubble(agent, customMsg = null) {
      // Remove existing bubble
      if (agent.speechBubble) {
        agent.mesh.remove(agent.speechBubble);
      }

      // Use short text for bubbles
      const messages = customMsg ? [customMsg] : shortBubbleText[agent.metin2Class];
      const message = messages[Math.floor(Math.random() * messages.length)];

      const bubbleDiv = document.createElement('div');
      bubbleDiv.className = 'speech-bubble';
      bubbleDiv.textContent = message;
      bubbleDiv.style.color = agent.colorHex;
      bubbleDiv.style.borderColor = agent.colorHex;

      // Make bubble clickable to open chat
      bubbleDiv.addEventListener('click', () => {
        openChatModal(agent);
      });

      const bubble = new CSS2DObject(bubbleDiv);
      bubble.position.set(0, 2.8, 0);
      agent.mesh.add(bubble);
      agent.speechBubble = bubble;

      // Remove after animation
      setTimeout(() => {
        if (agent.speechBubble === bubble) {
          agent.mesh.remove(bubble);
          agent.speechBubble = null;
        }
      }, 4000);
    }

    // Create connection between agents
    function createConnection(agent1, agent2) {
      if (agent1.connections.includes(agent2.id) || agent1 === agent2) return;

      const material = new THREE.LineBasicMaterial({
        color: 0x00ffff,
        transparent: true,
        opacity: 0.4
      });

      const points = [
        new THREE.Vector3(agent1.mesh.position.x, agent1.mesh.position.y + 1, agent1.mesh.position.z),
        new THREE.Vector3(agent2.mesh.position.x, agent2.mesh.position.y + 1, agent2.mesh.position.z)
      ];
      const geometry = new THREE.BufferGeometry().setFromPoints(points);
      const line = new THREE.Line(geometry, material);

      scene.add(line);

      const connection = { line, agent1, agent2 };
      connections.push(connection);
      agent1.connections.push(agent2.id);
      agent2.connections.push(agent1.id);
      updateStats();
    }

    // Update connection lines to follow agents
    function updateConnections() {
      connections.forEach(conn => {
        const positions = conn.line.geometry.attributes.position;
        positions.setXYZ(0, conn.agent1.mesh.position.x, conn.agent1.mesh.position.y + 1, conn.agent1.mesh.position.z);
        positions.setXYZ(1, conn.agent2.mesh.position.x, conn.agent2.mesh.position.y + 1, conn.agent2.mesh.position.z);
        positions.needsUpdate = true;
      });
    }

    // Remove agent
    function removeAgent(agent) {
      for (let i = connections.length - 1; i >= 0; i--) {
        const conn = connections[i];
        if (conn.agent1 === agent || conn.agent2 === agent) {
          scene.remove(conn.line);
          connections.splice(i, 1);
        }
      }

      agents.forEach(a => {
        a.connections = a.connections.filter(id => id !== agent.id);
      });

      scene.remove(agent.mesh);
      const idx = agents.indexOf(agent);
      if (idx > -1) agents.splice(idx, 1);

      if (selectedAgent === agent) {
        selectedAgent = null;
        document.getElementById('agentInfo').classList.remove('visible');
      }
      updateStats();
    }

    // Update stats display
    function updateStats() {
      document.getElementById('totalAgents').textContent = agents.length;
      document.getElementById('activeAgents').textContent = agents.filter(a => a.status === 'active').length;
      document.getElementById('totalConnections').textContent = connections.length;
      document.getElementById('networkLoad').textContent = Math.min(100, Math.floor((connections.length / Math.max(1, agents.length)) * 50)) + '%';
    }

    // Select agent
    function selectAgent(agent) {
      if (selectedAgent) {
        selectedAgent.mesh.scale.set(1, 1, 1);
      }

      selectedAgent = agent;
      agent.mesh.scale.set(1.3, 1.3, 1.3);

      const info = document.getElementById('agentInfo');
      info.classList.add('visible');
      document.getElementById('agentName').textContent = agent.name;

      const statusEl = document.getElementById('agentStatus');
      statusEl.textContent = agent.status.toUpperCase();
      statusEl.className = 'agent-status status-' + agent.status;

      document.getElementById('agentType').textContent = `${agent.type} (${agent.metin2Class})`;
      document.getElementById('agentTasks').textContent = agent.tasks;
      document.getElementById('agentUptime').textContent = formatTime(agent.uptime);
    }

    function formatTime(seconds) {
      if (seconds < 60) return seconds + 's';
      if (seconds < 3600) return Math.floor(seconds / 60) + 'm';
      return Math.floor(seconds / 3600) + 'h';
    }

    // Raycaster for clicking
    const raycaster = new THREE.Raycaster();
    const mouse = new THREE.Vector2();

    renderer.domElement.addEventListener('click', (event) => {
      mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
      mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

      raycaster.setFromCamera(mouse, camera);
      const meshes = agents.map(a => a.body);
      const intersects = raycaster.intersectObjects(meshes);

      if (intersects.length > 0) {
        const clickedMesh = intersects[0].object;
        const agent = agents.find(a => a.body === clickedMesh);
        if (agent) selectAgent(agent);
      }
    });

    // UI button handlers
    document.getElementById('addAgent').addEventListener('click', () => {
      const x = (Math.random() - 0.5) * (TERRAIN_SIZE - 5);
      const z = (Math.random() - 0.5) * (TERRAIN_SIZE - 5);
      const agent = createAgent(x, z);
      selectAgent(agent);
    });

    document.getElementById('connectAgents').addEventListener('click', () => {
      if (agents.length < 2) return;

      if (selectedAgent) {
        const others = agents.filter(a => a !== selectedAgent && !selectedAgent.connections.includes(a.id));
        if (others.length > 0) {
          const target = others[Math.floor(Math.random() * others.length)];
          createConnection(selectedAgent, target);
        }
      } else {
        const a1 = agents[Math.floor(Math.random() * agents.length)];
        const others = agents.filter(a => a !== a1 && !a1.connections.includes(a.id));
        if (others.length > 0) {
          const a2 = others[Math.floor(Math.random() * others.length)];
          createConnection(a1, a2);
        }
      }
    });

    document.getElementById('removeAgent').addEventListener('click', () => {
      if (selectedAgent) {
        removeAgent(selectedAgent);
      } else if (agents.length > 0) {
        removeAgent(agents[agents.length - 1]);
      }
    });

    // Animation loop
    function animate() {
      requestAnimationFrame(animate);

      const time = Date.now() * 0.001;

      // Animate agents
      agents.forEach((agent, i) => {
        // Ring rotation
        agent.ring.rotation.z += 0.03;

        // Indicator bobbing
        agent.indicator.rotation.y += 0.05;
        agent.indicator.position.y = 1.6 + Math.sin(time * 3 + i) * 0.1;

        // Random walking
        if (Math.random() < 0.01) {
          agent.targetX = (Math.random() - 0.5) * (TERRAIN_SIZE - 8);
          agent.targetZ = (Math.random() - 0.5) * (TERRAIN_SIZE - 8);
        }

        // Move toward target
        const dx = agent.targetX - agent.mesh.position.x;
        const dz = agent.targetZ - agent.mesh.position.z;
        const dist = Math.sqrt(dx * dx + dz * dz);

        if (dist > 0.5) {
          agent.mesh.position.x += (dx / dist) * agent.walkSpeed;
          agent.mesh.position.z += (dz / dist) * agent.walkSpeed;

          // Update Y to follow terrain
          agent.mesh.position.y = getTerrainHeight(agent.mesh.position.x, agent.mesh.position.z);

          // Face direction of movement
          agent.mesh.rotation.y = Math.atan2(dx, dz);

          // Walking bob
          agent.body.position.y = 0.6 + Math.abs(Math.sin(time * 10)) * 0.08;
        }

        // Random speech bubbles
        if (Math.random() < 0.002 && !agent.speechBubble) {
          showSpeechBubble(agent);
        }
      });

      // Update connection lines
      updateConnections();

      // Pulse connections
      connections.forEach((conn, i) => {
        const pulse = (Math.sin(time * 3 + i) + 1) / 2;
        conn.line.material.opacity = 0.2 + pulse * 0.4;
      });

      // Animate trees slightly
      trees.forEach((tree, i) => {
        tree.rotation.y = Math.sin(time * 0.5 + i) * 0.05;
      });

      // Animate treasure chest glows
      if (typeof treasureChests !== 'undefined') {
        treasureChests.forEach((chest, i) => {
          if (!chest.opened && chest.glow) {
            chest.glow.material.opacity = 0.3 + Math.sin(time * 2 + i) * 0.2;
            chest.glow.rotation.z += 0.01;
          }
        });
      }

      controls.update();
      composer.render();
      labelRenderer.render(scene, camera);
    }

    // Initialize with some agents
    for (let i = 0; i < 5; i++) {
      const x = (Math.random() - 0.5) * 15;
      const z = (Math.random() - 0.5) * 15;
      createAgent(x, z);
    }

    // Create some initial connections
    if (agents.length >= 2) {
      createConnection(agents[0], agents[1]);
      if (agents.length >= 3) createConnection(agents[1], agents[2]);
      if (agents.length >= 4) createConnection(agents[2], agents[3]);
    }

    // Handle resize
    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
      labelRenderer.setSize(window.innerWidth, window.innerHeight);
      composer.setSize(window.innerWidth, window.innerHeight);
    });

    // Terminal functionality
    const terminalLog = document.getElementById('terminalLog');
    const terminalInput = document.getElementById('terminalInput');
    const terminal = document.getElementById('terminal');
    const terminalToggle = document.getElementById('terminalToggle');

    // Mobile toggle
    terminalToggle.addEventListener('click', () => {
      terminal.classList.toggle('visible');
    });

    // Fake activity messages
    const activityMessages = {
      info: [
        'Scanning network topology...',
        'Synchronizing agent protocols...',
        'Checking neural pathways...',
        'Validating crypto signatures...',
        'Parsing incoming data streams...',
        'Optimizing memory allocation...',
        'Calibrating response matrices...',
        'Indexing knowledge base...'
      ],
      success: [
        'Connection established',
        'Task completed successfully',
        'Data sync complete',
        'Agent handshake verified',
        'Protocol upgrade applied',
        'Cache refreshed',
        'Backup checkpoint saved'
      ],
      warning: [
        'High latency detected',
        'Memory usage elevated',
        'Queue backlog growing',
        'Rate limit approaching',
        'Fallback mode engaged'
      ],
      error: [
        'Connection timeout',
        'Authentication failed',
        'Resource unavailable',
        'Buffer overflow prevented',
        'Invalid response format'
      ]
    };

    const taskTypes = [
      'data_analysis', 'code_review', 'content_gen', 'model_training',
      'inference_run', 'chat_response', 'embedding_calc', 'search_query',
      'summarization', 'translation', 'classification', 'sentiment_scan'
    ];

    function getTimestamp() {
      const now = new Date();
      return now.toTimeString().split(' ')[0];
    }

    function addLog(message, type = 'info') {
      const entry = document.createElement('div');
      entry.className = 'log-entry';
      entry.innerHTML = `<span class="log-time">[${getTimestamp()}]</span> <span class="log-${type}">${message}</span>`;
      terminalLog.appendChild(entry);
      terminalLog.scrollTop = terminalLog.scrollHeight;

      // Keep log clean (max 50 entries)
      while (terminalLog.children.length > 50) {
        terminalLog.removeChild(terminalLog.firstChild);
      }
    }

    // Generate fake activity logs
    function generateActivity() {
      if (agents.length === 0) return;

      const roll = Math.random();
      let type, messages;

      if (roll < 0.5) {
        type = 'info';
        messages = activityMessages.info;
      } else if (roll < 0.75) {
        type = 'success';
        messages = activityMessages.success;
      } else if (roll < 0.9) {
        type = 'warning';
        messages = activityMessages.warning;
      } else {
        type = 'error';
        messages = activityMessages.error;
      }

      const agent = agents[Math.floor(Math.random() * agents.length)];
      const msg = messages[Math.floor(Math.random() * messages.length)];
      addLog(`[${agent.name}] ${msg}`, type);

      // Sometimes update agent status based on activity
      if (type === 'error' && Math.random() < 0.3) {
        updateAgentStatus(agent, 'error');
      } else if (type === 'success' && agent.status === 'error') {
        updateAgentStatus(agent, 'active');
      }
    }

    // Update agent status
    function updateAgentStatus(agent, newStatus) {
      const oldStatus = agent.status;
      agent.status = newStatus;

      // Update indicator color
      const statusColors = {
        active: 0x00ff88,
        idle: 0xffee00,
        error: 0xff3366,
        processing: 0x00ffff
      };

      agent.indicator.material.color.setHex(statusColors[newStatus] || 0x00ff88);

      // Update UI if selected
      if (selectedAgent === agent) {
        const statusEl = document.getElementById('agentStatus');
        statusEl.textContent = newStatus.toUpperCase();
        statusEl.className = 'agent-status status-' + newStatus;
      }

      updateStats();
      addLog(`[${agent.name}] Status: ${oldStatus} ‚Üí ${newStatus}`, newStatus === 'error' ? 'error' : 'success');
    }

    // Process terminal commands
    function processCommand(cmd) {
      const parts = cmd.trim().toLowerCase().split(/\s+/);
      const command = parts[0];

      addLog(`> ${cmd}`, 'info');

      switch (command) {
        case 'help':
          addLog('Available commands:', 'success');
          addLog('  status <agent> <active|idle|error|processing>', 'info');
          addLog('  task <agent> - assign random task', 'info');
          addLog('  list - show all agents', 'info');
          addLog('  ping <agent> - ping an agent', 'info');
          addLog('  heal <agent> - restore agent to active', 'info');
          addLog('  broadcast <msg> - message all agents', 'info');
          addLog('  clear - clear terminal', 'info');
          break;

        case 'list':
          addLog(`Active agents (${agents.length}):`, 'success');
          agents.forEach(a => {
            addLog(`  ${a.name} [${a.status}] ${a.weapon}${a.metin2Class}`, 'agent');
          });
          break;

        case 'status':
          if (parts.length < 3) {
            addLog('Usage: status <agent> <active|idle|error|processing>', 'warning');
            break;
          }
          const statusAgent = agents.find(a => a.name.toLowerCase().includes(parts[1]));
          if (!statusAgent) {
            addLog(`Agent "${parts[1]}" not found`, 'error');
            break;
          }
          const validStatuses = ['active', 'idle', 'error', 'processing'];
          if (!validStatuses.includes(parts[2])) {
            addLog(`Invalid status. Use: ${validStatuses.join(', ')}`, 'error');
            break;
          }
          updateAgentStatus(statusAgent, parts[2]);
          break;

        case 'task':
          if (parts.length < 2) {
            addLog('Usage: task <agent>', 'warning');
            break;
          }
          const taskAgent = agents.find(a => a.name.toLowerCase().includes(parts[1]));
          if (!taskAgent) {
            addLog(`Agent "${parts[1]}" not found`, 'error');
            break;
          }
          const task = taskTypes[Math.floor(Math.random() * taskTypes.length)];
          taskAgent.tasks++;
          if (selectedAgent === taskAgent) {
            document.getElementById('agentTasks').textContent = taskAgent.tasks;
          }
          updateAgentStatus(taskAgent, 'processing');
          addLog(`Assigned ${task} to ${taskAgent.name}`, 'success');
          setTimeout(() => {
            if (taskAgent.status === 'processing') {
              updateAgentStatus(taskAgent, 'active');
              addLog(`[${taskAgent.name}] Completed ${task}`, 'success');
            }
          }, 2000 + Math.random() * 3000);
          break;

        case 'ping':
          if (parts.length < 2) {
            addLog('Usage: ping <agent>', 'warning');
            break;
          }
          const pingAgent = agents.find(a => a.name.toLowerCase().includes(parts[1]));
          if (!pingAgent) {
            addLog(`Agent "${parts[1]}" not found`, 'error');
            break;
          }
          const latency = Math.floor(Math.random() * 150) + 10;
          addLog(`Pinging ${pingAgent.name}...`, 'info');
          setTimeout(() => {
            addLog(`[${pingAgent.name}] PONG! ${latency}ms`, 'success');
            showSpeechBubble(pingAgent);
          }, latency);
          break;

        case 'heal':
          if (parts.length < 2) {
            addLog('Usage: heal <agent>', 'warning');
            break;
          }
          const healAgent = agents.find(a => a.name.toLowerCase().includes(parts[1]));
          if (!healAgent) {
            addLog(`Agent "${parts[1]}" not found`, 'error');
            break;
          }
          if (healAgent.status === 'active') {
            addLog(`${healAgent.name} is already active`, 'info');
          } else {
            addLog(`Healing ${healAgent.name}...`, 'info');
            updateAgentStatus(healAgent, 'active');
          }
          break;

        case 'broadcast':
          if (parts.length < 2) {
            addLog('Usage: broadcast <message>', 'warning');
            break;
          }
          const broadcastMsg = parts.slice(1).join(' ');
          addLog(`Broadcasting: "${broadcastMsg}"`, 'success');
          agents.forEach((a, i) => {
            setTimeout(() => showSpeechBubble(a), i * 300);
          });
          break;

        case 'clear':
          terminalLog.innerHTML = '';
          addLog('Terminal cleared', 'success');
          break;

        default:
          addLog(`Unknown command: ${command}. Type "help" for commands.`, 'error');
      }
    }

    // Terminal input handling
    terminalInput.addEventListener('keydown', (e) => {
      if (e.key === 'Enter' && terminalInput.value.trim()) {
        processCommand(terminalInput.value);
        terminalInput.value = '';
      }
    });

    // Initial log entries
    addLog('Agent Control Terminal v1.0', 'success');
    addLog('Type "help" for available commands', 'info');
    addLog('Initializing agent network...', 'info');
    setTimeout(() => addLog('Network initialized. Agents online.', 'success'), 500);

    // Auto-generate fake activity
    setInterval(generateActivity, 3000 + Math.random() * 2000);

    // Chat modal functionality
    const chatModal = document.getElementById('chatModal');
    const chatContainer = document.getElementById('chatContainer');
    const chatAgentName = document.getElementById('chatAgentName');
    const chatMessages = document.getElementById('chatMessages');
    const chatInput = document.getElementById('chatInput');
    const chatSend = document.getElementById('chatSend');
    const chatClose = document.getElementById('chatClose');

    let currentChatAgent = null;

    function openChatModal(agent) {
      currentChatAgent = agent;
      chatAgentName.textContent = `${agent.weapon} ${agent.name}`;
      chatAgentName.style.color = agent.colorHex;
      chatContainer.style.borderColor = agent.colorHex;

      // Initialize chat history for this agent
      if (!chatHistories[agent.id]) {
        chatHistories[agent.id] = [];
        // Add initial greeting
        const greeting = aiResponses[agent.metin2Class][0];
        chatHistories[agent.id].push({ type: 'agent', text: greeting });
      }

      // Render chat history
      renderChatMessages(agent);

      chatModal.classList.add('visible');
      chatInput.focus();

      // Log to terminal
      addLog(`[CHAT] Opened chat with ${agent.name}`, 'info');
    }

    function renderChatMessages(agent) {
      chatMessages.innerHTML = '';
      const history = chatHistories[agent.id] || [];

      history.forEach(msg => {
        const msgDiv = document.createElement('div');
        msgDiv.className = `chat-message ${msg.type}`;
        msgDiv.textContent = msg.text;
        if (msg.type === 'agent') {
          msgDiv.style.borderLeftColor = agent.colorHex;
        }
        chatMessages.appendChild(msgDiv);
      });

      chatMessages.scrollTop = chatMessages.scrollHeight;
    }

    function sendChatMessage() {
      const text = chatInput.value.trim();
      if (!text || !currentChatAgent) return;

      // Add user message
      chatHistories[currentChatAgent.id].push({ type: 'user', text: text });

      // Generate AI response
      const responses = aiResponses[currentChatAgent.metin2Class];
      const response = responses[Math.floor(Math.random() * responses.length)];

      // Simulate typing delay
      setTimeout(() => {
        chatHistories[currentChatAgent.id].push({ type: 'agent', text: response });
        renderChatMessages(currentChatAgent);

        // Show short bubble on the agent
        showSpeechBubble(currentChatAgent, shortBubbleText[currentChatAgent.metin2Class][Math.floor(Math.random() * 5)]);

        // Log to terminal
        addLog(`[${currentChatAgent.name}] Responded to chat`, 'success');
      }, 500 + Math.random() * 1000);

      chatInput.value = '';
      renderChatMessages(currentChatAgent);
    }

    chatSend.addEventListener('click', sendChatMessage);
    chatInput.addEventListener('keydown', (e) => {
      if (e.key === 'Enter') sendChatMessage();
    });

    chatClose.addEventListener('click', () => {
      chatModal.classList.remove('visible');
      currentChatAgent = null;
    });

    chatModal.addEventListener('click', (e) => {
      if (e.target === chatModal) {
        chatModal.classList.remove('visible');
        currentChatAgent = null;
      }
    });

    // Quest System with Technical Tips
    const quests = [
      { id: 1, title: 'Debug the Matrix', rarity: 'common', xp: 50, tip: 'Use console.log() strategically to trace data flow. Remove them before production!' },
      { id: 2, title: 'Master the Shadows', rarity: 'common', xp: 75, tip: 'CSS box-shadow can layer multiple shadows: box-shadow: 0 2px 4px rgba(0,0,0,0.2), 0 4px 8px rgba(0,0,0,0.1);' },
      { id: 3, title: 'Optimize the Forge', rarity: 'rare', xp: 150, tip: 'Use requestAnimationFrame() for smooth animations instead of setInterval(). It syncs with display refresh rate.' },
      { id: 4, title: 'Decode Ancient Scripts', rarity: 'rare', xp: 200, tip: 'Destructuring assignment: const {x, y} = object; Extract multiple properties in one line!' },
      { id: 5, title: 'Tame the Async Beast', rarity: 'epic', xp: 300, tip: 'async/await makes Promise chains readable. Always wrap in try/catch for error handling.' },
      { id: 6, title: 'Unlock Three.js Secrets', rarity: 'epic', xp: 400, tip: 'Reuse geometries and materials in Three.js. Creating new ones each frame causes memory leaks!' },
      { id: 7, title: 'Legendary Code Artifact', rarity: 'legendary', xp: 1000, tip: 'WeakMap and WeakSet allow garbage collection of keys. Perfect for caching without memory leaks.' }
    ];

    const treasureTips = {
      common: [
        'Array.isArray() is the safest way to check if something is an array.',
        'Use template literals: `Hello ${name}` instead of "Hello " + name',
        'const and let are block-scoped. var is function-scoped. Prefer const.',
        'Optional chaining: obj?.prop?.nested safely accesses nested properties.'
      ],
      rare: [
        'Array.from() converts array-like objects to real arrays with map support.',
        'Object.entries() returns [key, value] pairs for easy iteration.',
        'The nullish coalescing operator ?? only checks for null/undefined, not falsy.',
        'Use performance.now() for precise timing measurements in milliseconds.'
      ],
      epic: [
        'Proxy objects can intercept and customize fundamental operations like property access.',
        'Web Workers run JavaScript in background threads without blocking UI.',
        'IntersectionObserver is more efficient than scroll events for lazy loading.',
        'CSS contain: layout paint; can significantly improve render performance.'
      ],
      legendary: [
        'SharedArrayBuffer enables true shared memory between workers for parallel computing.',
        'Atomics provides atomic operations for thread-safe programming in JavaScript.',
        'The Temporal API (upcoming) will finally fix JavaScript date handling.',
        'Import assertions allow type checking for JSON and CSS module imports.'
      ]
    };

    // Quest Log UI
    const questLog = document.getElementById('questLog');
    const questList = document.getElementById('questList');
    const questBtn = document.getElementById('questBtn');
    const questLogClose = document.getElementById('questLogClose');

    function renderQuests() {
      questList.innerHTML = '';
      quests.forEach(quest => {
        const div = document.createElement('div');
        div.className = `quest-item ${quest.rarity}`;
        div.innerHTML = `
          <div class="quest-title">${quest.title}</div>
          <div class="quest-xp">+${quest.xp} XP</div>
        `;
        div.addEventListener('click', () => {
          showLoot(quest.rarity, quest.tip);
          addLog(`[QUEST] Completed: ${quest.title} (+${quest.xp} XP)`, 'success');
        });
        questList.appendChild(div);
      });
    }

    questBtn.addEventListener('click', () => {
      questLog.classList.toggle('visible');
      if (questLog.classList.contains('visible')) {
        renderQuests();
      }
    });

    questLogClose.addEventListener('click', () => {
      questLog.classList.remove('visible');
    });

    // Loot Modal
    const lootModal = document.getElementById('lootModal');
    const lootRarity = document.getElementById('lootRarity');
    const lootTip = document.getElementById('lootTip');
    const lootClose = document.getElementById('lootClose');

    function showLoot(rarity, tip) {
      const tipText = tip || treasureTips[rarity][Math.floor(Math.random() * treasureTips[rarity].length)];
      lootRarity.textContent = rarity.toUpperCase();
      lootRarity.className = `loot-rarity ${rarity}`;
      lootTip.textContent = tipText;
      lootModal.classList.add('visible');
    }

    lootClose.addEventListener('click', () => {
      lootModal.classList.remove('visible');
    });

    lootModal.addEventListener('click', (e) => {
      if (e.target === lootModal) {
        lootModal.classList.remove('visible');
      }
    });

    // Create 3D Treasure Chest
    const treasureChests = [];

    function createTreasureChest(x, z) {
      const group = new THREE.Group();
      const baseHeight = getTerrainHeight(x, z);

      // Chest base
      const baseGeo = new THREE.BoxGeometry(0.5, 0.35, 0.35);
      const baseMat = new THREE.MeshBasicMaterial({ color: 0x6b4423 });
      const base = new THREE.Mesh(baseGeo, baseMat);
      base.position.y = 0.175;
      group.add(base);

      // Chest lid (curved top)
      const lidGeo = new THREE.CylinderGeometry(0.18, 0.25, 0.5, 8, 1, false, 0, Math.PI);
      const lidMat = new THREE.MeshBasicMaterial({ color: 0x8b5a2b });
      const lid = new THREE.Mesh(lidGeo, lidMat);
      lid.rotation.z = Math.PI / 2;
      lid.rotation.y = Math.PI / 2;
      lid.position.y = 0.35;
      group.add(lid);

      // Gold trim
      const trimGeo = new THREE.BoxGeometry(0.52, 0.05, 0.37);
      const trimMat = new THREE.MeshBasicMaterial({ color: 0xd4a857 });
      const trim = new THREE.Mesh(trimGeo, trimMat);
      trim.position.y = 0.35;
      group.add(trim);

      // Lock
      const lockGeo = new THREE.BoxGeometry(0.08, 0.1, 0.05);
      const lockMat = new THREE.MeshBasicMaterial({ color: 0xd4a857 });
      const lock = new THREE.Mesh(lockGeo, lockMat);
      lock.position.set(0, 0.2, 0.2);
      group.add(lock);

      // Glow ring
      const glowGeo = new THREE.TorusGeometry(0.4, 0.02, 8, 16);
      const glowMat = new THREE.MeshBasicMaterial({
        color: 0xd4a857,
        transparent: true,
        opacity: 0.4
      });
      const glow = new THREE.Mesh(glowGeo, glowMat);
      glow.rotation.x = Math.PI / 2;
      glow.position.y = 0.05;
      group.add(glow);

      group.position.set(x, baseHeight, z);
      scene.add(group);

      // Determine rarity
      const roll = Math.random();
      let rarity;
      if (roll < 0.5) rarity = 'common';
      else if (roll < 0.8) rarity = 'rare';
      else if (roll < 0.95) rarity = 'epic';
      else rarity = 'legendary';

      const chest = { mesh: group, base, glow, rarity, opened: false };
      treasureChests.push(chest);
      return chest;
    }

    // Create initial treasure chests
    for (let i = 0; i < 5; i++) {
      const x = (Math.random() - 0.5) * (TERRAIN_SIZE - 10);
      const z = (Math.random() - 0.5) * (TERRAIN_SIZE - 10);
      createTreasureChest(x, z);
    }

    // Click detection for treasure chests
    renderer.domElement.addEventListener('click', (event) => {
      mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
      mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

      raycaster.setFromCamera(mouse, camera);
      const chestMeshes = treasureChests.filter(c => !c.opened).map(c => c.base);
      const intersects = raycaster.intersectObjects(chestMeshes);

      if (intersects.length > 0) {
        const clickedMesh = intersects[0].object;
        const chest = treasureChests.find(c => c.base === clickedMesh);
        if (chest && !chest.opened) {
          chest.opened = true;
          showLoot(chest.rarity);
          addLog(`[LOOT] Opened ${chest.rarity} treasure chest!`, chest.rarity === 'legendary' ? 'success' : 'info');

          // Animate chest opening
          chest.mesh.children.forEach(child => {
            child.material.transparent = true;
          });

          // Fade out chest
          let opacity = 1;
          const fadeInterval = setInterval(() => {
            opacity -= 0.05;
            chest.mesh.children.forEach(child => {
              if (child.material) child.material.opacity = opacity;
            });
            if (opacity <= 0) {
              clearInterval(fadeInterval);
              scene.remove(chest.mesh);
              // Spawn new chest elsewhere
              setTimeout(() => {
                const x = (Math.random() - 0.5) * (TERRAIN_SIZE - 10);
                const z = (Math.random() - 0.5) * (TERRAIN_SIZE - 10);
                createTreasureChest(x, z);
              }, 5000);
            }
          }, 50);
        }
      }
    });

    animate();
  </script>
</body>
</html>
