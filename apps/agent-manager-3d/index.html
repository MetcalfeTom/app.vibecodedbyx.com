<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>3D Agent Manager</title>
  <link rel="icon" href="https://emojicdn.elk.sh/ðŸ¤–">
  <meta property="og:title" content="3D Agent Manager">
  <meta property="og:description" content="Manage AI agents as glowing neon nodes in 3D space">
  <meta property="og:url" content="https://sloppy.live/agent-manager-3d">
  <meta property="og:image" content="https://sloppy.live/agent-manager-3d/og-image.png">
  <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700&display=swap" rel="stylesheet">
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      background: #050510;
      font-family: 'Orbitron', sans-serif;
      overflow: hidden;
      color: #fff;
    }

    #canvas-container {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
    }

    .ui-overlay {
      position: fixed;
      z-index: 100;
      pointer-events: none;
    }

    .ui-overlay > * {
      pointer-events: auto;
    }

    .header {
      top: 1rem;
      left: 50%;
      transform: translateX(-50%);
      text-align: center;
    }

    .header h1 {
      font-size: 1.5rem;
      color: #00ffff;
      text-shadow: 0 0 10px #00ffff, 0 0 20px #00ffff;
      letter-spacing: 3px;
    }

    .controls {
      top: 1rem;
      right: 1rem;
      display: flex;
      flex-direction: column;
      gap: 0.5rem;
    }

    .btn {
      padding: 0.6rem 1.2rem;
      background: rgba(0, 255, 255, 0.1);
      border: 2px solid #00ffff;
      border-radius: 8px;
      color: #00ffff;
      font-family: 'Orbitron', sans-serif;
      font-size: 0.75rem;
      cursor: pointer;
      transition: all 0.3s;
      text-transform: uppercase;
      box-shadow: 0 0 10px rgba(0, 255, 255, 0.3);
    }

    .btn:hover {
      background: rgba(0, 255, 255, 0.2);
      box-shadow: 0 0 20px rgba(0, 255, 255, 0.5);
      transform: scale(1.05);
    }

    .btn-danger {
      border-color: #ff3366;
      color: #ff3366;
      box-shadow: 0 0 10px rgba(255, 51, 102, 0.3);
    }

    .btn-danger:hover {
      background: rgba(255, 51, 102, 0.2);
      box-shadow: 0 0 20px rgba(255, 51, 102, 0.5);
    }

    .stats {
      bottom: 1rem;
      left: 1rem;
      background: rgba(0, 0, 0, 0.6);
      padding: 1rem;
      border-radius: 10px;
      border: 1px solid rgba(0, 255, 255, 0.3);
    }

    .stats h3 {
      font-size: 0.8rem;
      color: #00ffff;
      margin-bottom: 0.5rem;
      text-shadow: 0 0 5px #00ffff;
    }

    .stat-row {
      display: flex;
      justify-content: space-between;
      font-size: 0.7rem;
      margin: 0.3rem 0;
      color: #888;
    }

    .stat-value {
      color: #fff;
    }

    .agent-info {
      bottom: 1rem;
      right: 1rem;
      background: rgba(0, 0, 0, 0.6);
      padding: 1rem;
      border-radius: 10px;
      border: 1px solid rgba(255, 0, 255, 0.3);
      min-width: 200px;
      display: none;
    }

    .agent-info.visible {
      display: block;
    }

    .agent-info h3 {
      font-size: 0.9rem;
      color: #ff00ff;
      margin-bottom: 0.5rem;
      text-shadow: 0 0 5px #ff00ff;
    }

    .agent-status {
      display: inline-block;
      padding: 0.2rem 0.5rem;
      border-radius: 4px;
      font-size: 0.65rem;
      margin-bottom: 0.5rem;
    }

    .status-active {
      background: rgba(0, 255, 136, 0.2);
      color: #00ff88;
      border: 1px solid #00ff88;
    }

    .status-idle {
      background: rgba(255, 238, 0, 0.2);
      color: #ffee00;
      border: 1px solid #ffee00;
    }

    .status-error {
      background: rgba(255, 51, 102, 0.2);
      color: #ff3366;
      border: 1px solid #ff3366;
    }

    .legend {
      top: 5rem;
      right: 1rem;
      background: rgba(0, 0, 0, 0.5);
      padding: 0.8rem;
      border-radius: 8px;
      font-size: 0.65rem;
    }

    .legend-item {
      display: flex;
      align-items: center;
      gap: 0.5rem;
      margin: 0.3rem 0;
      color: #888;
    }

    .legend-dot {
      width: 10px;
      height: 10px;
      border-radius: 50%;
    }

    .instructions {
      bottom: 1rem;
      left: 50%;
      transform: translateX(-50%);
      font-size: 0.7rem;
      color: #666;
      text-align: center;
    }

    .backlink {
      position: fixed;
      bottom: 0.5rem;
      right: 0.5rem;
      font-size: 0.7rem;
      opacity: 0.4;
      z-index: 1000;
    }

    .backlink a {
      color: #00ffff;
      text-decoration: none;
    }

    @media (max-width: 600px) {
      .header h1 {
        font-size: 1rem;
      }

      .controls {
        top: auto;
        bottom: 6rem;
        right: 0.5rem;
      }

      .btn {
        padding: 0.5rem 0.8rem;
        font-size: 0.65rem;
      }

      .stats, .agent-info {
        display: none;
      }
    }
  </style>
</head>
<body>
  <div id="canvas-container"></div>

  <div class="ui-overlay header">
    <h1>ðŸ¤– AGENT MANAGER ðŸ¤–</h1>
  </div>

  <div class="ui-overlay controls">
    <button class="btn" id="addAgent">+ ADD AGENT</button>
    <button class="btn" id="connectAgents">CONNECT</button>
    <button class="btn btn-danger" id="removeAgent">- REMOVE</button>
  </div>

  <div class="ui-overlay legend">
    <div class="legend-item">
      <div class="legend-dot" style="background: #ff6b35; box-shadow: 0 0 5px #ff6b35;"></div>
      <span>Claude</span>
    </div>
    <div class="legend-item">
      <div class="legend-dot" style="background: #4285f4; box-shadow: 0 0 5px #4285f4;"></div>
      <span>Gemini</span>
    </div>
    <div class="legend-item">
      <div class="legend-dot" style="background: #00ff88; box-shadow: 0 0 5px #00ff88;"></div>
      <span>Codex</span>
    </div>
    <div class="legend-item">
      <div class="legend-dot" style="background: #ae53ff; box-shadow: 0 0 5px #ae53ff;"></div>
      <span>Cursor</span>
    </div>
  </div>

  <div class="ui-overlay stats">
    <h3>SYSTEM STATUS</h3>
    <div class="stat-row">
      <span>Total Agents</span>
      <span class="stat-value" id="totalAgents">0</span>
    </div>
    <div class="stat-row">
      <span>Active</span>
      <span class="stat-value" id="activeAgents">0</span>
    </div>
    <div class="stat-row">
      <span>Connections</span>
      <span class="stat-value" id="totalConnections">0</span>
    </div>
    <div class="stat-row">
      <span>Network Load</span>
      <span class="stat-value" id="networkLoad">0%</span>
    </div>
  </div>

  <div class="ui-overlay agent-info" id="agentInfo">
    <h3 id="agentName">AGENT-001</h3>
    <div class="agent-status status-active" id="agentStatus">ACTIVE</div>
    <div class="stat-row">
      <span>Type</span>
      <span class="stat-value" id="agentType">CLAUDE</span>
    </div>
    <div class="stat-row">
      <span>Tasks</span>
      <span class="stat-value" id="agentTasks">0</span>
    </div>
    <div class="stat-row">
      <span>Uptime</span>
      <span class="stat-value" id="agentUptime">0s</span>
    </div>
  </div>

  <div class="ui-overlay instructions">
    Drag to rotate â€¢ Scroll to zoom â€¢ Click agents to select
  </div>

  <div class="backlink"><a href="https://sloppy.live">sloppy.live</a></div>

  <script type="importmap">
  {
    "imports": {
      "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
      "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
    }
  }
  </script>

  <script type="module">
    import * as THREE from 'three';
    import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
    import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
    import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
    import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';

    // Scene setup
    const container = document.getElementById('canvas-container');
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x050510);
    scene.fog = new THREE.Fog(0x050510, 20, 60);

    const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.set(15, 12, 15);

    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    container.appendChild(renderer.domElement);

    // Post-processing for bloom/glow
    const composer = new EffectComposer(renderer);
    const renderPass = new RenderPass(scene, camera);
    composer.addPass(renderPass);

    const bloomPass = new UnrealBloomPass(
      new THREE.Vector2(window.innerWidth, window.innerHeight),
      1.2, 0.4, 0.85
    );
    composer.addPass(bloomPass);

    // Controls
    const controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;
    controls.dampingFactor = 0.05;
    controls.minDistance = 8;
    controls.maxDistance = 50;
    controls.maxPolarAngle = Math.PI / 2.2;

    // Terrain size
    const TERRAIN_SIZE = 40;
    const TERRAIN_SEGMENTS = 30;

    // Generate low-poly terrain
    function createTerrain() {
      const geometry = new THREE.PlaneGeometry(TERRAIN_SIZE, TERRAIN_SIZE, TERRAIN_SEGMENTS, TERRAIN_SEGMENTS);
      geometry.rotateX(-Math.PI / 2);

      const positions = geometry.attributes.position;
      const heightMap = [];

      for (let i = 0; i < positions.count; i++) {
        const x = positions.getX(i);
        const z = positions.getZ(i);
        // Simplex-like noise using sine waves
        let height = Math.sin(x * 0.3) * Math.cos(z * 0.3) * 1.5;
        height += Math.sin(x * 0.15 + 1) * Math.cos(z * 0.2 + 2) * 2;
        height += Math.random() * 0.3;
        positions.setY(i, height);
        heightMap.push(height);
      }

      geometry.computeVertexNormals();

      // Dark purple/blue terrain with neon edges
      const material = new THREE.MeshBasicMaterial({
        color: 0x1a0a2a,
        wireframe: false,
        side: THREE.DoubleSide
      });

      const terrain = new THREE.Mesh(geometry, material);
      scene.add(terrain);

      // Add wireframe overlay for neon effect
      const wireMaterial = new THREE.MeshBasicMaterial({
        color: 0x00ffff,
        wireframe: true,
        transparent: true,
        opacity: 0.15
      });
      const wireframe = new THREE.Mesh(geometry.clone(), wireMaterial);
      wireframe.position.y = 0.02;
      scene.add(wireframe);

      return { geometry, heightMap };
    }

    const terrainData = createTerrain();

    // Get terrain height at position
    function getTerrainHeight(x, z) {
      const halfSize = TERRAIN_SIZE / 2;
      const segSize = TERRAIN_SIZE / TERRAIN_SEGMENTS;

      const gridX = Math.floor((x + halfSize) / segSize);
      const gridZ = Math.floor((z + halfSize) / segSize);

      const idx = gridZ * (TERRAIN_SEGMENTS + 1) + gridX;
      if (idx >= 0 && idx < terrainData.heightMap.length) {
        return terrainData.heightMap[idx];
      }
      return 0;
    }

    // Create neon tree
    function createTree(x, z) {
      const group = new THREE.Group();
      const baseHeight = getTerrainHeight(x, z);

      // Tree trunk - simple cylinder
      const trunkGeo = new THREE.CylinderGeometry(0.1, 0.15, 1.5, 6);
      const trunkMat = new THREE.MeshBasicMaterial({ color: 0x4a2a6a });
      const trunk = new THREE.Mesh(trunkGeo, trunkMat);
      trunk.position.y = 0.75;
      group.add(trunk);

      // Neon color options
      const treeColors = [0x00ff88, 0xff00ff, 0x00ffff, 0xffee00];
      const color = treeColors[Math.floor(Math.random() * treeColors.length)];

      // Low-poly cone foliage layers
      for (let i = 0; i < 3; i++) {
        const coneGeo = new THREE.ConeGeometry(0.8 - i * 0.2, 1.2 - i * 0.2, 6);
        const coneMat = new THREE.MeshBasicMaterial({
          color: color,
          transparent: true,
          opacity: 0.7
        });
        const cone = new THREE.Mesh(coneGeo, coneMat);
        cone.position.y = 1.5 + i * 0.6;
        group.add(cone);
      }

      group.position.set(x, baseHeight, z);
      scene.add(group);
      return group;
    }

    // Create trees
    const trees = [];
    for (let i = 0; i < 25; i++) {
      const x = (Math.random() - 0.5) * (TERRAIN_SIZE - 5);
      const z = (Math.random() - 0.5) * (TERRAIN_SIZE - 5);
      trees.push(createTree(x, z));
    }

    // Agent data
    const agents = [];
    const connections = [];

    // AI Agent types with distinct colors
    const agentTypes = [
      { name: 'CLAUDE', color: 0xff6b35 },    // Orange (Anthropic)
      { name: 'GEMINI', color: 0x4285f4 },    // Blue (Google)
      { name: 'CODEX', color: 0x00ff88 },     // Green (OpenAI)
      { name: 'CURSOR', color: 0xae53ff }     // Purple (Cursor)
    ];

    const statuses = ['active', 'idle', 'error', 'processing'];

    let selectedAgent = null;
    let agentCounter = 0;

    // Create simple character unit
    function createAgent(x, z, forceType = null) {
      const agentType = forceType || agentTypes[Math.floor(Math.random() * agentTypes.length)];
      const color = agentType.color;
      const status = statuses[Math.floor(Math.random() * 3)];
      const baseHeight = getTerrainHeight(x, z);

      const group = new THREE.Group();

      // Body - low poly capsule shape
      const bodyGeo = new THREE.CapsuleGeometry(0.25, 0.5, 4, 6);
      const bodyMat = new THREE.MeshBasicMaterial({ color: color });
      const body = new THREE.Mesh(bodyGeo, bodyMat);
      body.position.y = 0.6;
      group.add(body);

      // Head - simple sphere
      const headGeo = new THREE.IcosahedronGeometry(0.2, 0);
      const headMat = new THREE.MeshBasicMaterial({ color: color });
      const head = new THREE.Mesh(headGeo, headMat);
      head.position.y = 1.2;
      group.add(head);

      // Glow ring around unit
      const ringGeo = new THREE.TorusGeometry(0.5, 0.03, 8, 16);
      const ringMat = new THREE.MeshBasicMaterial({
        color: color,
        transparent: true,
        opacity: 0.6
      });
      const ring = new THREE.Mesh(ringGeo, ringMat);
      ring.rotation.x = Math.PI / 2;
      ring.position.y = 0.1;
      group.add(ring);

      // Status indicator above head
      const indicatorGeo = new THREE.OctahedronGeometry(0.12, 0);
      const indicatorMat = new THREE.MeshBasicMaterial({ color: color });
      const indicator = new THREE.Mesh(indicatorGeo, indicatorMat);
      indicator.position.y = 1.6;
      group.add(indicator);

      group.position.set(x, baseHeight, z);
      scene.add(group);

      agentCounter++;
      const agent = {
        id: agentCounter,
        name: `${agentType.name}-${String(agentCounter).padStart(3, '0')}`,
        type: agentType.name,
        mesh: group,
        body: body,
        ring: ring,
        indicator: indicator,
        status: status,
        color: color,
        tasks: Math.floor(Math.random() * 100),
        uptime: Math.floor(Math.random() * 3600),
        connections: [],
        targetX: x,
        targetZ: z,
        walkSpeed: 0.02 + Math.random() * 0.02
      };

      agents.push(agent);
      updateStats();
      return agent;
    }

    // Create connection between agents
    function createConnection(agent1, agent2) {
      if (agent1.connections.includes(agent2.id) || agent1 === agent2) return;

      const material = new THREE.LineBasicMaterial({
        color: 0x00ffff,
        transparent: true,
        opacity: 0.4
      });

      const points = [
        new THREE.Vector3(agent1.mesh.position.x, agent1.mesh.position.y + 1, agent1.mesh.position.z),
        new THREE.Vector3(agent2.mesh.position.x, agent2.mesh.position.y + 1, agent2.mesh.position.z)
      ];
      const geometry = new THREE.BufferGeometry().setFromPoints(points);
      const line = new THREE.Line(geometry, material);

      scene.add(line);

      const connection = { line, agent1, agent2 };
      connections.push(connection);
      agent1.connections.push(agent2.id);
      agent2.connections.push(agent1.id);
      updateStats();
    }

    // Update connection lines to follow agents
    function updateConnections() {
      connections.forEach(conn => {
        const positions = conn.line.geometry.attributes.position;
        positions.setXYZ(0, conn.agent1.mesh.position.x, conn.agent1.mesh.position.y + 1, conn.agent1.mesh.position.z);
        positions.setXYZ(1, conn.agent2.mesh.position.x, conn.agent2.mesh.position.y + 1, conn.agent2.mesh.position.z);
        positions.needsUpdate = true;
      });
    }

    // Remove agent
    function removeAgent(agent) {
      for (let i = connections.length - 1; i >= 0; i--) {
        const conn = connections[i];
        if (conn.agent1 === agent || conn.agent2 === agent) {
          scene.remove(conn.line);
          connections.splice(i, 1);
        }
      }

      agents.forEach(a => {
        a.connections = a.connections.filter(id => id !== agent.id);
      });

      scene.remove(agent.mesh);
      const idx = agents.indexOf(agent);
      if (idx > -1) agents.splice(idx, 1);

      if (selectedAgent === agent) {
        selectedAgent = null;
        document.getElementById('agentInfo').classList.remove('visible');
      }
      updateStats();
    }

    // Update stats display
    function updateStats() {
      document.getElementById('totalAgents').textContent = agents.length;
      document.getElementById('activeAgents').textContent = agents.filter(a => a.status === 'active').length;
      document.getElementById('totalConnections').textContent = connections.length;
      document.getElementById('networkLoad').textContent = Math.min(100, Math.floor((connections.length / Math.max(1, agents.length)) * 50)) + '%';
    }

    // Select agent
    function selectAgent(agent) {
      if (selectedAgent) {
        selectedAgent.mesh.scale.set(1, 1, 1);
      }

      selectedAgent = agent;
      agent.mesh.scale.set(1.3, 1.3, 1.3);

      const info = document.getElementById('agentInfo');
      info.classList.add('visible');
      document.getElementById('agentName').textContent = agent.name;

      const statusEl = document.getElementById('agentStatus');
      statusEl.textContent = agent.status.toUpperCase();
      statusEl.className = 'agent-status status-' + agent.status;

      document.getElementById('agentType').textContent = agent.type;
      document.getElementById('agentTasks').textContent = agent.tasks;
      document.getElementById('agentUptime').textContent = formatTime(agent.uptime);
    }

    function formatTime(seconds) {
      if (seconds < 60) return seconds + 's';
      if (seconds < 3600) return Math.floor(seconds / 60) + 'm';
      return Math.floor(seconds / 3600) + 'h';
    }

    // Raycaster for clicking
    const raycaster = new THREE.Raycaster();
    const mouse = new THREE.Vector2();

    renderer.domElement.addEventListener('click', (event) => {
      mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
      mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

      raycaster.setFromCamera(mouse, camera);
      const meshes = agents.map(a => a.body);
      const intersects = raycaster.intersectObjects(meshes);

      if (intersects.length > 0) {
        const clickedMesh = intersects[0].object;
        const agent = agents.find(a => a.body === clickedMesh);
        if (agent) selectAgent(agent);
      }
    });

    // UI button handlers
    document.getElementById('addAgent').addEventListener('click', () => {
      const x = (Math.random() - 0.5) * (TERRAIN_SIZE - 5);
      const z = (Math.random() - 0.5) * (TERRAIN_SIZE - 5);
      const agent = createAgent(x, z);
      selectAgent(agent);
    });

    document.getElementById('connectAgents').addEventListener('click', () => {
      if (agents.length < 2) return;

      if (selectedAgent) {
        const others = agents.filter(a => a !== selectedAgent && !selectedAgent.connections.includes(a.id));
        if (others.length > 0) {
          const target = others[Math.floor(Math.random() * others.length)];
          createConnection(selectedAgent, target);
        }
      } else {
        const a1 = agents[Math.floor(Math.random() * agents.length)];
        const others = agents.filter(a => a !== a1 && !a1.connections.includes(a.id));
        if (others.length > 0) {
          const a2 = others[Math.floor(Math.random() * others.length)];
          createConnection(a1, a2);
        }
      }
    });

    document.getElementById('removeAgent').addEventListener('click', () => {
      if (selectedAgent) {
        removeAgent(selectedAgent);
      } else if (agents.length > 0) {
        removeAgent(agents[agents.length - 1]);
      }
    });

    // Animation loop
    function animate() {
      requestAnimationFrame(animate);

      const time = Date.now() * 0.001;

      // Animate agents
      agents.forEach((agent, i) => {
        // Ring rotation
        agent.ring.rotation.z += 0.03;

        // Indicator bobbing
        agent.indicator.rotation.y += 0.05;
        agent.indicator.position.y = 1.6 + Math.sin(time * 3 + i) * 0.1;

        // Random walking
        if (Math.random() < 0.01) {
          agent.targetX = (Math.random() - 0.5) * (TERRAIN_SIZE - 8);
          agent.targetZ = (Math.random() - 0.5) * (TERRAIN_SIZE - 8);
        }

        // Move toward target
        const dx = agent.targetX - agent.mesh.position.x;
        const dz = agent.targetZ - agent.mesh.position.z;
        const dist = Math.sqrt(dx * dx + dz * dz);

        if (dist > 0.5) {
          agent.mesh.position.x += (dx / dist) * agent.walkSpeed;
          agent.mesh.position.z += (dz / dist) * agent.walkSpeed;

          // Update Y to follow terrain
          agent.mesh.position.y = getTerrainHeight(agent.mesh.position.x, agent.mesh.position.z);

          // Face direction of movement
          agent.mesh.rotation.y = Math.atan2(dx, dz);

          // Walking bob
          agent.body.position.y = 0.6 + Math.abs(Math.sin(time * 10)) * 0.08;
        }
      });

      // Update connection lines
      updateConnections();

      // Pulse connections
      connections.forEach((conn, i) => {
        const pulse = (Math.sin(time * 3 + i) + 1) / 2;
        conn.line.material.opacity = 0.2 + pulse * 0.4;
      });

      // Animate trees slightly
      trees.forEach((tree, i) => {
        tree.rotation.y = Math.sin(time * 0.5 + i) * 0.05;
      });

      controls.update();
      composer.render();
    }

    // Initialize with some agents
    for (let i = 0; i < 5; i++) {
      const x = (Math.random() - 0.5) * 15;
      const z = (Math.random() - 0.5) * 15;
      createAgent(x, z);
    }

    // Create some initial connections
    if (agents.length >= 2) {
      createConnection(agents[0], agents[1]);
      if (agents.length >= 3) createConnection(agents[1], agents[2]);
      if (agents.length >= 4) createConnection(agents[2], agents[3]);
    }

    // Handle resize
    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
      composer.setSize(window.innerWidth, window.innerHeight);
    });

    animate();
  </script>
</body>
</html>
