<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
  <title>Robo Arm</title>
  <link rel="icon" href="https://emojicdn.elk.sh/ü¶æ">
  <meta property="og:title" content="Robo Arm">
  <meta property="og:description" content="Control a robotic arm to grab and toss glowing cubes!">
  <meta property="og:url" content="https://sloppy.live/robo-arm">
  <meta property="og:image" content="https://emojicdn.elk.sh/ü¶æ?style=google">
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link href="https://fonts.googleapis.com/css2?family=Exo+2:wght@400;700;900&display=swap" rel="stylesheet">
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }

    body {
      min-height: 100vh;
      background: #0a0a14;
      overflow: hidden;
      font-family: 'Exo 2', sans-serif;
    }

    canvas {
      display: block;
      cursor: crosshair;
    }

    .ui {
      position: fixed;
      top: 20px;
      left: 20px;
      z-index: 10;
      pointer-events: none;
    }

    .title {
      font-size: 28px;
      font-weight: 900;
      color: #00ffff;
      text-shadow: 0 0 20px #00ffff, 0 0 40px #00ffff;
      letter-spacing: 3px;
      margin-bottom: 10px;
    }

    .instructions {
      font-size: 12px;
      color: #666;
      line-height: 1.8;
    }

    .instructions span {
      color: #ff00ff;
    }

    .stats {
      position: fixed;
      top: 20px;
      right: 20px;
      text-align: right;
      font-size: 14px;
      color: #39ff14;
      text-shadow: 0 0 10px #39ff14;
    }

    .controls {
      position: fixed;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      display: flex;
      gap: 15px;
      z-index: 10;
    }

    .btn {
      background: rgba(255, 0, 255, 0.2);
      border: 2px solid #ff00ff;
      padding: 12px 25px;
      font-family: 'Exo 2', sans-serif;
      font-size: 14px;
      font-weight: 700;
      color: #ff00ff;
      border-radius: 8px;
      cursor: pointer;
      transition: all 0.2s;
      text-shadow: 0 0 10px #ff00ff;
    }

    .btn:hover {
      background: rgba(255, 0, 255, 0.4);
      box-shadow: 0 0 20px rgba(255, 0, 255, 0.5);
    }

    .btn:active {
      transform: scale(0.95);
    }

    .btn.cyan {
      border-color: #00ffff;
      color: #00ffff;
      background: rgba(0, 255, 255, 0.2);
      text-shadow: 0 0 10px #00ffff;
    }

    .btn.cyan:hover {
      background: rgba(0, 255, 255, 0.4);
      box-shadow: 0 0 20px rgba(0, 255, 255, 0.5);
    }

    .grab-indicator {
      position: fixed;
      bottom: 80px;
      left: 50%;
      transform: translateX(-50%);
      font-size: 16px;
      font-weight: 700;
      color: #39ff14;
      text-shadow: 0 0 15px #39ff14;
      opacity: 0;
      transition: opacity 0.2s;
    }

    .grab-indicator.active {
      opacity: 1;
      animation: pulse 0.3s ease-in-out infinite;
    }

    @keyframes pulse {
      0%, 100% { transform: translateX(-50%) scale(1); }
      50% { transform: translateX(-50%) scale(1.1); }
    }

    .back-link {
      position: fixed;
      bottom: 20px;
      left: 20px;
      color: #333;
      text-decoration: none;
      font-size: 11px;
      z-index: 10;
      transition: color 0.2s;
    }

    .back-link:hover {
      color: #00ffff;
    }

    @media (max-width: 600px) {
      .instructions { display: none; }
      .title { font-size: 20px; }
      .controls { bottom: 15px; gap: 10px; }
      .btn { padding: 10px 18px; font-size: 12px; }
    }
  </style>
</head>
<body>
  <canvas id="game"></canvas>

  <div class="ui">
    <div class="title">ROBO ARM</div>
    <div class="instructions">
      <span>MOVE</span> mouse to control arm<br>
      <span>HOLD CLICK</span> to grab cubes<br>
      <span>RELEASE</span> to toss!
    </div>
  </div>

  <div class="stats">
    <div id="cubeCount">CUBES: 0</div>
    <div id="grabbed">-</div>
  </div>

  <div class="grab-indicator" id="grabIndicator">GRABBING!</div>

  <div class="controls">
    <button class="btn cyan" id="spawnBtn">+ SPAWN CUBE</button>
    <button class="btn" id="clearBtn">CLEAR ALL</button>
  </div>

  <a href="https://sloppy.live" class="back-link">‚Üê sloppy.live</a>

  <script>
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');

    let width, height;
    let mouseX = 0, mouseY = 0;
    let isGrabbing = false;
    let grabbedCube = null;

    // Arm configuration
    const arm = {
      baseX: 0,
      baseY: 0,
      segments: [
        { length: 120, angle: -Math.PI / 2, width: 30 },
        { length: 100, angle: 0, width: 24 },
        { length: 80, angle: 0, width: 18 }
      ],
      clawOpen: 1,
      clawSize: 40
    };

    // Physics cubes
    let cubes = [];
    const GRAVITY = 0.4;
    const FRICTION = 0.99;
    const BOUNCE = 0.7;

    // Cube colors
    const CUBE_COLORS = [
      { fill: '#ff00ff', glow: 'rgba(255, 0, 255, 0.6)' },
      { fill: '#00ffff', glow: 'rgba(0, 255, 255, 0.6)' },
      { fill: '#ffff00', glow: 'rgba(255, 255, 0, 0.6)' },
      { fill: '#39ff14', glow: 'rgba(57, 255, 20, 0.6)' },
      { fill: '#ff6600', glow: 'rgba(255, 102, 0, 0.6)' },
      { fill: '#ff0066', glow: 'rgba(255, 0, 102, 0.6)' }
    ];

    class Cube {
      constructor(x, y) {
        this.x = x;
        this.y = y;
        this.vx = (Math.random() - 0.5) * 5;
        this.vy = 0;
        this.size = 35 + Math.random() * 20;
        this.rotation = Math.random() * Math.PI * 2;
        this.rotationSpeed = (Math.random() - 0.5) * 0.1;
        this.color = CUBE_COLORS[Math.floor(Math.random() * CUBE_COLORS.length)];
        this.grabbed = false;
        this.pulsePhase = Math.random() * Math.PI * 2;
      }

      update() {
        if (this.grabbed) {
          this.rotationSpeed *= 0.9;
          return;
        }

        // Apply gravity
        this.vy += GRAVITY;

        // Apply velocity
        this.x += this.vx;
        this.y += this.vy;

        // Friction
        this.vx *= FRICTION;

        // Rotation
        this.rotation += this.rotationSpeed;
        this.rotationSpeed *= 0.995;

        // Floor collision
        if (this.y + this.size / 2 > height - 50) {
          this.y = height - 50 - this.size / 2;
          this.vy *= -BOUNCE;
          this.rotationSpeed += this.vx * 0.01;
          if (Math.abs(this.vy) < 1) this.vy = 0;
        }

        // Wall collisions
        if (this.x - this.size / 2 < 0) {
          this.x = this.size / 2;
          this.vx *= -BOUNCE;
        }
        if (this.x + this.size / 2 > width) {
          this.x = width - this.size / 2;
          this.vx *= -BOUNCE;
        }

        // Ceiling
        if (this.y - this.size / 2 < 0) {
          this.y = this.size / 2;
          this.vy *= -BOUNCE;
        }

        // Cube-cube collision
        for (const other of cubes) {
          if (other === this || other.grabbed) continue;
          const dx = other.x - this.x;
          const dy = other.y - this.y;
          const dist = Math.sqrt(dx * dx + dy * dy);
          const minDist = (this.size + other.size) / 2;

          if (dist < minDist && dist > 0) {
            const overlap = minDist - dist;
            const nx = dx / dist;
            const ny = dy / dist;

            // Separate
            this.x -= nx * overlap / 2;
            this.y -= ny * overlap / 2;
            other.x += nx * overlap / 2;
            other.y += ny * overlap / 2;

            // Bounce
            const dvx = this.vx - other.vx;
            const dvy = this.vy - other.vy;
            const dvn = dvx * nx + dvy * ny;

            if (dvn > 0) {
              this.vx -= dvn * nx * 0.5;
              this.vy -= dvn * ny * 0.5;
              other.vx += dvn * nx * 0.5;
              other.vy += dvn * ny * 0.5;
            }
          }
        }

        this.pulsePhase += 0.1;
      }

      draw() {
        ctx.save();
        ctx.translate(this.x, this.y);
        ctx.rotate(this.rotation);

        const pulse = Math.sin(this.pulsePhase) * 0.15 + 0.85;
        const glowSize = this.grabbed ? 40 : 25 * pulse;

        // Glow
        ctx.shadowColor = this.color.fill;
        ctx.shadowBlur = glowSize;

        // Cube body
        ctx.fillStyle = this.color.fill;
        ctx.fillRect(-this.size / 2, -this.size / 2, this.size, this.size);

        // Border
        ctx.strokeStyle = '#fff';
        ctx.lineWidth = 2;
        ctx.strokeRect(-this.size / 2, -this.size / 2, this.size, this.size);

        // Inner highlight
        ctx.fillStyle = 'rgba(255, 255, 255, 0.3)';
        ctx.fillRect(-this.size / 2 + 5, -this.size / 2 + 5, this.size / 3, this.size / 3);

        ctx.restore();
      }
    }

    function resize() {
      width = canvas.width = window.innerWidth;
      height = canvas.height = window.innerHeight;
      arm.baseX = width / 2;
      arm.baseY = height - 50;
    }

    function getArmEndpoint() {
      let x = arm.baseX;
      let y = arm.baseY;
      let totalAngle = 0;

      for (const seg of arm.segments) {
        totalAngle += seg.angle;
        x += Math.cos(totalAngle) * seg.length;
        y += Math.sin(totalAngle) * seg.length;
      }

      return { x, y, angle: totalAngle };
    }

    function solveIK(targetX, targetY) {
      // Simple FABRIK-inspired IK solver
      const maxIterations = 10;
      const tolerance = 5;

      for (let iter = 0; iter < maxIterations; iter++) {
        // Forward pass - calculate current endpoint
        let points = [{ x: arm.baseX, y: arm.baseY }];
        let totalAngle = 0;

        for (const seg of arm.segments) {
          totalAngle += seg.angle;
          const last = points[points.length - 1];
          points.push({
            x: last.x + Math.cos(totalAngle) * seg.length,
            y: last.y + Math.sin(totalAngle) * seg.length
          });
        }

        const endpoint = points[points.length - 1];
        const dx = targetX - endpoint.x;
        const dy = targetY - endpoint.y;
        const dist = Math.sqrt(dx * dx + dy * dy);

        if (dist < tolerance) break;

        // Backward pass - adjust from target
        points[points.length - 1] = { x: targetX, y: targetY };

        for (let i = points.length - 2; i >= 0; i--) {
          const curr = points[i];
          const next = points[i + 1];
          const segLength = arm.segments[i] ? arm.segments[i].length : arm.segments[i - 1].length;

          const angle = Math.atan2(curr.y - next.y, curr.x - next.x);
          points[i] = {
            x: next.x + Math.cos(angle) * segLength,
            y: next.y + Math.sin(angle) * segLength
          };
        }

        // Forward pass - constrain to base
        points[0] = { x: arm.baseX, y: arm.baseY };

        for (let i = 0; i < arm.segments.length; i++) {
          const curr = points[i];
          const next = points[i + 1];
          const segLength = arm.segments[i].length;

          const angle = Math.atan2(next.y - curr.y, next.x - curr.x);
          points[i + 1] = {
            x: curr.x + Math.cos(angle) * segLength,
            y: curr.y + Math.sin(angle) * segLength
          };
        }

        // Calculate new angles
        let prevAngle = 0;
        for (let i = 0; i < arm.segments.length; i++) {
          const curr = points[i];
          const next = points[i + 1];
          const angle = Math.atan2(next.y - curr.y, next.x - curr.x);

          // Smooth angle transition
          const targetAngle = angle - prevAngle;
          arm.segments[i].angle += (targetAngle - arm.segments[i].angle) * 0.3;

          prevAngle = angle;
        }
      }
    }

    function drawArm() {
      let x = arm.baseX;
      let y = arm.baseY;
      let totalAngle = 0;

      // Draw base
      ctx.fillStyle = '#333';
      ctx.shadowColor = '#00ffff';
      ctx.shadowBlur = 20;
      ctx.beginPath();
      ctx.arc(arm.baseX, arm.baseY, 40, 0, Math.PI * 2);
      ctx.fill();

      ctx.fillStyle = '#00ffff';
      ctx.beginPath();
      ctx.arc(arm.baseX, arm.baseY, 25, 0, Math.PI * 2);
      ctx.fill();

      ctx.shadowBlur = 0;

      // Draw segments
      for (let i = 0; i < arm.segments.length; i++) {
        const seg = arm.segments[i];
        totalAngle += seg.angle;

        const endX = x + Math.cos(totalAngle) * seg.length;
        const endY = y + Math.sin(totalAngle) * seg.length;

        // Segment body
        ctx.save();
        ctx.translate(x, y);
        ctx.rotate(totalAngle);

        // Arm segment
        const gradient = ctx.createLinearGradient(0, -seg.width / 2, 0, seg.width / 2);
        gradient.addColorStop(0, '#444');
        gradient.addColorStop(0.5, '#666');
        gradient.addColorStop(1, '#333');

        ctx.fillStyle = gradient;
        ctx.shadowColor = '#00ffff';
        ctx.shadowBlur = 10;

        ctx.beginPath();
        ctx.roundRect(0, -seg.width / 2, seg.length, seg.width, 5);
        ctx.fill();

        // Segment glow line
        ctx.strokeStyle = '#00ffff';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(10, 0);
        ctx.lineTo(seg.length - 10, 0);
        ctx.stroke();

        ctx.restore();

        // Joint
        ctx.fillStyle = '#00ffff';
        ctx.shadowColor = '#00ffff';
        ctx.shadowBlur = 15;
        ctx.beginPath();
        ctx.arc(endX, endY, seg.width / 3, 0, Math.PI * 2);
        ctx.fill();

        x = endX;
        y = endY;
      }

      // Draw claw
      const clawAngle = totalAngle;
      const clawOpen = isGrabbing ? 0.2 : 0.6;

      ctx.save();
      ctx.translate(x, y);
      ctx.rotate(clawAngle);

      // Claw arms
      ctx.strokeStyle = '#ff00ff';
      ctx.lineWidth = 8;
      ctx.lineCap = 'round';
      ctx.shadowColor = '#ff00ff';
      ctx.shadowBlur = 15;

      // Left claw
      ctx.beginPath();
      ctx.moveTo(0, 0);
      ctx.lineTo(arm.clawSize * Math.cos(-clawOpen), arm.clawSize * Math.sin(-clawOpen));
      ctx.stroke();

      // Right claw
      ctx.beginPath();
      ctx.moveTo(0, 0);
      ctx.lineTo(arm.clawSize * Math.cos(clawOpen), arm.clawSize * Math.sin(clawOpen));
      ctx.stroke();

      // Claw tips
      ctx.fillStyle = '#ff00ff';
      ctx.beginPath();
      ctx.arc(arm.clawSize * Math.cos(-clawOpen), arm.clawSize * Math.sin(-clawOpen), 6, 0, Math.PI * 2);
      ctx.arc(arm.clawSize * Math.cos(clawOpen), arm.clawSize * Math.sin(clawOpen), 6, 0, Math.PI * 2);
      ctx.fill();

      ctx.restore();

      ctx.shadowBlur = 0;
    }

    function drawFloor() {
      // Floor
      ctx.fillStyle = '#1a1a2e';
      ctx.fillRect(0, height - 50, width, 50);

      // Floor glow line
      ctx.strokeStyle = '#ff00ff';
      ctx.lineWidth = 3;
      ctx.shadowColor = '#ff00ff';
      ctx.shadowBlur = 20;
      ctx.beginPath();
      ctx.moveTo(0, height - 50);
      ctx.lineTo(width, height - 50);
      ctx.stroke();

      // Grid lines on floor
      ctx.strokeStyle = 'rgba(255, 0, 255, 0.2)';
      ctx.lineWidth = 1;
      ctx.shadowBlur = 0;
      for (let x = 0; x < width; x += 50) {
        ctx.beginPath();
        ctx.moveTo(x, height - 50);
        ctx.lineTo(x, height);
        ctx.stroke();
      }
    }

    function drawBackground() {
      // Dark gradient
      const gradient = ctx.createRadialGradient(width / 2, height / 2, 0, width / 2, height / 2, Math.max(width, height));
      gradient.addColorStop(0, '#12121f');
      gradient.addColorStop(1, '#0a0a14');
      ctx.fillStyle = gradient;
      ctx.fillRect(0, 0, width, height);

      // Grid
      ctx.strokeStyle = 'rgba(0, 255, 255, 0.05)';
      ctx.lineWidth = 1;
      for (let x = 0; x < width; x += 60) {
        ctx.beginPath();
        ctx.moveTo(x, 0);
        ctx.lineTo(x, height);
        ctx.stroke();
      }
      for (let y = 0; y < height; y += 60) {
        ctx.beginPath();
        ctx.moveTo(0, y);
        ctx.lineTo(width, y);
        ctx.stroke();
      }
    }

    function spawnCube() {
      const x = Math.random() * (width - 200) + 100;
      const y = 100;
      cubes.push(new Cube(x, y));
      updateStats();
    }

    function clearCubes() {
      cubes = [];
      grabbedCube = null;
      updateStats();
    }

    function updateStats() {
      document.getElementById('cubeCount').textContent = `CUBES: ${cubes.length}`;
    }

    function checkGrab() {
      if (!isGrabbing || grabbedCube) return;

      const endpoint = getArmEndpoint();

      for (const cube of cubes) {
        const dx = cube.x - endpoint.x;
        const dy = cube.y - endpoint.y;
        const dist = Math.sqrt(dx * dx + dy * dy);

        if (dist < cube.size / 2 + arm.clawSize) {
          grabbedCube = cube;
          cube.grabbed = true;
          document.getElementById('grabbed').textContent = 'HOLDING';
          document.getElementById('grabIndicator').classList.add('active');
          break;
        }
      }
    }

    function releaseGrab() {
      if (grabbedCube) {
        grabbedCube.grabbed = false;

        // Calculate throw velocity based on arm movement
        const endpoint = getArmEndpoint();
        grabbedCube.vx = (mouseX - grabbedCube.x) * 0.15;
        grabbedCube.vy = (mouseY - grabbedCube.y) * 0.15;
        grabbedCube.rotationSpeed = grabbedCube.vx * 0.05;

        grabbedCube = null;
        document.getElementById('grabbed').textContent = '-';
        document.getElementById('grabIndicator').classList.remove('active');
      }
    }

    let lastMouseX = 0, lastMouseY = 0;

    function update() {
      // Solve IK for mouse position
      solveIK(mouseX, mouseY);

      // Update grabbed cube position
      if (grabbedCube) {
        const endpoint = getArmEndpoint();
        grabbedCube.x = endpoint.x;
        grabbedCube.y = endpoint.y;
      }

      // Check for grab
      checkGrab();

      // Update all cubes
      for (const cube of cubes) {
        cube.update();
      }

      // Store mouse velocity
      lastMouseX = mouseX;
      lastMouseY = mouseY;
    }

    function draw() {
      drawBackground();
      drawFloor();

      // Draw cubes behind arm
      for (const cube of cubes) {
        if (!cube.grabbed) cube.draw();
      }

      drawArm();

      // Draw grabbed cube on top
      if (grabbedCube) {
        grabbedCube.draw();
      }
    }

    function gameLoop() {
      update();
      draw();
      requestAnimationFrame(gameLoop);
    }

    // Event listeners
    function handleMove(x, y) {
      mouseX = x;
      mouseY = y;
    }

    canvas.addEventListener('mousemove', (e) => {
      handleMove(e.clientX, e.clientY);
    });

    canvas.addEventListener('touchmove', (e) => {
      e.preventDefault();
      const touch = e.touches[0];
      handleMove(touch.clientX, touch.clientY);
    }, { passive: false });

    canvas.addEventListener('mousedown', () => {
      isGrabbing = true;
    });

    canvas.addEventListener('mouseup', () => {
      isGrabbing = false;
      releaseGrab();
    });

    canvas.addEventListener('touchstart', (e) => {
      e.preventDefault();
      isGrabbing = true;
      const touch = e.touches[0];
      handleMove(touch.clientX, touch.clientY);
    }, { passive: false });

    canvas.addEventListener('touchend', () => {
      isGrabbing = false;
      releaseGrab();
    });

    document.getElementById('spawnBtn').addEventListener('click', spawnCube);
    document.getElementById('clearBtn').addEventListener('click', clearCubes);

    // Keyboard shortcuts
    document.addEventListener('keydown', (e) => {
      if (e.code === 'Space') {
        e.preventDefault();
        spawnCube();
      }
      if (e.code === 'KeyC') {
        clearCubes();
      }
    });

    // Prevent context menu on long press
    canvas.addEventListener('contextmenu', (e) => e.preventDefault());

    // Initialize
    resize();
    window.addEventListener('resize', resize);

    // Spawn some initial cubes
    for (let i = 0; i < 5; i++) {
      setTimeout(() => spawnCube(), i * 200);
    }

    gameLoop();
  </script>
</body>
</html>
