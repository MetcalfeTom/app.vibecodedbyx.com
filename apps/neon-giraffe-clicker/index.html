<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Neon Giraffe Clicker</title>
  <meta name="description" content="Click the giraffe. Hear the fart. Buy the hats.">
  <meta property="og:title" content="Neon Giraffe Clicker">
  <meta property="og:description" content="Click the giraffe. Hear the fart. Buy the hats.">
  <meta property="og:url" content="https://app.sloppy.live/neon-giraffe-clicker/">
  <meta property="og:image" content="https://emojicdn.elk.sh/ü¶í">
  <link rel="icon" href="https://emojicdn.elk.sh/ü¶í">
  <style>
    @import url('https://fonts.googleapis.com/css2?family=Bangers&display=swap');

    * { margin: 0; padding: 0; box-sizing: border-box; }

    body {
      background: linear-gradient(135deg, #0a0a1a 0%, #1a0a2e 50%, #0a1a1a 100%);
      min-height: 100vh;
      font-family: 'Bangers', cursive;
      overflow: hidden;
      display: flex;
      flex-direction: column;
      align-items: center;
      color: #fff;
    }

    h1 {
      font-size: clamp(24px, 6vw, 48px);
      color: #ffff00;
      text-shadow: 0 0 20px #ffff00, 0 0 40px #ff00ff;
      margin: 20px 0 10px;
      letter-spacing: 4px;
    }

    #stats {
      display: flex;
      gap: 30px;
      margin-bottom: 10px;
      font-size: clamp(16px, 4vw, 24px);
    }

    #clicks {
      color: #00ffff;
      text-shadow: 0 0 10px #00ffff;
    }

    #cps {
      color: #ff00ff;
      text-shadow: 0 0 10px #ff00ff;
    }

    #game-area {
      flex: 1;
      display: flex;
      align-items: center;
      justify-content: center;
      position: relative;
      width: 100%;
      max-width: 600px;
    }

    #giraffe-container {
      position: relative;
      cursor: pointer;
      transition: transform 0.1s;
      user-select: none;
      -webkit-tap-highlight-color: transparent;
    }

    #giraffe-container:active {
      transform: scale(0.95);
    }

    #giraffe-canvas {
      display: block;
    }

    #click-text {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      font-size: clamp(20px, 5vw, 32px);
      color: #00ff00;
      text-shadow: 0 0 20px #00ff00, 0 0 40px #00ff00;
      pointer-events: none;
      opacity: 0;
      white-space: nowrap;
      z-index: 100;
    }

    #health-bar-container {
      width: 200px;
      height: 20px;
      background: #1a0a2a;
      border: 2px solid #ff00ff;
      border-radius: 10px;
      overflow: hidden;
      margin-bottom: 10px;
      box-shadow: 0 0 15px rgba(255, 0, 255, 0.3);
    }

    #health-bar {
      height: 100%;
      width: 100%;
      background: linear-gradient(90deg, #ff0000, #ff6600, #00ff00);
      transition: width 0.2s;
    }

    #health-label {
      font-size: 14px;
      color: #ff6600;
      text-shadow: 0 0 10px #ff6600;
      margin-bottom: 5px;
    }

    #explosion-text {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      font-size: clamp(28px, 7vw, 48px);
      color: #ff0000;
      text-shadow: 0 0 30px #ff0000, 0 0 60px #ff6600;
      pointer-events: none;
      opacity: 0;
      white-space: nowrap;
      z-index: 200;
    }

    #explosion-text.show {
      animation: explosionPop 2s ease-out forwards;
    }

    @keyframes explosionPop {
      0% { opacity: 1; transform: translate(-50%, -50%) scale(0.5); }
      20% { opacity: 1; transform: translate(-50%, -50%) scale(1.5); }
      100% { opacity: 0; transform: translate(-50%, -50%) scale(2); }
    }

    #click-text.show {
      animation: clickPop 0.6s ease-out forwards;
    }

    @keyframes clickPop {
      0% { opacity: 1; transform: translate(-50%, -50%) scale(0.5); }
      50% { opacity: 1; transform: translate(-50%, -70%) scale(1.2); }
      100% { opacity: 0; transform: translate(-50%, -100%) scale(1); }
    }

    #upgrades {
      position: fixed;
      right: 10px;
      top: 50%;
      transform: translateY(-50%);
      display: flex;
      flex-direction: column;
      gap: 10px;
      z-index: 50;
    }

    .upgrade-btn {
      background: linear-gradient(180deg, #2a0a4a, #1a0a2a);
      border: 2px solid #ff00ff;
      border-radius: 10px;
      padding: 10px 15px;
      color: #fff;
      font-family: 'Bangers', cursive;
      font-size: clamp(12px, 2.5vw, 16px);
      cursor: pointer;
      text-align: left;
      min-width: 140px;
      transition: all 0.2s;
      box-shadow: 0 0 15px rgba(255, 0, 255, 0.3);
    }

    .upgrade-btn:hover:not(:disabled) {
      background: linear-gradient(180deg, #4a1a6a, #2a0a4a);
      box-shadow: 0 0 25px rgba(255, 0, 255, 0.6);
      transform: scale(1.05);
    }

    .upgrade-btn:disabled {
      opacity: 0.5;
      cursor: not-allowed;
      border-color: #666;
    }

    .upgrade-btn .name {
      display: block;
      color: #ffff00;
      font-size: 1.1em;
    }

    .upgrade-btn .cost {
      color: #00ffff;
      font-size: 0.9em;
    }

    .upgrade-btn .owned {
      color: #00ff00;
      font-size: 0.85em;
    }

    #fart-particles {
      position: absolute;
      pointer-events: none;
      width: 100%;
      height: 100%;
      top: 0;
      left: 0;
    }

    #backlink {
      position: fixed;
      bottom: 10px;
      left: 10px;
      z-index: 100;
    }

    #backlink a {
      color: #ff00ff;
      text-decoration: none;
      font-size: 14px;
      opacity: 0.7;
    }

    @media (max-width: 600px) {
      #upgrades {
        position: fixed;
        right: auto;
        left: 50%;
        top: auto;
        bottom: 10px;
        transform: translateX(-50%);
        flex-direction: row;
        flex-wrap: wrap;
        justify-content: center;
        gap: 8px;
        width: 95%;
      }

      .upgrade-btn {
        min-width: 100px;
        padding: 8px 10px;
        font-size: 11px;
      }
    }
  </style>
</head>
<body>
  <h1>ü¶í NEON GIRAFFE CLICKER ü¶í</h1>

  <div id="stats">
    <span id="clicks">CLICKS: 0</span>
    <span id="cps">+0/sec</span>
  </div>

  <div id="health-label">üí® FART HEALTH üí®</div>
  <div id="health-bar-container">
    <div id="health-bar"></div>
  </div>

  <div id="game-area">
    <div id="giraffe-container" onclick="clickGiraffe(event)">
      <canvas id="giraffe-canvas" width="300" height="400"></canvas>
      <canvas id="fart-particles" width="300" height="400"></canvas>
      <div id="click-text">YOU CLICKED THE GIRAFFE!</div>
      <div id="explosion-text">üíÄ GIRAFFE EXPLODED! üíÄ</div>
    </div>
  </div>

  <div id="upgrades">
    <button class="upgrade-btn" onclick="buyUpgrade('head')" id="btn-head">
      <span class="name">ü¶í Extra Head</span>
      <span class="cost">Cost: 50</span>
      <span class="owned">Owned: 0</span>
    </button>
    <button class="upgrade-btn" onclick="buyUpgrade('tophat')" id="btn-tophat">
      <span class="name">üé© Top Hat</span>
      <span class="cost">Cost: 100</span>
      <span class="owned">Owned: 0</span>
    </button>
    <button class="upgrade-btn" onclick="buyUpgrade('partyhat')" id="btn-partyhat">
      <span class="name">üéâ Party Hat</span>
      <span class="cost">Cost: 200</span>
      <span class="owned">Owned: 0</span>
    </button>
    <button class="upgrade-btn" onclick="buyUpgrade('crown')" id="btn-crown">
      <span class="name">üëë Crown</span>
      <span class="cost">Cost: 500</span>
      <span class="owned">Owned: 0</span>
    </button>
    <button class="upgrade-btn" onclick="buyUpgrade('viking')" id="btn-viking">
      <span class="name">‚öîÔ∏è Viking Helmet</span>
      <span class="cost">Cost: 350</span>
      <span class="owned">Owned: 0</span>
    </button>
    <button class="upgrade-btn" onclick="buyUpgrade('beret')" id="btn-beret">
      <span class="name">üé® Beret</span>
      <span class="cost">Cost: 150</span>
      <span class="owned">Owned: 0</span>
    </button>
    <button class="upgrade-btn" onclick="buyUpgrade('propeller')" id="btn-propeller">
      <span class="name">üöÅ Propeller Hat</span>
      <span class="cost">Cost: 400</span>
      <span class="owned">Owned: 0</span>
    </button>
    <button class="upgrade-btn" onclick="buyUpgrade('wizard')" id="btn-wizard">
      <span class="name">üßô Wizard Hat</span>
      <span class="cost">Cost: 600</span>
      <span class="owned">Owned: 0</span>
    </button>
    <button class="upgrade-btn" onclick="buyUpgrade('sombrero')" id="btn-sombrero">
      <span class="name">üíÉ Sombrero</span>
      <span class="cost">Cost: 450</span>
      <span class="owned">Owned: 0</span>
    </button>
    <button class="upgrade-btn" onclick="buyUpgrade('autoclicker')" id="btn-autoclicker">
      <span class="name">ü§ñ Auto-Clicker</span>
      <span class="cost">Cost: 250</span>
      <span class="owned">Owned: 0</span>
    </button>
  </div>

  <div id="backlink">
    <a href="https://sloppy.live">‚Üê sloppy.live</a>
  </div>

  <script>
    const canvas = document.getElementById('giraffe-canvas');
    const ctx = canvas.getContext('2d');
    const particleCanvas = document.getElementById('fart-particles');
    const pctx = particleCanvas.getContext('2d');

    let clicks = 0;
    let clicksPerSecond = 0;
    let frameCount = 0;

    // Health system
    let health = 100;
    const maxHealth = 100;
    const healthDamagePerClick = 5;
    const healthRegenRate = 2; // per second
    let isExploded = false;
    let respawnTimer = 0;
    const respawnDelay = 180; // 3 seconds at 60fps

    const upgrades = {
      head: { count: 0, baseCost: 50, multiplier: 1.5 },
      tophat: { count: 0, baseCost: 100, multiplier: 1.6 },
      partyhat: { count: 0, baseCost: 200, multiplier: 1.6 },
      crown: { count: 0, baseCost: 500, multiplier: 1.7 },
      viking: { count: 0, baseCost: 350, multiplier: 1.6 },
      beret: { count: 0, baseCost: 150, multiplier: 1.5 },
      propeller: { count: 0, baseCost: 400, multiplier: 1.7 },
      wizard: { count: 0, baseCost: 600, multiplier: 1.8 },
      sombrero: { count: 0, baseCost: 450, multiplier: 1.7 },
      autoclicker: { count: 0, baseCost: 250, multiplier: 2 }
    };

    // Farting crab bonus system
    const crab = {
      x: 50,
      y: 380,
      width: 60,
      height: 40,
      ready: true,
      cooldown: 0,
      cooldownMax: 3600, // 60 seconds at 60fps
      legPhase: 0
    };

    let fartParticles = [];
    let boneParticles = [];
    let audioCtx = null;

    function playFartSound() {
      if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
      const now = audioCtx.currentTime;

      // Create fart sound with noise and oscillator
      const duration = 0.3 + Math.random() * 0.3;

      // Low frequency oscillator for the "braaap"
      const osc = audioCtx.createOscillator();
      osc.type = 'sawtooth';
      osc.frequency.setValueAtTime(80 + Math.random() * 40, now);
      osc.frequency.exponentialRampToValueAtTime(40 + Math.random() * 20, now + duration);

      // Noise for texture
      const noiseBuffer = audioCtx.createBuffer(1, audioCtx.sampleRate * duration, audioCtx.sampleRate);
      const noiseData = noiseBuffer.getChannelData(0);
      for (let i = 0; i < noiseData.length; i++) {
        noiseData[i] = (Math.random() * 2 - 1) * 0.3;
      }
      const noise = audioCtx.createBufferSource();
      noise.buffer = noiseBuffer;

      // Low pass filter
      const filter = audioCtx.createBiquadFilter();
      filter.type = 'lowpass';
      filter.frequency.setValueAtTime(500, now);
      filter.frequency.exponentialRampToValueAtTime(150, now + duration);

      // Gain envelope
      const gain = audioCtx.createGain();
      gain.gain.setValueAtTime(0.4, now);
      gain.gain.linearRampToValueAtTime(0.5, now + 0.05);
      gain.gain.exponentialRampToValueAtTime(0.01, now + duration);

      // Connect
      osc.connect(filter);
      noise.connect(filter);
      filter.connect(gain);
      gain.connect(audioCtx.destination);

      osc.start(now);
      osc.stop(now + duration);
      noise.start(now);
      noise.stop(now + duration);
    }

    function spawnFartParticles() {
      const colors = ['#88ff00', '#aaff44', '#ccff88', '#77dd00'];
      for (let i = 0; i < 15; i++) {
        fartParticles.push({
          x: 150 + (Math.random() - 0.5) * 40,
          y: 350,
          vx: (Math.random() - 0.5) * 4,
          vy: -2 - Math.random() * 3,
          size: 5 + Math.random() * 15,
          color: colors[Math.floor(Math.random() * colors.length)],
          alpha: 1,
          rotation: Math.random() * Math.PI * 2
        });
      }
    }

    function playExplosionSound() {
      if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
      const now = audioCtx.currentTime;

      // Big boom
      const osc = audioCtx.createOscillator();
      osc.type = 'sawtooth';
      osc.frequency.setValueAtTime(150, now);
      osc.frequency.exponentialRampToValueAtTime(30, now + 0.5);

      const gain = audioCtx.createGain();
      gain.gain.setValueAtTime(0.6, now);
      gain.gain.exponentialRampToValueAtTime(0.01, now + 0.6);

      osc.connect(gain);
      gain.connect(audioCtx.destination);
      osc.start(now);
      osc.stop(now + 0.6);

      // Crackling
      for (let i = 0; i < 5; i++) {
        const noise = audioCtx.createBufferSource();
        const bufferSize = audioCtx.sampleRate * 0.1;
        const buffer = audioCtx.createBuffer(1, bufferSize, audioCtx.sampleRate);
        const data = buffer.getChannelData(0);
        for (let j = 0; j < bufferSize; j++) {
          data[j] = (Math.random() * 2 - 1) * Math.exp(-j / (bufferSize * 0.3));
        }
        noise.buffer = buffer;

        const noiseGain = audioCtx.createGain();
        noiseGain.gain.setValueAtTime(0.3, now + i * 0.08);
        noiseGain.gain.exponentialRampToValueAtTime(0.01, now + i * 0.08 + 0.1);

        noise.connect(noiseGain);
        noiseGain.connect(audioCtx.destination);
        noise.start(now + i * 0.08);
      }
    }

    function spawnBoneParticles() {
      const boneTypes = ['skull', 'leg', 'rib', 'spine', 'hoof'];
      const colors = ['#ffff00', '#ff00ff', '#00ffff', '#ff6600', '#00ff00'];

      for (let i = 0; i < 30; i++) {
        boneParticles.push({
          x: 150,
          y: 200,
          vx: (Math.random() - 0.5) * 15,
          vy: -8 - Math.random() * 10,
          rotation: Math.random() * Math.PI * 2,
          rotationSpeed: (Math.random() - 0.5) * 0.3,
          type: boneTypes[Math.floor(Math.random() * boneTypes.length)],
          color: colors[Math.floor(Math.random() * colors.length)],
          size: 10 + Math.random() * 20,
          alpha: 1
        });
      }
    }

    function explodeGiraffe() {
      isExploded = true;
      respawnTimer = respawnDelay;
      playExplosionSound();
      spawnBoneParticles();

      // Show explosion text
      const explosionText = document.getElementById('explosion-text');
      explosionText.classList.remove('show');
      void explosionText.offsetWidth;
      explosionText.classList.add('show');
    }

    function respawnGiraffe() {
      isExploded = false;
      health = maxHealth;
      boneParticles = [];
      updateHealthBar();
    }

    function updateHealthBar() {
      const healthBar = document.getElementById('health-bar');
      const percentage = Math.max(0, (health / maxHealth) * 100);
      healthBar.style.width = percentage + '%';

      // Change color based on health
      if (percentage > 60) {
        healthBar.style.background = 'linear-gradient(90deg, #00ff00, #88ff00)';
      } else if (percentage > 30) {
        healthBar.style.background = 'linear-gradient(90deg, #ff6600, #ffaa00)';
      } else {
        healthBar.style.background = 'linear-gradient(90deg, #ff0000, #ff3300)';
      }
    }

    function updateParticles() {
      pctx.clearRect(0, 0, particleCanvas.width, particleCanvas.height);

      // Fart particles
      fartParticles = fartParticles.filter(p => {
        p.x += p.vx;
        p.y += p.vy;
        p.vy += 0.05; // slight gravity
        p.alpha -= 0.02;
        p.rotation += 0.1;
        p.size *= 0.98;

        if (p.alpha > 0) {
          pctx.save();
          pctx.globalAlpha = p.alpha;
          pctx.fillStyle = p.color;
          pctx.translate(p.x, p.y);
          pctx.rotate(p.rotation);

          // Cloud shape
          pctx.beginPath();
          pctx.arc(0, 0, p.size, 0, Math.PI * 2);
          pctx.arc(p.size * 0.5, -p.size * 0.3, p.size * 0.7, 0, Math.PI * 2);
          pctx.arc(-p.size * 0.4, -p.size * 0.2, p.size * 0.6, 0, Math.PI * 2);
          pctx.fill();

          pctx.restore();
          return true;
        }
        return false;
      });

      // Bone particles
      boneParticles = boneParticles.filter(p => {
        p.x += p.vx;
        p.y += p.vy;
        p.vy += 0.3; // gravity
        p.vx *= 0.99;
        p.rotation += p.rotationSpeed;
        p.alpha -= 0.008;

        if (p.alpha > 0 && p.y < 500) {
          pctx.save();
          pctx.globalAlpha = p.alpha;
          pctx.translate(p.x, p.y);
          pctx.rotate(p.rotation);
          pctx.shadowColor = p.color;
          pctx.shadowBlur = 15;
          pctx.fillStyle = p.color;
          pctx.strokeStyle = p.color;
          pctx.lineWidth = 3;

          // Draw different bone types
          switch (p.type) {
            case 'skull':
              pctx.beginPath();
              pctx.arc(0, 0, p.size * 0.6, 0, Math.PI * 2);
              pctx.fill();
              pctx.fillStyle = '#000';
              pctx.beginPath();
              pctx.arc(-p.size * 0.2, -p.size * 0.1, p.size * 0.15, 0, Math.PI * 2);
              pctx.arc(p.size * 0.2, -p.size * 0.1, p.size * 0.15, 0, Math.PI * 2);
              pctx.fill();
              break;
            case 'leg':
              pctx.beginPath();
              pctx.moveTo(-p.size * 0.5, 0);
              pctx.lineTo(p.size * 0.5, 0);
              pctx.stroke();
              pctx.beginPath();
              pctx.arc(-p.size * 0.5, 0, p.size * 0.2, 0, Math.PI * 2);
              pctx.arc(p.size * 0.5, 0, p.size * 0.2, 0, Math.PI * 2);
              pctx.fill();
              break;
            case 'rib':
              pctx.beginPath();
              pctx.arc(0, 0, p.size * 0.4, 0.5, Math.PI - 0.5);
              pctx.stroke();
              break;
            case 'spine':
              for (let i = 0; i < 4; i++) {
                pctx.fillRect(-p.size * 0.4 + i * p.size * 0.25, -p.size * 0.1, p.size * 0.2, p.size * 0.2);
              }
              break;
            case 'hoof':
              pctx.beginPath();
              pctx.arc(0, 0, p.size * 0.3, 0, Math.PI);
              pctx.fill();
              break;
          }

          pctx.restore();
          return true;
        }
        return false;
      });
    }

    function clickGiraffe(e) {
      e.preventDefault();

      // Get click position relative to canvas
      const rect = canvas.getBoundingClientRect();
      const clickX = (e.clientX - rect.left) * (canvas.width / rect.width);
      const clickY = (e.clientY - rect.top) * (canvas.height / rect.height);

      // Check for crab click first
      if (clickCrab(clickX, clickY)) {
        return; // Crab was clicked, don't also click giraffe
      }

      // Can't click if exploded
      if (isExploded) return;

      // Base click value: 1 + 1 per extra head
      const baseClick = 1 + upgrades.head.count;

      // Hat multiplier: 2x per hat type owned
      let hatMultiplier = 1;
      if (upgrades.tophat.count > 0) hatMultiplier *= 2;
      if (upgrades.partyhat.count > 0) hatMultiplier *= 2;
      if (upgrades.crown.count > 0) hatMultiplier *= 2;
      if (upgrades.viking.count > 0) hatMultiplier *= 2;
      if (upgrades.beret.count > 0) hatMultiplier *= 2;
      if (upgrades.propeller.count > 0) hatMultiplier *= 2;
      if (upgrades.wizard.count > 0) hatMultiplier *= 2;
      if (upgrades.sombrero.count > 0) hatMultiplier *= 2;

      const clickValue = baseClick * hatMultiplier;
      clicks += clickValue;

      // Update display
      document.getElementById('clicks').textContent = `CLICKS: ${clicks}`;

      // Show text
      const clickText = document.getElementById('click-text');
      clickText.classList.remove('show');
      void clickText.offsetWidth; // Trigger reflow
      clickText.classList.add('show');

      // Play fart and spawn particles
      playFartSound();
      spawnFartParticles();

      // Damage health from farting
      health -= healthDamagePerClick;
      updateHealthBar();

      // Check for explosion
      if (health <= 0) {
        explodeGiraffe();
      }

      // Update upgrade buttons
      updateUpgradeButtons();
    }

    function getUpgradeCost(type) {
      const upgrade = upgrades[type];
      return Math.floor(upgrade.baseCost * Math.pow(upgrade.multiplier, upgrade.count));
    }

    function buyUpgrade(type) {
      const cost = getUpgradeCost(type);
      if (clicks >= cost) {
        clicks -= cost;
        upgrades[type].count++;
        document.getElementById('clicks').textContent = `CLICKS: ${clicks}`;
        updateUpgradeButtons();
      }
    }

    function updateUpgradeButtons() {
      for (const [type, data] of Object.entries(upgrades)) {
        const btn = document.getElementById(`btn-${type}`);
        const cost = getUpgradeCost(type);
        btn.querySelector('.cost').textContent = `Cost: ${cost}`;
        btn.querySelector('.owned').textContent = `Owned: ${data.count}`;
        btn.disabled = clicks < cost;
      }

      // Update CPS display
      clicksPerSecond = upgrades.autoclicker.count;
      document.getElementById('cps').textContent = `+${clicksPerSecond}/sec`;
    }

    function drawGiraffe() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      frameCount++;

      // Don't draw if exploded
      if (isExploded) {
        // Draw respawn countdown
        ctx.font = '24px Bangers';
        ctx.fillStyle = '#ff00ff';
        ctx.textAlign = 'center';
        ctx.shadowColor = '#ff00ff';
        ctx.shadowBlur = 20;
        const secondsLeft = Math.ceil(respawnTimer / 60);
        ctx.fillText(`Respawning in ${secondsLeft}...`, 150, 200);
        return;
      }

      const wobble = Math.sin(frameCount * 0.05) * 3;
      const headCount = 1 + upgrades.head.count;

      // Glow effect
      ctx.shadowColor = '#ffff00';
      ctx.shadowBlur = 20;

      // Body
      ctx.fillStyle = '#ffdd00';
      ctx.beginPath();
      ctx.ellipse(150, 320, 50, 70, 0, 0, Math.PI * 2);
      ctx.fill();

      // Spots on body
      ctx.fillStyle = '#cc8800';
      ctx.shadowBlur = 0;
      const spots = [[130, 300], [170, 310], [140, 340], [160, 330], [150, 290]];
      spots.forEach(([sx, sy]) => {
        ctx.beginPath();
        ctx.ellipse(sx, sy, 8, 10, Math.random() * 0.5, 0, Math.PI * 2);
        ctx.fill();
      });

      // Legs
      ctx.fillStyle = '#ffdd00';
      ctx.shadowColor = '#ffff00';
      ctx.shadowBlur = 10;
      for (let i = 0; i < 4; i++) {
        const legX = 115 + (i % 2) * 70;
        const legY = 370;
        const legWobble = Math.sin(frameCount * 0.1 + i) * 2;
        ctx.fillRect(legX + legWobble, legY, 15, 50);

        // Hooves
        ctx.fillStyle = '#663300';
        ctx.fillRect(legX + legWobble - 2, legY + 45, 19, 10);
        ctx.fillStyle = '#ffdd00';
      }

      // Tail
      ctx.strokeStyle = '#ffdd00';
      ctx.lineWidth = 5;
      ctx.beginPath();
      ctx.moveTo(100, 320);
      ctx.quadraticCurveTo(70 + wobble, 330, 60 + wobble * 2, 360);
      ctx.stroke();

      // Tail tuft
      ctx.fillStyle = '#cc8800';
      ctx.beginPath();
      ctx.arc(60 + wobble * 2, 365, 8, 0, Math.PI * 2);
      ctx.fill();

      // Draw necks and heads
      const neckSpacing = 30 / headCount;
      for (let h = 0; h < headCount; h++) {
        const neckOffset = (h - (headCount - 1) / 2) * neckSpacing;
        const neckWobble = Math.sin(frameCount * 0.05 + h * 0.5) * 5;

        // Neck
        ctx.fillStyle = '#ffdd00';
        ctx.shadowColor = '#ffff00';
        ctx.shadowBlur = 15;

        ctx.beginPath();
        ctx.moveTo(130 + neckOffset, 270);
        ctx.quadraticCurveTo(140 + neckOffset + neckWobble, 150, 150 + neckOffset + neckWobble * 0.5, 80);
        ctx.lineTo(170 + neckOffset + neckWobble * 0.5, 80);
        ctx.quadraticCurveTo(180 + neckOffset + neckWobble, 150, 170 + neckOffset, 270);
        ctx.fill();

        // Neck spots
        ctx.fillStyle = '#cc8800';
        ctx.shadowBlur = 0;
        for (let s = 0; s < 3; s++) {
          const spotY = 120 + s * 50;
          ctx.beginPath();
          ctx.ellipse(150 + neckOffset + neckWobble * (1 - s * 0.3), spotY, 6, 8, 0, 0, Math.PI * 2);
          ctx.fill();
        }

        // Head
        const headX = 150 + neckOffset + neckWobble * 0.5;
        const headY = 60;

        ctx.fillStyle = '#ffdd00';
        ctx.shadowColor = '#ffff00';
        ctx.shadowBlur = 15;
        ctx.beginPath();
        ctx.ellipse(headX, headY, 25, 20, 0, 0, Math.PI * 2);
        ctx.fill();

        // Snout
        ctx.beginPath();
        ctx.ellipse(headX + 20, headY + 5, 15, 12, 0, 0, Math.PI * 2);
        ctx.fill();

        // Ossicones (horns)
        ctx.fillStyle = '#cc8800';
        ctx.fillRect(headX - 12, headY - 30, 6, 20);
        ctx.fillRect(headX + 6, headY - 30, 6, 20);

        // Horn tips
        ctx.fillStyle = '#663300';
        ctx.beginPath();
        ctx.arc(headX - 9, headY - 32, 5, 0, Math.PI * 2);
        ctx.fill();
        ctx.beginPath();
        ctx.arc(headX + 9, headY - 32, 5, 0, Math.PI * 2);
        ctx.fill();

        // Ears
        ctx.fillStyle = '#ffdd00';
        ctx.beginPath();
        ctx.ellipse(headX - 20, headY - 10, 8, 12, -0.5, 0, Math.PI * 2);
        ctx.fill();
        ctx.beginPath();
        ctx.ellipse(headX + 20, headY - 10, 8, 12, 0.5, 0, Math.PI * 2);
        ctx.fill();

        // Eyes
        ctx.fillStyle = '#000';
        ctx.shadowBlur = 0;
        ctx.beginPath();
        ctx.arc(headX - 8, headY - 2, 5, 0, Math.PI * 2);
        ctx.fill();
        ctx.beginPath();
        ctx.arc(headX + 8, headY - 2, 5, 0, Math.PI * 2);
        ctx.fill();

        // Eye shine
        ctx.fillStyle = '#fff';
        ctx.beginPath();
        ctx.arc(headX - 6, headY - 4, 2, 0, Math.PI * 2);
        ctx.fill();
        ctx.beginPath();
        ctx.arc(headX + 10, headY - 4, 2, 0, Math.PI * 2);
        ctx.fill();

        // Nostrils
        ctx.fillStyle = '#663300';
        ctx.beginPath();
        ctx.ellipse(headX + 28, headY + 3, 3, 2, 0, 0, Math.PI * 2);
        ctx.fill();
        ctx.beginPath();
        ctx.ellipse(headX + 28, headY + 8, 3, 2, 0, 0, Math.PI * 2);
        ctx.fill();

        // Smile
        ctx.strokeStyle = '#663300';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.arc(headX + 15, headY + 8, 8, 0.2, Math.PI - 0.2);
        ctx.stroke();

        // 67 Tattoo
        ctx.fillStyle = '#ff00ff';
        ctx.shadowColor = '#ff00ff';
        ctx.shadowBlur = 8;
        ctx.font = 'bold 14px monospace';
        ctx.fillText('67', headX - 22, headY + 8);

        // Draw hats based on upgrades
        drawHats(headX, headY - 20, h);
      }
    }

    function drawHats(x, y, headIndex) {
      // Top hats
      if (upgrades.tophat.count > headIndex) {
        ctx.fillStyle = '#1a1a1a';
        ctx.shadowColor = '#ff00ff';
        ctx.shadowBlur = 10;
        ctx.fillRect(x - 20, y - 35, 40, 30);
        ctx.fillRect(x - 25, y - 8, 50, 8);
        ctx.fillStyle = '#ff00ff';
        ctx.fillRect(x - 18, y - 15, 36, 5);
      }

      // Party hats
      if (upgrades.partyhat.count > headIndex) {
        ctx.fillStyle = '#ff0066';
        ctx.shadowColor = '#ff0066';
        ctx.shadowBlur = 15;
        ctx.beginPath();
        ctx.moveTo(x, y - 50);
        ctx.lineTo(x - 20, y - 10);
        ctx.lineTo(x + 20, y - 10);
        ctx.closePath();
        ctx.fill();

        // Stripes
        ctx.strokeStyle = '#00ffff';
        ctx.lineWidth = 3;
        ctx.beginPath();
        ctx.moveTo(x - 5, y - 40);
        ctx.lineTo(x - 15, y - 15);
        ctx.stroke();
        ctx.beginPath();
        ctx.moveTo(x + 5, y - 40);
        ctx.lineTo(x + 15, y - 15);
        ctx.stroke();

        // Pom pom
        ctx.fillStyle = '#ffff00';
        ctx.beginPath();
        ctx.arc(x, y - 52, 6, 0, Math.PI * 2);
        ctx.fill();
      }

      // Crowns
      if (upgrades.crown.count > headIndex) {
        ctx.fillStyle = '#ffd700';
        ctx.shadowColor = '#ffd700';
        ctx.shadowBlur = 20;

        ctx.beginPath();
        ctx.moveTo(x - 22, y - 5);
        ctx.lineTo(x - 22, y - 25);
        ctx.lineTo(x - 12, y - 15);
        ctx.lineTo(x, y - 30);
        ctx.lineTo(x + 12, y - 15);
        ctx.lineTo(x + 22, y - 25);
        ctx.lineTo(x + 22, y - 5);
        ctx.closePath();
        ctx.fill();

        // Gems
        ctx.fillStyle = '#ff0000';
        ctx.beginPath();
        ctx.arc(x, y - 15, 5, 0, Math.PI * 2);
        ctx.fill();
        ctx.fillStyle = '#00ff00';
        ctx.beginPath();
        ctx.arc(x - 12, y - 10, 3, 0, Math.PI * 2);
        ctx.fill();
        ctx.fillStyle = '#0088ff';
        ctx.beginPath();
        ctx.arc(x + 12, y - 10, 3, 0, Math.PI * 2);
        ctx.fill();
      }

      // Viking helmet
      if (upgrades.viking.count > headIndex) {
        ctx.fillStyle = '#8b4513';
        ctx.shadowColor = '#ff6600';
        ctx.shadowBlur = 10;
        // Helmet dome
        ctx.beginPath();
        ctx.arc(x, y - 15, 22, Math.PI, 0);
        ctx.fill();
        // Horns
        ctx.fillStyle = '#f5f5dc';
        ctx.beginPath();
        ctx.moveTo(x - 22, y - 15);
        ctx.lineTo(x - 35, y - 40);
        ctx.lineTo(x - 18, y - 20);
        ctx.closePath();
        ctx.fill();
        ctx.beginPath();
        ctx.moveTo(x + 22, y - 15);
        ctx.lineTo(x + 35, y - 40);
        ctx.lineTo(x + 18, y - 20);
        ctx.closePath();
        ctx.fill();
      }

      // Beret
      if (upgrades.beret.count > headIndex) {
        ctx.fillStyle = '#ff0055';
        ctx.shadowColor = '#ff0055';
        ctx.shadowBlur = 12;
        ctx.beginPath();
        ctx.ellipse(x, y - 12, 28, 12, 0, 0, Math.PI * 2);
        ctx.fill();
        // Pom pom
        ctx.fillStyle = '#000000';
        ctx.beginPath();
        ctx.arc(x, y - 20, 5, 0, Math.PI * 2);
        ctx.fill();
      }

      // Propeller hat
      if (upgrades.propeller.count > headIndex) {
        ctx.fillStyle = '#00ccff';
        ctx.shadowColor = '#00ccff';
        ctx.shadowBlur = 15;
        // Beanie base
        ctx.beginPath();
        ctx.arc(x, y - 10, 20, Math.PI, 0);
        ctx.fill();
        // Propeller center
        ctx.fillStyle = '#ffff00';
        ctx.beginPath();
        ctx.arc(x, y - 30, 6, 0, Math.PI * 2);
        ctx.fill();
        // Spinning propeller blades
        const spin = frameCount * 0.2;
        ctx.fillStyle = '#ff00ff';
        ctx.save();
        ctx.translate(x, y - 30);
        ctx.rotate(spin);
        ctx.fillRect(-25, -3, 50, 6);
        ctx.rotate(Math.PI / 2);
        ctx.fillRect(-25, -3, 50, 6);
        ctx.restore();
      }

      // Wizard hat
      if (upgrades.wizard.count > headIndex) {
        ctx.fillStyle = '#4400aa';
        ctx.shadowColor = '#aa00ff';
        ctx.shadowBlur = 20;
        // Cone
        ctx.beginPath();
        ctx.moveTo(x, y - 70);
        ctx.lineTo(x - 25, y - 5);
        ctx.lineTo(x + 25, y - 5);
        ctx.closePath();
        ctx.fill();
        // Brim
        ctx.beginPath();
        ctx.ellipse(x, y - 5, 30, 8, 0, 0, Math.PI * 2);
        ctx.fill();
        // Stars
        ctx.fillStyle = '#ffff00';
        ctx.font = '12px serif';
        ctx.fillText('‚òÖ', x - 10, y - 35);
        ctx.fillText('‚òÖ', x + 5, y - 50);
        ctx.fillText('‚ú¶', x - 5, y - 20);
      }

      // Sombrero
      if (upgrades.sombrero.count > headIndex) {
        ctx.fillStyle = '#ff9900';
        ctx.shadowColor = '#ff6600';
        ctx.shadowBlur = 15;
        // Wide brim
        ctx.beginPath();
        ctx.ellipse(x, y - 5, 40, 10, 0, 0, Math.PI * 2);
        ctx.fill();
        // Crown
        ctx.beginPath();
        ctx.arc(x, y - 15, 18, Math.PI, 0);
        ctx.fill();
        // Decorative band
        ctx.strokeStyle = '#00ff00';
        ctx.lineWidth = 3;
        ctx.beginPath();
        ctx.arc(x, y - 15, 18, Math.PI, 0);
        ctx.stroke();
        ctx.strokeStyle = '#ff0066';
        ctx.beginPath();
        ctx.moveTo(x - 35, y - 5);
        ctx.lineTo(x + 35, y - 5);
        ctx.stroke();
      }
    }

    function playCrabFart() {
      if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();

      // Wet bubbly crab fart
      const osc = audioCtx.createOscillator();
      const gain = audioCtx.createGain();
      const filter = audioCtx.createBiquadFilter();

      osc.type = 'sawtooth';
      osc.frequency.setValueAtTime(80, audioCtx.currentTime);
      osc.frequency.exponentialRampToValueAtTime(40, audioCtx.currentTime + 0.3);

      filter.type = 'lowpass';
      filter.frequency.value = 300;

      gain.gain.setValueAtTime(0.4, audioCtx.currentTime);
      gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.4);

      osc.connect(filter);
      filter.connect(gain);
      gain.connect(audioCtx.destination);

      osc.start();
      osc.stop(audioCtx.currentTime + 0.4);
    }

    function drawCrab() {
      crab.legPhase += 0.1;

      const cx = crab.x;
      const cy = crab.y;

      // Legs (4 on each side)
      ctx.strokeStyle = crab.ready ? '#ff6600' : '#666666';
      ctx.lineWidth = 3;
      for (let i = 0; i < 4; i++) {
        const legOffset = Math.sin(crab.legPhase + i * 0.5) * 3;
        // Left legs
        ctx.beginPath();
        ctx.moveTo(cx - 15, cy + i * 8 - 10);
        ctx.lineTo(cx - 30 - i * 3, cy + i * 8 - 5 + legOffset);
        ctx.stroke();
        // Right legs
        ctx.beginPath();
        ctx.moveTo(cx + 15, cy + i * 8 - 10);
        ctx.lineTo(cx + 30 + i * 3, cy + i * 8 - 5 + legOffset);
        ctx.stroke();
      }

      // Body
      ctx.fillStyle = crab.ready ? '#ff4400' : '#555555';
      ctx.shadowColor = crab.ready ? '#ff6600' : '#333333';
      ctx.shadowBlur = crab.ready ? 15 : 5;
      ctx.beginPath();
      ctx.ellipse(cx, cy, 25, 18, 0, 0, Math.PI * 2);
      ctx.fill();

      // Claws
      ctx.fillStyle = crab.ready ? '#ff6600' : '#666666';
      // Left claw
      ctx.beginPath();
      ctx.ellipse(cx - 35, cy - 10, 12, 8, -0.3, 0, Math.PI * 2);
      ctx.fill();
      ctx.beginPath();
      ctx.ellipse(cx - 40, cy - 5, 8, 5, 0.5, 0, Math.PI * 2);
      ctx.fill();
      // Right claw
      ctx.beginPath();
      ctx.ellipse(cx + 35, cy - 10, 12, 8, 0.3, 0, Math.PI * 2);
      ctx.fill();
      ctx.beginPath();
      ctx.ellipse(cx + 40, cy - 5, 8, 5, -0.5, 0, Math.PI * 2);
      ctx.fill();

      // Eyes on stalks
      ctx.fillStyle = '#000';
      ctx.beginPath();
      ctx.arc(cx - 8, cy - 22, 5, 0, Math.PI * 2);
      ctx.fill();
      ctx.beginPath();
      ctx.arc(cx + 8, cy - 22, 5, 0, Math.PI * 2);
      ctx.fill();
      // Eye stalks
      ctx.strokeStyle = crab.ready ? '#ff4400' : '#555555';
      ctx.lineWidth = 4;
      ctx.beginPath();
      ctx.moveTo(cx - 8, cy - 15);
      ctx.lineTo(cx - 8, cy - 22);
      ctx.stroke();
      ctx.beginPath();
      ctx.moveTo(cx + 8, cy - 15);
      ctx.lineTo(cx + 8, cy - 22);
      ctx.stroke();

      // Ready indicator or cooldown
      ctx.shadowBlur = 0;
      if (crab.ready) {
        ctx.fillStyle = '#00ff00';
        ctx.font = 'bold 10px monospace';
        ctx.fillText('+1000!', cx - 18, cy + 35);
      } else {
        const secondsLeft = Math.ceil(crab.cooldown / 60);
        ctx.fillStyle = '#888888';
        ctx.font = '10px monospace';
        ctx.fillText(`${secondsLeft}s`, cx - 10, cy + 35);
      }
    }

    function updateCrab() {
      if (!crab.ready) {
        crab.cooldown--;
        if (crab.cooldown <= 0) {
          crab.ready = true;
        }
      }
    }

    function clickCrab(x, y) {
      if (!crab.ready) return false;

      // Check if click is within crab bounds
      const dx = x - crab.x;
      const dy = y - crab.y;
      if (Math.abs(dx) < 40 && Math.abs(dy) < 30) {
        // Crab clicked!
        clicks += 1000;
        document.getElementById('clicks').textContent = `CLICKS: ${clicks}`;
        updateUpgradeButtons();
        playCrabFart();
        spawnFartParticles(); // Use existing fart particles

        // Start cooldown
        crab.ready = false;
        crab.cooldown = crab.cooldownMax;

        return true;
      }
      return false;
    }

    function autoClick() {
      if (upgrades.autoclicker.count > 0 && !isExploded) {
        // Base click value: 1 + 1 per extra head
        const baseClick = 1 + upgrades.head.count;

        // Hat multiplier for auto-clicks too
        let hatMultiplier = 1;
        if (upgrades.tophat.count > 0) hatMultiplier *= 2;
        if (upgrades.partyhat.count > 0) hatMultiplier *= 2;
        if (upgrades.crown.count > 0) hatMultiplier *= 2;
        if (upgrades.viking.count > 0) hatMultiplier *= 2;
        if (upgrades.beret.count > 0) hatMultiplier *= 2;
        if (upgrades.propeller.count > 0) hatMultiplier *= 2;
        if (upgrades.wizard.count > 0) hatMultiplier *= 2;
        if (upgrades.sombrero.count > 0) hatMultiplier *= 2;

        const clickValue = baseClick * hatMultiplier;
        clicks += upgrades.autoclicker.count * clickValue;
        document.getElementById('clicks').textContent = `CLICKS: ${clicks}`;
        updateUpgradeButtons();
      }
    }

    function gameLoop() {
      // Handle respawn timer
      if (isExploded) {
        respawnTimer--;
        if (respawnTimer <= 0) {
          respawnGiraffe();
        }
      } else {
        // Regenerate health slowly
        if (frameCount % 30 === 0 && health < maxHealth) { // Every 0.5 seconds
          health = Math.min(maxHealth, health + healthRegenRate);
          updateHealthBar();
        }
      }

      drawGiraffe();
      drawCrab();
      updateCrab();
      updateParticles();
      requestAnimationFrame(gameLoop);
    }

    // Auto-clicker runs every second
    setInterval(autoClick, 1000);

    // Start game
    updateHealthBar();
    updateUpgradeButtons();
    gameLoop();
  </script>
<script src="/apps/sloppy-header/sloppy-bar.js"></script>
<script src="/vibelib-extended.js"></script>
<script>
  // Compatibility Patch for Legacy Apps
  window.addEventListener("load", () => {
    if (window.SloppyKarma && window.VibeLib.Economy) {
      // Redirect old calls to new engine
      window.SloppyKarma.track = window.VibeLib.Economy.track;
    }
  });
</script>
</body>
</html>
