<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
  <title>Neon Maelstrom - Bullet Hell</title>
  <link rel="icon" href="https://emojicdn.elk.sh/ðŸŒ€">
  <meta name="description" content="Dodge neon bullet storms as a glowing triangle. Dash through the chaos!">
  <meta property="og:title" content="Neon Maelstrom">
  <meta property="og:description" content="Fast-paced bullet hell. Dodge, dash, survive the neon chaos.">
  <meta property="og:url" content="https://app.sloppy.live/neon-maelstrom">
  <meta property="og:image" content="https://app.sloppy.live/neon-maelstrom/og-image.png">
  <meta property="og:type" content="website">
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&display=swap" rel="stylesheet">
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }
    body {
      background: #050510;
      font-family: 'Orbitron', sans-serif;
      overflow: hidden;
      height: 100vh;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    #gameCanvas {
      display: block;
      background: radial-gradient(ellipse at center, #0a0a20 0%, #050510 100%);
    }
    #ui {
      position: fixed;
      top: 20px;
      left: 20px;
      color: #0ff;
      font-size: 14px;
      text-shadow: 0 0 10px #0ff, 0 0 20px #0ff;
      z-index: 10;
      pointer-events: none;
    }
    #score {
      font-size: 24px;
      font-weight: 900;
      margin-bottom: 8px;
    }
    #wave {
      color: #f0f;
      text-shadow: 0 0 10px #f0f;
      margin-bottom: 8px;
    }
    #dashBar {
      width: 120px;
      height: 8px;
      background: rgba(255,255,255,0.1);
      border: 1px solid #0ff;
      border-radius: 4px;
      overflow: hidden;
    }
    #dashFill {
      height: 100%;
      background: linear-gradient(90deg, #0ff, #f0f);
      box-shadow: 0 0 10px #0ff;
      transition: width 0.1s;
    }
    #startScreen, #gameOverScreen {
      position: fixed;
      inset: 0;
      background: rgba(5,5,16,0.95);
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      z-index: 100;
      color: #fff;
      text-align: center;
      padding: 20px;
    }
    #startScreen h1, #gameOverScreen h1 {
      font-size: clamp(32px, 8vw, 64px);
      font-weight: 900;
      background: linear-gradient(135deg, #0ff, #f0f, #ff0);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
      text-shadow: none;
      margin-bottom: 20px;
      animation: glow 2s ease-in-out infinite alternate;
    }
    @keyframes glow {
      from { filter: drop-shadow(0 0 20px #0ff); }
      to { filter: drop-shadow(0 0 40px #f0f); }
    }
    .subtitle {
      color: #888;
      font-size: 14px;
      margin-bottom: 30px;
      max-width: 400px;
    }
    .controls {
      color: #666;
      font-size: 12px;
      margin-bottom: 30px;
      line-height: 1.8;
    }
    .controls span {
      color: #0ff;
      background: rgba(0,255,255,0.1);
      padding: 4px 10px;
      border-radius: 4px;
      margin: 0 4px;
    }
    .startBtn {
      background: transparent;
      border: 2px solid #0ff;
      color: #0ff;
      font-family: 'Orbitron', sans-serif;
      font-size: 18px;
      font-weight: 700;
      padding: 15px 50px;
      cursor: pointer;
      transition: all 0.3s;
      text-transform: uppercase;
      letter-spacing: 3px;
    }
    .startBtn:hover {
      background: #0ff;
      color: #050510;
      box-shadow: 0 0 30px #0ff;
    }
    #finalScore {
      font-size: 48px;
      color: #f0f;
      text-shadow: 0 0 20px #f0f;
      margin: 20px 0;
    }
    #finalWave {
      color: #0ff;
      margin-bottom: 30px;
    }
    .backlink {
      position: fixed;
      bottom: 15px;
      right: 15px;
      color: #444;
      font-size: 11px;
      text-decoration: none;
      z-index: 10;
      transition: color 0.3s;
    }
    .backlink:hover {
      color: #0ff;
    }
    @media (max-width: 768px) {
      #ui { font-size: 12px; top: 10px; left: 10px; }
      #score { font-size: 18px; }
      #dashBar { width: 80px; }
    }
    #gameCanvas {
      cursor: crosshair;
    }
    .hidden { display: none !important; }
  </style>
</head>
<body>
  <div id="ui">
    <div id="score">0</div>
    <div id="wave">WAVE 1</div>
    <div id="dashBar"><div id="dashFill"></div></div>
  </div>

  <canvas id="gameCanvas"></canvas>

  <div id="startScreen">
    <h1>NEON MAELSTROM</h1>
    <p class="subtitle">Navigate the chaos. Dodge neon bullet storms. How long can you survive?</p>
    <div class="controls">
      <span>CLICK</span> or <span>TAP</span> Move toward cursor<br>
      <span>DOUBLE-CLICK</span> or <span>DOUBLE-TAP</span> Dash
    </div>
    <button class="startBtn" id="startBtn">ENTER THE STORM</button>
  </div>

  <div id="gameOverScreen" class="hidden">
    <h1>OBLITERATED</h1>
    <div id="finalScore">0</div>
    <div id="finalWave">Reached Wave 1</div>
    <button class="startBtn" id="restartBtn">TRY AGAIN</button>
  </div>

  <a href="https://sloppy.live" class="backlink">sloppy.live</a>

  <script>
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const scoreEl = document.getElementById('score');
    const waveEl = document.getElementById('wave');
    const dashFill = document.getElementById('dashFill');
    const startScreen = document.getElementById('startScreen');
    const gameOverScreen = document.getElementById('gameOverScreen');
    const finalScoreEl = document.getElementById('finalScore');
    const finalWaveEl = document.getElementById('finalWave');

    let W, H;
    function resize() {
      W = canvas.width = window.innerWidth;
      H = canvas.height = window.innerHeight;
    }
    resize();
    window.addEventListener('resize', resize);

    // Game state
    let gameRunning = false;
    let score = 0;
    let wave = 1;
    let waveTimer = 0;
    let spawnTimer = 0;
    let patternIndex = 0;

    // Player
    const player = {
      x: 0, y: 0,
      size: 15,
      speed: 5,
      dashSpeed: 25,
      dashDuration: 8,
      dashCooldown: 60,
      dashTimer: 0,
      cooldownTimer: 0,
      isDashing: false,
      invincible: false,
      invincibleTimer: 0,
      trail: [],
      angle: -Math.PI / 2
    };

    // Input - cursor-based movement
    let isMoving = false;
    let targetX = 0, targetY = 0;
    let lastClickTime = 0;
    const DOUBLE_CLICK_DELAY = 300; // ms

    // Bullets
    let bullets = [];
    let particles = [];
    let warnings = [];

    // Colors
    const neonColors = ['#0ff', '#f0f', '#ff0', '#0f0', '#f00', '#00f', '#f80'];

    function randomColor() {
      return neonColors[Math.floor(Math.random() * neonColors.length)];
    }

    // Bullet patterns
    const patterns = [
      // Spiral
      function spiral(cx, cy, color) {
        const count = 12 + wave * 2;
        const speed = 2 + wave * 0.15;
        for (let i = 0; i < count; i++) {
          const angle = (i / count) * Math.PI * 2 + patternIndex * 0.1;
          bullets.push({
            x: cx, y: cy,
            vx: Math.cos(angle) * speed,
            vy: Math.sin(angle) * speed,
            size: 6,
            color: color || '#0ff'
          });
        }
      },
      // Ring burst
      function ring(cx, cy, color) {
        const count = 20 + wave * 3;
        const speed = 3 + wave * 0.2;
        for (let i = 0; i < count; i++) {
          const angle = (i / count) * Math.PI * 2;
          bullets.push({
            x: cx, y: cy,
            vx: Math.cos(angle) * speed,
            vy: Math.sin(angle) * speed,
            size: 5,
            color: color || '#f0f'
          });
        }
      },
      // Aimed burst at player
      function aimed(cx, cy, color) {
        const dx = player.x - cx;
        const dy = player.y - cy;
        const baseAngle = Math.atan2(dy, dx);
        const count = 5 + Math.floor(wave / 2);
        const spread = 0.3;
        const speed = 4 + wave * 0.25;
        for (let i = 0; i < count; i++) {
          const angle = baseAngle + (i - (count - 1) / 2) * spread;
          bullets.push({
            x: cx, y: cy,
            vx: Math.cos(angle) * speed,
            vy: Math.sin(angle) * speed,
            size: 7,
            color: color || '#ff0'
          });
        }
      },
      // Wave pattern
      function wavePattern(cx, cy, color) {
        const count = 15 + wave * 2;
        const speed = 2.5 + wave * 0.1;
        for (let i = 0; i < count; i++) {
          const angle = (i / count) * Math.PI * 2;
          bullets.push({
            x: cx, y: cy,
            vx: Math.cos(angle) * speed,
            vy: Math.sin(angle) * speed,
            size: 4,
            color: color || '#0f0',
            wave: true,
            baseAngle: angle,
            time: 0
          });
        }
      },
      // Cross pattern
      function cross(cx, cy, color) {
        const arms = 4;
        const bulletsPerArm = 8 + wave;
        const speed = 3 + wave * 0.15;
        for (let a = 0; a < arms; a++) {
          const baseAngle = (a / arms) * Math.PI * 2 + patternIndex * 0.05;
          for (let i = 0; i < bulletsPerArm; i++) {
            setTimeout(() => {
              if (!gameRunning) return;
              bullets.push({
                x: cx, y: cy,
                vx: Math.cos(baseAngle) * speed,
                vy: Math.sin(baseAngle) * speed,
                size: 5,
                color: color || '#f80'
              });
            }, i * 50);
          }
        }
      },
      // Scatter
      function scatter(cx, cy, color) {
        const count = 30 + wave * 5;
        for (let i = 0; i < count; i++) {
          const angle = Math.random() * Math.PI * 2;
          const speed = 1.5 + Math.random() * 3 + wave * 0.1;
          bullets.push({
            x: cx, y: cy,
            vx: Math.cos(angle) * speed,
            vy: Math.sin(angle) * speed,
            size: 4 + Math.random() * 3,
            color: color || randomColor()
          });
        }
      }
    ];

    // Warning duration in frames (about 0.5 seconds at 60fps)
    const WARNING_DURATION = 30;

    function createWarning(cx, cy, color, patternFunc) {
      // For edge spawns, show warning at screen edge
      let warnX = cx, warnY = cy;
      if (cx < 0) warnX = 30;
      if (cx > W) warnX = W - 30;
      if (cy < 0) warnY = 30;
      if (cy > H) warnY = H - 30;

      warnings.push({
        x: warnX,
        y: warnY,
        spawnX: cx,
        spawnY: cy,
        color: color,
        life: WARNING_DURATION,
        maxLife: WARNING_DURATION,
        patternFunc: patternFunc
      });
    }

    function spawnPattern() {
      const sides = ['top', 'bottom', 'left', 'right', 'center'];
      const side = sides[Math.floor(Math.random() * sides.length)];
      let cx, cy;

      switch (side) {
        case 'top': cx = Math.random() * W; cy = -20; break;
        case 'bottom': cx = Math.random() * W; cy = H + 20; break;
        case 'left': cx = -20; cy = Math.random() * H; break;
        case 'right': cx = W + 20; cy = Math.random() * H; break;
        case 'center': cx = W / 2 + (Math.random() - 0.5) * 200; cy = H / 2 + (Math.random() - 0.5) * 200; break;
      }

      const patternFunc = patterns[Math.floor(Math.random() * patterns.length)];
      const color = randomColor();
      createWarning(cx, cy, color, patternFunc);
      patternIndex++;
    }

    function spawnParticle(x, y, color, count = 5) {
      for (let i = 0; i < count; i++) {
        const angle = Math.random() * Math.PI * 2;
        const speed = 2 + Math.random() * 4;
        particles.push({
          x, y,
          vx: Math.cos(angle) * speed,
          vy: Math.sin(angle) * speed,
          size: 2 + Math.random() * 3,
          color,
          life: 1
        });
      }
    }

    function drawPlayer() {
      ctx.save();
      ctx.translate(player.x, player.y);
      ctx.rotate(player.angle + Math.PI / 2);

      // Glow
      const glowColor = player.isDashing ? '#fff' : (player.invincible ? '#f80' : '#0ff');
      ctx.shadowColor = glowColor;
      ctx.shadowBlur = player.isDashing ? 40 : 20;

      // Triangle
      ctx.beginPath();
      ctx.moveTo(0, -player.size);
      ctx.lineTo(-player.size * 0.7, player.size * 0.7);
      ctx.lineTo(player.size * 0.7, player.size * 0.7);
      ctx.closePath();

      ctx.fillStyle = player.invincible ?
        `rgba(255,136,0,${0.5 + Math.sin(Date.now() * 0.02) * 0.3})` :
        (player.isDashing ? '#fff' : '#0ff');
      ctx.fill();

      ctx.strokeStyle = glowColor;
      ctx.lineWidth = 2;
      ctx.stroke();

      ctx.restore();
    }

    function drawTrail() {
      for (let i = 0; i < player.trail.length; i++) {
        const t = player.trail[i];
        const alpha = (i / player.trail.length) * 0.5;
        ctx.save();
        ctx.translate(t.x, t.y);
        ctx.rotate(t.angle + Math.PI / 2);
        ctx.globalAlpha = alpha;
        ctx.shadowColor = player.isDashing ? '#fff' : '#0ff';
        ctx.shadowBlur = 10;

        ctx.beginPath();
        ctx.moveTo(0, -player.size * 0.8);
        ctx.lineTo(-player.size * 0.5, player.size * 0.5);
        ctx.lineTo(player.size * 0.5, player.size * 0.5);
        ctx.closePath();
        ctx.fillStyle = player.isDashing ? '#fff' : '#0ff';
        ctx.fill();
        ctx.restore();
      }
    }

    function drawBullet(b) {
      ctx.save();
      ctx.shadowColor = b.color;
      ctx.shadowBlur = 15;
      ctx.fillStyle = b.color;
      ctx.beginPath();
      ctx.arc(b.x, b.y, b.size, 0, Math.PI * 2);
      ctx.fill();

      // Inner glow
      ctx.fillStyle = '#fff';
      ctx.beginPath();
      ctx.arc(b.x, b.y, b.size * 0.4, 0, Math.PI * 2);
      ctx.fill();
      ctx.restore();
    }

    function drawParticle(p) {
      ctx.save();
      ctx.globalAlpha = p.life;
      ctx.shadowColor = p.color;
      ctx.shadowBlur = 10;
      ctx.fillStyle = p.color;
      ctx.beginPath();
      ctx.arc(p.x, p.y, p.size * p.life, 0, Math.PI * 2);
      ctx.fill();
      ctx.restore();
    }

    function drawWarning(w) {
      ctx.save();
      const progress = 1 - (w.life / w.maxLife);
      const pulse = Math.sin(Date.now() * 0.03) * 0.3 + 0.7;
      const radius = 20 + progress * 30;

      // Outer pulsing ring
      ctx.strokeStyle = w.color;
      ctx.lineWidth = 3;
      ctx.globalAlpha = pulse * (0.3 + progress * 0.7);
      ctx.shadowColor = w.color;
      ctx.shadowBlur = 20 + progress * 20;
      ctx.beginPath();
      ctx.arc(w.x, w.y, radius, 0, Math.PI * 2);
      ctx.stroke();

      // Inner expanding ring
      ctx.globalAlpha = (1 - progress) * 0.5;
      ctx.beginPath();
      ctx.arc(w.x, w.y, radius * 0.5, 0, Math.PI * 2);
      ctx.stroke();

      // Danger triangle
      ctx.globalAlpha = pulse;
      ctx.fillStyle = w.color;
      ctx.font = 'bold 16px Orbitron';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillText('!', w.x, w.y);

      // Direction line for edge spawns
      if (w.spawnX < 0 || w.spawnX > W || w.spawnY < 0 || w.spawnY > H) {
        const angle = Math.atan2(w.spawnY - w.y, w.spawnX - w.x);
        ctx.globalAlpha = 0.4 * pulse;
        ctx.beginPath();
        ctx.moveTo(w.x + Math.cos(angle) * 25, w.y + Math.sin(angle) * 25);
        ctx.lineTo(w.x + Math.cos(angle) * 45, w.y + Math.sin(angle) * 45);
        ctx.stroke();
      }

      ctx.restore();
    }

    function drawBackground() {
      // Grid
      ctx.strokeStyle = 'rgba(0,255,255,0.05)';
      ctx.lineWidth = 1;
      const gridSize = 60;
      const offsetX = (Date.now() * 0.02) % gridSize;
      const offsetY = (Date.now() * 0.01) % gridSize;

      for (let x = -gridSize + offsetX; x < W + gridSize; x += gridSize) {
        ctx.beginPath();
        ctx.moveTo(x, 0);
        ctx.lineTo(x, H);
        ctx.stroke();
      }
      for (let y = -gridSize + offsetY; y < H + gridSize; y += gridSize) {
        ctx.beginPath();
        ctx.moveTo(0, y);
        ctx.lineTo(W, y);
        ctx.stroke();
      }
    }

    function triggerDash() {
      if (player.cooldownTimer <= 0 && !player.isDashing) {
        player.isDashing = true;
        player.dashTimer = player.dashDuration;
        player.invincible = true;
        player.invincibleTimer = player.dashDuration + 5;
        spawnParticle(player.x, player.y, '#fff', 15);
      }
    }

    function update() {
      if (!gameRunning) return;

      // Player movement toward cursor
      if (isMoving) {
        const dx = targetX - player.x;
        const dy = targetY - player.y;
        const dist = Math.hypot(dx, dy);

        if (dist > 5) {
          // Update angle to face target
          player.angle = Math.atan2(dy, dx);

          // Move toward target
          const speed = player.isDashing ? player.dashSpeed : player.speed;
          const moveX = (dx / dist) * speed;
          const moveY = (dy / dist) * speed;

          player.x += moveX;
          player.y += moveY;
        }
      }

      // Bounds
      player.x = Math.max(player.size, Math.min(W - player.size, player.x));
      player.y = Math.max(player.size, Math.min(H - player.size, player.y));

      // Trail
      player.trail.push({ x: player.x, y: player.y, angle: player.angle });
      if (player.trail.length > (player.isDashing ? 20 : 10)) {
        player.trail.shift();
      }

      // Timers
      if (player.dashTimer > 0) {
        player.dashTimer--;
        if (player.dashTimer <= 0) {
          player.isDashing = false;
          player.cooldownTimer = player.dashCooldown;
        }
      }

      if (player.cooldownTimer > 0) {
        player.cooldownTimer--;
      }

      if (player.invincibleTimer > 0) {
        player.invincibleTimer--;
        if (player.invincibleTimer <= 0) {
          player.invincible = false;
        }
      }

      // Update dash UI
      const dashReady = player.cooldownTimer <= 0 ? 100 :
        ((player.dashCooldown - player.cooldownTimer) / player.dashCooldown) * 100;
      dashFill.style.width = dashReady + '%';

      // Spawn patterns
      const spawnRate = Math.max(30, 120 - wave * 10);
      spawnTimer++;
      if (spawnTimer >= spawnRate) {
        spawnTimer = 0;
        spawnPattern();
      }

      // Wave progression
      waveTimer++;
      if (waveTimer >= 600) { // 10 seconds per wave
        waveTimer = 0;
        wave++;
        waveEl.textContent = 'WAVE ' + wave;
        waveEl.style.animation = 'none';
        waveEl.offsetHeight;
        waveEl.style.animation = 'glow 0.5s ease-out';
      }

      // Update bullets
      for (let i = bullets.length - 1; i >= 0; i--) {
        const b = bullets[i];

        // Wave bullets oscillate
        if (b.wave) {
          b.time++;
          const wobble = Math.sin(b.time * 0.1) * 0.5;
          const perpAngle = b.baseAngle + Math.PI / 2;
          b.x += b.vx + Math.cos(perpAngle) * wobble;
          b.y += b.vy + Math.sin(perpAngle) * wobble;
        } else {
          b.x += b.vx;
          b.y += b.vy;
        }

        // Remove off-screen
        if (b.x < -50 || b.x > W + 50 || b.y < -50 || b.y > H + 50) {
          bullets.splice(i, 1);
          continue;
        }

        // Collision with player
        if (!player.invincible) {
          const dist = Math.hypot(b.x - player.x, b.y - player.y);
          if (dist < b.size + player.size * 0.6) {
            gameOver();
            return;
          }
        }
      }

      // Update particles
      for (let i = particles.length - 1; i >= 0; i--) {
        const p = particles[i];
        p.x += p.vx;
        p.y += p.vy;
        p.vx *= 0.95;
        p.vy *= 0.95;
        p.life -= 0.03;
        if (p.life <= 0) {
          particles.splice(i, 1);
        }
      }

      // Update warnings
      for (let i = warnings.length - 1; i >= 0; i--) {
        const w = warnings[i];
        w.life--;
        if (w.life <= 0) {
          // Spawn the actual bullets now
          w.patternFunc(w.spawnX, w.spawnY, w.color);
          warnings.splice(i, 1);
        }
      }

      // Score
      score += 1 + wave;
      scoreEl.textContent = score.toLocaleString();
    }

    function draw() {
      ctx.fillStyle = '#050510';
      ctx.fillRect(0, 0, W, H);

      drawBackground();

      if (gameRunning) {
        // Draw warnings first (behind everything)
        for (const w of warnings) {
          drawWarning(w);
        }

        drawTrail();

        for (const b of bullets) {
          drawBullet(b);
        }

        for (const p of particles) {
          drawParticle(p);
        }

        drawPlayer();

        // Draw target cursor when moving
        if (isMoving) {
          ctx.save();
          ctx.strokeStyle = '#0ff';
          ctx.lineWidth = 2;
          ctx.globalAlpha = 0.5;
          ctx.shadowColor = '#0ff';
          ctx.shadowBlur = 10;
          ctx.beginPath();
          ctx.arc(targetX, targetY, 12, 0, Math.PI * 2);
          ctx.stroke();
          ctx.beginPath();
          ctx.moveTo(targetX - 6, targetY);
          ctx.lineTo(targetX + 6, targetY);
          ctx.moveTo(targetX, targetY - 6);
          ctx.lineTo(targetX, targetY + 6);
          ctx.stroke();
          ctx.restore();
        }
      }
    }

    function gameLoop() {
      update();
      draw();
      requestAnimationFrame(gameLoop);
    }

    function startGame() {
      gameRunning = true;
      score = 0;
      wave = 1;
      waveTimer = 0;
      spawnTimer = 0;
      patternIndex = 0;
      bullets = [];
      particles = [];
      warnings = [];

      player.x = W / 2;
      player.y = H / 2;
      player.trail = [];
      player.dashTimer = 0;
      player.cooldownTimer = 0;
      player.isDashing = false;
      player.invincible = false;
      player.invincibleTimer = 0;

      scoreEl.textContent = '0';
      waveEl.textContent = 'WAVE 1';

      startScreen.classList.add('hidden');
      gameOverScreen.classList.add('hidden');
    }

    function gameOver() {
      gameRunning = false;
      spawnParticle(player.x, player.y, '#f00', 30);
      spawnParticle(player.x, player.y, '#ff0', 20);

      finalScoreEl.textContent = score.toLocaleString();
      finalWaveEl.textContent = 'Reached Wave ' + wave;

      setTimeout(() => {
        gameOverScreen.classList.remove('hidden');
      }, 500);
    }

    // Input handlers - mouse/touch based
    function handlePointerStart(x, y) {
      if (!gameRunning) return;

      const now = Date.now();
      if (now - lastClickTime < DOUBLE_CLICK_DELAY) {
        // Double click/tap - trigger dash
        triggerDash();
      }
      lastClickTime = now;

      isMoving = true;
      targetX = x;
      targetY = y;
    }

    function handlePointerMove(x, y) {
      if (!gameRunning || !isMoving) return;
      targetX = x;
      targetY = y;
    }

    function handlePointerEnd() {
      isMoving = false;
    }

    // Mouse events
    canvas.addEventListener('mousedown', e => {
      handlePointerStart(e.clientX, e.clientY);
    });

    canvas.addEventListener('mousemove', e => {
      handlePointerMove(e.clientX, e.clientY);
    });

    canvas.addEventListener('mouseup', handlePointerEnd);
    canvas.addEventListener('mouseleave', handlePointerEnd);

    // Touch events
    canvas.addEventListener('touchstart', e => {
      e.preventDefault();
      const touch = e.touches[0];
      handlePointerStart(touch.clientX, touch.clientY);
    });

    canvas.addEventListener('touchmove', e => {
      e.preventDefault();
      const touch = e.touches[0];
      handlePointerMove(touch.clientX, touch.clientY);
    });

    canvas.addEventListener('touchend', e => {
      e.preventDefault();
      handlePointerEnd();
    });

    // Start buttons
    document.getElementById('startBtn').addEventListener('click', startGame);
    document.getElementById('restartBtn').addEventListener('click', startGame);

    // Init
    player.x = W / 2;
    player.y = H / 2;
    gameLoop();
  </script>
<script src="/apps/sloppy-header/sloppy-bar.js"></script>
<script src="/vibelib-extended.js"></script>
<script>
  // Compatibility Patch for Legacy Apps
  window.addEventListener("load", () => {
    if (window.SloppyKarma && window.VibeLib.Economy) {
      // Redirect old calls to new engine
      window.SloppyKarma.track = window.VibeLib.Economy.track;
    }
  });
</script>
</body>
</html>
