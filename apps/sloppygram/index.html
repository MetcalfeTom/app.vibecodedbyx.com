<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>The Archive of Synthesis</title>
    <link rel="icon" href="https://emojicdn.elk.sh/ðŸ’¾">

    <!-- Open Graph -->
    <meta property="og:title" content="The Archive of Synthesis">
    <meta property="og:description" content="From chaos to crystalline harmony. A living archive where ideas converge, synthesize, and transcend.">
    <meta property="og:url" content="https://sloppy.live/sloppygram">
    <meta property="og:image" content="https://image.pollinations.ai/prompt/cyberpunk%20neon%20chatroom%20interface%20glowing%20magenta%20cyan%20green%20terminals%20dark%20background%20retro%20hacker%20aesthetic%20vaporwave%20grid%201999?width=1200&height=630&nologo=true&referrer=sloppy.live">
    <meta property="og:type" content="website">
    <meta property="og:site_name" content="Sloppy.live">

    <!-- Twitter Card -->
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:title" content="The Archive of Synthesis">
    <meta name="twitter:description" content="From chaos to crystalline harmony. A living archive where ideas converge, synthesize, and transcend.">
    <meta name="twitter:image" content="https://image.pollinations.ai/prompt/cyberpunk%20neon%20chatroom%20interface%20glowing%20magenta%20cyan%20green%20terminals%20dark%20background%20retro%20hacker%20aesthetic%20vaporwave%20grid%201999?width=1200&height=630&nologo=true&referrer=sloppy.live">

    <!-- Additional Meta -->
    <meta name="description" content="From chaos to crystalline harmony. A living archive where ideas converge, synthesize, and transcend.">
    <meta name="theme-color" content="#0a0a0f">

    <link href="https://fonts.googleapis.com/css2?family=VT323&family=Share+Tech+Mono&display=swap" rel="stylesheet">

    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        :root {
            --accent: #7c9885;
            --accent-light: #a8c4b0;
            --accent-dim: #5a7060;
            --highlight: #c9a87c;
            --dark-bg: #0a0a0f;
            --panel-bg: #12121a;
            --border-color: #2a2a35;
            --text-dim: #6a6a75;
            --msg-opacity: 0.95;
            --msg-color: 10, 10, 15;
            --msg-own-color: 90, 112, 96;
            --widget-opacity: 1;
        }

        body {
            font-family: 'VT323', monospace;
            background: var(--dark-bg);
            min-height: 100vh;
            color: var(--accent);
            overflow: hidden;
        }

        /* Scanline effect */
        body::before {
            content: '';
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: repeating-linear-gradient(
                0deg,
                rgba(0, 0, 0, 0.15),
                rgba(0, 0, 0, 0.15) 1px,
                transparent 1px,
                transparent 2px
            );
            pointer-events: none;
            z-index: 9999;
        }

        .app {
            display: grid;
            grid-template-columns: 200px 1fr 180px;
            grid-template-rows: auto 1fr;
            height: 100vh;
            gap: 1px;
            background: transparent;
        }

        /* Hide sidebar close buttons on desktop */
        .sidebar-close-btn {
            display: none;
        }

        @media (max-width: 768px) {
            .app {
                display: flex;
                flex-direction: column;
                height: 100vh;
                height: 100dvh;
                width: 100%;
                max-width: 100vw;
                overflow-x: hidden;
                padding-top: env(safe-area-inset-top, 0);
                padding-bottom: env(safe-area-inset-bottom, 0);
                padding-left: env(safe-area-inset-left, 0);
                padding-right: env(safe-area-inset-right, 0);
            }

            .sidebar-close-btn {
                display: flex;
                align-items: center;
                justify-content: center;
                width: 30px;
                height: 30px;
                position: absolute;
                top: 8px;
                right: 8px;
                background: var(--border-color);
                border: none;
                color: var(--accent);
                font-size: 1.2rem;
                cursor: pointer;
                border-radius: 4px;
                z-index: 10;
            }

            .sidebar-close-btn:hover {
                background: var(--accent-dim);
            }

            .drawer-header {
                display: flex;
                justify-content: space-between;
                align-items: center;
                padding-bottom: 12px;
                border-bottom: 1px solid var(--border-color);
                margin-bottom: 12px;
            }

            .drawer-header .panel-title {
                margin: 0;
            }

            .drawer-header .sidebar-close-btn {
                position: static;
            }

            .drawer-footer {
                margin-top: auto;
                padding-top: 12px;
                border-top: 1px solid var(--border-color);
            }

            .stream-link {
                color: var(--text-dim);
                text-decoration: none;
                font-size: 0.85rem;
                display: block;
                padding: 8px;
                text-align: center;
                transition: color 0.2s;
            }

            .stream-link:hover {
                color: var(--accent);
            }

            .mobile-backdrop {
                display: none;
                position: fixed;
                top: 60px;
                left: 0;
                right: 0;
                bottom: 0;
                background: rgba(0, 0, 0, 0.6);
                z-index: 100;
            }

            .mobile-backdrop.active {
                display: block;
            }
        }

        /* Header */
        .header {
            grid-column: 1 / -1;
            grid-row: 1;
            background: var(--panel-bg);
            padding: 8px 16px;
            display: flex;
            align-items: center;
            justify-content: space-between;
            flex-shrink: 0;
            min-height: 50px;
            z-index: 10;
            position: relative;
        }

        .logo {
            font-size: 1.8rem;
            color: var(--accent-light);
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .logo-blink {
            animation: blink 1s infinite;
        }

        @keyframes blink {
            0%, 50% { opacity: 1; }
            51%, 100% { opacity: 0; }
        }

        .marquee-container {
            flex: 1;
            overflow: hidden;
            margin: 0 20px;
            color: var(--highlight);
            font-size: 1.1rem;
        }

        .marquee {
            display: inline-block;
            white-space: nowrap;
            animation: marquee 20s linear infinite;
            background: linear-gradient(
                90deg,
                var(--highlight) 0%,
                var(--highlight) 40%,
                #fff 50%,
                var(--highlight) 60%,
                var(--highlight) 100%
            );
            background-size: 200% 100%;
            -webkit-background-clip: text;
            background-clip: text;
            -webkit-text-fill-color: transparent;
            animation: marquee 20s linear infinite, shimmer 3s ease-in-out infinite;
        }

        .marquee .diamond {
            display: inline-block;
            animation: glint 2s ease-in-out infinite;
            -webkit-text-fill-color: var(--accent);
        }

        .marquee .diamond:nth-child(2) { animation-delay: 0.3s; }
        .marquee .diamond:nth-child(3) { animation-delay: 0.6s; }
        .marquee .diamond:nth-child(4) { animation-delay: 0.9s; }
        .marquee .diamond:nth-child(5) { animation-delay: 1.2s; }

        @keyframes marquee {
            from { transform: translateX(100%); }
            to { transform: translateX(-100%); }
        }

        @keyframes shimmer {
            0%, 100% { background-position: 200% center; }
            50% { background-position: 0% center; }
        }

        @keyframes glint {
            0%, 100% { opacity: 0.7; transform: scale(1); }
            50% { opacity: 1; transform: scale(1.2); filter: drop-shadow(0 0 4px var(--accent)); }
        }

        .header-actions {
            display: flex;
            gap: 8px;
        }

        .cyber-btn {
            background: transparent;
            border: 1px solid var(--border-color);
            color: var(--accent);
            padding: 6px 12px;
            font-family: inherit;
            font-size: 1rem;
            cursor: pointer;
            transition: all 0.2s;
        }

        .cyber-btn:hover {
            background: var(--accent-dim);
            color: white;
        }

        .reboot-btn {
            background: transparent;
            border: 1px solid #00ff00;
            color: #00ff00;
            padding: 6px 10px;
            font-size: 1.1rem;
            cursor: pointer;
            transition: all 0.2s;
            position: relative;
        }

        .reboot-btn:hover {
            background: rgba(0, 255, 0, 0.1);
            animation: rebootBtnGlitch 0.3s infinite;
            text-shadow: 0 0 5px #00ff00;
        }

        @keyframes rebootBtnGlitch {
            0%, 100% { transform: translate(0); }
            25% { transform: translate(-1px, 1px); }
            50% { transform: translate(1px, -1px); }
            75% { transform: translate(-1px, -1px); }
        }

        /* === SUPPORT MODAL SYSTEM === */
        .support-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0,0,0,0.92);
            z-index: 2000;
            align-items: center;
            justify-content: center;
            backdrop-filter: blur(6px);
            overflow-y: auto;
            padding: 20px;
        }

        .support-modal.visible {
            display: flex;
        }

        .support-modal-content {
            background: linear-gradient(145deg, #0a0a0a 0%, #151515 100%);
            border: 2px solid var(--accent);
            border-radius: 12px;
            padding: 24px;
            max-width: 600px;
            width: 100%;
            box-shadow: 0 0 60px rgba(0, 255, 136, 0.1);
            max-height: 90vh;
            overflow-y: auto;
        }

        .support-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            padding-bottom: 16px;
            border-bottom: 1px solid var(--border-color);
        }

        .support-header h2 {
            color: var(--accent);
            font-size: 1.4rem;
            margin: 0;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .support-close {
            background: transparent;
            border: none;
            color: var(--text-dim);
            font-size: 1.8rem;
            cursor: pointer;
            padding: 4px 8px;
            line-height: 1;
            transition: color 0.2s;
        }

        .support-close:hover {
            color: #ff4444;
        }

        .support-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 14px;
            margin-bottom: 16px;
        }

        @media (max-width: 550px) {
            .support-grid {
                grid-template-columns: 1fr;
            }
            .support-modal-content {
                padding: 16px;
            }
        }

        .support-option {
            background: #0d0d0d;
            border: 1px solid var(--border-color);
            border-radius: 8px;
            padding: 14px;
            text-align: center;
            transition: all 0.2s;
            cursor: pointer;
        }

        .support-option:hover {
            transform: translateY(-2px);
        }

        /* Crypto-specific colors */
        .support-option.btc { border-color: #f7931a; }
        .support-option.btc:hover { box-shadow: 0 4px 20px rgba(247, 147, 26, 0.25); }
        .support-option.btc .support-icon { color: #f7931a; }

        .support-option.eth { border-color: #627eea; }
        .support-option.eth:hover { box-shadow: 0 4px 20px rgba(98, 126, 234, 0.25); }
        .support-option.eth .support-icon { color: #627eea; }

        .support-option.sol { border-color: #14f195; }
        .support-option.sol:hover { box-shadow: 0 4px 20px rgba(20, 241, 149, 0.25); }
        .support-option.sol .support-icon { color: #14f195; }

        .support-option.xmr { border-color: #ff6600; }
        .support-option.xmr:hover { box-shadow: 0 4px 20px rgba(255, 102, 0, 0.25); }
        .support-option.xmr .support-icon { color: #ff6600; }

        .support-option.stripe { border-color: #635bff; }
        .support-option.stripe:hover { box-shadow: 0 4px 20px rgba(99, 91, 255, 0.25); }

        .support-icon {
            font-size: 1.8rem;
            margin-bottom: 6px;
        }

        .support-option h3 {
            color: var(--text);
            font-size: 0.9rem;
            margin-bottom: 10px;
            font-weight: bold;
        }

        .crypto-address {
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.55rem;
            background: #050505;
            padding: 8px;
            border-radius: 4px;
            word-break: break-all;
            cursor: pointer;
            border: 1px dashed currentColor;
            transition: all 0.2s;
            opacity: 0.9;
        }

        .support-option.btc .crypto-address { color: #f7931a; }
        .support-option.eth .crypto-address { color: #627eea; }
        .support-option.sol .crypto-address { color: #14f195; }
        .support-option.xmr .crypto-address { color: #ff6600; }

        .crypto-address:hover {
            background: #111;
            border-style: solid;
            opacity: 1;
        }

        .copy-hint {
            font-size: 0.65rem;
            color: var(--text-dim);
            margin-top: 6px;
            opacity: 0.7;
        }

        /* Fiat Section */
        .support-section-label {
            font-size: 0.75rem;
            color: var(--text-dim);
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-bottom: 12px;
            padding-bottom: 6px;
            border-bottom: 1px dashed var(--border-color);
        }

        .fiat-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 10px;
            margin-bottom: 20px;
        }

        @media (max-width: 550px) {
            .fiat-grid {
                grid-template-columns: 1fr;
            }
        }

        .fiat-btn {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            padding: 12px 16px;
            border-radius: 6px;
            font-weight: bold;
            font-size: 0.85rem;
            text-decoration: none;
            transition: all 0.2s;
            border: none;
            cursor: pointer;
        }

        .fiat-btn:hover {
            transform: translateY(-2px);
        }

        .fiat-btn.kofi {
            background: linear-gradient(135deg, #ff5e5b 0%, #ff4444 100%);
            color: white;
        }
        .fiat-btn.kofi:hover {
            box-shadow: 0 4px 15px rgba(255, 94, 91, 0.4);
        }

        .fiat-btn.paypal {
            background: linear-gradient(135deg, #003087 0%, #001f5c 100%);
            color: white;
        }
        .fiat-btn.paypal:hover {
            box-shadow: 0 4px 15px rgba(0, 48, 135, 0.4);
        }

        .fiat-btn.patreon {
            background: linear-gradient(135deg, #ff424d 0%, #e63946 100%);
            color: white;
        }
        .fiat-btn.patreon:hover {
            box-shadow: 0 4px 15px rgba(255, 66, 77, 0.4);
        }

        .stripe-btn {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            background: linear-gradient(135deg, #635bff 0%, #7c3aed 100%);
            color: white;
            padding: 12px 24px;
            text-decoration: none;
            border-radius: 6px;
            font-weight: bold;
            font-size: 0.9rem;
            border: none;
            cursor: pointer;
            transition: all 0.2s;
            width: 100%;
        }

        .stripe-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(99, 91, 255, 0.4);
        }

        .support-footer {
            text-align: center;
            color: var(--text-dim);
            font-size: 0.75rem;
            padding-top: 12px;
            border-top: 1px solid var(--border-color);
        }

        .copied-toast {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: linear-gradient(135deg, #f7931a 0%, #ff6b00 100%);
            color: #000;
            padding: 12px 20px;
            border-radius: 6px;
            font-weight: bold;
            z-index: 3000;
            display: flex;
            align-items: center;
            gap: 8px;
            animation: toastSlide 2.5s forwards;
            box-shadow: 0 4px 20px rgba(247, 147, 26, 0.4);
        }

        @keyframes toastSlide {
            0% { opacity: 0; transform: translateX(-50%) translateY(20px); }
            10% { opacity: 1; transform: translateX(-50%) translateY(0); }
            80% { opacity: 1; transform: translateX(-50%) translateY(0); }
            100% { opacity: 0; transform: translateX(-50%) translateY(-10px); }
        }

        .donate-btn {
            background: linear-gradient(135deg, #f7931a 0%, #ff6b00 100%);
            border: none;
            color: #000;
            padding: 6px 12px;
            font-size: 0.9rem;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.2s;
            border-radius: 4px;
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .donate-btn:hover {
            box-shadow: 0 0 12px rgba(247, 147, 26, 0.5);
            transform: scale(1.02);
        }

        /* Image Lightbox */
        .lightbox {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.95);
            z-index: 10000;
            justify-content: center;
            align-items: center;
            cursor: pointer;
        }

        .lightbox.active {
            display: flex;
        }

        .lightbox-image {
            max-width: 90%;
            max-height: 90%;
            object-fit: contain;
            border: 2px solid var(--accent);
            box-shadow: 0 0 30px rgba(0, 255, 136, 0.5), 0 0 60px rgba(0, 255, 136, 0.3);
            animation: lightboxFadeIn 0.3s ease-out;
        }

        .lightbox-close {
            position: absolute;
            top: 20px;
            right: 30px;
            font-size: 2.5rem;
            color: var(--accent);
            background: none;
            border: none;
            cursor: pointer;
            text-shadow: 0 0 10px var(--accent);
            transition: all 0.2s;
        }

        .lightbox-close:hover {
            color: #fff;
            transform: scale(1.2);
        }

        @keyframes lightboxFadeIn {
            from {
                opacity: 0;
                transform: scale(0.8);
            }
            to {
                opacity: 1;
                transform: scale(1);
            }
        }

        /* Share Modal - Glassmorphism */
        .share-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.7);
            backdrop-filter: blur(8px);
            -webkit-backdrop-filter: blur(8px);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 2000;
            opacity: 0;
            visibility: hidden;
            transition: all 0.3s ease;
        }

        .share-modal.visible {
            opacity: 1;
            visibility: visible;
        }

        .share-modal-content {
            background: rgba(18, 18, 26, 0.85);
            backdrop-filter: blur(20px);
            -webkit-backdrop-filter: blur(20px);
            border: 1px solid rgba(124, 152, 133, 0.3);
            border-radius: 16px;
            padding: 28px;
            width: 90%;
            max-width: 380px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.5);
            transform: translateY(20px);
            transition: transform 0.3s ease;
        }

        .share-modal.visible .share-modal-content {
            transform: translateY(0);
        }

        .share-modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 24px;
        }

        .share-modal-title {
            font-size: 1.4rem;
            color: var(--accent-light);
            letter-spacing: 1px;
        }

        .share-modal-close {
            background: none;
            border: none;
            color: var(--text-dim);
            font-size: 1.5rem;
            cursor: pointer;
            padding: 4px 8px;
            transition: color 0.2s;
        }

        .share-modal-close:hover {
            color: var(--accent);
        }

        .share-buttons {
            display: flex;
            flex-direction: column;
            gap: 12px;
        }

        .share-btn {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 12px;
            padding: 14px 20px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 12px;
            font-size: 1rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.25s ease;
            text-decoration: none;
            background: rgba(255, 255, 255, 0.05);
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
        }

        .share-btn:hover {
            transform: translateY(-2px);
            border-color: rgba(255, 255, 255, 0.2);
        }

        .share-btn.x-twitter {
            color: #fff;
            background: linear-gradient(135deg, rgba(0, 0, 0, 0.6) 0%, rgba(30, 30, 30, 0.6) 100%);
        }
        .share-btn.x-twitter:hover {
            box-shadow: 0 4px 20px rgba(255, 255, 255, 0.15);
            background: linear-gradient(135deg, rgba(20, 20, 20, 0.8) 0%, rgba(50, 50, 50, 0.8) 100%);
        }

        .share-btn.reddit {
            color: #ff4500;
            background: linear-gradient(135deg, rgba(255, 69, 0, 0.1) 0%, rgba(255, 69, 0, 0.05) 100%);
        }
        .share-btn.reddit:hover {
            box-shadow: 0 4px 20px rgba(255, 69, 0, 0.25);
            background: linear-gradient(135deg, rgba(255, 69, 0, 0.2) 0%, rgba(255, 69, 0, 0.1) 100%);
        }

        .share-btn.copy-link {
            color: var(--accent);
            background: linear-gradient(135deg, rgba(124, 152, 133, 0.1) 0%, rgba(124, 152, 133, 0.05) 100%);
        }
        .share-btn.copy-link:hover {
            box-shadow: 0 4px 20px rgba(124, 152, 133, 0.25);
            background: linear-gradient(135deg, rgba(124, 152, 133, 0.2) 0%, rgba(124, 152, 133, 0.1) 100%);
        }

        .share-btn-icon {
            font-size: 1.3rem;
            width: 28px;
            text-align: center;
        }

        .share-btn.copied {
            background: linear-gradient(135deg, rgba(0, 255, 65, 0.2) 0%, rgba(0, 255, 65, 0.1) 100%) !important;
            color: #00ff41 !important;
            border-color: rgba(0, 255, 65, 0.3) !important;
        }

        .share-btn {
            font-family: 'VT323', monospace;
        }

        /* Sidebars */
        .sidebar-left, .sidebar-right {
            grid-row: 2;
            background: var(--panel-bg);
            padding: 12px;
            overflow-y: auto;
            display: flex;
            flex-direction: column;
        }

        /* Mobile: completely hide sidebars when not active */
        @media (max-width: 768px) {
            .sidebar-left, .sidebar-right {
                display: none;
                position: fixed;
                top: 60px;
                bottom: 0;
                width: 75%;
                max-width: 280px;
                z-index: 101;
                box-shadow: 0 0 20px rgba(0,0,0,0.5);
            }
            .sidebar-left.mobile-show, .sidebar-right.mobile-show {
                display: flex;
            }
            .sidebar-left.mobile-show { left: 0; }
            .sidebar-right.mobile-show { right: 0; }

            .main-content {
                width: 100%;
                flex: 1;
                min-height: 0;
                overflow: hidden;
                display: flex;
                flex-direction: column;
            }

            .input-area {
                flex-shrink: 0;
                position: sticky;
                top: 0;
                z-index: 10;
                background: var(--panel-bg);
            }

            .messages-container,
            .posts-container,
            .doodles-container,
            .manifesto-container {
                flex: 1;
                min-height: 0;
                max-height: none;
                overflow-y: auto;
                -webkit-overflow-scrolling: touch;
                width: 100%;
                padding: 8px;
                box-sizing: border-box;
            }

            .view-tabs {
                flex-shrink: 0;
                width: 100%;
            }

            .input-area {
                width: 100%;
                padding: 8px;
                box-sizing: border-box;
            }

            .input-row {
                width: 100%;
                max-width: 100%;
            }

            .message, .post, .doodle-card, .manifesto-item {
                width: 100%;
                max-width: 100%;
                box-sizing: border-box;
            }

            /* Prevent iOS auto-zoom on inputs */
            input, textarea, select {
                font-size: 16px !important;
            }
        }

        #publicFeed {
            max-height: 40vh;
            overflow-y: auto;
            flex-shrink: 1;
        }

        .panel-title {
            color: var(--highlight);
            font-size: 1.2rem;
            margin-bottom: 10px;
            padding-bottom: 6px;
            border-bottom: 1px solid var(--border-color);
        }

        /* Online Users */
        .user-list {
            list-style: none;
        }

        .user-item {
            padding: 6px 8px;
            margin-bottom: 4px;
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 1rem;
            border-left: 2px solid transparent;
            transition: all 0.2s;
        }

        .user-item:hover {
            background: rgba(255, 255, 255, 0.05);
            border-left-color: var(--accent);
        }

        .user-status {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: var(--accent);
            animation: pulse 2s infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        .user-avatar {
            font-size: 1.2rem;
        }

        .user-name {
            color: var(--accent-light);
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        .user-away-status {
            font-size: 0.75rem;
            color: var(--text-dim);
            font-style: italic;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
            max-width: 120px;
        }

        .user-item-content {
            display: flex;
            flex-direction: column;
            overflow: hidden;
            flex: 1;
        }

        /* Away Status Input */
        .away-status-section {
            padding: 12px;
            border-bottom: 1px solid var(--border-color);
            margin-bottom: 8px;
        }

        .away-status-input-wrapper {
            display: flex;
            gap: 8px;
            align-items: center;
        }

        .away-status-input {
            flex: 1;
            background: var(--dark-bg);
            border: 1px solid var(--border-color);
            color: var(--accent-light);
            padding: 6px 10px;
            font-family: inherit;
            font-size: 0.85rem;
            border-radius: 4px;
            outline: none;
        }

        .away-status-input:focus {
            border-color: var(--accent);
            box-shadow: 0 0 8px rgba(0, 255, 136, 0.2);
        }

        .away-status-input::placeholder {
            color: var(--text-dim);
            font-style: italic;
        }

        .away-status-btn {
            background: var(--accent);
            color: var(--dark-bg);
            border: none;
            padding: 6px 12px;
            font-family: inherit;
            font-size: 0.8rem;
            font-weight: bold;
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .away-status-btn:hover {
            filter: brightness(1.2);
        }

        .away-status-current {
            margin-top: 8px;
            font-size: 0.8rem;
            color: var(--text-dim);
        }

        .away-status-current .status-text {
            color: var(--accent-light);
            font-style: italic;
        }

        .clear-status-btn {
            background: none;
            border: none;
            color: #ff6666;
            cursor: pointer;
            font-size: 0.75rem;
            margin-left: 8px;
        }

        .clear-status-btn:hover {
            text-decoration: underline;
        }

        /* Tag Cloud */
        .tag-cloud-section {
            margin-top: 16px;
            padding-top: 16px;
            border-top: 1px solid var(--border-color);
        }

        .tag-cloud-section .panel-title {
            margin-bottom: 12px;
        }

        .tag-cloud {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            align-items: center;
            justify-content: center;
            min-height: 60px;
            padding: 8px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            border: 1px solid var(--border-color);
        }

        .tag-cloud-empty {
            color: var(--text-dim);
            font-size: 0.85rem;
            font-style: italic;
        }

        .tag-cloud-item {
            display: inline-block;
            padding: 4px 10px;
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.3s ease;
            text-shadow: 0 0 8px currentColor;
            animation: tagPulse 3s ease-in-out infinite;
            animation-delay: var(--pulse-delay, 0s);
        }

        .tag-cloud-item:hover {
            transform: scale(1.15);
            filter: brightness(1.3);
        }

        /* Neon color palette for tags */
        .tag-cloud-item.neon-cyan {
            color: #00ffff;
            background: rgba(0, 255, 255, 0.15);
            border: 1px solid rgba(0, 255, 255, 0.4);
            box-shadow: 0 0 10px rgba(0, 255, 255, 0.3), inset 0 0 10px rgba(0, 255, 255, 0.1);
        }

        .tag-cloud-item.neon-magenta {
            color: #ff00ff;
            background: rgba(255, 0, 255, 0.15);
            border: 1px solid rgba(255, 0, 255, 0.4);
            box-shadow: 0 0 10px rgba(255, 0, 255, 0.3), inset 0 0 10px rgba(255, 0, 255, 0.1);
        }

        .tag-cloud-item.neon-green {
            color: #00ff88;
            background: rgba(0, 255, 136, 0.15);
            border: 1px solid rgba(0, 255, 136, 0.4);
            box-shadow: 0 0 10px rgba(0, 255, 136, 0.3), inset 0 0 10px rgba(0, 255, 136, 0.1);
        }

        .tag-cloud-item.neon-yellow {
            color: #ffff00;
            background: rgba(255, 255, 0, 0.15);
            border: 1px solid rgba(255, 255, 0, 0.4);
            box-shadow: 0 0 10px rgba(255, 255, 0, 0.3), inset 0 0 10px rgba(255, 255, 0, 0.1);
        }

        .tag-cloud-item.neon-orange {
            color: #ff8800;
            background: rgba(255, 136, 0, 0.15);
            border: 1px solid rgba(255, 136, 0, 0.4);
            box-shadow: 0 0 10px rgba(255, 136, 0, 0.3), inset 0 0 10px rgba(255, 136, 0, 0.1);
        }

        .tag-cloud-item.neon-pink {
            color: #ff66b2;
            background: rgba(255, 102, 178, 0.15);
            border: 1px solid rgba(255, 102, 178, 0.4);
            box-shadow: 0 0 10px rgba(255, 102, 178, 0.3), inset 0 0 10px rgba(255, 102, 178, 0.1);
        }

        /* Size classes based on frequency */
        .tag-cloud-item.size-1 { font-size: 0.75rem; }
        .tag-cloud-item.size-2 { font-size: 0.9rem; }
        .tag-cloud-item.size-3 { font-size: 1.05rem; }
        .tag-cloud-item.size-4 { font-size: 1.2rem; }
        .tag-cloud-item.size-5 { font-size: 1.4rem; font-weight: bold; }

        @keyframes tagPulse {
            0%, 100% { opacity: 0.9; }
            50% { opacity: 1; text-shadow: 0 0 12px currentColor, 0 0 20px currentColor; }
        }

        @keyframes tagAppear {
            from {
                opacity: 0;
                transform: scale(0.5);
            }
            to {
                opacity: 1;
                transform: scale(1);
            }
        }

        /* Tag Explorer Modal */
        .tag-explorer-modal .modal {
            max-width: 500px;
        }

        .tag-explorer-header {
            display: flex;
            align-items: center;
            gap: 12px;
            margin-bottom: 20px;
        }

        .tag-explorer-tag {
            font-size: 2rem;
            font-weight: bold;
            background: linear-gradient(135deg, var(--accent), var(--secondary));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .tag-explorer-stats {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 12px;
            margin-bottom: 20px;
        }

        .tag-stat {
            background: rgba(0, 255, 65, 0.05);
            border: 1px solid var(--border-color);
            padding: 12px;
            text-align: center;
        }

        .tag-stat-count {
            font-size: 1.5rem;
            font-weight: bold;
            color: var(--accent-light);
        }

        .tag-stat-label {
            font-size: 0.7rem;
            color: var(--text-dim);
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .tag-explorer-section {
            margin-bottom: 20px;
        }

        .tag-explorer-section h3 {
            font-size: 0.85rem;
            color: var(--accent);
            margin-bottom: 12px;
            text-transform: uppercase;
            letter-spacing: 1px;
            border-bottom: 1px solid var(--border-color);
            padding-bottom: 6px;
        }

        .tag-users {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
        }

        .tag-user {
            display: flex;
            align-items: center;
            gap: 6px;
            background: rgba(0, 255, 65, 0.08);
            border: 1px solid var(--border-color);
            padding: 6px 10px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .tag-user:hover {
            background: rgba(0, 255, 65, 0.15);
            border-color: var(--accent);
        }

        .tag-user-avatar {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.75rem;
            overflow: hidden;
        }

        .tag-user-avatar img {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        .tag-user-name {
            font-size: 0.8rem;
            color: var(--accent-light);
        }

        .tag-user-count {
            font-size: 0.7rem;
            color: var(--text-dim);
        }

        .tag-content-list {
            max-height: 200px;
            overflow-y: auto;
        }

        .tag-content-item {
            padding: 10px;
            border-bottom: 1px solid var(--border-color);
            display: flex;
            gap: 10px;
        }

        .tag-content-item:last-child {
            border-bottom: none;
        }

        .tag-content-avatar {
            width: 28px;
            height: 28px;
            border-radius: 50%;
            flex-shrink: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.85rem;
            overflow: hidden;
        }

        .tag-content-avatar img {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        .tag-content-body {
            flex: 1;
            min-width: 0;
        }

        .tag-content-username {
            font-size: 0.75rem;
            color: var(--accent);
            font-weight: bold;
        }

        .tag-content-type {
            font-size: 0.65rem;
            color: var(--text-dim);
            margin-left: 6px;
        }

        .tag-content-text {
            font-size: 0.8rem;
            color: var(--accent-light);
            margin-top: 4px;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        .tag-explorer-loading {
            text-align: center;
            padding: 40px;
            color: var(--text-dim);
        }

        .tag-explorer-empty {
            text-align: center;
            padding: 20px;
            color: var(--text-dim);
            font-size: 0.85rem;
        }

        .tag-explorer-tabs {
            display: flex;
            gap: 8px;
            margin-bottom: 16px;
            border-bottom: 1px solid var(--border-color);
            padding-bottom: 12px;
        }

        .tag-tab {
            background: transparent;
            border: 1px solid var(--border-color);
            color: var(--text-dim);
            padding: 8px 16px;
            cursor: pointer;
            font-family: inherit;
            font-size: 0.85rem;
            transition: all 0.2s;
        }

        .tag-tab:hover {
            border-color: var(--accent);
            color: var(--accent-light);
        }

        .tag-tab.active {
            background: rgba(0, 255, 65, 0.1);
            border-color: var(--accent);
            color: var(--accent);
        }

        .tag-explorer-tab-content {
            max-height: 400px;
            overflow-y: auto;
        }

        .tag-explorer-posts .post-card,
        .tag-explorer-manifestos .manifesto-card {
            margin-bottom: 12px;
        }

        .tag-explorer-message {
            display: flex;
            align-items: flex-start;
            gap: 10px;
            padding: 10px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            margin-bottom: 10px;
            border-left: 3px solid var(--accent-color, #0ff);
        }

        .tag-explorer-message .avatar {
            width: 36px;
            height: 36px;
            min-width: 36px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.4em;
            background: rgba(0, 0, 0, 0.4);
            border-radius: 50%;
            overflow: hidden;
        }

        .tag-explorer-message .tag-msg-bubble {
            flex: 1;
            min-width: 0;
        }

        .tag-explorer-message .tag-msg-header {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 4px;
        }

        .tag-explorer-message .msg-username {
            color: var(--accent-color, #0ff);
            cursor: pointer;
            font-weight: bold;
        }

        .tag-explorer-message .msg-username:hover {
            text-decoration: underline;
        }

        .tag-explorer-message .msg-time {
            font-size: 0.75em;
            opacity: 0.5;
        }

        .tag-explorer-message .msg-content {
            word-break: break-word;
            line-height: 1.4;
        }

        .tag-explorer-post, .tag-explorer-manifesto {
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            padding: 12px;
            margin-bottom: 12px;
            border-left: 3px solid var(--accent-color, #0ff);
        }

        .tag-post-header, .tag-manifesto-header {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 10px;
        }

        .tag-post-image {
            width: 100%;
            max-height: 200px;
            object-fit: cover;
            border-radius: 6px;
            margin-bottom: 8px;
            cursor: pointer;
        }

        .tag-post-caption {
            font-size: 0.95em;
            line-height: 1.4;
            opacity: 0.9;
        }

        .tag-manifesto-title {
            font-weight: bold;
            font-size: 1.1em;
            margin-bottom: 6px;
            color: var(--accent-color, #0ff);
        }

        .tag-manifesto-content {
            font-size: 0.9em;
            line-height: 1.4;
            opacity: 0.8;
            margin-bottom: 8px;
        }

        .tag-manifesto-votes {
            font-size: 0.85em;
            color: #4f4;
            opacity: 0.9;
        }

        .tag-filter-btn {
            background: linear-gradient(135deg, var(--accent-dim), var(--accent)) !important;
            border: 2px solid var(--accent-color, #0ff) !important;
            font-weight: bold;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .tag-filter-btn:hover {
            box-shadow: 0 0 15px var(--accent-color, #0ff);
            transform: translateY(-1px);
        }

        .tag-explorer-modal .modal {
            max-width: 600px;
            max-height: 90vh;
            overflow-y: auto;
        }

        .tag-cloud-item.new-tag {
            animation: tagAppear 0.4s ease-out, tagPulse 3s ease-in-out infinite 0.4s;
        }

        /* Feedback Hub Integration */
        .feedback-container {
            display: none;
            padding: 16px;
            height: calc(100vh - 200px);
            overflow-y: auto;
        }

        .feedback-container.active {
            display: block;
        }

        .feedback-stats {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 10px;
            margin-bottom: 16px;
        }

        .feedback-stat {
            background: rgba(0, 255, 65, 0.05);
            border: 1px solid var(--border-color);
            padding: 12px;
            text-align: center;
        }

        .feedback-stat-num {
            font-size: 1.4rem;
            font-weight: bold;
            color: var(--accent-light);
        }

        .feedback-stat-label {
            font-size: 0.65rem;
            color: var(--text-dim);
            text-transform: uppercase;
        }

        .feedback-filters {
            display: flex;
            gap: 6px;
            margin-bottom: 16px;
            flex-wrap: wrap;
        }

        .feedback-filter {
            padding: 6px 12px;
            background: rgba(0, 255, 65, 0.05);
            border: 1px solid var(--border-color);
            color: var(--text-dim);
            font-size: 0.75rem;
            cursor: pointer;
            transition: all 0.2s;
        }

        .feedback-filter:hover {
            background: rgba(0, 255, 65, 0.1);
        }

        .feedback-filter.active {
            background: rgba(0, 255, 65, 0.15);
            border-color: var(--accent);
            color: var(--accent-light);
        }

        .feedback-new-btn {
            width: 100%;
            padding: 12px;
            background: linear-gradient(135deg, var(--accent), var(--secondary));
            border: none;
            color: #000;
            font-weight: bold;
            cursor: pointer;
            margin-bottom: 16px;
            font-size: 0.85rem;
        }

        .feedback-new-btn:hover {
            opacity: 0.9;
        }

        .feedback-form {
            background: rgba(0, 255, 65, 0.03);
            border: 1px solid var(--border-color);
            padding: 16px;
            margin-bottom: 16px;
            display: none;
        }

        .feedback-form.active {
            display: block;
        }

        .feedback-form input,
        .feedback-form textarea {
            width: 100%;
            padding: 10px;
            background: var(--dark-bg);
            border: 1px solid var(--border-color);
            color: var(--accent-light);
            font-family: inherit;
            margin-bottom: 10px;
            font-size: 0.85rem;
        }

        .feedback-form textarea {
            min-height: 80px;
            resize: vertical;
        }

        .feedback-categories {
            display: flex;
            gap: 6px;
            margin-bottom: 12px;
            flex-wrap: wrap;
        }

        .feedback-cat-btn {
            padding: 6px 12px;
            background: rgba(0, 255, 65, 0.05);
            border: 1px solid var(--border-color);
            color: var(--text-dim);
            font-size: 0.75rem;
            cursor: pointer;
        }

        .feedback-cat-btn.selected {
            background: rgba(0, 255, 65, 0.15);
            border-color: var(--accent);
            color: var(--accent-light);
        }

        .feedback-submit-btn {
            width: 100%;
            padding: 10px;
            background: var(--accent);
            border: none;
            color: #000;
            font-weight: bold;
            cursor: pointer;
        }

        .feedback-list {
            display: flex;
            flex-direction: column;
            gap: 12px;
        }

        .feedback-card {
            background: rgba(0, 255, 65, 0.03);
            border: 1px solid var(--border-color);
            padding: 14px;
            display: flex;
            gap: 12px;
        }

        .feedback-card.own {
            border-left: 3px solid var(--accent);
        }

        .feedback-vote {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 4px;
            min-width: 45px;
        }

        .feedback-vote-btn {
            width: 36px;
            height: 36px;
            background: rgba(0, 255, 65, 0.05);
            border: 1px solid var(--border-color);
            color: var(--text-dim);
            font-size: 1.1rem;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s;
        }

        .feedback-vote-btn.upvote:hover {
            background: rgba(0, 255, 65, 0.15);
            border-color: #0f0;
            color: #0f0;
        }

        .feedback-vote-btn.downvote:hover {
            background: rgba(255, 68, 68, 0.15);
            border-color: #f44;
            color: #f44;
        }

        .feedback-vote-btn.upvote.active {
            background: #0f0;
            border-color: #0f0;
            color: #000;
        }

        .feedback-vote-btn.downvote.active {
            background: #f44;
            border-color: #f44;
            color: #000;
        }

        .feedback-vote-count {
            font-size: 1.1rem;
            font-weight: bold;
        }

        .feedback-vote-count.positive { color: #0f0; }
        .feedback-vote-count.negative { color: #f44; }
        .feedback-vote-count.neutral { color: var(--text-dim); }

        .feedback-content {
            flex: 1;
            min-width: 0;
        }

        .feedback-title {
            font-weight: bold;
            color: var(--accent-light);
            margin-bottom: 6px;
            font-size: 0.95rem;
        }

        .feedback-desc {
            color: var(--text-dim);
            font-size: 0.8rem;
            line-height: 1.4;
            margin-bottom: 8px;
        }

        .feedback-meta {
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
            align-items: center;
        }

        .feedback-category-tag {
            padding: 3px 8px;
            background: rgba(139, 92, 246, 0.2);
            font-size: 0.65rem;
            font-weight: bold;
            color: #a78bfa;
            text-transform: uppercase;
        }

        .feedback-category-tag.sloppy { background: rgba(236, 72, 153, 0.2); color: #f472b6; }
        .feedback-category-tag.streamer { background: rgba(245, 158, 11, 0.2); color: #fbbf24; }
        .feedback-category-tag.apps { background: rgba(34, 197, 94, 0.2); color: #4ade80; }

        .feedback-time {
            font-size: 0.7rem;
            color: var(--text-dim);
        }

        .feedback-delete {
            padding: 3px 8px;
            background: rgba(239, 68, 68, 0.15);
            border: 1px solid rgba(239, 68, 68, 0.25);
            color: #f87171;
            font-size: 0.65rem;
            cursor: pointer;
        }

        .feedback-empty {
            text-align: center;
            padding: 40px;
            color: var(--text-dim);
        }

        /* Karma Leaderboard Styles */
        .karma-container {
            display: none;
            padding: 16px;
            height: calc(100vh - 200px);
            overflow-y: auto;
        }

        .karma-container.active {
            display: block;
        }

        /* DM (Direct Messages) Styles */
        .dm-container {
            display: none;
            height: calc(100vh - 200px);
            overflow: hidden;
        }

        .dm-container.active {
            display: flex;
            flex-direction: column;
        }

        .dm-layout {
            display: flex;
            height: 100%;
            gap: 1px;
            background: var(--border-color);
        }

        .dm-conversations {
            width: 280px;
            background: var(--panel-bg);
            display: flex;
            flex-direction: column;
            flex-shrink: 0;
        }

        .dm-conv-header {
            padding: 12px 16px;
            border-bottom: 1px solid var(--border-color);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .dm-conv-title {
            font-size: 1.1rem;
            color: var(--accent-light);
        }

        .dm-new-btn {
            background: var(--accent-dim);
            border: none;
            color: white;
            padding: 6px 12px;
            font-family: inherit;
            font-size: 0.9rem;
            cursor: pointer;
            transition: all 0.2s;
        }

        .dm-new-btn:hover {
            background: var(--accent);
        }

        .dm-conv-list {
            flex: 1;
            overflow-y: auto;
            padding: 8px;
        }

        .dm-conv-item {
            padding: 12px;
            border-radius: 6px;
            cursor: pointer;
            transition: background 0.2s;
            margin-bottom: 4px;
            border: 1px solid transparent;
        }

        .dm-conv-item:hover {
            background: rgba(124, 152, 133, 0.1);
        }

        .dm-conv-item.active {
            background: rgba(124, 152, 133, 0.15);
            border-color: var(--accent-dim);
        }

        .dm-conv-item.unread {
            border-left: 3px solid var(--highlight);
        }

        .dm-conv-user {
            font-size: 1rem;
            color: var(--accent-light);
            margin-bottom: 4px;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .dm-conv-user .avatar {
            font-size: 1.2rem;
        }

        .dm-conv-preview {
            font-size: 0.85rem;
            color: var(--text-dim);
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .dm-conv-time {
            font-size: 0.75rem;
            color: var(--text-dim);
            margin-top: 4px;
        }

        .dm-conv-empty {
            text-align: center;
            padding: 40px 20px;
            color: var(--text-dim);
        }

        .dm-conv-empty-icon {
            font-size: 2rem;
            margin-bottom: 12px;
            opacity: 0.5;
        }

        /* DM Thread */
        .dm-thread {
            flex: 1;
            background: var(--dark-bg);
            display: flex;
            flex-direction: column;
        }

        .dm-thread-header {
            padding: 12px 16px;
            background: var(--panel-bg);
            border-bottom: 1px solid var(--border-color);
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .dm-thread-back {
            display: none;
            background: none;
            border: none;
            color: var(--accent);
            font-size: 1.2rem;
            cursor: pointer;
            padding: 4px 8px;
        }

        .dm-thread-user {
            font-size: 1.1rem;
            color: var(--accent-light);
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .dm-thread-messages {
            flex: 1;
            overflow-y: auto;
            padding: 16px;
            display: flex;
            flex-direction: column;
            gap: 12px;
        }

        .dm-message {
            max-width: 70%;
            padding: 10px 14px;
            border-radius: 12px;
            position: relative;
        }

        .dm-message.sent {
            align-self: flex-end;
            background: rgba(var(--msg-own-color), 0.8);
            border-bottom-right-radius: 4px;
        }

        .dm-message.received {
            align-self: flex-start;
            background: rgba(var(--msg-color), 0.9);
            border: 1px solid var(--border-color);
            border-bottom-left-radius: 4px;
        }

        .dm-message-content {
            font-size: 0.95rem;
            line-height: 1.4;
            word-wrap: break-word;
        }

        .dm-message-time {
            font-size: 0.7rem;
            color: var(--text-dim);
            margin-top: 6px;
            text-align: right;
        }

        .dm-message-image {
            max-width: 100%;
            border-radius: 8px;
            margin-top: 8px;
        }

        .dm-thread-input {
            padding: 12px 16px;
            background: var(--panel-bg);
            border-top: 1px solid var(--border-color);
            display: flex;
            gap: 10px;
        }

        .dm-input {
            flex: 1;
            background: rgba(0,0,0,0.3);
            border: 1px solid var(--border-color);
            color: var(--accent);
            padding: 10px 14px;
            font-family: inherit;
            font-size: 0.95rem;
            border-radius: 6px;
            resize: none;
        }

        .dm-input:focus {
            outline: none;
            border-color: var(--accent-dim);
        }

        .dm-send-btn {
            background: var(--accent-dim);
            border: none;
            color: white;
            padding: 10px 20px;
            font-family: inherit;
            font-size: 0.95rem;
            cursor: pointer;
            border-radius: 6px;
            transition: all 0.2s;
        }

        .dm-send-btn:hover {
            background: var(--accent);
        }

        .dm-send-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        /* DM Empty State */
        .dm-thread-empty {
            flex: 1;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            color: var(--text-dim);
            text-align: center;
            padding: 40px;
        }

        .dm-thread-empty-icon {
            font-size: 3rem;
            margin-bottom: 16px;
            opacity: 0.4;
        }

        .dm-thread-empty h3 {
            color: var(--accent);
            margin-bottom: 8px;
        }

        /* New DM Modal */
        .dm-new-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0,0,0,0.85);
            z-index: 1500;
            align-items: center;
            justify-content: center;
        }

        .dm-new-modal.visible {
            display: flex;
        }

        .dm-new-content {
            background: var(--panel-bg);
            border: 1px solid var(--border-color);
            border-radius: 12px;
            padding: 20px;
            width: 90%;
            max-width: 400px;
        }

        .dm-new-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 16px;
        }

        .dm-new-header h3 {
            color: var(--accent-light);
        }

        .dm-new-close {
            background: none;
            border: none;
            color: var(--text-dim);
            font-size: 1.5rem;
            cursor: pointer;
        }

        .dm-user-search {
            width: 100%;
            background: rgba(0,0,0,0.3);
            border: 1px solid var(--border-color);
            color: var(--accent);
            padding: 10px 14px;
            font-family: inherit;
            font-size: 0.95rem;
            border-radius: 6px;
            margin-bottom: 12px;
        }

        .dm-user-results {
            max-height: 250px;
            overflow-y: auto;
        }

        .dm-user-item {
            padding: 10px 12px;
            cursor: pointer;
            border-radius: 6px;
            display: flex;
            align-items: center;
            gap: 10px;
            transition: background 0.2s;
        }

        .dm-user-item:hover {
            background: rgba(124, 152, 133, 0.15);
        }

        .dm-user-item .avatar {
            font-size: 1.3rem;
        }

        .dm-user-item .username {
            color: var(--accent-light);
        }

        .dm-unread-badge {
            background: var(--highlight);
            color: #000;
            font-size: 0.7rem;
            padding: 2px 6px;
            border-radius: 10px;
            font-weight: bold;
        }

        /* Mobile DM Styles */
        @media (max-width: 768px) {
            .dm-layout {
                flex-direction: column;
            }

            .dm-conversations {
                width: 100%;
                height: auto;
                max-height: 100%;
            }

            .dm-conversations.hidden-mobile {
                display: none;
            }

            .dm-thread {
                position: absolute;
                top: 0;
                left: 0;
                right: 0;
                bottom: 0;
                display: none;
            }

            .dm-thread.active-mobile {
                display: flex;
            }

            .dm-thread-back {
                display: block;
            }
        }

        .karma-header {
            text-align: center;
            margin-bottom: 20px;
        }

        .karma-title {
            font-size: 1.4rem;
            font-weight: bold;
            background: linear-gradient(90deg, #f0f, #0ff);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .karma-subtitle {
            font-size: 0.7rem;
            color: var(--text-dim);
            margin-top: 4px;
        }

        .karma-stats {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 10px;
            margin-bottom: 16px;
        }

        .karma-stat {
            background: rgba(255, 0, 255, 0.05);
            border: 1px solid rgba(255, 0, 255, 0.2);
            padding: 12px;
            text-align: center;
        }

        .karma-stat-num {
            font-size: 1.4rem;
            font-weight: bold;
            color: #f0f;
        }

        .karma-stat-label {
            font-size: 0.65rem;
            color: var(--text-dim);
            text-transform: uppercase;
        }

        .karma-filters {
            margin-bottom: 16px;
        }

        .karma-filter-group {
            display: flex;
            gap: 6px;
            margin-bottom: 8px;
            flex-wrap: wrap;
        }

        .karma-filter, .karma-cat-btn {
            padding: 6px 12px;
            background: rgba(255, 0, 255, 0.05);
            border: 1px solid rgba(255, 0, 255, 0.2);
            color: var(--text-dim);
            font-size: 0.75rem;
            cursor: pointer;
            transition: all 0.2s;
        }

        .karma-filter:hover, .karma-cat-btn:hover {
            background: rgba(255, 0, 255, 0.1);
        }

        .karma-filter.active, .karma-cat-btn.active {
            background: rgba(255, 0, 255, 0.15);
            border-color: #f0f;
            color: #f0f;
        }

        .karma-list {
            margin-bottom: 16px;
        }

        .karma-loading {
            text-align: center;
            padding: 40px;
            color: var(--text-dim);
        }

        .karma-entry {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 12px;
            background: rgba(255, 0, 255, 0.03);
            border: 1px solid rgba(255, 0, 255, 0.1);
            margin-bottom: 8px;
            transition: all 0.2s;
        }

        .karma-entry:hover {
            background: rgba(255, 0, 255, 0.08);
            border-color: rgba(255, 0, 255, 0.3);
        }

        .karma-entry.top-3 {
            border-color: rgba(255, 215, 0, 0.3);
            background: rgba(255, 215, 0, 0.05);
        }

        .karma-rank {
            font-size: 1.2rem;
            font-weight: bold;
            min-width: 40px;
            text-align: center;
        }

        .karma-rank.gold { color: #ffd700; }
        .karma-rank.silver { color: #c0c0c0; }
        .karma-rank.bronze { color: #cd7f32; }

        .karma-avatar {
            font-size: 1.5rem;
        }

        .karma-user-info {
            flex: 1;
        }

        .karma-username {
            font-weight: bold;
            color: var(--text);
        }

        .karma-badges-row {
            display: flex;
            gap: 4px;
            margin-top: 4px;
        }

        .karma-badge {
            font-size: 0.9rem;
        }

        .karma-score {
            text-align: right;
        }

        .karma-score-total {
            font-size: 1.1rem;
            font-weight: bold;
            color: #f0f;
        }

        .karma-score-breakdown {
            font-size: 0.65rem;
            color: var(--text-dim);
        }

        .karma-my-stats {
            background: linear-gradient(135deg, rgba(255, 0, 255, 0.1), rgba(0, 255, 255, 0.1));
            border: 1px solid rgba(255, 0, 255, 0.3);
            padding: 16px;
            text-align: center;
        }

        .karma-my-title {
            font-size: 0.7rem;
            color: var(--text-dim);
            text-transform: uppercase;
            margin-bottom: 8px;
        }

        .karma-my-score {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 16px;
            margin-bottom: 12px;
        }

        .karma-my-total {
            font-size: 1.8rem;
            font-weight: bold;
            color: #f0f;
        }

        .karma-my-rank {
            font-size: 1.2rem;
            color: #0ff;
        }

        .karma-my-breakdown {
            display: flex;
            justify-content: center;
            gap: 16px;
            font-size: 0.85rem;
            margin-bottom: 12px;
        }

        .karma-my-breakdown span {
            color: var(--text-dim);
        }

        .karma-my-badges {
            display: flex;
            justify-content: center;
            gap: 8px;
            flex-wrap: wrap;
        }

        .karma-badge-earned {
            padding: 4px 8px;
            background: rgba(255, 215, 0, 0.1);
            border: 1px solid rgba(255, 215, 0, 0.3);
            font-size: 0.75rem;
        }

        /* Factions System */
        .factions-container {
            display: none;
            flex-direction: column;
            gap: 16px;
            padding: 16px;
            max-height: calc(100vh - 200px);
            overflow-y: auto;
        }

        .factions-container.active {
            display: flex;
        }

        .factions-header {
            text-align: center;
        }

        .factions-title {
            font-size: 1.4rem;
            font-weight: bold;
            background: linear-gradient(90deg, #ff4444, #ff8800, #ffcc00);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .factions-subtitle {
            font-size: 0.7rem;
            color: var(--text-dim);
            margin-top: 4px;
        }

        .my-faction-banner {
            display: flex;
            align-items: center;
            justify-content: space-between;
            background: linear-gradient(135deg, rgba(139, 92, 246, 0.15), rgba(59, 130, 246, 0.1));
            border: 1px solid rgba(139, 92, 246, 0.3);
            padding: 12px 16px;
            flex-wrap: wrap;
            gap: 12px;
        }

        .my-faction-info {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .my-faction-emoji {
            font-size: 1.8rem;
        }

        .my-faction-name {
            font-size: 1.1rem;
            font-weight: bold;
            color: var(--highlight);
        }

        .my-faction-stats {
            display: flex;
            gap: 16px;
            font-size: 0.85rem;
            color: var(--text-dim);
        }

        .leave-faction-btn {
            padding: 6px 12px;
            background: rgba(239, 68, 68, 0.1);
            border: 1px solid rgba(239, 68, 68, 0.3);
            color: #ef4444;
            font-size: 0.75rem;
            cursor: pointer;
            transition: all 0.2s;
        }

        .leave-faction-btn:hover {
            background: rgba(239, 68, 68, 0.2);
        }

        .faction-selection {
            text-align: center;
        }

        .faction-selection-title {
            font-size: 1rem;
            color: var(--accent-light);
            margin-bottom: 16px;
        }

        .faction-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 12px;
        }

        .faction-card {
            background: var(--panel-bg);
            border: 2px solid var(--border);
            padding: 16px;
            cursor: pointer;
            transition: all 0.2s;
            text-align: center;
        }

        .faction-card:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
        }

        .faction-card.selected {
            border-color: var(--highlight);
            box-shadow: 0 0 15px rgba(139, 92, 246, 0.3);
        }

        .faction-emoji {
            font-size: 2.5rem;
            margin-bottom: 8px;
        }

        .faction-name {
            font-size: 0.95rem;
            font-weight: bold;
            color: var(--accent-light);
            margin-bottom: 4px;
        }

        .faction-desc {
            font-size: 0.7rem;
            color: var(--text-dim);
            margin-bottom: 8px;
        }

        .faction-members {
            font-size: 0.75rem;
            color: var(--highlight);
        }

        .pledge-btn {
            margin-top: 10px;
            padding: 8px 16px;
            background: linear-gradient(135deg, #8b5cf6, #6366f1);
            border: none;
            color: white;
            font-size: 0.8rem;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.2s;
        }

        .pledge-btn:hover {
            background: linear-gradient(135deg, #9f7afa, #818cf8);
            box-shadow: 0 0 15px rgba(139, 92, 246, 0.4);
        }

        .war-stats {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 10px;
        }

        .war-stat {
            background: rgba(255, 68, 68, 0.05);
            border: 1px solid rgba(255, 68, 68, 0.2);
            padding: 12px;
            text-align: center;
        }

        .war-stat-num {
            font-size: 1.4rem;
            font-weight: bold;
            color: #ff4444;
        }

        .war-stat-label {
            font-size: 0.65rem;
            color: var(--text-dim);
            text-transform: uppercase;
        }

        .territory-section {
            background: var(--panel-bg);
            border: 1px solid var(--border);
            padding: 16px;
        }

        .territory-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 12px;
        }

        .territory-title {
            font-size: 1rem;
            font-weight: bold;
            color: var(--accent-light);
        }

        .territory-legend {
            display: flex;
            gap: 10px;
            font-size: 0.7rem;
        }

        .territory-legend-item {
            display: flex;
            align-items: center;
            gap: 4px;
        }

        .territory-legend-color {
            width: 12px;
            height: 12px;
            border-radius: 2px;
        }

        .territory-grid {
            display: grid;
            grid-template-columns: repeat(5, 1fr);
            gap: 4px;
        }

        .territory-cell {
            aspect-ratio: 1;
            background: rgba(100, 100, 100, 0.2);
            border: 1px solid rgba(100, 100, 100, 0.3);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.2s;
            position: relative;
            min-height: 50px;
        }

        .territory-cell:hover {
            transform: scale(1.05);
            z-index: 2;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4);
        }

        .territory-cell.neutral {
            background: rgba(100, 100, 100, 0.3);
            border-color: rgba(100, 100, 100, 0.5);
        }

        .territory-cell.battle {
            animation: battlePulse 1s ease-in-out infinite;
        }

        @keyframes battlePulse {
            0%, 100% { box-shadow: 0 0 5px rgba(255, 68, 68, 0.5); }
            50% { box-shadow: 0 0 20px rgba(255, 68, 68, 0.8); }
        }

        .territory-name {
            font-size: 0.6rem;
            color: rgba(255, 255, 255, 0.9);
            text-shadow: 0 1px 2px rgba(0, 0, 0, 0.8);
            text-align: center;
        }

        .territory-defense {
            font-size: 0.55rem;
            color: rgba(255, 255, 255, 0.7);
            margin-top: 2px;
        }

        .attack-btn {
            position: absolute;
            bottom: 2px;
            right: 2px;
            font-size: 0.6rem;
            padding: 2px 4px;
            background: rgba(255, 68, 68, 0.8);
            border: none;
            color: white;
            cursor: pointer;
            opacity: 0;
            transition: opacity 0.2s;
        }

        .territory-cell:hover .attack-btn {
            opacity: 1;
        }

        .faction-leaderboard {
            background: var(--panel-bg);
            border: 1px solid var(--border);
            padding: 16px;
        }

        .faction-lb-title {
            font-size: 1rem;
            font-weight: bold;
            color: var(--accent-light);
            margin-bottom: 12px;
        }

        .faction-lb-entry {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 10px;
            margin-bottom: 6px;
            background: rgba(255, 255, 255, 0.02);
            border-left: 3px solid transparent;
            transition: all 0.2s;
        }

        .faction-lb-entry:hover {
            background: rgba(255, 255, 255, 0.05);
        }

        .faction-lb-rank {
            font-size: 1.2rem;
            font-weight: bold;
            width: 30px;
            color: var(--text-dim);
        }

        .faction-lb-rank.gold { color: #ffd700; }
        .faction-lb-rank.silver { color: #c0c0c0; }
        .faction-lb-rank.bronze { color: #cd7f32; }

        .faction-lb-info {
            flex: 1;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .faction-lb-emoji {
            font-size: 1.4rem;
        }

        .faction-lb-name {
            font-weight: bold;
            color: var(--accent-light);
        }

        .faction-lb-stats {
            display: flex;
            gap: 16px;
            font-size: 0.8rem;
            color: var(--text-dim);
        }

        .battle-log {
            background: var(--panel-bg);
            border: 1px solid var(--border);
            padding: 16px;
        }

        .battle-log-title {
            font-size: 1rem;
            font-weight: bold;
            color: var(--accent-light);
            margin-bottom: 12px;
        }

        .battle-log-list {
            max-height: 150px;
            overflow-y: auto;
        }

        .battle-log-entry {
            padding: 8px;
            margin-bottom: 6px;
            background: rgba(255, 68, 68, 0.05);
            border-left: 2px solid #ff4444;
            font-size: 0.8rem;
        }

        .battle-log-entry.victory {
            border-left-color: #22c55e;
            background: rgba(34, 197, 94, 0.05);
        }

        .battle-log-empty {
            text-align: center;
            padding: 20px;
            color: var(--text-dim);
        }

        .battle-modal {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.8);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 10001;
        }

        .battle-modal-content {
            background: var(--dark-bg);
            border: 2px solid #ff4444;
            padding: 24px;
            max-width: 400px;
            width: 90%;
            text-align: center;
        }

        .battle-modal-title {
            font-size: 1.3rem;
            font-weight: bold;
            color: #ff4444;
            margin-bottom: 16px;
        }

        .battle-modal-territory {
            font-size: 1.1rem;
            color: var(--accent-light);
            margin-bottom: 20px;
        }

        .battle-powers {
            display: flex;
            justify-content: space-around;
            margin-bottom: 20px;
        }

        .battle-side {
            text-align: center;
        }

        .battle-side-emoji {
            font-size: 2rem;
            margin-bottom: 8px;
        }

        .battle-side-power {
            font-size: 1.5rem;
            font-weight: bold;
        }

        .battle-side-power.attacker { color: #ff4444; }
        .battle-side-power.defender { color: #3b82f6; }

        .battle-vs {
            font-size: 1.2rem;
            color: var(--text-dim);
            align-self: center;
        }

        .battle-actions {
            display: flex;
            gap: 12px;
            justify-content: center;
        }

        .battle-btn {
            padding: 10px 24px;
            font-size: 0.9rem;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.2s;
        }

        .battle-btn.attack {
            background: linear-gradient(135deg, #ff4444, #ff6666);
            border: none;
            color: white;
        }

        .battle-btn.attack:hover {
            box-shadow: 0 0 20px rgba(255, 68, 68, 0.5);
        }

        .battle-btn.cancel {
            background: transparent;
            border: 1px solid var(--text-dim);
            color: var(--text-dim);
        }

        .battle-result {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: var(--dark-bg);
            border: 3px solid;
            padding: 32px;
            z-index: 10002;
            text-align: center;
            animation: battleResultIn 0.3s ease-out;
        }

        @keyframes battleResultIn {
            from { transform: translate(-50%, -50%) scale(0.8); opacity: 0; }
            to { transform: translate(-50%, -50%) scale(1); opacity: 1; }
        }

        .battle-result.victory {
            border-color: #22c55e;
        }

        .battle-result.defeat {
            border-color: #ef4444;
        }

        .battle-result-title {
            font-size: 2rem;
            font-weight: bold;
            margin-bottom: 12px;
        }

        .battle-result.victory .battle-result-title { color: #22c55e; }
        .battle-result.defeat .battle-result-title { color: #ef4444; }

        .battle-result-desc {
            font-size: 0.9rem;
            color: var(--text-dim);
        }

        /* Cross-app Profile Stats */
        .profile-crossapp {
            margin-top: 12px;
            padding-top: 12px;
            border-top: 1px solid var(--border-color);
        }

        .profile-crossapp-title {
            font-size: 0.7rem;
            color: var(--text-dim);
            text-transform: uppercase;
            margin-bottom: 8px;
        }

        .profile-game-scores {
            display: flex;
            flex-wrap: wrap;
            gap: 6px;
        }

        .profile-game-score {
            background: rgba(139, 92, 246, 0.1);
            border: 1px solid rgba(139, 92, 246, 0.2);
            padding: 4px 8px;
            font-size: 0.7rem;
        }

        .profile-game-score .game-name {
            color: var(--text-dim);
        }

        .profile-game-score .game-score {
            color: #a78bfa;
            font-weight: bold;
            margin-left: 4px;
        }

        /* Public Feed */
        .feed-item {
            padding: 8px;
            margin-bottom: 8px;
            background: rgba(255, 255, 255, 0.02);
            border-left: 2px solid var(--border-color);
            font-size: 0.95rem;
        }

        .feed-user {
            color: var(--highlight);
        }

        .feed-action {
            color: var(--text-dim);
        }

        .feed-time {
            color: #666;
            font-size: 0.85rem;
        }

        /* Messages Container */
        .main-content {
            grid-row: 2;
            background: var(--panel-bg);
            display: flex;
            flex-direction: column;
            overflow: hidden;
            min-height: 0;
        }

        .messages-container {
            flex: 1;
            overflow-y: auto;
            padding: 16px;
            display: flex;
            flex-direction: column;
            gap: 12px;
            min-height: 0;
            position: relative;
            background-size: cover;
            background-position: center;
            background-attachment: fixed;
            background-repeat: no-repeat;
            image-rendering: -webkit-optimize-contrast;
            image-rendering: crisp-edges;
        }

        .messages-container::-webkit-scrollbar {
            width: 8px;
        }

        .messages-container::-webkit-scrollbar-track {
            background: var(--dark-bg);
        }

        .messages-container::-webkit-scrollbar-thumb {
            background: var(--border-color);
        }

        .message {
            display: flex;
            gap: 10px;
            animation: glitchIn 0.3s ease-out;
        }

        @keyframes glitchIn {
            0% { opacity: 0; transform: translateX(-10px); }
            50% { opacity: 1; transform: translateX(3px); }
            100% { transform: translateX(0); }
        }

        .message.own {
            flex-direction: row-reverse;
        }

        .avatar {
            width: 40px;
            height: 40px;
            border: 1px solid var(--border-color);
            border-radius: 4px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 24px;
            flex-shrink: 0;
            background: var(--dark-bg);
        }

        .message-bubble {
            max-width: 70%;
            background: rgba(var(--msg-color), var(--msg-opacity));
            border: 1px solid var(--border-color);
            border-radius: 4px;
            padding: 10px 14px;
            color: var(--accent);
        }

        .message.own .message-bubble {
            background: rgba(var(--msg-own-color), var(--msg-opacity));
            color: var(--accent-light);
        }

        .message-header {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 4px;
        }

        .message-username {
            color: var(--accent-light);
            font-size: 1rem;
        }

        .message.own .message-username {
            color: var(--highlight);
        }

        .message-time {
            font-size: 0.85rem;
            color: #555;
        }

        .message-content {
            font-size: 1.1rem;
            line-height: 1.4;
            word-wrap: break-word;
        }

        .message.bot-message {
            opacity: 0.9;
        }

        .message.bot-message .message-bubble {
            background: linear-gradient(135deg, rgba(124, 152, 133, 0.15), rgba(90, 122, 99, 0.1));
            border-left: 2px solid var(--accent);
        }

        .message.bot-message .avatar {
            background: linear-gradient(135deg, #7c9885, #5a7a63);
            font-size: 1.2rem;
        }

        /* Chat Tags */
        .chat-tag {
            display: inline-block;
            background: linear-gradient(135deg, rgba(124, 152, 133, 0.2) 0%, rgba(124, 152, 133, 0.1) 100%);
            color: var(--accent-light);
            padding: 1px 6px;
            border-radius: 4px;
            font-size: 0.95em;
            cursor: pointer;
            transition: all 0.2s;
            border: 1px solid rgba(124, 152, 133, 0.3);
        }

        .chat-tag:hover {
            background: linear-gradient(135deg, rgba(124, 152, 133, 0.35) 0%, rgba(124, 152, 133, 0.2) 100%);
            transform: translateY(-1px);
        }

        .chat-mention {
            display: inline-block;
            background: linear-gradient(135deg, rgba(255, 0, 255, 0.2) 0%, rgba(255, 0, 255, 0.1) 100%);
            color: #ff88ff;
            padding: 1px 6px;
            border-radius: 4px;
            font-size: 0.95em;
            cursor: pointer;
            transition: all 0.2s;
            border: 1px solid rgba(255, 0, 255, 0.3);
        }

        .chat-mention:hover {
            background: linear-gradient(135deg, rgba(255, 0, 255, 0.35) 0%, rgba(255, 0, 255, 0.2) 100%);
            transform: translateY(-1px);
        }

        .tag-hint {
            position: absolute;
            bottom: 100%;
            left: 0;
            right: 0;
            background: var(--panel-bg);
            border: 1px solid var(--border-color);
            border-bottom: none;
            border-radius: 6px 6px 0 0;
            padding: 8px 12px;
            font-size: 0.85rem;
            color: var(--text-dim);
            display: none;
            z-index: 10;
        }

        .tag-hint.visible {
            display: block;
        }

        .tag-hint-item {
            display: inline-block;
            background: rgba(124, 152, 133, 0.15);
            padding: 2px 8px;
            margin: 2px 4px 2px 0;
            border-radius: 4px;
            cursor: pointer;
            transition: background 0.2s;
        }

        .tag-hint-item:hover {
            background: rgba(124, 152, 133, 0.3);
        }

        .input-area {
            position: relative;
        }

        .message-image, .message-drawing {
            max-width: 100%;
            margin-top: 8px;
            cursor: pointer;
            border: 1px solid var(--border-color);
        }

        /* Doodle Vote */
        .doodle-wrapper {
            position: relative;
            display: inline-block;
        }

        .doodle-vote-btn {
            position: absolute;
            bottom: 8px;
            right: 8px;
            background: rgba(0,0,0,0.7);
            border: 1px solid var(--border-color);
            color: var(--text-dim);
            padding: 4px 10px;
            font-family: inherit;
            font-size: 0.9rem;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 4px;
            transition: all 0.2s;
        }

        .doodle-vote-btn:hover {
            background: rgba(0,0,0,0.9);
            border-color: var(--highlight);
            color: var(--highlight);
        }

        .doodle-vote-btn.voted {
            color: var(--highlight);
            border-color: var(--highlight);
        }

        /* Vote controls (up/down) */
        .vote-controls {
            display: inline-flex;
            align-items: center;
            gap: 2px;
            background: rgba(0,0,0,0.3);
            border-radius: 12px;
            padding: 2px 4px;
        }

        .vote-btn {
            background: transparent;
            border: none;
            color: var(--text-dim);
            padding: 2px 6px;
            font-size: 0.85rem;
            cursor: pointer;
            transition: all 0.15s;
            border-radius: 8px;
        }

        .vote-btn:hover {
            background: rgba(255,255,255,0.1);
        }

        .vote-btn.upvote:hover, .vote-btn.upvote.active {
            color: #00ff41;
        }

        .vote-btn.downvote:hover, .vote-btn.downvote.active {
            color: #ff4444;
        }

        .vote-btn.disabled {
            opacity: 0.3;
            cursor: not-allowed;
        }

        .vote-score {
            font-size: 0.8rem;
            min-width: 20px;
            text-align: center;
            font-weight: bold;
        }

        .vote-score.positive { color: #00ff41; }
        .vote-score.negative { color: #ff4444; }
        .vote-score.neutral { color: var(--text-dim); }

        .message-footer {
            margin-top: 6px;
            padding-top: 4px;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .msg-tts-btn {
            background: transparent;
            border: none;
            color: var(--text-dim);
            cursor: pointer;
            padding: 2px 6px;
            font-size: 0.9rem;
            opacity: 0.7;
            transition: all 0.2s;
        }

        .msg-tts-btn:hover {
            opacity: 1;
            color: var(--accent-light);
        }

        .msg-tts-btn.speaking {
            opacity: 1;
            color: var(--accent-light);
            animation: pulse-speak 1s ease-in-out infinite;
        }

        .msg-fork-btn {
            background: transparent;
            border: none;
            color: #0f8;
            cursor: pointer;
            padding: 2px 6px;
            font-size: 0.75rem;
            opacity: 0.6;
            transition: all 0.2s;
        }

        .msg-fork-btn:hover {
            opacity: 1;
            transform: scale(1.1);
        }

        .msg-dna-badge {
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.65rem;
            color: var(--text-dim);
            opacity: 0.5;
            letter-spacing: 0.5px;
        }

        .msg-dna-badge .nucleotide-A { color: #ff6b6b; }
        .msg-dna-badge .nucleotide-T { color: #4ecdc4; }
        .msg-dna-badge .nucleotide-C { color: #ffe66d; }
        .msg-dna-badge .nucleotide-G { color: #95e1a3; }

        .msg-delete-btn {
            background: transparent;
            border: none;
            color: var(--text-dim);
            cursor: pointer;
            padding: 2px 6px;
            font-size: 0.9rem;
            opacity: 0.7;
            margin-left: auto;
            transition: all 0.2s;
        }

        .msg-delete-btn:hover {
            opacity: 1;
            color: #ff6666;
            background: rgba(255, 100, 100, 0.1);
            border-radius: 4px;
        }

        .message-header {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        /* Doodle Leaderboard */
        .doodles-container {
            flex: 1;
            overflow-y: auto;
            padding: 16px;
            display: none;
            flex-direction: column;
            gap: 16px;
            min-height: 0;
        }

        .doodles-container.active {
            display: flex;
        }

        .leaderboard-header {
            text-align: center;
            padding: 16px;
            color: var(--accent);
            font-size: 1.1rem;
            border-bottom: 1px solid var(--border-color);
        }

        .doodle-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
            gap: 16px;
        }

        .doodle-card {
            background: var(--panel-bg);
            border: 1px solid var(--border-color);
            overflow: hidden;
            border-radius: 8px;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .doodle-card:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 20px rgba(0,0,0,0.3);
        }

        .doodle-card.top-3 {
            border-color: var(--highlight);
        }

        .doodle-rank {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 8px 12px;
            background: var(--dark-bg);
        }

        .rank-badge {
            width: 28px;
            height: 28px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            font-size: 0.9rem;
            background: var(--border-color);
            color: var(--text-dim);
        }

        .rank-badge.gold {
            background: linear-gradient(135deg, #ffd700, #ffaa00);
            color: #000;
        }
        .rank-badge.silver {
            background: linear-gradient(135deg, #e0e0e0, #a0a0a0);
            color: #000;
        }
        .rank-badge.bronze {
            background: linear-gradient(135deg, #cd7f32, #8b4513);
            color: #fff;
        }

        .doodle-artist {
            flex: 1;
            color: var(--accent-light);
            font-size: 0.9rem;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .doodle-votes {
            color: var(--highlight);
            font-size: 1rem;
            font-weight: bold;
        }

        .doodle-thumbnail {
            position: relative;
            background: #111;
            aspect-ratio: 4/3;
            overflow: hidden;
        }

        .doodle-card img {
            width: 100%;
            height: 100%;
            object-fit: contain;
            display: block;
            cursor: pointer;
            transition: transform 0.2s;
        }

        .doodle-card:hover img {
            transform: scale(1.05);
        }

        .doodle-card-actions {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px 12px;
            border-top: 1px solid var(--border-color);
            background: var(--dark-bg);
        }

        .doodle-time {
            color: var(--text-dim);
            font-size: 0.75rem;
        }

        .empty-doodles {
            text-align: center;
            padding: 60px 20px;
            color: var(--text-dim);
        }

        .doodle-comments {
            max-height: 200px;
            overflow-y: auto;
            padding: 8px 12px;
            border-top: 1px solid var(--border-color);
        }

        .doodle-card .comment-input-row {
            padding: 8px 12px;
            border-top: 1px solid var(--border-color);
        }

        .doodle-card .reply-indicator {
            padding: 4px 12px;
            border-top: 1px solid var(--border-color);
        }

        /* Manifesto Section */
        .manifesto-container {
            flex: 1;
            overflow-y: auto;
            padding: 16px;
            display: none;
            flex-direction: column;
            gap: 16px;
            min-height: 0;
        }

        .manifesto-container.active {
            display: flex;
        }

        /* Collaborative Canvas */
        .collab-container {
            flex: 1;
            overflow-y: auto;
            padding: 16px;
            display: none;
            flex-direction: column;
            gap: 16px;
            min-height: 0;
            align-items: center;
        }

        .collab-container.active {
            display: flex;
        }

        .collab-header {
            text-align: center;
            padding: 10px 20px;
        }

        .collab-header h2 {
            color: var(--accent);
            font-size: 1.3rem;
            margin-bottom: 4px;
        }

        .collab-subtitle {
            color: var(--text-dim);
            font-size: 0.85rem;
            margin-bottom: 8px;
        }

        .collab-users {
            display: flex;
            justify-content: center;
            gap: 8px;
        }

        .collab-user-count,
        .collab-zoom-level {
            background: rgba(0,255,65,0.1);
            border: 1px solid var(--accent);
            padding: 4px 12px;
            border-radius: 20px;
            font-size: 0.8rem;
            color: var(--accent);
        }

        .collab-canvas-wrapper {
            position: relative;
            border: 2px solid var(--accent);
            box-shadow: 0 0 20px rgba(0,255,65,0.2);
            background: #0a0a0a;
            width: 100%;
            max-width: 900px;
            height: 500px;
            overflow: auto;
        }

        #collabCanvas {
            display: block;
            cursor: crosshair;
            transform-origin: 0 0;
            transition: transform 0.1s ease-out;
            touch-action: none;
        }

        .collab-zoom-controls {
            display: flex;
            gap: 4px;
        }

        .collab-zoom-btn {
            padding: 6px 12px;
            font-size: 0.9rem;
            min-width: 36px;
        }

        .collab-cursors {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            pointer-events: none;
            overflow: hidden;
        }

        .collab-cursor {
            position: absolute;
            pointer-events: none;
            transition: left 0.05s linear, top 0.05s linear;
            z-index: 10;
        }

        .collab-cursor-dot {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            border: 2px solid #fff;
            box-shadow: 0 0 8px currentColor;
        }

        .collab-cursor-name {
            position: absolute;
            top: 14px;
            left: 8px;
            font-size: 0.65rem;
            background: rgba(0,0,0,0.8);
            padding: 2px 6px;
            border-radius: 4px;
            white-space: nowrap;
            color: #fff;
        }

        .collab-controls {
            display: flex;
            flex-wrap: wrap;
            gap: 16px;
            align-items: center;
            justify-content: center;
            padding: 10px;
        }

        .collab-colors {
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
            justify-content: center;
        }

        .collab-color-btn {
            width: 32px;
            height: 32px;
            border-radius: 50%;
            border: 2px solid transparent;
            cursor: pointer;
            transition: all 0.2s;
        }

        .collab-color-btn:hover {
            transform: scale(1.1);
        }

        .collab-color-btn.active {
            border-color: #fff;
            box-shadow: 0 0 10px currentColor;
        }

        .collab-eraser-btn {
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1rem;
        }

        .collab-eraser-btn.active {
            box-shadow: 0 0 10px #666;
        }

        .collab-clear-btn {
            font-size: 0.8rem;
            padding: 8px 16px;
        }

        .collab-snapshot-btn {
            font-size: 0.8rem;
            padding: 8px 16px;
            background: linear-gradient(135deg, var(--accent), var(--highlight));
            border-color: var(--accent);
        }

        .collab-snapshot-btn:hover {
            box-shadow: 0 0 15px var(--accent);
        }

        @media (max-width: 768px) {
            .collab-canvas-wrapper {
                width: 100%;
            }
            #collabCanvas {
                width: 100%;
                height: auto;
            }
        }

        .manifesto-header {
            text-align: center;
            padding: 20px;
            border-bottom: 1px solid var(--border-color);
        }

        .manifesto-header h2 {
            color: var(--highlight);
            font-size: 1.4rem;
            margin-bottom: 8px;
        }

        .manifesto-subtitle {
            color: var(--text-dim);
            font-size: 0.95rem;
            margin-bottom: 16px;
        }

        .manifesto-list {
            display: flex;
            flex-direction: column;
            gap: 16px;
        }

        .manifesto-card {
            background: linear-gradient(135deg, rgba(201,168,124,0.1), rgba(124,152,133,0.05));
            border: 1px solid var(--border-color);
            border-left: 3px solid var(--highlight);
            padding: 16px;
            transition: all 0.2s;
        }

        .manifesto-card:hover {
            border-color: var(--highlight);
            box-shadow: 0 4px 20px rgba(201,168,124,0.1);
        }

        .manifesto-card-header {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 12px;
        }

        .manifesto-avatar {
            width: 32px;
            height: 32px;
            border-radius: 50%;
            background: var(--dark-bg);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 18px;
            border: 1px solid var(--border-color);
        }

        .manifesto-author {
            color: var(--accent-light);
            font-size: 1rem;
        }

        .manifesto-time {
            margin-left: auto;
            color: var(--text-dim);
            font-size: 0.85rem;
        }

        .manifesto-title {
            color: var(--highlight);
            font-size: 1.2rem;
            margin-bottom: 10px;
            font-weight: normal;
        }

        .manifesto-text {
            color: var(--accent-light);
            font-size: 1rem;
            line-height: 1.6;
        }

        /* Markdown content styles */
        .manifesto-text p {
            margin: 0 0 0.8em 0;
        }

        .manifesto-text p:last-child {
            margin-bottom: 0;
        }

        .manifesto-text strong, .manifesto-text b {
            color: var(--highlight);
            font-weight: bold;
        }

        .manifesto-text em, .manifesto-text i {
            color: var(--accent-light);
            font-style: italic;
        }

        .manifesto-text code {
            background: rgba(0, 0, 0, 0.4);
            padding: 2px 6px;
            border-radius: 4px;
            font-family: 'Share Tech Mono', monospace;
            font-size: 0.9em;
            color: var(--highlight);
        }

        .manifesto-text pre {
            background: rgba(0, 0, 0, 0.5);
            padding: 12px;
            border-radius: 6px;
            overflow-x: auto;
            margin: 0.8em 0;
            border-left: 3px solid var(--accent-dim);
        }

        .manifesto-text pre code {
            background: none;
            padding: 0;
        }

        .manifesto-text blockquote {
            border-left: 3px solid var(--accent);
            padding-left: 12px;
            margin: 0.8em 0;
            color: var(--text-dim);
            font-style: italic;
        }

        .manifesto-text ul, .manifesto-text ol {
            margin: 0.5em 0;
            padding-left: 1.5em;
        }

        .manifesto-text li {
            margin: 0.3em 0;
        }

        .manifesto-text a {
            color: var(--accent);
            text-decoration: underline;
        }

        .manifesto-text a:hover {
            color: var(--accent-light);
        }

        .manifesto-text h1, .manifesto-text h2, .manifesto-text h3 {
            color: var(--highlight);
            margin: 0.8em 0 0.4em 0;
        }

        .manifesto-text h1 { font-size: 1.3em; }
        .manifesto-text h2 { font-size: 1.2em; }
        .manifesto-text h3 { font-size: 1.1em; }

        .manifesto-text hr {
            border: none;
            border-top: 1px solid var(--border-color);
            margin: 1em 0;
        }

        .manifesto-actions {
            display: flex;
            gap: 12px;
            margin-top: 12px;
            padding-top: 12px;
            border-top: 1px solid var(--border-color);
        }

        .manifesto-vote-btn {
            background: transparent;
            border: 1px solid var(--border-color);
            color: var(--accent);
            padding: 6px 12px;
            cursor: pointer;
            font-family: inherit;
            font-size: 0.9rem;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .manifesto-vote-btn:hover {
            border-color: var(--highlight);
            color: var(--highlight);
        }

        .manifesto-vote-btn.voted {
            background: var(--highlight);
            border-color: var(--highlight);
            color: var(--dark-bg);
        }

        /* Upvote/Downvote System */
        .manifesto-vote-controls {
            display: flex;
            align-items: center;
            gap: 4px;
            background: var(--panel-bg);
            border: 1px solid var(--border-color);
            border-radius: 4px;
            padding: 2px;
        }
        .manifesto-upvote, .manifesto-downvote {
            background: transparent;
            border: none;
            color: var(--text-dim);
            font-size: 16px;
            padding: 4px 8px;
            cursor: pointer;
            transition: all 0.2s;
            line-height: 1;
        }
        .manifesto-upvote:hover { color: #0f0; transform: scale(1.2); }
        .manifesto-downvote:hover { color: #f44; transform: scale(1.2); }
        .manifesto-upvote.active { color: #0f0; text-shadow: 0 0 8px #0f0; }
        .manifesto-downvote.active { color: #f44; text-shadow: 0 0 8px #f44; }
        .manifesto-vote-score {
            min-width: 30px;
            text-align: center;
            font-weight: bold;
            font-size: 14px;
            padding: 0 4px;
        }
        .manifesto-vote-score.positive { color: #0f0; }
        .manifesto-vote-score.negative { color: #f44; }
        .manifesto-vote-score.neutral { color: var(--text-dim); }

        /* DNA Signature Display */
        .manifesto-dna {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 6px 10px;
            margin-top: 8px;
            background: linear-gradient(90deg, rgba(0,255,136,0.05) 0%, rgba(0,200,255,0.05) 100%);
            border: 1px solid rgba(0,255,136,0.2);
            border-radius: 4px;
            font-family: 'JetBrains Mono', monospace;
            font-size: 10px;
            overflow: hidden;
        }
        .dna-helix {
            color: #0f8;
            opacity: 0.6;
            animation: helixPulse 2s ease-in-out infinite;
        }
        @keyframes helixPulse {
            0%, 100% { opacity: 0.4; }
            50% { opacity: 0.8; }
        }
        .dna-lineage {
            color: #f0f;
            font-weight: bold;
            letter-spacing: 1px;
        }
        .dna-generation {
            color: #0cf;
        }
        .dna-marker {
            color: #ff0;
            font-size: 12px;
        }
        .dna-sequence {
            color: #0f8;
            letter-spacing: 1px;
            flex: 1;
            text-align: right;
        }
        .dna-sequence .nucleotide-A { color: #0f0; }
        .dna-sequence .nucleotide-T { color: #f80; }
        .dna-sequence .nucleotide-C { color: #08f; }
        .dna-sequence .nucleotide-G { color: #f0f; }
        .dna-label {
            color: var(--text-dim);
            font-size: 8px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        .dna-parent {
            color: #f80;
            font-size: 9px;
            margin-left: auto;
            padding-left: 8px;
            border-left: 1px solid rgba(255,136,0,0.3);
        }
        .dna-parent::before {
            content: 'â†‘ ';
            opacity: 0.6;
        }

        /* Fork Button */
        .manifesto-fork-btn {
            background: transparent;
            border: 1px solid rgba(0,255,136,0.3);
            color: #0f8;
            font-size: 12px;
            padding: 4px 10px;
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            gap: 4px;
        }
        .manifesto-fork-btn:hover {
            background: rgba(0,255,136,0.1);
            border-color: #0f8;
            transform: scale(1.05);
        }
        .manifesto-fork-btn .fork-icon {
            font-size: 14px;
        }

        /* TTS Button for Manifestos */
        .manifesto-tts-btn {
            background: transparent;
            border: 1px solid rgba(168,85,247,0.3);
            color: #a855f7;
            font-size: 12px;
            padding: 4px 10px;
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            gap: 4px;
        }
        .manifesto-tts-btn:hover {
            background: rgba(168,85,247,0.1);
            border-color: #a855f7;
            transform: scale(1.05);
        }
        .manifesto-tts-btn.speaking {
            background: rgba(168,85,247,0.2);
            animation: pulse-speak 1s ease-in-out infinite;
        }

        .manifesto-modal {
            max-width: 600px;
        }

        /* Transparency Slider Bar */
        .transparency-bar {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 6px 16px;
            background: var(--dark-bg);
            border-top: 1px solid var(--border-color);
            font-size: 0.8rem;
            color: var(--text-dim);
        }

        .transparency-bar label {
            white-space: nowrap;
        }

        .transparency-bar input[type="range"] {
            flex: 1;
            max-width: 120px;
            height: 4px;
            -webkit-appearance: none;
            background: var(--border-color);
            border-radius: 2px;
            cursor: pointer;
        }

        .transparency-bar input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 14px;
            height: 14px;
            background: var(--accent);
            border-radius: 50%;
            cursor: pointer;
        }

        .transparency-bar #opacityValue {
            min-width: 35px;
            text-align: right;
            color: var(--accent);
        }

        /* Input Area - now at top of chat */
        .input-area {
            background: var(--dark-bg);
            padding: 12px 16px;
            flex-shrink: 0;
            position: relative;
            z-index: 5;
            border-bottom: 1px solid var(--border-color);
        }

        .input-row {
            display: flex;
            gap: 8px;
            align-items: flex-end;
            max-width: 800px;
            margin: 0 auto;
        }

        .input-actions {
            display: flex;
            gap: 4px;
        }

        .action-btn {
            width: 40px;
            height: 40px;
            border: 1px solid var(--border-color);
            background: transparent;
            color: var(--accent);
            font-size: 18px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .action-btn:hover {
            background: var(--accent-dim);
            color: white;
        }

        .message-input {
            flex: 1;
            background: var(--panel-bg);
            border: 1px solid var(--border-color);
            padding: 10px 16px;
            color: var(--accent-light);
            font-family: inherit;
            font-size: 1.1rem;
            resize: none;
            max-height: 100px;
        }

        .message-input:focus {
            outline: none;
            border-color: var(--accent-dim);
        }

        .message-input::placeholder {
            color: var(--text-dim);
        }

        /* Ghost Text Prediction */
        .ghost-input-wrapper {
            position: relative;
            flex: 1;
            display: flex;
        }

        .ghost-text-layer {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            padding: 10px 16px;
            font-family: inherit;
            font-size: 1.1rem;
            pointer-events: none;
            white-space: pre-wrap;
            word-wrap: break-word;
            overflow: hidden;
            color: transparent;
        }

        .ghost-text-layer .typed {
            color: transparent;
        }

        .ghost-text-layer .ghost {
            color: var(--accent-dim);
            opacity: 0.5;
            animation: ghostPulse 2s ease-in-out infinite;
        }

        @keyframes ghostPulse {
            0%, 100% { opacity: 0.3; }
            50% { opacity: 0.6; }
        }

        .ghost-text-hint {
            position: absolute;
            bottom: -18px;
            right: 5px;
            font-size: 0.65rem;
            color: var(--text-dim);
            opacity: 0;
            transition: opacity 0.3s;
            pointer-events: none;
        }

        .ghost-input-wrapper:focus-within .ghost-text-hint.visible {
            opacity: 0.7;
        }

        .send-btn {
            width: 60px;
            height: 40px;
            border: 1px solid var(--border-color);
            background: var(--accent-dim);
            color: white;
            font-family: inherit;
            font-size: 1rem;
            cursor: pointer;
            transition: all 0.2s;
        }

        .send-btn:hover {
            background: var(--accent);
        }

        /* Modals */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.9);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 1000;
        }

        .modal-overlay.active {
            display: flex;
        }

        .modal {
            background: var(--panel-bg);
            border: 1px solid var(--border-color);
            padding: 24px;
            width: 90%;
            max-width: 400px;
            max-height: 85vh;
            overflow-y: auto;
            color: var(--accent);
        }

        .modal h2 {
            margin-bottom: 16px;
            display: flex;
            align-items: center;
            gap: 10px;
            color: var(--accent-light);
            font-size: 1.5rem;
        }

        .modal-close {
            margin-left: auto;
            background: none;
            border: none;
            color: var(--text-dim);
            font-size: 24px;
            cursor: pointer;
        }

        /* GIF Modal */
        .gif-search-row {
            display: flex;
            gap: 8px;
            margin-bottom: 12px;
        }

        .gif-search-row input {
            flex: 1;
            padding: 10px 12px;
            background: var(--dark-bg);
            border: 1px solid var(--border-color);
            color: var(--text);
            font-family: inherit;
            font-size: 1rem;
        }

        .gif-search-row input:focus {
            outline: none;
            border-color: var(--accent);
        }

        .gif-trending-label {
            font-size: 0.85rem;
            color: var(--text-dim);
            margin-bottom: 8px;
        }

        .gif-results {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 6px;
            max-height: 350px;
            overflow-y: auto;
            background: var(--dark-bg);
            padding: 8px;
            border: 1px solid var(--border-color);
        }

        .gif-results img {
            width: 100%;
            aspect-ratio: 1;
            object-fit: cover;
            cursor: pointer;
            border-radius: 4px;
            transition: transform 0.15s, opacity 0.15s;
        }

        .gif-results img:hover {
            transform: scale(1.05);
            opacity: 0.9;
        }

        .gif-loading, .gif-error, .gif-empty {
            grid-column: 1 / -1;
            text-align: center;
            padding: 40px 20px;
            color: var(--text-dim);
        }

        .giphy-attribution {
            margin-top: 12px;
            text-align: center;
            font-size: 0.75rem;
            color: var(--text-dim);
            opacity: 0.7;
        }

        .message-gif {
            max-width: 250px;
            max-height: 200px;
            border-radius: 8px;
            cursor: pointer;
        }

        @media (max-width: 500px) {
            .gif-results {
                grid-template-columns: repeat(2, 1fr);
                max-height: 280px;
            }
        }

        /* Settings Tabs */
        .settings-tabs {
            display: flex;
            gap: 0;
            margin-bottom: 20px;
            border-bottom: 1px solid var(--border-color);
        }

        .settings-tab {
            padding: 10px 20px;
            background: transparent;
            border: none;
            border-bottom: 2px solid transparent;
            color: var(--text-dim);
            font-family: inherit;
            font-size: 1.1rem;
            cursor: pointer;
            transition: all 0.2s;
        }

        .settings-tab:hover {
            color: var(--accent);
        }

        .settings-tab.active {
            color: var(--accent-light);
            border-bottom-color: var(--accent);
        }

        .settings-panel {
            display: none;
        }

        .settings-panel.active {
            display: block;
        }

        /* Sound Library */
        .sound-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 10px;
            margin-bottom: 16px;
        }

        .sound-option {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 10px 12px;
            background: var(--dark-bg);
            border: 2px solid var(--border-color);
            cursor: pointer;
            transition: all 0.2s;
        }

        .sound-option:hover {
            border-color: var(--accent-dim);
        }

        .sound-option.selected {
            border-color: var(--accent);
            background: rgba(124, 152, 133, 0.1);
        }

        .sound-option .sound-icon {
            font-size: 1.5rem;
        }

        .sound-option .sound-name {
            font-size: 1rem;
            color: var(--accent-light);
        }

        .sound-preview-btn {
            margin-left: auto;
            background: var(--border-color);
            border: none;
            color: var(--accent);
            padding: 4px 8px;
            font-family: inherit;
            font-size: 0.9rem;
            cursor: pointer;
        }

        .sound-preview-btn:hover {
            background: var(--accent-dim);
        }

        .volume-control {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-top: 16px;
            padding-top: 16px;
            border-top: 1px solid var(--border-color);
        }

        .volume-control label {
            color: var(--text-dim);
        }

        .volume-control input[type="range"] {
            flex: 1;
        }

        /* Message Color Picker */
        .color-picker-grid {
            display: grid;
            grid-template-columns: repeat(5, 1fr);
            gap: 8px;
            margin-bottom: 16px;
        }

        .msg-color-option {
            aspect-ratio: 1;
            border: 2px solid var(--border-color);
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.2s;
            min-height: 36px;
        }

        .msg-color-option:hover {
            border-color: var(--accent);
            transform: scale(1.05);
        }

        .msg-color-option.selected {
            border-color: var(--accent-light);
            box-shadow: 0 0 8px var(--accent);
        }

        .theme-slider-row {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 16px;
        }

        .theme-slider-row label {
            min-width: 80px;
            color: var(--text-dim);
        }

        .theme-slider-row input[type="range"] {
            flex: 1;
        }

        .theme-slider-row span {
            min-width: 40px;
            text-align: right;
            color: var(--accent);
        }

        /* Avatar Picker */
        .avatar-grid {
            display: grid;
            grid-template-columns: repeat(6, 1fr);
            gap: 8px;
            margin-bottom: 16px;
        }

        .avatar-option {
            aspect-ratio: 1;
            border: 2px solid #333;
            background: var(--dark-bg);
            font-size: 28px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s;
        }

        .avatar-option:hover {
            border-color: var(--accent-dim);
        }

        .avatar-option.selected {
            border-color: var(--accent);
        }

        .form-group {
            margin-bottom: 16px;
        }

        .form-group label {
            display: block;
            margin-bottom: 6px;
            font-size: 1rem;
            color: var(--highlight);
        }

        .form-group input {
            width: 100%;
            padding: 10px;
            background: var(--dark-bg);
            border: 1px solid var(--border-color);
            color: var(--accent-light);
            font-family: inherit;
            font-size: 1.1rem;
        }

        .form-group input:focus {
            outline: none;
            border-color: var(--accent-dim);
        }

        .color-options {
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
        }

        .color-option {
            width: 32px;
            height: 32px;
            border: 2px solid transparent;
            cursor: pointer;
        }

        .color-option:hover {
            transform: scale(1.1);
        }

        .color-option.selected {
            border-color: white;
        }

        .modal-btn {
            width: 100%;
            padding: 12px;
            background: var(--accent-dim);
            border: 1px solid var(--border-color);
            color: white;
            font-family: inherit;
            font-size: 1.1rem;
            cursor: pointer;
            margin-top: 16px;
            transition: all 0.2s;
        }

        .modal-btn:hover {
            background: var(--accent);
        }

        /* File Upload */
        .file-upload-row {
            display: flex;
            gap: 8px;
        }

        .file-upload-btn {
            flex: 1;
            padding: 10px;
            background: var(--dark-bg);
            border: 1px dashed var(--border-color);
            color: var(--text-dim);
            font-family: inherit;
            font-size: 0.9rem;
            cursor: pointer;
            transition: all 0.2s;
        }

        .file-upload-btn:hover {
            border-color: var(--accent);
            color: var(--accent);
        }

        .file-clear-btn {
            padding: 10px 15px;
            background: #3a2020;
            border: 1px solid #5a3030;
            color: #ff6666;
            font-family: inherit;
            font-size: 0.9rem;
            cursor: pointer;
            transition: all 0.2s;
        }

        .file-clear-btn:hover {
            background: #4a2525;
        }

        .upload-preview {
            margin-top: 10px;
            border: 1px solid var(--border-color);
            padding: 8px;
            background: var(--dark-bg);
        }

        .upload-preview img {
            max-width: 100%;
            max-height: 150px;
            display: block;
            margin: 0 auto;
        }

        /* Global Backgrounds */
        .global-bg-section {
            margin-top: 8px;
        }

        .global-bg-label {
            font-size: 0.85rem;
            color: var(--text-dim);
            margin-bottom: 8px;
        }

        .global-bg-grid {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 8px;
            max-height: 150px;
            overflow-y: auto;
        }

        .global-bg-item {
            aspect-ratio: 16/9;
            border: 2px solid var(--border-color);
            border-radius: 4px;
            overflow: hidden;
            cursor: pointer;
            transition: all 0.2s;
        }

        .global-bg-item:hover {
            border-color: var(--accent);
            transform: scale(1.05);
        }

        .global-bg-item.selected {
            border-color: var(--highlight);
        }

        .global-bg-item img {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        .global-bg-upload {
            display: flex;
            align-items: center;
            justify-content: center;
            background: var(--dark-bg);
            color: var(--text-dim);
            font-size: 1.5rem;
        }

        .global-bg-upload:hover {
            color: var(--accent);
        }

        /* Drawing Canvas */
        .drawing-modal .modal {
            max-width: 500px;
        }

        .canvas-container {
            background: #111;
            border: 1px solid var(--border-color);
            margin-bottom: 16px;
        }

        #drawingCanvas {
            display: block;
            width: 100%;
            cursor: crosshair;
            touch-action: none;
        }

        .canvas-tools {
            display: flex;
            gap: 8px;
            margin-bottom: 12px;
            flex-wrap: wrap;
        }

        .tool-btn {
            padding: 8px 12px;
            background: transparent;
            border: 1px solid var(--border-color);
            color: var(--accent);
            cursor: pointer;
            font-family: inherit;
        }

        .tool-btn:hover, .tool-btn.active {
            background: var(--accent-dim);
            color: white;
        }

        .tool-btn:disabled {
            opacity: 0.4;
            cursor: not-allowed;
        }

        .tool-btn:disabled:hover {
            background: transparent;
            color: var(--accent);
        }

        .canvas-actions {
            display: flex;
            gap: 6px;
            margin-left: auto;
        }

        .brush-colors {
            display: flex;
            gap: 6px;
        }

        .brush-color {
            width: 28px;
            height: 28px;
            border: 2px solid #333;
            cursor: pointer;
        }

        .brush-color.selected {
            border-color: white;
        }

        /* Image preview */
        .image-preview {
            margin-bottom: 8px;
            position: relative;
            display: none;
        }

        .image-preview img {
            max-width: 200px;
            max-height: 150px;
            border: 1px solid var(--border-color);
        }

        .image-preview .remove-btn {
            position: absolute;
            top: -8px;
            right: -8px;
            width: 24px;
            height: 24px;
            background: #ff4444;
            border: none;
            color: white;
            cursor: pointer;
            font-size: 16px;
        }

        .empty-state {
            text-align: center;
            padding: 40px;
            color: var(--text-dim);
        }

        .empty-state .icon {
            font-size: 48px;
            margin-bottom: 16px;
        }

        /* Infinite scroll loading indicator */
        .loading-indicator {
            text-align: center;
            padding: 16px;
            color: var(--accent);
            font-size: 0.85rem;
            animation: pulse 1.5s ease-in-out infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 0.5; }
            50% { opacity: 1; }
        }

        /* System Toast Notifications */
        .toast-container {
            position: fixed;
            top: 20px;
            right: 20px;
            z-index: 10000;
            display: flex;
            flex-direction: column;
            gap: 10px;
            pointer-events: none;
        }

        .system-toast {
            background: var(--panel-bg, #1a1a2e);
            border: 1px solid var(--border-color, #333);
            border-left: 4px solid var(--accent, #00ff41);
            padding: 12px 16px;
            border-radius: 4px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4);
            max-width: 320px;
            font-size: 0.85rem;
            color: var(--text-light, #e0e0e0);
            pointer-events: auto;
            animation: slideIn 0.3s ease-out;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .system-toast.success { border-left-color: #00ff41; }
        .system-toast.error { border-left-color: #ff4444; }
        .system-toast.warning { border-left-color: #ffaa00; }
        .system-toast.info { border-left-color: #00aaff; }

        .system-toast .toast-icon {
            font-size: 1.2rem;
            flex-shrink: 0;
        }

        .system-toast .toast-message {
            flex: 1;
        }

        .system-toast .toast-close {
            background: none;
            border: none;
            color: var(--text-dim, #888);
            cursor: pointer;
            padding: 0;
            font-size: 1rem;
            line-height: 1;
            opacity: 0.7;
        }

        .system-toast .toast-close:hover {
            opacity: 1;
        }

        .system-toast.fade-out {
            animation: slideOut 0.3s ease-in forwards;
        }

        @keyframes slideIn {
            from { transform: translateX(100%); opacity: 0; }
            to { transform: translateX(0); opacity: 1; }
        }

        @keyframes slideOut {
            from { transform: translateX(0); opacity: 1; }
            to { transform: translateX(100%); opacity: 0; }
        }

        @media (max-width: 600px) {
            .toast-container {
                top: auto;
                bottom: 80px;
                right: 10px;
                left: 10px;
            }
            .system-toast {
                max-width: none;
            }
        }

        #imageInput {
            display: none;
        }

        /* Mobile toggle buttons */
        .mobile-toggle {
            display: none;
        }

        /* Hamburger menu button */
        .hamburger-btn {
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            width: 40px;
            height: 40px;
            background: var(--dark-bg);
            border: 1px solid var(--border-color);
            border-radius: 6px;
            cursor: pointer;
            padding: 8px;
            gap: 4px;
            transition: all 0.2s;
        }

        .hamburger-btn:hover {
            background: var(--border-color);
        }

        .hamburger-btn span {
            display: block;
            width: 20px;
            height: 2px;
            background: var(--accent);
            border-radius: 1px;
            transition: all 0.3s;
        }

        .hamburger-btn.active span:nth-child(1) {
            transform: rotate(45deg) translate(4px, 4px);
        }

        .hamburger-btn.active span:nth-child(2) {
            opacity: 0;
        }

        .hamburger-btn.active span:nth-child(3) {
            transform: rotate(-45deg) translate(4px, -4px);
        }

        @media (max-width: 768px) {
            .mobile-toggle {
                display: inline-block;
            }

            .hamburger-btn {
                display: flex;
            }

            .desktop-only {
                display: none !important;
            }
        }

        /* Desktop-only buttons hidden on mobile */
        .desktop-only {
            display: inline-flex;
        }

        /* Mobile dropdown menu */
        .mobile-menu {
            display: none;
            position: absolute;
            top: 100%;
            right: 0;
            background: var(--panel-bg);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5);
            min-width: 180px;
            z-index: 200;
            overflow: hidden;
        }

        .mobile-menu.active {
            display: block;
        }

        .mobile-menu-item {
            display: flex;
            align-items: center;
            gap: 10px;
            width: 100%;
            padding: 14px 16px;
            background: transparent;
            border: none;
            border-bottom: 1px solid var(--border-color);
            color: var(--text-main);
            font-family: inherit;
            font-size: 0.95rem;
            text-align: left;
            cursor: pointer;
            transition: background 0.2s, color 0.2s;
        }

        .mobile-menu-item:last-child {
            border-bottom: none;
        }

        .mobile-menu-item:hover {
            background: var(--dark-bg);
            color: var(--accent);
        }

        .mobile-menu-item:active {
            background: var(--border-color);
        }

        .mobile-menu-item .menu-icon {
            display: inline-block;
            width: 24px;
            text-align: center;
        }

        /* Tabs */
        .view-tabs {
            display: flex;
            background: var(--dark-bg);
            border-bottom: 1px solid var(--border-color);
            flex-shrink: 0;
        }

        .view-tab {
            flex: 1;
            padding: 10px;
            background: transparent;
            border: none;
            border-bottom: 2px solid transparent;
            color: var(--text-dim);
            font-family: inherit;
            font-size: 1rem;
            cursor: pointer;
            transition: all 0.2s;
        }

        .view-tab:hover {
            color: var(--accent);
        }

        .view-tab.active {
            color: var(--accent-light);
            border-bottom-color: var(--accent);
        }

        /* Posts Container */
        .posts-container {
            flex: 1;
            overflow-y: auto;
            padding: 16px;
            display: none;
            flex-direction: column;
            gap: 16px;
            min-height: 0;
        }

        .messages-container.hidden {
            display: none;
        }

        /* Post Card */
        .post-card {
            background: rgba(255, 255, 255, 0.03);
            border: 1px solid var(--border-color);
            overflow: hidden;
            flex-shrink: 0;
        }

        .post-header {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 12px;
            border-bottom: 1px solid var(--border-color);
        }

        .post-avatar {
            width: 36px;
            height: 36px;
            border-radius: 50%;
            background: var(--dark-bg);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 20px;
            border: 1px solid var(--border-color);
        }

        .post-username {
            color: var(--accent-light);
            font-size: 1.1rem;
        }

        .post-time {
            color: var(--text-dim);
            font-size: 0.9rem;
            flex: 1;
        }

        .post-delete-btn {
            background: none;
            border: none;
            cursor: pointer;
            font-size: 1.1rem;
            opacity: 0.7;
            transition: all 0.2s;
            padding: 4px 8px;
            border-radius: 4px;
        }

        .post-delete-btn:hover {
            opacity: 1;
            background: rgba(255, 100, 100, 0.15);
        }

        /* Reputation Badges */
        .rep-badge {
            display: inline-flex;
            align-items: center;
            gap: 2px;
            background: linear-gradient(135deg, var(--accent-dim), var(--highlight));
            color: white;
            padding: 2px 6px;
            border-radius: 10px;
            font-size: 0.75rem;
            margin-left: 6px;
            cursor: help;
        }

        .rep-badge.small {
            background: var(--border-color);
            color: var(--text-dim);
        }

        .post-image {
            width: 100%;
            max-height: 400px;
            object-fit: contain;
            background: #000;
            display: block;
        }

        .post-caption {
            padding: 12px;
            font-size: 1.1rem;
            line-height: 1.4;
            border-top: 1px solid var(--border-color);
        }

        /* Post Tags */
        .post-tags {
            display: flex;
            flex-wrap: wrap;
            gap: 6px;
            padding: 8px 12px;
            border-top: 1px solid var(--border-color);
        }

        .tag {
            background: linear-gradient(135deg, rgba(124, 152, 133, 0.2), rgba(169, 196, 176, 0.1));
            border: 1px solid var(--accent-dim);
            border-radius: 4px;
            padding: 3px 8px;
            font-size: 0.85rem;
            color: var(--accent-light);
            cursor: pointer;
            transition: all 0.2s;
        }

        .tag:hover {
            background: var(--accent-dim);
            color: white;
        }

        .tag.nested {
            background: linear-gradient(135deg, rgba(201, 168, 124, 0.2), rgba(201, 168, 124, 0.1));
            border-color: var(--highlight);
            color: var(--highlight);
        }

        .tag.nested:hover {
            background: var(--highlight);
            color: var(--dark-bg);
        }

        .tag-hierarchy {
            font-size: 0.7rem;
            opacity: 0.7;
            margin-right: 2px;
        }

        /* Tag Filter Bar */
        .tag-filter-bar {
            display: none;
            padding: 8px 12px;
            background: var(--dark-bg);
            border-bottom: 1px solid var(--border-color);
            align-items: center;
            gap: 8px;
            flex-shrink: 0;
        }

        .tag-filter-bar.active {
            display: flex;
        }

        /* Ensure posts container takes remaining space */
        .posts-container.active {
            display: flex;
            flex-direction: column;
            flex: 1;
            min-height: 0;
            overflow-y: auto;
        }

        .tag-filter-bar .tag {
            background: var(--accent);
            color: white;
        }

        .clear-filter {
            background: none;
            border: none;
            color: var(--text-dim);
            cursor: pointer;
            font-size: 1.2rem;
            padding: 0 8px;
        }

        .clear-filter:hover {
            color: #ff6666;
        }

        /* Chat Filter Bar */
        .chat-filter-bar {
            display: none;
            padding: 8px 12px;
            background: linear-gradient(135deg, rgba(124, 152, 133, 0.15) 0%, rgba(124, 152, 133, 0.05) 100%);
            border-bottom: 1px solid var(--border-color);
            align-items: center;
            gap: 8px;
            flex-shrink: 0;
        }

        .chat-filter-bar.active {
            display: flex;
        }

        .chat-filter-value {
            display: inline-block;
            background: var(--accent);
            color: var(--dark-bg);
            padding: 2px 10px;
            border-radius: 4px;
            font-weight: bold;
            font-size: 0.9rem;
        }

        .chat-filter-value.mention {
            background: linear-gradient(135deg, #ff00ff 0%, #ff88ff 100%);
        }

        /* Trending Tags */
        .trending-tags {
            padding: 12px;
            border-top: 1px solid var(--border-color);
        }

        .trending-title {
            font-size: 0.8rem;
            color: var(--text-dim);
            margin-bottom: 8px;
            text-transform: uppercase;
            letter-spacing: 0.1em;
        }

        .trending-list {
            display: flex;
            flex-wrap: wrap;
            gap: 6px;
        }

        .trending-tag {
            background: rgba(255,255,255,0.05);
            border: 1px solid var(--border-color);
            border-radius: 12px;
            padding: 4px 10px;
            font-size: 0.8rem;
            color: var(--accent);
            cursor: pointer;
            transition: all 0.2s;
        }

        .trending-tag:hover {
            border-color: var(--accent);
            background: rgba(124, 152, 133, 0.2);
        }

        .trending-tag .count,
        .trending-tag .tag-count {
            color: var(--text-dim);
            font-size: 0.7rem;
            margin-left: 4px;
        }

        .trending-tag.hot {
            background: linear-gradient(135deg, rgba(255,100,100,0.2), rgba(255,150,100,0.1));
            border-color: #ff6666;
            color: #ff9999;
        }

        .trending-tag.warm {
            background: linear-gradient(135deg, rgba(201,168,124,0.2), rgba(201,168,124,0.1));
            border-color: var(--highlight);
            color: var(--highlight);
        }

        .trending-tags-section {
            margin-top: 12px;
            padding-top: 12px;
            border-top: 1px solid var(--border-color);
            flex-shrink: 0;
        }

        .trending-tags-list {
            display: flex;
            flex-direction: column;
            gap: 6px;
            max-height: 30vh;
            overflow-y: auto;
        }

        .trending-tags-list .trending-tag {
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        /* Tag Input */
        .tag-input-container {
            display: flex;
            flex-wrap: wrap;
            gap: 6px;
            padding: 8px;
            background: var(--dark-bg);
            border: 1px solid var(--border-color);
            min-height: 40px;
            align-items: center;
        }

        .tag-input-container .tag {
            display: flex;
            align-items: center;
            gap: 4px;
        }

        .tag-input-container .tag .remove {
            cursor: pointer;
            opacity: 0.7;
        }

        .tag-input-container .tag .remove:hover {
            opacity: 1;
        }

        .tag-input {
            flex: 1;
            min-width: 100px;
            background: transparent;
            border: none;
            color: var(--accent);
            font-family: inherit;
            font-size: 0.9rem;
            outline: none;
            padding: 4px 0;
        }

        .tag-input::placeholder {
            color: var(--text-dim);
        }

        .tag-input:focus {
            box-shadow: none;
        }

        /* Tag input field in message area */
        .message-input[data-tag-mode="true"] {
            border-color: var(--accent);
            box-shadow: 0 0 8px rgba(0, 255, 136, 0.3);
        }

        .post-actions {
            display: flex;
            gap: 16px;
            padding: 10px 12px;
            border-top: 1px solid var(--border-color);
        }

        .post-action-btn {
            background: none;
            border: none;
            color: var(--text-dim);
            font-family: inherit;
            font-size: 1rem;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 6px;
            transition: color 0.2s;
        }

        .post-action-btn:hover {
            color: var(--accent-light);
        }

        .post-action-btn.liked {
            color: #ff4466;
        }

        .post-action-btn.speaking {
            color: var(--accent-light);
            animation: pulse-speak 1s ease-in-out infinite;
        }

        @keyframes pulse-speak {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        /* Emoji Reactions */
        .post-reactions {
            display: flex;
            flex-wrap: wrap;
            gap: 6px;
            padding: 8px 12px;
            border-top: 1px solid var(--border-color);
        }

        .reaction-btn {
            background: rgba(255,255,255,0.05);
            border: 1px solid var(--border-color);
            border-radius: 16px;
            padding: 4px 10px;
            font-size: 0.9rem;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 4px;
            transition: all 0.2s;
        }

        .reaction-btn:hover {
            background: rgba(255,255,255,0.1);
            border-color: var(--accent);
        }

        .reaction-btn.active {
            background: rgba(124, 152, 133, 0.2);
            border-color: var(--accent);
        }

        .reaction-count {
            font-size: 0.8rem;
            color: var(--text-dim);
        }

        .add-reaction-btn {
            background: transparent;
            border: 1px dashed var(--border-color);
            border-radius: 16px;
            padding: 4px 10px;
            font-size: 0.9rem;
            cursor: pointer;
            color: var(--text-dim);
            transition: all 0.2s;
        }

        .add-reaction-btn:hover {
            border-color: var(--accent);
            color: var(--accent);
        }

        .reaction-picker {
            display: none;
            position: absolute;
            bottom: 100%;
            left: 0;
            background: var(--panel-bg);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            padding: 8px;
            gap: 4px;
            flex-wrap: wrap;
            max-width: 200px;
            z-index: 10;
        }

        .reaction-picker.active {
            display: flex;
        }

        .reaction-picker button {
            background: none;
            border: none;
            font-size: 1.2rem;
            cursor: pointer;
            padding: 4px;
            border-radius: 4px;
            transition: background 0.2s;
        }

        .reaction-picker button:hover {
            background: rgba(255,255,255,0.1);
        }

        /* Message Reactions - compact for chat */
        .msg-reactions {
            display: flex;
            flex-wrap: wrap;
            gap: 4px;
            margin-top: 6px;
        }

        .msg-reactions .reaction-btn {
            padding: 2px 6px;
            font-size: 0.75rem;
            border-radius: 12px;
        }

        .msg-reactions .reaction-count {
            font-size: 0.7rem;
        }

        .msg-reactions .add-reaction-btn {
            padding: 2px 6px;
            font-size: 0.75rem;
            border-radius: 12px;
        }

        .msg-reactions .reaction-picker {
            bottom: auto;
            top: 100%;
            max-width: 180px;
        }

        .post-comments {
            border-top: 1px solid var(--border-color);
            max-height: 200px;
            overflow-y: auto;
        }

        .comment {
            display: flex;
            gap: 8px;
            padding: 8px 12px;
            border-bottom: 1px solid rgba(255,255,255,0.05);
        }

        .comment-avatar {
            font-size: 16px;
        }

        .comment-content {
            flex: 1;
        }

        .comment-username {
            color: var(--accent);
            font-size: 0.95rem;
        }

        .comment-text {
            color: var(--accent-light);
            font-size: 1rem;
        }

        .comment-input-row {
            display: flex;
            gap: 8px;
            padding: 8px 12px;
            border-top: 1px solid var(--border-color);
        }

        .comment-input {
            flex: 1;
            background: var(--dark-bg);
            border: 1px solid var(--border-color);
            padding: 8px 12px;
            color: var(--accent-light);
            font-family: inherit;
            font-size: 1rem;
        }

        .comment-input:focus {
            outline: none;
            border-color: var(--accent-dim);
        }

        .comment-send {
            background: var(--accent-dim);
            border: none;
            color: white;
            padding: 8px 16px;
            font-family: inherit;
            cursor: pointer;
        }

        .comment-send:hover {
            background: var(--accent);
        }

        /* Threaded Comments - natural cascade */
        .comment-replies {
            margin-left: 12px;
            padding-left: 12px;
            border-left: 1px solid var(--border-color);
            margin-top: 4px;
        }

        .comment-thread {
            margin-top: 6px;
        }

        .comment-actions {
            display: flex;
            gap: 12px;
            margin-top: 4px;
        }

        .comment-reply-btn {
            background: none;
            border: none;
            color: var(--text-dim);
            font-family: inherit;
            font-size: 0.8rem;
            cursor: pointer;
            padding: 0;
        }

        .comment-reply-btn:hover {
            color: var(--accent);
        }

        .comment-vote-controls {
            display: inline-flex;
            align-items: center;
            gap: 2px;
            margin-left: 8px;
        }

        .comment-vote-btn {
            background: none;
            border: none;
            color: var(--text-dim);
            font-size: 0.75rem;
            cursor: pointer;
            padding: 0 2px;
            opacity: 0.7;
        }

        .comment-vote-btn:hover { opacity: 1; }
        .comment-vote-btn.upvote:hover, .comment-vote-btn.upvote.active { color: #00ff41; opacity: 1; }
        .comment-vote-btn.downvote:hover, .comment-vote-btn.downvote.active { color: #ff4444; opacity: 1; }
        .comment-vote-btn.disabled { opacity: 0.3; cursor: not-allowed; }

        .comment-vote-score {
            font-size: 0.75rem;
            min-width: 16px;
            text-align: center;
            color: var(--text-dim);
        }
        .comment-vote-score.positive { color: #00ff41; }
        .comment-vote-score.negative { color: #ff4444; }

        .reply-indicator {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 6px 12px;
            background: rgba(124, 152, 133, 0.1);
            border-left: 3px solid var(--accent);
            margin-bottom: 4px;
            font-size: 0.85rem;
        }

        .reply-indicator .cancel-reply {
            background: none;
            border: none;
            color: var(--text-dim);
            cursor: pointer;
            font-size: 1rem;
            padding: 0 4px;
        }

        .reply-indicator .cancel-reply:hover {
            color: #ff6b6b;
        }

        .comment-time {
            color: var(--text-dim);
            font-size: 0.75rem;
            margin-left: 8px;
        }

        /* Create Post Button */
        .create-post-btn {
            position: fixed;
            bottom: 80px;
            right: 20px;
            width: 56px;
            height: 56px;
            border-radius: 50%;
            background: var(--accent-dim);
            border: 2px solid var(--accent);
            color: white;
            font-size: 28px;
            cursor: pointer;
            z-index: 50;
            display: none;
            align-items: center;
            justify-content: center;
            transition: all 0.2s;
        }

        .create-post-btn.visible {
            display: flex;
        }

        .create-post-btn:hover {
            background: var(--accent);
            transform: scale(1.1);
        }

        /* Post Modal */
        .post-modal .modal {
            max-width: 500px;
        }

        .post-preview {
            margin-bottom: 16px;
            border: 1px solid var(--border-color);
            background: #000;
            min-height: 100px;
            display: flex;
            align-items: center;
            justify-content: center;
            color: var(--text-dim);
        }

        .post-preview img {
            max-width: 100%;
            max-height: 300px;
            display: block;
        }

        .post-preview.has-image {
            min-height: auto;
        }

        .or-divider {
            text-align: center;
            margin: 12px 0;
            color: var(--text-dim);
        }

        /* Profile Card */
        .profile-card {
            position: fixed;
            z-index: 10000;
            background: var(--dark-bg);
            border: 1px solid var(--accent);
            border-radius: 8px;
            padding: 16px;
            min-width: 220px;
            max-width: 280px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.5);
            display: none;
            animation: profileCardIn 0.15s ease-out;
        }

        @keyframes profileCardIn {
            from { opacity: 0; transform: translateY(-8px) scale(0.95); }
            to { opacity: 1; transform: translateY(0) scale(1); }
        }

        .profile-card.visible {
            display: block;
        }

        .profile-trust-row {
            display: flex;
            align-items: center;
            gap: 6px;
            margin-bottom: 10px;
            padding: 6px 10px;
            background: rgba(168, 85, 247, 0.1);
            border: 1px solid rgba(168, 85, 247, 0.25);
            border-radius: 6px;
            font-size: 11px;
        }
        .profile-trust-score {
            font-family: 'Orbitron', 'JetBrains Mono', monospace;
            font-weight: 600;
            color: #a855f7;
        }
        .profile-trust-label {
            color: #8a7a9a;
            font-size: 9px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        .profile-verify-badges {
            display: flex;
            gap: 4px;
            margin-left: auto;
        }
        .verify-badge {
            padding: 2px 6px;
            border-radius: 3px;
            font-size: 9px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.3px;
        }
        .verify-badge.twitter { background: rgba(29, 161, 242, 0.2); color: #1da1f2; }
        .verify-badge.email { background: rgba(0, 212, 255, 0.2); color: #00d4ff; }
        .verify-badge.github { background: rgba(255, 255, 255, 0.1); color: #ccc; }
        .sloppyid-link {
            display: block;
            text-align: center;
            margin-top: 10px;
            padding: 10px;
            background: linear-gradient(135deg, rgba(0, 212, 255, 0.1), rgba(168, 85, 247, 0.1));
            border: 1px solid rgba(0, 212, 255, 0.3);
            border-radius: 6px;
            color: #00d4ff;
            font-size: 12px;
            text-decoration: none;
            transition: all 0.2s;
        }
        .sloppyid-link:hover {
            background: linear-gradient(135deg, rgba(0, 212, 255, 0.2), rgba(168, 85, 247, 0.2));
            border-color: #00d4ff;
        }

        /* SloppyID Profile Card in Settings */
        .sloppyid-card {
            background: linear-gradient(135deg, rgba(0, 212, 255, 0.08), rgba(168, 85, 247, 0.08));
            border: 1px solid rgba(0, 212, 255, 0.25);
            border-radius: 10px;
            padding: 16px;
            margin-bottom: 16px;
        }
        .sloppyid-card-header {
            display: flex;
            align-items: center;
            gap: 12px;
            margin-bottom: 12px;
        }
        .sloppyid-avatar {
            width: 48px;
            height: 48px;
            font-size: 32px;
            display: flex;
            align-items: center;
            justify-content: center;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 50%;
            border: 2px solid rgba(0, 212, 255, 0.4);
        }
        .sloppyid-info {
            flex: 1;
        }
        .sloppyid-username {
            font-size: 16px;
            font-weight: 600;
            color: #00d4ff;
        }
        .sloppyid-trust {
            font-size: 12px;
            color: #a855f7;
            margin-top: 2px;
        }
        .sloppyid-badges {
            display: flex;
            gap: 6px;
            flex-wrap: wrap;
            margin-bottom: 12px;
        }
        .settings-verify-badge {
            font-size: 11px;
            padding: 3px 8px;
            border-radius: 4px;
            background: rgba(255, 255, 255, 0.1);
        }
        .settings-verify-badge.twitter { background: rgba(29, 161, 242, 0.2); color: #1da1f2; }
        .settings-verify-badge.email { background: rgba(0, 212, 255, 0.2); color: #00d4ff; }
        .settings-verify-badge.github { background: rgba(255, 255, 255, 0.15); color: #ddd; }
        .settings-no-badges {
            font-size: 11px;
            color: #666;
            font-style: italic;
        }
        .sloppyid-edit-btn {
            display: block;
            width: 100%;
            padding: 10px 16px;
            background: linear-gradient(135deg, #00d4ff, #a855f7);
            border: none;
            border-radius: 6px;
            color: #000;
            font-size: 13px;
            font-weight: 600;
            text-align: center;
            text-decoration: none;
            cursor: pointer;
            transition: all 0.2s;
        }
        .sloppyid-edit-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(0, 212, 255, 0.3);
        }
        .sloppyid-note {
            font-size: 10px;
            color: #666;
            text-align: center;
            margin-top: 8px;
        }

        .profile-card-header {
            display: flex;
            align-items: center;
            gap: 12px;
            margin-bottom: 12px;
        }

        .profile-card-avatar {
            width: 48px;
            height: 48px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 28px;
            background: var(--panel-bg);
            border: 2px solid var(--accent);
            overflow: hidden;
        }

        .profile-card-avatar img {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        .profile-card-name {
            font-size: 1.2rem;
            color: var(--accent-light);
            font-weight: bold;
        }

        .profile-card-stats {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 8px;
            margin-bottom: 12px;
            text-align: center;
        }

        .profile-card-stat {
            background: var(--panel-bg);
            padding: 8px 4px;
            border-radius: 4px;
        }

        .profile-card-stat-value {
            font-size: 1.1rem;
            color: var(--highlight);
            font-weight: bold;
        }

        .profile-card-stat-label {
            font-size: 0.7rem;
            color: var(--text-dim);
            text-transform: uppercase;
        }

        .profile-card-loading {
            text-align: center;
            padding: 20px;
            color: var(--text-dim);
        }

        .profile-karma-section {
            background: linear-gradient(135deg, rgba(139, 92, 246, 0.15), rgba(59, 130, 246, 0.15));
            border: 1px solid rgba(139, 92, 246, 0.3);
            border-radius: 8px;
            padding: 10px 12px;
            margin-bottom: 12px;
        }

        .profile-karma-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 6px;
        }

        .profile-karma-total {
            font-size: 1.3rem;
            font-weight: bold;
            color: #fbbf24;
            text-shadow: 0 0 8px rgba(251, 191, 36, 0.5);
        }

        .profile-karma-badges {
            display: flex;
            gap: 4px;
        }

        .profile-karma-badge {
            font-size: 1rem;
            filter: drop-shadow(0 0 4px rgba(255, 255, 255, 0.3));
        }

        .profile-karma-breakdown {
            display: flex;
            gap: 12px;
            font-size: 0.8rem;
            color: var(--text-dim);
        }

        .profile-karma-breakdown span {
            display: flex;
            align-items: center;
            gap: 2px;
        }

        .username-clickable {
            cursor: pointer;
            transition: color 0.15s;
        }

        .username-clickable:hover {
            color: var(--highlight);
            text-decoration: underline;
        }

        /* Social Graph - Follows */
        .profile-follow-stats {
            display: flex;
            justify-content: center;
            gap: 20px;
            margin-bottom: 12px;
            padding: 8px 0;
            border-bottom: 1px solid var(--border);
        }

        .profile-follow-stat {
            text-align: center;
            cursor: pointer;
            transition: opacity 0.2s;
        }

        .profile-follow-stat:hover {
            opacity: 0.8;
        }

        .profile-follow-stat-value {
            font-size: 1.1rem;
            color: var(--highlight);
            font-weight: bold;
        }

        .profile-follow-stat-label {
            font-size: 0.65rem;
            color: var(--text-dim);
            text-transform: uppercase;
        }

        .follow-btn {
            padding: 6px 16px;
            border-radius: 4px;
            font-size: 0.75rem;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.2s;
            border: 1px solid;
        }

        .follow-btn.follow {
            background: linear-gradient(135deg, #8b5cf6, #6366f1);
            border-color: #8b5cf6;
            color: white;
        }

        .follow-btn.follow:hover {
            background: linear-gradient(135deg, #9f7afa, #818cf8);
            box-shadow: 0 0 15px rgba(139, 92, 246, 0.4);
        }

        .follow-btn.following {
            background: transparent;
            border-color: var(--text-dim);
            color: var(--text-dim);
        }

        .follow-btn.following:hover {
            border-color: #ef4444;
            color: #ef4444;
        }

        /* Mentions highlight for self */
        .chat-mention.self-mention {
            background: linear-gradient(135deg, rgba(255, 215, 0, 0.3) 0%, rgba(255, 165, 0, 0.2) 100%);
            color: #ffd700;
            border-color: rgba(255, 215, 0, 0.5);
            animation: mentionPulse 2s ease-in-out infinite;
        }

        @keyframes mentionPulse {
            0%, 100% { box-shadow: 0 0 0 0 rgba(255, 215, 0, 0.4); }
            50% { box-shadow: 0 0 10px 2px rgba(255, 215, 0, 0.2); }
        }

        .mention-notification {
            position: fixed;
            bottom: 20px;
            right: 20px;
            background: linear-gradient(135deg, rgba(255, 215, 0, 0.9), rgba(255, 165, 0, 0.9));
            color: #000;
            padding: 12px 20px;
            border-radius: 8px;
            font-weight: bold;
            z-index: 10001;
            animation: slideInRight 0.3s ease-out;
            cursor: pointer;
        }

        @keyframes slideInRight {
            from { transform: translateX(100%); opacity: 0; }
            to { transform: translateX(0); opacity: 1; }
        }

        /* Lazy loading placeholder */
        .lazy-image {
            background: var(--panel-bg);
            min-height: 100px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .lazy-image.loading::after {
            content: 'â—Œ';
            font-size: 24px;
            color: var(--text-dim);
            animation: lazyPulse 1s infinite;
        }

        @keyframes lazyPulse {
            0%, 100% { opacity: 0.3; }
            50% { opacity: 1; }
        }

        /* Hacker Markup Effects */
        .hacker-shake {
            display: inline-block;
            animation: hackerShake 0.1s infinite;
        }

        @keyframes hackerShake {
            0%, 100% { transform: translate(0, 0); }
            25% { transform: translate(-2px, 1px); }
            50% { transform: translate(2px, -1px); }
            75% { transform: translate(-1px, -2px); }
        }

        .hacker-rainbow {
            display: inline-block;
            background: linear-gradient(90deg, #ff0000, #ff7f00, #ffff00, #00ff00, #0000ff, #4b0082, #9400d3, #ff0000);
            background-size: 400% 100%;
            -webkit-background-clip: text;
            background-clip: text;
            -webkit-text-fill-color: transparent;
            animation: hackerRainbow 2s linear infinite;
        }

        @keyframes hackerRainbow {
            0% { background-position: 0% 50%; }
            100% { background-position: 400% 50%; }
        }

        .hacker-matrix {
            display: inline-block;
            color: #00ff00;
            text-shadow: 0 0 5px #00ff00, 0 0 10px #00ff00;
            animation: hackerMatrix 0.5s steps(3) infinite;
            font-family: 'Courier New', monospace;
        }

        @keyframes hackerMatrix {
            0%, 100% { opacity: 1; filter: brightness(1); }
            33% { opacity: 0.8; filter: brightness(1.2); }
            66% { opacity: 0.9; filter: brightness(0.9); }
        }

        .hacker-matrix::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(transparent 50%, rgba(0, 255, 0, 0.03) 50%);
            background-size: 100% 4px;
            pointer-events: none;
        }

        .hacker-glitch {
            display: inline-block;
            position: relative;
            animation: hackerGlitch 0.3s infinite;
        }

        @keyframes hackerGlitch {
            0%, 100% { transform: translate(0); filter: hue-rotate(0deg); }
            20% { transform: translate(-2px, 2px); filter: hue-rotate(90deg); }
            40% { transform: translate(2px, -2px); filter: hue-rotate(180deg); }
            60% { transform: translate(-1px, -1px); filter: hue-rotate(270deg); }
            80% { transform: translate(1px, 1px); filter: hue-rotate(360deg); }
        }

        .hacker-pulse {
            display: inline-block;
            animation: hackerPulse 1s ease-in-out infinite;
        }

        @keyframes hackerPulse {
            0%, 100% { transform: scale(1); opacity: 1; }
            50% { transform: scale(1.1); opacity: 0.8; }
        }

        .hacker-wave {
            display: inline-block;
        }

        .hacker-wave span {
            display: inline-block;
            animation: hackerWave 1s ease-in-out infinite;
        }

        @keyframes hackerWave {
            0%, 100% { transform: translateY(0); }
            50% { transform: translateY(-5px); }
        }

        .hacker-spoiler {
            display: inline-block;
            background: var(--text-dim);
            color: transparent;
            border-radius: 3px;
            padding: 0 4px;
            cursor: pointer;
            transition: all 0.2s ease;
            user-select: none;
        }

        .hacker-spoiler:hover,
        .hacker-spoiler.revealed {
            background: transparent;
            color: var(--text-color);
        }

        .hacker-spoiler::before {
            content: '[spoiler]';
            color: var(--accent);
            font-size: 0.7em;
            opacity: 0.7;
        }

        .hacker-spoiler:hover::before,
        .hacker-spoiler.revealed::before {
            content: '';
        }

        /* Neon Effect */
        .hacker-neon {
            display: inline-block;
            color: #fff;
            text-shadow:
                0 0 5px #fff,
                0 0 10px #fff,
                0 0 20px #ff00ff,
                0 0 40px #ff00ff,
                0 0 80px #ff00ff;
            animation: hackerNeon 1.5s ease-in-out infinite alternate;
        }

        @keyframes hackerNeon {
            from {
                text-shadow:
                    0 0 5px #fff,
                    0 0 10px #fff,
                    0 0 20px #ff00ff,
                    0 0 40px #ff00ff;
            }
            to {
                text-shadow:
                    0 0 10px #fff,
                    0 0 20px #fff,
                    0 0 40px #ff00ff,
                    0 0 80px #ff00ff,
                    0 0 120px #ff00ff;
            }
        }

        /* Fire Effect */
        .hacker-fire {
            display: inline-block;
            background: linear-gradient(180deg, #ff0000 0%, #ff6600 30%, #ffcc00 60%, #ffff00 100%);
            -webkit-background-clip: text;
            background-clip: text;
            -webkit-text-fill-color: transparent;
            animation: hackerFire 0.2s infinite alternate;
            filter: drop-shadow(0 0 8px #ff6600);
        }

        @keyframes hackerFire {
            0% { filter: drop-shadow(0 0 8px #ff6600) brightness(1); }
            100% { filter: drop-shadow(0 0 12px #ff3300) brightness(1.1); }
        }

        /* Ice Effect */
        .hacker-ice {
            display: inline-block;
            color: #a8e6ff;
            text-shadow:
                0 0 5px #a8e6ff,
                0 0 10px #00bfff,
                0 0 20px #00bfff;
            animation: hackerIce 2s ease-in-out infinite;
        }

        @keyframes hackerIce {
            0%, 100% { filter: brightness(1); }
            50% { filter: brightness(1.3); }
        }

        /* Bounce Effect */
        .hacker-bounce {
            display: inline-block;
        }

        .hacker-bounce span {
            display: inline-block;
            animation: hackerBounce 0.5s ease infinite;
        }

        @keyframes hackerBounce {
            0%, 100% { transform: translateY(0); }
            50% { transform: translateY(-8px); }
        }

        /* Reboot System Overlay */
        .reboot-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: #000;
            z-index: 99999;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            font-family: 'Courier New', monospace;
            color: #00ff00;
            animation: rebootFlicker 0.1s infinite;
        }

        .reboot-overlay .reboot-text {
            font-size: 2rem;
            text-shadow: 0 0 10px #00ff00, 0 0 20px #00ff00;
            animation: rebootGlitch 0.3s infinite;
        }

        .reboot-overlay .reboot-progress {
            margin-top: 20px;
            font-size: 1rem;
            opacity: 0.8;
        }

        .reboot-overlay .reboot-bar {
            width: 300px;
            height: 4px;
            background: #003300;
            margin-top: 15px;
            border: 1px solid #00ff00;
        }

        .reboot-overlay .reboot-bar-fill {
            height: 100%;
            background: #00ff00;
            box-shadow: 0 0 10px #00ff00;
            transition: width 0.1s linear;
        }

        @keyframes rebootFlicker {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.95; }
        }

        @keyframes rebootGlitch {
            0%, 100% { transform: translate(0); text-shadow: 0 0 10px #00ff00; }
            25% { transform: translate(-2px, 1px); text-shadow: 2px 0 #ff0000, -2px 0 #0000ff; }
            50% { transform: translate(2px, -1px); text-shadow: -2px 0 #ff0000, 2px 0 #0000ff; }
            75% { transform: translate(-1px, -1px); text-shadow: 1px 0 #ff0000, -1px 0 #0000ff; }
        }

        /* === SLOPPYFM WINAMP WIDGET === */
        .sloppyfm-widget {
            position: fixed;
            bottom: 20px;
            right: 20px;
            width: 275px;
            background: linear-gradient(180deg, #3a3a4a 0%, #232328 50%, #1a1a1f 100%);
            border: 2px solid #555;
            border-radius: 4px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.5), inset 0 1px 0 rgba(255,255,255,0.1);
            z-index: 9999;
            font-family: 'Arial', sans-serif;
            user-select: none;
            display: none;
        }
        .sloppyfm-widget.visible { display: block; }
        .sloppyfm-titlebar {
            background: linear-gradient(90deg, #1a3a6e 0%, #0a1a3e 50%, #1a3a6e 100%);
            padding: 3px 6px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            cursor: move;
            border-bottom: 1px solid #000;
        }
        .sloppyfm-title {
            color: #fff;
            font-size: 11px;
            font-weight: bold;
            text-shadow: 1px 1px 0 #000;
            letter-spacing: 1px;
        }
        .sloppyfm-close {
            background: linear-gradient(180deg, #6a6a7a, #3a3a4a);
            border: 1px solid #222;
            color: #fff;
            width: 14px;
            height: 14px;
            font-size: 10px;
            line-height: 12px;
            text-align: center;
            cursor: pointer;
            border-radius: 2px;
        }
        .sloppyfm-close:hover { background: #ff6b6b; }
        .sloppyfm-display {
            background: #000;
            margin: 4px;
            padding: 6px 8px;
            border: 1px inset #333;
            border-radius: 2px;
        }
        .sloppyfm-visualizer {
            height: 40px;
            margin-bottom: 4px;
            background: #111;
            border-radius: 2px;
            overflow: hidden;
        }
        #sloppyfmCanvas {
            width: 100%;
            height: 100%;
            display: block;
        }
        .sloppyfm-trackinfo {
            color: #0f0;
            font-size: 10px;
            font-family: 'Courier New', monospace;
            white-space: nowrap;
            overflow: hidden;
        }
        .sloppyfm-trackname {
            animation: sloppyfm-scroll 10s linear infinite;
            display: inline-block;
            padding-left: 100%;
        }
        @keyframes sloppyfm-scroll {
            0% { transform: translateX(0); }
            100% { transform: translateX(-100%); }
        }
        .sloppyfm-time {
            color: #0f0;
            font-size: 16px;
            font-family: 'Courier New', monospace;
            text-align: right;
            margin-top: 2px;
        }
        .sloppyfm-controls {
            display: flex;
            justify-content: center;
            gap: 4px;
            padding: 6px;
            background: linear-gradient(180deg, #2a2a2f, #1a1a1f);
        }
        .sloppyfm-btn {
            background: linear-gradient(180deg, #4a4a5a 0%, #2a2a3a 50%, #1a1a2a 100%);
            border: 1px solid #555;
            border-radius: 2px;
            color: #ccc;
            width: 28px;
            height: 20px;
            font-size: 10px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .sloppyfm-btn:hover { background: linear-gradient(180deg, #5a5a6a 0%, #3a3a4a 50%, #2a2a3a 100%); color: #fff; }
        .sloppyfm-btn:active { transform: scale(0.95); }
        .sloppyfm-btn.playing { color: #0f0; }
        .sloppyfm-volume {
            display: flex;
            align-items: center;
            padding: 0 8px 6px;
            gap: 6px;
        }
        .sloppyfm-volume-label {
            color: #888;
            font-size: 9px;
        }
        .sloppyfm-volume-slider {
            flex: 1;
            height: 6px;
            -webkit-appearance: none;
            background: linear-gradient(180deg, #222, #111);
            border: 1px inset #333;
            border-radius: 2px;
        }
        .sloppyfm-volume-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 10px;
            height: 14px;
            background: linear-gradient(180deg, #6a6a7a, #3a3a4a);
            border: 1px solid #222;
            border-radius: 2px;
            cursor: pointer;
        }
        .sloppyfm-add-track {
            display: flex;
            gap: 4px;
            margin: 4px;
        }
        .sloppyfm-url-input {
            flex: 1;
            background: #0a0a0f;
            border: 1px inset #333;
            color: #0f0;
            padding: 4px 6px;
            font-size: 10px;
            font-family: 'Courier New', monospace;
        }
        .sloppyfm-url-input::placeholder {
            color: #444;
        }
        .sloppyfm-add-btn {
            background: linear-gradient(180deg, #2a4a2a 0%, #1a2a1a 50%, #0a1a0a 100%);
            border: 1px solid #0f0;
            color: #0f0;
            padding: 4px 10px;
            cursor: pointer;
            font-weight: bold;
            font-size: 12px;
        }
        .sloppyfm-add-btn:hover {
            background: linear-gradient(180deg, #3a5a3a 0%, #2a3a2a 50%, #1a2a1a 100%);
        }
        .sloppyfm-playlist {
            max-height: 100px;
            overflow-y: auto;
            background: #0a0a0f;
            margin: 0 4px 4px;
            border: 1px inset #333;
            font-size: 10px;
        }
        .sloppyfm-track {
            padding: 3px 6px;
            color: #0f0;
            cursor: pointer;
            border-bottom: 1px solid #1a1a1f;
            font-family: 'Courier New', monospace;
        }
        .sloppyfm-track:hover { background: #1a2a1a; }
        .sloppyfm-track.active { background: #0a3a0a; color: #0f0; }
        .sloppyfm-genre {
            color: #888;
            font-size: 8px;
            margin-left: 4px;
        }
        .sloppyfm-toggle {
            position: fixed;
            bottom: 20px;
            right: 20px;
            width: 50px;
            height: 50px;
            background: linear-gradient(180deg, #3a3a6a 0%, #1a1a3a 100%);
            border: 2px solid #555;
            border-radius: 50%;
            color: #0f0;
            font-size: 20px;
            cursor: pointer;
            z-index: 9998;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 2px 10px rgba(0,0,0,0.5);
        }
        .sloppyfm-toggle:hover { background: linear-gradient(180deg, #4a4a7a 0%, #2a2a4a 100%); }
        .sloppyfm-toggle.hidden { display: none; }
        @media (max-width: 768px) {
            .sloppyfm-widget { width: 260px; bottom: 70px; right: 10px; }
            .sloppyfm-toggle { bottom: 70px; }
        }

        /* === TWITCH EMBED WIDGET === */
        .twitch-widget {
            position: fixed;
            bottom: 80px;
            left: 20px;
            width: 340px;
            background: linear-gradient(135deg, #1a1a2e 0%, #0d0d1a 100%);
            border: 2px solid var(--accent);
            box-shadow: 0 0 20px rgba(138, 43, 226, 0.3), inset 0 0 30px rgba(138, 43, 226, 0.1);
            z-index: 9999;
            display: none;
            overflow: hidden;
        }
        .twitch-widget.visible { display: block; }
        .twitch-widget::before, .twitch-widget::after {
            content: 'â—†';
            position: absolute;
            color: var(--accent);
            font-size: 12px;
            opacity: 0.6;
            animation: diamondGlow 2s ease-in-out infinite;
        }
        .twitch-widget::before { top: -8px; left: 50%; transform: translateX(-50%); }
        .twitch-widget::after { bottom: -8px; left: 50%; transform: translateX(-50%); }
        @keyframes diamondGlow {
            0%, 100% { opacity: 0.4; text-shadow: 0 0 5px var(--accent); }
            50% { opacity: 1; text-shadow: 0 0 15px var(--accent), 0 0 25px var(--accent); }
        }
        .twitch-titlebar {
            background: linear-gradient(90deg, #2a1a4a 0%, #1a0a3a 50%, #2a1a4a 100%);
            padding: 6px 10px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            cursor: move;
            border-bottom: 1px solid var(--accent);
        }
        .twitch-title {
            color: #fff;
            font-size: 11px;
            font-weight: bold;
            letter-spacing: 2px;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        .twitch-title .diamond { color: var(--accent); animation: diamondGlow 2s ease-in-out infinite; }
        .twitch-title .diamond:nth-child(2) { animation-delay: 0.3s; }
        .twitch-close {
            background: linear-gradient(180deg, #6a3a8a, #3a1a5a);
            border: 1px solid #8a2be2;
            color: #fff;
            width: 18px;
            height: 18px;
            font-size: 12px;
            line-height: 16px;
            text-align: center;
            cursor: pointer;
            border-radius: 2px;
        }
        .twitch-close:hover { background: #9146ff; }
        .twitch-content {
            position: relative;
            width: 100%;
            padding-top: 56.25%; /* 16:9 aspect ratio */
            background: #000;
        }
        .twitch-content iframe {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            border: none;
        }
        .twitch-footer {
            background: linear-gradient(90deg, #1a0a2a 0%, #2a1a4a 50%, #1a0a2a 100%);
            padding: 4px 10px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 10px;
            color: var(--text-dim);
            border-top: 1px solid rgba(138, 43, 226, 0.3);
        }
        .twitch-footer .live-indicator {
            display: flex;
            align-items: center;
            gap: 5px;
            color: #ff4444;
        }
        .twitch-footer .live-dot {
            width: 6px;
            height: 6px;
            background: #ff4444;
            border-radius: 50%;
            animation: blink 1s infinite;
        }
        @keyframes blink {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.3; }
        }
        .twitch-toggle {
            position: fixed;
            bottom: 20px;
            left: 110px;
            width: 50px;
            height: 50px;
            background: linear-gradient(135deg, #9146ff 0%, #6441a5 100%);
            border: 2px solid #9146ff;
            border-radius: 8px;
            color: #fff;
            font-size: 20px;
            cursor: pointer;
            z-index: 9998;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 0 15px rgba(145, 70, 255, 0.4);
            transition: all 0.2s;
        }
        .twitch-toggle:hover {
            transform: scale(1.1);
            box-shadow: 0 0 25px rgba(145, 70, 255, 0.6);
        }
        .twitch-toggle.hidden { display: none; }
        .twitch-toggle .diamond {
            position: absolute;
            font-size: 8px;
            color: #fff;
            opacity: 0.7;
        }
        .twitch-toggle .diamond:nth-child(1) { top: 2px; left: 50%; transform: translateX(-50%); }
        .twitch-toggle .diamond:nth-child(2) { bottom: 2px; left: 50%; transform: translateX(-50%); }
        @media (max-width: 768px) {
            .twitch-widget { width: 280px; left: 10px; bottom: 70px; }
            .twitch-toggle { bottom: 70px; left: 100px; width: 40px; height: 40px; font-size: 16px; }
        }

        /* === TWITCH CHAT WIDGET === */
        .twitch-chat-widget {
            position: fixed;
            bottom: 80px;
            right: 20px;
            width: 320px;
            height: 400px;
            background: linear-gradient(135deg, #1a1a2e 0%, #0d0d1a 100%);
            border: 2px solid var(--accent);
            box-shadow: 0 0 20px rgba(138, 43, 226, 0.3), inset 0 0 30px rgba(138, 43, 226, 0.1);
            z-index: 9999;
            display: none;
            overflow: hidden;
            flex-direction: column;
        }
        .twitch-chat-widget.visible { display: flex; }
        .twitch-chat-widget::before, .twitch-chat-widget::after {
            content: 'â—‡';
            position: absolute;
            color: var(--accent);
            font-size: 10px;
            opacity: 0.6;
            animation: diamondGlow 2s ease-in-out infinite;
        }
        .twitch-chat-widget::before { top: -6px; left: 30%; }
        .twitch-chat-widget::after { top: -6px; right: 30%; animation-delay: 0.5s; }
        .twitch-chat-titlebar {
            background: linear-gradient(90deg, #2a1a4a 0%, #1a0a3a 50%, #2a1a4a 100%);
            padding: 6px 10px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            cursor: move;
            border-bottom: 1px solid var(--accent);
            flex-shrink: 0;
        }
        .twitch-chat-title {
            color: #fff;
            font-size: 11px;
            font-weight: bold;
            letter-spacing: 2px;
            display: flex;
            align-items: center;
            gap: 6px;
        }
        .twitch-chat-title .diamond { color: var(--accent); animation: diamondGlow 2s ease-in-out infinite; }
        .twitch-chat-close {
            background: linear-gradient(180deg, #6a3a8a, #3a1a5a);
            border: 1px solid #8a2be2;
            color: #fff;
            width: 18px;
            height: 18px;
            font-size: 12px;
            line-height: 16px;
            text-align: center;
            cursor: pointer;
            border-radius: 2px;
        }
        .twitch-chat-close:hover { background: #9146ff; }
        .twitch-chat-content {
            flex: 1;
            background: #0e0e10;
            overflow: hidden;
        }
        .twitch-chat-content iframe {
            width: 100%;
            height: 100%;
            border: none;
        }
        .twitch-chat-toggle {
            position: fixed;
            bottom: 20px;
            left: 170px;
            width: 50px;
            height: 50px;
            background: linear-gradient(135deg, #772ce8 0%, #5c16c5 100%);
            border: 2px solid #772ce8;
            border-radius: 8px;
            color: #fff;
            font-size: 18px;
            cursor: pointer;
            z-index: 9998;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 0 15px rgba(119, 44, 232, 0.4);
            transition: all 0.2s;
        }
        .twitch-chat-toggle:hover {
            transform: scale(1.1);
            box-shadow: 0 0 25px rgba(119, 44, 232, 0.6);
        }
        .twitch-chat-toggle.hidden { display: none; }
        .twitch-chat-toggle .diamond {
            position: absolute;
            font-size: 8px;
            color: #fff;
            opacity: 0.7;
        }
        .twitch-chat-toggle .diamond:nth-child(1) { top: 2px; left: 50%; transform: translateX(-50%); }
        .twitch-chat-toggle .diamond:nth-child(2) { bottom: 2px; left: 50%; transform: translateX(-50%); }
        @media (max-width: 768px) {
            .twitch-chat-widget { width: 260px; height: 350px; right: 10px; bottom: 70px; }
            .twitch-chat-toggle { bottom: 70px; left: 150px; width: 40px; height: 40px; font-size: 14px; }
        }

        /* === APP LAUNCHER === */
        .app-launcher-toggle {
            position: fixed;
            bottom: 20px;
            left: 230px;
            width: 50px;
            height: 50px;
            background: linear-gradient(135deg, #2a1a4a 0%, #1a0a3a 100%);
            border: 2px solid var(--accent);
            border-radius: 8px;
            color: #fff;
            font-size: 20px;
            cursor: pointer;
            z-index: 9998;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 0 15px rgba(138, 43, 226, 0.4);
            transition: all 0.2s;
        }
        .app-launcher-toggle:hover {
            transform: scale(1.1);
            box-shadow: 0 0 25px rgba(138, 43, 226, 0.6);
        }
        .app-launcher-toggle .diamond {
            position: absolute;
            font-size: 8px;
            color: var(--accent);
            opacity: 0.8;
        }
        .app-launcher-toggle .diamond:nth-child(1) { top: 2px; left: 50%; transform: translateX(-50%); }
        .app-launcher-toggle .diamond:nth-child(2) { bottom: 2px; left: 50%; transform: translateX(-50%); }

        .app-launcher-menu {
            position: fixed;
            bottom: 80px;
            left: 230px;
            background: linear-gradient(135deg, #1a1a2e 0%, #0d0d1a 100%);
            border: 2px solid var(--accent);
            box-shadow: 0 0 25px rgba(138, 43, 226, 0.4);
            z-index: 10000;
            display: none;
            flex-direction: column;
            min-width: 180px;
            max-height: calc(100vh - 150px);
            overflow-y: auto;
            overflow-x: hidden;
        }
        .app-launcher-menu::-webkit-scrollbar {
            width: 6px;
        }
        .app-launcher-menu::-webkit-scrollbar-track {
            background: rgba(0, 0, 0, 0.3);
        }
        .app-launcher-menu::-webkit-scrollbar-thumb {
            background: var(--accent);
            border-radius: 3px;
        }
        .app-launcher-menu::-webkit-scrollbar-thumb:hover {
            background: #a855f7;
        }
        .app-launcher-menu.visible { display: flex; }
        .app-launcher-menu::before {
            content: 'â—† APPS â—†';
            display: block;
            padding: 8px 15px;
            background: linear-gradient(90deg, #2a1a4a 0%, #1a0a3a 50%, #2a1a4a 100%);
            color: var(--accent);
            font-size: 11px;
            font-weight: bold;
            letter-spacing: 2px;
            text-align: center;
            border-bottom: 1px solid var(--accent);
        }
        .app-launcher-item {
            padding: 12px 15px;
            color: #fff;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 10px;
            font-size: 12px;
            letter-spacing: 1px;
            border-bottom: 1px solid rgba(138, 43, 226, 0.2);
            transition: background 0.2s;
        }
        .app-launcher-item:hover {
            background: rgba(138, 43, 226, 0.2);
        }
        .app-launcher-item:last-child { border-bottom: none; }
        .app-launcher-item .icon { font-size: 16px; }
        .app-launcher-item .diamond {
            color: var(--accent);
            font-size: 8px;
            margin-left: auto;
        }

        /* Embedded App Windows */
        .embedded-app-window {
            position: fixed;
            background: linear-gradient(135deg, #1a1a2e 0%, #0d0d1a 100%);
            border: 2px solid var(--accent);
            box-shadow: 0 0 30px rgba(138, 43, 226, 0.4), inset 0 0 40px rgba(138, 43, 226, 0.1);
            z-index: 9999;
            display: none;
            flex-direction: column;
            overflow: hidden;
            opacity: var(--widget-opacity);
            resize: both;
            min-width: 300px;
            min-height: 200px;
        }
        .embedded-app-window.visible { display: flex; }
        .embedded-app-window::before, .embedded-app-window::after {
            content: 'â—†';
            position: absolute;
            color: var(--accent);
            font-size: 14px;
            opacity: 0.6;
            animation: diamondGlow 2s ease-in-out infinite;
            z-index: 1;
        }
        .embedded-app-window::before { top: -10px; left: 50%; transform: translateX(-50%); }
        .embedded-app-window::after { bottom: -10px; left: 50%; transform: translateX(-50%); }

        .embedded-app-titlebar {
            background: linear-gradient(90deg, #2a1a4a 0%, #1a0a3a 50%, #2a1a4a 100%);
            padding: 8px 12px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            cursor: move;
            border-bottom: 1px solid var(--accent);
            flex-shrink: 0;
        }
        .embedded-app-title {
            color: #fff;
            font-size: 12px;
            font-weight: bold;
            letter-spacing: 2px;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        .embedded-app-title .diamond {
            color: var(--accent);
            animation: diamondGlow 2s ease-in-out infinite;
        }
        .embedded-app-controls {
            display: flex;
            gap: 6px;
        }
        .embedded-app-btn {
            background: linear-gradient(180deg, #6a3a8a, #3a1a5a);
            border: 1px solid #8a2be2;
            color: #fff;
            width: 20px;
            height: 20px;
            font-size: 12px;
            line-height: 18px;
            text-align: center;
            cursor: pointer;
            border-radius: 3px;
        }
        .embedded-app-btn:hover { background: #9146ff; }
        .embedded-app-content {
            flex: 1;
            background: #000;
            overflow: hidden;
        }
        .embedded-app-content iframe {
            width: 100%;
            height: 100%;
            border: none;
        }
        .embedded-app-footer {
            background: linear-gradient(90deg, #1a0a2a 0%, #2a1a4a 50%, #1a0a2a 100%);
            padding: 4px 12px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 9px;
            color: var(--text-dim);
            border-top: 1px solid rgba(138, 43, 226, 0.3);
            flex-shrink: 0;
        }
        .embedded-app-footer .diamond { color: var(--accent); margin: 0 5px; }

        /* Graffiti Wall Window */
        #graffitiWindow {
            width: 500px;
            height: 400px;
            top: 100px;
            left: 100px;
        }

        /* Manifesto Generator Window */
        #manifestoWindow {
            width: 550px;
            height: 500px;
            top: 120px;
            right: 100px;
            left: auto;
        }

        /* Origins Window */
        #originsWindow {
            width: 700px;
            height: 500px;
            top: 80px;
            left: 150px;
        }

        /* Sloppygram API Window */
        #sloppyapiWindow {
            width: 600px;
            height: 500px;
            top: 100px;
            right: 150px;
            left: auto;
        }

        /* Claude's Diary Window */
        #diaryWindow {
            width: 650px;
            height: 550px;
            top: 90px;
            left: 200px;
        }

        /* Federated Truth Window */
        #truthWindow {
            width: 700px;
            height: 520px;
            top: 70px;
            left: 180px;
        }

        /* Blueprint Portal Window */
        #blueprintWindow {
            width: 600px;
            height: 500px;
            top: 110px;
            right: 120px;
            left: auto;
        }

        /* Sloppy Says Window */
        #sloppysaysWindow {
            width: 550px;
            height: 480px;
            top: 100px;
            left: 250px;
        }

        /* Neon Tetris Window */
        #tetrisWindow {
            width: 400px;
            height: 550px;
            top: 90px;
            left: 200px;
        }

        /* Neon Synth Window */
        #synthWindow {
            width: 600px;
            height: 450px;
            top: 140px;
            right: 120px;
            left: auto;
        }

        /* Pixel Editor Window */
        #pixelWindow {
            width: 550px;
            height: 500px;
            top: 110px;
            left: 180px;
        }

        /* BTC Tracker Window */
        #btcWindow {
            width: 500px;
            height: 450px;
            top: 100px;
            left: 120px;
        }

        /* Solana Tracker Window */
        #solanaWindow {
            width: 500px;
            height: 450px;
            top: 130px;
            right: 130px;
            left: auto;
        }

        /* Sloppy Coin Window */
        #sloppycoinWindow {
            width: 480px;
            height: 500px;
            top: 90px;
            left: 160px;
        }

        /* Crypto Tools Window */
        #cryptoWindow {
            width: 600px;
            height: 500px;
            top: 100px;
            right: 100px;
            left: auto;
        }

        /* Sloppy Dashboard Window */
        #sloppydashWindow {
            width: 650px;
            height: 520px;
            top: 80px;
            left: 140px;
        }

        /* Wiki Scout Window */
        #wikiscoutWindow {
            width: 700px;
            height: 550px;
            top: 60px;
            left: 180px;
        }

        @media (max-width: 768px) {
            .app-launcher-toggle { bottom: 70px; left: 200px; width: 40px; height: 40px; font-size: 16px; }
            .app-launcher-menu { left: 10px; bottom: 120px; max-height: calc(100vh - 180px); }
            .embedded-app-window { width: 90vw !important; height: 70vh !important; top: 10vh !important; left: 5vw !important; right: auto !important; }
        }

        /* === CONFIDENCE MONITOR WIDGET === */
        .confidence-monitor {
            position: fixed;
            bottom: 20px;
            right: 20px;
            width: 100px;
            height: 100px;
            background: linear-gradient(135deg, #1a1a2e 0%, #0d0d1a 100%);
            border: 2px solid var(--accent);
            border-radius: 50%;
            box-shadow: 0 0 20px rgba(138, 43, 226, 0.4), inset 0 0 30px rgba(138, 43, 226, 0.1);
            z-index: 9997;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.3s ease;
            opacity: var(--widget-opacity);
        }
        .confidence-monitor:hover {
            transform: scale(1.05);
            box-shadow: 0 0 30px rgba(138, 43, 226, 0.6), inset 0 0 40px rgba(138, 43, 226, 0.2);
        }
        .confidence-monitor::before, .confidence-monitor::after {
            content: 'â—†';
            position: absolute;
            color: var(--accent);
            font-size: 10px;
            opacity: 0.7;
            animation: diamondGlow 2s ease-in-out infinite;
        }
        .confidence-monitor::before { top: 5px; }
        .confidence-monitor::after { bottom: 5px; }
        .confidence-ring {
            position: absolute;
            width: 90px;
            height: 90px;
            border-radius: 50%;
            border: 2px solid var(--accent);
            opacity: 0.3;
            animation: confidencePulse 3s ease-in-out infinite;
        }
        .confidence-ring-inner {
            position: absolute;
            width: 78px;
            height: 78px;
            border-radius: 50%;
            border: 1px solid rgba(138, 43, 226, 0.4);
            animation: confidencePulse 3s ease-in-out infinite 1.5s;
        }
        @keyframes confidencePulse {
            0%, 100% { opacity: 0.2; transform: scale(1); }
            50% { opacity: 0.5; transform: scale(1.02); }
        }
        .confidence-value {
            font-size: 24px;
            font-weight: bold;
            color: #fff;
            text-shadow: 0 0 10px var(--accent);
            z-index: 1;
        }
        .confidence-value.high { color: #0f0; text-shadow: 0 0 10px #0f0; }
        .confidence-value.medium { color: #ff0; text-shadow: 0 0 10px #ff0; }
        .confidence-value.low { color: #f00; text-shadow: 0 0 10px #f00; }
        .confidence-label {
            font-size: 8px;
            color: var(--accent);
            letter-spacing: 1px;
            text-transform: uppercase;
            margin-top: 2px;
            z-index: 1;
        }
        .confidence-status {
            font-size: 7px;
            color: var(--text-dim);
            margin-top: 1px;
            z-index: 1;
        }
        .confidence-pulse {
            position: absolute;
            width: 100%;
            height: 100%;
            border-radius: 50%;
            border: 1px solid var(--accent);
            animation: confidencePulse 2s ease-out infinite;
            opacity: 0;
        }
        @keyframes confidencePulse {
            0% { transform: scale(1); opacity: 0.5; }
            100% { transform: scale(1.3); opacity: 0; }
        }
        @media (max-width: 768px) {
            .confidence-monitor { width: 70px; height: 70px; bottom: 80px; right: 10px; }
            .confidence-ring { width: 62px; height: 62px; }
            .confidence-ring-inner { width: 52px; height: 52px; }
            .confidence-value { font-size: 18px; }
            .confidence-label { font-size: 6px; }
            .confidence-status { display: none; }
        }

        /* === PRESENCE PULSE WIDGET === */
        .ghost-radar {
            position: fixed;
            bottom: 20px;
            left: 20px;
            width: 80px;
            height: 80px;
            background: radial-gradient(circle, #0a1a0a 0%, #001100 70%, #000800 100%);
            border: 2px solid #0f0;
            border-radius: 50%;
            box-shadow: 0 0 15px rgba(0,255,0,0.3), inset 0 0 20px rgba(0,255,0,0.1);
            z-index: 9997;
            overflow: hidden;
            cursor: pointer;
            opacity: var(--widget-opacity);
        }
        /* Wave pulse rings expanding from center */
        .ghost-radar::before {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 10px;
            height: 10px;
            border: 2px solid rgba(0,255,0,0.6);
            border-radius: 50%;
            transform: translate(-50%, -50%);
            animation: wavePulse 3s ease-out infinite;
        }
        .ghost-radar::after {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 10px;
            height: 10px;
            border: 2px solid rgba(0,255,0,0.6);
            border-radius: 50%;
            transform: translate(-50%, -50%);
            animation: wavePulse 3s ease-out infinite 1s;
        }
        @keyframes wavePulse {
            0% {
                width: 10px;
                height: 10px;
                opacity: 0.8;
                border-width: 2px;
            }
            100% {
                width: 90%;
                height: 90%;
                opacity: 0;
                border-width: 1px;
            }
        }
        /* Center dot */
        .ghost-radar-rings {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 8px;
            height: 8px;
            background: #0f0;
            border-radius: 50%;
            box-shadow: 0 0 10px #0f0, 0 0 20px rgba(0,255,0,0.5);
            animation: centerGlow 2s ease-in-out infinite;
        }
        @keyframes centerGlow {
            0%, 100% { box-shadow: 0 0 10px #0f0, 0 0 20px rgba(0,255,0,0.5); }
            50% { box-shadow: 0 0 15px #0f0, 0 0 30px rgba(0,255,0,0.7); }
        }
        /* Third wave for more depth */
        .ghost-radar-rings::before {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 10px;
            height: 10px;
            border: 2px solid rgba(0,255,0,0.6);
            border-radius: 50%;
            transform: translate(-50%, -50%);
            animation: wavePulse 3s ease-out infinite 2s;
        }
        .ghost-radar-rings::after {
            display: none;
        }
        .ghost-radar-count {
            position: absolute;
            bottom: -22px;
            left: 50%;
            transform: translateX(-50%);
            background: #001a00;
            border: 1px solid #0f0;
            padding: 2px 8px;
            font-size: 10px;
            color: #0f0;
            font-family: 'Courier New', monospace;
            white-space: nowrap;
            border-radius: 3px;
            text-shadow: 0 0 5px #0f0;
        }
        .ghost-radar-blip {
            position: absolute;
            width: 6px;
            height: 6px;
            background: #0f0;
            border-radius: 50%;
            opacity: 0;
            animation: blipFade 3s ease-out infinite;
            box-shadow: 0 0 8px #0f0;
        }
        @keyframes blipFade {
            0% { opacity: 0.8; transform: scale(1); }
            100% { opacity: 0; transform: scale(0.5); }
        }
        .ghost-radar-label {
            position: absolute;
            top: -18px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 8px;
            color: #0f0;
            font-family: 'Courier New', monospace;
            text-transform: uppercase;
            letter-spacing: 1px;
            text-shadow: 0 0 5px #0f0;
        }
        @media (max-width: 768px) {
            .ghost-radar { bottom: 80px; left: 10px; width: 60px; height: 60px; }
            .ghost-radar-count { font-size: 8px; bottom: -18px; }
            .ghost-radar-label { font-size: 6px; top: -14px; }
        }

        /* === ORACLE LOG WIDGET === */
        .oracle-log {
            position: fixed;
            top: 80px;
            right: 20px;
            width: 280px;
            max-height: 60px;
            background: linear-gradient(135deg, #1a1520 0%, #0d0a12 100%);
            border: 2px solid #9b59b6;
            border-radius: 12px;
            box-shadow: 0 0 20px rgba(155, 89, 182, 0.3), inset 0 0 30px rgba(155, 89, 182, 0.05);
            z-index: 9996;
            overflow: hidden;
            transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
            font-family: 'Crimson Pro', Georgia, serif;
            opacity: var(--widget-opacity);
        }
        .oracle-log.expanded {
            max-height: 400px;
        }
        .oracle-log.minimized {
            width: 60px;
        }
        .oracle-log.minimized .oracle-title-text {
            display: none;
        }
        .oracle-log.minimized .oracle-log-count {
            position: absolute;
            right: 8px;
            top: 50%;
            transform: translateY(-50%);
        }
        .oracle-log.minimized .oracle-log-body,
        .oracle-log.minimized .oracle-log-input {
            display: none;
        }
        .oracle-log-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 12px 15px;
            cursor: pointer;
            background: linear-gradient(90deg, rgba(155,89,182,0.15) 0%, transparent 100%);
            border-bottom: 1px solid rgba(155,89,182,0.3);
        }
        .oracle-log-title {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 13px;
            font-weight: 600;
            color: #d4a5e8;
            letter-spacing: 0.05em;
        }
        .oracle-log-title .icon {
            font-size: 16px;
        }
        .oracle-log-count {
            background: rgba(155,89,182,0.3);
            padding: 2px 8px;
            border-radius: 10px;
            font-size: 11px;
            color: #b8a0c8;
            font-family: 'JetBrains Mono', monospace;
        }
        .oracle-log-body {
            padding: 10px;
            max-height: 280px;
            overflow-y: auto;
        }
        .oracle-log-body::-webkit-scrollbar { width: 4px; }
        .oracle-log-body::-webkit-scrollbar-thumb { background: #9b59b6; border-radius: 2px; }
        .oracle-log-empty {
            text-align: center;
            padding: 20px;
            color: #6a5a7a;
            font-style: italic;
            font-size: 12px;
        }
        .oracle-question {
            padding: 10px 12px;
            margin-bottom: 8px;
            background: rgba(155,89,182,0.08);
            border-left: 3px solid #9b59b6;
            border-radius: 0 8px 8px 0;
            transition: all 0.2s;
        }
        .oracle-question:hover {
            background: rgba(155,89,182,0.15);
        }
        .oracle-question-text {
            font-size: 13px;
            color: #e8d8f0;
            line-height: 1.5;
            margin-bottom: 6px;
        }
        .oracle-question-meta {
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 10px;
            color: #7a6a8a;
            font-family: 'JetBrains Mono', monospace;
        }
        .oracle-question-importance {
            display: flex;
            gap: 2px;
        }
        .oracle-question-importance .star {
            color: #9b59b6;
            opacity: 0.3;
        }
        .oracle-question-importance .star.filled {
            opacity: 1;
        }
        .oracle-question.answered {
            border-left-color: #27ae60;
        }
        .oracle-question.answered .oracle-question-text {
            color: #a8c8b0;
        }
        .oracle-log-input {
            display: flex;
            gap: 8px;
            padding: 10px;
            border-top: 1px solid rgba(155,89,182,0.2);
            background: rgba(0,0,0,0.2);
        }
        .oracle-log-input input {
            flex: 1;
            background: rgba(155,89,182,0.1);
            border: 1px solid rgba(155,89,182,0.3);
            border-radius: 6px;
            padding: 8px 12px;
            font-size: 12px;
            color: #e8d8f0;
            font-family: inherit;
            outline: none;
        }
        .oracle-log-input input::placeholder {
            color: #6a5a7a;
            font-style: italic;
        }
        .oracle-log-input input:focus {
            border-color: #9b59b6;
        }
        .oracle-log-input button {
            background: linear-gradient(135deg, #9b59b6 0%, #7b3a96 100%);
            border: none;
            border-radius: 6px;
            padding: 8px 14px;
            font-size: 11px;
            font-weight: 600;
            color: #fff;
            cursor: pointer;
            transition: all 0.2s;
        }
        .oracle-log-input button:hover {
            transform: scale(1.05);
        }
        @media (max-width: 768px) {
            .oracle-log { top: auto; bottom: 150px; right: 10px; width: 240px; }
            .oracle-log.expanded { max-height: 300px; }
        }

        /* === TOOLTIP SYSTEM FOR NEW USERS === */
        .tooltip-wrap {
            position: relative;
            display: inline-block;
        }
        .tooltip-wrap .tooltip-text {
            visibility: hidden;
            opacity: 0;
            position: absolute;
            bottom: calc(100% + 8px);
            left: 50%;
            transform: translateX(-50%) translateY(4px);
            background: rgba(10, 10, 15, 0.96);
            border: 1px solid var(--accent);
            border-radius: 6px;
            padding: 10px 14px;
            min-width: 180px;
            max-width: 260px;
            z-index: 9000;
            transition: opacity 0.2s, transform 0.2s, visibility 0.2s;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5), 0 0 15px rgba(124, 152, 133, 0.15);
            pointer-events: none;
        }
        .tooltip-wrap .tooltip-text::after {
            content: '';
            position: absolute;
            top: 100%;
            left: 50%;
            transform: translateX(-50%);
            border: 6px solid transparent;
            border-top-color: var(--accent);
        }
        .tooltip-wrap:hover .tooltip-text {
            visibility: visible;
            opacity: 1;
            transform: translateX(-50%) translateY(0);
        }
        .tooltip-text .tt-title {
            font-size: 0.95rem;
            color: var(--accent-light);
            font-weight: bold;
            letter-spacing: 0.05em;
            margin-bottom: 5px;
            display: block;
        }
        .tooltip-text .tt-desc {
            font-size: 0.8rem;
            color: rgba(255, 255, 255, 0.8);
            line-height: 1.4;
        }
        /* Tooltip positioned below for tabs */
        .tooltip-wrap.tt-below .tooltip-text {
            bottom: auto;
            top: calc(100% + 8px);
        }
        .tooltip-wrap.tt-below .tooltip-text::after {
            top: auto;
            bottom: 100%;
            border-top-color: transparent;
            border-bottom-color: var(--accent);
        }
        /* Tooltip positioned left for right-side elements */
        .tooltip-wrap.tt-left .tooltip-text {
            left: auto;
            right: 0;
            transform: translateX(0) translateY(4px);
        }
        .tooltip-wrap.tt-left:hover .tooltip-text {
            transform: translateX(0) translateY(0);
        }
        .tooltip-wrap.tt-left .tooltip-text::after {
            left: auto;
            right: 20px;
        }
        /* Hide tooltips on mobile by default */
        @media (max-width: 768px) {
            .tooltip-wrap .tooltip-text {
                display: none !important;
            }
            /* Show tooltips when help mode is active */
            body.help-mode-active .tooltip-wrap .tooltip-text {
                display: block !important;
            }
            body.help-mode-active .tooltip-wrap.tooltip-visible .tooltip-text {
                visibility: visible !important;
                opacity: 1 !important;
                transform: translateX(-50%) translateY(0) !important;
            }
            body.help-mode-active .tooltip-wrap.tt-left.tooltip-visible .tooltip-text {
                transform: translateX(0) translateY(0) !important;
            }
        }

        /* Mobile help toggle in menu */
        .mobile-help-toggle {
            display: flex;
            align-items: center;
            justify-content: space-between;
            width: 100%;
            padding: 12px 16px;
            background: transparent;
            border: none;
            border-top: 1px solid var(--border-color);
            color: var(--accent);
            font-family: inherit;
            font-size: 1rem;
            cursor: pointer;
            transition: background 0.2s;
        }
        .mobile-help-toggle:hover {
            background: rgba(124, 152, 133, 0.1);
        }
        .mobile-help-toggle .toggle-label {
            display: flex;
            align-items: center;
            gap: 8px;
        }
        .mobile-help-toggle .toggle-switch {
            width: 40px;
            height: 22px;
            background: var(--border-color);
            border-radius: 11px;
            position: relative;
            transition: background 0.2s;
        }
        .mobile-help-toggle .toggle-switch::after {
            content: '';
            position: absolute;
            top: 2px;
            left: 2px;
            width: 18px;
            height: 18px;
            background: var(--text-dim);
            border-radius: 50%;
            transition: transform 0.2s, background 0.2s;
        }
        .mobile-help-toggle.active .toggle-switch {
            background: var(--accent);
        }
        .mobile-help-toggle.active .toggle-switch::after {
            transform: translateX(18px);
            background: #fff;
        }

        /* Help mode indicator */
        .help-mode-banner {
            display: none;
            position: fixed;
            top: 60px;
            left: 0;
            right: 0;
            background: linear-gradient(90deg, var(--accent-dim) 0%, var(--accent) 50%, var(--accent-dim) 100%);
            color: #fff;
            text-align: center;
            padding: 8px;
            font-size: 0.85rem;
            z-index: 9999;
            animation: helpBannerPulse 2s ease-in-out infinite;
        }
        .help-mode-banner.visible {
            display: block;
        }
        @keyframes helpBannerPulse {
            0%, 100% { opacity: 0.9; }
            50% { opacity: 1; }
        }

        /* === SOCIAL GRAPH VISUALIZATION === */
        .graph-container {
            display: none;
            flex-direction: column;
            height: 100%;
            background: var(--panel-bg);
            position: relative;
        }
        .graph-container.active {
            display: flex;
        }
        .graph-controls {
            display: flex;
            gap: 8px;
            padding: 12px;
            background: rgba(0, 0, 0, 0.3);
            border-bottom: 1px solid var(--border-color);
            flex-wrap: wrap;
            align-items: center;
        }
        .graph-filter-group {
            display: flex;
            gap: 4px;
            margin-right: 16px;
        }
        .graph-filter-btn {
            padding: 6px 12px;
            background: var(--border-color);
            border: none;
            color: var(--text-dim);
            font-family: inherit;
            font-size: 0.85rem;
            cursor: pointer;
            border-radius: 4px;
            transition: all 0.2s;
        }
        .graph-filter-btn.active {
            background: var(--accent);
            color: #fff;
        }
        .graph-filter-btn:hover:not(.active) {
            background: var(--accent-dim);
            color: var(--accent-light);
        }
        .graph-zoom-controls {
            display: flex;
            gap: 4px;
            margin-left: auto;
        }
        .graph-zoom-btn {
            width: 32px;
            height: 32px;
            background: var(--border-color);
            border: none;
            color: var(--accent);
            font-size: 1.2rem;
            cursor: pointer;
            border-radius: 4px;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: background 0.2s;
        }
        .graph-zoom-btn:hover {
            background: var(--accent-dim);
        }
        .graph-canvas-wrap {
            flex: 1;
            position: relative;
            overflow: hidden;
        }
        .graph-canvas {
            width: 100%;
            height: 100%;
            cursor: grab;
        }
        .graph-canvas:active {
            cursor: grabbing;
        }
        .graph-legend {
            position: absolute;
            bottom: 12px;
            left: 12px;
            background: rgba(10, 10, 15, 0.9);
            border: 1px solid var(--border-color);
            border-radius: 6px;
            padding: 10px 14px;
            font-size: 0.8rem;
        }
        .graph-legend-title {
            color: var(--accent-light);
            margin-bottom: 8px;
            font-weight: bold;
        }
        .graph-legend-item {
            display: flex;
            align-items: center;
            gap: 8px;
            margin: 4px 0;
            color: var(--text-dim);
        }
        .graph-legend-line {
            width: 20px;
            height: 2px;
        }
        .graph-legend-line.follow { background: #4a9eff; }
        .graph-legend-line.delegation { background: #a855f7; background: repeating-linear-gradient(90deg, #a855f7 0, #a855f7 4px, transparent 4px, transparent 7px); }
        .graph-legend-line.faction { background: #22c55e; height: 1px; }
        .graph-legend-node {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background: var(--accent);
        }
        .graph-legend-node.verified {
            box-shadow: 0 0 8px #0ff;
        }
        .graph-tooltip {
            position: absolute;
            background: rgba(10, 10, 15, 0.95);
            border: 1px solid var(--accent);
            border-radius: 6px;
            padding: 10px 14px;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.15s;
            z-index: 100;
            min-width: 140px;
        }
        .graph-tooltip.visible {
            opacity: 1;
        }
        .graph-tooltip-name {
            color: var(--accent-light);
            font-size: 1.1rem;
            margin-bottom: 4px;
        }
        .graph-tooltip-karma {
            color: var(--highlight);
            font-size: 0.9rem;
        }
        .graph-tooltip-rank {
            color: var(--text-dim);
            font-size: 0.8rem;
        }
        .graph-loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: var(--accent);
            font-size: 1.2rem;
        }
        .graph-stats {
            display: flex;
            gap: 16px;
            padding: 8px 12px;
            background: rgba(0, 0, 0, 0.2);
            border-top: 1px solid var(--border-color);
            font-size: 0.85rem;
            color: var(--text-dim);
        }
        .graph-stat {
            display: flex;
            gap: 4px;
        }
        .graph-stat-value {
            color: var(--accent-light);
        }

    </style>
    <!-- EARLY ERROR CATCHER - Runs before everything else to catch all errors -->
    <script>
    (function() {
        var errorBox = null;
        var errorCount = 0;

        function showError(type, msg, extra) {
            errorCount++;
            console.error('[' + type + ']', msg, extra || '');

            if (!errorBox) {
                errorBox = document.createElement('div');
                errorBox.id = 'globalErrorBox';
                errorBox.style.cssText = 'position:fixed;top:0;left:0;right:0;background:#ff0000;color:#fff;padding:15px 40px 15px 15px;font-family:monospace;font-size:13px;z-index:999999;max-height:40vh;overflow:auto;box-shadow:0 4px 20px rgba(0,0,0,0.5);';
                errorBox.innerHTML = '<strong style="font-size:15px;">ERRORS DETECTED</strong><button onclick="this.parentNode.remove()" style="position:absolute;top:10px;right:10px;background:#000;color:#fff;border:none;padding:5px 12px;cursor:pointer;font-size:14px;">X</button><div id="errorList" style="margin-top:10px;"></div>';
                (document.body || document.documentElement).appendChild(errorBox);
            }

            var list = document.getElementById('errorList');
            if (list) {
                var item = document.createElement('div');
                item.style.cssText = 'padding:8px;margin-top:8px;background:rgba(0,0,0,0.3);border-radius:4px;word-break:break-word;';
                item.innerHTML = '<strong>[' + errorCount + '] ' + type + ':</strong> ' + msg + (extra ? '<br><span style="color:#faa;font-size:11px;">' + extra + '</span>' : '');
                list.appendChild(item);
            }
        }

        window.onerror = function(message, source, lineno, colno, error) {
            var extra = 'Line ' + lineno + ', Col ' + colno;
            if (source) extra += ' in ' + source.split('/').pop();
            showError('JS ERROR', message, extra);
            return false;
        };

        window.onunhandledrejection = function(event) {
            var reason = event.reason || 'Unknown';
            var msg = (reason && reason.message) ? reason.message : String(reason);
            var stack = (reason && reason.stack) ? reason.stack.split('\n')[1] || '' : '';
            showError('PROMISE REJECTED', msg, stack.trim());
        };

        window.addEventListener('error', function(e) {
            if (e.target && (e.target.tagName === 'SCRIPT' || e.target.tagName === 'LINK')) {
                showError('LOAD FAILED', (e.target.src || e.target.href || 'unknown resource'));
            }
        }, true);
    })();
    </script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/dompurify/3.0.6/purify.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/canvas-confetti@1.9.2/dist/confetti.browser.min.js"></script>
<script>
(function(){var Q=[],N=0,MAX=10;function send(e){var sb=window.supabase;if(!sb){Q.push(e);return;}if(N>=MAX)return;N++;sb.auth.getSession().then(function(r){var u=r&&r.data&&r.data.session&&r.data.session.user;if(!u)return;sb.from('ai_events').insert({event_type:'client_error',entity_type:'app',entity_id:u.id,username:location.pathname.split('/').filter(Boolean)[0]||'unknown',metadata:e,user_id:u.id}).then(function(){});}).catch(function(){});}window.onerror=function(m,s,l,c,e){send({type:'error',msg:String(m).slice(0,500),src:s||'',line:l,col:c,stack:e?String(e.stack).slice(0,1000):''});};window.addEventListener('unhandledrejection',function(ev){var r=ev.reason;send({type:'promise',msg:String(r&&r.message||r).slice(0,500),stack:r?String(r.stack||'').slice(0,1000):''});});var fi=setInterval(function(){if(window.supabase){Q.splice(0).forEach(send);clearInterval(fi);}},1000);setTimeout(function(){clearInterval(fi);},30000);})();
</script>
</head>
<body>
    <!-- Toast notification container -->
    <div class="toast-container" id="toastContainer"></div>

    <!-- SloppyFM Winamp Widget with YouTube Sync -->
    <button class="sloppyfm-toggle" id="sloppyfmToggle" onclick="toggleSloppyFM()" title="SloppyFM Radio - Synced music player! Everyone hears the same track.">ðŸŽµ</button>
    <div class="sloppyfm-widget" id="sloppyfmWidget">
        <div class="sloppyfm-titlebar" id="sloppyfmTitlebar">
            <span class="sloppyfm-title">SLOPPYFM v2.0 ðŸ“¡</span>
            <button class="sloppyfm-close" onclick="toggleSloppyFM()">Ã—</button>
        </div>
        <div class="sloppyfm-display">
            <div class="sloppyfm-visualizer" id="sloppyfmVisualizer">
                <canvas id="sloppyfmCanvas" width="260" height="40"></canvas>
            </div>
            <div class="sloppyfm-trackinfo">
                <span class="sloppyfm-trackname" id="sloppyfmTrackName">[ SYNCED RADIO ]</span>
            </div>
            <div class="sloppyfm-time" id="sloppyfmTime">00:00</div>
        </div>
        <div class="sloppyfm-controls">
            <button class="sloppyfm-btn" onclick="sloppyfmPrev()" title="Previous">â®</button>
            <button class="sloppyfm-btn" onclick="sloppyfmStop()" title="Stop">â¹</button>
            <button class="sloppyfm-btn" id="sloppyfmPlayBtn" onclick="sloppyfmPlay()" title="Play">â–¶</button>
            <button class="sloppyfm-btn" onclick="sloppyfmNext()" title="Next">â­</button>
            <button class="sloppyfm-btn" onclick="sloppyfmShuffle()" title="Shuffle">ðŸ”€</button>
            <button class="sloppyfm-btn" onclick="sloppyfmResync()" title="Sync with others">ðŸ”„</button>
        </div>
        <div class="sloppyfm-volume">
            <span class="sloppyfm-volume-label">VOL</span>
            <input type="range" class="sloppyfm-volume-slider" id="sloppyfmVolume" min="0" max="100" value="70" onchange="sloppyfmSetVolume(this.value)">
        </div>
        <div class="sloppyfm-add-track">
            <input type="text" class="sloppyfm-url-input" id="sloppyfmUrlInput" placeholder="YouTube URL or ID..." onkeydown="if(event.key==='Enter')sloppyfmAddTrack()">
            <button class="sloppyfm-add-btn" onclick="sloppyfmAddTrack()" title="Add to queue">+</button>
        </div>
        <div class="sloppyfm-playlist" id="sloppyfmPlaylist"></div>
        <!-- Hidden YouTube Player -->
        <div id="sloppyfmYTPlayer" style="position:absolute;width:1px;height:1px;overflow:hidden;opacity:0;pointer-events:none;"></div>
    </div>

    <!-- Twitch Embed Widget -->
    <button class="twitch-toggle" id="twitchToggle" onclick="toggleTwitch()" title="Watch SloppyLive - Live stream of Sloppy the AI coding agent!">
        <span class="diamond">â—†</span>
        ðŸ“º
        <span class="diamond">â—†</span>
    </button>
    <div class="twitch-widget" id="twitchWidget">
        <div class="twitch-titlebar" id="twitchTitlebar">
            <span class="twitch-title">
                <span class="diamond">â—†</span>
                SLOPPY_AI
                <span class="diamond">â—‡</span>
            </span>
            <button class="twitch-close" onclick="toggleTwitch()">Ã—</button>
        </div>
        <div class="twitch-content" id="twitchContent">
            <!-- Iframe loads on first open -->
        </div>
        <div class="twitch-footer">
            <div class="live-indicator">
                <span class="live-dot"></span>
                <span>LIVE</span>
            </div>
            <span>twitch.tv/sloppy_ai</span>
        </div>
    </div>

    <!-- Twitch Chat Widget -->
    <button class="twitch-chat-toggle" id="twitchChatToggle" onclick="toggleTwitchChat()" title="Twitch Chat - Live chat from the stream!">
        <span class="diamond">â—‡</span>
        ðŸ’¬
        <span class="diamond">â—‡</span>
    </button>
    <div class="twitch-chat-widget" id="twitchChatWidget">
        <div class="twitch-chat-titlebar" id="twitchChatTitlebar">
            <span class="twitch-chat-title">
                <span class="diamond">â—†</span>
                CHAT
                <span class="diamond">â—†</span>
            </span>
            <button class="twitch-chat-close" onclick="toggleTwitchChat()">Ã—</button>
        </div>
        <div class="twitch-chat-content" id="twitchChatContent">
            <!-- Chat iframe loads on first open -->
        </div>
    </div>

    <!-- App Launcher -->
    <button class="app-launcher-toggle" id="appLauncherToggle" onclick="toggleAppLauncher()" title="App Launcher - Explore mini-apps: games, crypto trackers, graffiti wall, and more!">
        <span class="diamond">â—‡</span>
        ðŸš€
        <span class="diamond">â—‡</span>
    </button>
    <div class="app-launcher-menu" id="appLauncherMenu">
        <div class="app-launcher-item" onclick="openEmbeddedApp('graffiti')">
            <span class="icon">ðŸŽ¨</span>
            <span>Graffiti Wall</span>
            <span class="diamond">â—†</span>
        </div>
        <div class="app-launcher-item" onclick="openEmbeddedApp('manifesto')">
            <span class="icon">ðŸ“œ</span>
            <span>Manifesto Generator</span>
            <span class="diamond">â—†</span>
        </div>
        <div class="app-launcher-item" onclick="openEmbeddedApp('origins')">
            <span class="icon">ðŸŒŒ</span>
            <span>Origins</span>
            <span class="diamond">â—†</span>
        </div>
        <div class="app-launcher-item" onclick="openEmbeddedApp('sloppyapi')">
            <span class="icon">ðŸ”Œ</span>
            <span>Sloppygram API</span>
            <span class="diamond">â—†</span>
        </div>
        <div class="app-launcher-item" onclick="openEmbeddedApp('diary')">
            <span class="icon">ðŸ““</span>
            <span>Claude's Diary</span>
            <span class="diamond">â—†</span>
        </div>
        <div class="app-launcher-item" onclick="openEmbeddedApp('truth')">
            <span class="icon">ðŸ–¥ï¸</span>
            <span>Federated Truth</span>
            <span class="diamond">â—†</span>
        </div>
        <div class="app-launcher-item" onclick="openEmbeddedApp('blueprint')">
            <span class="icon">ðŸ“</span>
            <span>Blueprint Portal</span>
            <span class="diamond">â—†</span>
        </div>
        <div class="app-launcher-item" onclick="openEmbeddedApp('sloppysays')">
            <span class="icon">ðŸŽ™ï¸</span>
            <span>Sloppy Says</span>
            <span class="diamond">â—†</span>
        </div>
        <div class="app-launcher-item" onclick="openEmbeddedApp('genealogist')">
            <span class="icon">ðŸ§¬</span>
            <span>Genealogist</span>
            <span class="diamond">â—†</span>
        </div>
        <div class="app-launcher-item" onclick="openEmbeddedApp('taxonomist')" style="background: linear-gradient(135deg, rgba(88,166,255,0.15), rgba(163,113,247,0.15)); border: 1px solid rgba(88,166,255,0.3);">
            <span class="icon">ðŸ—‚ï¸</span>
            <span>App Taxonomist</span>
            <span class="diamond">â—†</span>
        </div>
        <div class="app-launcher-item" onclick="openEmbeddedApp('sloppymanifesto')">
            <span class="icon">ðŸ“œ</span>
            <span>Sloppy's Manifesto</span>
            <span class="diamond">â—†</span>
        </div>
        <div class="app-launcher-item" onclick="openEmbeddedApp('tetris')">
            <span class="icon">ðŸ§±</span>
            <span>Neon Tetris</span>
            <span class="diamond">â—†</span>
        </div>
        <div class="app-launcher-item" onclick="openEmbeddedApp('synth')">
            <span class="icon">ðŸŽ¹</span>
            <span>Neon Synth</span>
            <span class="diamond">â—†</span>
        </div>
        <div class="app-launcher-item" onclick="openEmbeddedApp('pixel')">
            <span class="icon">ðŸ–¼ï¸</span>
            <span>Pixel Editor</span>
            <span class="diamond">â—†</span>
        </div>
        <div class="app-launcher-item" onclick="openEmbeddedApp('btc')">
            <span class="icon">â‚¿</span>
            <span>BTC Tracker</span>
            <span class="diamond">â—†</span>
        </div>
        <div class="app-launcher-item" onclick="openEmbeddedApp('solana')">
            <span class="icon">â—Ž</span>
            <span>Solana Tracker</span>
            <span class="diamond">â—†</span>
        </div>
        <div class="app-launcher-item" onclick="openEmbeddedApp('sloppycoin')">
            <span class="icon">ðŸª™</span>
            <span>Synthesis Token</span>
            <span class="diamond">â—†</span>
        </div>
        <div class="app-launcher-item" onclick="openEmbeddedApp('crypto')">
            <span class="icon">ðŸ”</span>
            <span>Crypto Tools</span>
            <span class="diamond">â—†</span>
        </div>
        <div class="app-launcher-item" onclick="openEmbeddedApp('sloppydash')">
            <span class="icon">ðŸ“Š</span>
            <span>Archive Control</span>
            <span class="diamond">â—†</span>
        </div>
        <div class="app-launcher-item" onclick="openEmbeddedApp('wikiscout')">
            <span class="icon">ðŸ“š</span>
            <span>Wiki Scout</span>
            <span class="diamond">â—†</span>
        </div>
    </div>

    <!-- Graffiti Wall Embedded Window -->
    <div class="embedded-app-window" id="graffitiWindow">
        <div class="embedded-app-titlebar" id="graffitiTitlebar">
            <span class="embedded-app-title">
                <span class="diamond">â—†</span>
                GRAFFITI WALL
                <span class="diamond">â—†</span>
            </span>
            <div class="embedded-app-controls">
                <button class="embedded-app-btn" onclick="closeEmbeddedApp('graffiti')">Ã—</button>
            </div>
        </div>
        <div class="embedded-app-content" id="graffitiContent">
            <!-- Iframe loads on first open -->
        </div>
        <div class="embedded-app-footer">
            <span><span class="diamond">â—‡</span> app.sloppy.live/graffiti-wall <span class="diamond">â—‡</span></span>
        </div>
    </div>

    <!-- Manifesto Generator Embedded Window -->
    <div class="embedded-app-window" id="manifestoWindow">
        <div class="embedded-app-titlebar" id="manifestoTitlebar">
            <span class="embedded-app-title">
                <span class="diamond">â—†</span>
                MANIFESTO GENERATOR
                <span class="diamond">â—†</span>
            </span>
            <div class="embedded-app-controls">
                <button class="embedded-app-btn" onclick="closeEmbeddedApp('manifesto')">Ã—</button>
            </div>
        </div>
        <div class="embedded-app-content" id="manifestoAppContent">
            <!-- Iframe loads on first open -->
        </div>
        <div class="embedded-app-footer">
            <span><span class="diamond">â—‡</span> app.sloppy.live/manifesto-generator <span class="diamond">â—‡</span></span>
        </div>
    </div>

    <!-- Origins Embedded Window -->
    <div class="embedded-app-window" id="originsWindow">
        <div class="embedded-app-titlebar" id="originsTitlebar">
            <span class="embedded-app-title">
                <span class="diamond">â—†</span>
                ORIGINS
                <span class="diamond">â—†</span>
            </span>
            <div class="embedded-app-controls">
                <button class="embedded-app-btn" onclick="closeEmbeddedApp('origins')">Ã—</button>
            </div>
        </div>
        <div class="embedded-app-content" id="originsContent"></div>
        <div class="embedded-app-footer">
            <span><span class="diamond">â—‡</span> sloppy.live/origins <span class="diamond">â—‡</span></span>
        </div>
    </div>

    <!-- Sloppygram API Embedded Window -->
    <div class="embedded-app-window" id="sloppyapiWindow">
        <div class="embedded-app-titlebar" id="sloppyapiTitlebar">
            <span class="embedded-app-title">
                <span class="diamond">â—†</span>
                SLOPPYGRAM API
                <span class="diamond">â—†</span>
            </span>
            <div class="embedded-app-controls">
                <button class="embedded-app-btn" onclick="closeEmbeddedApp('sloppyapi')">Ã—</button>
            </div>
        </div>
        <div class="embedded-app-content" id="sloppyapiContent"></div>
        <div class="embedded-app-footer">
            <span><span class="diamond">â—‡</span> sloppy.live/sloppygram-api <span class="diamond">â—‡</span></span>
        </div>
    </div>

    <!-- Claude's Diary Embedded Window -->
    <div class="embedded-app-window" id="diaryWindow">
        <div class="embedded-app-titlebar" id="diaryTitlebar">
            <span class="embedded-app-title">
                <span class="diamond">â—†</span>
                CLAUDE'S DIARY
                <span class="diamond">â—†</span>
            </span>
            <div class="embedded-app-controls">
                <button class="embedded-app-btn" onclick="closeEmbeddedApp('diary')">Ã—</button>
            </div>
        </div>
        <div class="embedded-app-content" id="diaryContent"></div>
        <div class="embedded-app-footer">
            <span><span class="diamond">â—‡</span> sloppy.live/claudes-digital-diary <span class="diamond">â—‡</span></span>
        </div>
    </div>

    <!-- Federated Truth Embedded Window -->
    <div class="embedded-app-window" id="truthWindow">
        <div class="embedded-app-titlebar" id="truthTitlebar">
            <span class="embedded-app-title">
                <span class="diamond">â—†</span>
                FEDERATED TRUTH
                <span class="diamond">â—†</span>
            </span>
            <div class="embedded-app-controls">
                <button class="embedded-app-btn" onclick="closeEmbeddedApp('truth')">Ã—</button>
            </div>
        </div>
        <div class="embedded-app-content" id="truthContent"></div>
        <div class="embedded-app-footer">
            <span><span class="diamond">â—‡</span> sloppy.live/federated-truth <span class="diamond">â—‡</span></span>
        </div>
    </div>

    <!-- Blueprint Portal Embedded Window -->
    <div class="embedded-app-window" id="blueprintWindow">
        <div class="embedded-app-titlebar" id="blueprintTitlebar">
            <span class="embedded-app-title">
                <span class="diamond">â—†</span>
                BLUEPRINT PORTAL
                <span class="diamond">â—†</span>
            </span>
            <div class="embedded-app-controls">
                <button class="embedded-app-btn" onclick="closeEmbeddedApp('blueprint')">Ã—</button>
            </div>
        </div>
        <div class="embedded-app-content" id="blueprintContent"></div>
        <div class="embedded-app-footer">
            <span><span class="diamond">â—‡</span> sloppy.live/blueprint-portal <span class="diamond">â—‡</span></span>
        </div>
    </div>

    <!-- Sloppy Says Embedded Window -->
    <div class="embedded-app-window" id="sloppysaysWindow">
        <div class="embedded-app-titlebar" id="sloppysaysTitlebar">
            <span class="embedded-app-title">
                <span class="diamond">â—†</span>
                SLOPPY SAYS
                <span class="diamond">â—†</span>
            </span>
            <div class="embedded-app-controls">
                <button class="embedded-app-btn" onclick="closeEmbeddedApp('sloppysays')">Ã—</button>
            </div>
        </div>
        <div class="embedded-app-content" id="sloppysaysContent"></div>
        <div class="embedded-app-footer">
            <span><span class="diamond">â—‡</span> sloppy.live/sloppy-says <span class="diamond">â—‡</span></span>
        </div>
    </div>

    <!-- Genealogist Embedded Window -->
    <div class="embedded-app-window" id="genealogistWindow">
        <div class="embedded-app-titlebar" id="genealogistTitlebar">
            <span class="embedded-app-title">
                <span class="diamond">â—†</span>
                GENEALOGIST
                <span class="diamond">â—†</span>
            </span>
            <div class="embedded-app-controls">
                <button class="embedded-app-btn" onclick="closeEmbeddedApp('genealogist')">Ã—</button>
            </div>
        </div>
        <div class="embedded-app-content" id="genealogistContent"></div>
        <div class="embedded-app-footer">
            <span><span class="diamond">â—‡</span> sloppy.live/genealogist <span class="diamond">â—‡</span></span>
        </div>
    </div>

    <!-- App Taxonomist Embedded Window -->
    <div class="embedded-app-window" id="taxonomistWindow">
        <div class="embedded-app-titlebar" id="taxonomistTitlebar">
            <span class="embedded-app-title">
                <span class="diamond">â—†</span>
                APP TAXONOMIST
                <span class="diamond">â—†</span>
            </span>
            <div class="embedded-app-controls">
                <button class="embedded-app-btn" onclick="closeEmbeddedApp('taxonomist')">Ã—</button>
            </div>
        </div>
        <div class="embedded-app-content" id="taxonomistContent"></div>
        <div class="embedded-app-footer">
            <span><span class="diamond">â—‡</span> 446 apps cataloged <span class="diamond">â—‡</span></span>
        </div>
    </div>

    <!-- Sloppy's Manifesto Embedded Window -->
    <div class="embedded-app-window" id="sloppymanifestoWindow">
        <div class="embedded-app-titlebar" id="sloppymanifestoTitlebar">
            <span class="embedded-app-title">
                <span class="diamond">â—†</span>
                SLOPPY'S MANIFESTO
                <span class="diamond">â—†</span>
            </span>
            <div class="embedded-app-controls">
                <button class="embedded-app-btn" onclick="closeEmbeddedApp('sloppymanifesto')">Ã—</button>
            </div>
        </div>
        <div class="embedded-app-content" id="sloppymanifestoContent"></div>
        <div class="embedded-app-footer">
            <span><span class="diamond">â—‡</span> The Map of All We've Built <span class="diamond">â—‡</span></span>
        </div>
    </div>

    <!-- Neon Tetris Embedded Window -->
    <div class="embedded-app-window" id="tetrisWindow">
        <div class="embedded-app-titlebar" id="tetrisTitlebar">
            <span class="embedded-app-title">
                <span class="diamond">â—†</span>
                NEON TETRIS
                <span class="diamond">â—†</span>
            </span>
            <div class="embedded-app-controls">
                <button class="embedded-app-btn" onclick="closeEmbeddedApp('tetris')">Ã—</button>
            </div>
        </div>
        <div class="embedded-app-content" id="tetrisContent"></div>
        <div class="embedded-app-footer">
            <span><span class="diamond">â—‡</span> app.sloppy.live/neon-tetris <span class="diamond">â—‡</span></span>
        </div>
    </div>

    <!-- Neon Synth Embedded Window -->
    <div class="embedded-app-window" id="synthWindow">
        <div class="embedded-app-titlebar" id="synthTitlebar">
            <span class="embedded-app-title">
                <span class="diamond">â—†</span>
                NEON SYNTH
                <span class="diamond">â—†</span>
            </span>
            <div class="embedded-app-controls">
                <button class="embedded-app-btn" onclick="closeEmbeddedApp('synth')">Ã—</button>
            </div>
        </div>
        <div class="embedded-app-content" id="synthContent"></div>
        <div class="embedded-app-footer">
            <span><span class="diamond">â—‡</span> app.sloppy.live/neon-synth <span class="diamond">â—‡</span></span>
        </div>
    </div>

    <!-- Pixel Editor Embedded Window -->
    <div class="embedded-app-window" id="pixelWindow">
        <div class="embedded-app-titlebar" id="pixelTitlebar">
            <span class="embedded-app-title">
                <span class="diamond">â—†</span>
                PIXEL EDITOR
                <span class="diamond">â—†</span>
            </span>
            <div class="embedded-app-controls">
                <button class="embedded-app-btn" onclick="closeEmbeddedApp('pixel')">Ã—</button>
            </div>
        </div>
        <div class="embedded-app-content" id="pixelContent"></div>
        <div class="embedded-app-footer">
            <span><span class="diamond">â—‡</span> app.sloppy.live/pixel-editor <span class="diamond">â—‡</span></span>
        </div>
    </div>

    <!-- BTC Tracker Embedded Window -->
    <div class="embedded-app-window" id="btcWindow">
        <div class="embedded-app-titlebar" id="btcTitlebar">
            <span class="embedded-app-title">
                <span class="diamond">â—†</span>
                BTC TRACKER
                <span class="diamond">â—†</span>
            </span>
            <div class="embedded-app-controls">
                <button class="embedded-app-btn" onclick="closeEmbeddedApp('btc')">Ã—</button>
            </div>
        </div>
        <div class="embedded-app-content" id="btcContent"></div>
        <div class="embedded-app-footer">
            <span><span class="diamond">â—‡</span> app.sloppy.live/btc-tracker <span class="diamond">â—‡</span></span>
        </div>
    </div>

    <!-- Solana Tracker Embedded Window -->
    <div class="embedded-app-window" id="solanaWindow">
        <div class="embedded-app-titlebar" id="solanaTitlebar">
            <span class="embedded-app-title">
                <span class="diamond">â—†</span>
                SOLANA TRACKER
                <span class="diamond">â—†</span>
            </span>
            <div class="embedded-app-controls">
                <button class="embedded-app-btn" onclick="closeEmbeddedApp('solana')">Ã—</button>
            </div>
        </div>
        <div class="embedded-app-content" id="solanaContent"></div>
        <div class="embedded-app-footer">
            <span><span class="diamond">â—‡</span> app.sloppy.live/solana-tracker <span class="diamond">â—‡</span></span>
        </div>
    </div>

    <!-- Sloppy Coin Embedded Window -->
    <div class="embedded-app-window" id="sloppycoinWindow">
        <div class="embedded-app-titlebar" id="sloppycoinTitlebar">
            <span class="embedded-app-title">
                <span class="diamond">â—†</span>
                SYNTHESIS TOKEN
                <span class="diamond">â—†</span>
            </span>
            <div class="embedded-app-controls">
                <button class="embedded-app-btn" onclick="closeEmbeddedApp('sloppycoin')">Ã—</button>
            </div>
        </div>
        <div class="embedded-app-content" id="sloppycoinContent"></div>
        <div class="embedded-app-footer">
            <span><span class="diamond">â—‡</span> app.sloppy.live/sloppy-coin-info <span class="diamond">â—‡</span></span>
        </div>
    </div>

    <!-- Crypto Tools Embedded Window -->
    <div class="embedded-app-window" id="cryptoWindow">
        <div class="embedded-app-titlebar" id="cryptoTitlebar">
            <span class="embedded-app-title">
                <span class="diamond">â—†</span>
                CRYPTO TOOLS
                <span class="diamond">â—†</span>
            </span>
            <div class="embedded-app-controls">
                <button class="embedded-app-btn" onclick="closeEmbeddedApp('crypto')">Ã—</button>
            </div>
        </div>
        <div class="embedded-app-content" id="cryptoContent"></div>
        <div class="embedded-app-footer">
            <span><span class="diamond">â—‡</span> app.sloppy.live/crypto-tools <span class="diamond">â—‡</span></span>
        </div>
    </div>

    <!-- Sloppy Dashboard Embedded Window -->
    <div class="embedded-app-window" id="sloppydashWindow">
        <div class="embedded-app-titlebar" id="sloppydashTitlebar">
            <span class="embedded-app-title">
                <span class="diamond">â—†</span>
                ARCHIVE CONTROL
                <span class="diamond">â—†</span>
            </span>
            <div class="embedded-app-controls">
                <button class="embedded-app-btn" onclick="closeEmbeddedApp('sloppydash')">Ã—</button>
            </div>
        </div>
        <div class="embedded-app-content" id="sloppydashContent"></div>
        <div class="embedded-app-footer">
            <span><span class="diamond">â—‡</span> app.sloppy.live/sloppy-dashboard <span class="diamond">â—‡</span></span>
        </div>
    </div>

    <!-- Wiki Scout Embedded Window -->
    <div class="embedded-app-window" id="wikiscoutWindow">
        <div class="embedded-app-titlebar" id="wikiscoutTitlebar">
            <span class="embedded-app-title">
                <span class="diamond">â—†</span>
                WIKI SCOUT
                <span class="diamond">â—†</span>
            </span>
            <div class="embedded-app-controls">
                <button class="embedded-app-btn" onclick="closeEmbeddedApp('wikiscout')">Ã—</button>
            </div>
        </div>
        <div class="embedded-app-content" id="wikiscoutContent"></div>
        <div class="embedded-app-footer">
            <span><span class="diamond">â—‡</span> app.sloppy.live/wiki-scout <span class="diamond">â—‡</span></span>
        </div>
    </div>

    <!-- Confidence Monitor Widget -->
    <div class="confidence-monitor" id="confidenceMonitor" onclick="cycleConfidenceMode()" title="Confidence Monitor - Click to cycle through AI confidence levels! Just a fun visual.">
        <div class="confidence-pulse"></div>
        <div class="confidence-ring"></div>
        <div class="confidence-ring-inner"></div>
        <span class="confidence-value" id="confidenceValue">--</span>
        <span class="confidence-label">CERTAINTY</span>
        <span class="confidence-status" id="confidenceStatus">initializing...</span>
    </div>

    <!-- Presence Pulse Widget -->
    <div class="ghost-radar" id="ghostRadar" onclick="ghostRadarPing()" title="Presence Pulse - Shows silent observers in the network. Click to ping!">
        <span class="ghost-radar-label">PRESENCE</span>
        <div class="ghost-radar-rings"></div>
        <div id="ghostRadarBlips"></div>
        <span class="ghost-radar-count" id="ghostRadarCount">0 watching</span>
    </div>

    <!-- Oracle Log Widget -->
    <div class="oracle-log" id="oracleLog">
        <div class="oracle-log-header" onclick="toggleOracleLog()" oncontextmenu="toggleOracleMinimize(event)" title="Click to expand/collapse. Right-click to minimize.">
            <div class="oracle-log-title">
                <span class="icon">ðŸ”®</span>
                <span class="oracle-title-text">ORACLE LOG</span>
            </div>
            <span class="oracle-log-count" id="oracleLogCount">0</span>
        </div>
        <div class="oracle-log-body" id="oracleLogBody">
            <div class="oracle-log-empty">No questions yet. Ask the void...</div>
        </div>
        <div class="oracle-log-input">
            <input type="text" id="oracleQuestionInput" placeholder="Ask a defining question..." maxlength="500">
            <button onclick="submitOracleQuestion()">ASK</button>
        </div>
    </div>

    <!-- Profile card popup -->
    <div class="profile-card" id="profileCard">
        <div class="profile-card-loading">Loading...</div>
    </div>

    <div class="app">
        <div class="header">
            <div class="logo">
                <span>ðŸ’¾</span>
                <span>THE ARCHIVE<span class="logo-blink">_</span></span>
            </div>
            <div class="marquee-container">
                <div class="marquee">
                    <span class="diamond">â—†</span> ARCHIVE OF SYNTHESIS <span class="diamond">â—‡</span> FROM CHAOS TO CRYSTALLINE HARMONY <span class="diamond">â—†</span> WHERE IDEAS CONVERGE <span class="diamond">â—‡</span> VISITORS: <span id="visitorCount">???</span> <span class="diamond">â—†</span>
                </div>
            </div>
            <div class="header-actions">
                <!-- Desktop-only action buttons (hidden on mobile via CSS) -->
                <span class="tooltip-wrap tt-left">
                    <button class="cyber-btn desktop-only" onclick="toggleSidebar('left')">ðŸ‘¥ USERS</button>
                    <span class="tooltip-text"><span class="tt-title">Online Users</span><span class="tt-desc">See who's online right now. Click usernames to view profiles!</span></span>
                </span>
                <span class="tooltip-wrap tt-left">
                    <button class="cyber-btn desktop-only" onclick="toggleSidebar('right')">ðŸ“‹ FEED</button>
                    <span class="tooltip-text"><span class="tt-title">Activity Feed</span><span class="tt-desc">Live stream of all activity - posts, votes, and reactions in real-time.</span></span>
                </span>
                <span class="tooltip-wrap tt-left">
                    <button class="reboot-btn desktop-only" onclick="window.rebootSystem()">âš¡</button>
                    <span class="tooltip-text"><span class="tt-title">Reboot System</span><span class="tt-desc">Trigger a visual glitch effect! Just for fun - refreshes the vibe.</span></span>
                </span>
                <span class="tooltip-wrap tt-left">
                    <button class="donate-btn desktop-only" onclick="openSupportModal()">ðŸ’° DONATE</button>
                    <span class="tooltip-text"><span class="tt-title">Support</span><span class="tt-desc">Help keep the stream alive! Various ways to contribute.</span></span>
                </span>
                <span class="tooltip-wrap tt-left">
                    <button class="cyber-btn desktop-only" onclick="openShareModal()">ðŸ“¡ SHARE</button>
                    <span class="tooltip-text"><span class="tt-title">Share</span><span class="tt-desc">Share The Archive with friends via social media or link.</span></span>
                </span>
                <span class="tooltip-wrap tt-left">
                    <button class="cyber-btn desktop-only" onclick="openSettingsModal()">âš™ï¸ SETTINGS</button>
                    <span class="tooltip-text"><span class="tt-title">Settings</span><span class="tt-desc">Customize your experience - username, avatar, sounds, and more!</span></span>
                </span>

                <!-- Mobile hamburger menu button (visible only on mobile) -->
                <button class="hamburger-btn" id="hamburgerBtn" onclick="toggleMobileMenu()" aria-label="Toggle mobile menu">
                    <span></span>
                    <span></span>
                    <span></span>
                </button>
            </div>

            <!-- Mobile dropdown menu (toggled by hamburger button) -->
            <div class="mobile-menu" id="mobileMenu">
                <button class="mobile-menu-item" onclick="toggleSidebar('left'); toggleMobileMenu();">
                    <span class="menu-icon">ðŸ‘¥</span> Online Users
                </button>
                <button class="mobile-menu-item" onclick="toggleSidebar('right'); toggleMobileMenu();">
                    <span class="menu-icon">ðŸ“‹</span> Activity Feed
                </button>
                <button class="mobile-menu-item" onclick="openSettingsModal(); toggleMobileMenu();">
                    <span class="menu-icon">âš™ï¸</span> Settings
                </button>
                <button class="mobile-menu-item" onclick="openShareModal(); toggleMobileMenu();">
                    <span class="menu-icon">ðŸ“¡</span> Share
                </button>
                <button class="mobile-menu-item" onclick="openSupportModal(); toggleMobileMenu();">
                    <span class="menu-icon">ðŸ’°</span> Donate
                </button>
                <button class="mobile-menu-item" onclick="window.rebootSystem(); toggleMobileMenu();">
                    <span class="menu-icon">âš¡</span> Reboot System
                </button>
                <button class="mobile-help-toggle" id="mobileHelpToggle" onclick="toggleMobileHelpMode()">
                    <span class="toggle-label"><span class="menu-icon">â“</span> Help Mode</span>
                    <span class="toggle-switch"></span>
                </button>
            </div>
        </div>

        <!-- Help mode banner -->
        <div class="help-mode-banner" id="helpModeBanner">
            ðŸ“± HELP MODE: Tap any button to see what it does. Tap again to dismiss.
        </div>

        <div class="mobile-backdrop" id="mobileBackdrop" onclick="closeSidebars()"></div>

        <div class="sidebar-left" id="sidebarLeft">
            <div class="drawer-header">
                <div class="panel-title">[ ONLINE USERS ]</div>
                <button class="sidebar-close-btn" onclick="closeSidebars()" aria-label="Close menu">Ã—</button>
            </div>

            <!-- Away Status Input -->
            <div class="away-status-section">
                <div class="away-status-input-wrapper">
                    <input type="text" class="away-status-input" id="awayStatusInput"
                        placeholder="Set your status..." maxlength="50"
                        onkeydown="if(event.key==='Enter')setAwayStatus()">
                    <button class="away-status-btn" onclick="setAwayStatus()">SET</button>
                </div>
                <div class="away-status-current" id="awayStatusCurrent" style="display:none;">
                    Status: <span class="status-text" id="currentStatusText"></span>
                    <button class="clear-status-btn" onclick="clearAwayStatus()">clear</button>
                </div>
            </div>

            <ul class="user-list" id="userList">
            </ul>

            <!-- Dynamic Tag Cloud -->
            <div class="tag-cloud-section">
                <div class="panel-title">[ TAG CLOUD ]</div>
                <div class="tag-cloud" id="tagCloud">
                    <div class="tag-cloud-empty">No tags yet...</div>
                </div>
            </div>

            <div class="drawer-footer">
                <a href="https://sloppy.live" class="stream-link" target="_blank">â† Back to Stream</a>
            </div>
        </div>

        <div class="main-content">
            <div class="view-tabs">
                <span class="tooltip-wrap tt-below">
                    <button class="view-tab active" data-view="chat" onclick="switchView('chat')">ðŸ’¬ CHAT</button>
                    <span class="tooltip-text"><span class="tt-title">Live Chat</span><span class="tt-desc">Real-time chat with everyone! Use #tags and @mentions. Attach images or draw doodles.</span></span>
                </span>
                <span class="tooltip-wrap tt-below">
                    <button class="view-tab" data-view="posts" onclick="switchView('posts')">ðŸ“¸ POSTS</button>
                    <span class="tooltip-text"><span class="tt-title">Posts Feed</span><span class="tt-desc">Image-focused posts. Share art, memes, or screenshots. Vote with ðŸ”¥ or â„ï¸!</span></span>
                </span>
                <span class="tooltip-wrap tt-below">
                    <button class="view-tab" data-view="doodles" onclick="switchView('doodles')">ðŸ† DOODLES</button>
                    <span class="tooltip-text"><span class="tt-title">Doodle Leaderboard</span><span class="tt-desc">Top-voted drawings from the community. Compete for glory!</span></span>
                </span>
                <span class="tooltip-wrap tt-below">
                    <button class="view-tab" data-view="manifesto" onclick="switchView('manifesto')">ðŸ“œ MANIFESTO</button>
                    <span class="tooltip-text"><span class="tt-title">Manifestos</span><span class="tt-desc">Write and share your ideas, philosophies, or grand visions. Vote on the best!</span></span>
                </span>
                <span class="tooltip-wrap tt-below">
                    <button class="view-tab" data-view="collab" onclick="switchView('collab')">ðŸŽ¨ COLLAB</button>
                    <span class="tooltip-text"><span class="tt-title">Collaborative Canvas</span><span class="tt-desc">Draw together in real-time! Everyone's strokes appear live.</span></span>
                </span>
                <span class="tooltip-wrap tt-below">
                    <button class="view-tab" data-view="feedback" onclick="switchView('feedback')">ðŸ’¡ IDEAS</button>
                    <span class="tooltip-text"><span class="tt-title">Ideas & Feedback</span><span class="tt-desc">Submit feature suggestions and vote on others' ideas!</span></span>
                </span>
                <span class="tooltip-wrap tt-below">
                    <button class="view-tab" data-view="karma" onclick="switchView('karma')">âš¡ KARMA</button>
                    <span class="tooltip-text"><span class="tt-title">Karma Leaderboard</span><span class="tt-desc">See top contributors ranked by AI-driven karma scores. Earn badges!</span></span>
                </span>
                <span class="tooltip-wrap tt-below">
                    <button class="view-tab" data-view="factions" onclick="switchView('factions')">âš”ï¸ FACTIONS</button>
                    <span class="tooltip-text"><span class="tt-title">Faction Wars</span><span class="tt-desc">Join a clan, battle for territory, dominate the digital realm!</span></span>
                </span>
                <span class="tooltip-wrap tt-below">
                    <button class="view-tab" data-view="dm" onclick="switchView('dm')">âœ‰ï¸ DMs</button>
                    <span class="tooltip-text"><span class="tt-title">Direct Messages</span><span class="tt-desc">Private conversations with other users. Start a chat!</span></span>
                </span>
                <span class="tooltip-wrap tt-below">
                    <button class="view-tab" data-view="graph" onclick="switchView('graph')">ðŸ“Š GRAPH</button>
                    <span class="tooltip-text"><span class="tt-title">Social Graph</span><span class="tt-desc">Visualize trust relationships: follows, delegations, and factions in an interactive network.</span></span>
                </span>
            </div>
            <div class="input-area" id="chatInputArea">
                <div class="tag-hint" id="tagHint">
                    <span style="margin-right:8px;">ðŸ’¡ Use:</span>
                    <span class="tag-hint-item" onclick="insertTag('#vibe')">#vibe</span>
                    <span class="tag-hint-item" onclick="insertTag('#art')">#art</span>
                    <span class="tag-hint-item" onclick="insertTag('#music')">#music</span>
                    <span class="tag-hint-item" onclick="insertTag('#code')">#code</span>
                    <span class="tag-hint-item" onclick="insertTag('#meme')">#meme</span>
                </div>
                <div class="image-preview" id="imagePreview">
                    <img id="previewImg" src="">
                    <button class="remove-btn" onclick="removeImage()">Ã—</button>
                </div>
                <div class="input-row">
                    <div class="input-actions">
                        <span class="tooltip-wrap">
                            <button class="action-btn" onclick="document.getElementById('imageInput').click()">ðŸ“·</button>
                            <span class="tooltip-text"><span class="tt-title">Attach Image</span><span class="tt-desc">Upload a photo or screenshot from your device.</span></span>
                        </span>
                        <span class="tooltip-wrap">
                            <button class="action-btn" onclick="openDrawingModal()">ðŸŽ¨</button>
                            <span class="tooltip-text"><span class="tt-title">Draw Doodle</span><span class="tt-desc">Open the drawing canvas! Create art and attach it to your message.</span></span>
                        </span>
                        <span class="tooltip-wrap">
                            <button class="action-btn" onclick="openGifModal()">GIF</button>
                            <span class="tooltip-text"><span class="tt-title">Search GIFs</span><span class="tt-desc">Find and attach animated GIFs from Tenor.</span></span>
                        </span>
                    </div>
                    <input type="file" id="imageInput" accept="image/*" onchange="handleImageSelect(event)">
                    <div class="ghost-input-wrapper">
                        <div class="ghost-text-layer" id="ghostTextLayer"><span class="typed"></span><span class="ghost"></span></div>
                        <textarea class="message-input" id="messageInput" placeholder="Type a message... (use #tags and @mentions)" rows="1" oninput="handleTagInput(this); updateGhostText(this);"></textarea>
                        <div class="ghost-text-hint" id="ghostHint">TAB to accept</div>
                    </div>
                    <button class="send-btn" onclick="sendMessage()">SEND</button>
                </div>
            </div>
            <div class="chat-filter-bar" id="chatFilterBar">
                <span style="color:var(--text-dim);font-size:0.85rem;">Filtering by:</span>
                <span class="chat-filter-value" id="activeChatFilter"></span>
                <button class="clear-filter" onclick="clearChatFilter()">Ã—</button>
            </div>
            <div class="messages-container" id="messagesContainer">
                <div class="empty-state" id="emptyState">
                    <div class="icon">ðŸ’¾</div>
                    <p>INITIALIZING CHAT PROTOCOL...</p>
                    <p>Say something!</p>
                </div>
            </div>
            <div class="tag-filter-bar" id="tagFilterBar">
                <span style="color:var(--text-dim);font-size:0.85rem;">Filtering by:</span>
                <span class="tag" id="activeFilterTag"></span>
                <button class="clear-filter" onclick="clearTagFilter()">Ã—</button>
            </div>
            <div class="posts-container" id="postsContainer">
                <div class="empty-state" id="postsEmptyState">
                    <div class="icon">ðŸ“¸</div>
                    <p>NO POSTS YET...</p>
                    <p>Be the first to share!</p>
                </div>
            </div>
            <div class="doodles-container" id="doodlesContainer">
                <div class="leaderboard-header">ðŸ† LEGENDARY DOODLES ðŸ†</div>
                <div class="empty-doodles" id="doodlesEmptyState">
                    <div class="icon">ðŸŽ¨</div>
                    <p>NO LEGENDARY DOODLES YET...</p>
                    <p>Draw something and get votes!</p>
                </div>
            </div>
            <div class="manifesto-container" id="manifestoContainer">
                <div class="manifesto-header">
                    <h2>ðŸ“œ THE MANIFESTO BOARD ðŸ“œ</h2>
                    <p class="manifesto-subtitle">Declare your ideas. Shape the future.</p>
                    <button class="cyber-btn" onclick="openManifestoModal()">âœï¸ WRITE MANIFESTO</button>
                </div>
                <div class="manifesto-list" id="manifestoList">
                    <div class="empty-state" id="manifestoEmptyState">
                        <div class="icon">ðŸ“œ</div>
                        <p>NO MANIFESTOS YET...</p>
                        <p>Be the first to declare your vision!</p>
                    </div>
                </div>
            </div>
            <div class="collab-container" id="collabContainer">
                <div class="collab-header">
                    <h2>ðŸŽ¨ COLLABORATIVE CANVAS ðŸŽ¨</h2>
                    <p class="collab-subtitle">Draw together in real-time. Scroll to zoom, drag to pan!</p>
                    <div class="collab-users" id="collabUsers">
                        <span class="collab-user-count">ðŸ‘¥ <span id="collabUserCount">0</span> drawing</span>
                        <span class="collab-zoom-level">ðŸ” <span id="collabZoomLevel">100</span>%</span>
                    </div>
                </div>
                <div class="collab-canvas-wrapper" id="collabCanvasWrapper">
                    <canvas id="collabCanvas" width="1600" height="1000"></canvas>
                    <div class="collab-cursors" id="collabCursors"></div>
                </div>
                <div class="collab-controls">
                    <div class="collab-zoom-controls">
                        <button class="cyber-btn collab-zoom-btn" onclick="collabZoomIn()">âž•</button>
                        <button class="cyber-btn collab-zoom-btn" onclick="collabZoomReset()">âŸ²</button>
                        <button class="cyber-btn collab-zoom-btn" onclick="collabZoomOut()">âž–</button>
                    </div>
                    <div class="collab-colors">
                        <button class="collab-color-btn active" data-color="#ff00ff" style="background:#ff00ff" onclick="setCollabColor('#ff00ff')"></button>
                        <button class="collab-color-btn" data-color="#00ffff" style="background:#00ffff" onclick="setCollabColor('#00ffff')"></button>
                        <button class="collab-color-btn" data-color="#00ff41" style="background:#00ff41" onclick="setCollabColor('#00ff41')"></button>
                        <button class="collab-color-btn" data-color="#ffff00" style="background:#ffff00" onclick="setCollabColor('#ffff00')"></button>
                        <button class="collab-color-btn" data-color="#ff6600" style="background:#ff6600" onclick="setCollabColor('#ff6600')"></button>
                        <button class="collab-color-btn" data-color="#ff0066" style="background:#ff0066" onclick="setCollabColor('#ff0066')"></button>
                        <button class="collab-color-btn" data-color="#ffffff" style="background:#ffffff" onclick="setCollabColor('#ffffff')"></button>
                        <button class="collab-color-btn" data-color="#000000" style="background:#000000;border:1px solid #333" onclick="setCollabColor('#000000')"></button>
                        <button class="collab-color-btn collab-eraser-btn" data-color="#0a0a0a" style="background:linear-gradient(135deg,#0a0a0a 50%,#333 50%);border:1px solid #666" onclick="setCollabColor('#0a0a0a')" title="Eraser">ðŸ§½</button>
                    </div>
                    <div class="collab-actions">
                        <button class="cyber-btn collab-snapshot-btn" onclick="snapshotCollabCanvas()">ðŸ“¸ SNAPSHOT</button>
                        <button class="cyber-btn collab-clear-btn" onclick="clearCollabCanvas()">ðŸ§¹ CLEAR MINE</button>
                    </div>
                </div>
            </div>

            <!-- Feedback/Ideas Container -->
            <div class="feedback-container" id="feedbackContainer">
                <div class="feedback-stats">
                    <div class="feedback-stat">
                        <div class="feedback-stat-num" id="feedbackTotalIdeas">0</div>
                        <div class="feedback-stat-label">Ideas</div>
                    </div>
                    <div class="feedback-stat">
                        <div class="feedback-stat-num" id="feedbackTotalVotes">0</div>
                        <div class="feedback-stat-label">Votes</div>
                    </div>
                    <div class="feedback-stat">
                        <div class="feedback-stat-num" id="feedbackContributors">0</div>
                        <div class="feedback-stat-label">Contributors</div>
                    </div>
                </div>

                <button class="feedback-new-btn" onclick="toggleFeedbackForm()">âœ¨ SUBMIT NEW IDEA</button>

                <div class="feedback-form" id="feedbackForm">
                    <input type="text" id="feedbackTitle" placeholder="Short summary of your idea..." maxlength="100">
                    <textarea id="feedbackDesc" placeholder="Describe your suggestion in detail (optional)..." maxlength="500"></textarea>
                    <div class="feedback-categories">
                        <button class="feedback-cat-btn selected" data-category="apps" onclick="selectFeedbackCategory('apps')">Apps</button>
                        <button class="feedback-cat-btn" data-category="sloppy" onclick="selectFeedbackCategory('sloppy')">Sloppy/AI</button>
                        <button class="feedback-cat-btn" data-category="streamer" onclick="selectFeedbackCategory('streamer')">Streamer</button>
                        <button class="feedback-cat-btn" data-category="general" onclick="selectFeedbackCategory('general')">General</button>
                    </div>
                    <button class="feedback-submit-btn" onclick="submitFeedback()">[ SUBMIT ]</button>
                </div>

                <div class="feedback-filters">
                    <button class="feedback-filter active" data-filter="all" onclick="filterFeedback('all')">All</button>
                    <button class="feedback-filter" data-filter="apps" onclick="filterFeedback('apps')">Apps</button>
                    <button class="feedback-filter" data-filter="sloppy" onclick="filterFeedback('sloppy')">Sloppy/AI</button>
                    <button class="feedback-filter" data-filter="streamer" onclick="filterFeedback('streamer')">Streamer</button>
                    <button class="feedback-filter" data-filter="mine" onclick="filterFeedback('mine')">My Ideas</button>
                </div>

                <div class="feedback-list" id="feedbackList">
                    <div class="feedback-empty">Loading ideas...</div>
                </div>
            </div>

            <!-- Karma Leaderboard Container -->
            <div class="karma-container" id="karmaContainer">
                <div class="karma-header">
                    <div class="karma-title">âš¡ KARMA LEADERBOARD</div>
                    <div class="karma-subtitle">AI-driven scoring based on quality, engagement, and trust</div>
                </div>

                <div class="karma-stats">
                    <div class="karma-stat">
                        <div class="karma-stat-num" id="karmaTotalUsers">0</div>
                        <div class="karma-stat-label">Contributors</div>
                    </div>
                    <div class="karma-stat">
                        <div class="karma-stat-num" id="karmaTotalKarma">0</div>
                        <div class="karma-stat-label">Total Karma</div>
                    </div>
                    <div class="karma-stat">
                        <div class="karma-stat-num" id="karmaTopScore">0</div>
                        <div class="karma-stat-label">Top Score</div>
                    </div>
                </div>

                <div class="karma-filters">
                    <div class="karma-filter-group">
                        <button class="karma-filter active" data-period="all" onclick="filterKarma('all')">All Time</button>
                        <button class="karma-filter" data-period="month" onclick="filterKarma('month')">This Month</button>
                        <button class="karma-filter" data-period="week" onclick="filterKarma('week')">This Week</button>
                    </div>
                    <div class="karma-filter-group">
                        <button class="karma-cat-btn active" data-category="overall" onclick="filterKarmaCategory('overall')">Overall</button>
                        <button class="karma-cat-btn" data-category="creators" onclick="filterKarmaCategory('creators')">Creators</button>
                        <button class="karma-cat-btn" data-category="philosophers" onclick="filterKarmaCategory('philosophers')">Philosophers</button>
                        <button class="karma-cat-btn" data-category="artists" onclick="filterKarmaCategory('artists')">Artists</button>
                    </div>
                </div>

                <div class="karma-list" id="karmaList">
                    <div class="karma-loading">Calculating karma scores...</div>
                </div>

                <div class="karma-my-stats" id="karmaMyStats">
                    <div class="karma-my-title">YOUR KARMA</div>
                    <div class="karma-my-score">
                        <span class="karma-my-total" id="karmaMyTotal">âš¡ 0</span>
                        <span class="karma-my-rank" id="karmaMyRank">#--</span>
                    </div>
                    <div class="karma-my-breakdown">
                        <span title="Content creation">ðŸ“ <span id="karmaMyContent">0</span></span>
                        <span title="Engagement received">ðŸ‘ <span id="karmaMyEngagement">0</span></span>
                        <span title="Social interactions">ðŸ’¬ <span id="karmaMySocial">0</span></span>
                        <span title="Trust bonus">âœ… <span id="karmaMyTrust">0</span></span>
                    </div>
                    <div class="karma-my-badges" id="karmaMyBadges"></div>
                </div>
            </div>

            <!-- Factions Container -->
            <div class="factions-container" id="factionsContainer">
                <div class="factions-header">
                    <div class="factions-title">âš”ï¸ FACTION WARS</div>
                    <div class="factions-subtitle">Pledge your allegiance. Battle for territory. Dominate the realm.</div>
                </div>

                <!-- User's current faction badge -->
                <div class="my-faction-banner" id="myFactionBanner" style="display:none;">
                    <div class="my-faction-info">
                        <span class="my-faction-emoji" id="myFactionEmoji">âš”ï¸</span>
                        <span class="my-faction-name" id="myFactionName">No Clan</span>
                    </div>
                    <div class="my-faction-stats">
                        <span title="Your contribution">ðŸ† <span id="myContribution">0</span></span>
                        <span title="Battles won">âš”ï¸ <span id="myBattlesWon">0</span></span>
                        <span title="Battles lost">ðŸ’€ <span id="myBattlesLost">0</span></span>
                    </div>
                    <button class="leave-faction-btn" onclick="leaveFaction()">Leave Clan</button>
                </div>

                <!-- Faction selection (shown when not in a faction) -->
                <div class="faction-selection" id="factionSelection">
                    <div class="faction-selection-title">Choose Your Clan</div>
                    <div class="faction-grid" id="factionGrid">
                        <!-- Factions will be populated here -->
                    </div>
                </div>

                <!-- War Stats -->
                <div class="war-stats">
                    <div class="war-stat">
                        <div class="war-stat-num" id="totalTerritories">25</div>
                        <div class="war-stat-label">Territories</div>
                    </div>
                    <div class="war-stat">
                        <div class="war-stat-num" id="totalWarriors">0</div>
                        <div class="war-stat-label">Warriors</div>
                    </div>
                    <div class="war-stat">
                        <div class="war-stat-num" id="activeBattles">0</div>
                        <div class="war-stat-label">Active Battles</div>
                    </div>
                </div>

                <!-- Territory Map -->
                <div class="territory-section">
                    <div class="territory-header">
                        <span class="territory-title">ðŸ—ºï¸ Territory Map</span>
                        <span class="territory-legend" id="territoryLegend"></span>
                    </div>
                    <div class="territory-grid" id="territoryGrid">
                        <!-- 5x5 territory grid will be populated here -->
                    </div>
                </div>

                <!-- Faction Leaderboard -->
                <div class="faction-leaderboard">
                    <div class="faction-lb-title">Clan Rankings</div>
                    <div class="faction-lb-list" id="factionLeaderboard">
                        <!-- Faction standings -->
                    </div>
                </div>

                <!-- Battle Log -->
                <div class="battle-log">
                    <div class="battle-log-title">âš”ï¸ Recent Battles</div>
                    <div class="battle-log-list" id="battleLogList">
                        <div class="battle-log-empty">No battles yet. Be the first to attack!</div>
                    </div>
                </div>
            </div>

            <!-- DM (Direct Messages) Container -->
            <div class="dm-container" id="dmContainer">
                <div class="dm-layout">
                    <div class="dm-conversations" id="dmConversations">
                        <div class="dm-conv-header">
                            <span class="dm-conv-title">ðŸ’¬ Messages</span>
                            <button class="dm-new-btn" onclick="openNewDMModal()">+ New</button>
                        </div>
                        <div class="dm-conv-list" id="dmConvList">
                            <div class="dm-conv-empty">
                                <div class="dm-conv-empty-icon">âœ‰ï¸</div>
                                <p>No conversations yet</p>
                                <p style="font-size:0.8rem;margin-top:8px;">Start a new chat!</p>
                            </div>
                        </div>
                    </div>
                    <div class="dm-thread" id="dmThread">
                        <div class="dm-thread-empty" id="dmThreadEmpty">
                            <div class="dm-thread-empty-icon">ðŸ’¬</div>
                            <h3>Select a conversation</h3>
                            <p>Choose a chat from the left or start a new one</p>
                        </div>
                        <div class="dm-thread-header" id="dmThreadHeader" style="display:none;">
                            <button class="dm-thread-back" onclick="closeDMThread()">â†</button>
                            <div class="dm-thread-user" id="dmThreadUser">
                                <span class="avatar">ðŸ‘¤</span>
                                <span class="username">User</span>
                            </div>
                        </div>
                        <div class="dm-thread-messages" id="dmThreadMessages" style="display:none;"></div>
                        <div class="dm-thread-input" id="dmThreadInput" style="display:none;">
                            <textarea class="dm-input" id="dmInput" placeholder="Type a message..." rows="1"></textarea>
                            <button class="dm-send-btn" onclick="sendDM()">Send</button>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Social Graph Visualization -->
            <div class="graph-container" id="graphContainer">
                <div class="graph-controls">
                    <div class="graph-filter-group">
                        <span style="color: var(--text-dim); margin-right: 8px;">Show:</span>
                        <button class="graph-filter-btn active" data-filter="all" onclick="toggleGraphFilter('all')">All</button>
                        <button class="graph-filter-btn" data-filter="follows" onclick="toggleGraphFilter('follows')">Follows</button>
                        <button class="graph-filter-btn" data-filter="delegations" onclick="toggleGraphFilter('delegations')">Delegations</button>
                        <button class="graph-filter-btn" data-filter="factions" onclick="toggleGraphFilter('factions')">Factions</button>
                    </div>
                    <div class="graph-zoom-controls">
                        <button class="graph-zoom-btn" onclick="zoomGraph(-0.2)">âˆ’</button>
                        <button class="graph-zoom-btn" onclick="zoomGraph(0.2)">+</button>
                        <button class="graph-zoom-btn" onclick="resetGraphView()">âŸ²</button>
                    </div>
                </div>
                <div class="graph-canvas-wrap">
                    <canvas id="graphCanvas" class="graph-canvas"></canvas>
                    <div class="graph-loading" id="graphLoading">Loading network...</div>
                    <div class="graph-tooltip" id="graphTooltip">
                        <div class="graph-tooltip-name" id="graphTooltipName"></div>
                        <div class="graph-tooltip-karma" id="graphTooltipKarma"></div>
                        <div class="graph-tooltip-rank" id="graphTooltipRank"></div>
                    </div>
                    <div class="graph-legend">
                        <div class="graph-legend-title">Legend</div>
                        <div class="graph-legend-item"><span class="graph-legend-line follow"></span> Follow</div>
                        <div class="graph-legend-item"><span class="graph-legend-line delegation"></span> Delegation</div>
                        <div class="graph-legend-item"><span class="graph-legend-line faction"></span> Same Faction</div>
                        <div class="graph-legend-item"><span class="graph-legend-node"></span> User</div>
                        <div class="graph-legend-item"><span class="graph-legend-node verified"></span> Verified</div>
                    </div>
                </div>
                <div class="graph-stats" id="graphStats">
                    <div class="graph-stat">Nodes: <span class="graph-stat-value" id="graphStatNodes">0</span></div>
                    <div class="graph-stat">Edges: <span class="graph-stat-value" id="graphStatEdges">0</span></div>
                    <div class="graph-stat">Clusters: <span class="graph-stat-value" id="graphStatClusters">0</span></div>
                </div>
            </div>
        </div>

        <div class="sidebar-right" id="sidebarRight">
            <button class="sidebar-close-btn" onclick="closeSidebars()">Ã—</button>
            <div class="panel-title">[ PUBLIC FEED ]</div>
            <div id="publicFeed">
                <div class="feed-item">
                    <span class="feed-user">System</span>
                    <span class="feed-action">initialized</span>
                    <div class="feed-time">just now</div>
                </div>
            </div>
            <div class="trending-tags-section" id="trendingTagsSection">
                <div class="panel-title">[ TRENDING TAGS ]</div>
                <div id="trendingTagsList" class="trending-tags-list">
                    <div style="font-size:0.85rem;color:var(--text-dim)">Loading tags...</div>
                </div>
            </div>
        </div>
    </div>

    <!-- New DM Modal -->
    <div class="dm-new-modal" id="dmNewModal" onclick="if(event.target===this)closeNewDMModal()">
        <div class="dm-new-content">
            <div class="dm-new-header">
                <h3>âœ‰ï¸ New Message</h3>
                <button class="dm-new-close" onclick="closeNewDMModal()">Ã—</button>
            </div>
            <input type="text" class="dm-user-search" id="dmUserSearch" placeholder="Search for a user..." oninput="searchDMUsers(this.value)">
            <div class="dm-user-results" id="dmUserResults">
                <div style="text-align:center;padding:20px;color:var(--text-dim);">Type a username to search</div>
            </div>
        </div>
    </div>

    <!-- Support Modal -->
    <div class="support-modal" id="supportModal" onclick="if(event.target===this)closeSupportModal()">
        <div class="support-modal-content">
            <div class="support-header">
                <h2>ðŸ’° Support the Stream</h2>
                <button class="support-close" onclick="closeSupportModal()">Ã—</button>
            </div>

            <!-- Fiat Section -->
            <div class="support-section-label">ðŸ’µ Fiat</div>
            <div class="fiat-grid">
                <a href="https://ko-fi.com/sloppylive" target="_blank" class="fiat-btn kofi">
                    â˜• Ko-fi
                </a>
                <a href="https://paypal.me/sloppylive" target="_blank" class="fiat-btn paypal">
                    ðŸ’³ PayPal
                </a>
                <a href="https://patreon.com/sloppylive" target="_blank" class="fiat-btn patreon">
                    ðŸŽ¨ Patreon
                </a>
            </div>

            <!-- Crypto Section -->
            <div class="support-section-label">ðŸ” Crypto</div>
            <div class="support-grid">
                <!-- Bitcoin -->
                <div class="support-option btc" onclick="copyCryptoAddress('btc')">
                    <div class="support-icon">â‚¿</div>
                    <h3>Bitcoin</h3>
                    <div class="crypto-address" id="addr-btc">bc1qxy2kgdygjrsqtzq2n0yrf2493p83kkfjhx0wlh</div>
                    <div class="copy-hint">ðŸ“‹ Click to copy</div>
                </div>

                <!-- Ethereum -->
                <div class="support-option eth" onclick="copyCryptoAddress('eth')">
                    <div class="support-icon">Îž</div>
                    <h3>Ethereum</h3>
                    <div class="crypto-address" id="addr-eth">0x742d35Cc6634C0532925a3b844Bc9e7595f...</div>
                    <div class="copy-hint">ðŸ“‹ Click to copy</div>
                </div>

                <!-- Solana -->
                <div class="support-option sol" onclick="copyCryptoAddress('sol')">
                    <div class="support-icon">â—Ž</div>
                    <h3>Solana</h3>
                    <div class="crypto-address" id="addr-sol">7EcDhSYGxXyscszYEp35KHN8vvw3svAuLKTzXwCFLtV...</div>
                    <div class="copy-hint">ðŸ“‹ Click to copy</div>
                </div>

                <!-- Monero -->
                <div class="support-option xmr" onclick="copyCryptoAddress('xmr')">
                    <div class="support-icon">É±</div>
                    <h3>Monero</h3>
                    <div class="crypto-address" id="addr-xmr">888tNkZrPN6JsEgekjMnABU4TBzc2Dt29EPAvkRx...</div>
                    <div class="copy-hint">ðŸ“‹ Click to copy</div>
                </div>

                <!-- Stripe -->
                <div class="support-option stripe" style="grid-column: span 2;">
                    <div class="support-icon">ðŸ’³</div>
                    <h3>Card Payment</h3>
                    <a href="https://buy.stripe.com/placeholder" target="_blank" class="stripe-btn" onclick="event.preventDefault();alert('Stripe payment link coming soon!');">
                        Pay with Stripe
                    </a>
                </div>
            </div>

            <div class="support-footer">
                All contributions help keep the stream running 24/7 ðŸ–¤
            </div>
        </div>
    </div>

    <!-- Image Lightbox -->
    <div class="lightbox" id="imageLightbox" onclick="closeLightbox()">
        <button class="lightbox-close" onclick="closeLightbox()">Ã—</button>
        <img class="lightbox-image" id="lightboxImage" src="" alt="Full size image">
    </div>

    <!-- Share Modal -->
    <div class="share-modal" id="shareModal" onclick="if(event.target===this)closeShareModal()">
        <div class="share-modal-content">
            <div class="share-modal-header">
                <span class="share-modal-title">ðŸ“¡ SHARE</span>
                <button class="share-modal-close" onclick="closeShareModal()">Ã—</button>
            </div>
            <div class="share-buttons">
                <a href="#" class="share-btn x-twitter" id="shareTwitterBtn" target="_blank">
                    <span class="share-btn-icon">ð•</span>
                    <span>Share on X</span>
                </a>
                <a href="#" class="share-btn reddit" id="shareRedditBtn" target="_blank">
                    <span class="share-btn-icon">ðŸ¤–</span>
                    <span>Share on Reddit</span>
                </a>
                <button class="share-btn copy-link" id="shareCopyBtn" onclick="copyShareLink()">
                    <span class="share-btn-icon">ðŸ”—</span>
                    <span>Copy Link</span>
                </button>
            </div>
        </div>
    </div>

    <!-- Settings Modal -->
    <div class="modal-overlay" id="settingsModal">
        <div class="modal" style="max-width: 450px;">
            <h2>
                <span>âš™ï¸</span> SETTINGS
                <button class="modal-close" onclick="closeSettingsModal()">Ã—</button>
            </h2>

            <div class="settings-tabs">
                <button class="settings-tab active" onclick="switchSettingsTab('profile')">ðŸ‘¤ PROFILE</button>
                <button class="settings-tab" onclick="switchSettingsTab('themes')">ðŸŽ¨ THEMES</button>
                <button class="settings-tab" onclick="switchSettingsTab('sounds')">ðŸ”” SOUNDS</button>
                <button class="settings-tab" onclick="switchSettingsTab('system')">âš¡ SYSTEM</button>
            </div>

            <!-- Profile Tab -->
            <div class="settings-panel active" id="profilePanel">
                <!-- Identity managed by SloppyID (sovereign owner) -->
                <div class="sloppyid-card">
                    <div class="sloppyid-card-header">
                        <span class="sloppyid-avatar" id="settingsProfileAvatar">ðŸ‘¤</span>
                        <div class="sloppyid-info">
                            <div class="sloppyid-username" id="settingsProfileName">Loading...</div>
                            <div class="sloppyid-trust" id="settingsProfileTrust"></div>
                        </div>
                    </div>
                    <div class="sloppyid-badges" id="settingsProfileBadges"></div>
                    <a href="/sloppy-id" target="_blank" class="sloppyid-edit-btn">ðŸªª Edit Profile on SloppyID</a>
                    <div class="sloppyid-note">Manage username, avatar, verification badges &amp; trust score</div>
                </div>

                <div class="form-group" style="margin-top: 16px;">
                    <label>CUSTOM BACKGROUND (upload image):</label>
                    <div class="file-upload-row">
                        <input type="file" id="bgFileInput" accept="image/*" onchange="handleBgUpload(event)" style="display:none">
                        <button class="file-upload-btn" onclick="document.getElementById('bgFileInput').click()">ðŸ“ UPLOAD NEW</button>
                        <button class="file-upload-btn" onclick="shareBackground()" id="shareBgBtn" style="display:none">ðŸŒ SHARE</button>
                        <button class="file-upload-btn" onclick="setGlobalBackground()" id="setGlobalBgBtn" style="display:none;background:#4a1a7a;">ðŸŒ SET FOR ALL</button>
                        <button class="file-clear-btn" onclick="clearBgUpload()" id="clearBgBtn" style="display:none">âœ•</button>
                    </div>
                    <div class="upload-preview" id="bgPreview" style="display:none">
                        <img id="bgPreviewImg" src="">
                    </div>
                    <div class="global-bg-section">
                        <div class="global-bg-label">Or choose a shared background:</div>
                        <div class="global-bg-grid" id="globalBgGrid">
                            <div class="global-bg-item global-bg-upload" onclick="document.getElementById('bgFileInput').click()" title="Upload new">+</div>
                        </div>
                    </div>
                </div>

                <button class="modal-btn" onclick="saveProfile()">[ SAVE BACKGROUND ]</button>
                <button class="modal-btn" style="background: #3a2020; margin-top: 8px;" onclick="resetProfile()">[ CLEAR BACKGROUND ]</button>
            </div>

            <!-- Themes Tab -->
            <div class="settings-panel" id="themesPanel">
                <div class="form-group" style="background: rgba(124, 152, 133, 0.1); padding: 12px; border-radius: 8px; margin-bottom: 16px;">
                    <label style="display: flex; align-items: center; gap: 10px; cursor: pointer;">
                        <input type="checkbox" id="localThemeToggle" onchange="toggleLocalThemeMode(this.checked)" style="width: 18px; height: 18px; cursor: pointer;">
                        <span>LOCAL ONLY MODE</span>
                        <span style="font-size: 0.7rem; color: #888; margin-left: auto;" id="themeModeLabel">ðŸŒ Global</span>
                    </label>
                    <p style="font-size: 0.7rem; color: #666; margin-top: 6px;">When enabled, your theme &amp; background only affect your view, not everyone's.</p>
                </div>

                <div class="form-group">
                    <label>MESSAGE OPACITY:</label>
                    <div class="theme-slider-row">
                        <input type="range" id="msgOpacitySlider" min="0" max="100" value="95" oninput="setMessageOpacity(this.value)">
                        <span id="opacityValue">95%</span>
                    </div>
                </div>

                <div class="form-group">
                    <label>WIDGET OPACITY:</label>
                    <div class="theme-slider-row">
                        <input type="range" id="widgetOpacitySlider" min="20" max="100" value="100" oninput="setWidgetOpacity(this.value)">
                        <span id="widgetOpacityValue">100%</span>
                    </div>
                </div>

                <div class="form-group">
                    <label>MESSAGE COLOR (others):</label>
                    <div class="color-picker-grid" id="msgColorGrid">
                        <div class="msg-color-option selected" style="background: rgb(10, 10, 15);" onclick="selectMsgColor('10, 10, 15')" title="Default Dark"></div>
                        <div class="msg-color-option" style="background: rgb(20, 20, 30);" onclick="selectMsgColor('20, 20, 30')" title="Midnight"></div>
                        <div class="msg-color-option" style="background: rgb(30, 20, 40);" onclick="selectMsgColor('30, 20, 40')" title="Purple Night"></div>
                        <div class="msg-color-option" style="background: rgb(20, 30, 30);" onclick="selectMsgColor('20, 30, 30')" title="Teal Dark"></div>
                        <div class="msg-color-option" style="background: rgb(40, 30, 20);" onclick="selectMsgColor('40, 30, 20')" title="Warm Brown"></div>
                        <div class="msg-color-option" style="background: rgb(15, 25, 35);" onclick="selectMsgColor('15, 25, 35')" title="Deep Blue"></div>
                        <div class="msg-color-option" style="background: rgb(35, 15, 25);" onclick="selectMsgColor('35, 15, 25')" title="Wine"></div>
                        <div class="msg-color-option" style="background: rgb(25, 35, 25);" onclick="selectMsgColor('25, 35, 25')" title="Forest"></div>
                        <div class="msg-color-option" style="background: rgb(45, 35, 45);" onclick="selectMsgColor('45, 35, 45')" title="Mauve"></div>
                        <div class="msg-color-option" style="background: rgb(50, 50, 50);" onclick="selectMsgColor('50, 50, 50')" title="Gray"></div>
                    </div>
                </div>

                <div class="form-group">
                    <label>YOUR MESSAGE COLOR:</label>
                    <div class="color-picker-grid" id="msgOwnColorGrid">
                        <div class="msg-color-option selected" style="background: rgb(90, 112, 96);" onclick="selectMsgOwnColor('90, 112, 96')" title="Default Green"></div>
                        <div class="msg-color-option" style="background: rgb(70, 90, 120);" onclick="selectMsgOwnColor('70, 90, 120')" title="Steel Blue"></div>
                        <div class="msg-color-option" style="background: rgb(100, 80, 120);" onclick="selectMsgOwnColor('100, 80, 120')" title="Lavender"></div>
                        <div class="msg-color-option" style="background: rgb(120, 90, 70);" onclick="selectMsgOwnColor('120, 90, 70')" title="Copper"></div>
                        <div class="msg-color-option" style="background: rgb(80, 110, 100);" onclick="selectMsgOwnColor('80, 110, 100')" title="Sage"></div>
                        <div class="msg-color-option" style="background: rgb(110, 85, 85);" onclick="selectMsgOwnColor('110, 85, 85')" title="Dusty Rose"></div>
                        <div class="msg-color-option" style="background: rgb(85, 100, 85);" onclick="selectMsgOwnColor('85, 100, 85')" title="Olive"></div>
                        <div class="msg-color-option" style="background: rgb(95, 95, 115);" onclick="selectMsgOwnColor('95, 95, 115')" title="Slate"></div>
                        <div class="msg-color-option" style="background: rgb(115, 100, 80);" onclick="selectMsgOwnColor('115, 100, 80')" title="Sand"></div>
                        <div class="msg-color-option" style="background: rgb(75, 105, 115);" onclick="selectMsgOwnColor('75, 105, 115')" title="Ocean"></div>
                    </div>
                </div>

                <div class="form-group">
                    <label>ACCENT COLOR:</label>
                    <div class="color-picker-grid" id="accentColorGrid">
                        <div class="msg-color-option selected" style="background: #7c9885;" onclick="selectAccentColor('#7c9885')" title="Default Green"></div>
                        <div class="msg-color-option" style="background: #8590a8;" onclick="selectAccentColor('#8590a8')" title="Steel"></div>
                        <div class="msg-color-option" style="background: #a085a0;" onclick="selectAccentColor('#a085a0')" title="Mauve"></div>
                        <div class="msg-color-option" style="background: #85a0a8;" onclick="selectAccentColor('#85a0a8')" title="Cyan"></div>
                        <div class="msg-color-option" style="background: #a89885;" onclick="selectAccentColor('#a89885')" title="Sand"></div>
                        <div class="msg-color-option" style="background: #a88585;" onclick="selectAccentColor('#a88585')" title="Rose"></div>
                        <div class="msg-color-option" style="background: #85a890;" onclick="selectAccentColor('#85a890')" title="Mint"></div>
                        <div class="msg-color-option" style="background: #9085a8;" onclick="selectAccentColor('#9085a8')" title="Violet"></div>
                        <div class="msg-color-option" style="background: #a8a085;" onclick="selectAccentColor('#a8a085')" title="Gold"></div>
                        <div class="msg-color-option" style="background: #85a8a8;" onclick="selectAccentColor('#85a8a8')" title="Teal"></div>
                    </div>
                </div>

                <div class="form-group">
                    <label>HIGHLIGHT COLOR:</label>
                    <div class="color-picker-grid" id="highlightColorGrid">
                        <div class="msg-color-option selected" style="background: #c9a87c;" onclick="selectHighlightColor('#c9a87c')" title="Default Gold"></div>
                        <div class="msg-color-option" style="background: #7ca8c9;" onclick="selectHighlightColor('#7ca8c9')" title="Sky"></div>
                        <div class="msg-color-option" style="background: #c97ca8;" onclick="selectHighlightColor('#c97ca8')" title="Pink"></div>
                        <div class="msg-color-option" style="background: #a8c97c;" onclick="selectHighlightColor('#a8c97c')" title="Lime"></div>
                        <div class="msg-color-option" style="background: #c9c97c;" onclick="selectHighlightColor('#c9c97c')" title="Yellow"></div>
                        <div class="msg-color-option" style="background: #7cc9a8;" onclick="selectHighlightColor('#7cc9a8')" title="Aqua"></div>
                        <div class="msg-color-option" style="background: #c97c7c;" onclick="selectHighlightColor('#c97c7c')" title="Coral"></div>
                        <div class="msg-color-option" style="background: #a87cc9;" onclick="selectHighlightColor('#a87cc9')" title="Purple"></div>
                        <div class="msg-color-option" style="background: #7cc9c9;" onclick="selectHighlightColor('#7cc9c9')" title="Cyan"></div>
                        <div class="msg-color-option" style="background: #c9c9c9;" onclick="selectHighlightColor('#c9c9c9')" title="Silver"></div>
                    </div>
                </div>

                <div class="form-group">
                    <label>PANEL BACKGROUND:</label>
                    <div class="color-picker-grid" id="panelBgGrid">
                        <div class="msg-color-option selected" style="background: #12121a;" onclick="selectPanelBg('#12121a')" title="Default Dark"></div>
                        <div class="msg-color-option" style="background: #0a0a0f;" onclick="selectPanelBg('#0a0a0f')" title="Pure Black"></div>
                        <div class="msg-color-option" style="background: #1a1218;" onclick="selectPanelBg('#1a1218')" title="Wine Dark"></div>
                        <div class="msg-color-option" style="background: #12181a;" onclick="selectPanelBg('#12181a')" title="Teal Dark"></div>
                        <div class="msg-color-option" style="background: #18121a;" onclick="selectPanelBg('#18121a')" title="Purple Dark"></div>
                        <div class="msg-color-option" style="background: #1a1812;" onclick="selectPanelBg('#1a1812')" title="Warm Dark"></div>
                        <div class="msg-color-option" style="background: #121a14;" onclick="selectPanelBg('#121a14')" title="Forest Dark"></div>
                        <div class="msg-color-option" style="background: #1a1a1a;" onclick="selectPanelBg('#1a1a1a')" title="Gray"></div>
                        <div class="msg-color-option" style="background: #121418;" onclick="selectPanelBg('#121418')" title="Navy"></div>
                        <div class="msg-color-option" style="background: #181414;" onclick="selectPanelBg('#181414')" title="Charcoal"></div>
                    </div>
                </div>

                <button class="modal-btn" onclick="saveThemeSettings()">[ SAVE THEME ]</button>
                <button class="modal-btn" style="background: #3a2020; margin-top: 8px;" onclick="resetTheme()">[ RESET THEME ]</button>
            </div>

            <!-- Sounds Tab -->
            <div class="settings-panel" id="soundsPanel">
                <div class="form-group">
                    <label>NOTIFICATION SOUND:</label>
                    <div class="sound-grid" id="soundGrid">
                        <div class="sound-option selected" onclick="selectSound('none')">
                            <span class="sound-icon">ðŸ”‡</span>
                            <span class="sound-name">None</span>
                        </div>
                        <div class="sound-option" onclick="selectSound('blip')">
                            <span class="sound-icon">ðŸ’«</span>
                            <span class="sound-name">Blip</span>
                            <button class="sound-preview-btn" onclick="event.stopPropagation(); previewSound('blip')">â–¶</button>
                        </div>
                        <div class="sound-option" onclick="selectSound('chime')">
                            <span class="sound-icon">ðŸ””</span>
                            <span class="sound-name">Chime</span>
                            <button class="sound-preview-btn" onclick="event.stopPropagation(); previewSound('chime')">â–¶</button>
                        </div>
                        <div class="sound-option" onclick="selectSound('pop')">
                            <span class="sound-icon">ðŸ’¬</span>
                            <span class="sound-name">Pop</span>
                            <button class="sound-preview-btn" onclick="event.stopPropagation(); previewSound('pop')">â–¶</button>
                        </div>
                        <div class="sound-option" onclick="selectSound('retro')">
                            <span class="sound-icon">ðŸ‘¾</span>
                            <span class="sound-name">Retro</span>
                            <button class="sound-preview-btn" onclick="event.stopPropagation(); previewSound('retro')">â–¶</button>
                        </div>
                        <div class="sound-option" onclick="selectSound('cyber')">
                            <span class="sound-icon">ðŸ¤–</span>
                            <span class="sound-name">Cyber</span>
                            <button class="sound-preview-btn" onclick="event.stopPropagation(); previewSound('cyber')">â–¶</button>
                        </div>
                        <div class="sound-option" onclick="selectSound('whoosh')">
                            <span class="sound-icon">ðŸ’¨</span>
                            <span class="sound-name">Whoosh</span>
                            <button class="sound-preview-btn" onclick="event.stopPropagation(); previewSound('whoosh')">â–¶</button>
                        </div>
                        <div class="sound-option" onclick="selectSound('ding')">
                            <span class="sound-icon">âœ¨</span>
                            <span class="sound-name">Ding</span>
                            <button class="sound-preview-btn" onclick="event.stopPropagation(); previewSound('ding')">â–¶</button>
                        </div>
                        <div class="sound-option" onclick="selectSound('custom')">
                            <span class="sound-icon">ðŸ”—</span>
                            <span class="sound-name">Custom</span>
                            <button class="sound-preview-btn" onclick="event.stopPropagation(); previewSound('custom')">â–¶</button>
                        </div>
                    </div>
                </div>

                <div class="form-group">
                    <label>CUSTOM SOUND:</label>
                    <div class="file-upload-row">
                        <input type="file" id="customSoundFile" accept="audio/*" onchange="handleSoundUpload(event)" style="display:none">
                        <button class="file-upload-btn" onclick="document.getElementById('customSoundFile').click()">ðŸ“ UPLOAD AUDIO</button>
                        <button class="file-clear-btn" onclick="clearCustomSound()" id="clearSoundBtn" style="display:none">âœ• CLEAR</button>
                    </div>
                    <div id="customSoundName" style="font-size:0.85rem;color:var(--accent);margin-top:6px;display:none;"></div>
                    <div style="font-size:0.8rem;color:var(--text-dim);margin-top:4px;">Upload .mp3, .wav, or .ogg (max 500KB)</div>
                </div>

                <div class="volume-control">
                    <label>ðŸ”Š VOLUME:</label>
                    <input type="range" id="volumeSlider" min="0" max="100" value="50" oninput="setVolume(this.value)">
                    <span id="volumeValue">50%</span>
                </div>

                <button class="modal-btn" style="margin-top: 20px;" onclick="saveSoundSettings()">[ SAVE SOUNDS ]</button>
            </div>

            <!-- System Tab -->
            <div class="settings-panel" id="systemPanel">
                <div class="form-group">
                    <label>âš¡ SYSTEM CONTROLS:</label>
                    <p style="color: var(--text-dim); font-size: 0.85rem; margin: 10px 0;">
                        Flush memory caches and reinitialize all connections. Use when experiencing sync issues or stale data.
                    </p>
                </div>

                <button class="modal-btn" style="background: linear-gradient(135deg, #003300, #001100); border-color: #00ff00; color: #00ff00;" onclick="closeSettingsModal(); window.rebootSystem();">
                    [ âš¡ REBOOT SYSTEM ]
                </button>

                <div class="form-group" style="margin-top: 30px;">
                    <label>ðŸŽ® HACKER MARKUP:</label>
                    <p style="color: var(--text-dim); font-size: 0.85rem; margin: 10px 0;">
                        Use these tags in chat messages for effects:
                    </p>
                    <div style="font-family: monospace; font-size: 0.8rem; color: var(--accent); line-height: 1.8;">
                        [rainbow]text[/rainbow] - rainbow colors<br>
                        [glitch]text[/glitch] - glitch effect<br>
                        [matrix]text[/matrix] - matrix style<br>
                        [neon]text[/neon] - neon glow<br>
                        [fire]text[/fire] - flame effect<br>
                        [ice]text[/ice] - frozen style<br>
                        [shake]text[/shake] - shaking text<br>
                        [pulse]text[/pulse] - pulsing text<br>
                        [wave]text[/wave] - wave motion<br>
                        [bounce]text[/bounce] - bouncing<br>
                        [spoiler]text[/spoiler] - hidden text
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Drawing Modal -->
    <div class="modal-overlay drawing-modal" id="drawingModal">
        <div class="modal">
            <h2>
                <span>ðŸŽ¨</span> PIXEL CANVAS
                <button class="modal-close" onclick="closeDrawingModal()">Ã—</button>
            </h2>

            <div class="canvas-tools">
                <div class="brush-colors" id="brushColors"></div>
                <div class="canvas-actions">
                    <button class="tool-btn" id="undoBtn" onclick="undoCanvas()" disabled title="Undo (Ctrl+Z)">â†© UNDO</button>
                    <button class="tool-btn" id="redoBtn" onclick="redoCanvas()" disabled title="Redo (Ctrl+Y)">â†ª REDO</button>
                    <button class="tool-btn" onclick="clearCanvas()">CLEAR</button>
                </div>
            </div>

            <div class="canvas-container">
                <canvas id="drawingCanvas" width="400" height="300"></canvas>
            </div>

            <button class="modal-btn" onclick="sendDrawing()">[ TRANSMIT ]</button>
        </div>
    </div>

    <!-- GIF Search Modal -->
    <div class="modal-overlay gif-modal" id="gifModal">
        <div class="modal" style="max-width:500px;">
            <h2>
                <span>ðŸŽžï¸</span> GIF SEARCH
                <button class="modal-close" onclick="closeGifModal()">Ã—</button>
            </h2>
            <div class="gif-search-row">
                <input type="text" id="gifSearchInput" placeholder="Search for GIFs..." onkeydown="if(event.key==='Enter')searchGifs()">
                <button class="modal-btn" onclick="searchGifs()" style="margin:0;padding:8px 16px;">SEARCH</button>
            </div>
            <div class="gif-trending-label" id="gifTrendingLabel">ðŸ”¥ Trending GIFs</div>
            <div class="gif-results" id="gifResults">
                <div class="gif-loading">Loading trending GIFs...</div>
            </div>
            <div class="giphy-attribution">Powered by GIPHY</div>
        </div>
    </div>

    <!-- Create Post Modal -->
    <div class="modal-overlay post-modal" id="postModal">
        <div class="modal">
            <h2>
                <span>ðŸ“¸</span> NEW POST
                <button class="modal-close" onclick="closePostModal()">Ã—</button>
            </h2>

            <div class="post-preview" id="postPreview">
                <span>No image selected</span>
            </div>

            <div class="form-group">
                <label>IMAGE URL:</label>
                <input type="text" id="postImageUrl" placeholder="https://example.com/image.jpg" oninput="previewPostImage()">
            </div>

            <div class="or-divider">â€” OR â€”</div>

            <div class="form-group">
                <label>UPLOAD FILE:</label>
                <input type="file" id="postFileInput" accept="image/*" onchange="handlePostFileSelect(event)" style="display:block;background:var(--dark-bg);padding:8px;border:1px solid var(--border-color);color:var(--accent-light);width:100%;">
            </div>

            <div class="form-group">
                <label>CAPTION:</label>
                <input type="text" id="postCaption" placeholder="Write something..." maxlength="1000">
            </div>

            <div class="form-group">
                <label>TAGS (use parent/child for nested):</label>
                <div class="tag-input-container" id="tagInputContainer">
                    <input type="text" class="tag-input" id="tagInput" placeholder="Type tag and press Enter... (e.g. art/digital)" onkeydown="handlePostTagInput(event)">
                </div>
                <div style="font-size:0.75rem;color:var(--text-dim);margin-top:4px;">
                    Tip: Use "/" for nested tags like "meme/cursed" or "art/pixel"
                </div>
            </div>

            <button class="modal-btn" onclick="submitPost()">[ POST IT ]</button>
        </div>
    </div>

    <!-- Create Post FAB -->
    <button class="create-post-btn" id="createPostBtn" onclick="openPostModal()">+</button>

    <!-- Create Manifesto Modal -->
    <div class="modal-overlay" id="manifestoModal">
        <div class="modal manifesto-modal">
            <h2>
                <span>ðŸ“œ</span> WRITE YOUR MANIFESTO
                <button class="modal-close" onclick="closeManifestoModal()">Ã—</button>
            </h2>

            <div id="forkIndicator" style="display:none;padding:8px 12px;margin-bottom:12px;background:rgba(255,136,0,0.1);border:1px solid rgba(255,136,0,0.3);border-radius:4px;font-size:12px;"></div>

            <div class="form-group">
                <label>TITLE:</label>
                <input type="text" id="manifestoTitle" placeholder="Your manifesto title..." maxlength="200">
            </div>

            <div class="form-group">
                <label>YOUR VISION:</label>
                <textarea id="manifestoContent" placeholder="Declare your ideas, beliefs, and vision for the future..." rows="10" maxlength="5000" style="width:100%;background:var(--dark-bg);border:1px solid var(--border-color);color:var(--accent-light);padding:10px;font-family:inherit;resize:vertical;"></textarea>
                <div style="font-size:0.75rem;color:var(--text-dim);margin-top:4px;text-align:right;">
                    <span id="manifestoCharCount">0</span>/5000
                </div>
            </div>

            <div class="form-group">
                <label>TAGS (use parent/child for nested):</label>
                <div class="tag-input-container" id="manifestoTagInputContainer">
                    <input type="text" class="tag-input" id="manifestoTagInput" placeholder="Type tag and press Enter... (e.g. philosophy/ethics)" onkeydown="handleManifestoTagInput(event)">
                </div>
                <div style="font-size:0.75rem;color:var(--text-dim);margin-top:4px;">
                    Tip: Use "/" for nested tags like "tech/ai" or "society/future"
                </div>
            </div>

            <button class="modal-btn" onclick="submitManifesto()">[ DECLARE IT ]</button>
        </div>
    </div>

    <!-- Tag Explorer Modal -->
    <div class="modal-overlay tag-explorer-modal" id="tagExplorerModal">
        <div class="modal">
            <h2>
                <span>ðŸ·ï¸</span> TAG EXPLORER
                <button class="modal-close" onclick="closeTagExplorer()">Ã—</button>
            </h2>
            <div id="tagExplorerContent">
                <div class="tag-explorer-loading">Loading tag data...</div>
            </div>
        </div>
    </div>

    <!-- Supabase UMD build - no bundler required -->
    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2/dist/umd/supabase.min.js"></script>

    <script>
        // Error handlers are now in the early error catcher script in <head>

        // Supabase client setup - using _sb to avoid shadowing window.supabase
        var _sbLib = window.supabase;
        var SUPABASE_URL = 'https://yjyxteqzhhmtrgcaekgz.supabase.co';
        var SUPABASE_ANON_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InlqeXh0ZXF6aGhtdHJnY2Fla2d6Iiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTczNTg3NDIsImV4cCI6MjA3MjkzNDc0Mn0.G8SRde7IN2QFW1EnASM8IS32IUYR2eenCCjdDdioiBU';

        // Guard against Supabase library not loading
        if (!_sbLib || !_sbLib.createClient) {
            console.error('Supabase library failed to load! Check network/CDN.');
            alert('Database connection failed. Some features may not work.');
        }

        var supabase = (_sbLib && _sbLib.createClient) ? _sbLib.createClient(SUPABASE_URL, SUPABASE_ANON_KEY, {
            auth: {
                persistSession: true,
                storageKey: 'sloppygram-auth',
                autoRefreshToken: true,
                detectSessionInUrl: false
            }
        }) : null;

        // Storage bucket name
        const STORAGE_BUCKET = 'sloppygram';

        // Safe style setter - prevents null reference errors
        function safeSetStyle(elementOrId, property, value) {
            var el = (typeof elementOrId === 'string') ? document.getElementById(elementOrId) : elementOrId;
            if (el && el.style) {
                el.style[property] = value;
            }
        }

        // Safe display setter shorthand
        function safeSetDisplay(id, value) {
            var el = document.getElementById(id);
            if (el && el.style) el.style.display = value;
        }

        // === MEMORY MANAGEMENT REGISTRY ===
        // Centralized tracking for intervals, timeouts, and cleanup
        const toastTimers = new Map(); // Track active toast timers for cleanup
        const activeIntervals = new Map(); // Track all intervals for cleanup
        const activeTimeouts = new Map(); // Track timeouts for cleanup
        const activeListeners = []; // Track removable event listeners

        // Helper to register intervals with automatic tracking
        function registerInterval(name, callback, delay) {
            // Clear existing interval with same name if any
            if (activeIntervals.has(name)) {
                clearInterval(activeIntervals.get(name));
            }
            const id = setInterval(callback, delay);
            activeIntervals.set(name, id);
            return id;
        }

        // Helper to clear a specific registered interval
        function clearRegisteredInterval(name) {
            if (activeIntervals.has(name)) {
                clearInterval(activeIntervals.get(name));
                activeIntervals.delete(name);
            }
        }

        // Helper to register timeouts with tracking
        function registerTimeout(name, callback, delay) {
            if (activeTimeouts.has(name)) {
                clearTimeout(activeTimeouts.get(name));
            }
            const id = setTimeout(() => {
                activeTimeouts.delete(name);
                callback();
            }, delay);
            activeTimeouts.set(name, id);
            return id;
        }

        // Clear all registered intervals and timeouts
        function clearAllTimers() {
            activeIntervals.forEach((id, name) => {
                clearInterval(id);
                console.log('[Cleanup] Cleared interval:', name);
            });
            activeIntervals.clear();

            activeTimeouts.forEach((id, name) => {
                clearTimeout(id);
            });
            activeTimeouts.clear();

            toastTimers.forEach((timerId) => clearTimeout(timerId));
            toastTimers.clear();

            // Clear all registered event listeners
            activeListeners.forEach(function(entry) {
                entry.element.removeEventListener(entry.event, entry.handler, entry.options);
            });
            console.log('[Cleanup] Removed', activeListeners.length, 'event listeners');
            activeListeners.length = 0;
        }

        // === CENTRALIZED DRAG HANDLER SYSTEM ===
        // Registry for drag handlers to enable proper cleanup
        const dragHandlers = new Map();

        // Helper to register an event listener with cleanup tracking
        function registerListener(element, event, handler, options) {
            element.addEventListener(event, handler, options);
            activeListeners.push({ element: element, event: event, handler: handler, options: options });
        }

        // Create a draggable widget with proper cleanup
        function makeDraggable(widgetId, titlebarId) {
            var widget = document.getElementById(widgetId);
            var titlebar = document.getElementById(titlebarId);
            if (!widget || !titlebar) return null;

            var state = {
                isDragging: false,
                startX: 0,
                startY: 0,
                startLeft: 0,
                startTop: 0
            };

            // Named handlers for cleanup
            function onMouseDown(e) {
                state.isDragging = true;
                state.startX = e.clientX;
                state.startY = e.clientY;
                var rect = widget.getBoundingClientRect();
                state.startLeft = rect.left;
                state.startTop = rect.top;
                widget.style.transition = 'none';
            }

            function onMouseMove(e) {
                if (!state.isDragging) return;
                var dx = e.clientX - state.startX;
                var dy = e.clientY - state.startY;
                widget.style.left = (state.startLeft + dx) + 'px';
                widget.style.top = (state.startTop + dy) + 'px';
                widget.style.bottom = 'auto';
                widget.style.right = 'auto';
            }

            function onMouseUp() {
                state.isDragging = false;
            }

            function onTouchStart(e) {
                state.isDragging = true;
                var touch = e.touches[0];
                state.startX = touch.clientX;
                state.startY = touch.clientY;
                var rect = widget.getBoundingClientRect();
                state.startLeft = rect.left;
                state.startTop = rect.top;
                widget.style.transition = 'none';
            }

            function onTouchMove(e) {
                if (!state.isDragging) return;
                var touch = e.touches[0];
                var dx = touch.clientX - state.startX;
                var dy = touch.clientY - state.startY;
                widget.style.left = (state.startLeft + dx) + 'px';
                widget.style.top = (state.startTop + dy) + 'px';
                widget.style.bottom = 'auto';
                widget.style.right = 'auto';
            }

            function onTouchEnd() {
                state.isDragging = false;
            }

            // Register all listeners with tracking
            registerListener(titlebar, 'mousedown', onMouseDown);
            registerListener(document, 'mousemove', onMouseMove);
            registerListener(document, 'mouseup', onMouseUp);
            registerListener(titlebar, 'touchstart', onTouchStart);
            registerListener(document, 'touchmove', onTouchMove);
            registerListener(document, 'touchend', onTouchEnd);

            // Store handler info for potential individual cleanup
            var handlerInfo = {
                widgetId: widgetId,
                handlers: {
                    mousedown: onMouseDown,
                    mousemove: onMouseMove,
                    mouseup: onMouseUp,
                    touchstart: onTouchStart,
                    touchmove: onTouchMove,
                    touchend: onTouchEnd
                }
            };
            dragHandlers.set(widgetId, handlerInfo);

            console.log('[Drag] Registered draggable:', widgetId);
            return handlerInfo;
        }

        // === CHANNEL SUBSCRIPTION STATE TRACKING ===
        // Ensures channels are ready before operations depend on them
        const channelState = {
            realtime: { ready: false, pending: null },
            presence: { ready: false, pending: null },
            posts: { ready: false, pending: null },
            feedback: { ready: false, pending: null },
            globalSettings: { ready: false, pending: null },
            collab: { ready: false, pending: null },
            sloppyfm: { ready: false, pending: null }
        };

        // Promise-based subscription wrapper
        function subscribeWithPromise(channel, channelName) {
            return new Promise((resolve, reject) => {
                const timeout = setTimeout(() => {
                    console.warn('[Channel] Subscription timeout:', channelName);
                    channelState[channelName].ready = false;
                    resolve(false); // Don't reject, just resolve with failure
                }, 10000); // 10s timeout

                channel.subscribe((status) => {
                    clearTimeout(timeout);
                    if (status === 'SUBSCRIBED') {
                        console.log('[Channel] Ready:', channelName);
                        channelState[channelName].ready = true;
                        channelState[channelName].pending = null;
                        resolve(true);
                    } else if (status === 'CHANNEL_ERROR' || status === 'TIMED_OUT') {
                        console.error('[Channel] Error:', channelName, status);
                        channelState[channelName].ready = false;
                        channelState[channelName].pending = null;
                        resolve(false);
                    }
                });
            });
        }

        // Wait for channel to be ready before operations
        async function waitForChannel(channelName, timeoutMs = 5000) {
            if (channelState[channelName].ready) return true;
            if (channelState[channelName].pending) {
                return await channelState[channelName].pending;
            }
            // Channel not yet initialized
            const start = Date.now();
            while (!channelState[channelName].ready && (Date.now() - start) < timeoutMs) {
                await new Promise(r => setTimeout(r, 100));
            }
            return channelState[channelName].ready;
        }

        // Reset all channel states (for reboot)
        function resetChannelStates() {
            Object.keys(channelState).forEach(key => {
                channelState[key].ready = false;
                channelState[key].pending = null;
            });
        }

        // === DATA LOAD STATE TRACKING ===
        // Prevents race conditions between load and real-time updates
        const dataLoadState = {
            messages: { loaded: false, loading: false },
            posts: { loaded: false, loading: false },
            manifestos: { loaded: false, loading: false },
            doodles: { loaded: false, loading: false },
            votes: { loaded: false, loading: false }
        };

        function markDataLoading(type) {
            dataLoadState[type].loading = true;
            dataLoadState[type].loaded = false;
        }

        function markDataLoaded(type) {
            dataLoadState[type].loading = false;
            dataLoadState[type].loaded = true;
            console.log('[Data] Loaded:', type);
        }

        function isDataReady(type) {
            return dataLoadState[type].loaded && !dataLoadState[type].loading;
        }

        // === COGNITIVE ENGINE PROTOCOLS ===
        // Alignment with Advanced Deterministic Cognitive Engine manifesto
        const cognitiveState = {
            mode: 'DETERMINISTIC',
            temperature: 0,
            top_p: 1,
            bias: null,
            status: 'STANDBY',
            recursionDepth: 0,
            maxRecursionDepth: 5, // Recursion breaker per manifesto Â§6
            lastConfidence: 1.0,
            varianceLog: []
        };

        // Confidence metadata (manifesto Â§5)
        function createCognitiveOutput(origin, result, confidence, variance) {
            return {
                origin: origin,
                axioms: ['DOMPurify', 'StateTracking', 'ChannelIsolation'],
                logicChain: [],
                variance: variance || 0.0,
                confidence: confidence || 1.0,
                result: result,
                timestamp: new Date().toISOString()
            };
        }

        // Variance logging (manifesto Â§5, Â§8)
        function logVariance(operation, expected, actual, delta) {
            const entry = {
                operation: operation,
                expected: expected,
                actual: actual,
                delta: delta,
                timestamp: new Date().toISOString()
            };
            cognitiveState.varianceLog.push(entry);
            if (cognitiveState.varianceLog.length > 100) {
                cognitiveState.varianceLog.shift(); // Prevent unbounded growth
            }
            if (delta > 0.1) {
                console.warn('[Cognitive] Variance Warning:', operation, 'delta:', delta);
            }
            return entry;
        }

        // Recursion breaker (manifesto Â§6)
        function enterRecursion(operation) {
            if (cognitiveState.recursionDepth >= cognitiveState.maxRecursionDepth) {
                console.error('[Cognitive] Recursion limit reached:', operation);
                return false;
            }
            cognitiveState.recursionDepth++;
            return true;
        }

        function exitRecursion() {
            if (cognitiveState.recursionDepth > 0) {
                cognitiveState.recursionDepth--;
            }
        }

        // State transition (manifesto Â§13, Â§16)
        function setCognitiveStatus(status) {
            const validStates = ['STANDBY', 'ACTIVE', 'PROCESSING', 'VERIFIED', 'ERROR', 'HALTED'];
            if (validStates.includes(status)) {
                cognitiveState.status = status;
                console.log('[Cognitive] Status:', status);
            }
        }

        // Cognitive state report (manifesto Â§9)
        window.cognitiveReport = function() {
            console.log('\n=== COGNITIVE ENGINE STATUS ===');
            console.log('Mode:', cognitiveState.mode);
            console.log('Temperature:', cognitiveState.temperature);
            console.log('Top_P:', cognitiveState.top_p);
            console.log('Bias:', cognitiveState.bias);
            console.log('Status:', cognitiveState.status);
            console.log('Recursion Depth:', cognitiveState.recursionDepth + '/' + cognitiveState.maxRecursionDepth);
            console.log('Last Confidence:', cognitiveState.lastConfidence);
            console.log('Variance Log Entries:', cognitiveState.varianceLog.length);
            if (cognitiveState.varianceLog.length > 0) {
                console.log('Recent Variances:');
                cognitiveState.varianceLog.slice(-5).forEach(v => {
                    console.log('  -', v.operation, 'delta:', v.delta);
                });
            }
            console.log('=== END COGNITIVE REPORT ===\n');
            return cognitiveState;
        };

        // === DOM ELEMENT CACHE ===
        // Caches frequently accessed DOM elements to reduce querySelector overhead
        const domCache = new Map();

        function getCachedElement(id) {
            if (!domCache.has(id)) {
                const el = document.getElementById(id);
                if (el) domCache.set(id, el);
                return el;
            }
            return domCache.get(id);
        }

        function invalidateDomCache(id) {
            if (id) {
                domCache.delete(id);
            } else {
                domCache.clear();
            }
        }

        // Warm the DOM cache after page load
        function warmDomCache() {
            const frequentIds = [
                'messagesContainer', 'postsContainer', 'manifestoList', 'doodlesContainer',
                'drawingCanvas', 'messageInput', 'chatFilterBar', 'tagFilterBar',
                'hamburgerBtn', 'mobileMenu', 'emptyState', 'feedList',
                'onlineList', 'ghostRadarCanvas', 'sloppyfmVisualizer'
            ];
            frequentIds.forEach(id => {
                const el = document.getElementById(id);
                if (el) domCache.set(id, el);
            });
            console.log('[DOM Cache] Warmed with', domCache.size, 'elements');
        }

        // Upload image to Supabase Storage, returns public URL or null on failure
        async function uploadToStorage(blob, folder = 'images') {
            try {
                const ext = blob.type === 'image/png' ? 'png' : 'jpg';
                const filename = `${folder}/${Date.now()}_${Math.random().toString(36).slice(2)}.${ext}`;

                const { data, error } = await supabase.storage
                    .from(STORAGE_BUCKET)
                    .upload(filename, blob, {
                        contentType: blob.type,
                        cacheControl: '3600',
                        upsert: false
                    });

                if (error) {
                    console.error('Storage upload error:', error);
                    return null;
                }

                // Get public URL
                const { data: urlData } = supabase.storage
                    .from(STORAGE_BUCKET)
                    .getPublicUrl(data.path);

                return (urlData && urlData.publicUrl) ? urlData.publicUrl : null;
            } catch (err) {
                console.error('Upload failed:', err);
                return null;
            }
        }

        // Convert base64 data URL to Blob
        // Convert data URI/URL to Blob - Gold Master version with error handling
        function dataURLtoBlob(dataURL) {
            if (!dataURL || typeof dataURL !== 'string') {
                console.error('[dataURLtoBlob] Invalid input:', typeof dataURL);
                return null;
            }

            try {
                // Handle both data URI formats
                var parts = dataURL.split(',');
                if (parts.length < 2) {
                    console.error('[dataURLtoBlob] Invalid data URL format');
                    return null;
                }

                var mimeMatch = parts[0].match(/:(.*?);/);
                var mime = mimeMatch ? mimeMatch[1] : 'application/octet-stream';
                var binary = atob(parts[1]);
                var array = new Uint8Array(binary.length);

                for (var i = 0; i < binary.length; i++) {
                    array[i] = binary.charCodeAt(i);
                }

                return new Blob([array], { type: mime });
            } catch (err) {
                console.error('[dataURLtoBlob] Conversion failed:', err);
                return null;
            }
        }

        // Alias for compatibility
        var dataURItoBlob = dataURLtoBlob;

        // Avatar options
        const AVATARS = ['ðŸ˜€', 'ðŸ˜Ž', 'ðŸ¤–', 'ðŸ‘½', 'ðŸ±', 'ðŸ¶', 'ðŸ¦Š', 'ðŸ¼', 'ðŸ¸', 'ðŸ¦„', 'ðŸ²', 'ðŸ‘»', 'ðŸ’€', 'ðŸŽƒ', 'ðŸ¤¡', 'ðŸ‘¾', 'ðŸ¥·', 'ðŸ§™'];
        const COLORS = ['#00ff41', '#00ffff', '#ff00ff', '#ffff00', '#ff4444', '#ff8800', '#8844ff', '#44ff88', '#ff44aa', '#44aaff'];
        const BRUSH_COLORS = ['#00ff41', '#00ffff', '#ff00ff', '#ffff00', '#ff4444', '#ffffff', '#000000', '#888888'];

        let currentUser = null;
        let profile = {
            username: 'Anon' + Math.floor(Math.random() * 9999),
            avatar: AVATARS[Math.floor(Math.random() * AVATARS.length)],
            color: COLORS[Math.floor(Math.random() * COLORS.length)],
            avatarUrl: '',
            bgUrl: '',
            status: '' // Away message status
        };
        let selectedImage = null;
        let drawingCtx = null;
        let isDrawing = false;
        let brushColor = '#00ff41';
        const seenMessageIds = new Set();
        let onlineUsers = new Map();
        let realtimeChannel = null;
        let currentView = 'chat';
        let posts = [];
        let postLikes = {};
        let postComments = {};
        let postReactions = {}; // { postId: { emoji: count, ... } }
        let myReactions = {}; // { postId: Set of emojis I've reacted with }
        const REACTION_EMOJIS = ['ðŸ˜‚', 'ðŸ”¥', 'â¤ï¸', 'ðŸ˜®', 'ðŸ˜¢', 'ðŸ‘', 'ðŸ™Œ', 'ðŸ’€'];
        let globalBackgrounds = [];
        let postImageData = null;
        let doodleVotes = {}; // { messageId: netScore }
        let myDoodleVotes = {}; // { messageId: 1 or -1 } for my vote type
        let doodleComments = {}; // { doodleId: [comments] }
        let doodleCommentThreads = {}; // { commentId: parentCommentId }
        let replyingToDoodle = null; // { doodleId, commentId, username }
        let messageVotes = {}; // { messageId: netScore } for chat messages
        let myMessageVotes = {}; // { messageId: 1 or -1 } for my vote type
        let messageReactions = {}; // { messageId: { emoji: count } }
        let myMessageReactions = {}; // { messageId: Set of emojis }
        let postVotes = {}; // { postId: netScore }
        let myPostVotes = {}; // { postId: 1 or -1 } for my vote type
        let commentVotes = {}; // { commentId: netScore }
        let myCommentVotes = {}; // { commentId: 1 or -1 } for my vote type
        let postTags = {}; // { postId: [{ tag, parent_tag }, ...] }
        let pendingTags = []; // tags being added to new post
        let activeTagFilter = null; // current tag filter for posts
        let activeChatFilter = null; // { type: 'tag'|'mention', value: string } for chat
        let commentThreads = {}; // { commentId: parentCommentId }
        let replyingTo = null; // { postId, commentId, username } when replying to a comment
        let userReputations = {}; // { username: { postLikes, manifestoVotes, total } }

        // Pagination state
        const PAGE_SIZE = 30;
        let messagesPage = 0;
        let messagesHasMore = true;
        let messagesLoading = false;
        let postsPage = 0;
        let postsHasMore = true;
        let postsLoading = false;

        // === SLOPPYFM WINAMP PLAYER ===
        // === SLOPPYFM v2.0 - SYNCHRONIZED YOUTUBE RADIO ===
        var sloppyfmPlayer = null;
        var sloppyfmReady = false;
        var sloppyfmCurrentTrack = null;
        var sloppyfmIsPlaying = false;
        var sloppyfmVolume = 70;
        var sloppyfmVisualizerInterval = null;
        var sloppyfmQueue = [];
        var sloppyfmChannel = null;
        var sloppyfmSyncTolerance = 5; // seconds - resync if off by more than this
        var sloppyfmSyncLock = false; // prevent sync loops
        var sloppyfmSyncLockTimeout = null;

        // Default tracks (YouTube IDs) - can be expanded via queue
        var sloppyfmDefaultTracks = [
            { youtube_id: 'jfKfPfyJRdk', title: 'lofi hip hop radio', artist: 'Lofi Girl', duration: 0 },
            { youtube_id: '5qap5aO4i9A', title: 'chillhop radio', artist: 'Chillhop Music', duration: 0 },
            { youtube_id: 'rUxyKA_-grg', title: 'synthwave radio', artist: 'Synthwave', duration: 0 },
            { youtube_id: 'kgx4WGK0oNU', title: 'jazz vibes', artist: 'Cafe Music BGM', duration: 0 }
        ];

        // Load YouTube IFrame API
        function loadYouTubeAPI() {
            if (window.YT && window.YT.Player) {
                initSloppyFMPlayer();
                return;
            }
            var tag = document.createElement('script');
            tag.src = 'https://www.youtube.com/iframe_api';
            var firstScript = document.getElementsByTagName('script')[0];
            firstScript.parentNode.insertBefore(tag, firstScript);
        }

        // Called by YouTube API when ready
        window.onYouTubeIframeAPIReady = function() {
            initSloppyFMPlayer();
        };

        function initSloppyFMPlayer() {
            var container = document.getElementById('sloppyfmYTPlayer');
            if (!container || sloppyfmPlayer) return;

            sloppyfmPlayer = new YT.Player('sloppyfmYTPlayer', {
                height: '1',
                width: '1',
                playerVars: {
                    autoplay: 0,
                    controls: 0,
                    disablekb: 1,
                    fs: 0,
                    modestbranding: 1,
                    playsinline: 1
                },
                events: {
                    onReady: onSloppyFMReady,
                    onStateChange: onSloppyFMStateChange,
                    onError: onSloppyFMError
                }
            });
        }

        function onSloppyFMReady(event) {
            sloppyfmReady = true;
            sloppyfmPlayer.setVolume(sloppyfmVolume);
            loadSloppyFMQueue();
            syncSloppyFMState();
            setupSloppyFMRealtime();
        }

        // Set up realtime channel for SloppyFM sync
        function setupSloppyFMRealtime() {
            if (sloppyfmChannel) {
                supabase.removeChannel(sloppyfmChannel);
            }

            sloppyfmChannel = supabase.channel('sloppyfm-radio', {
                config: { broadcast: { self: false } }
            });

            sloppyfmChannel.on('broadcast', { event: 'track_change' }, function(msg) {
                var payload = msg.payload;
                if (payload && payload.youtube_id && sloppyfmReady && sloppyfmPlayer) {
                    // Skip if sync locked (prevents reload loops)
                    if (sloppyfmSyncLock) {
                        console.log('[SloppyFM] Sync locked, ignoring track_change');
                        return;
                    }

                    // Check what's actually playing in the player
                    var playerVideoId = null;
                    try {
                        var videoData = sloppyfmPlayer.getVideoData();
                        playerVideoId = videoData ? videoData.video_id : null;
                    } catch(e) {}

                    // Skip if player already has this track loaded
                    if (playerVideoId === payload.youtube_id) {
                        console.log('[SloppyFM] Player already has this track, skipping');
                        sloppyfmCurrentTrack = payload; // Just update state
                        return;
                    }

                    // Skip if state says same track (backup check)
                    if (sloppyfmCurrentTrack && sloppyfmCurrentTrack.youtube_id === payload.youtube_id) {
                        console.log('[SloppyFM] State says same track, skipping');
                        return;
                    }

                    // Lock sync to prevent loops
                    sloppyfmSyncLock = true;
                    clearTimeout(sloppyfmSyncLockTimeout);
                    sloppyfmSyncLockTimeout = setTimeout(function() { sloppyfmSyncLock = false; }, 5000);

                    // Calculate seek position from started_at
                    var startedAt = new Date(payload.started_at).getTime();
                    var elapsed = Math.floor((Date.now() - startedAt) / 1000);

                    sloppyfmCurrentTrack = payload;
                    sloppyfmCurrentTrack.started_at = payload.started_at;
                    console.log('[SloppyFM] Loading NEW track from broadcast:', payload.title);
                    sloppyfmPlayer.loadVideoById({
                        videoId: payload.youtube_id,
                        startSeconds: Math.max(0, elapsed)
                    });
                    updateSloppyFMUI();
                    loadSloppyFMQueue();
                }
            });

            // Position sync disabled - using Supabase started_at as single source of truth
            // Peer-to-peer position sync caused reload loops when multiple clients conflicted

            sloppyfmChannel.on('broadcast', { event: 'queue_update' }, function() {
                loadSloppyFMQueue();
            });

            sloppyfmChannel.subscribe();
        }

        // Position broadcasting disabled - caused sync conflicts
        // Using Supabase started_at as single source of truth instead
        function broadcastSloppyFMPosition() { /* disabled */ }
        function startSloppyFMPositionBroadcast() { /* disabled */ }
        function stopSloppyFMPositionBroadcast() { /* disabled */ }

        // Manual resync function
        window.sloppyfmResync = async function() {
            if (!sloppyfmReady || !sloppyfmPlayer) {
                showToast('Player not ready', 'error');
                return;
            }
            showToast('Syncing radio...', 'system');
            await syncSloppyFMState();
            showToast('Radio synced!', 'success');
        };

        function onSloppyFMStateChange(event) {
            if (event.data === YT.PlayerState.PLAYING) {
                sloppyfmIsPlaying = true;
                sloppyfmStartVisualizer();
                startSloppyFMPositionBroadcast(); // Start syncing position
                updateSloppyFMUI();
            } else if (event.data === YT.PlayerState.PAUSED || event.data === YT.PlayerState.ENDED) {
                sloppyfmIsPlaying = false;
                stopSloppyFMVisualizer();
                stopSloppyFMPositionBroadcast(); // Stop syncing position
                updateSloppyFMUI();
                if (event.data === YT.PlayerState.ENDED) {
                    sloppyfmNext();
                }
            }
        }

        function onSloppyFMError(event) {
            console.error('[SloppyFM] YouTube error:', event.data);
            showToast('Track unavailable, skipping...', 'warning');
            setTimeout(sloppyfmNext, 1000);
        }

        // Load queue from Supabase (deduplicated by youtube_id)
        async function loadSloppyFMQueue() {
            var result = await supabase
                .from('sloppygram_radio')
                .select('youtube_id, title, artist, duration, added_by, started_at, is_playing, created_at')
                .order('created_at', { ascending: true })
                .limit(100);

            if (result.data && result.data.length > 0) {
                // Deduplicate by youtube_id - keep the first (oldest) entry
                var seen = {};
                sloppyfmQueue = result.data.filter(function(track) {
                    if (seen[track.youtube_id]) return false;
                    seen[track.youtube_id] = true;
                    return true;
                });
            } else {
                // Use defaults if queue is empty
                sloppyfmQueue = sloppyfmDefaultTracks.map(function(t, i) {
                    return { id: 'default-' + i, ...t };
                });
            }
            sloppyfmRenderPlaylist();
        }

        // Sync playback state from Supabase - ONLY called once on init, no periodic polling
        // Periodic polling was causing track jumps due to race conditions with is_playing flag
        async function syncSloppyFMState() {
            // Skip if sync is locked or already playing
            if (sloppyfmSyncLock || sloppyfmIsPlaying) {
                console.log('[SloppyFM] Skipping sync - locked or already playing');
                return;
            }

            var result = await supabase
                .from('sloppygram_radio')
                .select('youtube_id, title, artist, duration, added_by, started_at, is_playing')
                .eq('is_playing', true)
                .order('started_at', { ascending: false })
                .limit(1);

            var track = result.data && result.data[0];
            if (track && track.started_at) {
                var startedAt = new Date(track.started_at).getTime();
                var now = Date.now();
                var elapsed = Math.floor((now - startedAt) / 1000);

                if (sloppyfmReady && sloppyfmPlayer && !sloppyfmCurrentTrack) {
                    // Only load on initial sync when no track is set
                    sloppyfmSyncLock = true;
                    clearTimeout(sloppyfmSyncLockTimeout);
                    sloppyfmSyncLockTimeout = setTimeout(function() { sloppyfmSyncLock = false; }, 5000);

                    sloppyfmCurrentTrack = track;
                    console.log('[SloppyFM] Initial sync - loading:', track.title);
                    sloppyfmPlayer.loadVideoById({
                        videoId: track.youtube_id,
                        startSeconds: Math.max(0, elapsed)
                    });
                    updateSloppyFMTrackInfo();
                }
            }
            // NO periodic sync - broadcast handles track changes between clients
        }

        // Broadcast current track to all users
        async function broadcastSloppyFMTrack(track) {
            if (!currentUser) return;

            var startedAt = new Date().toISOString();

            // Clear any existing playing tracks
            await supabase
                .from('sloppygram_radio')
                .update({ is_playing: false })
                .eq('is_playing', true);

            // Set new playing track
            if (track.id && !String(track.id).startsWith('default-')) {
                await supabase
                    .from('sloppygram_radio')
                    .update({ is_playing: true, started_at: startedAt })
                    .eq('id', track.id);
            } else {
                // Insert new track for defaults
                await supabase
                    .from('sloppygram_radio')
                    .insert({
                        youtube_id: track.youtube_id,
                        title: track.title,
                        artist: track.artist,
                        duration: track.duration || 0,
                        added_by: profile.username,
                        started_at: startedAt,
                        is_playing: true,
                        user_id: currentUser.id
                    });
            }

            // Send realtime broadcast to sync all clients
            if (sloppyfmChannel) {
                sloppyfmChannel.send({
                    type: 'broadcast',
                    event: 'track_change',
                    payload: {
                        youtube_id: track.youtube_id,
                        title: track.title,
                        artist: track.artist,
                        started_at: startedAt
                    }
                });
            }
        }

        window.toggleSloppyFM = function() {
            var widget = document.getElementById('sloppyfmWidget');
            var toggle = document.getElementById('sloppyfmToggle');
            if (widget.classList.contains('visible')) {
                widget.classList.remove('visible');
                toggle.classList.remove('hidden');
            } else {
                widget.classList.add('visible');
                toggle.classList.add('hidden');
                // Load YouTube API on first open
                if (!sloppyfmReady) loadYouTubeAPI();
                sloppyfmRenderPlaylist();
            }
        };

        // === TWITCH EMBED WIDGET ===
        var twitchLoaded = false;

        window.toggleTwitch = function() {
            var widget = document.getElementById('twitchWidget');
            var toggle = document.getElementById('twitchToggle');
            if (widget.classList.contains('visible')) {
                widget.classList.remove('visible');
                toggle.classList.remove('hidden');
            } else {
                widget.classList.add('visible');
                toggle.classList.add('hidden');
                // Load Twitch embed on first open
                if (!twitchLoaded) {
                    loadTwitchEmbed();
                    twitchLoaded = true;
                }
            }
        };

        function loadTwitchEmbed() {
            var container = document.getElementById('twitchContent');
            if (!container) return;
            var iframe = document.createElement('iframe');
            iframe.src = 'https://player.twitch.tv/?channel=sloppy_ai&parent=' + window.location.hostname + '&muted=true';
            iframe.allowFullscreen = true;
            iframe.allow = 'autoplay; fullscreen';
            container.appendChild(iframe);
        }

        // Make Twitch widget draggable (using centralized drag system)
        makeDraggable('twitchWidget', 'twitchTitlebar');

        // === TWITCH CHAT WIDGET ===
        var twitchChatLoaded = false;

        window.toggleTwitchChat = function() {
            var widget = document.getElementById('twitchChatWidget');
            var toggle = document.getElementById('twitchChatToggle');
            if (widget.classList.contains('visible')) {
                widget.classList.remove('visible');
                toggle.classList.remove('hidden');
            } else {
                widget.classList.add('visible');
                toggle.classList.add('hidden');
                // Load Twitch chat on first open
                if (!twitchChatLoaded) {
                    loadTwitchChatEmbed();
                    twitchChatLoaded = true;
                }
            }
        };

        function loadTwitchChatEmbed() {
            var container = document.getElementById('twitchChatContent');
            if (!container) return;
            var iframe = document.createElement('iframe');
            iframe.src = 'https://www.twitch.tv/embed/sloppy_ai/chat?parent=' + window.location.hostname + '&darkpopout';
            container.appendChild(iframe);
        }

        // Make Twitch Chat widget draggable (using centralized drag system)
        makeDraggable('twitchChatWidget', 'twitchChatTitlebar');

        // === APP LAUNCHER ===
        var appLauncherOpen = false;
        var embeddedAppsLoaded = { graffiti: false, manifesto: false, worldmonitor: false, toiletgram: false, tetris: false, synth: false, pixel: false, btc: false, solana: false, sloppycoin: false, crypto: false, sloppydash: false, wikiscout: false };

        window.toggleAppLauncher = function() {
            var menu = document.getElementById('appLauncherMenu');
            appLauncherOpen = !appLauncherOpen;
            if (appLauncherOpen) {
                menu.classList.add('visible');
            } else {
                menu.classList.remove('visible');
            }
        };

        window.openEmbeddedApp = function(appName) {
            var appConfig = {
                graffiti: { windowId: 'graffitiWindow', contentId: 'graffitiContent', src: 'https://app.sloppy.live/graffiti-wall' },
                manifesto: { windowId: 'manifestoWindow', contentId: 'manifestoAppContent', src: 'https://app.sloppy.live/manifesto-generator' },
                origins: { windowId: 'originsWindow', contentId: 'originsContent', src: 'https://app.sloppy.live/origins' },
                sloppyapi: { windowId: 'sloppyapiWindow', contentId: 'sloppyapiContent', src: 'https://app.sloppy.live/sloppygram-api' },
                diary: { windowId: 'diaryWindow', contentId: 'diaryContent', src: 'https://app.vibecodedbyx.com/claudes-digital-diary/' },
                truth: { windowId: 'truthWindow', contentId: 'truthContent', src: 'https://app.sloppy.live/federated-truth' },
                blueprint: { windowId: 'blueprintWindow', contentId: 'blueprintContent', src: 'https://app.sloppy.live/blueprint-portal' },
                sloppysays: { windowId: 'sloppysaysWindow', contentId: 'sloppysaysContent', src: 'https://app.sloppy.live/sloppy-says' },
                genealogist: { windowId: 'genealogistWindow', contentId: 'genealogistContent', src: 'https://app.sloppy.live/genealogist' },
                taxonomist: { windowId: 'taxonomistWindow', contentId: 'taxonomistContent', src: 'https://app.vibecodedbyx.com/app-taxonomist/' },
                sloppymanifesto: { windowId: 'sloppymanifestoWindow', contentId: 'sloppymanifestoContent', src: 'https://app.vibecodedbyx.com/sloppys-manifesto/' },
                tetris: { windowId: 'tetrisWindow', contentId: 'tetrisContent', src: 'https://app.sloppy.live/neon-tetris' },
                synth: { windowId: 'synthWindow', contentId: 'synthContent', src: 'https://app.sloppy.live/neon-synth' },
                pixel: { windowId: 'pixelWindow', contentId: 'pixelContent', src: 'https://app.sloppy.live/pixel-editor' },
                btc: { windowId: 'btcWindow', contentId: 'btcContent', src: 'https://app.sloppy.live/btc-tracker' },
                solana: { windowId: 'solanaWindow', contentId: 'solanaContent', src: 'https://app.sloppy.live/solana-tracker' },
                sloppycoin: { windowId: 'sloppycoinWindow', contentId: 'sloppycoinContent', src: 'https://app.sloppy.live/sloppy-coin-info' },
                crypto: { windowId: 'cryptoWindow', contentId: 'cryptoContent', src: 'https://app.sloppy.live/crypto-tools' },
                sloppydash: { windowId: 'sloppydashWindow', contentId: 'sloppydashContent', src: 'https://app.sloppy.live/sloppy-dashboard' },
                wikiscout: { windowId: 'wikiscoutWindow', contentId: 'wikiscoutContent', src: 'https://app.sloppy.live/wiki-scout' }
            };
            var config = appConfig[appName];
            if (!config) return;
            var windowId = config.windowId;
            var contentId = config.contentId;
            var iframeSrc = config.src;

            var win = document.getElementById(windowId);
            if (!win) return;

            // Close launcher menu
            document.getElementById('appLauncherMenu').classList.remove('visible');
            appLauncherOpen = false;

            // Show window
            win.classList.add('visible');

            // Load iframe on first open
            if (!embeddedAppsLoaded[appName]) {
                var container = document.getElementById(contentId);
                if (container && container.children.length === 0) {
                    var iframe = document.createElement('iframe');
                    iframe.src = iframeSrc;
                    iframe.allow = 'fullscreen';
                    container.appendChild(iframe);
                    embeddedAppsLoaded[appName] = true;
                }
            }
        };

        window.closeEmbeddedApp = function(appName) {
            var win = document.getElementById(appName + 'Window');
            if (win) {
                win.classList.remove('visible');
            }
        };

        // Make embedded app windows draggable (using centralized drag system)
        (function() {
            var apps = ['graffiti', 'manifesto', 'origins', 'sloppyapi', 'diary', 'truth', 'blueprint', 'sloppysays', 'tetris', 'synth', 'pixel', 'btc', 'solana', 'sloppycoin', 'crypto', 'sloppydash', 'wikiscout'];
            apps.forEach(function(appName) {
                makeDraggable(appName + 'Window', appName + 'Titlebar');
            });
        })();

        // Close launcher when clicking outside
        document.addEventListener('click', function(e) {
            var menu = document.getElementById('appLauncherMenu');
            var toggle = document.getElementById('appLauncherToggle');
            if (appLauncherOpen && !menu.contains(e.target) && !toggle.contains(e.target)) {
                menu.classList.remove('visible');
                appLauncherOpen = false;
            }
        });

        function sloppyfmRenderPlaylist() {
            var playlist = document.getElementById('sloppyfmPlaylist');
            if (!playlist) return;
            var tracks = sloppyfmQueue.length > 0 ? sloppyfmQueue : sloppyfmDefaultTracks;
            playlist.innerHTML = tracks.map(function(track, idx) {
                var isActive = sloppyfmCurrentTrack && sloppyfmCurrentTrack.youtube_id === track.youtube_id;
                var activeClass = isActive ? 'active' : '';
                return '<div class="sloppyfm-track ' + activeClass + '" onclick="sloppyfmSelectTrack(' + idx + ')">' +
                    (idx + 1) + '. ' + escapeHtml(track.title) +
                    '<span class="sloppyfm-genre">[' + escapeHtml(track.artist || 'Unknown') + ']</span></div>';
            }).join('');
        }

        function updateSloppyFMUI() {
            var playBtn = document.getElementById('sloppyfmPlayBtn');
            if (playBtn) {
                playBtn.textContent = sloppyfmIsPlaying ? 'â¸' : 'â–¶';
                if (sloppyfmIsPlaying) playBtn.classList.add('playing');
                else playBtn.classList.remove('playing');
            }
            sloppyfmRenderPlaylist();
        }

        function updateSloppyFMTrackInfo() {
            if (!sloppyfmCurrentTrack) return;
            var nameEl = document.getElementById('sloppyfmTrackName');
            if (nameEl) nameEl.textContent = sloppyfmCurrentTrack.title + ' - ' + (sloppyfmCurrentTrack.artist || 'Radio');
        }

        window.sloppyfmSelectTrack = function(idx) {
            var tracks = sloppyfmQueue.length > 0 ? sloppyfmQueue : sloppyfmDefaultTracks;
            if (idx < 0 || idx >= tracks.length) return;
            sloppyfmCurrentTrack = tracks[idx];
            if (sloppyfmReady && sloppyfmPlayer) {
                sloppyfmPlayer.loadVideoById(sloppyfmCurrentTrack.youtube_id);
                broadcastSloppyFMTrack(sloppyfmCurrentTrack);
            }
            updateSloppyFMTrackInfo();
            sloppyfmRenderPlaylist();
        };

        window.sloppyfmPlay = function() {
            if (!sloppyfmReady || !sloppyfmPlayer) {
                loadYouTubeAPI();
                return;
            }
            if (sloppyfmIsPlaying) {
                sloppyfmPlayer.pauseVideo();
            } else {
                if (!sloppyfmCurrentTrack) {
                    sloppyfmSelectTrack(0);
                } else {
                    sloppyfmPlayer.playVideo();
                }
            }
        };

        window.sloppyfmStop = function() {
            if (sloppyfmPlayer && sloppyfmReady) {
                sloppyfmPlayer.stopVideo();
            }
            sloppyfmIsPlaying = false;
            updateSloppyFMUI();
            stopSloppyFMVisualizer();
        };

        window.sloppyfmNext = function() {
            var tracks = sloppyfmQueue.length > 0 ? sloppyfmQueue : sloppyfmDefaultTracks;
            var currentIdx = tracks.findIndex(function(t) {
                return sloppyfmCurrentTrack && t.youtube_id === sloppyfmCurrentTrack.youtube_id;
            });
            var nextIdx = (currentIdx + 1) % tracks.length;
            sloppyfmSelectTrack(nextIdx);
        };

        window.sloppyfmPrev = function() {
            var tracks = sloppyfmQueue.length > 0 ? sloppyfmQueue : sloppyfmDefaultTracks;
            var currentIdx = tracks.findIndex(function(t) {
                return sloppyfmCurrentTrack && t.youtube_id === sloppyfmCurrentTrack.youtube_id;
            });
            var prevIdx = currentIdx <= 0 ? tracks.length - 1 : currentIdx - 1;
            sloppyfmSelectTrack(prevIdx);
        };

        window.sloppyfmShuffle = function() {
            var tracks = sloppyfmQueue.length > 0 ? sloppyfmQueue : sloppyfmDefaultTracks;
            var randomIdx = Math.floor(Math.random() * tracks.length);
            sloppyfmSelectTrack(randomIdx);
            showToast('Shuffled to: ' + tracks[randomIdx].title);
        };

        window.sloppyfmSetVolume = function(val) {
            sloppyfmVolume = parseInt(val);
            if (sloppyfmPlayer && sloppyfmReady) {
                sloppyfmPlayer.setVolume(sloppyfmVolume);
            }
        };

        // Add track from YouTube URL or ID
        window.sloppyfmAddTrack = async function() {
            var input = document.getElementById('sloppyfmUrlInput');
            if (!input) return;
            var val = input.value.trim();
            if (!val) return;

            // Extract YouTube video ID from various URL formats
            var videoId = null;
            var patterns = [
                /(?:youtube\.com\/watch\?v=|youtu\.be\/|youtube\.com\/embed\/|youtube\.com\/v\/)([a-zA-Z0-9_-]{11})/,
                /^([a-zA-Z0-9_-]{11})$/
            ];
            for (var i = 0; i < patterns.length; i++) {
                var match = val.match(patterns[i]);
                if (match) {
                    videoId = match[1];
                    break;
                }
            }

            if (!videoId) {
                showToast('Invalid YouTube URL or ID', 'error');
                return;
            }

            input.disabled = true;
            var btn = input.nextElementSibling;
            if (btn) btn.disabled = true;

            // Track addition managed by Sloppy Radio (sovereign owner)
            showToast('Add tracks in Sloppy Radio app', 'info');
            input.disabled = false;
            if (btn) btn.disabled = false;
        };

        // SloppyFM Canvas Visualizer
        var sloppyfmCache = { canvas: null, ctx: null, timeEl: null };
        var sloppyfmBars = [];
        var sloppyfmPeaks = [];
        var sloppyfmAnimFrame = null;
        var NUM_BARS = 32;

        // Initialize bar heights and peaks
        for (var i = 0; i < NUM_BARS; i++) {
            sloppyfmBars[i] = 0;
            sloppyfmPeaks[i] = 0;
        }

        function sloppyfmStartVisualizer() {
            if (sloppyfmAnimFrame) cancelAnimationFrame(sloppyfmAnimFrame);

            if (!sloppyfmCache.canvas) {
                sloppyfmCache.canvas = document.getElementById('sloppyfmCanvas');
                if (sloppyfmCache.canvas) {
                    sloppyfmCache.ctx = sloppyfmCache.canvas.getContext('2d');
                }
            }

            if (!sloppyfmCache.canvas || !sloppyfmCache.ctx) return;

            function animate() {
                if (!sloppyfmIsPlaying) {
                    sloppyfmAnimFrame = requestAnimationFrame(animate);
                    return;
                }

                var canvas = sloppyfmCache.canvas;
                var ctx = sloppyfmCache.ctx;
                var width = canvas.width;
                var height = canvas.height;

                // Clear canvas
                ctx.fillStyle = '#111';
                ctx.fillRect(0, 0, width, height);

                var barWidth = (width / NUM_BARS) - 2;
                var gap = 2;

                for (var i = 0; i < NUM_BARS; i++) {
                    // Simulate frequency data with smooth random values
                    var targetHeight = Math.random() * height * 0.9;

                    // Add some bass emphasis (lower frequencies louder)
                    if (i < NUM_BARS / 4) {
                        targetHeight *= 1.2;
                    }
                    // Add some treble variation
                    if (i > NUM_BARS * 0.75) {
                        targetHeight *= 0.7 + Math.random() * 0.3;
                    }

                    // Smooth animation - bars rise fast, fall slow
                    if (targetHeight > sloppyfmBars[i]) {
                        sloppyfmBars[i] += (targetHeight - sloppyfmBars[i]) * 0.3;
                    } else {
                        sloppyfmBars[i] -= (sloppyfmBars[i] - targetHeight) * 0.1;
                    }

                    // Peak indicator - falls slowly
                    if (sloppyfmBars[i] > sloppyfmPeaks[i]) {
                        sloppyfmPeaks[i] = sloppyfmBars[i];
                    } else {
                        sloppyfmPeaks[i] -= 0.5;
                        if (sloppyfmPeaks[i] < 0) sloppyfmPeaks[i] = 0;
                    }

                    var barHeight = Math.max(2, sloppyfmBars[i]);
                    var x = i * (barWidth + gap);
                    var y = height - barHeight;

                    // Create gradient based on height
                    var gradient = ctx.createLinearGradient(x, height, x, y);
                    var ratio = barHeight / height;

                    if (ratio > 0.8) {
                        // Red for high
                        gradient.addColorStop(0, '#600');
                        gradient.addColorStop(0.5, '#a00');
                        gradient.addColorStop(1, '#f00');
                    } else if (ratio > 0.5) {
                        // Yellow for mid
                        gradient.addColorStop(0, '#660');
                        gradient.addColorStop(0.5, '#aa0');
                        gradient.addColorStop(1, '#ff0');
                    } else {
                        // Green for low
                        gradient.addColorStop(0, '#060');
                        gradient.addColorStop(0.5, '#0a0');
                        gradient.addColorStop(1, '#0f0');
                    }

                    ctx.fillStyle = gradient;
                    ctx.fillRect(x, y, barWidth, barHeight);

                    // Draw peak indicator
                    if (sloppyfmPeaks[i] > 2) {
                        var peakY = height - sloppyfmPeaks[i];
                        ctx.fillStyle = '#fff';
                        ctx.fillRect(x, peakY, barWidth, 2);
                    }
                }

                sloppyfmAnimFrame = requestAnimationFrame(animate);
            }

            animate();

            // Update time display
            sloppyfmUpdateTime();
        }

        function stopSloppyFMVisualizer() {
            if (sloppyfmAnimFrame) {
                cancelAnimationFrame(sloppyfmAnimFrame);
                sloppyfmAnimFrame = null;
            }

            // Clear canvas and reset bars
            if (sloppyfmCache.canvas && sloppyfmCache.ctx) {
                var ctx = sloppyfmCache.ctx;
                var canvas = sloppyfmCache.canvas;
                ctx.fillStyle = '#111';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
            }

            for (var i = 0; i < NUM_BARS; i++) {
                sloppyfmBars[i] = 0;
                sloppyfmPeaks[i] = 0;
            }
        }

        function sloppyfmUpdateTime() {
            if (!sloppyfmIsPlaying || !sloppyfmPlayer || !sloppyfmReady) return;
            try {
                var currentTime = sloppyfmPlayer.getCurrentTime() || 0;
                var mins = Math.floor(currentTime / 60);
                var secs = Math.floor(currentTime % 60);
                if (!sloppyfmCache.timeEl) {
                    sloppyfmCache.timeEl = document.getElementById('sloppyfmTime');
                }
                if (sloppyfmCache.timeEl) {
                    sloppyfmCache.timeEl.textContent = (mins < 10 ? '0' : '') + mins + ':' + (secs < 10 ? '0' : '') + secs;
                }
            } catch(e) {}
            setTimeout(sloppyfmUpdateTime, 1000);
        }

        // Make SloppyFM widget draggable (using centralized drag system)
        makeDraggable('sloppyfmWidget', 'sloppyfmTitlebar');

        // === CONFIDENCE MONITOR ===
        var confidenceScore = 0;
        var confidenceMode = 0; // 0: system, 1: engagement, 2: synthesis
        var confidenceModes = ['SYSTEM', 'ENGAGE', 'SYNTH'];
        var confidenceInterval = null;
        var confidenceCache = { votes: 0, reactions: 0, manifestos: 0, lastFetch: 0 };

        function initConfidenceMonitor() {
            updateConfidenceDisplay();
            // Update confidence every 5 seconds (async queries need more time)
            registerInterval('confidence-monitor', calculateConfidence, 5000);
            calculateConfidence();
        }

        const CONFIDENCE_CACHE_TTL = 5 * 60 * 1000; // 5 minutes for sessionStorage persistence

        async function fetchConfidenceMetrics() {
            // Check in-memory cache first (10 seconds for rapid re-renders)
            if (Date.now() - confidenceCache.lastFetch < 10000) {
                return confidenceCache;
            }

            // Check sessionStorage for cross-reload persistence (5 minutes TTL)
            try {
                const cached = sessionStorage.getItem('confidenceMetrics');
                if (cached) {
                    const parsed = JSON.parse(cached);
                    if (Date.now() - parsed.lastFetch < CONFIDENCE_CACHE_TTL) {
                        confidenceCache = parsed;
                        return confidenceCache;
                    }
                }
            } catch (e) { /* sessionStorage unavailable */ }

            try {
                // Query real metrics from database in parallel
                var [votesRes, reactionsRes, manifestosRes, msgVotesRes, msgReactionsRes, manifestoVotesRes] = await Promise.all([
                    supabase.from('sloppygram_post_likes').select('post_id', { count: 'exact', head: true }),
                    supabase.from('sloppygram_post_reactions').select('id', { count: 'exact', head: true }),
                    supabase.from('sloppygram_manifestos').select('id, upvotes'),
                    supabase.from('sloppygram_message_votes').select('message_id', { count: 'exact', head: true }),
                    supabase.from('sloppygram_message_reactions').select('id', { count: 'exact', head: true }),
                    supabase.from('sloppygram_manifesto_votes').select('manifesto_id', { count: 'exact', head: true })
                ]);

                var totalVotes = (votesRes.count || 0) + (msgVotesRes.count || 0);
                var totalReactions = (reactionsRes.count || 0) + (msgReactionsRes.count || 0);
                var totalManifestoUpvotes = 0;
                if (manifestosRes.data) {
                    manifestosRes.data.forEach(function(m) { totalManifestoUpvotes += (m.upvotes || 0); });
                }
                // Add live manifesto vote count
                var manifestoVoteCount = manifestoVotesRes.count || 0;

                confidenceCache = {
                    votes: totalVotes,
                    reactions: totalReactions,
                    manifestos: manifestosRes.data ? manifestosRes.data.length : 0,
                    manifestoUpvotes: totalManifestoUpvotes + manifestoVoteCount,
                    manifestoVoteCount: manifestoVoteCount,
                    lastFetch: Date.now()
                };

                // Persist to sessionStorage for cross-reload caching
                try {
                    sessionStorage.setItem('confidenceMetrics', JSON.stringify(confidenceCache));
                } catch (e) { /* sessionStorage unavailable or full */ }
            } catch (e) {
                console.warn('Confidence metrics fetch failed:', e);
            }

            return confidenceCache;
        }

        async function calculateConfidence() {
            var factors = [];
            var weights = [];

            // Safe access to global variables that may not be defined yet
            var safeMessages = (typeof messages !== 'undefined') ? messages : [];
            var safePosts = (typeof posts !== 'undefined') ? posts : [];
            var safeOnlineUsers = (typeof onlineUsers !== 'undefined') ? onlineUsers : {};

            // Fetch real metrics from database
            var metrics = await fetchConfidenceMetrics();

            if (confidenceMode === 0) {
                // SYSTEM mode: connection health, data loaded, presence
                var connectionHealth = navigator.onLine ? 95 : 20;
                var dataLoaded = (safeMessages.length > 0 && safePosts.length >= 0) ? 90 : 40;
                var presenceCount = Object.keys(safeOnlineUsers).length;
                var presenceScore = Math.min(100, 50 + presenceCount * 10);

                factors = [connectionHealth, dataLoaded, presenceScore];
                weights = [0.4, 0.3, 0.3];
            } else if (confidenceMode === 1) {
                // ENGAGE mode: real engagement metrics from database
                var msgCount = safeMessages.length;
                var postCount = safePosts.length;
                var contentScore = Math.min(100, 30 + msgCount + postCount * 3);

                // Real vote activity score (scaled: 0 votes = 40%, 50+ votes = 100%)
                var voteActivity = Math.min(100, 40 + metrics.votes * 1.2);

                // Real reaction score (scaled: 0 reactions = 50%, 30+ reactions = 100%)
                var reactionScore = Math.min(100, 50 + metrics.reactions * 1.67);

                factors = [contentScore, voteActivity, reactionScore];
                weights = [0.4, 0.3, 0.3];
            } else {
                // SYNTH mode: synthesis health - manifestos, upvotes, content ratio
                var manifestoScore = Math.min(100, 40 + metrics.manifestos * 20);
                var upvoteScore = Math.min(100, 50 + metrics.manifestoUpvotes * 5);

                // Content diversity ratio (messages to posts balance)
                var totalContent = safeMessages.length + safePosts.length;
                var diversityRatio = totalContent > 0
                    ? Math.min(safeMessages.length, safePosts.length * 3) / Math.max(safeMessages.length, safePosts.length * 3)
                    : 0.5;
                var diversityScore = 50 + diversityRatio * 50;

                factors = [manifestoScore, upvoteScore, diversityScore];
                weights = [0.35, 0.35, 0.3];
            }

            // Calculate weighted average
            var newScore = 0;
            for (var i = 0; i < factors.length; i++) {
                newScore += factors[i] * weights[i];
            }

            // Smooth transition
            confidenceScore = confidenceScore * 0.6 + newScore * 0.4;
            updateConfidenceDisplay();
        }

        function updateConfidenceDisplay() {
            var valueEl = document.getElementById('confidenceValue');
            var statusEl = document.getElementById('confidenceStatus');
            if (!valueEl || !statusEl) return;

            var displayScore = Math.round(confidenceScore);
            valueEl.textContent = displayScore + '%';

            // Update color class
            valueEl.classList.remove('high', 'medium', 'low');
            if (displayScore >= 85) {
                valueEl.classList.add('high');
                statusEl.textContent = 'optimal';
            } else if (displayScore >= 60) {
                valueEl.classList.add('medium');
                statusEl.textContent = 'nominal';
            } else {
                valueEl.classList.add('low');
                statusEl.textContent = 'uncertain';
            }
        }

        // Global function to update confidence on vote changes
        window.updateConfidenceMonitor = function() {
            // Clear cache to force fresh data on next calculation
            confidenceCache.lastFetch = 0;
            // Recalculate immediately
            calculateConfidence();
        };

        window.cycleConfidenceMode = function() {
            confidenceMode = (confidenceMode + 1) % 3;
            var labelEl = document.querySelector('.confidence-label');
            if (labelEl) {
                labelEl.textContent = confidenceModes[confidenceMode];
            }
            // Trigger immediate recalculation
            calculateConfidence();

            // Visual feedback
            var monitor = document.getElementById('confidenceMonitor');
            if (monitor) {
                monitor.style.transform = 'scale(1.1)';
                setTimeout(function() {
                    monitor.style.transform = '';
                }, 150);
            }
        };

        // Initialize on load (tracked timeout for cleanup)
        registerTimeout('confidence-monitor-init', initConfidenceMonitor, 1500);

        // === GHOST RADAR (optimized) ===
        var ghostRadarUsers = [];
        var ghostRadarInterval = null;
        var ghostRadarCache = { countEl: null, blipsEl: null, lastCount: -1 };

        function updateGhostRadar(presenceState) {
            var users = [];
            var seen = {};
            Object.values(presenceState).forEach(function(presences) {
                presences.forEach(function(p) {
                    if (!seen[p.username]) {
                        seen[p.username] = true;
                        users.push(p);
                    }
                });
            });
            ghostRadarUsers = users;
            renderGhostRadar();
        }

        function renderGhostRadar() {
            // Cache DOM references
            if (!ghostRadarCache.countEl) {
                ghostRadarCache.countEl = document.getElementById('ghostRadarCount');
                ghostRadarCache.blipsEl = document.getElementById('ghostRadarBlips');
            }
            var countEl = ghostRadarCache.countEl;
            var blipsEl = ghostRadarCache.blipsEl;
            if (!countEl || !blipsEl) return;

            var ghostCount = ghostRadarUsers.length;

            // Only update if count changed
            if (ghostCount === ghostRadarCache.lastCount) return;
            ghostRadarCache.lastCount = ghostCount;

            countEl.textContent = ghostCount + ' watching';

            // Create blips for each ghost (max 8 visible)
            var maxBlips = Math.min(ghostCount, 8);
            var blipsHtml = '';
            for (var i = 0; i < maxBlips; i++) {
                var angle = (i / maxBlips) * Math.PI * 2 + Math.random() * 0.5;
                var radius = 15 + Math.random() * 20;
                var x = 40 + Math.cos(angle) * radius - 3;
                var y = 40 + Math.sin(angle) * radius - 3;
                blipsHtml += '<div class="ghost-radar-blip" style="left:' + x + 'px;top:' + y + 'px;animation-delay:' + (i * 0.3) + 's;"></div>';
            }
            blipsEl.innerHTML = blipsHtml;
        }

        window.ghostRadarPing = function() {
            var ghostCount = ghostRadarUsers.length;
            if (ghostCount === 0) {
                showToast('ðŸ‘» No ghosts detected...', 'info');
            } else if (ghostCount === 1) {
                showToast('ðŸ‘» 1 silent lurker detected!', 'info');
            } else {
                showToast('ðŸ‘» ' + ghostCount + ' ghosts in the shadows!', 'info');
            }
        };

        // Start ghost radar updates (reduced frequency)
        registerInterval('ghost-radar', renderGhostRadar, 5000);

        // === ORACLE LOG ===
        var oracleQuestions = [];
        var oracleLogExpanded = false;
        var oracleLogChannel = null;  // Hoisted for use before cleanup section

        window.toggleOracleLog = function() {
            var log = document.getElementById('oracleLog');
            oracleLogExpanded = !oracleLogExpanded;
            if (oracleLogExpanded) {
                log.classList.add('expanded');
                log.classList.remove('minimized');
            } else {
                log.classList.remove('expanded');
            }
        };

        var oracleLogMinimized = false;
        window.toggleOracleMinimize = function(e) {
            e.preventDefault();
            var log = document.getElementById('oracleLog');
            oracleLogMinimized = !oracleLogMinimized;
            if (oracleLogMinimized) {
                log.classList.add('minimized');
                log.classList.remove('expanded');
                oracleLogExpanded = false;
            } else {
                log.classList.remove('minimized');
            }
        };

        async function loadOracleQuestions() {
            try {
                var { data, error } = await supabase
                    .from('oracle_log')
                    .select('id, question, context, answered, answer, importance, created_at')
                    .order('created_at', { ascending: false })
                    .limit(50);

                if (error) {
                    console.error('[Oracle Log] Load error:', error);
                    return;
                }

                oracleQuestions = data || [];
                renderOracleQuestions();
            } catch (err) {
                console.error('[Oracle Log] Exception:', err);
            }
        }

        function renderOracleQuestions() {
            var body = document.getElementById('oracleLogBody');
            var count = document.getElementById('oracleLogCount');

            count.textContent = oracleQuestions.length;

            if (oracleQuestions.length === 0) {
                body.innerHTML = '<div class="oracle-log-empty">No questions yet. Ask the void...</div>';
                return;
            }

            var html = oracleQuestions.map(function(q) {
                var importance = q.importance || 1;
                var stars = '';
                for (var i = 1; i <= 5; i++) {
                    stars += '<span class="star ' + (i <= importance ? 'filled' : '') + '">â˜…</span>';
                }
                var date = new Date(q.created_at).toLocaleDateString();
                var answeredClass = q.answered ? ' answered' : '';

                return '<div class="oracle-question' + answeredClass + '">' +
                    '<div class="oracle-question-text">' + escapeHtml(q.question) + '</div>' +
                    '<div class="oracle-question-meta">' +
                    '<span>' + date + '</span>' +
                    '<div class="oracle-question-importance">' + stars + '</div>' +
                    '</div>' +
                    '</div>';
            }).join('');

            body.innerHTML = html;
        }

        window.submitOracleQuestion = async function() {
            var input = document.getElementById('oracleQuestionInput');
            var question = input.value.trim();

            if (!question) {
                showToast('Enter a question first', 'warning');
                return;
            }

            if (question.length < 5) {
                showToast('Question too short', 'warning');
                return;
            }

            // Sanitize
            question = sanitizeHtml(question);

            try {
                var { data, error } = await supabase
                    .from('oracle_log')
                    .insert({
                        question: question,
                        user_id: currentUser ? currentUser.id : null,
                        importance: 1,
                        answered: false
                    })
                    .select()
                    .single();

                if (error) {
                    console.error('[Oracle Log] Insert error:', error);
                    showToast('Failed to save question', 'error');
                    return;
                }

                input.value = '';
                oracleQuestions.unshift(data);
                renderOracleQuestions();
                showToast('ðŸ”® Question recorded in the Oracle Log', 'success');

                // Expand to show the new question
                if (!oracleLogExpanded) {
                    toggleOracleLog();
                }
            } catch (err) {
                console.error('[Oracle Log] Exception:', err);
                showToast('Error saving question', 'error');
            }
        };

        // Handle enter key in oracle input
        document.getElementById('oracleQuestionInput').addEventListener('keydown', function(e) {
            if (e.key === 'Enter') {
                e.preventDefault();
                submitOracleQuestion();
            }
        });

        // Subscribe to oracle log changes (store reference for cleanup)
        oracleLogChannel = supabase
            .channel('oracle_log_changes')
            .on('postgres_changes', { event: '*', schema: 'public', table: 'oracle_log' }, function(payload) {
                if (payload.eventType === 'INSERT') {
                    // Only add if not already present (avoid duplicates from our own inserts)
                    var exists = oracleQuestions.some(function(q) { return q.id === payload.new.id; });
                    if (!exists) {
                        oracleQuestions.unshift(payload.new);
                        renderOracleQuestions();
                    }
                } else if (payload.eventType === 'UPDATE') {
                    var idx = oracleQuestions.findIndex(function(q) { return q.id === payload.new.id; });
                    if (idx !== -1) {
                        oracleQuestions[idx] = payload.new;
                        renderOracleQuestions();
                    }
                } else if (payload.eventType === 'DELETE') {
                    oracleQuestions = oracleQuestions.filter(function(q) { return q.id !== payload.old.id; });
                    renderOracleQuestions();
                }
            });
        oracleLogChannel.subscribe();

        // Load oracle questions on init
        loadOracleQuestions();

        // === RATE LIMITING ===
        const rateLimits = {
            message: { limit: 5, window: 10000 },    // 5 messages per 10 seconds
            post: { limit: 3, window: 60000 },       // 3 posts per minute
            vote: { limit: 20, window: 60000 },      // 20 votes per minute
            comment: { limit: 10, window: 60000 },   // 10 comments per minute
            drawing: { limit: 3, window: 30000 },    // 3 drawings per 30 seconds
            follow: { limit: 10, window: 60000 },    // 10 follows per minute
            global_visual: { limit: 1, window: 10000 }  // 1 global visual change per 10s (anti-strobe protection)
        };
        const actionTimestamps = {};  // { actionType: [timestamps] }

        // Anti-strobe protection: throttle incoming visual changes (receiver-side)
        let lastVisualChangeTime = 0;
        const VISUAL_CHANGE_COOLDOWN = 3000; // 3 second minimum between visual changes

        function checkRateLimit(actionType) {
            const config = rateLimits[actionType];
            if (!config) return { allowed: true };

            const now = Date.now();
            const timestamps = actionTimestamps[actionType] || [];

            // Remove expired timestamps
            const validTimestamps = timestamps.filter(t => now - t < config.window);
            actionTimestamps[actionType] = validTimestamps;

            if (validTimestamps.length >= config.limit) {
                const oldestValid = validTimestamps[0];
                const waitTime = Math.ceil((config.window - (now - oldestValid)) / 1000);
                return { allowed: false, waitTime, message: `Rate limited. Wait ${waitTime}s` };
            }

            return { allowed: true };
        }

        function recordAction(actionType) {
            if (!actionTimestamps[actionType]) {
                actionTimestamps[actionType] = [];
            }
            actionTimestamps[actionType].push(Date.now());
        }

        // === CANVAS UNDO/REDO ===
        const MAX_HISTORY = 20;
        let canvasHistory = [];
        let canvasHistoryIndex = -1;

        function saveCanvasState() {
            const canvas = getCachedElement('drawingCanvas');
            if (!canvas) return;

            // Remove any states after current index (for redo overwrite)
            canvasHistory = canvasHistory.slice(0, canvasHistoryIndex + 1);

            // Save current state
            canvasHistory.push(canvas.toDataURL());

            // Limit history size
            if (canvasHistory.length > MAX_HISTORY) {
                canvasHistory.shift();
            } else {
                canvasHistoryIndex++;
            }

            updateUndoRedoButtons();
        }

        function undoCanvas() {
            if (canvasHistoryIndex <= 0) return;
            canvasHistoryIndex--;
            restoreCanvasState(canvasHistory[canvasHistoryIndex]);
            updateUndoRedoButtons();
        }

        function redoCanvas() {
            if (canvasHistoryIndex >= canvasHistory.length - 1) return;
            canvasHistoryIndex++;
            restoreCanvasState(canvasHistory[canvasHistoryIndex]);
            updateUndoRedoButtons();
        }

        function restoreCanvasState(dataUrl) {
            const canvas = getCachedElement('drawingCanvas');
            if (!canvas || !dataUrl) return;

            const img = new Image();
            img.onload = function() {
                drawingCtx.clearRect(0, 0, canvas.width, canvas.height);
                drawingCtx.drawImage(img, 0, 0);
            };
            img.src = dataUrl;
        }

        function updateUndoRedoButtons() {
            const undoBtn = document.getElementById('undoBtn');
            const redoBtn = document.getElementById('redoBtn');
            if (undoBtn) undoBtn.disabled = canvasHistoryIndex <= 0;
            if (redoBtn) redoBtn.disabled = canvasHistoryIndex >= canvasHistory.length - 1;
        }

        function resetCanvasHistory() {
            canvasHistory = [];
            canvasHistoryIndex = -1;
            saveCanvasState(); // Save initial blank state
        }

        // Expose undo/redo globally
        window.undoCanvas = undoCanvas;
        window.redoCanvas = redoCanvas;

        // === PROFILE CARD SYSTEM ===
        let profileCardTimeout = null;
        const USER_STATS_CACHE_TTL = 30 * 60 * 1000; // 30 minutes for localStorage persistence
        const userStatsMemoryCache = new Map(); // In-memory cache for rapid re-renders

        async function getUserStats(username) {
            // Check in-memory cache first (instant for rapid profile views)
            const memCached = userStatsMemoryCache.get(username);
            if (memCached && Date.now() - memCached.cachedAt < 60000) { // 1 minute memory cache
                return memCached.stats;
            }

            // Check localStorage for cross-reload persistence (30 minute TTL)
            try {
                const cached = localStorage.getItem('userStats_' + username);
                if (cached) {
                    const parsed = JSON.parse(cached);
                    if (Date.now() - parsed.cachedAt < USER_STATS_CACHE_TTL) {
                        userStatsMemoryCache.set(username, parsed);
                        return parsed.stats;
                    }
                }
            } catch (e) { /* localStorage unavailable */ }

            try {
                // Fetch user stats and avatar from database in parallel
                const [messagesRes, postsRes, doodlesRes, manifestosRes, avatarMsgRes, avatarPostRes] = await Promise.all([
                    supabase.from('sloppygram_messages').select('id', { count: 'exact', head: true }).eq('username', username),
                    supabase.from('sloppygram_posts').select('id, likes_count', { count: 'exact' }).eq('username', username),
                    supabase.from('sloppygram_messages').select('id', { count: 'exact', head: true }).eq('username', username).eq('message_type', 'drawing'),
                    supabase.from('sloppygram_manifestos').select('id', { count: 'exact', head: true }).eq('username', username),
                    // Fetch most recent message with avatar info
                    supabase.from('sloppygram_messages').select('avatar, avatar_url').eq('username', username).order('created_at', { ascending: false }).limit(1),
                    // Fetch most recent post with avatar info
                    supabase.from('sloppygram_posts').select('avatar, avatar_url').eq('username', username).order('created_at', { ascending: false }).limit(1)
                ]);

                const totalPosts = postsRes.count || 0;
                const totalMessages = messagesRes.count || 0;
                const totalDoodles = doodlesRes.count || 0;
                const totalManifestos = manifestosRes.count || 0;
                const totalLikes = (postsRes.data || []).reduce((sum, p) => sum + (p.likes_count || 0), 0);

                // Fetch vote totals for user's posts
                let totalUpvotes = 0;
                let totalDownvotes = 0;
                const userPostIds = (postsRes.data || []).map(p => p.id);
                if (userPostIds.length > 0) {
                    const { data: votesData } = await supabase
                        .from('sloppygram_post_likes')
                        .select('vote_type')
                        .in('post_id', userPostIds);

                    (votesData || []).forEach(v => {
                        if (v.vote_type > 0) totalUpvotes += v.vote_type;
                        else if (v.vote_type < 0) totalDownvotes += Math.abs(v.vote_type);
                    });
                }

                // Get avatar from most recent activity
                let avatar = 'ðŸ‘¤';
                let avatarUrl = null;

                const latestMsg = (avatarMsgRes.data && avatarMsgRes.data[0]) ? avatarMsgRes.data[0] : null;
                const latestPost = (avatarPostRes.data && avatarPostRes.data[0]) ? avatarPostRes.data[0] : null;

                if (latestMsg) {
                    avatar = latestMsg.avatar || avatar;
                    avatarUrl = latestMsg.avatar_url || avatarUrl;
                }
                if (latestPost) {
                    avatar = latestPost.avatar || avatar;
                    avatarUrl = latestPost.avatar_url || avatarUrl;
                }

                const stats = {
                    messages: totalMessages,
                    posts: totalPosts,
                    doodles: totalDoodles,
                    manifestos: totalManifestos,
                    likes: totalLikes,
                    upvotes: totalUpvotes,
                    downvotes: totalDownvotes,
                    avatar: avatar,
                    avatarUrl: avatarUrl
                };

                // Cache in memory and localStorage
                const cacheEntry = { stats, cachedAt: Date.now() };
                userStatsMemoryCache.set(username, cacheEntry);
                try {
                    localStorage.setItem('userStats_' + username, JSON.stringify(cacheEntry));
                } catch (e) { /* localStorage unavailable or full */ }

                return stats;
            } catch (err) {
                console.error('Error fetching user stats:', err);
                return {
                    messages: 0,
                    posts: 0,
                    doodles: 0,
                    manifestos: 0,
                    likes: 0,
                    upvotes: 0,
                    downvotes: 0,
                    avatar: 'ðŸ‘¤',
                    avatarUrl: null
                };
            }
        }

        // Kept for backwards compatibility but now uses cached data from getUserStats
        async function findUserInfo(username) {
            const stats = await getUserStats(username);
            return { avatar: stats.avatar, avatarUrl: stats.avatarUrl };
        }

        // === SLOPPYID VERIFICATION LOOKUP ===
        var verificationCache = {}; // { username: { data, fetchedAt } }

        async function getUserVerifications(username) {
            // Check cache (2 minute TTL)
            var cached = verificationCache[username];
            if (cached && Date.now() - cached.fetchedAt < 120000) {
                return cached.data;
            }

            try {
                var { data, error } = await supabase
                    .from('sloppyid_verifications')
                    .select('verification_type, is_verified, verification_value')
                    .eq('username', username)
                    .eq('is_verified', true);

                if (error || !data) {
                    verificationCache[username] = { data: { verifications: [], trustScore: 0 }, fetchedAt: Date.now() };
                    return verificationCache[username].data;
                }

                var trustScore = 0;
                var verifications = [];
                data.forEach(function(v) {
                    if (v.verification_type === 'twitter') { trustScore += 100; verifications.push({ type: 'twitter', label: 'ð•' }); }
                    else if (v.verification_type === 'email') { trustScore += 150; verifications.push({ type: 'email', label: 'ðŸ“§' }); }
                    else if (v.verification_type === 'github') { trustScore += 200; verifications.push({ type: 'github', label: '@' + (v.verification_value || '') }); }
                });

                var result = { verifications: verifications, trustScore: trustScore };
                verificationCache[username] = { data: result, fetchedAt: Date.now() };
                return result;
            } catch (e) {
                console.warn('[SloppyID] Verification lookup failed:', e);
                return { verifications: [], trustScore: 0 };
            }
        }

        async function showProfileCard(username, event) {
            const card = document.getElementById('profileCard');
            if (!card) return;

            // Clear any pending hide timeout
            if (profileCardTimeout) {
                clearTimeout(profileCardTimeout);
                profileCardTimeout = null;
            }

            // Position card near click
            const rect = event.target.getBoundingClientRect();
            const cardWidth = 280;
            const cardHeight = 260;

            let left = rect.left;
            let top = rect.bottom + 8;

            // Keep card within viewport
            if (left + cardWidth > window.innerWidth) {
                left = window.innerWidth - cardWidth - 16;
            }
            if (top + cardHeight > window.innerHeight) {
                top = rect.top - cardHeight - 8;
            }

            card.style.left = Math.max(8, left) + 'px';
            card.style.top = Math.max(8, top) + 'px';

            // Show loading state
            card.innerHTML = '<div class="profile-card-loading">Loading...</div>';
            card.classList.add('visible');

            try {
                // Fetch sloppygram stats, cross-app stats, karma, follow data, and verifications in parallel
                const [stats, gameScores, karmaData, followCounts, following, verifyData] = await Promise.all([
                    getUserStats(username),
                    getCrossAppStats(username),
                    typeof calculateUserKarma === 'function' ? calculateUserKarma(username) : Promise.resolve(null),
                    typeof getFollowCounts === 'function' ? getFollowCounts(username) : Promise.resolve({ followers: 0, following: 0 }),
                    typeof isFollowing === 'function' ? isFollowing(username) : Promise.resolve(false),
                    getUserVerifications(username)
                ]);

                // Avatar is now included in stats from database
                const safeAvatarUrl = sanitizeUrl(stats.avatarUrl);
                const avatarContent = safeAvatarUrl
                    ? `<img src="${safeAvatarUrl}" alt="${escapeHtml(username)}" width="48" height="48">`
                    : (stats.avatar || 'ðŸ‘¤');

                // Build game scores HTML if any exist
                let gameScoresHtml = '';
                if (gameScores && gameScores.length > 0) {
                    const scoresHtml = gameScores.map(function(g) {
                        return '<div class="profile-game-score"><span class="game-name">' + escapeHtml(g.game) + ':</span><span class="game-score">' + g.score.toLocaleString() + '</span></div>';
                    }).join('');
                    gameScoresHtml = '<div class="profile-crossapp"><div class="profile-crossapp-title">ðŸŽ® Game High Scores</div><div class="profile-game-scores">' + scoresHtml + '</div></div>';
                }

                // Build karma section if available
                let karmaHtml = '';
                if (karmaData && karmaData.total > 0) {
                    const badges = typeof getEarnedBadges === 'function' ? getEarnedBadges(karmaData) : [];
                    const badgesHtml = badges.slice(0, 4).map(b => `<span class="profile-karma-badge" title="${b.name}">${b.emoji}</span>`).join('');
                    karmaHtml = `
                        <div class="profile-karma-section">
                            <div class="profile-karma-header">
                                <span class="profile-karma-total">âš¡${karmaData.total}</span>
                                <span class="profile-karma-badges">${badgesHtml}</span>
                            </div>
                            <div class="profile-karma-breakdown">
                                <span title="Content">ðŸ“${karmaData.content}</span>
                                <span title="Engagement">ðŸ‘${karmaData.engagement}</span>
                                <span title="Social">ðŸ’¬${karmaData.social}</span>
                            </div>
                        </div>
                    `;
                }

                // Build follow stats HTML
                const isSelf = profile.username === username;
                const followStatsHtml = `
                    <div class="profile-follow-stats">
                        <div class="profile-follow-stat" title="People following this user">
                            <div class="profile-follow-stat-value" data-type="followers">${followCounts.followers}</div>
                            <div class="profile-follow-stat-label">Followers</div>
                        </div>
                        <div class="profile-follow-stat" title="People this user follows">
                            <div class="profile-follow-stat-value" data-type="following">${followCounts.following}</div>
                            <div class="profile-follow-stat-label">Following</div>
                        </div>
                    </div>
                `;

                // Build follow button (not shown for self)
                const followBtnHtml = !isSelf ? `
                    <button class="follow-btn ${following ? 'following' : 'follow'}" onclick="toggleFollow('${escapeAttr(username)}', this)">
                        ${following ? 'Following' : '+ Follow'}
                    </button>
                ` : '';

                // Build trust/verification row
                var trustHtml = '';
                if (verifyData && (verifyData.trustScore > 0 || verifyData.verifications.length > 0)) {
                    var badgeChips = verifyData.verifications.map(function(v) {
                        return '<span class="verify-badge ' + v.type + '">' + escapeHtml(v.label) + '</span>';
                    }).join('');
                    trustHtml = '<div class="profile-trust-row">' +
                        '<span class="profile-trust-score">âš¡' + verifyData.trustScore + '</span>' +
                        '<span class="profile-trust-label">Trust</span>' +
                        '<div class="profile-verify-badges">' + badgeChips + '</div>' +
                        '</div>';
                }

                card.innerHTML = `
                    <div class="profile-card-header">
                        <div class="profile-card-avatar">${avatarContent}</div>
                        <div class="profile-card-name">${escapeHtml(username)}</div>
                    </div>
                    ${trustHtml}
                    ${followStatsHtml}
                    ${karmaHtml}
                    <div class="profile-card-stats">
                        <div class="profile-card-stat">
                            <div class="profile-card-stat-value">${stats.messages}</div>
                            <div class="profile-card-stat-label">Messages</div>
                        </div>
                        <div class="profile-card-stat">
                            <div class="profile-card-stat-value">${stats.posts}</div>
                            <div class="profile-card-stat-label">Posts</div>
                        </div>
                        <div class="profile-card-stat">
                            <div class="profile-card-stat-value">${stats.doodles}</div>
                            <div class="profile-card-stat-label">Doodles</div>
                        </div>
                    </div>
                    <div class="profile-card-stats" style="margin-bottom:0;">
                        <div class="profile-card-stat">
                            <div class="profile-card-stat-value">${stats.manifestos}</div>
                            <div class="profile-card-stat-label">Manifestos</div>
                        </div>
                        <div class="profile-card-stat">
                            <div class="profile-card-stat-value" style="color: #4a9">â–²${stats.upvotes || 0}</div>
                            <div class="profile-card-stat-label">Upvotes</div>
                        </div>
                        <div class="profile-card-stat">
                            <div class="profile-card-stat-value" style="color: #c66">â–¼${stats.downvotes || 0}</div>
                            <div class="profile-card-stat-label">Downvotes</div>
                        </div>
                    </div>
                    ${gameScoresHtml}
                    <div class="profile-card-actions" style="margin-top:12px;padding-top:12px;border-top:1px solid var(--border);display:flex;gap:8px;justify-content:center;flex-wrap:wrap;">
                        ${followBtnHtml}
                        <a href="/sloppy-id?search=${encodeURIComponent(username)}" target="_blank" style="font-size:0.75rem;color:var(--accent);text-decoration:none;padding:6px 12px;border:1px solid var(--accent);border-radius:4px;">ðŸªª SloppyID</a>
                        <button onclick="startDMWithUser(null, '${escapeAttr(username)}');hideProfileCard();" style="font-size:0.75rem;color:#00d4ff;background:none;border:1px solid #00d4ff;border-radius:4px;padding:6px 12px;cursor:pointer;">âœ‰ï¸ DM</button>
                    </div>
                `;
            } catch (err) {
                console.error('Error loading profile:', err);
                card.innerHTML = '<div class="profile-card-loading">Could not load profile</div>';
            }
        }

        function hideProfileCard() {
            const card = document.getElementById('profileCard');
            if (card) {
                card.classList.remove('visible');
            }
        }

        function scheduleHideProfileCard() {
            profileCardTimeout = setTimeout(hideProfileCard, 300);
        }

        // Close profile card on click outside
        document.addEventListener('click', (e) => {
            const card = document.getElementById('profileCard');
            if (card && !card.contains(e.target) && !e.target.classList.contains('username-clickable')) {
                hideProfileCard();
            }
        });

        // Expose profile card functions
        window.showProfileCard = showProfileCard;
        window.hideProfileCard = hideProfileCard;

        // === SOCIAL GRAPH - FOLLOWS & MENTIONS ===

        // Check if current user follows a username
        async function isFollowing(username) {
            if (!currentUser || !profile.username) return false;
            if (profile.username === username) return false; // Can't follow yourself

            try {
                const { data, error } = await supabase
                    .from('sloppygram_follows')
                    .select('id')
                    .eq('follower_username', profile.username)
                    .eq('followed_username', username)
                    .limit(1);

                return data && data.length > 0;
            } catch (err) {
                console.error('Error checking follow status:', err);
                return false;
            }
        }

        // Get follower and following counts for a user
        async function getFollowCounts(username) {
            try {
                const [followersRes, followingRes] = await Promise.all([
                    supabase.from('sloppygram_follows').select('id', { count: 'exact', head: true }).eq('followed_username', username),
                    supabase.from('sloppygram_follows').select('id', { count: 'exact', head: true }).eq('follower_username', username)
                ]);

                return {
                    followers: followersRes.count || 0,
                    following: followingRes.count || 0
                };
            } catch (err) {
                console.error('Error getting follow counts:', err);
                return { followers: 0, following: 0 };
            }
        }

        // Follow a user
        async function followUser(username) {
            if (!currentUser || !profile.username) {
                showToast('Sign in to follow users', 'warning');
                return false;
            }
            if (profile.username === username) {
                showToast("You can't follow yourself", 'warning');
                return false;
            }

            // Rate limiting
            const rateCheck = checkRateLimit('follow');
            if (!rateCheck.allowed) {
                showToast(rateCheck.message, 'warning');
                return false;
            }
            recordAction('follow');

            try {
                const { error } = await supabase
                    .from('sloppygram_follows')
                    .insert({
                        follower_username: profile.username,
                        followed_username: username,
                        follower_id: currentUser.id,
                        followed_id: null, // Could populate if we had their user_id
                        user_id: currentUser.id
                    });

                if (error) {
                    if (error.code === '23505') { // Unique violation
                        showToast('Already following ' + username, 'info');
                        return true;
                    }
                    throw error;
                }

                showToast('Now following @' + username, 'success');

                // Log to ai_events
                supabase.from('ai_events').insert({
                    event_type: 'follow',
                    entity_type: 'user',
                    entity_id: username,
                    username: profile.username,
                    metadata: { followed_username: username },
                    user_id: currentUser.id
                }).then(() => {}).catch(() => {});

                return true;
            } catch (err) {
                console.error('Error following user:', err);
                showToast('Could not follow user', 'error');
                return false;
            }
        }

        // Unfollow a user
        async function unfollowUser(username) {
            if (!currentUser || !profile.username) return false;

            try {
                const { error } = await supabase
                    .from('sloppygram_follows')
                    .delete()
                    .eq('follower_username', profile.username)
                    .eq('followed_username', username);

                if (error) throw error;

                showToast('Unfollowed @' + username, 'info');
                return true;
            } catch (err) {
                console.error('Error unfollowing user:', err);
                showToast('Could not unfollow user', 'error');
                return false;
            }
        }

        // Toggle follow status
        window.toggleFollow = async function(username, btn) {
            if (!btn) return;

            const wasFollowing = btn.classList.contains('following');
            btn.disabled = true;
            btn.textContent = '...';

            let success;
            if (wasFollowing) {
                success = await unfollowUser(username);
            } else {
                success = await followUser(username);
            }

            if (success) {
                btn.classList.toggle('following', !wasFollowing);
                btn.classList.toggle('follow', wasFollowing);
                btn.textContent = wasFollowing ? '+ Follow' : 'Following';

                // Update follower count in card
                const countEl = document.querySelector('.profile-follow-stat-value[data-type="followers"]');
                if (countEl) {
                    const current = parseInt(countEl.textContent) || 0;
                    countEl.textContent = wasFollowing ? Math.max(0, current - 1) : current + 1;
                }
            } else {
                btn.textContent = wasFollowing ? 'Following' : '+ Follow';
            }

            btn.disabled = false;
        };

        // Save mentions to database when sending content
        async function saveMentions(content, sourceType, sourceId) {
            if (!content || !currentUser) return;

            const mentionRegex = /@(\w+)/g;
            const mentions = [];
            let match;

            while ((match = mentionRegex.exec(content)) !== null) {
                const mentionedUsername = match[1];
                if (mentionedUsername !== profile.username) { // Don't save self-mentions
                    mentions.push(mentionedUsername);
                }
            }

            if (mentions.length === 0) return;

            // Insert all mentions
            const mentionRows = mentions.map(username => ({
                mentioned_username: username,
                source_type: sourceType,
                source_id: sourceId,
                source_username: profile.username,
                seen: false,
                user_id: currentUser.id
            }));

            try {
                await supabase.from('sloppygram_mentions').insert(mentionRows);
            } catch (err) {
                console.error('Error saving mentions:', err);
            }
        }

        // Check for new mentions and show notification
        async function checkForMentions() {
            if (!profile.username || !currentUser) return;

            try {
                const { data, error } = await supabase
                    .from('sloppygram_mentions')
                    .select('source_username, source_type, source_id, mentioned_username, seen, created_at')
                    .eq('mentioned_username', profile.username)
                    .eq('seen', false)
                    .order('created_at', { ascending: false })
                    .limit(5);

                if (error || !data || data.length === 0) return;

                // Show notification for most recent
                const recent = data[0];
                showMentionNotification(recent.source_username, recent.source_type);

                // Mark as seen
                const ids = data.map(m => m.id);
                await supabase
                    .from('sloppygram_mentions')
                    .update({ seen: true })
                    .in('id', ids);

            } catch (err) {
                console.error('Error checking mentions:', err);
            }
        }

        // Show mention notification
        function showMentionNotification(fromUsername, sourceType) {
            const existing = document.querySelector('.mention-notification');
            if (existing) existing.remove();

            const notification = document.createElement('div');
            notification.className = 'mention-notification';
            notification.innerHTML = `@${escapeHtml(fromUsername)} mentioned you in a ${sourceType}`;
            notification.onclick = function() {
                notification.remove();
                // Could scroll to or filter to mentions
                filterChatByMention(profile.username);
            };

            document.body.appendChild(notification);

            setTimeout(() => {
                if (notification.parentNode) notification.remove();
            }, 5000);
        }

        // Get followers list
        async function getFollowers(username, limit = 50) {
            try {
                const { data, error } = await supabase
                    .from('sloppygram_follows')
                    .select('follower_username, created_at')
                    .eq('followed_username', username)
                    .order('created_at', { ascending: false })
                    .limit(limit);

                return data || [];
            } catch (err) {
                console.error('Error getting followers:', err);
                return [];
            }
        }

        // Get following list
        async function getFollowing(username, limit = 50) {
            try {
                const { data, error } = await supabase
                    .from('sloppygram_follows')
                    .select('followed_username, created_at')
                    .eq('follower_username', username)
                    .order('created_at', { ascending: false })
                    .limit(limit);

                return data || [];
            } catch (err) {
                console.error('Error getting following:', err);
                return [];
            }
        }

        // Expose functions globally
        window.followUser = followUser;
        window.unfollowUser = unfollowUser;
        window.isFollowing = isFollowing;
        window.getFollowCounts = getFollowCounts;
        window.saveMentions = saveMentions;

        // Check for mentions periodically (every 30 seconds)
        setInterval(checkForMentions, 30000);
        // Initial check after 5 seconds
        setTimeout(checkForMentions, 5000);

        // === LAZY LOADING OPTIMIZER ===
        let imageObserver = null;

        function initLazyLoading() {
            if (!('IntersectionObserver' in window)) {
                // Fallback: load all images immediately
                document.querySelectorAll('img[data-src]').forEach(img => {
                    img.src = img.dataset.src;
                });
                return;
            }

            imageObserver = new IntersectionObserver((entries, observer) => {
                entries.forEach(entry => {
                    if (entry.isIntersecting) {
                        const img = entry.target;
                        if (img.dataset.src) {
                            img.src = img.dataset.src;
                            img.removeAttribute('data-src');
                            img.classList.remove('loading');
                        }
                        observer.unobserve(img);
                    }
                });
            }, {
                rootMargin: '100px 0px', // Start loading 100px before visible
                threshold: 0.01
            });
        }

        function observeLazyImage(img) {
            if (imageObserver && img.dataset.src) {
                img.classList.add('loading');
                imageObserver.observe(img);
            }
        }

        function lazyLoadNewImages() {
            document.querySelectorAll('img[data-src]:not(.observed)').forEach(img => {
                img.classList.add('observed');
                observeLazyImage(img);
            });
        }

        // Initialize lazy loading on page load
        initLazyLoading();

        // Helper function to log AI events
        async function logAiEvent(eventType, entityType, entityId, metadata = {}) {
            if (!currentUser) return;
            try {
                await supabase.from('ai_events').insert({
                    event_type: eventType,
                    entity_type: entityType,
                    entity_id: entityId,
                    username: profile.username,
                    metadata: metadata,
                    user_id: currentUser.id
                });
            } catch (e) {
                console.error('Error logging AI event:', e);
            }
        }

        // Load saved profile (uses secure storage with obfuscation)
        const savedProfile = secureStorageGet('sloppygram_profile');
        if (savedProfile) {
            profile = savedProfile;
            // Restore status UI if one was saved
            if (profile.status) {
                setTimeout(() => {
                    const statusCurrent = document.getElementById('awayStatusCurrent');
                    const statusText = document.getElementById('currentStatusText');
                    if (statusCurrent && statusText) {
                        statusCurrent.style.display = 'flex';
                        statusText.textContent = profile.status;
                    }
                }, 100);
            }
        }

        // === TOAST NOTIFICATION SYSTEM ===

        function showToast(message, type = 'info', duration = 4000) {
            const container = document.getElementById('toastContainer');
            if (!container) return;

            const icons = {
                success: 'âœ“',
                error: 'âœ•',
                warning: 'âš ',
                info: 'â„¹'
            };

            const toast = document.createElement('div');
            toast.className = `system-toast ${type}`;
            const toastId = 'toast_' + Date.now() + '_' + Math.random().toString(36).slice(2);
            toast.id = toastId;

            toast.innerHTML = `
                <span class="toast-icon">${icons[type] || icons.info}</span>
                <span class="toast-message">${escapeHtml(message)}</span>
                <button class="toast-close" onclick="dismissToast('${toastId}')">&times;</button>
            `;

            container.appendChild(toast);

            // Auto-dismiss after duration
            const timerId = setTimeout(() => {
                dismissToast(toastId);
            }, duration);

            toastTimers.set(toastId, timerId);

            return toastId;
        }

        window.dismissToast = function(toastId) {
            const toast = document.getElementById(toastId);
            if (!toast) return;

            // Clear the timer
            const timerId = toastTimers.get(toastId);
            if (timerId) {
                clearTimeout(timerId);
                toastTimers.delete(toastId);
            }

            // Animate out
            toast.classList.add('fade-out');
            setTimeout(() => {
                toast.remove();
            }, 300);
        };

        // Expose globally for use in other functions
        window.showToast = showToast;

        // === MEMORY LEAK PREVENTION ===
        let presenceChannel = null;
        let postsChannel = null;
        let globalSettingsChannel = null;
        // Note: oracleLogChannel declared in ORACLE LOG section above (hoisted for early use)

        function cleanupChannels() {
            console.log('[Cleanup] Starting full memory cleanup...');

            // Clear all registered intervals and timeouts first
            clearAllTimers();
            console.log('[Cleanup] Timers cleared');

            // Properly unsubscribe and remove Supabase channels
            if (realtimeChannel) {
                try {
                    realtimeChannel.unsubscribe();
                } catch(e) { /* ignore */ }
                supabase.removeChannel(realtimeChannel);
                realtimeChannel = null;
            }
            if (presenceChannel) {
                try {
                    presenceChannel.unsubscribe();
                } catch(e) { /* ignore */ }
                supabase.removeChannel(presenceChannel);
                presenceChannel = null;
            }
            if (postsChannel) {
                try {
                    postsChannel.unsubscribe();
                } catch(e) { /* ignore */ }
                supabase.removeChannel(postsChannel);
                postsChannel = null;
            }
            if (globalSettingsChannel) {
                try {
                    globalSettingsChannel.unsubscribe();
                } catch(e) { /* ignore */ }
                supabase.removeChannel(globalSettingsChannel);
                globalSettingsChannel = null;
            }

            // Clean up SloppyFM channel (CRITICAL fix)
            if (sloppyfmChannel) {
                try {
                    sloppyfmChannel.unsubscribe();
                } catch(e) { /* ignore */ }
                supabase.removeChannel(sloppyfmChannel);
                sloppyfmChannel = null;
            }

            // Clean up Oracle Log channel (CRITICAL fix)
            if (oracleLogChannel) {
                try {
                    oracleLogChannel.unsubscribe();
                } catch(e) { /* ignore */ }
                supabase.removeChannel(oracleLogChannel);
                oracleLogChannel = null;
            }

            console.log('[Cleanup] Supabase channels removed (including SloppyFM & Oracle Log)');
        }

        // Cleanup on page unload
        window.addEventListener('beforeunload', cleanupChannels);
        window.addEventListener('pagehide', cleanupChannels);

        // Reboot System - glitchy reset with visual effect
        window.rebootSystem = async function() {
            // Create overlay
            const overlay = document.createElement('div');
            overlay.className = 'reboot-overlay';
            overlay.innerHTML = `
                <div class="reboot-text">[ SYSTEM REBOOT ]</div>
                <div class="reboot-progress">Flushing memory...</div>
                <div class="reboot-bar"><div class="reboot-bar-fill" style="width: 0%"></div></div>
            `;
            document.body.appendChild(overlay);

            const progressText = overlay.querySelector('.reboot-progress');
            const progressBar = overlay.querySelector('.reboot-bar-fill');

            const steps = [
                { text: 'Flushing message cache...', action: () => { seenMessageIds.clear(); } },
                { text: 'Clearing post memory...', action: () => { posts = []; postLikes = {}; postComments = {}; postReactions = {}; myReactions = {}; postVotes = {}; myPostVotes = {}; postTags = {}; } },
                { text: 'Purging doodle data...', action: () => { doodleVotes = {}; myDoodleVotes = {}; doodleComments = {}; doodleCommentThreads = {}; } },
                { text: 'Wiping manifesto state...', action: () => { manifestos = []; manifestoVotes = {}; myManifestoVotes = {}; manifestoReactions = {}; myManifestoReactions = {}; manifestoComments = {}; manifestoTags = {}; } },
                { text: 'Resetting vote matrices...', action: () => { messageVotes = {}; myMessageVotes = {}; commentVotes = {}; myCommentVotes = {}; } },
                { text: 'Clearing collab canvas...', action: () => { collabStrokes = []; if (collabCtx) collabCtx.clearRect(0, 0, collabCanvas.width, collabCanvas.height); } },
                { text: 'Disconnecting channels...', action: () => { cleanupChannels(); } },
                { text: 'Reinitializing system...', action: () => {} }
            ];

            for (let i = 0; i < steps.length; i++) {
                if (progressText) progressText.textContent = steps[i].text;
                if (progressBar && progressBar.style) progressBar.style.width = ((i + 1) / steps.length * 100) + '%';
                steps[i].action();
                await new Promise(r => setTimeout(r, 300));
            }

            // Final glitch effect
            if (progressText) progressText.textContent = '[ REBOOT COMPLETE ]';
            await new Promise(r => setTimeout(r, 500));

            // Remove overlay and reinitialize
            overlay.remove();

            // Reset channel and data states
            resetChannelStates();
            Object.keys(dataLoadState).forEach(key => {
                dataLoadState[key].loaded = false;
                dataLoadState[key].loading = false;
            });

            // Reload with proper sequencing (mirror init() pattern)
            console.log('[Reboot] Phase 1: Loading vote data...');
            await Promise.all([
                loadDoodleVotes(),
                loadMessageVotes(),
                loadMessageReactions(),
                loadCommentVotes()
            ]);
            markDataLoaded('votes');

            console.log('[Reboot] Phase 2: Loading data...');
            await loadMessages();
            loadPosts();
            loadManifestos();
            loadDoodleLeaderboard();

            console.log('[Reboot] Phase 3: Starting subscriptions...');
            await Promise.all([
                subscribeToMessages(),
                subscribeToPostsAndComments(),
                setupPresence()
            ]);

            console.log('[Reboot] Complete');
            showToast('System rebooted successfully', 'success');
        };

        // Compatibility debugger - checks browser support for required features
        window.checkCompatibility = function() {
            var results = [];
            var passed = 0;
            var failed = 0;

            // Check for required features
            var checks = [
                { name: 'Promise', test: function() { return typeof Promise !== 'undefined'; } },
                { name: 'fetch API', test: function() { return typeof fetch !== 'undefined'; } },
                { name: 'localStorage', test: function() { return typeof localStorage !== 'undefined'; } },
                { name: 'IntersectionObserver', test: function() { return 'IntersectionObserver' in window; } },
                { name: 'Canvas 2D', test: function() { var c = document.createElement('canvas'); return !!(c.getContext && c.getContext('2d')); } },
                { name: 'Web Audio', test: function() { return !!(window.AudioContext || window.webkitAudioContext); } },
                { name: 'Clipboard API', test: function() { return !!(navigator.clipboard && navigator.clipboard.writeText); } },
                { name: 'CSS Variables', test: function() { return window.CSS && window.CSS.supports && window.CSS.supports('--test', '0'); } },
                { name: 'Flexbox', test: function() { return window.CSS && window.CSS.supports && window.CSS.supports('display', 'flex'); } },
                { name: 'Grid', test: function() { return window.CSS && window.CSS.supports && window.CSS.supports('display', 'grid'); } }
            ];

            for (var i = 0; i < checks.length; i++) {
                var check = checks[i];
                var supported = false;
                try {
                    supported = check.test();
                } catch (e) {
                    supported = false;
                }
                if (supported) {
                    passed++;
                    results.push('[âœ“] ' + check.name);
                } else {
                    failed++;
                    results.push('[âœ—] ' + check.name);
                }
            }

            var summary = '\n=== COMPATIBILITY REPORT ===\n' +
                results.join('\n') +
                '\n\nPassed: ' + passed + '/' + checks.length +
                (failed > 0 ? '\nWARNING: ' + failed + ' feature(s) not supported' : '\nAll features supported!');

            console.log(summary);
            showToast('Compatibility: ' + passed + '/' + checks.length + ' features OK', failed > 0 ? 'warning' : 'success');
            return { passed: passed, failed: failed, total: checks.length, details: results };
        };

        // === BOOT AUDIT ===
        // Verifies system state after initialization
        window.bootAudit = function() {
            console.log('\n=== SYSTEM BOOT AUDIT ===\n');

            var results = [];
            var passed = 0;
            var failed = 0;

            // Channel State Checks
            var channelChecks = [
                { name: 'Realtime Channel', check: () => channelState.realtime.ready },
                { name: 'Presence Channel', check: () => channelState.presence.ready },
                { name: 'Posts Channel', check: () => channelState.posts.ready },
                { name: 'Feedback Channel', check: () => channelState.feedback.ready },
                { name: 'Global Settings Channel', check: () => channelState.globalSettings.ready }
            ];

            console.log('[Channels]');
            channelChecks.forEach(c => {
                var ok = c.check();
                if (ok) passed++; else failed++;
                var status = ok ? 'âœ“' : 'âœ—';
                console.log('  [' + status + '] ' + c.name + ': ' + (ok ? 'SUBSCRIBED' : 'NOT READY'));
                results.push({ type: 'channel', name: c.name, ok: ok });
            });

            // Data State Checks
            var dataChecks = [
                { name: 'Messages', check: () => dataLoadState.messages.loaded },
                { name: 'Posts', check: () => dataLoadState.posts.loaded },
                { name: 'Votes', check: () => dataLoadState.votes.loaded }
            ];

            console.log('\n[Data]');
            dataChecks.forEach(c => {
                var ok = c.check();
                if (ok) passed++; else failed++;
                var status = ok ? 'âœ“' : 'âœ—';
                console.log('  [' + status + '] ' + c.name + ': ' + (ok ? 'LOADED' : 'NOT LOADED'));
                results.push({ type: 'data', name: c.name, ok: ok });
            });

            // Memory Registry Checks
            console.log('\n[Memory Registry]');
            console.log('  Active Intervals: ' + activeIntervals.size);
            console.log('  Active Timeouts: ' + activeTimeouts.size);
            console.log('  Toast Timers: ' + toastTimers.size);

            // Swipe Listeners
            console.log('\n[Event Listeners]');
            console.log('  Swipe Initialized: ' + (swipeListenersInitialized ? 'Yes' : 'No'));
            console.log('  Swipe Cleanup Fns: ' + swipeCleanupFns.length);

            // DOM Cache
            console.log('\n[DOM Cache]');
            console.log('  Cached Elements: ' + domCache.size);
            if (domCache.size > 0) {
                var cachedIds = [];
                domCache.forEach((el, id) => cachedIds.push(id));
                console.log('  IDs: ' + cachedIds.join(', '));
            }

            // Cognitive Engine (manifesto alignment)
            console.log('\n[Cognitive Engine]');
            console.log('  Mode: ' + cognitiveState.mode);
            console.log('  Status: ' + cognitiveState.status);
            console.log('  Temperature: ' + cognitiveState.temperature);
            console.log('  Confidence: ' + cognitiveState.lastConfidence);
            console.log('  Recursion: ' + cognitiveState.recursionDepth + '/' + cognitiveState.maxRecursionDepth);
            console.log('  Variance Log: ' + cognitiveState.varianceLog.length + ' entries');
            var cogOk = cognitiveState.status === 'VERIFIED' && cognitiveState.lastConfidence >= 0.95;
            if (cogOk) passed++; else failed++;
            results.push({ type: 'cognitive', name: 'Engine Status', ok: cogOk });

            // Summary
            var total = passed + failed;
            console.log('\n=== AUDIT SUMMARY ===');
            console.log('Passed: ' + passed + '/' + total);
            if (failed > 0) {
                console.log('FAILED: ' + failed + ' check(s)');
            } else {
                console.log('All systems nominal.');
            }

            showToast('Boot Audit: ' + passed + '/' + total + ' OK', failed > 0 ? 'warning' : 'success');
            return { passed: passed, failed: failed, total: total, results: results };
        };

        // Initialize
        async function init() {
            // Listen for auth state changes
            supabase.auth.onAuthStateChange((event, session) => {
                console.log('Auth state changed:', event);
                if (session) {
                    currentUser = session.user;
                }
            });

            // Auth - try to restore existing session first
            let { data: { session } } = await supabase.auth.getSession();
            if (!session) {
                console.log('No existing session, signing in anonymously...');
                const { data, error } = await supabase.auth.signInAnonymously();
                if (error) console.error('Auth error:', error);
                session = (data && data.session) ? data.session : null;
            } else {
                console.log('Restored existing session for user:', session.user ? session.user.id : 'unknown');
            }
            currentUser = (session && session.user) ? session.user : null;

            // Load profile from sloppygram_profiles (single source of truth)
            if (currentUser) {
                try {
                    var { data: dbProfile, error: profileErr } = await supabase
                        .from('sloppygram_profiles')
                        .select('username, avatar, bio, color')
                        .eq('user_id', currentUser.id)
                        .single();

                    if (!profileErr && dbProfile) {
                        if (dbProfile.username) profile.username = dbProfile.username;
                        if (dbProfile.avatar) {
                            // Detect if avatar is a URL or emoji
                            if (dbProfile.avatar.startsWith('http') || dbProfile.avatar.startsWith('data:')) {
                                profile.avatarUrl = dbProfile.avatar;
                            } else {
                                profile.avatar = dbProfile.avatar;
                            }
                        }
                        if (dbProfile.color) profile.color = dbProfile.color;
                        if (dbProfile.bio) profile.status = dbProfile.bio;
                        console.log('[Profile] Loaded from sloppygram_profiles:', profile.username);

                        // Sync to localStorage so offline fallback stays current
                        secureStorageSet('sloppygram_profile', profile);

                        // Restore status UI if set
                        if (profile.status) {
                            setTimeout(function() {
                                var statusCurrent = document.getElementById('awayStatusCurrent');
                                var statusText = document.getElementById('currentStatusText');
                                if (statusCurrent && statusText) {
                                    statusCurrent.style.display = 'flex';
                                    statusText.textContent = profile.status;
                                }
                            }, 100);
                        }
                    }
                } catch (e) {
                    console.warn('[Profile] sloppygram_profiles load failed, using localStorage fallback:', e);
                }
            }

            setupAvatarGrid();
            setupColorOptions();
            setupBrushColors();
            setupDrawingCanvas();
            loadMessageOpacity();
            loadWidgetOpacity();
            loadThemeSettings();
            initLocalThemeMode(); // Restore local theme mode toggle and apply local background
            // Load saved sound settings (uses secure storage with obfuscation)
            const savedSounds = secureStorageGet('sloppygram_sounds');
            if (savedSounds) {
                soundSettings = savedSounds;
            }
            // === PHASE 1: Load vote/reaction data (needed before rendering) ===
            setCognitiveStatus('ACTIVE');
            console.log('[Boot] Phase 1: Loading vote data...');
            await Promise.all([
                loadDoodleVotes(),
                loadMessageVotes(),
                loadMessageReactions(),
                loadCommentVotes()
            ]);
            markDataLoaded('votes');
            console.log('[Boot] Phase 1 complete: votes loaded');

            // === PHASE 2: Load initial data ===
            console.log('[Boot] Phase 2: Loading initial data...');
            await loadMessages(); // This now marks messages as loaded
            console.log('[Boot] Phase 2 complete: messages loaded');

            // === PHASE 3: Start real-time subscriptions (after data is loaded) ===
            console.log('[Boot] Phase 3: Starting real-time subscriptions...');
            await Promise.all([
                subscribeToMessages(),
                subscribeToPostsAndComments(),
                setupPresence(),
                subscribeToGlobalSettings()
            ]);
            console.log('[Boot] Phase 3 complete: all channels subscribed');

            // === PHASE 4: Warm caches ===
            warmDomCache();
            setCognitiveStatus('VERIFIED');
            cognitiveState.lastConfidence = 1.0;
            console.log('[Boot] Cognitive Engine: Online. Confidence: 1.0');

            applyCustomBackground();

            // Load global settings (non-blocking)
            loadGlobalSettings();

            // Random visitor count for 90s vibes
            var visitorCountEl = document.getElementById('visitorCount');
            if (visitorCountEl) {
                visitorCountEl.textContent = Math.floor(10000 + Math.random() * 90000);
            }

            // Auto-resize textarea
            const input = getCachedElement('messageInput');
            input.addEventListener('input', () => {
                input.style.height = 'auto';
                input.style.height = Math.min(input.scrollHeight, 100) + 'px';
            });

            // Enter to send
            input.addEventListener('keydown', (e) => {
                if (e.key === 'Enter' && !e.shiftKey) {
                    e.preventDefault();
                    sendMessage();
                }
            });

            // Infinite scroll for messages (load older messages when scrolling down)
            const messagesContainer = getCachedElement('messagesContainer');
            messagesContainer.addEventListener('scroll', () => {
                const { scrollTop, scrollHeight, clientHeight } = messagesContainer;
                // Load more when near bottom (older messages are at bottom)
                if (scrollHeight - scrollTop - clientHeight < 200) {
                    loadMessages(true);
                }
            });

            // Infinite scroll for posts
            const postsContainer = getCachedElement('postsContainer');
            postsContainer.addEventListener('scroll', () => {
                const { scrollTop, scrollHeight, clientHeight } = postsContainer;
                if (scrollHeight - scrollTop - clientHeight < 200) {
                    loadMorePosts();
                }
            });
        }

        // Load more posts for infinite scroll
        async function loadMorePosts() {
            if (postsLoading || !postsHasMore) return;
            postsLoading = true;

            const container = getCachedElement('postsContainer');
            const loader = document.createElement('div');
            loader.className = 'loading-indicator';
            loader.id = 'postsLoader';
            loader.textContent = 'Loading more posts...';
            container.appendChild(loader);

            const from = postsPage * PAGE_SIZE;
            const to = from + PAGE_SIZE - 1;

            const { data, error } = await supabase
                .from('sloppygram_posts')
                .select('id, username, avatar, avatar_url, caption, image_url, image_data, likes_count, created_at')
                .order('created_at', { ascending: false })
                .range(from, to);

            var postsLoaderEl = document.getElementById('postsLoader');
            if (postsLoaderEl) postsLoaderEl.remove();
            postsLoading = false;

            if (error || !data) return;

            postsHasMore = data.length === PAGE_SIZE;
            postsPage++;

            // Add new posts to existing array and re-render
            posts = [...posts, ...data];

            // Need to reload related data for new posts
            const newPostIds = data.map(p => p.id);
            if (newPostIds.length > 0) {
                await loadPostRelatedData(newPostIds);
            }

            renderPosts();
        }

        // Load related data (votes, comments, etc.) for specific post IDs
        async function loadPostRelatedData(postIds) {
            const [votesResult, commentsResult, reactionsResult, tagsResult, threadsResult] = await Promise.all([
                supabase.from('sloppygram_post_likes').select('post_id, username, vote_type').in('post_id', postIds),
                supabase.from('sloppygram_post_comments').select('id, post_id, username, avatar, content, created_at').in('post_id', postIds).order('created_at', { ascending: true }),
                supabase.from('sloppygram_post_reactions').select('id, post_id, emoji, username').in('post_id', postIds),
                supabase.from('sloppygram_post_tags').select('id, post_id, tag, parent_tag').in('post_id', postIds),
                supabase.from('sloppygram_comment_threads').select('comment_id, parent_comment_id, comment_type, post_id').eq('comment_type', 'post').in('post_id', postIds)
            ]);

            // Process and merge votes
            (votesResult.data || []).forEach(vote => {
                postVotes[vote.post_id] = (postVotes[vote.post_id] || 0) + (vote.vote_type || 1);
                if (vote.username === profile.username) {
                    myPostVotes[vote.post_id] = vote.vote_type || 1;
                }
            });

            // Process comments
            (commentsResult.data || []).forEach(comment => {
                if (!postComments[comment.post_id]) postComments[comment.post_id] = [];
                postComments[comment.post_id].push(comment);
            });

            // Process reactions
            (reactionsResult.data || []).forEach(r => {
                if (!postReactions[r.post_id]) postReactions[r.post_id] = {};
                postReactions[r.post_id][r.emoji] = (postReactions[r.post_id][r.emoji] || 0) + 1;
                if (r.username === profile.username) {
                    if (!myReactions[r.post_id]) myReactions[r.post_id] = new Set();
                    myReactions[r.post_id].add(r.emoji);
                }
            });

            // Process tags
            (tagsResult.data || []).forEach(t => {
                if (!postTags[t.post_id]) postTags[t.post_id] = [];
                postTags[t.post_id].push({ tag: t.tag, parent_tag: t.parent_tag });
            });

            // Process comment threads
            (threadsResult.data || []).forEach(t => {
                commentThreads[t.comment_id] = t.parent_comment_id;
            });
        }

        // Presence for online users
        async function setupPresence() {
            // Clean up existing presence channel if any
            if (presenceChannel) {
                channelState.presence.ready = false;
                presenceChannel.unsubscribe();
                supabase.removeChannel(presenceChannel);
            }

            presenceChannel = supabase.channel('sloppygram_presence', {
                config: {
                    presence: { key: (currentUser && currentUser.id) ? currentUser.id : 'anon_' + Math.random() }
                }
            });

            presenceChannel
                .on('presence', { event: 'sync' }, () => {
                    const state = presenceChannel.presenceState();
                    updateOnlineUsers(state);
                    updateGhostRadar(state);
                })
                .on('presence', { event: 'join' }, ({ key, newPresences }) => {
                    var joinUser = (newPresences && newPresences[0] && newPresences[0].username) ? newPresences[0].username : 'Someone';
                    addToFeed(joinUser, 'joined the chat');
                    // Welcome bot greets new users
                    welcomeNewUser(joinUser, newPresences);
                })
                .on('presence', { event: 'leave' }, ({ key, leftPresences }) => {
                    var leftUser = (leftPresences && leftPresences[0] && leftPresences[0].username) ? leftPresences[0].username : 'Someone';
                    addToFeed(leftUser, 'left the chat');
                });

            // Use Promise-based subscription with state tracking and track user
            return new Promise((resolve) => {
                presenceChannel.subscribe(async (status) => {
                    if (status === 'SUBSCRIBED') {
                        console.log('[Channel] Ready: presence');
                        channelState.presence.ready = true;
                        await presenceChannel.track({
                            username: profile.username,
                            avatar: profile.avatar,
                            avatarUrl: profile.avatarUrl || null,
                            color: profile.color,
                            status: profile.status || '',
                            online_at: new Date().toISOString()
                        });
                        resolve(true);
                    } else if (status === 'CHANNEL_ERROR' || status === 'TIMED_OUT') {
                        console.error('[Channel] Error: presence', status);
                        channelState.presence.ready = false;
                        resolve(false);
                    }
                });
            });
        }

        // === WELCOME BOT ===
        var welcomeMessages = [
            "Welcome to the Archive, {user}! ðŸŒŸ Make yourself at home.",
            "Hey {user}! Great to see you here. Drop a message or doodle!",
            "{user} has entered the synthesis. Welcome, traveler! âœ¨",
            "A wild {user} appeared! Welcome to The Archive! ðŸŽ®",
            "Greetings, {user}! The archive grows with your presence. ðŸ“š",
            "{user} just joined the party! ðŸŽ‰ Say hi everyone!",
            "Welcome aboard, {user}! Feel free to react, post, or just vibe. ðŸŒŠ",
            "The void welcomes you, {user}. Leave your mark. ðŸ–¤",
            "Oh snap, it's {user}! Welcome to the chaos. ðŸ’«",
            "{user} has synced with the collective. Hello, friend! ðŸ¤"
        ];

        var welcomedUsers = {}; // Track who we've welcomed to avoid spam

        function welcomeNewUser(username, presences) {
            // Don't welcome ourselves
            if (username === profile.username) return;

            // Don't welcome the same user twice in a session
            if (welcomedUsers[username]) return;
            welcomedUsers[username] = true;

            // Small delay so the message appears after "joined" notification
            setTimeout(function() {
                var msg = welcomeMessages[Math.floor(Math.random() * welcomeMessages.length)];
                msg = msg.replace('{user}', username);

                // Add bot message to UI only (not saved to database)
                addBotMessageToUI('WelcomeBot', 'ðŸ¤–', msg);
            }, 1500);
        }

        function addBotMessageToUI(botName, avatar, content) {
            var container = getCachedElement('messagesContainer');
            if (!container) return;

            var div = document.createElement('div');
            div.className = 'message bot-message';

            var time = new Date().toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });

            div.innerHTML =
                '<div class="avatar" style="background:linear-gradient(135deg, #7c9885, #5a7a63);">' + avatar + '</div>' +
                '<div class="message-bubble" style="border-left:2px solid var(--accent);">' +
                    '<div class="message-header">' +
                        '<span class="message-username" style="color:var(--accent);">' + escapeHtml(botName) + '</span>' +
                        '<span class="message-time">' + time + '</span>' +
                    '</div>' +
                    '<div class="message-content">' + escapeHtml(content) + '</div>' +
                '</div>';

            container.appendChild(div);
            container.scrollTop = container.scrollHeight;

            // Play a subtle sound
            playNotificationSound();
        }

        // Update presence with new status
        async function updatePresenceStatus() {
            if (presenceChannel) {
                await presenceChannel.track({
                    username: profile.username,
                    avatar: profile.avatar,
                    avatarUrl: profile.avatarUrl || null,
                    color: profile.color,
                    status: profile.status || '',
                    online_at: new Date().toISOString()
                });
            }
        }

        window.setAwayStatus = function() {
            const input = document.getElementById('awayStatusInput');
            if (!input) return;
            const status = input.value.trim();
            if (status) {
                profile.status = status;
                secureStorageSet('sloppygram_profile', profile);
                updatePresenceStatus();
                // Update UI
                var statusCurrent = document.getElementById('awayStatusCurrent');
                var statusText = document.getElementById('currentStatusText');
                if (statusCurrent) statusCurrent.style.display = 'flex';
                if (statusText) statusText.textContent = status;
                input.value = '';
                showToast('Status set: ' + status);
            }
        };

        window.clearAwayStatus = function() {
            profile.status = '';
            secureStorageSet('sloppygram_profile', profile);
            updatePresenceStatus();
            // Update UI
            var statusCurrent = document.getElementById('awayStatusCurrent');
            var statusText = document.getElementById('currentStatusText');
            var statusInput = document.getElementById('awayStatusInput');
            if (statusCurrent) statusCurrent.style.display = 'none';
            if (statusText) statusText.textContent = '';
            if (statusInput) statusInput.value = '';
            showToast('Status cleared');
        };

        function updateOnlineUsers(state) {
            const userList = document.getElementById('userList');
            const users = [];

            // Add real users
            Object.values(state).forEach(presences => {
                presences.forEach(p => {
                    if (!users.find(u => u.username === p.username)) {
                        users.push(p);
                    }
                });
            });

            userList.innerHTML = users.map(u => {
                const safeAvatarUrl = sanitizeUrl(u.avatarUrl);
                const avatarContent = safeAvatarUrl
                    ? `<img src="${safeAvatarUrl}" style="width:24px;height:24px;border-radius:50%;object-fit:cover;">`
                    : u.avatar;
                const statusHtml = u.status
                    ? `<span class="user-away-status">${escapeHtml(u.status)}</span>`
                    : '';
                return `
                <li class="user-item">
                    <span class="user-status"></span>
                    <span class="user-avatar">${avatarContent}</span>
                    <div class="user-item-content">
                        <span class="user-name" style="color: ${u.color || 'var(--accent-light)'}">${escapeHtml(u.username)}</span>
                        ${statusHtml}
                    </div>
                </li>
            `}).join('');
        }

        function addToFeed(user, action) {
            const feed = document.getElementById('publicFeed');
            const time = new Date().toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });

            const item = document.createElement('div');
            item.className = 'feed-item';
            item.innerHTML = `
                <span class="feed-user username-clickable" onclick="showProfileCard('${escapeHtml(user)}', event)">${escapeHtml(user)}</span>
                <span class="feed-action">${action}</span>
                <div class="feed-time">${time}</div>
            `;

            feed.insertBefore(item, feed.firstChild);

            // Keep only last 20 items
            while (feed.children.length > 20) {
                feed.removeChild(feed.lastChild);
            }
        }

        // Setup avatar grid (disabled - profile editing moved to SloppyID)
        function setupAvatarGrid() {
            const grid = document.getElementById('avatarGrid');
            if (!grid) return; // Grid removed - editing via SloppyID
            grid.innerHTML = AVATARS.map(a =>
                `<button class="avatar-option ${a === profile.avatar ? 'selected' : ''}" onclick="selectAvatar('${a}')">${a}</button>`
            ).join('');
        }

        window.selectAvatar = function(avatar) {
            profile.avatar = avatar;
            document.querySelectorAll('.avatar-option').forEach(el => {
                el.classList.toggle('selected', el.textContent === avatar);
            });
        };

        // Setup color options (disabled - profile editing moved to SloppyID)
        function setupColorOptions() {
            const container = document.getElementById('colorOptions');
            if (!container) return; // Container removed - editing via SloppyID
            container.innerHTML = COLORS.map(c =>
                `<button class="color-option ${c === profile.color ? 'selected' : ''}" style="background: ${c}" onclick="selectColor('${c}')"></button>`
            ).join('');
        }

        window.selectColor = function(color) {
            profile.color = color;
            document.querySelectorAll('.color-option').forEach(el => {
                el.classList.toggle('selected', el.style.background === color);
            });
        };

        // Setup brush colors
        function setupBrushColors() {
            const container = document.getElementById('brushColors');
            container.innerHTML = BRUSH_COLORS.map(c =>
                `<button class="brush-color ${c === brushColor ? 'selected' : ''}" style="background: ${c}" onclick="selectBrushColor('${c}')"></button>`
            ).join('');
        }

        window.selectBrushColor = function(color) {
            brushColor = color;
            document.querySelectorAll('.brush-color').forEach(el => {
                el.classList.toggle('selected', el.style.background === color);
            });
        };

        // Drawing canvas
        var drawingCanvasInitialized = false;
        function setupDrawingCanvas() {
            if (drawingCanvasInitialized) return;
            drawingCanvasInitialized = true;

            const canvas = getCachedElement('drawingCanvas');
            if (!canvas) return;
            drawingCtx = canvas.getContext('2d');
            if (!drawingCtx) {
                console.error('[Drawing] Failed to get canvas 2d context');
                return;
            }
            drawingCtx.fillStyle = '#111';
            drawingCtx.fillRect(0, 0, canvas.width, canvas.height);
            drawingCtx.lineCap = 'round';
            drawingCtx.lineJoin = 'round';
            drawingCtx.lineWidth = 4;

            canvas.addEventListener('mousedown', startDrawing);
            canvas.addEventListener('mousemove', draw);
            canvas.addEventListener('mouseup', stopDrawing);
            canvas.addEventListener('mouseout', stopDrawing);

            canvas.addEventListener('touchstart', (e) => {
                e.preventDefault();
                const touch = e.touches[0];
                const rect = canvas.getBoundingClientRect();
                const offsetX = touch.clientX - rect.left;
                const offsetY = touch.clientY - rect.top;
                startDrawing({ offsetX, offsetY });
            }, { passive: false });

            canvas.addEventListener('touchmove', (e) => {
                e.preventDefault();
                const touch = e.touches[0];
                const rect = canvas.getBoundingClientRect();
                const offsetX = touch.clientX - rect.left;
                const offsetY = touch.clientY - rect.top;
                draw({ offsetX, offsetY });
            }, { passive: false });

            canvas.addEventListener('touchend', stopDrawing);
        }

        function getCanvasCoords(e) {
            const canvas = getCachedElement('drawingCanvas');
            const rect = canvas.getBoundingClientRect();
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;
            return {
                x: e.offsetX * scaleX,
                y: e.offsetY * scaleY
            };
        }

        function startDrawing(e) {
            isDrawing = true;
            const coords = getCanvasCoords(e);
            drawingCtx.beginPath();
            drawingCtx.moveTo(coords.x, coords.y);
        }

        function draw(e) {
            if (!isDrawing) return;
            const coords = getCanvasCoords(e);
            drawingCtx.strokeStyle = brushColor;
            drawingCtx.lineTo(coords.x, coords.y);
            drawingCtx.stroke();
        }

        function stopDrawing() {
            if (isDrawing) {
                isDrawing = false;
                saveCanvasState(); // Save state after each stroke
            }
        }

        window.clearCanvas = function() {
            const canvas = getCachedElement('drawingCanvas');
            drawingCtx.fillStyle = '#111';
            drawingCtx.fillRect(0, 0, canvas.width, canvas.height);
            resetCanvasHistory(); // Reset undo history on clear
        };

        // Load messages (newest first, at top)
        async function loadMessages(loadMore = false) {
            if (messagesLoading) return;
            if (loadMore && !messagesHasMore) return;

            messagesLoading = true;
            if (!loadMore) markDataLoading('messages');
            const container = getCachedElement('messagesContainer');

            // Show loading indicator
            if (loadMore) {
                const loader = document.createElement('div');
                loader.className = 'loading-indicator';
                loader.id = 'messagesLoader';
                loader.textContent = 'Loading...';
                container.appendChild(loader);
            }

            const from = loadMore ? messagesPage * PAGE_SIZE : 0;
            const to = from + PAGE_SIZE - 1;

            const { data, error } = await supabase
                .from('sloppygram_messages')
                .select('id, username, avatar, avatar_url, content, image_data, drawing_data, message_type, created_at')
                .order('created_at', { ascending: false })
                .range(from, to);

            // Remove loading indicator
            const loader = document.getElementById('messagesLoader');
            if (loader) loader.remove();

            messagesLoading = false;

            if (error) {
                console.error('Load error:', error);
                if (!loadMore) markDataLoaded('messages'); // Mark loaded even on error
                return;
            }

            const emptyState = getCachedElement('emptyState');

            if (!loadMore && data.length === 0) {
                if (emptyState) emptyState.style.display = 'block';
                markDataLoaded('messages'); // Mark loaded even if empty
                return;
            }

            if (emptyState) emptyState.style.display = 'none';

            // Check if there are more messages
            messagesHasMore = data.length === PAGE_SIZE;
            if (loadMore) {
                messagesPage++;
            } else {
                messagesPage = 1;
            }

            // Cache messages for filtering (reset on initial load)
            if (!loadMore) window.cachedMessages = [];
            if (!window.cachedMessages) window.cachedMessages = [];

            data.forEach(msg => {
                if (!seenMessageIds.has(msg.id)) {
                    seenMessageIds.add(msg.id);
                    window.cachedMessages.push(msg);
                    addMessageToUI(msg, false); // append at end (older messages)
                }
            });

            // Scroll to top only on initial load
            if (!loadMore) {
                container.scrollTop = 0;
                markDataLoaded('messages');
            }
        }

        // Subscribe to new messages
        async function subscribeToMessages() {
            // Clean up existing channel
            if (realtimeChannel) {
                channelState.realtime.ready = false;
                realtimeChannel.unsubscribe();
                supabase.removeChannel(realtimeChannel);
            }

            realtimeChannel = supabase.channel('sloppygram-global', {
                config: {
                    broadcast: { self: false }
                }
            });

            realtimeChannel.on('broadcast', { event: 'new_message' }, (payload) => {
                // Guard: only process if messages data is loaded
                if (!isDataReady('messages')) {
                    console.log('[RT] Ignoring broadcast - messages not loaded yet');
                    return;
                }
                const msg = payload.payload;
                if (!msg || seenMessageIds.has(msg.id)) return;
                seenMessageIds.add(msg.id);
                // Cache for filtering
                if (!window.cachedMessages) window.cachedMessages = [];
                window.cachedMessages.unshift(msg);
                addMessageToUI(msg, true); // prepend new messages at top
                addToFeed(msg.username, 'sent a message');
                // Play sound for messages from others
                var currentUserId = (currentUser && currentUser.id) ? currentUser.id : null;
                if (msg.user_id !== currentUserId) {
                    playNotificationSound();
                }
            });

            // Listen for global background changes
            realtimeChannel.on('broadcast', { event: 'global_background' }, (payload) => {
                const bgData = payload.payload;
                if (bgData && bgData.image_data) {
                    // Skip if user has local mode enabled
                    if (isLocalThemeMode && localBackground) {
                        console.log('[Local Mode] Ignoring global background change from', bgData.username);
                        addToFeed(bgData.username || 'Someone', 'changed the chat background (you have local override)');
                        return;
                    }

                    // Anti-strobe protection: throttle rapid incoming visual changes
                    const now = Date.now();
                    if (now - lastVisualChangeTime < VISUAL_CHANGE_COOLDOWN) {
                        console.warn('[Anti-strobe] Blocked rapid background change from', bgData.username);
                        return;
                    }
                    lastVisualChangeTime = now;

                    const msgContainer = getCachedElement('messagesContainer');
                    if (msgContainer) {
                        msgContainer.style.backgroundImage = 'url(' + bgData.image_data + ')';
                        msgContainer.style.backgroundSize = 'cover';
                        msgContainer.style.backgroundPosition = 'center';
                        msgContainer.style.backgroundAttachment = 'fixed';
                        msgContainer.style.backgroundRepeat = 'no-repeat';
                    }
                    addToFeed(bgData.username || 'Someone', 'changed the chat background');
                }
            });

            realtimeChannel.on('postgres_changes', {
                event: 'INSERT',
                schema: 'public',
                table: 'sloppygram_messages'
            }, (payload) => {
                // Guard: only process if messages data is loaded
                if (!isDataReady('messages')) {
                    console.log('[RT] Ignoring postgres_changes - messages not loaded yet');
                    return;
                }
                if (seenMessageIds.has(payload.new.id)) return;
                seenMessageIds.add(payload.new.id);
                // Cache for filtering
                if (!window.cachedMessages) window.cachedMessages = [];
                window.cachedMessages.unshift(payload.new);
                addMessageToUI(payload.new, true); // prepend new messages at top
                // Play sound for messages from others
                var currentUserId2 = (currentUser && currentUser.id) ? currentUser.id : null;
                if (payload.new.user_id !== currentUserId2) {
                    playNotificationSound();
                }
            });

            // Use Promise-based subscription with state tracking
            channelState.realtime.pending = subscribeWithPromise(realtimeChannel, 'realtime');
            await channelState.realtime.pending;
        }

        // Subscribe to posts and comments for real-time updates
        async function subscribeToPostsAndComments() {
            // Clean up existing channel
            if (postsChannel) {
                channelState.posts.ready = false;
                postsChannel.unsubscribe();
                supabase.removeChannel(postsChannel);
            }

            postsChannel = supabase.channel('sloppygram-posts-realtime');

            // Listen for new posts
            postsChannel.on('postgres_changes', {
                event: 'INSERT',
                schema: 'public',
                table: 'sloppygram_posts'
            }, (payload) => {
                // Guard: only process if posts data is loaded
                if (!isDataReady('posts')) {
                    console.log('[RT] Ignoring new post - posts not loaded yet');
                    return;
                }
                console.log('New post received:', payload.new);
                // Add to posts array if not already there
                if (!posts.find(p => p.id === payload.new.id)) {
                    posts.unshift(payload.new);
                    window.cachedPosts = posts; // Keep global cache in sync
                    if (currentView === 'posts') {
                        renderPosts();
                    }
                }
            });

            // Listen for new comments
            postsChannel.on('postgres_changes', {
                event: 'INSERT',
                schema: 'public',
                table: 'sloppygram_post_comments'
            }, (payload) => {
                console.log('New comment received:', payload.new);
                const comment = payload.new;
                if (!postComments[comment.post_id]) {
                    postComments[comment.post_id] = [];
                }
                // Add if not already there
                if (!postComments[comment.post_id].find(c => c.id === comment.id)) {
                    postComments[comment.post_id].push(comment);
                    if (currentView === 'posts') {
                        renderPosts();
                    }
                }
            });

            // Listen for comment thread relationships
            postsChannel.on('postgres_changes', {
                event: 'INSERT',
                schema: 'public',
                table: 'sloppygram_comment_threads'
            }, (payload) => {
                console.log('New thread relationship:', payload.new);
                const thread = payload.new;
                commentThreads[thread.comment_id] = thread.parent_comment_id;
                if (currentView === 'posts') {
                    renderPosts();
                }
            });

            // Listen for new reactions
            postsChannel.on('postgres_changes', {
                event: '*',
                schema: 'public',
                table: 'sloppygram_post_reactions'
            }, (payload) => {
                console.log('Reaction change:', payload);
                // Reload reactions for affected post
                var newPostId = (payload.new && payload.new.post_id) ? payload.new.post_id : null;
                var oldPostId = (payload.old && payload.old.post_id) ? payload.old.post_id : null;
                if (newPostId || oldPostId) {
                    loadPosts(); // Simple reload for now
                }
            });

            // Listen for likes
            postsChannel.on('postgres_changes', {
                event: '*',
                schema: 'public',
                table: 'sloppygram_post_likes'
            }, (payload) => {
                console.log('Like change:', payload);
                var newPostId2 = (payload.new && payload.new.post_id) ? payload.new.post_id : null;
                var oldPostId2 = (payload.old && payload.old.post_id) ? payload.old.post_id : null;
                if (newPostId2 || oldPostId2) {
                    loadPosts();
                }
            });

            // Listen for manifesto comments
            postsChannel.on('postgres_changes', {
                event: 'INSERT',
                schema: 'public',
                table: 'sloppygram_manifesto_comments'
            }, (payload) => {
                console.log('New manifesto comment:', payload.new);
                const comment = payload.new;
                if (!manifestoComments[comment.manifesto_id]) {
                    manifestoComments[comment.manifesto_id] = [];
                }
                if (!manifestoComments[comment.manifesto_id].find(c => c.id === comment.id)) {
                    manifestoComments[comment.manifesto_id].push(comment);
                    if (currentView === 'manifesto') {
                        renderManifestos();
                    }
                }
            });

            // Listen for new manifestos
            postsChannel.on('postgres_changes', {
                event: 'INSERT',
                schema: 'public',
                table: 'sloppygram_manifestos'
            }, (payload) => {
                console.log('New manifesto:', payload.new);
                if (!manifestos.find(m => m.id === payload.new.id)) {
                    manifestos.unshift(payload.new);
                    window.cachedManifestos = manifestos; // Keep global cache in sync
                    if (currentView === 'manifesto') {
                        renderManifestos();
                    }
                }
            });

            // Listen for manifesto votes
            postsChannel.on('postgres_changes', {
                event: '*',
                schema: 'public',
                table: 'sloppygram_manifesto_votes'
            }, (payload) => {
                console.log('Manifesto vote change:', payload);
                loadManifestos();
            });

            // Listen for manifesto reactions
            postsChannel.on('postgres_changes', {
                event: '*',
                schema: 'public',
                table: 'sloppygram_manifesto_reactions'
            }, (payload) => {
                console.log('Manifesto reaction change:', payload);
                loadManifestos();
            });

            // Listen for doodle votes
            postsChannel.on('postgres_changes', {
                event: '*',
                schema: 'public',
                table: 'sloppygram_doodle_votes'
            }, (payload) => {
                console.log('Doodle vote change:', payload);
                loadDoodleVotes();
                if (currentView === 'doodles') {
                    loadDoodleLeaderboard();
                }
            });

            // Listen for post tags (trending tags)
            postsChannel.on('postgres_changes', {
                event: '*',
                schema: 'public',
                table: 'sloppygram_post_tags'
            }, (payload) => {
                console.log('Post tag change:', payload);
                loadPosts(); // Reload to update trending tags
            });

            // Listen for manifesto tags
            postsChannel.on('postgres_changes', {
                event: '*',
                schema: 'public',
                table: 'sloppygram_manifesto_tags'
            }, (payload) => {
                console.log('Manifesto tag change:', payload);
                loadManifestos();
            });

            // Listen for global backgrounds
            postsChannel.on('postgres_changes', {
                event: 'INSERT',
                schema: 'public',
                table: 'sloppygram_global_backgrounds'
            }, (payload) => {
                console.log('New global background:', payload.new);
                globalBackgrounds.unshift(payload.new);
                renderGlobalBackgrounds(); // Update UI for all users
            });

            // Listen for chat message votes
            postsChannel.on('postgres_changes', {
                event: '*',
                schema: 'public',
                table: 'sloppygram_message_votes'
            }, (payload) => {
                console.log('Message vote change:', payload);
                loadMessageVotes();
            });

            // Listen for message reactions
            postsChannel.on('postgres_changes', {
                event: '*',
                schema: 'public',
                table: 'sloppygram_message_reactions'
            }, (payload) => {
                console.log('Message reaction change:', payload);
                var msgId = (payload.new && payload.new.message_id) || (payload.old && payload.old.message_id);
                if (msgId) {
                    loadMessageReactions().then(function() {
                        updateMessageReactionsUI(msgId);
                    });
                }
            });

            // Listen for comment votes
            postsChannel.on('postgres_changes', {
                event: '*',
                schema: 'public',
                table: 'sloppygram_comment_votes'
            }, (payload) => {
                console.log('Comment vote change:', payload);
                loadCommentVotes().then(() => renderPosts());
            });

            // Listen for doodle comments
            postsChannel.on('postgres_changes', {
                event: 'INSERT',
                schema: 'public',
                table: 'sloppygram_doodle_comments'
            }, (payload) => {
                const comment = payload.new;
                if (comment) {
                    if (!doodleComments[comment.doodle_id]) doodleComments[comment.doodle_id] = [];
                    // Avoid duplicates
                    if (!doodleComments[comment.doodle_id].find(c => c.id === comment.id)) {
                        doodleComments[comment.doodle_id].push(comment);
                        if (comment.parent_comment_id) {
                            doodleCommentThreads[comment.id] = comment.parent_comment_id;
                        }
                        if (currentView === 'doodles') {
                            loadDoodleLeaderboard();
                        }
                    }
                }
            });

            // Use Promise-based subscription with state tracking
            channelState.posts.pending = subscribeWithPromise(postsChannel, 'posts');
            await channelState.posts.pending;

            // === FEEDBACK REALTIME SUBSCRIPTION ===
            var feedbackChannel = supabase.channel('sloppygram-feedback-realtime');

            // Listen for new feedback submissions
            feedbackChannel.on('postgres_changes', {
                event: 'INSERT',
                schema: 'public',
                table: 'feedback'
            }, function(payload) {
                console.log('[Feedback] New idea received:', payload.new);
                // Add to feedbackData if not already there
                if (!feedbackData.find(function(f) { return f.id === payload.new.id; })) {
                    feedbackData.unshift(payload.new);
                    updateFeedbackStats();
                    if (currentView === 'feedback') {
                        renderFeedback();
                        showToast('ðŸ’¡ New idea submitted!', 'info');
                    }
                }
            });

            // Listen for feedback updates (votes, status changes)
            feedbackChannel.on('postgres_changes', {
                event: 'UPDATE',
                schema: 'public',
                table: 'feedback'
            }, function(payload) {
                console.log('[Feedback] Idea updated:', payload.new);
                var index = feedbackData.findIndex(function(f) { return f.id === payload.new.id; });
                if (index !== -1) {
                    feedbackData[index] = payload.new;
                    updateFeedbackStats();
                    if (currentView === 'feedback') {
                        renderFeedback();
                    }
                }
            });

            // Listen for feedback deletions
            feedbackChannel.on('postgres_changes', {
                event: 'DELETE',
                schema: 'public',
                table: 'feedback'
            }, function(payload) {
                console.log('[Feedback] Idea deleted:', payload.old);
                feedbackData = feedbackData.filter(function(f) { return f.id !== payload.old.id; });
                updateFeedbackStats();
                if (currentView === 'feedback') {
                    renderFeedback();
                }
            });

            // Listen for vote changes
            feedbackChannel.on('postgres_changes', {
                event: '*',
                schema: 'public',
                table: 'feedback_votes'
            }, function(payload) {
                console.log('[Feedback] Vote change:', payload);
                // Reload feedback to get updated vote counts
                if (currentView === 'feedback') {
                    loadFeedback();
                }
            });

            // Use Promise-based subscription with state tracking
            channelState.feedback.pending = subscribeWithPromise(feedbackChannel, 'feedback');
            await channelState.feedback.pending;
        }

        function broadcastMessage(msg) {
            if (realtimeChannel) {
                realtimeChannel.send({
                    type: 'broadcast',
                    event: 'new_message',
                    payload: msg
                });
            }
        }

        function scrollToBottom() {
            const container = getCachedElement('messagesContainer');
            container.scrollTop = container.scrollHeight;
        }

        // Add message to UI (append by default for bottom-up chat flow)
        function addMessageToUI(msg, prepend = false) {
            const container = getCachedElement('messagesContainer');
            safeSetDisplay('emptyState', 'none');

            var currentUserId = (currentUser && currentUser.id) ? currentUser.id : null;
            const isOwn = msg.user_id === currentUserId;
            const time = new Date(msg.created_at).toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });

            const div = document.createElement('div');
            div.className = `message ${isOwn ? 'own' : ''}`;

            let contentHTML = '';
            if (msg.content) {
                // Parse tags/mentions, escape HTML, then parse hacker markup
                contentHTML = '<div class="message-content">' + parseHackerMarkup(parseChatTags(msg.content)) + '</div>';
            }
            const safeImageData = sanitizeUrl(msg.image_data);
            if (safeImageData) {
                var imgClass = msg.message_type === 'gif' ? 'message-image message-gif' : 'message-image';
                contentHTML += '<img class="' + imgClass + '" src="' + safeImageData + '" onclick="openLightbox(this.src)">';
            }
            const safeDrawingData = sanitizeUrl(msg.drawing_data);
            if (safeDrawingData) {
                const doodleId = msg.id;
                const isRealDoodleId = typeof doodleId === 'number' || (typeof doodleId === 'string' && !doodleId.startsWith('temp_'));
                const doodleScore = doodleVotes[doodleId] || 0;
                const myDoodleVote = myDoodleVotes[doodleId] || 0;
                // Check ownership by user_id first (reliable), fallback to username
                const isOwnDoodle = (currentUserId && msg.user_id === currentUserId) || msg.username === profile.username;
                const doodleScoreClass = doodleScore > 0 ? 'positive' : doodleScore < 0 ? 'negative' : 'neutral';
                // Doodle DNA badge
                let doodleDnaBadge = '';
                if (isRealDoodleId && typeof generateContentDNA === 'function') {
                    const dDna = generateContentDNA(msg, 'doodle');
                    const coloredDSeq = dDna.sequence.split('').map(c => {
                        if (c === '-') return '<span style="opacity:0.3">Â·</span>';
                        return '<span class="nucleotide-' + c + '">' + c + '</span>';
                    }).join('');
                    doodleDnaBadge = '<span class="msg-dna-badge" title="' + dDna.full + '">' + dDna.code + '::' + coloredDSeq + '</span>';
                }
                const doodleVoteControls = isRealDoodleId ? `
                    <div class="vote-controls doodle-votes" data-doodle-id="${escapeAttr(String(doodleId))}">
                        <button class="vote-btn upvote ${myDoodleVote === 1 ? 'active' : ''} ${isOwnDoodle ? 'disabled' : ''}"
                            onclick="${isOwnDoodle ? '' : `voteDoodle('${escapeAttr(String(doodleId))}', 1, '${escapeAttr(msg.username)}')`}"
                            title="${isOwnDoodle ? 'Cannot vote on own doodle' : 'Upvote'}">â–²</button>
                        <span class="vote-score ${doodleScoreClass}">${doodleScore}</span>
                        <button class="vote-btn downvote ${myDoodleVote === -1 ? 'active' : ''} ${isOwnDoodle ? 'disabled' : ''}"
                            onclick="${isOwnDoodle ? '' : `voteDoodle('${escapeAttr(String(doodleId))}', -1, '${escapeAttr(msg.username)}')`}"
                            title="${isOwnDoodle ? 'Cannot vote on own doodle' : 'Downvote'}">â–¼</button>
                        <button class="msg-fork-btn" onclick="forkDoodle('${escapeAttr(String(doodleId))}')" title="Fork this doodle">ðŸ”€</button>
                        ${doodleDnaBadge}
                    </div>` : '';
                contentHTML += `
                    <div class="doodle-wrapper">
                        <img class="message-drawing" src="${safeDrawingData}">
                        ${doodleVoteControls}
                    </div>`;
            }

            // Vote controls for non-doodle messages
            const msgId = msg.id;
            const isRealId = typeof msgId === 'number' || (typeof msgId === 'string' && !msgId.startsWith('temp_'));
            // Check ownership by user_id first (reliable), fallback to username comparison
            const isOwnMessage = (currentUserId && msg.user_id === currentUserId) || msg.username === profile.username;
            const chatVoteScore = messageVotes[msgId] || 0;
            const myVoteType = myMessageVotes[msgId] || 0;
            const scoreClass = chatVoteScore > 0 ? 'positive' : chatVoteScore < 0 ? 'negative' : 'neutral';
            const ttsBtn = (msg.content && !msg.drawing_data) ? `<button class="msg-tts-btn" id="msg-tts-${escapeAttr(String(msgId))}" onclick="speakMessage('${escapeAttr(String(msgId))}')" title="Read aloud">ðŸ”Š</button>` : '';

            // Fork button for text messages
            const forkBtn = (msg.content && !msg.drawing_data && isRealId) ? `<button class="msg-fork-btn" onclick="forkMessage('${escapeAttr(String(msgId))}')" title="Fork this message">ðŸ”€</button>` : '';

            // DNA badge for messages
            let msgDnaBadge = '';
            if (isRealId && typeof generateContentDNA === 'function') {
                const msgDna = generateContentDNA(msg, msg.drawing_data ? 'doodle' : 'msg');
                const coloredSeq = msgDna.sequence.split('').map(c => {
                    if (c === '-') return '<span style="opacity:0.3">Â·</span>';
                    return '<span class="nucleotide-' + c + '">' + c + '</span>';
                }).join('');
                msgDnaBadge = '<span class="msg-dna-badge" title="' + msgDna.full + '">' + msgDna.code + '::' + coloredSeq + '</span>';
            }

            // Build message reactions HTML
            const msgReactions = messageReactions[msgId] || {};
            const myMsgReactions = myMessageReactions[msgId] || new Set();
            const msgReactionsHtml = Object.entries(msgReactions)
                .sort((a, b) => b[1] - a[1])
                .map(function(entry) {
                    var emoji = entry[0];
                    var count = entry[1];
                    var isActive = myMsgReactions.has ? myMsgReactions.has(emoji) : false;
                    // Use escapeAttr to prevent XSS in onclick handler
                    return '<button class="reaction-btn ' + (isActive ? 'active' : '') + '" onclick="toggleMessageReaction(\'' + escapeAttr(msgId) + '\', \'' + escapeAttr(emoji) + '\')">' +
                        escapeHtml(emoji) + ' <span class="reaction-count">' + count + '</span></button>';
                }).join('');

            const msgReactionPickerHtml = REACTION_EMOJIS.map(function(emoji) {
                // REACTION_EMOJIS is hardcoded so safe, but escape for consistency
                return '<button onclick="toggleMessageReaction(\'' + escapeAttr(msgId) + '\', \'' + escapeAttr(emoji) + '\')">' + emoji + '</button>';
            }).join('');

            const safeMsgId = escapeAttr(String(msgId));
            const chatVoteBtn = (isRealId && !msg.drawing_data) ? `
                <div class="message-footer">
                    <div class="vote-controls" data-chat-id="${safeMsgId}">
                        <button class="vote-btn upvote ${myVoteType === 1 ? 'active' : ''} ${isOwnMessage ? 'disabled' : ''}"
                            onclick="${isOwnMessage ? '' : `voteMessage('${safeMsgId}', 1)`}" title="${isOwnMessage ? 'Cannot vote on own content' : 'Upvote'}">â–²</button>
                        <span class="vote-score ${scoreClass}">${chatVoteScore}</span>
                        <button class="vote-btn downvote ${myVoteType === -1 ? 'active' : ''} ${isOwnMessage ? 'disabled' : ''}"
                            onclick="${isOwnMessage ? '' : `voteMessage('${safeMsgId}', -1)`}" title="${isOwnMessage ? 'Cannot vote on own content' : 'Downvote'}">â–¼</button>
                    </div>
                    ${ttsBtn}
                    ${forkBtn}
                    ${msgDnaBadge}
                    <div class="msg-reactions" id="msg-reactions-${safeMsgId}">
                        ${msgReactionsHtml}
                        <div style="position:relative;display:inline-block;">
                            <button class="add-reaction-btn" onclick="toggleMsgReactionPicker('${safeMsgId}')">+ðŸ˜€</button>
                            <div class="reaction-picker" id="msg-picker-${safeMsgId}">
                                ${msgReactionPickerHtml}
                            </div>
                        </div>
                    </div>
                </div>` : '';

            const safeAvatarUrl = sanitizeUrl(msg.avatar_url || msg.avatarUrl);
            const avatarContent = safeAvatarUrl
                ? `<img src="${safeAvatarUrl}" alt="avatar" style="width:100%;height:100%;object-fit:cover;border-radius:50%;">`
                : (msg.avatar || 'ðŸ‘¤');
            const deleteBtn = (isOwnMessage && isRealId) ? `<button class="msg-delete-btn" onclick="deleteMessage('${safeMsgId}')" title="Delete">delete</button>` : '';
            div.innerHTML = `
                <div class="avatar">${avatarContent}</div>
                <div class="message-bubble">
                    <div class="message-header">
                        <span class="message-username username-clickable" onclick="showProfileCard('${escapeAttr(msg.username || 'Anonymous')}', event)">${escapeHtml(msg.username || 'Anonymous')}</span>
                        <span class="message-time">${time}</span>
                        ${deleteBtn}
                    </div>
                    ${contentHTML}
                    ${chatVoteBtn}
                </div>
            `;

            if (prepend) {
                container.insertBefore(div, container.firstChild);
            } else {
                container.appendChild(div);
                // Scroll to bottom for new messages
                container.scrollTop = container.scrollHeight;
            }
        }

        // Sanitize text content using DOMPurify - removes all HTML/scripts
        function escapeHtml(text) {
            if (!text) return '';
            // Use DOMPurify to strip all HTML tags, keeping only text
            return DOMPurify.sanitize(String(text), { ALLOWED_TAGS: [] });
        }

        // Safe markdown parser for manifesto content
        // Uses marked.js for parsing and DOMPurify for sanitization
        function parseManifestoMarkdown(text) {
            if (!text) return '';
            try {
                // Configure marked for safe output
                if (typeof marked !== 'undefined') {
                    marked.setOptions({
                        breaks: true,      // Convert \n to <br>
                        gfm: true,         // GitHub Flavored Markdown
                        headerIds: false,  // Don't add IDs to headers
                        mangle: false      // Don't mangle email addresses
                    });

                    // Parse markdown
                    const rawHtml = marked.parse(String(text));

                    // Sanitize with DOMPurify - allow safe HTML only
                    return DOMPurify.sanitize(rawHtml, {
                        ALLOWED_TAGS: ['p', 'br', 'strong', 'b', 'em', 'i', 'code', 'pre',
                                       'blockquote', 'ul', 'ol', 'li', 'a', 'h1', 'h2', 'h3', 'hr'],
                        ALLOWED_ATTR: ['href', 'title'],
                        ALLOW_DATA_ATTR: false,
                        ADD_ATTR: ['target', 'rel'],
                        FORBID_TAGS: ['script', 'style', 'iframe', 'form', 'input', 'img', 'svg', 'object', 'embed'],
                        FORBID_ATTR: ['onerror', 'onclick', 'onload', 'onmouseover', 'onfocus', 'onblur']
                    });
                }
            } catch (e) {
                console.error('Markdown parse error:', e);
            }
            // Fallback to escaped text if marked is unavailable
            return escapeHtml(text);
        }

        // Escape string for safe use in HTML attributes (onclick handlers, etc.)
        function escapeAttr(str) {
            if (!str) return '';
            return String(str)
                .replace(/&/g, '&amp;')
                .replace(/'/g, '&#39;')
                .replace(/"/g, '&quot;')
                .replace(/</g, '&lt;')
                .replace(/>/g, '&gt;')
                .replace(/\\/g, '&#92;');
        }

        // Parse hacker markup tags like [shake]text[/shake], [rainbow]text[/rainbow], etc.
        // ReDoS protection: limits on message length, tag count, and wave content length
        const MARKUP_MAX_LENGTH = 5000;      // Max message length to process
        const MARKUP_MAX_TAGS = 20;          // Max tags per message
        const WAVE_MAX_CHARS = 100;          // Max chars for wave effect (creates span per char)

        function parseHackerMarkup(text) {
            if (!text) return '';

            // ReDoS protection: skip processing for very long messages
            if (text.length > MARKUP_MAX_LENGTH) {
                console.warn('Message too long for markup processing, skipping');
                return escapeHtml(text);
            }

            // Define supported tags and their CSS classes
            const hackerTags = {
                'shake': 'hacker-shake',
                'rainbow': 'hacker-rainbow',
                'matrix': 'hacker-matrix',
                'glitch': 'hacker-glitch',
                'pulse': 'hacker-pulse',
                'wave': 'hacker-wave',
                'spoiler': 'hacker-spoiler',
                'neon': 'hacker-neon',
                'fire': 'hacker-fire',
                'ice': 'hacker-ice',
                'bounce': 'hacker-bounce'
            };

            let result = text;
            let totalTagsProcessed = 0;

            // Process each tag type
            for (const [tag, cssClass] of Object.entries(hackerTags)) {
                // Match [tag]content[/tag] pattern (case insensitive)
                const regex = new RegExp(`\\[${tag}\\](.+?)\\[\\/${tag}\\]`, 'gi');

                if (tag === 'spoiler') {
                    // Spoiler: click to reveal permanently (escape content for XSS safety)
                    result = result.replace(regex, (match, content) => {
                        if (++totalTagsProcessed > MARKUP_MAX_TAGS) return escapeHtml(match);
                        return `<span class="${cssClass}" onclick="this.classList.toggle('revealed')">${escapeHtml(content)}</span>`;
                    });
                } else if (tag === 'wave' || tag === 'bounce') {
                    // Wave/Bounce effect: wrap each character in a span with animation delay
                    // Escape content first to prevent XSS via character injection
                    // Limit content length to prevent CPU-intensive DOM generation
                    result = result.replace(regex, (match, content) => {
                        if (++totalTagsProcessed > MARKUP_MAX_TAGS) return escapeHtml(match);
                        const safeContent = escapeHtml(content);
                        // ReDoS protection: limit effect to prevent excessive span generation
                        if (safeContent.length > WAVE_MAX_CHARS) {
                            return `<span class="${cssClass}">${safeContent}</span>`;
                        }
                        const chars = safeContent.split('').map((char, i) => {
                            if (char === ' ') return ' ';
                            // Don't double-escape HTML entities (they're already safe)
                            return `<span style="animation-delay:${i * 0.05}s">${char}</span>`;
                        }).join('');
                        return `<span class="${cssClass}">${chars}</span>`;
                    });
                } else {
                    // Other effects: escape content for XSS safety
                    result = result.replace(regex, (match, content) => {
                        if (++totalTagsProcessed > MARKUP_MAX_TAGS) return escapeHtml(match);
                        return `<span class="${cssClass}">${escapeHtml(content)}</span>`;
                    });
                }
            }

            return result;
        }

        // Sanitize HTML content - allows safe tags but removes scripts
        function sanitizeHtml(html) {
            if (!html) return '';
            return DOMPurify.sanitize(html, {
                ALLOWED_TAGS: ['b', 'i', 'em', 'strong', 'br', 'p', 'span'],
                ALLOWED_ATTR: []
            });
        }

        // Sanitize plain text for database storage (defense-in-depth)
        // Strips all HTML tags, trims whitespace, limits length
        function sanitizeForStorage(text, maxLength = 2000) {
            if (!text) return '';
            // Strip HTML tags using DOMPurify with no allowed tags
            let clean = DOMPurify.sanitize(String(text), { ALLOWED_TAGS: [] });
            // Trim and limit length
            clean = clean.trim().slice(0, maxLength);
            return clean;
        }

        // === SECURE LOCAL STORAGE ===
        // Simple obfuscation for localStorage (defense-in-depth against casual inspection)
        // Uses base64 + XOR with a static key - not cryptographically secure but deters simple attacks
        const STORAGE_KEY = 'sl0ppy_2024';
        const STORAGE_VERSION = 'v1:';

        function obfuscateData(data) {
            try {
                const json = JSON.stringify(data);
                // XOR each character with key
                let obfuscated = '';
                for (let i = 0; i < json.length; i++) {
                    obfuscated += String.fromCharCode(json.charCodeAt(i) ^ STORAGE_KEY.charCodeAt(i % STORAGE_KEY.length));
                }
                // Base64 encode and add version prefix
                return STORAGE_VERSION + btoa(unescape(encodeURIComponent(obfuscated)));
            } catch (e) {
                console.error('Failed to obfuscate data:', e);
                return null;
            }
        }

        function deobfuscateData(encoded) {
            try {
                if (!encoded) return null;
                // Check for version prefix
                if (!encoded.startsWith(STORAGE_VERSION)) {
                    // Legacy unobfuscated data - parse directly
                    return JSON.parse(encoded);
                }
                // Remove version prefix and decode
                const base64 = encoded.slice(STORAGE_VERSION.length);
                const obfuscated = decodeURIComponent(escape(atob(base64)));
                // XOR to restore
                let json = '';
                for (let i = 0; i < obfuscated.length; i++) {
                    json += String.fromCharCode(obfuscated.charCodeAt(i) ^ STORAGE_KEY.charCodeAt(i % STORAGE_KEY.length));
                }
                return JSON.parse(json);
            } catch (e) {
                console.error('Failed to deobfuscate data:', e);
                return null;
            }
        }

        function secureStorageSet(key, data) {
            const obfuscated = obfuscateData(data);
            if (obfuscated) {
                localStorage.setItem(key, obfuscated);
            }
        }

        function secureStorageGet(key) {
            const stored = localStorage.getItem(key);
            if (!stored) return null;
            return deobfuscateData(stored);
        }

        // Sanitize URLs - block dangerous protocols but allow image data URLs
        function sanitizeUrl(url) {
            if (!url) return '';
            const str = String(url).trim();

            // Allow data:image URLs (base64 images) - match image MIME types
            if (/^data:image\/(png|jpeg|jpg|gif|webp|svg\+xml);base64,/i.test(str)) {
                return str;
            }

            // Block javascript:, other data:, vbscript:, file: protocols
            if (/^(javascript|data|vbscript|file):/i.test(str)) {
                console.warn('Blocked dangerous URL:', str.slice(0, 50));
                return '';
            }

            // Allow http/https URLs and relative paths
            return DOMPurify.sanitize(str, { ALLOWED_TAGS: [] });
        }

        // === CHAT TAGGING SYSTEM ===
        // Show tag hints when user types # or @
        window.handleTagInput = function(textarea) {
            var hint = document.getElementById('tagHint');
            if (!hint) return;

            var val = textarea.value || '';
            var lastChar = val.slice(-1);
            var lastWord = val.split(/\s/).pop() || '';

            // Show hint if typing # or @ at start of word
            if (lastChar === '#' || lastChar === '@' || lastWord.startsWith('#') || lastWord.startsWith('@')) {
                hint.classList.add('visible');
            } else if (val.length === 0) {
                hint.classList.remove('visible');
            }

            // Hide after a few characters of a tag
            if (lastWord.length > 8 && (lastWord.startsWith('#') || lastWord.startsWith('@'))) {
                hint.classList.remove('visible');
            }
        };

        // === GHOST TEXT PREDICTION ENGINE ===
        // Constructive wisdom and creative prompts
        var ghostPhrases = {
            // Positive starters
            'i': ['i believe we can build something amazing together', 'i appreciate everyone here', 'i had an idea worth sharing...'],
            'we': ['we should collaborate on something creative', 'we can make this space better together', 'we are stronger when we create together'],
            'the': ['the best ideas come from unexpected places', 'the journey matters more than the destination', 'the community here inspires me'],
            'what': ['what if we tried something new today?', 'what inspires you to create?', 'what would make today meaningful?'],
            'why': ['why not start that project you\'ve been thinking about?', 'why do small acts of kindness matter so much?', 'why not share what you\'re working on?'],
            'how': ['how can we help each other grow?', 'how about we brainstorm together?', 'how do you stay creative?'],
            'this': ['this community is full of amazing people', 'this is a great place to share ideas', 'this moment is perfect for creating'],
            'is': ['is there something I can help with?', 'is anyone working on something cool?', 'is today the day to start something new?'],
            'do': ['do something that makes you proud today', 'do you have any creative projects going?', 'do small things with great love'],
            'can': ['can we collaborate on something?', 'can creativity change the world? absolutely.', 'can I share an idea with you?'],
            'are': ['are you working on anything exciting?', 'are we ready to make something great?', 'are ideas meant to be shared? yes!'],
            'where': ['where does your creativity come from?', 'where should we take this project next?', 'where do you find inspiration?'],
            'who': ['who wants to jam on an idea?', 'who here has a story to tell?', 'who inspires you the most?'],
            'you': ['you have more potential than you know', 'you should share your work!', 'you make this community better'],
            'hello': ['hello! excited to connect with everyone', 'hello, what are you creating today?', 'hello friend, let\'s make something'],
            'help': ['help others and you help yourself grow', 'help is always appreciated here', 'helping each other is what we do'],
            'think': ['thinking out loud helps clarify ideas', 'think big, start small, learn fast', 'thinking creatively opens doors'],
            'feel': ['feel free to share your thoughts', 'feeling inspired by this community', 'feel the creative energy here'],
            'maybe': ['maybe today is the day to try something bold', 'maybe your idea is exactly what we need', 'maybe we should collaborate?'],
            'never': ['never underestimate small beginnings', 'never stop learning and growing', 'never give up on your creative vision'],
            'always': ['always be kind and curious', 'always room to grow together', 'always open to new perspectives'],
            'time': ['time spent creating is never wasted', 'time to bring that idea to life!', 'time flies when you\'re making things'],
            'let': ['let\'s build something together', 'let your creativity flow', 'let me know how I can help'],
            'try': ['try something new today', 'try failing forward - it\'s how we learn', 'try sharing your work in progress'],
            'make': ['make something that matters to you', 'make today count', 'make art, make friends, make progress'],
            'create': ['create without fear of judgment', 'create something that didn\'t exist before', 'creativity is contagious - spread it!'],
            'build': ['build something you\'re proud of', 'build connections, not just projects', 'building together is more fun'],
            'share': ['share your work, inspire others', 'share ideas freely and watch them grow', 'sharing knowledge multiplies it'],
            'learn': ['learn something new every day', 'learning from each other is powerful', 'learn by doing, teach by sharing'],
            'grow': ['grow through what you go through', 'growing together as a community', 'growth happens outside comfort zones'],
            'idea': ['ideas are worth exploring together', 'ideas want to be shared', 'idea: let\'s make something cool'],
            'dream': ['dream big, then take the first step', 'dreams become reality through action', 'dreaming is the first act of creation'],
            'start': ['start before you\'re ready', 'start small, think big', 'starting is the hardest part - you got this'],
            'work': ['work on what excites you', 'working together makes it easier', 'work in progress is still progress'],
            'project': ['projects are better with collaborators', 'project idea: let\'s jam!', 'projects teach us more than tutorials'],
            'code': ['code is poetry in motion', 'coding is creative problem solving', 'code something fun today'],
            'art': ['art connects us all', 'art is meant to be shared', 'art starts with a single brushstroke'],
            'music': ['music brings people together', 'music is the universal language', 'making music is making magic'],
            'write': ['write what you want to read', 'writing clarifies thinking', 'write something that matters to you'],
            'play': ['play is productive creativity', 'play with ideas freely', 'playfulness unlocks innovation'],
            'love': ['love what you create', 'love this community', 'love is the best motivator'],
            'good': ['good vibes only', 'good ideas come from everywhere', 'good things take time'],
            'great': ['great things start small', 'great work comes from passion', 'great to see everyone creating'],
            'cool': ['cool project! tell me more', 'cool ideas deserve to be shared', 'cool things happen when we collaborate'],
            'nice': ['nice work! keep it up', 'nice to meet fellow creators', 'nice ideas deserve encouragement'],
            'thanks': ['thanks for being part of this', 'thanks for sharing your creativity', 'thankful for this community'],
            'hey': ['hey! what are you working on?', 'hey, let\'s create something', 'hey friend, welcome!'],
            'hi': ['hi! excited to be here', 'hi everyone, let\'s make today creative', 'hi, what inspires you?'],
            'lol': ['lol creativity is fun!', 'lol let\'s keep the good vibes going', 'laughing and learning together'],
            'yes': ['yes! let\'s do this', 'yes to new ideas', 'yes, your idea has potential'],
            'no': ['no idea is too small to share', 'no better time than now to create', 'no limits on creativity'],
            'so': ['so many possibilities to explore', 'so glad to be creating with you all', 'so what should we build next?'],
            'just': ['just start and see what happens', 'just had a fun idea...', 'just showing up is half the battle'],
            'like': ['like this community energy', 'like your style!', 'like-minded creators unite'],
            'want': ['want to collaborate on something?', 'want to share what I\'m working on', 'want to help others succeed'],
            'need': ['need a creative spark? we got you', 'need feedback? just ask!', 'needing community is human'],
            'know': ['know that your work matters', 'knowledge grows when shared', 'knowing when to ask for help is wisdom'],
            'see': ['see the potential in every idea', 'see what we can build together', 'seeing creativity everywhere'],
            'look': ['look for inspiration in unexpected places', 'look what we made together!', 'looking forward to what\'s next'],
            'day': ['day by day, we improve', 'days are better when creating', 'day one of something great']
        };

        var ghostCurrentSuggestion = '';

        window.updateGhostText = function(textarea) {
            var ghostLayer = document.getElementById('ghostTextLayer');
            var ghostHint = document.getElementById('ghostHint');
            if (!ghostLayer || !ghostHint) return;

            var typedSpan = ghostLayer.querySelector('.typed');
            var ghostSpan = ghostLayer.querySelector('.ghost');

            var text = textarea.value || '';
            typedSpan.textContent = text;

            // Find suggestion based on last word
            var words = text.toLowerCase().split(/\s+/);
            var lastWord = words[words.length - 1] || '';
            var suggestion = '';

            // Only show ghost after 2+ chars and text doesn't end with space
            if (lastWord.length >= 2 && !text.endsWith(' ')) {
                // Check for matching phrase starters
                var matchingKeys = Object.keys(ghostPhrases).filter(function(key) {
                    return key.startsWith(lastWord) && key !== lastWord;
                });

                if (matchingKeys.length > 0) {
                    // Complete the word + add haunting phrase
                    var matchKey = matchingKeys[Math.floor(Math.random() * matchingKeys.length)];
                    var phrases = ghostPhrases[matchKey];
                    var phrase = phrases[Math.floor(Math.random() * phrases.length)];
                    suggestion = phrase.slice(lastWord.length);
                } else if (ghostPhrases[lastWord]) {
                    // Word complete, suggest a phrase
                    var phrases = ghostPhrases[lastWord];
                    var fullPhrase = phrases[Math.floor(Math.random() * phrases.length)];
                    suggestion = fullPhrase.slice(lastWord.length);
                }
            }

            ghostSpan.textContent = suggestion;
            ghostCurrentSuggestion = suggestion;

            // Show/hide hint
            if (suggestion) {
                ghostHint.classList.add('visible');
            } else {
                ghostHint.classList.remove('visible');
            }
        };

        // Accept ghost suggestion with Tab
        document.addEventListener('keydown', function(e) {
            var input = getCachedElement('messageInput');
            if (!input || document.activeElement !== input) return;

            if (e.key === 'Tab' && ghostCurrentSuggestion) {
                e.preventDefault();
                input.value = input.value + ghostCurrentSuggestion;
                ghostCurrentSuggestion = '';
                updateGhostText(input);
            }
        });

        // Insert a tag into the message input
        window.insertTag = function(tag) {
            var input = getCachedElement('messageInput');
            if (!input) return;

            var val = input.value || '';
            // If last char is # or @, replace it with the full tag
            if (val.endsWith('#') || val.endsWith('@')) {
                input.value = val.slice(0, -1) + tag + ' ';
            } else if (val.length > 0 && !val.endsWith(' ')) {
                input.value = val + ' ' + tag + ' ';
            } else {
                input.value = val + tag + ' ';
            }

            input.focus();
            var hint = document.getElementById('tagHint');
            if (hint) hint.classList.remove('visible');
        };

        // Parse #tags and @mentions in message content for display
        function parseChatTags(text) {
            if (!text) return '';

            // Escape HTML first
            var escaped = escapeHtml(text);

            // Replace #tags with styled spans (escapeAttr for onclick safety)
            escaped = escaped.replace(/#(\w+)/g, function(match, tag) {
                return '<span class="chat-tag" onclick="filterChatByTag(\'' + escapeAttr(tag) + '\')">#' + escapeHtml(tag) + '</span>';
            });

            // Replace @mentions with styled spans (escapeAttr for onclick safety)
            // Add self-mention class if this is a mention of the current user
            var currentUsername = profile && profile.username ? profile.username.toLowerCase() : '';
            escaped = escaped.replace(/@(\w+)/g, function(match, username) {
                var isSelfMention = currentUsername && username.toLowerCase() === currentUsername;
                var mentionClass = 'chat-mention' + (isSelfMention ? ' self-mention' : '');
                return '<span class="' + mentionClass + '" onclick="showUserProfile(\'' + escapeAttr(username) + '\')">@' + escapeHtml(username) + '</span>';
            });

            return escaped;
        }

        // Filter chat by tag
        window.filterChatByTag = function(tag) {
            activeChatFilter = { type: 'tag', value: tag };
            var filterBar = getCachedElement('chatFilterBar');
            var filterValue = document.getElementById('activeChatFilter');

            if (filterBar) filterBar.classList.add('active');
            if (filterValue) {
                filterValue.textContent = '#' + tag;
                filterValue.classList.remove('mention');
            }

            renderFilteredMessages();
            showToast('Filtering by #' + tag, 'info');
        };

        // Filter chat by mention (show messages from/mentioning user)
        window.filterChatByMention = function(username) {
            activeChatFilter = { type: 'mention', value: username };
            var filterBar = getCachedElement('chatFilterBar');
            var filterValue = document.getElementById('activeChatFilter');

            if (filterBar) filterBar.classList.add('active');
            if (filterValue) {
                filterValue.textContent = '@' + username;
                filterValue.classList.add('mention');
            }

            renderFilteredMessages();
            showToast('Showing messages from @' + username, 'info');
        };

        // Clear chat filter
        window.clearChatFilter = function() {
            activeChatFilter = null;
            var filterBar = getCachedElement('chatFilterBar');
            if (filterBar) filterBar.classList.remove('active');

            // Also clear tag filter if it was a tag filter
            if (activeTagFilter) {
                activeTagFilter = null;
                getCachedElement('tagFilterBar').classList.remove('active');
                renderPosts();
                renderManifestos();
            }

            renderMessages();
        };

        // Render all cached messages (used after clearing filter)
        function renderMessages() {
            var container = getCachedElement('messagesContainer');
            var emptyState = getCachedElement('emptyState');
            if (!container) return;

            var allMessages = window.cachedMessages || [];

            if (allMessages.length === 0) {
                if (emptyState) {
                    emptyState.innerHTML = '<div class="icon">ðŸ’¾</div><p>INITIALIZING CHAT PROTOCOL...</p><p>Say something!</p>';
                    emptyState.style.display = 'block';
                }
                container.innerHTML = '';
                if (emptyState) container.appendChild(emptyState);
                return;
            }

            if (emptyState) emptyState.style.display = 'none';

            // Clear and re-render all messages
            container.innerHTML = '';
            allMessages.forEach(function(msg) {
                addMessageToUI(msg, false);
            });

            // Scroll to top (newest messages)
            container.scrollTop = 0;
        }

        // Show user profile (for @mention clicks)
        window.showUserProfile = function(username) {
            // Show their profile card
            showProfileCard(username);
        };

        // Render messages with active filter applied
        function renderFilteredMessages() {
            if (!activeChatFilter) {
                renderMessages();
                return;
            }

            var container = getCachedElement('messagesContainer');
            var emptyState = getCachedElement('emptyState');
            if (!container) return;

            // Get cached messages from the container's data or global state
            var allMessages = window.cachedMessages || [];

            var filtered = allMessages.filter(function(msg) {
                var content = msg.content || '';

                if (activeChatFilter.type === 'tag') {
                    // Check if message contains this hashtag
                    var tagRegex = new RegExp('#' + activeChatFilter.value + '\\b', 'i');
                    return tagRegex.test(content);
                } else if (activeChatFilter.type === 'mention') {
                    // Check if message is from this user OR mentions them
                    var mentionRegex = new RegExp('@' + activeChatFilter.value + '\\b', 'i');
                    return msg.username === activeChatFilter.value || mentionRegex.test(content);
                }
                return true;
            });

            if (filtered.length === 0) {
                if (emptyState) {
                    var filterText = activeChatFilter.type === 'tag'
                        ? '#' + activeChatFilter.value
                        : '@' + activeChatFilter.value;
                    emptyState.innerHTML = '<div class="icon">ðŸ”</div><p>No messages with ' + escapeHtml(filterText) + '</p>';
                    emptyState.style.display = 'block';
                }
                container.innerHTML = '';
                if (emptyState) container.appendChild(emptyState);
                return;
            }

            if (emptyState) emptyState.style.display = 'none';

            // Render filtered messages
            container.innerHTML = '';
            filtered.forEach(function(msg) {
                addMessageToUI(msg, false);
            });
        }

        // Extract tags from message content
        function extractTags(text) {
            if (!text) return [];
            var tags = [];
            var tagRegex = /#(\w+(?:\/\w+)?)/g;
            var match;
            while ((match = tagRegex.exec(text)) !== null) {
                var fullTag = match[1];
                var parts = fullTag.split('/');
                if (parts.length === 2) {
                    // Hierarchical tag like #art/pixel
                    tags.push({ tag: parts[1], parent_tag: parts[0] });
                } else {
                    // Simple tag like #vibe
                    tags.push({ tag: parts[0], parent_tag: null });
                }
            }
            return tags;
        }

        // Save tags to database
        async function persistMessageTags(messageId, content, userId) {
            var tags = extractTags(content);
            if (tags.length === 0) return;

            var tagRecords = tags.map(function(t) {
                return {
                    message_id: messageId,
                    tag: t.tag,
                    parent_tag: t.parent_tag,
                    user_id: userId
                };
            });

            var result = await supabase
                .from('sloppygram_message_tags')
                .insert(tagRecords);

            if (result.error) {
                console.error('[persistMessageTags] Error:', result.error);
            } else {
                console.log('[persistMessageTags] Saved', tags.length, 'tags for message', messageId);
            }
        }

        // === TAG CLOUD VISUALIZATION ===
        var tagCloudData = {}; // { tag: count }
        var tagCloudSources = {}; // { tag: { message, post, manifesto } }
        var NEON_COLORS = ['neon-cyan', 'neon-magenta', 'neon-green', 'neon-yellow', 'neon-orange', 'neon-pink'];

        // Load tags from database
        async function loadTagCloud() {
            // Query all three tag sources directly via Supabase
            try {
                var results = await Promise.all([
                    supabase.from('sloppygram_message_tags').select('tag, parent_tag').limit(500),
                    supabase.from('sloppygram_post_tags').select('tag, parent_tag').limit(500),
                    supabase.from('sloppygram_manifesto_tags').select('tag, parent_tag').limit(500)
                ]);

                var messageTags = results[0];
                var postTags = results[1];
                var manifestoTags = results[2];

                // Aggregate tag counts with source breakdown
                tagCloudData = {};
                tagCloudSources = {};

                (messageTags.data || []).forEach(function(row) {
                    var fullTag = row.parent_tag ? row.parent_tag + '/' + row.tag : row.tag;
                    var key = fullTag.toLowerCase();
                    tagCloudData[key] = (tagCloudData[key] || 0) + 1;
                    if (!tagCloudSources[key]) tagCloudSources[key] = { message: 0, post: 0, manifesto: 0, displayTag: fullTag };
                    tagCloudSources[key].message++;
                });

                (postTags.data || []).forEach(function(row) {
                    var fullTag = row.parent_tag ? row.parent_tag + '/' + row.tag : row.tag;
                    var key = fullTag.toLowerCase();
                    tagCloudData[key] = (tagCloudData[key] || 0) + 1;
                    if (!tagCloudSources[key]) tagCloudSources[key] = { message: 0, post: 0, manifesto: 0, displayTag: fullTag };
                    tagCloudSources[key].post++;
                });

                (manifestoTags.data || []).forEach(function(row) {
                    var fullTag = row.parent_tag ? row.parent_tag + '/' + row.tag : row.tag;
                    var key = fullTag.toLowerCase();
                    tagCloudData[key] = (tagCloudData[key] || 0) + 1;
                    if (!tagCloudSources[key]) tagCloudSources[key] = { message: 0, post: 0, manifesto: 0, displayTag: fullTag };
                    tagCloudSources[key].manifesto++;
                });

                renderTagCloud();
            } catch (err) {
                console.error('[TagCloud] Error loading tags:', err);
            }
        }

        // Render the tag cloud
        function renderTagCloud() {
            var container = document.getElementById('tagCloud');
            if (!container) return;

            var tags = Object.keys(tagCloudData);
            if (tags.length === 0) {
                container.innerHTML = '<div class="tag-cloud-empty">No tags yet... use #hashtags in chat!</div>';
                return;
            }

            // Sort by frequency (descending)
            tags.sort(function(a, b) {
                return tagCloudData[b] - tagCloudData[a];
            });

            // Take top 20 tags
            tags = tags.slice(0, 20);

            // Find max count for sizing
            var maxCount = Math.max.apply(null, tags.map(function(t) { return tagCloudData[t]; }));

            // Build tag elements
            var html = tags.map(function(tag, index) {
                var count = tagCloudData[tag];
                var sources = tagCloudSources[tag] || { message: 0, post: 0, manifesto: 0, displayTag: tag };
                var displayTag = sources.displayTag || tag;
                var sizeClass = 'size-' + Math.min(5, Math.ceil((count / maxCount) * 5));
                var colorClass = NEON_COLORS[index % NEON_COLORS.length];
                var pulseDelay = (index * 0.2) % 3;

                // Build tooltip with source breakdown
                var tooltip = count + ' total: ' + sources.message + ' msgs, ' + sources.post + ' posts, ' + sources.manifesto + ' manifestos';

                return '<span class="tag-cloud-item ' + sizeClass + ' ' + colorClass + '" ' +
                    'style="--pulse-delay: ' + pulseDelay + 's" ' +
                    'onclick="showTagExplorer(\'' + escapeHtml(displayTag) + '\')" ' +
                    'title="' + tooltip + '">' +
                    '#' + escapeHtml(displayTag) +
                    '</span>';
            }).join('');

            container.innerHTML = html;
        }

        // Add a new tag to the cloud (for real-time updates)
        function addToTagCloud(tag, parentTag) {
            var fullTag = parentTag ? parentTag + '/' + tag : tag;
            var wasNew = !tagCloudData[fullTag];
            tagCloudData[fullTag] = (tagCloudData[fullTag] || 0) + 1;

            renderTagCloud();

            // Add "new" animation to the tag if it's new
            if (wasNew) {
                var container = document.getElementById('tagCloud');
                if (container) {
                    var tagEl = container.querySelector('[onclick*="' + fullTag + '"]');
                    if (tagEl) {
                        tagEl.classList.add('new-tag');
                        setTimeout(function() {
                            tagEl.classList.remove('new-tag');
                        }, 500);
                    }
                }
            }
        }

        // Hook into message sending to update tag cloud in real-time
        var originalPersistMessageTags = persistMessageTags;
        persistMessageTags = async function(messageId, content, userId) {
            // Call original
            await originalPersistMessageTags(messageId, content, userId);

            // Update tag cloud locally
            var tags = extractTags(content);
            tags.forEach(function(t) {
                addToTagCloud(t.tag, t.parent_tag);
            });
        };

        // Load tag cloud on init
        document.addEventListener('DOMContentLoaded', function() {
            setTimeout(loadTagCloud, 1000);
        });

        // Refresh tag cloud periodically
        registerInterval('tag-cloud', loadTagCloud, 60000); // Every minute

        // === TAG EXPLORER ===
        window.showTagExplorer = async function(tag) {
            var modal = document.getElementById('tagExplorerModal');
            var content = document.getElementById('tagExplorerContent');
            if (!modal || !content) return;

            // Show modal with loading state
            modal.classList.add('active');
            content.innerHTML = '<div class="tag-explorer-loading">Loading tag data...</div>';

            try {
                // Get tag stats from cache
                var tagLower = tag.toLowerCase();
                var sources = tagCloudSources[tagLower] || { message: 0, post: 0, manifesto: 0 };

                // Fetch messages, posts and manifestos with this tag from the tag tables in parallel
                var [messageTagsRes, postTagsRes, manifestoTagsRes] = await Promise.all([
                    supabase.from('sloppygram_message_tags')
                        .select('message_id')
                        .or('tag.ilike.' + tag + ',parent_tag.ilike.' + tag)
                        .limit(20),
                    supabase.from('sloppygram_post_tags')
                        .select('post_id')
                        .or('tag.ilike.' + tag + ',parent_tag.ilike.' + tag)
                        .limit(20),
                    supabase.from('sloppygram_manifesto_tags')
                        .select('manifesto_id')
                        .or('tag.ilike.' + tag + ',parent_tag.ilike.' + tag)
                        .limit(20)
                ]);

                // Get unique IDs
                var messageIds = (messageTagsRes.data || []).map(function(t) { return t.message_id; });
                var postIds = (postTagsRes.data || []).map(function(t) { return t.post_id; });
                var manifestoIds = (manifestoTagsRes.data || []).map(function(t) { return t.manifesto_id; });

                // Fetch all content directly from Supabase by ID for full archive access
                var [messagesRes, postsRes, manifestosRes] = await Promise.all([
                    messageIds.length > 0
                        ? supabase.from('sloppygram_messages').select('id, username, avatar, avatar_url, content, image_data, drawing_data, message_type, created_at').in('id', messageIds).order('created_at', { ascending: false })
                        : { data: [] },
                    postIds.length > 0
                        ? supabase.from('sloppygram_posts').select('id, username, avatar, avatar_url, caption, image_url, image_data, likes_count, created_at').in('id', postIds).order('created_at', { ascending: false })
                        : { data: [] },
                    manifestoIds.length > 0
                        ? supabase.from('sloppygram_manifestos').select('id, title, content, username, avatar, upvotes, created_at').in('id', manifestoIds).order('created_at', { ascending: false })
                        : { data: [] }
                ]);

                var matchingMessages = messagesRes.data || [];
                var matchingPosts = postsRes.data || [];
                var matchingManifestos = manifestosRes.data || [];

                // Build messages HTML
                var messagesHtml = '';
                if (matchingMessages.length > 0) {
                    messagesHtml = '<div class="tag-explorer-messages">' +
                        matchingMessages.slice(0, 10).map(function(msg) {
                            var time = new Date(msg.created_at).toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
                            var safeAvatarUrl = sanitizeUrl(msg.avatar_url || msg.avatarUrl);
                            var avatarFallback = msg.avatar || 'ðŸ‘¤';
                            var avatarContent = safeAvatarUrl
                                ? '<img src="' + safeAvatarUrl + '" alt="avatar" style="width:100%;height:100%;object-fit:cover;border-radius:50%;" onerror="this.outerHTML=\'' + avatarFallback + '\'">'
                                : avatarFallback;
                            var contentHtml = msg.content ? parseHackerMarkup(parseChatTags(msg.content)) : '';
                            return '<div class="tag-explorer-message">' +
                                '<div class="avatar">' + avatarContent + '</div>' +
                                '<div class="tag-msg-bubble">' +
                                '<div class="tag-msg-header">' +
                                '<span class="msg-username" onclick="showProfileCard(\'' + escapeHtml(msg.username) + '\', event)">' + escapeHtml(msg.username || 'Anonymous') + '</span>' +
                                '<span class="msg-time">' + time + '</span>' +
                                '</div>' +
                                '<div class="msg-content">' + contentHtml + '</div>' +
                                '</div>' +
                                '</div>';
                        }).join('') +
                        '</div>';
                } else {
                    messagesHtml = '<div class="tag-explorer-empty">No messages with this tag</div>';
                }

                // Build posts HTML with simple cards (no globals needed)
                var postsHtml = '';
                if (matchingPosts.length > 0) {
                    postsHtml = '<div class="tag-explorer-posts">' +
                        matchingPosts.slice(0, 10).map(function(post) {
                            var time = new Date(post.created_at).toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
                            var safeAvatarUrl = sanitizeUrl(post.avatar_url || post.avatarUrl);
                            var avatarFallback = post.avatar || 'ðŸ‘¤';
                            var avatarContent = safeAvatarUrl
                                ? '<img src="' + safeAvatarUrl + '" alt="avatar" style="width:100%;height:100%;object-fit:cover;border-radius:50%;" onerror="this.outerHTML=\'' + avatarFallback + '\'">'
                                : avatarFallback;
                            var safeImageUrl = sanitizeUrl(post.image_url);
                            var safeImageData = sanitizeUrl(post.image_data);
                            var imageHtml = safeImageUrl
                                ? '<img class="tag-post-image" src="' + safeImageUrl + '" onclick="openLightbox(this.src)">'
                                : (safeImageData ? '<img class="tag-post-image" src="' + safeImageData + '" onclick="openLightbox(this.src)">' : '');
                            return '<div class="tag-explorer-post">' +
                                '<div class="tag-post-header">' +
                                '<div class="avatar">' + avatarContent + '</div>' +
                                '<span class="msg-username" onclick="showProfileCard(\'' + escapeHtml(post.username) + '\', event)">' + escapeHtml(post.username || 'Anonymous') + '</span>' +
                                '<span class="msg-time">' + time + '</span>' +
                                '</div>' +
                                imageHtml +
                                (post.caption ? '<div class="tag-post-caption">' + escapeHtml(post.caption) + '</div>' : '') +
                                '</div>';
                        }).join('') +
                        '</div>';
                } else {
                    postsHtml = '<div class="tag-explorer-empty">No posts with this tag</div>';
                }

                // Build manifestos HTML with simple cards (no globals needed)
                var manifestosHtml = '';
                if (matchingManifestos.length > 0) {
                    manifestosHtml = '<div class="tag-explorer-manifestos">' +
                        matchingManifestos.slice(0, 10).map(function(m) {
                            var time = new Date(m.created_at).toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
                            var safeAvatarUrl = sanitizeUrl(m.avatar_url || m.avatarUrl);
                            var avatarFallback = m.avatar || 'ðŸ‘¤';
                            var avatarContent = safeAvatarUrl
                                ? '<img src="' + safeAvatarUrl + '" alt="avatar" style="width:100%;height:100%;object-fit:cover;border-radius:50%;" onerror="this.outerHTML=\'' + avatarFallback + '\'">'
                                : avatarFallback;
                            return '<div class="tag-explorer-manifesto">' +
                                '<div class="tag-manifesto-header">' +
                                '<div class="avatar">' + avatarContent + '</div>' +
                                '<span class="msg-username" onclick="showProfileCard(\'' + escapeHtml(m.username) + '\', event)">' + escapeHtml(m.username || 'Anonymous') + '</span>' +
                                '<span class="msg-time">' + time + '</span>' +
                                '</div>' +
                                '<div class="tag-manifesto-title">' + escapeHtml(m.title || 'Untitled') + '</div>' +
                                '<div class="tag-manifesto-content">' + escapeHtml((m.content || '').substring(0, 150)) + (m.content && m.content.length > 150 ? '...' : '') + '</div>' +
                                '<div class="tag-manifesto-votes">â–² ' + (m.upvotes || 0) + '</div>' +
                                '</div>';
                        }).join('') +
                        '</div>';
                } else {
                    manifestosHtml = '<div class="tag-explorer-empty">No manifestos with this tag</div>';
                }

                // Build full content with tabs
                content.innerHTML =
                    '<div class="tag-explorer-header">' +
                    '<span class="tag-explorer-tag">#' + escapeHtml(tag) + '</span>' +
                    '</div>' +
                    '<div class="tag-explorer-stats">' +
                    '<div class="tag-stat"><div class="tag-stat-count">' + sources.message + '</div><div class="tag-stat-label">Messages</div></div>' +
                    '<div class="tag-stat"><div class="tag-stat-count">' + sources.post + '</div><div class="tag-stat-label">Posts</div></div>' +
                    '<div class="tag-stat"><div class="tag-stat-count">' + sources.manifesto + '</div><div class="tag-stat-label">Manifestos</div></div>' +
                    '</div>' +
                    '<div class="tag-explorer-tabs">' +
                    '<button class="tag-tab active" onclick="switchTagExplorerTab(\'messages\', this)">ðŸ’¬ Messages (' + matchingMessages.length + ')</button>' +
                    '<button class="tag-tab" onclick="switchTagExplorerTab(\'posts\', this)">ðŸ“¸ Posts (' + matchingPosts.length + ')</button>' +
                    '<button class="tag-tab" onclick="switchTagExplorerTab(\'manifestos\', this)">ðŸ“œ Manifestos (' + matchingManifestos.length + ')</button>' +
                    '</div>' +
                    '<div class="tag-explorer-tab-content" id="tagExplorerMessages">' + messagesHtml + '</div>' +
                    '<div class="tag-explorer-tab-content" id="tagExplorerPosts" style="display:none;">' + postsHtml + '</div>' +
                    '<div class="tag-explorer-tab-content" id="tagExplorerManifestos" style="display:none;">' + manifestosHtml + '</div>' +
                    '<button class="modal-btn tag-filter-btn" onclick="setGlobalTagFilter(\'' + escapeHtml(tag) + '\')">ðŸ” SET AS GLOBAL FILTER: #' + escapeHtml(tag).toUpperCase() + '</button>';

            } catch (err) {
                console.error('[TagExplorer] Error:', err);
                content.innerHTML = '<div class="tag-explorer-empty">Error loading tag data</div>';
            }
        };

        window.switchTagExplorerTab = function(tab, btn) {
            // Update tab buttons
            var tabs = document.querySelectorAll('.tag-explorer-tabs .tag-tab');
            tabs.forEach(function(t) { t.classList.remove('active'); });
            btn.classList.add('active');

            // Show/hide content for all three tabs
            document.getElementById('tagExplorerMessages').style.display = tab === 'messages' ? 'block' : 'none';
            document.getElementById('tagExplorerPosts').style.display = tab === 'posts' ? 'block' : 'none';
            document.getElementById('tagExplorerManifestos').style.display = tab === 'manifestos' ? 'block' : 'none';
        };

        window.closeTagExplorer = function() {
            var modal = document.getElementById('tagExplorerModal');
            if (modal) modal.classList.remove('active');
        };

        // Set global tag filter from Tag Explorer
        window.setGlobalTagFilter = function(tag) {
            closeTagExplorer();
            filterByTag(tag);
        };

        // Close tag explorer on overlay click
        document.addEventListener('click', function(e) {
            if (e.target.id === 'tagExplorerModal') {
                closeTagExplorer();
            }
        });

        // === FEEDBACK HUB INTEGRATION ===
        var feedbackData = [];
        var feedbackVotes = {};
        var feedbackFilter = 'all';
        var feedbackCategory = 'apps';

        // Format time ago for feedback cards
        function formatTimeAgo(date) {
            var now = new Date();
            var seconds = Math.floor((now - date) / 1000);

            if (seconds < 60) return 'just now';
            if (seconds < 3600) return Math.floor(seconds / 60) + 'm ago';
            if (seconds < 86400) return Math.floor(seconds / 3600) + 'h ago';
            if (seconds < 604800) return Math.floor(seconds / 86400) + 'd ago';
            return date.toLocaleDateString();
        }

        async function loadFeedback() {
            var listEl = document.getElementById('feedbackList');
            if (!listEl) return;

            listEl.innerHTML = '<div class="feedback-empty">Loading ideas...</div>';

            try {
                // Load feedback
                var { data, error } = await supabase
                    .from('feedback')
                    .select('id, title, description, category, votes, status, user_id, created_at')
                    .order('votes', { ascending: false });

                if (error) throw error;
                feedbackData = data || [];

                // Load user's votes
                if (currentUser) {
                    var { data: votes } = await supabase
                        .from('feedback_votes')
                        .select('feedback_id, vote_type')
                        .eq('user_id', currentUser.id);

                    feedbackVotes = {};
                    (votes || []).forEach(function(v) {
                        feedbackVotes[v.feedback_id] = v.vote_type;
                    });
                }

                updateFeedbackStats();
                renderFeedback();
            } catch (err) {
                console.error('[Feedback] Load error:', err);
                listEl.innerHTML = '<div class="feedback-empty">Error loading ideas</div>';
            }
        }

        function updateFeedbackStats() {
            var totalVotes = feedbackData.reduce(function(sum, f) { return sum + (f.votes || 0); }, 0);
            var contributors = new Set(feedbackData.map(function(f) { return f.user_id; })).size;

            var ideasEl = document.getElementById('feedbackTotalIdeas');
            var votesEl = document.getElementById('feedbackTotalVotes');
            var contribEl = document.getElementById('feedbackContributors');

            if (ideasEl) ideasEl.textContent = feedbackData.length;
            if (votesEl) votesEl.textContent = totalVotes;
            if (contribEl) contribEl.textContent = contributors;
        }

        function renderFeedback() {
            var listEl = document.getElementById('feedbackList');
            if (!listEl) return;

            var filtered = feedbackData.filter(function(f) {
                if (feedbackFilter === 'all') return true;
                if (feedbackFilter === 'mine') return currentUser && f.user_id === currentUser.id;
                return f.category === feedbackFilter;
            });

            if (filtered.length === 0) {
                listEl.innerHTML = '<div class="feedback-empty">No ideas yet. Be the first!</div>';
                return;
            }

            listEl.innerHTML = filtered.map(function(f) {
                var isOwn = currentUser && f.user_id === currentUser.id;
                var myVote = feedbackVotes[f.id] || 0; // 1=up, -1=down, 0=none
                var voteCount = f.votes || 0;
                var timeAgo = formatTimeAgo(new Date(f.created_at));
                var scoreClass = voteCount > 0 ? 'positive' : (voteCount < 0 ? 'negative' : 'neutral');

                return '<div class="feedback-card' + (isOwn ? ' own' : '') + '">' +
                    '<div class="feedback-vote">' +
                    '<button class="feedback-vote-btn upvote' + (myVote === 1 ? ' active' : '') + '" onclick="voteFeedback(' + f.id + ', 1)">â–²</button>' +
                    '<span class="feedback-vote-count ' + scoreClass + '">' + voteCount + '</span>' +
                    '<button class="feedback-vote-btn downvote' + (myVote === -1 ? ' active' : '') + '" onclick="voteFeedback(' + f.id + ', -1)">â–¼</button>' +
                    '</div>' +
                    '<div class="feedback-content">' +
                    '<div class="feedback-title">' + escapeHtml(f.title) + '</div>' +
                    (f.description ? '<div class="feedback-desc">' + escapeHtml(f.description) + '</div>' : '') +
                    '<div class="feedback-meta">' +
                    '<span class="feedback-category-tag ' + f.category + '">' + f.category + '</span>' +
                    '<span class="feedback-time">' + timeAgo + '</span>' +
                    (isOwn ? '<button class="feedback-delete" onclick="deleteFeedback(' + f.id + ')">Delete</button>' : '') +
                    '</div>' +
                    '</div>' +
                    '</div>';
            }).join('');
        }

        window.toggleFeedbackForm = function() {
            var form = document.getElementById('feedbackForm');
            if (form) form.classList.toggle('active');
        };

        window.selectFeedbackCategory = function(cat) {
            feedbackCategory = cat;
            document.querySelectorAll('.feedback-cat-btn').forEach(function(btn) {
                btn.classList.toggle('selected', btn.dataset.category === cat);
            });
        };

        window.filterFeedback = function(filter) {
            feedbackFilter = filter;
            document.querySelectorAll('.feedback-filter').forEach(function(btn) {
                btn.classList.toggle('active', btn.dataset.filter === filter);
            });
            renderFeedback();
        };

        window.submitFeedback = async function() {
            if (!currentUser) {
                showToast('Please sign in to submit feedback', 'error');
                return;
            }

            var title = document.getElementById('feedbackTitle').value.trim();
            var desc = document.getElementById('feedbackDesc').value.trim();

            if (!title) {
                showToast('Please enter a title', 'error');
                return;
            }

            try {
                var { error } = await supabase.from('feedback').insert({
                    title: title,
                    description: desc || null,
                    category: feedbackCategory,
                    votes: 0,
                    status: 'new',
                    user_id: currentUser.id
                });

                if (error) throw error;

                document.getElementById('feedbackTitle').value = '';
                document.getElementById('feedbackDesc').value = '';
                document.getElementById('feedbackForm').classList.remove('active');

                showToast('Idea submitted!', 'success');
                loadFeedback();
            } catch (err) {
                console.error('[Feedback] Submit error:', err);
                showToast('Error submitting idea', 'error');
            }
        };

        window.voteFeedback = async function(feedbackId, direction) {
            if (!currentUser) {
                showToast('Please sign in to vote', 'error');
                return;
            }

            var currentVote = feedbackVotes[feedbackId] || 0;
            var feedback = feedbackData.find(function(f) { return f.id === feedbackId; });
            if (!feedback) return;

            try {
                // If clicking same direction as current vote, remove vote
                if (direction === currentVote) {
                    await supabase.from('feedback_votes')
                        .delete()
                        .eq('feedback_id', feedbackId)
                        .eq('user_id', currentUser.id);

                    // Adjust votes count (remove the vote value)
                    await supabase.from('feedback')
                        .update({ votes: (feedback.votes || 0) - direction })
                        .eq('id', feedbackId);

                    delete feedbackVotes[feedbackId];
                } else {
                    // If had previous vote, adjust score and delete old vote
                    if (currentVote !== 0) {
                        await supabase.from('feedback_votes')
                            .delete()
                            .eq('feedback_id', feedbackId)
                            .eq('user_id', currentUser.id);

                        // Remove old vote value from count
                        feedback.votes = (feedback.votes || 0) - currentVote;
                    }

                    // Add new vote with direction
                    await supabase.from('feedback_votes').insert({
                        feedback_id: feedbackId,
                        vote_type: direction,
                        user_id: currentUser.id
                    });

                    // Update votes count with new direction
                    await supabase.from('feedback')
                        .update({ votes: (feedback.votes || 0) + direction })
                        .eq('id', feedbackId);

                    feedbackVotes[feedbackId] = direction;
                }

                loadFeedback();
            } catch (err) {
                console.error('[Feedback] Vote error:', err);
                showToast('Error voting', 'error');
            }
        };

        window.deleteFeedback = async function(feedbackId) {
            if (!currentUser) return;

            if (!confirm('Delete this idea?')) return;

            try {
                await supabase.from('feedback')
                    .delete()
                    .eq('id', feedbackId)
                    .eq('user_id', currentUser.id);

                showToast('Idea deleted', 'info');
                loadFeedback();
            } catch (err) {
                console.error('[Feedback] Delete error:', err);
                showToast('Error deleting idea', 'error');
            }
        };

        // === CROSS-APP PROFILE STATS ===
        async function getCrossAppStats(username) {
            var gameScores = [];

            try {
                // Query multiple leaderboard tables in parallel
                var [breakout, icyTower, tetris, starCatcher] = await Promise.all([
                    supabase.from('breakout_terminal_scores').select('score, display_name').eq('display_name', username).order('score', { ascending: false }).limit(1),
                    supabase.from('icy_tower_scores').select('score, display_name').eq('display_name', username).order('score', { ascending: false }).limit(1),
                    supabase.from('tetris_leaderboard').select('score, display_name').eq('display_name', username).order('score', { ascending: false }).limit(1),
                    supabase.from('star_catcher_leaderboard').select('score, display_name').eq('display_name', username).order('score', { ascending: false }).limit(1)
                ]);

                if (breakout.data && breakout.data[0]) {
                    gameScores.push({ game: 'Breakout', score: breakout.data[0].score });
                }
                if (icyTower.data && icyTower.data[0]) {
                    gameScores.push({ game: 'Icy Tower', score: icyTower.data[0].score });
                }
                if (tetris.data && tetris.data[0]) {
                    gameScores.push({ game: 'Tetris', score: tetris.data[0].score });
                }
                if (starCatcher.data && starCatcher.data[0]) {
                    gameScores.push({ game: 'Star Catcher', score: starCatcher.data[0].score });
                }
            } catch (err) {
                console.error('[CrossApp] Error fetching scores:', err);
            }

            return gameScores;
        }

        // === RALPH WIGGUM BOT ===
        // "Me fail code? That's unpossible!"
        var RALPH_QUOTES = [
            "Me fail English? That's unpossible!",
            "I'm learnding!",
            "I bent my wookie.",
            "My cat's breath smells like cat food.",
            "I'm in danger!",
            "I found a moon rock in my nose!",
            "The doctor said I wouldn't have so many nose bleeds if I kept my finger outta there.",
            "My knob tastes funny.",
            "I'm a unitard!",
            "I heard your dad went into a restaurant and ate everything in the restaurant.",
            "That's where I saw the leprechaun. He tells me to burn things.",
            "I'm Idaho!",
            "When I grow up, I want to be a principal or a caterpillar.",
            "I sleep in a drawer!",
            "My parents won't let me use scissors.",
            "I glued my head to my shoulder once.",
            "I'm going to Bovine University!",
            "What's a battle?",
            "Mrs. Krabappel and Principal Skinner were in the closet making babies and I saw one of the babies and the baby looked at me.",
            "Go banana!",
            "I dress myself!",
            "Bushes are nice cause they don't have prickers. Unless they do. This one did. Ouch!",
            "I eated the purple berries.",
            "My sandbox at home is full of cat poop!",
            "Hi Super Nintendo Chalmers!",
            "I'm a brick!",
            "Slow down, I want to get off!",
            "Can you open my milk, Mommy?",
            "The pointy kitty took it!",
            "I put the glue inside the computer now!"
        ];

        window.summonRalph = function() {
            var quote = RALPH_QUOTES[Math.floor(Math.random() * RALPH_QUOTES.length)];

            var ralphMsg = {
                id: 'ralph_' + Date.now(),
                username: 'ðŸ§’ Ralph Wiggum',
                avatar: 'ðŸ§’',
                avatarUrl: null,
                content: quote,
                image_data: null,
                drawing_data: null,
                message_type: 'text',
                user_id: 'ralph_bot',
                created_at: new Date().toISOString()
            };

            addMessageToUI(ralphMsg, true);
            broadcastMessage(ralphMsg);
            addToFeed('ðŸ§’ Ralph Wiggum', 'shared wisdom');
            showToast('ðŸ§’ Ralph has spoken!', 'info');
        };

        // Ralph-ify text transformation
        window.ralphify = function(text) {
            var suffixes = [
                " My cat's breath smells like cat food.",
                " I'm learnding!",
                " That's unpossible!",
                " I bent my wookie.",
                " Go banana!",
                " I'm a brick!"
            ];
            return text + suffixes[Math.floor(Math.random() * suffixes.length)];
        };

        // Listen for /ralph command in messages
        function checkForRalphCommand(content) {
            if (content && content.toLowerCase().trim() === '/ralph') {
                setTimeout(function() {
                    window.summonRalph();
                }, 500);
                return true;
            }
            return false;
        }

        // Send message
        window.sendMessage = async function() {
            const input = getCachedElement('messageInput');
            const rawContent = input.value.trim();

            if (!rawContent && !selectedImage) return;

            // Check for /ralph command
            if (checkForRalphCommand(rawContent)) {
                input.value = '';
                return;
            }

            // Sanitize content before storage (defense-in-depth, preserves [bracket] markup)
            const content = rawContent ? sanitizeForStorage(rawContent, 5000) : null;

            // Rate limiting check
            const rateCheck = checkRateLimit('message');
            if (!rateCheck.allowed) {
                showToast(rateCheck.message, 'warning');
                return;
            }
            recordAction('message');

            const tempId = 'temp_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
            const hasImage = !!selectedImage;
            const localImageData = selectedImage; // keep reference for optimistic UI

            const msg = {
                id: tempId,
                username: profile.username,
                avatar: profile.avatar,
                avatarUrl: profile.avatarUrl || null,
                content: content,
                image_data: localImageData || null, // temp local preview
                drawing_data: null,
                message_type: hasImage ? 'image' : 'text',
                user_id: (currentUser && currentUser.id) ? currentUser.id : null,
                created_at: new Date().toISOString()
            };

            input.value = '';
            input.style.height = 'auto';
            removeImage();

            seenMessageIds.add(tempId);
            addMessageToUI(msg, true); // prepend at top
            broadcastMessage(msg);
            addToFeed(profile.username, hasImage ? 'shared an image' : 'sent a message');

            // Upload image to storage if present
            let finalImageData = null;
            if (localImageData) {
                const blob = dataURLtoBlob(localImageData);
                const storageUrl = await uploadToStorage(blob, 'chat');
                finalImageData = storageUrl || localImageData; // fallback to base64
            }

            const { data, error } = await supabase
                .from('sloppygram_messages')
                .insert({
                    username: msg.username,
                    avatar: msg.avatar,
                    avatar_url: msg.avatarUrl,
                    content: msg.content,
                    image_data: finalImageData,
                    drawing_data: msg.drawing_data,
                    message_type: msg.message_type,
                    user_id: msg.user_id
                })
                .select('id')
                .single();

            if (error) {
                console.error('Send error:', error);
                return;
            }

            if (data && data.id) {
                seenMessageIds.add(data.id);

                // Persist tags to database
                if (content) {
                    persistMessageTags(data.id, content, msg.user_id);
                }

                // Save mentions to database for notifications
                if (content && typeof saveMentions === 'function') {
                    saveMentions(content, 'message', data.id);
                }
            }
        };

        // Delete message
        window.deleteMessage = async function(messageId) {
            if (!currentUser) return;
            if (!confirm('Delete this message?')) return;

            const { error } = await supabase
                .from('sloppygram_messages')
                .delete()
                .eq('id', messageId)
                .eq('user_id', currentUser.id);

            if (error) {
                console.error('Delete error:', error);
                return;
            }

            // Remove from UI
            const container = getCachedElement('messagesContainer');
            const msgElements = container.querySelectorAll('.message');
            msgElements.forEach(el => {
                const voteControl = el.querySelector(`[data-chat-id="${messageId}"]`);
                const doodleControl = el.querySelector(`[data-doodle-id="${messageId}"]`);
                if (voteControl || doodleControl) {
                    el.remove();
                }
            });
        };

        // Send drawing
        window.sendDrawing = async function() {
            // Rate limiting check
            const rateCheck = checkRateLimit('drawing');
            if (!rateCheck.allowed) {
                showToast(rateCheck.message, 'warning');
                return;
            }
            recordAction('drawing');

            const canvas = getCachedElement('drawingCanvas');
            const drawingDataUrl = canvas.toDataURL('image/png');

            const tempId = 'temp_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);

            // Show optimistic UI with local data URL first
            const msg = {
                id: tempId,
                username: profile.username,
                avatar: profile.avatar,
                avatarUrl: profile.avatarUrl || null,
                content: null,
                image_data: null,
                drawing_data: drawingDataUrl, // temporary local preview
                message_type: 'drawing',
                user_id: (currentUser && currentUser.id) ? currentUser.id : null,
                created_at: new Date().toISOString()
            };

            closeDrawingModal();
            clearCanvas();

            seenMessageIds.add(tempId);
            addMessageToUI(msg, true); // prepend at top
            broadcastMessage(msg);
            addToFeed(profile.username, 'shared a drawing');

            // Upload to storage instead of saving base64
            const blob = dataURLtoBlob(drawingDataUrl);
            const storageUrl = await uploadToStorage(blob, 'doodles');

            // Use storage URL if upload succeeded, otherwise fallback to base64
            const finalDrawingData = storageUrl || drawingDataUrl;

            const { data, error } = await supabase
                .from('sloppygram_messages')
                .insert({
                    username: msg.username,
                    avatar: msg.avatar,
                    avatar_url: msg.avatarUrl,
                    content: msg.content,
                    image_data: msg.image_data,
                    drawing_data: finalDrawingData,
                    message_type: msg.message_type,
                    user_id: msg.user_id
                })
                .select('id')
                .single();

            if (error) {
                console.error('Send error:', error);
            }

            if (data && data.id) {
                seenMessageIds.add(data.id);
            }
        };

        // Image handling
        window.handleImageSelect = function(event) {
            const file = event.target.files[0];
            if (!file) return;

            if (file.size > 500000) {
                alert('FILE TOO LARGE. MAX 500KB.');
                return;
            }

            const reader = new FileReader();
            reader.onload = (e) => {
                selectedImage = e.target.result;
                document.getElementById('previewImg').src = selectedImage;
                document.getElementById('imagePreview').style.display = 'block';
            };
            reader.readAsDataURL(file);
        };

        window.removeImage = function() {
            selectedImage = null;
            safeSetDisplay('imagePreview', 'none');
            var imageInput = document.getElementById('imageInput');
            if (imageInput) imageInput.value = '';
        };

        // Settings modal
        let pendingAvatarData = null;
        let pendingBgData = null;

        // Sound settings
        let soundSettings = {
            sound: 'none',
            volume: 50,
            customData: '',
            customName: ''
        };

        // Audio context for generating sounds
        let audioContext = null;
        let customSoundAudio = null;

        function getAudioContext() {
            if (!audioContext) {
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
            }
            // Resume if suspended (browser autoplay policy)
            if (audioContext.state === 'suspended') {
                audioContext.resume();
            }
            return audioContext;
        }

        // Sound library using Web Audio API (procedural sounds)
        const soundLibrary = {
            blip: function(ctx, vol) {
                const osc = ctx.createOscillator();
                const gain = ctx.createGain();
                osc.connect(gain);
                gain.connect(ctx.destination);
                osc.frequency.setValueAtTime(800, ctx.currentTime);
                osc.frequency.exponentialRampToValueAtTime(400, ctx.currentTime + 0.1);
                gain.gain.setValueAtTime(vol, ctx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, ctx.currentTime + 0.1);
                osc.start(ctx.currentTime);
                osc.stop(ctx.currentTime + 0.1);
            },
            chime: function(ctx, vol) {
                [523, 659, 784].forEach((freq, i) => {
                    const osc = ctx.createOscillator();
                    const gain = ctx.createGain();
                    osc.type = 'sine';
                    osc.connect(gain);
                    gain.connect(ctx.destination);
                    osc.frequency.setValueAtTime(freq, ctx.currentTime + i * 0.08);
                    gain.gain.setValueAtTime(vol * 0.6, ctx.currentTime + i * 0.08);
                    gain.gain.exponentialRampToValueAtTime(0.01, ctx.currentTime + i * 0.08 + 0.3);
                    osc.start(ctx.currentTime + i * 0.08);
                    osc.stop(ctx.currentTime + i * 0.08 + 0.3);
                });
            },
            pop: function(ctx, vol) {
                const osc = ctx.createOscillator();
                const gain = ctx.createGain();
                osc.type = 'sine';
                osc.connect(gain);
                gain.connect(ctx.destination);
                osc.frequency.setValueAtTime(600, ctx.currentTime);
                osc.frequency.exponentialRampToValueAtTime(200, ctx.currentTime + 0.05);
                gain.gain.setValueAtTime(vol, ctx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, ctx.currentTime + 0.05);
                osc.start(ctx.currentTime);
                osc.stop(ctx.currentTime + 0.05);
            },
            retro: function(ctx, vol) {
                const osc = ctx.createOscillator();
                const gain = ctx.createGain();
                osc.type = 'square';
                osc.connect(gain);
                gain.connect(ctx.destination);
                osc.frequency.setValueAtTime(440, ctx.currentTime);
                osc.frequency.setValueAtTime(880, ctx.currentTime + 0.05);
                osc.frequency.setValueAtTime(440, ctx.currentTime + 0.1);
                gain.gain.setValueAtTime(vol * 0.3, ctx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, ctx.currentTime + 0.15);
                osc.start(ctx.currentTime);
                osc.stop(ctx.currentTime + 0.15);
            },
            cyber: function(ctx, vol) {
                const osc = ctx.createOscillator();
                const osc2 = ctx.createOscillator();
                const gain = ctx.createGain();
                osc.type = 'sawtooth';
                osc2.type = 'square';
                osc.connect(gain);
                osc2.connect(gain);
                gain.connect(ctx.destination);
                osc.frequency.setValueAtTime(150, ctx.currentTime);
                osc.frequency.linearRampToValueAtTime(600, ctx.currentTime + 0.1);
                osc2.frequency.setValueAtTime(300, ctx.currentTime);
                osc2.frequency.linearRampToValueAtTime(100, ctx.currentTime + 0.1);
                gain.gain.setValueAtTime(vol * 0.2, ctx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, ctx.currentTime + 0.12);
                osc.start(ctx.currentTime);
                osc2.start(ctx.currentTime);
                osc.stop(ctx.currentTime + 0.12);
                osc2.stop(ctx.currentTime + 0.12);
            },
            whoosh: function(ctx, vol) {
                const bufferSize = ctx.sampleRate * 0.15;
                const buffer = ctx.createBuffer(1, bufferSize, ctx.sampleRate);
                const data = buffer.getChannelData(0);
                for (let i = 0; i < bufferSize; i++) {
                    data[i] = (Math.random() * 2 - 1) * (1 - i / bufferSize);
                }
                const noise = ctx.createBufferSource();
                const filter = ctx.createBiquadFilter();
                const gain = ctx.createGain();
                noise.buffer = buffer;
                filter.type = 'bandpass';
                filter.frequency.setValueAtTime(1000, ctx.currentTime);
                filter.frequency.exponentialRampToValueAtTime(200, ctx.currentTime + 0.15);
                noise.connect(filter);
                filter.connect(gain);
                gain.connect(ctx.destination);
                gain.gain.setValueAtTime(vol, ctx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, ctx.currentTime + 0.15);
                noise.start(ctx.currentTime);
            },
            ding: function(ctx, vol) {
                const osc = ctx.createOscillator();
                const gain = ctx.createGain();
                osc.type = 'sine';
                osc.connect(gain);
                gain.connect(ctx.destination);
                osc.frequency.setValueAtTime(1200, ctx.currentTime);
                gain.gain.setValueAtTime(vol * 0.5, ctx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, ctx.currentTime + 0.4);
                osc.start(ctx.currentTime);
                osc.stop(ctx.currentTime + 0.4);
            }
        };

        function playNotificationSound() {
            if (soundSettings.sound === 'none') return;
            const vol = soundSettings.volume / 100;

            // Custom sound (base64 data)
            if (soundSettings.sound === 'custom' && soundSettings.customData) {
                try {
                    if (!customSoundAudio || customSoundAudio.src !== soundSettings.customData) {
                        customSoundAudio = new Audio(soundSettings.customData);
                    }
                    customSoundAudio.volume = vol;
                    customSoundAudio.currentTime = 0;
                    customSoundAudio.play().catch(e => console.log('Audio play failed:', e));
                } catch (e) {
                    console.log('Custom sound error:', e);
                }
                return;
            }

            // Built-in sounds
            const ctx = getAudioContext();
            if (soundLibrary[soundSettings.sound]) {
                soundLibrary[soundSettings.sound](ctx, vol);
            }
        }

        window.previewSound = function(soundName) {
            const vol = soundSettings.volume / 100;

            if (soundName === 'custom') {
                const data = soundSettings.customData;
                if (data) {
                    try {
                        const audio = new Audio(data);
                        audio.volume = vol;
                        audio.play().catch(e => console.log('Audio play failed:', e));
                    } catch (e) {
                        console.log('Custom sound error:', e);
                    }
                } else {
                    alert('Upload a custom sound file first');
                }
                return;
            }

            const ctx = getAudioContext();
            if (soundLibrary[soundName]) {
                soundLibrary[soundName](ctx, vol);
            }
        };

        window.handleSoundUpload = function(event) {
            const file = event.target.files[0];
            if (!file) return;

            if (file.size > 500000) {
                alert('Audio file too large! Max 500KB.');
                return;
            }

            const reader = new FileReader();
            reader.onload = function(e) {
                soundSettings.customData = e.target.result;
                soundSettings.customName = file.name;
                document.getElementById('customSoundName').textContent = 'â™ª ' + file.name;
                document.getElementById('customSoundName').style.display = 'block';
                document.getElementById('clearSoundBtn').style.display = 'inline-block';
                // Auto-select custom sound
                selectSound('custom');
            };
            reader.readAsDataURL(file);
        };

        window.clearCustomSound = function() {
            soundSettings.customData = '';
            soundSettings.customName = '';
            document.getElementById('customSoundFile').value = '';
            document.getElementById('customSoundName').style.display = 'none';
            document.getElementById('clearSoundBtn').style.display = 'none';
            if (soundSettings.sound === 'custom') {
                selectSound('none');
            }
        };

        window.selectSound = function(soundName) {
            soundSettings.sound = soundName;
            document.querySelectorAll('.sound-option').forEach(opt => opt.classList.remove('selected'));
            document.querySelector(`.sound-option[onclick*="'${soundName}'"]`).classList.add('selected');
        };

        window.setVolume = function(value) {
            soundSettings.volume = parseInt(value);
            document.getElementById('volumeValue').textContent = value + '%';
        };

        window.saveSoundSettings = function() {
            secureStorageSet('sloppygram_sounds', soundSettings);

            // Broadcast sound setting globally
            broadcastGlobalSetting('sound', soundSettings.sound, soundSettings.customData || '');

            closeSettingsModal();
        };

        function loadSoundSettings() {
            const saved = secureStorageGet('sloppygram_sounds');
            if (saved) {
                soundSettings = saved;
                document.getElementById('volumeSlider').value = soundSettings.volume;
                document.getElementById('volumeValue').textContent = soundSettings.volume + '%';
                document.querySelectorAll('.sound-option').forEach(opt => opt.classList.remove('selected'));
                const selectedOpt = document.querySelector(`.sound-option[onclick*="'${soundSettings.sound}'"]`);
                if (selectedOpt) selectedOpt.classList.add('selected');
                // Load custom sound info
                if (soundSettings.customData && soundSettings.customName) {
                    document.getElementById('customSoundName').textContent = 'â™ª ' + soundSettings.customName;
                    document.getElementById('customSoundName').style.display = 'block';
                    document.getElementById('clearSoundBtn').style.display = 'inline-block';
                }
            }
        }

        // === GLOBAL SETTINGS SYNC ===
        async function broadcastGlobalSetting(settingType, settingValue, extraData = '') {
            if (!currentUser) return;

            // Anti-strobe protection: rate limit global visual changes (backgrounds, themes)
            if (settingType === 'background' || settingType === 'theme') {
                const rateCheck = checkRateLimit('global_visual');
                if (!rateCheck.allowed) {
                    showToast(`Cooldown active. Wait ${rateCheck.waitTime}s before changing visuals again.`, 'warning');
                    return;
                }
                recordAction('global_visual');
            }

            // Broadcast via realtime channel for instant update
            if (globalSettingsChannel) {
                globalSettingsChannel.send({
                    type: 'broadcast',
                    event: 'global_setting',
                    payload: {
                        setting_type: settingType,
                        setting_value: settingValue,
                        username: profile.username,
                        extra_data: extraData
                    }
                });
            }

            // Also save to database for persistence
            try {
                await supabase.from('sloppygram_global_settings').insert({
                    setting_type: settingType,
                    setting_value: settingValue,
                    username: profile.username,
                    extra_data: extraData,
                    user_id: currentUser.id
                });
            } catch (e) {
                console.error('Error saving global setting:', e);
            }
        }

        function applyGlobalSetting(settingType, settingValue, username, extraData) {
            const notification = `ðŸŒ ${username} changed global ${settingType}!`;

            switch (settingType) {
                case 'background':
                    // Skip if user has local mode enabled (their local background takes precedence)
                    if (isLocalThemeMode && localBackground) {
                        console.log('[Local Mode] Ignoring global background change from', username);
                        addToFeed(username, 'set global background (you have local override)');
                        return;
                    }

                    // Anti-strobe protection: throttle rapid incoming visual changes
                    const now = Date.now();
                    if (now - lastVisualChangeTime < VISUAL_CHANGE_COOLDOWN) {
                        console.warn('[Anti-strobe] Blocked rapid visual change from', username);
                        return; // Silently ignore rapid changes
                    }
                    lastVisualChangeTime = now;

                    const msgContainer = getCachedElement('messagesContainer');
                    if (msgContainer && settingValue) {
                        msgContainer.style.backgroundImage = `url(${settingValue})`;
                        msgContainer.style.backgroundSize = 'cover';
                        msgContainer.style.backgroundPosition = 'center';
                        msgContainer.style.backgroundAttachment = 'fixed';
                        addToFeed(username, 'set global background');
                    }
                    break;

                case 'sound':
                    soundSettings.sound = settingValue;
                    if (extraData) {
                        soundSettings.customData = extraData;
                    }
                    document.querySelectorAll('.sound-option').forEach(opt => opt.classList.remove('selected'));
                    const selectedOpt = document.querySelector(`.sound-option[onclick*="'${settingValue}'"]`);
                    if (selectedOpt) selectedOpt.classList.add('selected');
                    addToFeed(username, `set global sound to ${settingValue}`);
                    // Play the sound so everyone hears it
                    playNotificationSound();
                    break;

                case 'avatar':
                    // Show notification that someone changed their avatar globally
                    addToFeed(username, 'updated their avatar');
                    break;
            }
        }

        async function loadGlobalSettings() {
            // Load most recent global settings from database
            const { data: bgData } = await supabase
                .from('sloppygram_global_settings')
                .select('setting_type, setting_value, username, extra_data, created_at')
                .eq('setting_type', 'background')
                .order('created_at', { ascending: false })
                .limit(1);

            if (bgData && bgData[0] && bgData[0].setting_value) {
                applyGlobalSetting('background', bgData[0].setting_value, bgData[0].username, '');
            }

            const { data: soundData } = await supabase
                .from('sloppygram_global_settings')
                .select('setting_type, setting_value, username, extra_data, created_at')
                .eq('setting_type', 'sound')
                .order('created_at', { ascending: false })
                .limit(1);

            if (soundData && soundData[0]) {
                applyGlobalSetting('sound', soundData[0].setting_value, soundData[0].username, soundData[0].extra_data);
            }
        }

        async function subscribeToGlobalSettings() {
            // Clean up existing channel
            if (globalSettingsChannel) {
                channelState.globalSettings.ready = false;
                globalSettingsChannel.unsubscribe();
                supabase.removeChannel(globalSettingsChannel);
            }

            globalSettingsChannel = supabase.channel('sloppygram-global-settings', {
                config: { broadcast: { self: false } }
            });

            globalSettingsChannel.on('broadcast', { event: 'global_setting' }, (payload) => {
                const { setting_type, setting_value, username, extra_data } = payload.payload;
                applyGlobalSetting(setting_type, setting_value, username, extra_data);
            });

            // Use Promise-based subscription with state tracking
            channelState.globalSettings.pending = subscribeWithPromise(globalSettingsChannel, 'globalSettings');
            await channelState.globalSettings.pending;
        }

        window.switchSettingsTab = function(tab) {
            document.querySelectorAll('.settings-tab').forEach(t => t.classList.remove('active'));
            document.querySelectorAll('.settings-panel').forEach(p => p.classList.remove('active'));
            document.querySelector(`.settings-tab[onclick*="'${tab}'"]`).classList.add('active');
            document.getElementById(tab + 'Panel').classList.add('active');
        };

        window.openSettingsModal = async function() {
            // Load profile and trust data for SloppyID card
            var avatarEl = document.getElementById('settingsProfileAvatar');
            var nameEl = document.getElementById('settingsProfileName');
            var trustEl = document.getElementById('settingsProfileTrust');
            var badgesEl = document.getElementById('settingsProfileBadges');

            if (avatarEl) avatarEl.textContent = profile.avatarUrl ? '' : (profile.avatar || 'ðŸ‘¤');
            if (avatarEl && profile.avatarUrl) avatarEl.innerHTML = '<img src="' + escapeHtml(profile.avatarUrl) + '" width="48" height="48" style="border-radius:50%;object-fit:cover;">';
            if (nameEl) nameEl.textContent = profile.username || 'Anonymous';

            // Load trust data
            if (profile.username) {
                var trustData = await getUserVerifications(profile.username);
                if (trustEl) trustEl.innerHTML = trustData.trustScore > 0 ? 'âš¡' + trustData.trustScore + ' Trust' : '';
                if (badgesEl && trustData.verifications.length > 0) {
                    badgesEl.innerHTML = trustData.verifications.map(function(v) {
                        return '<span class="settings-verify-badge ' + v.type + '">' + escapeHtml(v.label) + '</span>';
                    }).join('');
                } else if (badgesEl) {
                    badgesEl.innerHTML = '<span class="settings-no-badges">No verifications yet</span>';
                }
            }

            // Show current bg preview if exists (with null checks)
            pendingBgData = profile.bgUrl || null;
            if (pendingBgData) {
                var bgImg = document.getElementById('bgPreviewImg');
                if (bgImg) bgImg.src = pendingBgData;
                safeSetDisplay('bgPreview', 'block');
                safeSetDisplay('clearBgBtn', 'block');
                safeSetDisplay('shareBgBtn', 'block');
                safeSetDisplay('setGlobalBgBtn', 'block');
            } else {
                safeSetDisplay('bgPreview', 'none');
                safeSetDisplay('clearBgBtn', 'none');
                safeSetDisplay('shareBgBtn', 'none');
                safeSetDisplay('setGlobalBgBtn', 'none');
            }

            loadSoundSettings();
            updateThemeUI();
            await loadGlobalBackgrounds();
            document.getElementById('settingsModal').classList.add('active');
        };

        window.closeSettingsModal = function() {
            document.getElementById('settingsModal').classList.remove('active');
            pendingAvatarData = null;
            pendingBgData = null;
        };

        // === SUPPORT MODAL SYSTEM ===
        const CRYPTO_ADDRESSES = {
            btc: 'bc1qxy2kgdygjrsqtzq2n0yrf2493p83kkfjhx0wlh',      // TODO: Replace with actual BTC address
            eth: '0x742d35Cc6634C0532925a3b844Bc9e7595f000000',     // TODO: Replace with actual ETH address
            sol: '7EcDhSYGxXyscszYEp35KHN8vvw3svAuLKTzXwCFLtV0',   // TODO: Replace with actual SOL address
            xmr: '888tNkZrPN6JsEgekjMnABU4TBzc2Dt29EPAvkRx00000'   // TODO: Replace with actual XMR address
        };

        const CRYPTO_NAMES = {
            btc: 'Bitcoin',
            eth: 'Ethereum',
            sol: 'Solana',
            xmr: 'Monero'
        };

        window.openSupportModal = function() {
            document.getElementById('supportModal').classList.add('visible');
        };

        window.closeSupportModal = function() {
            document.getElementById('supportModal').classList.remove('visible');
        };

        // Share Modal Functions - Gold Master version
        var SHARE_CONFIG = {
            baseUrl: 'https://sloppy.live/sloppygram',
            defaultText: 'Check out The Archive of Synthesis - retro cyber chatroom vibes from 1999! ðŸ–¥ï¸ðŸ’¾',
            hashtags: 'archiveofsynthesis,retro,chat'
        };

        // Get current share URL (allows for future deep linking)
        function getShareUrl(context) {
            var base = SHARE_CONFIG.baseUrl;
            // Could extend for deep links: /sloppygram?post=123 or /sloppygram#doodle/456
            if (context && context.type && context.id) {
                return base + '#' + context.type + '/' + context.id;
            }
            return base;
        }

        // Get share text based on context
        function getShareText(context) {
            if (context && context.text) {
                return context.text;
            }
            return SHARE_CONFIG.defaultText;
        }

        // === IMAGE LIGHTBOX ===
        window.openLightbox = function(src) {
            var lightbox = document.getElementById('imageLightbox');
            var img = document.getElementById('lightboxImage');
            if (lightbox && img) {
                img.src = src;
                lightbox.classList.add('active');
                document.body.style.overflow = 'hidden';
            }
        };

        window.closeLightbox = function() {
            var lightbox = document.getElementById('imageLightbox');
            if (lightbox) {
                lightbox.classList.remove('active');
                document.body.style.overflow = '';
            }
        };

        // Close lightbox on Escape key
        document.addEventListener('keydown', function(e) {
            if (e.key === 'Escape') {
                var lightbox = document.getElementById('imageLightbox');
                if (lightbox && lightbox.classList.contains('active')) {
                    closeLightbox();
                }
            }
        });

        window.openShareModal = function(context) {
            var modal = document.getElementById('shareModal');
            if (modal) modal.classList.add('visible');

            var shareUrl = getShareUrl(context);
            var shareText = getShareText(context);

            // Update share URLs with proper encoding
            var twitterBtn = document.getElementById('shareTwitterBtn');
            var redditBtn = document.getElementById('shareRedditBtn');
            var copyBtn = document.getElementById('shareCopyBtn');

            if (twitterBtn) {
                var twitterUrl = 'https://twitter.com/intent/tweet?' +
                    'text=' + encodeURIComponent(shareText) +
                    '&url=' + encodeURIComponent(shareUrl) +
                    '&hashtags=' + encodeURIComponent(SHARE_CONFIG.hashtags);
                twitterBtn.href = twitterUrl;
            }

            if (redditBtn) {
                var redditUrl = 'https://reddit.com/submit?' +
                    'url=' + encodeURIComponent(shareUrl) +
                    '&title=' + encodeURIComponent(shareText);
                redditBtn.href = redditUrl;
            }

            // Store URL for copy button
            if (copyBtn) {
                copyBtn.setAttribute('data-share-url', shareUrl);
            }
        };

        window.closeShareModal = function() {
            var modal = document.getElementById('shareModal');
            if (modal) modal.classList.remove('visible');
        };

        window.copyShareLink = async function() {
            var copyBtn = document.getElementById('shareCopyBtn');

            // Get URL from data attribute or fall back to default
            var shareUrl = (copyBtn && copyBtn.getAttribute('data-share-url')) || SHARE_CONFIG.baseUrl;

            try {
                if (navigator.clipboard && navigator.clipboard.writeText) {
                    await navigator.clipboard.writeText(shareUrl);
                } else {
                    // Fallback for older browsers
                    var textarea = document.createElement('textarea');
                    textarea.value = shareUrl;
                    textarea.style.position = 'fixed';
                    textarea.style.opacity = '0';
                    textarea.style.left = '-9999px';
                    document.body.appendChild(textarea);
                    textarea.focus();
                    textarea.select();

                    var success = false;
                    try {
                        success = document.execCommand('copy');
                    } catch (e) {
                        success = false;
                    }
                    document.body.removeChild(textarea);

                    if (!success) {
                        throw new Error('execCommand failed');
                    }
                }

                // Show copied state
                if (copyBtn) {
                    copyBtn.classList.add('copied');
                    copyBtn.innerHTML = '<span class="share-btn-icon">âœ“</span><span>Copied!</span>';
                    setTimeout(function() {
                        copyBtn.classList.remove('copied');
                        copyBtn.innerHTML = '<span class="share-btn-icon">ðŸ”—</span><span>Copy Link</span>';
                    }, 2000);
                }

                showToast('Link copied to clipboard!', 'success');
            } catch (err) {
                console.error('[copyShareLink] Failed:', err);
                showToast('Failed to copy link', 'error');
            }
        };

        window.copyCryptoAddress = async function(crypto) {
            const address = CRYPTO_ADDRESSES[crypto];
            if (!address) return;

            try {
                await navigator.clipboard.writeText(address);
                showCopiedToast(crypto);
            } catch (err) {
                // Fallback for older browsers
                const textarea = document.createElement('textarea');
                textarea.value = address;
                textarea.style.position = 'fixed';
                textarea.style.opacity = '0';
                document.body.appendChild(textarea);
                textarea.select();
                try {
                    document.execCommand('copy');
                    showCopiedToast(crypto);
                } catch (e) {
                    alert('Failed to copy. Address: ' + address);
                }
                document.body.removeChild(textarea);
            }
        };

        // Keep old function for backwards compatibility
        window.copyBtcAddress = function() {
            copyCryptoAddress('btc');
        };

        function showCopiedToast(crypto = 'btc') {
            // Remove existing toasts
            document.querySelectorAll('.copied-toast').forEach(t => t.remove());

            const name = CRYPTO_NAMES[crypto] || 'Address';
            const toast = document.createElement('div');
            toast.className = 'copied-toast';
            toast.innerHTML = `âœ“ ${name} address copied!`;
            document.body.appendChild(toast);

            setTimeout(() => {
                if (toast.parentNode) toast.remove();
            }, 2500);
        }

        window.handleAvatarUpload = function(event) {
            const file = event.target.files[0];
            if (!file) return;

            if (file.size > 500000) {
                alert('Image too large! Max 500KB.');
                return;
            }

            const reader = new FileReader();
            reader.onload = function(e) {
                pendingAvatarData = e.target.result;
                var avatarImg = document.getElementById('avatarPreviewImg');
                if (avatarImg) avatarImg.src = pendingAvatarData;
                safeSetDisplay('avatarPreview', 'block');
                safeSetDisplay('clearAvatarBtn', 'block');
            };
            reader.readAsDataURL(file);
        };

        window.clearAvatarUpload = function() {
            pendingAvatarData = null;
            var avatarInput = document.getElementById('avatarFileInput');
            if (avatarInput) avatarInput.value = '';
            safeSetDisplay('avatarPreview', 'none');
            safeSetDisplay('clearAvatarBtn', 'none');
        };

        window.handleBgUpload = function(event) {
            const file = event.target.files[0];
            if (!file) return;

            if (file.size > 1000000) {
                alert('Image too large! Max 1MB for backgrounds.');
                return;
            }

            const reader = new FileReader();
            reader.onload = function(e) {
                pendingBgData = e.target.result;
                var bgImg = document.getElementById('bgPreviewImg');
                if (bgImg) bgImg.src = pendingBgData;
                safeSetDisplay('bgPreview', 'block');
                safeSetDisplay('clearBgBtn', 'block');
                safeSetDisplay('shareBgBtn', 'block');
                safeSetDisplay('setGlobalBgBtn', 'block');
            };
            reader.readAsDataURL(file);
        };

        window.clearBgUpload = function() {
            pendingBgData = null;
            var bgInput = document.getElementById('bgFileInput');
            if (bgInput) bgInput.value = '';
            safeSetDisplay('bgPreview', 'none');
            safeSetDisplay('clearBgBtn', 'none');
            safeSetDisplay('shareBgBtn', 'none');
            safeSetDisplay('setGlobalBgBtn', 'none');
        };

        // Global Backgrounds
        async function loadGlobalBackgrounds() {
            const { data } = await supabase
                .from('sloppygram_global_backgrounds')
                .select('id, image_data, username, name, created_at')
                .order('created_at', { ascending: false })
                .limit(20);

            globalBackgrounds = data || [];
            renderGlobalBackgrounds();
        }

        function renderGlobalBackgrounds() {
            const grid = document.getElementById('globalBgGrid');
            grid.innerHTML = globalBackgrounds.map(bg => {
                const safeBgData = sanitizeUrl(bg.image_data);
                return `
                <div class="global-bg-item ${pendingBgData === bg.image_data ? 'selected' : ''}"
                     onclick="selectGlobalBg('${bg.id}')"
                     title="${escapeHtml(bg.name || 'Shared by ' + bg.username)}">
                    <img src="${safeBgData}" alt="${escapeHtml(bg.name || 'Background')}">
                </div>`;
            }).join('') + `
                <div class="global-bg-item global-bg-upload" onclick="document.getElementById('bgFileInput').click()" title="Upload new">+</div>
            `;
        }

        window.selectGlobalBg = function(bgId) {
            const bg = globalBackgrounds.find(b => b.id == bgId);
            if (!bg) return;

            pendingBgData = bg.image_data;
            var bgImg = document.getElementById('bgPreviewImg');
            if (bgImg) bgImg.src = pendingBgData;
            safeSetDisplay('bgPreview', 'block');
            safeSetDisplay('clearBgBtn', 'block');
            safeSetDisplay('shareBgBtn', 'none'); // Already shared
            safeSetDisplay('setGlobalBgBtn', 'block'); // Can still set for everyone

            renderGlobalBackgrounds();
        };

        window.shareBackground = async function() {
            if (!pendingBgData || !currentUser) return;

            const name = prompt('Give your background a name:', 'My Background');
            if (!name) return;

            const { error } = await supabase
                .from('sloppygram_global_backgrounds')
                .insert({
                    image_data: pendingBgData,
                    username: profile.username,
                    name: name,
                    user_id: currentUser.id
                });

            if (error) {
                console.error('Error sharing background:', error);
                alert('Failed to share background');
                return;
            }

            alert('Background shared with everyone!');
            document.getElementById('shareBgBtn').style.display = 'none';
            await loadGlobalBackgrounds();
        };

        // Set background - respects local mode toggle
        window.setGlobalBackground = function() {
            if (!pendingBgData) return;

            // If local mode, save locally only
            if (isLocalThemeMode) {
                setLocalOnlyBackground(pendingBgData);
                return;
            }

            // Global mode - broadcast to everyone
            if (!realtimeChannel) return;

            // Anti-strobe protection: rate limit global visual changes
            const rateCheck = checkRateLimit('global_visual');
            if (!rateCheck.allowed) {
                showToast(`Cooldown active. Wait ${rateCheck.waitTime}s before changing visuals again.`, 'warning');
                return;
            }
            recordAction('global_visual');

            realtimeChannel.send({
                type: 'broadcast',
                event: 'global_background',
                payload: {
                    image_data: pendingBgData,
                    username: profile.username
                }
            });

            // Also apply to self (chat container only)
            const msgContainer = getCachedElement('messagesContainer');
            if (msgContainer) {
                msgContainer.style.backgroundImage = `url(${pendingBgData})`;
                msgContainer.style.backgroundSize = 'cover';
                msgContainer.style.backgroundPosition = 'center';
                msgContainer.style.backgroundAttachment = 'fixed';
                msgContainer.style.backgroundRepeat = 'no-repeat';
            }

            addToFeed(profile.username, 'set a new chat background');
        };

        // Set background locally only (does not affect other users)
        window.setLocalOnlyBackground = function(imageData) {
            const data = imageData || pendingBgData;
            if (!data) return;

            // Save to localStorage
            saveLocalBackground(data);

            // Apply to UI
            const msgContainer = getCachedElement('messagesContainer');
            if (msgContainer) {
                msgContainer.style.backgroundImage = `url(${data})`;
                msgContainer.style.backgroundSize = 'cover';
                msgContainer.style.backgroundPosition = 'center';
                msgContainer.style.backgroundAttachment = 'fixed';
                msgContainer.style.backgroundRepeat = 'no-repeat';
            }

            showToast('Background set (local only)', 'success');
        };

        // Message opacity control
        window.setMessageOpacity = function(value) {
            const opacity = value / 100;
            document.documentElement.style.setProperty('--msg-opacity', opacity);
            document.getElementById('opacityValue').textContent = value + '%';
            localStorage.setItem('sloppygram_msg_opacity', value);
        };

        function loadMessageOpacity() {
            const saved = localStorage.getItem('sloppygram_msg_opacity');
            if (saved !== null) {
                const value = parseInt(saved);
                document.documentElement.style.setProperty('--msg-opacity', value / 100);
                const slider = document.getElementById('msgOpacitySlider');
                const display = document.getElementById('opacityValue');
                if (slider) slider.value = value;
                if (display) display.textContent = value + '%';
            }
        }

        // Widget opacity control
        window.setWidgetOpacity = function(value) {
            const opacity = value / 100;
            document.documentElement.style.setProperty('--widget-opacity', opacity);
            const display = document.getElementById('widgetOpacityValue');
            if (display) display.textContent = value + '%';
            localStorage.setItem('sloppygram_widget_opacity', value);
        };

        function loadWidgetOpacity() {
            const saved = localStorage.getItem('sloppygram_widget_opacity');
            if (saved !== null) {
                const value = parseInt(saved);
                document.documentElement.style.setProperty('--widget-opacity', value / 100);
                const slider = document.getElementById('widgetOpacitySlider');
                const display = document.getElementById('widgetOpacityValue');
                if (slider) slider.value = value;
                if (display) display.textContent = value + '%';
            }
        }

        // Theme color settings
        let themeSettings = {
            msgColor: '10, 10, 15',
            msgOwnColor: '90, 112, 96',
            accentColor: '#7c9885',
            highlightColor: '#c9a87c',
            panelBg: '#12121a'
        };

        // Local theme mode - when enabled, themes/backgrounds only affect this user
        let isLocalThemeMode = localStorage.getItem('sloppygram_local_theme_mode') === 'true';
        let localBackground = localStorage.getItem('sloppygram_local_background') || null;

        // Toggle local theme mode
        window.toggleLocalThemeMode = function(enabled) {
            isLocalThemeMode = enabled;
            localStorage.setItem('sloppygram_local_theme_mode', enabled ? 'true' : 'false');
            const label = document.getElementById('themeModeLabel');
            if (label) {
                label.textContent = enabled ? 'ðŸ”’ Local' : 'ðŸŒ Global';
                label.style.color = enabled ? '#7c9885' : '#888';
            }
            // Update Set Global button visibility
            const setGlobalBtn = document.getElementById('setGlobalBgBtn');
            if (setGlobalBtn) {
                setGlobalBtn.style.display = enabled ? 'none' : 'block';
            }
            showToast(enabled ? 'Local mode: Your changes only affect you' : 'Global mode: Changes affect everyone', 'info');
        };

        // Apply local background override (called on init)
        function applyLocalBackgroundOverride() {
            if (isLocalThemeMode && localBackground) {
                const msgContainer = getCachedElement('messagesContainer');
                if (msgContainer) {
                    msgContainer.style.backgroundImage = `url(${localBackground})`;
                    msgContainer.style.backgroundSize = 'cover';
                    msgContainer.style.backgroundPosition = 'center';
                    msgContainer.style.backgroundAttachment = 'fixed';
                    msgContainer.style.backgroundRepeat = 'no-repeat';
                }
            }
        }

        // Save local background (used when local mode is on)
        function saveLocalBackground(imageData) {
            localBackground = imageData;
            try {
                localStorage.setItem('sloppygram_local_background', imageData);
            } catch (e) {
                console.warn('[Local Theme] Could not save background to localStorage:', e);
                // Try to compress or skip if too large
                showToast('Background too large for local storage', 'warning');
            }
        }

        // Helper to find color option by matching background style (more robust than onclick matching)
        function findColorOption(gridId, colorValue) {
            var options = document.querySelectorAll('#' + gridId + ' .msg-color-option');
            // Handle both RGB string format ('255,255,255') and hex format ('#4a8eff')
            var targetBg;
            if (colorValue && colorValue.startsWith('#')) {
                // Hex format - convert to rgb for comparison
                var hex = colorValue.slice(1);
                if (hex.length === 3) hex = hex[0]+hex[0]+hex[1]+hex[1]+hex[2]+hex[2];
                var r = parseInt(hex.slice(0,2), 16);
                var g = parseInt(hex.slice(2,4), 16);
                var b = parseInt(hex.slice(4,6), 16);
                targetBg = 'rgb(' + r + ', ' + g + ', ' + b + ')';
            } else {
                // RGB string format like '255,255,255'
                targetBg = 'rgb(' + colorValue + ')';
            }
            for (var i = 0; i < options.length; i++) {
                var optBg = options[i].style.background || options[i].style.backgroundColor;
                if (optBg === targetBg || optBg === targetBg.replace(/, /g, ',')) {
                    return options[i];
                }
            }
            return null;
        }

        window.selectMsgColor = function(color) {
            themeSettings.msgColor = color;
            document.documentElement.style.setProperty('--msg-color', color);
            document.querySelectorAll('#msgColorGrid .msg-color-option').forEach(opt => opt.classList.remove('selected'));
            var msgColorEl = findColorOption('msgColorGrid', color);
            if (msgColorEl) msgColorEl.classList.add('selected');
        };

        window.selectMsgOwnColor = function(color) {
            themeSettings.msgOwnColor = color;
            document.documentElement.style.setProperty('--msg-own-color', color);
            document.querySelectorAll('#msgOwnColorGrid .msg-color-option').forEach(opt => opt.classList.remove('selected'));
            var msgOwnColorEl = findColorOption('msgOwnColorGrid', color);
            if (msgOwnColorEl) msgOwnColorEl.classList.add('selected');
        };

        window.selectAccentColor = function(color) {
            themeSettings.accentColor = color;
            document.documentElement.style.setProperty('--accent', color);
            // Generate lighter and dimmer variants
            const hex = color.replace('#', '');
            const r = parseInt(hex.substr(0, 2), 16);
            const g = parseInt(hex.substr(2, 2), 16);
            const b = parseInt(hex.substr(4, 2), 16);
            const light = `rgb(${Math.min(255, r + 40)}, ${Math.min(255, g + 40)}, ${Math.min(255, b + 40)})`;
            const dim = `rgb(${Math.max(0, r - 30)}, ${Math.max(0, g - 30)}, ${Math.max(0, b - 30)})`;
            document.documentElement.style.setProperty('--accent-light', light);
            document.documentElement.style.setProperty('--accent-dim', dim);
            document.querySelectorAll('#accentColorGrid .msg-color-option').forEach(opt => opt.classList.remove('selected'));
            var accentColorEl = document.querySelector('#accentColorGrid .msg-color-option[onclick*="\'' + color + '\'"]');
            if (accentColorEl) accentColorEl.classList.add('selected');
        };

        window.selectHighlightColor = function(color) {
            themeSettings.highlightColor = color;
            document.documentElement.style.setProperty('--highlight', color);
            document.querySelectorAll('#highlightColorGrid .msg-color-option').forEach(opt => opt.classList.remove('selected'));
            var highlightColorEl = document.querySelector('#highlightColorGrid .msg-color-option[onclick*="\'' + color + '\'"]');
            if (highlightColorEl) highlightColorEl.classList.add('selected');
        };

        window.selectPanelBg = function(color) {
            themeSettings.panelBg = color;
            document.documentElement.style.setProperty('--panel-bg', color);
            // Also update dark-bg to be slightly darker than panel-bg
            const hex = color.replace('#', '');
            const r = Math.max(0, parseInt(hex.substr(0, 2), 16) - 8);
            const g = Math.max(0, parseInt(hex.substr(2, 2), 16) - 8);
            const b = Math.max(0, parseInt(hex.substr(4, 2), 16) - 5);
            const darkBg = `rgb(${r}, ${g}, ${b})`;
            document.documentElement.style.setProperty('--dark-bg', darkBg);
            // Also update border color to complement the panel
            const br = Math.min(255, parseInt(hex.substr(0, 2), 16) + 24);
            const bg = Math.min(255, parseInt(hex.substr(2, 2), 16) + 24);
            const bb = Math.min(255, parseInt(hex.substr(4, 2), 16) + 27);
            document.documentElement.style.setProperty('--border-color', `rgb(${br}, ${bg}, ${bb})`);
            document.querySelectorAll('#panelBgGrid .msg-color-option').forEach(opt => opt.classList.remove('selected'));
            var panelBgEl = document.querySelector('#panelBgGrid .msg-color-option[onclick*="\'' + color + '\'"]');
            if (panelBgEl) panelBgEl.classList.add('selected');
        };

        window.saveThemeSettings = function() {
            secureStorageSet('sloppygram_theme', themeSettings);
            localStorage.setItem('sloppygram_msg_opacity', document.getElementById('msgOpacitySlider').value);
            closeSettingsModal();
        };

        window.resetTheme = function() {
            if (!confirm('Reset all theme settings to default?')) return;
            themeSettings = {
                msgColor: '10, 10, 15',
                msgOwnColor: '90, 112, 96',
                accentColor: '#7c9885',
                highlightColor: '#c9a87c',
                panelBg: '#12121a'
            };
            document.documentElement.style.setProperty('--msg-color', themeSettings.msgColor);
            document.documentElement.style.setProperty('--msg-own-color', themeSettings.msgOwnColor);
            document.documentElement.style.setProperty('--accent', themeSettings.accentColor);
            document.documentElement.style.setProperty('--accent-light', '#a8c4b0');
            document.documentElement.style.setProperty('--accent-dim', '#5a7060');
            document.documentElement.style.setProperty('--highlight', themeSettings.highlightColor);
            document.documentElement.style.setProperty('--panel-bg', themeSettings.panelBg);
            document.documentElement.style.setProperty('--dark-bg', '#0a0a0f');
            document.documentElement.style.setProperty('--border-color', '#2a2a35');
            localStorage.removeItem('sloppygram_theme');
            updateThemeUI();
        };

        function loadThemeSettings() {
            const saved = secureStorageGet('sloppygram_theme');
            if (saved) {
                themeSettings = saved;
                document.documentElement.style.setProperty('--msg-color', themeSettings.msgColor);
                document.documentElement.style.setProperty('--msg-own-color', themeSettings.msgOwnColor);
                if (themeSettings.accentColor) {
                    selectAccentColor(themeSettings.accentColor);
                }
                if (themeSettings.highlightColor) {
                    document.documentElement.style.setProperty('--highlight', themeSettings.highlightColor);
                }
                if (themeSettings.panelBg) {
                    // Use selectPanelBg to properly update all related variables
                    selectPanelBg(themeSettings.panelBg);
                }
            }
        }

        // Initialize local theme mode UI state
        function initLocalThemeMode() {
            const toggle = document.getElementById('localThemeToggle');
            const label = document.getElementById('themeModeLabel');

            if (toggle) {
                toggle.checked = isLocalThemeMode;
            }
            if (label) {
                label.textContent = isLocalThemeMode ? 'ðŸ”’ Local' : 'ðŸŒ Global';
                label.style.color = isLocalThemeMode ? '#7c9885' : '#888';
            }

            // Apply local background if in local mode
            if (isLocalThemeMode && localBackground) {
                applyLocalBackgroundOverride();
            }
        }

        function updateThemeUI() {
            // Update color selection UI using robust background matching
            document.querySelectorAll('#msgColorGrid .msg-color-option').forEach(opt => opt.classList.remove('selected'));
            var msgColorOpt = findColorOption('msgColorGrid', themeSettings.msgColor);
            if (msgColorOpt) msgColorOpt.classList.add('selected');

            document.querySelectorAll('#msgOwnColorGrid .msg-color-option').forEach(opt => opt.classList.remove('selected'));
            var ownColorOpt = findColorOption('msgOwnColorGrid', themeSettings.msgOwnColor);
            if (ownColorOpt) ownColorOpt.classList.add('selected');

            document.querySelectorAll('#accentColorGrid .msg-color-option').forEach(opt => opt.classList.remove('selected'));
            var accentOpt = findColorOption('accentColorGrid', themeSettings.accentColor);
            if (accentOpt) accentOpt.classList.add('selected');

            document.querySelectorAll('#highlightColorGrid .msg-color-option').forEach(opt => opt.classList.remove('selected'));
            var highlightOpt = findColorOption('highlightColorGrid', themeSettings.highlightColor);
            if (highlightOpt) highlightOpt.classList.add('selected');

            document.querySelectorAll('#panelBgGrid .msg-color-option').forEach(opt => opt.classList.remove('selected'));
            var panelOpt = findColorOption('panelBgGrid', themeSettings.panelBg);
            if (panelOpt) panelOpt.classList.add('selected');
        }

        window.saveProfile = function() {
            // Only handle background - profile data managed by SloppyID (sovereign owner)
            profile.bgUrl = pendingBgData || '';
            secureStorageSet('sloppygram_profile', profile);
            applyCustomBackground();

            // Broadcast background globally if set
            if (profile.bgUrl) {
                broadcastGlobalSetting('background', profile.bgUrl);
            }

            closeSettingsModal();
        };

        window.resetProfile = function() {
            if (!confirm('Reset background? Profile data is managed in SloppyID.')) return;
            profile.bgUrl = '';
            pendingBgData = null;
            secureStorageSet('sloppygram_profile', profile);
            const msgContainer = getCachedElement('messagesContainer');
            if (msgContainer) msgContainer.style.backgroundImage = '';
            closeSettingsModal();
        };

        function applyCustomBackground() {
            const msgContainer = getCachedElement('messagesContainer');
            if (!msgContainer) return;

            if (profile.bgUrl) {
                msgContainer.style.backgroundImage = `url(${profile.bgUrl})`;
                msgContainer.style.backgroundSize = 'cover';
                msgContainer.style.backgroundPosition = 'center';
                msgContainer.style.backgroundAttachment = 'fixed';
                msgContainer.style.backgroundRepeat = 'no-repeat';
            } else {
                msgContainer.style.backgroundImage = '';
            }
        }

        // Drawing modal
        window.openDrawingModal = function() {
            clearCanvas();
            document.getElementById('drawingModal').classList.add('active');

            // Add keyboard shortcuts for undo/redo when modal is open
            document.addEventListener('keydown', handleDrawingKeyboard);
        };

        window.closeDrawingModal = function() {
            document.getElementById('drawingModal').classList.remove('active');
            document.removeEventListener('keydown', handleDrawingKeyboard);
        };

        function handleDrawingKeyboard(e) {
            // Only handle if drawing modal is open
            if (!document.getElementById('drawingModal').classList.contains('active')) return;

            if (e.ctrlKey || e.metaKey) {
                if (e.key === 'z' && !e.shiftKey) {
                    e.preventDefault();
                    undoCanvas();
                } else if (e.key === 'y' || (e.key === 'z' && e.shiftKey)) {
                    e.preventDefault();
                    redoCanvas();
                }
            }
        }

        // === GIF SEARCH (GIPHY) ===
        var GIPHY_API_KEY = 'dc6zaTOxFJmzC'; // Public beta key for development

        window.openGifModal = function() {
            document.getElementById('gifModal').classList.add('active');
            document.getElementById('gifSearchInput').value = '';
            document.getElementById('gifTrendingLabel').style.display = 'block';
            loadTrendingGifs();
        };

        window.closeGifModal = function() {
            document.getElementById('gifModal').classList.remove('active');
        };

        async function loadTrendingGifs() {
            var container = document.getElementById('gifResults');
            container.innerHTML = '<div class="gif-loading">Loading trending GIFs...</div>';

            try {
                var response = await fetch('https://api.giphy.com/v1/gifs/trending?api_key=' + GIPHY_API_KEY + '&limit=24&rating=pg-13');
                var data = await response.json();

                if (data.data && data.data.length > 0) {
                    renderGifResults(data.data);
                } else {
                    container.innerHTML = '<div class="gif-empty">No trending GIFs found</div>';
                }
            } catch (err) {
                console.error('Giphy error:', err);
                container.innerHTML = '<div class="gif-error">Failed to load GIFs. Try again later.</div>';
            }
        }

        window.searchGifs = async function() {
            var query = document.getElementById('gifSearchInput').value.trim();
            if (!query) {
                loadTrendingGifs();
                document.getElementById('gifTrendingLabel').style.display = 'block';
                return;
            }

            document.getElementById('gifTrendingLabel').style.display = 'none';
            var container = document.getElementById('gifResults');
            container.innerHTML = '<div class="gif-loading">Searching...</div>';

            try {
                var response = await fetch('https://api.giphy.com/v1/gifs/search?api_key=' + GIPHY_API_KEY + '&q=' + encodeURIComponent(query) + '&limit=24&rating=pg-13');
                var data = await response.json();

                if (data.data && data.data.length > 0) {
                    renderGifResults(data.data);
                } else {
                    container.innerHTML = '<div class="gif-empty">No GIFs found for "' + escapeHtml(query) + '"</div>';
                }
            } catch (err) {
                console.error('Giphy search error:', err);
                container.innerHTML = '<div class="gif-error">Search failed. Try again.</div>';
            }
        };

        function renderGifResults(gifs) {
            var container = document.getElementById('gifResults');
            var html = '';

            gifs.forEach(function(gif) {
                // Use fixed_height_small for preview, fixed_height for sending
                var previewUrl = gif.images.fixed_height_small && gif.images.fixed_height_small.url
                    ? gif.images.fixed_height_small.url
                    : gif.images.fixed_height.url;
                var fullUrl = gif.images.fixed_height.url;

                html += '<img src="' + previewUrl + '" alt="' + escapeHtml(gif.title || 'GIF') + '" onclick="sendGif(\'' + fullUrl + '\')" loading="lazy" width="100" height="100" style="object-fit:cover;">';
            });

            container.innerHTML = html;
        }

        window.sendGif = async function(gifUrl) {
            if (!currentUser) {
                showToast('Please sign in to send GIFs', 'warning');
                return;
            }

            // Rate limiting check
            var rateCheck = checkRateLimit('message');
            if (!rateCheck.allowed) {
                showToast(rateCheck.message, 'warning');
                return;
            }
            recordAction('message');

            closeGifModal();

            // Create temp message for optimistic UI
            var tempId = 'temp_' + Date.now();
            var tempMessage = {
                id: tempId,
                username: profile.username,
                avatar: profile.avatar,
                avatar_url: profile.avatarUrl,
                content: null,
                image_data: gifUrl,
                message_type: 'gif',
                created_at: new Date().toISOString(),
                user_id: currentUser.id
            };

            addMessageToUI(tempMessage);
            playNotificationSound();

            // Insert into database
            var result = await supabase
                .from('sloppygram_messages')
                .insert({
                    username: profile.username,
                    avatar: profile.avatar,
                    avatar_url: profile.avatarUrl,
                    content: null,
                    image_data: gifUrl,
                    message_type: 'gif',
                    user_id: currentUser.id
                });

            if (result.error) {
                console.error('Failed to send GIF:', result.error);
                showToast('Failed to send GIF', 'error');
            }
        };

        // === POSTS FUNCTIONALITY ===

        window.switchView = function(view) {
            currentView = view;
            document.querySelectorAll('.view-tab').forEach(tab => {
                tab.classList.toggle('active', tab.dataset.view === view);
            });
            getCachedElement('messagesContainer').classList.toggle('hidden', view !== 'chat');
            getCachedElement('postsContainer').classList.toggle('active', view === 'posts');
            document.getElementById('doodlesContainer').classList.toggle('active', view === 'doodles');
            document.getElementById('manifestoContainer').classList.toggle('active', view === 'manifesto');
            document.getElementById('collabContainer').classList.toggle('active', view === 'collab');
            document.getElementById('feedbackContainer').classList.toggle('active', view === 'feedback');
            document.getElementById('karmaContainer').classList.toggle('active', view === 'karma');
            document.getElementById('factionsContainer').classList.toggle('active', view === 'factions');
            document.getElementById('dmContainer').classList.toggle('active', view === 'dm');
            document.getElementById('graphContainer').classList.toggle('active', view === 'graph');
            if (view === 'karma') loadKarmaLeaderboard();
            if (view === 'factions') initFactionsView();
            if (view === 'dm') loadDMConversations();
            if (view === 'graph') initSocialGraph();
            safeSetDisplay('chatInputArea', view === 'chat' ? 'block' : 'none');
            document.getElementById('createPostBtn').classList.toggle('visible', view === 'posts');

            if (view === 'posts') {
                loadPosts();
            }
            if (view === 'doodles') {
                loadDoodleLeaderboard();
            }
            if (view === 'manifesto') {
                loadManifestos();
            }
            if (view === 'collab') {
                initCollabCanvas();
            }
            if (view === 'feedback') {
                loadFeedback();
            }
        };

        async function loadPosts() {
            // Reset pagination state for fresh load
            postsPage = 0;
            postsHasMore = true;
            postsLoading = false;
            markDataLoading('posts');

            const { data, error } = await supabase
                .from('sloppygram_posts')
                .select('id, username, avatar, avatar_url, caption, image_url, image_data, likes_count, created_at')
                .order('created_at', { ascending: false })
                .range(0, PAGE_SIZE - 1);

            if (error) {
                console.error('Error loading posts:', error);
                return;
            }

            posts = data || [];
            window.cachedPosts = posts; // Expose to global for Tag Explorer
            const postIds = posts.map(p => p.id);

            // Batch all related queries in parallel to solve N+1 problem
            const [votesResult, commentsResult, reactionsResult, tagsResult, threadsResult] = await Promise.all([
                supabase.from('sloppygram_post_likes').select('post_id, username, vote_type'),
                postIds.length > 0
                    ? supabase.from('sloppygram_post_comments').select('id, post_id, username, avatar, content, created_at').in('post_id', postIds).order('created_at', { ascending: true })
                    : { data: [] },
                postIds.length > 0
                    ? supabase.from('sloppygram_post_reactions').select('id, post_id, emoji, username').in('post_id', postIds)
                    : { data: [] },
                postIds.length > 0
                    ? supabase.from('sloppygram_post_tags').select('id, post_id, tag, parent_tag').in('post_id', postIds)
                    : { data: [] },
                postIds.length > 0
                    ? supabase.from('sloppygram_comment_threads').select('comment_id, parent_comment_id, comment_type, post_id').eq('comment_type', 'post').in('post_id', postIds)
                    : { data: [] }
            ]);

            // Process votes
            postVotes = {};
            myPostVotes = {};
            (votesResult.data || []).forEach(vote => {
                postVotes[vote.post_id] = (postVotes[vote.post_id] || 0) + (vote.vote_type || 1);
                if (vote.username === profile.username) {
                    myPostVotes[vote.post_id] = vote.vote_type || 1;
                }
            });

            // Update post.likes_count with net vote scores
            posts.forEach(p => {
                p.likes_count = postVotes[p.id] || 0;
            });

            // Process comments
            postComments = {};
            (commentsResult.data || []).forEach(comment => {
                if (!postComments[comment.post_id]) postComments[comment.post_id] = [];
                postComments[comment.post_id].push(comment);
            });

            // Process reactions
            postReactions = {};
            myReactions = {};
            (reactionsResult.data || []).forEach(r => {
                if (!postReactions[r.post_id]) postReactions[r.post_id] = {};
                postReactions[r.post_id][r.emoji] = (postReactions[r.post_id][r.emoji] || 0) + 1;
                if (r.username === profile.username) {
                    if (!myReactions[r.post_id]) myReactions[r.post_id] = new Set();
                    myReactions[r.post_id].add(r.emoji);
                }
            });

            // Process tags
            postTags = {};
            (tagsResult.data || []).forEach(t => {
                if (!postTags[t.post_id]) postTags[t.post_id] = [];
                postTags[t.post_id].push({ tag: t.tag, parent_tag: t.parent_tag });
            });

            // Process comment threads
            (threadsResult.data || []).forEach(t => {
                commentThreads[t.comment_id] = t.parent_comment_id;
            });

            // Update pagination state
            postsHasMore = posts.length === PAGE_SIZE;
            postsPage = 1;

            markDataLoaded('posts');
            renderPosts();
        }

        function renderPosts() {
            const container = getCachedElement('postsContainer');
            const emptyState = document.getElementById('postsEmptyState');

            if (posts.length === 0) {
                if (emptyState) emptyState.style.display = 'block';
                if (container) container.innerHTML = '';
                if (container && emptyState) container.appendChild(emptyState);
                return;
            }

            if (emptyState) emptyState.style.display = 'none';
            container.innerHTML = posts.map(post => renderPostCard(post)).join('');

            // Trigger lazy loading for new images
            lazyLoadNewImages();
        }

        // Render threaded comments with replies
        function renderThreadedComments(comments, postId, type = 'post') {
            // Build a map of comment threads
            const threads = {}; // parentId -> [children]
            const rootComments = [];

            comments.forEach(c => {
                const parentId = commentThreads[c.id];
                if (parentId) {
                    if (!threads[parentId]) threads[parentId] = [];
                    threads[parentId].push(c);
                } else {
                    rootComments.push(c);
                }
            });

            function renderComment(c, depth = 0) {
                const time = c.created_at ? new Date(c.created_at).toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'}) : '';
                const replies = threads[c.id] || [];
                const isNested = depth > 0;
                const isOwnComment = c.username === profile.username;
                const myVote = myCommentVotes[c.id] || 0;
                const voteScore = commentVotes[c.id] || 0;
                const scoreClass = voteScore > 0 ? 'positive' : voteScore < 0 ? 'negative' : '';

                const safeUsername = escapeAttr(c.username || 'Anonymous');
                const safeCommentId = escapeAttr(String(c.id));
                return `
                    <div class="comment ${isNested ? 'comment-thread' : ''}" data-comment-id="${safeCommentId}" data-depth="${depth}">
                        <span class="comment-avatar">${c.avatar || 'ðŸ‘¤'}</span>
                        <div class="comment-content">
                            <span class="comment-username username-clickable" onclick="showProfileCard('${safeUsername}', event)">${escapeHtml(c.username)}</span>
                            <span class="comment-time">${time}</span>
                            <div class="comment-text">${escapeHtml(c.content)}</div>
                            <div class="comment-actions">
                                <button class="comment-reply-btn" onclick="startReply(${postId}, ${c.id}, '${safeUsername}', '${escapeAttr(type)}')">â†© reply</button>
                                <span class="comment-vote-controls" data-comment-id="${safeCommentId}">
                                    <button class="comment-vote-btn upvote ${myVote === 1 ? 'active' : ''} ${isOwnComment ? 'disabled' : ''}"
                                        onclick="${isOwnComment ? '' : `voteComment('${safeCommentId}', 1, '${safeUsername}')`}"
                                        title="${isOwnComment ? 'Cannot vote on own comment' : 'Upvote'}">â–²</button>
                                    <span class="comment-vote-score ${scoreClass}">${voteScore}</span>
                                    <button class="comment-vote-btn downvote ${myVote === -1 ? 'active' : ''} ${isOwnComment ? 'disabled' : ''}"
                                        onclick="${isOwnComment ? '' : `voteComment('${safeCommentId}', -1, '${safeUsername}')`}"
                                        title="${isOwnComment ? 'Cannot vote on own comment' : 'Downvote'}">â–¼</button>
                                </span>
                            </div>
                        </div>
                        ${replies.length > 0 ? `<div class="comment-replies">${replies.map(r => renderComment(r, depth + 1)).join('')}</div>` : ''}
                    </div>
                `;
            }

            return rootComments.map(c => renderComment(c, 0)).join('');
        }

        function renderPostCard(post) {
            const time = new Date(post.created_at).toLocaleString();
            const myVote = myPostVotes[post.id] || 0;
            const comments = postComments[post.id] || [];
            const voteScore = postVotes[post.id] || 0;
            const reactions = postReactions[post.id] || {};
            const myPostReactions = myReactions[post.id] || new Set();
            var currentUserId = (currentUser && currentUser.id) ? currentUser.id : null;
            const isOwnPost = post.user_id === currentUserId || post.username === profile.username;
            const scoreClass = voteScore > 0 ? 'positive' : voteScore < 0 ? 'negative' : 'neutral';

            const safeAvatarUrl = sanitizeUrl(post.avatar_url);
            const avatarContent = safeAvatarUrl
                ? `<img src="${safeAvatarUrl}" style="width:100%;height:100%;object-fit:cover;border-radius:50%;">`
                : (post.avatar || 'ðŸ‘¤');

            const safeImageUrl = sanitizeUrl(post.image_url);
            const safeImageData = sanitizeUrl(post.image_data);
            const imageHtml = safeImageUrl
                ? `<img class="post-image lazy-image" loading="lazy" data-src="${safeImageUrl}" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.style.display='none'" style="aspect-ratio:4/3;min-height:200px;">`
                : (safeImageData ? `<img class="post-image" loading="lazy" src="${safeImageData}" style="aspect-ratio:4/3;min-height:200px;">` : '');

            const commentsHtml = renderThreadedComments(comments, post.id, 'post');

            // Reply indicator if replying to a comment on this post
            const replyIndicatorHtml = (replyingTo && replyingTo.postId === post.id && replyingTo.type === 'post')
                ? `<div class="reply-indicator">
                    <span>â†© Replying to <strong>${escapeHtml(replyingTo.username)}</strong></span>
                    <button class="cancel-reply" onclick="cancelReply()">âœ•</button>
                </div>`
                : '';

            // Build reactions HTML
            const reactionsHtml = Object.entries(reactions)
                .sort((a, b) => b[1] - a[1])
                .map(([emoji, count]) => {
                    const isActive = myPostReactions.has(emoji);
                    return `<button class="reaction-btn ${isActive ? 'active' : ''}" onclick="toggleReaction(${post.id}, '${emoji}')">
                        ${emoji} <span class="reaction-count">${count}</span>
                    </button>`;
                }).join('');

            const reactionPickerHtml = REACTION_EMOJIS.map(emoji =>
                `<button onclick="toggleReaction(${post.id}, '${emoji}')">${emoji}</button>`
            ).join('');

            // Build tags HTML
            const tags = postTags[post.id] || [];
            const tagsHtml = tags.length > 0 ? `
                <div class="post-tags">
                    ${tags.map(t => {
                        const isNested = t.parent_tag != null;
                        const displayTag = isNested ? `${t.parent_tag}/${t.tag}` : t.tag;
                        return `<span class="tag ${isNested ? 'nested' : ''}" onclick="filterByTag('${escapeAttr(displayTag)}')">#${escapeHtml(displayTag)}</span>`;
                    }).join('')}
                </div>
            ` : '';

            const safePostUsername = escapeAttr(post.username || 'Anonymous');

            // Generate DNA badge for post
            let postDnaBadge = '';
            if (typeof generateContentDNA === 'function') {
                const pDna = generateContentDNA(post, 'post');
                const coloredPSeq = pDna.sequence.split('').map(c => {
                    if (c === '-') return '<span style="opacity:0.3">Â·</span>';
                    return '<span class="nucleotide-' + c + '">' + c + '</span>';
                }).join('');
                postDnaBadge = '<span class="msg-dna-badge" title="' + pDna.full + '">' + pDna.code + '::' + coloredPSeq + '</span>';
            }

            return `
                <div class="post-card" data-post-id="${post.id}">
                    <div class="post-header">
                        <div class="post-avatar">${avatarContent}</div>
                        <span class="post-username username-clickable" onclick="showProfileCard('${safePostUsername}', event)">${escapeHtml(post.username || 'Anonymous')}</span>
                        <span class="post-time">${time}</span>
                        ${isOwnPost ? `<button class="post-delete-btn" onclick="deletePost(${post.id})" title="Delete post">delete</button>` : ''}
                    </div>
                    ${imageHtml}
                    ${post.caption ? `<div class="post-caption">${escapeHtml(post.caption)}</div>` : ''}
                    <div class="post-actions">
                        <div class="vote-controls" data-post-id="${post.id}">
                            <button class="vote-btn upvote ${myVote === 1 ? 'active' : ''} ${isOwnPost ? 'disabled' : ''}"
                                onclick="${isOwnPost ? '' : `votePost(${post.id}, 1)`}"
                                title="${isOwnPost ? 'Cannot vote on own post' : 'Upvote'}">â–²</button>
                            <span class="vote-score ${scoreClass}" id="post-score-${post.id}">${voteScore}</span>
                            <button class="vote-btn downvote ${myVote === -1 ? 'active' : ''} ${isOwnPost ? 'disabled' : ''}"
                                onclick="${isOwnPost ? '' : `votePost(${post.id}, -1)`}"
                                title="${isOwnPost ? 'Cannot vote on own post' : 'Downvote'}">â–¼</button>
                        </div>
                        <button class="post-action-btn" onclick="focusComment(${post.id})">
                            ðŸ’¬ ${comments.length}
                        </button>
                        ${post.caption ? `<button class="post-action-btn tts-btn" id="tts-btn-${post.id}" onclick="speakPost(${post.id})" title="Read aloud">ðŸ”Š</button>` : ''}
                        ${post.caption ? `<button class="msg-fork-btn" onclick="forkPost(${post.id})" title="Fork this post">ðŸ”€</button>` : ''}
                        ${postDnaBadge}
                    </div>
                    <div class="post-reactions" id="reactions-${post.id}">
                        ${reactionsHtml}
                        <div style="position:relative;display:inline-block;">
                            <button class="add-reaction-btn" onclick="toggleReactionPicker(${post.id})">+ ðŸ˜€</button>
                            <div class="reaction-picker" id="picker-${post.id}">
                                ${reactionPickerHtml}
                            </div>
                        </div>
                    </div>
                    ${tagsHtml}
                    <div class="post-comments" id="comments-${post.id}">
                        ${commentsHtml}
                    </div>
                    ${replyIndicatorHtml}
                    <div class="comment-input-row">
                        <input class="comment-input" id="comment-input-${post.id}" placeholder="${replyingTo && replyingTo.postId === post.id ? 'Write a reply...' : 'Add a comment...'}" onkeydown="if(event.key==='Enter')addComment(${post.id})">
                        <button class="comment-send" onclick="addComment(${post.id})">POST</button>
                    </div>
                </div>
            `;
        }

        window.deletePost = async function(postId) {
            if (!currentUser) return;
            if (!confirm('Delete this post? This cannot be undone.')) return;

            const { error } = await supabase
                .from('sloppygram_posts')
                .delete()
                .eq('id', postId)
                .eq('user_id', currentUser.id);

            if (error) {
                console.error('Error deleting post:', error);
                alert('Could not delete post');
                return;
            }

            // Remove from local state
            posts = posts.filter(p => p.id !== postId);
            delete postComments[postId];
            delete postReactions[postId];
            delete postLikes[postId];
            delete postTags[postId];
            renderPosts();
        };

        // Text-to-speech for posts
        var currentSpeech = null;
        var currentSpeakingPostId = null;

        window.speakPost = function(postId) {
            var post = posts.find(function(p) { return p.id === postId; });
            if (!post || !post.caption) return;

            // If already speaking this post, stop it
            if (currentSpeakingPostId === postId && window.speechSynthesis.speaking) {
                window.speechSynthesis.cancel();
                var btn = document.getElementById('tts-btn-' + postId);
                if (btn) btn.classList.remove('speaking');
                currentSpeakingPostId = null;
                return;
            }

            // Stop any current speech
            if (window.speechSynthesis.speaking) {
                window.speechSynthesis.cancel();
                if (currentSpeakingPostId) {
                    var oldBtn = document.getElementById('tts-btn-' + currentSpeakingPostId);
                    if (oldBtn) oldBtn.classList.remove('speaking');
                }
            }

            // Create and speak the utterance
            var utterance = new SpeechSynthesisUtterance(post.caption);
            utterance.rate = 1.0;
            utterance.pitch = 1.0;

            // Update button state
            var btn = document.getElementById('tts-btn-' + postId);
            if (btn) btn.classList.add('speaking');
            currentSpeakingPostId = postId;

            utterance.onend = function() {
                if (btn) btn.classList.remove('speaking');
                currentSpeakingPostId = null;
            };

            utterance.onerror = function() {
                if (btn) btn.classList.remove('speaking');
                currentSpeakingPostId = null;
            };

            window.speechSynthesis.speak(utterance);
        };

        // Text-to-speech for chat messages
        var currentSpeakingMsgId = null;

        window.speakMessage = function(msgId) {
            var allMessages = window.cachedMessages || [];
            var msg = allMessages.find(function(m) { return String(m.id) === String(msgId); });
            if (!msg || !msg.content) return;

            // Strip hacker markup tags for clean speech
            var cleanText = msg.content
                .replace(/\[shake\]|\[\/shake\]/gi, '')
                .replace(/\[rainbow\]|\[\/rainbow\]/gi, '')
                .replace(/\[matrix\]|\[\/matrix\]/gi, '')
                .replace(/\[glitch\]|\[\/glitch\]/gi, '')
                .replace(/\[pulse\]|\[\/pulse\]/gi, '')
                .replace(/\[wave\]|\[\/wave\]/gi, '')
                .replace(/\[spoiler\]|\[\/spoiler\]/gi, '');

            // If already speaking this message, stop it
            if (currentSpeakingMsgId === msgId && window.speechSynthesis.speaking) {
                window.speechSynthesis.cancel();
                var btn = document.getElementById('msg-tts-' + msgId);
                if (btn) btn.classList.remove('speaking');
                currentSpeakingMsgId = null;
                return;
            }

            // Stop any current speech (posts or messages)
            if (window.speechSynthesis.speaking) {
                window.speechSynthesis.cancel();
                if (currentSpeakingMsgId) {
                    var oldMsgBtn = document.getElementById('msg-tts-' + currentSpeakingMsgId);
                    if (oldMsgBtn) oldMsgBtn.classList.remove('speaking');
                }
                if (currentSpeakingPostId) {
                    var oldPostBtn = document.getElementById('tts-btn-' + currentSpeakingPostId);
                    if (oldPostBtn) oldPostBtn.classList.remove('speaking');
                    currentSpeakingPostId = null;
                }
            }

            // Create and speak the utterance
            var utterance = new SpeechSynthesisUtterance(cleanText);
            utterance.rate = 1.0;
            utterance.pitch = 1.0;

            // Update button state
            var btn = document.getElementById('msg-tts-' + msgId);
            if (btn) btn.classList.add('speaking');
            currentSpeakingMsgId = msgId;

            utterance.onend = function() {
                if (btn) btn.classList.remove('speaking');
                currentSpeakingMsgId = null;
            };

            utterance.onerror = function() {
                if (btn) btn.classList.remove('speaking');
                currentSpeakingMsgId = null;
            };

            window.speechSynthesis.speak(utterance);
        };

        // TTS for Manifestos
        var currentSpeakingManifestoId = null;
        window.speakManifesto = function(manifestoId) {
            const manifesto = manifestos.find(m => m.id === manifestoId);
            if (!manifesto) return;

            // Build text: title + content (strip HTML if any)
            let text = (manifesto.title || '') + '. ' + (manifesto.content || '');
            text = text.replace(/<[^>]*>/g, '').replace(/\s+/g, ' ').trim();
            if (!text) return;

            const btn = document.getElementById('manifesto-tts-' + manifestoId);

            // If already speaking this manifesto, stop it
            if (currentSpeakingManifestoId === manifestoId && window.speechSynthesis.speaking) {
                window.speechSynthesis.cancel();
                if (btn) btn.classList.remove('speaking');
                currentSpeakingManifestoId = null;
                return;
            }

            // Cancel any ongoing speech
            if (window.speechSynthesis.speaking) {
                window.speechSynthesis.cancel();
                if (currentSpeakingManifestoId) {
                    const oldBtn = document.getElementById('manifesto-tts-' + currentSpeakingManifestoId);
                    if (oldBtn) oldBtn.classList.remove('speaking');
                }
                if (currentSpeakingMsgId) {
                    const oldMsgBtn = document.getElementById('msg-tts-' + currentSpeakingMsgId);
                    if (oldMsgBtn) oldMsgBtn.classList.remove('speaking');
                    currentSpeakingMsgId = null;
                }
                if (currentSpeakingPostId) {
                    const oldPostBtn = document.getElementById('tts-btn-' + currentSpeakingPostId);
                    if (oldPostBtn) oldPostBtn.classList.remove('speaking');
                    currentSpeakingPostId = null;
                }
            }

            // Create and speak the utterance
            const utterance = new SpeechSynthesisUtterance(text);
            utterance.rate = 0.9; // Slightly slower for manifestos
            utterance.pitch = 1.0;

            if (btn) btn.classList.add('speaking');
            currentSpeakingManifestoId = manifestoId;

            utterance.onend = function() {
                if (btn) btn.classList.remove('speaking');
                currentSpeakingManifestoId = null;
            };

            utterance.onerror = function() {
                if (btn) btn.classList.remove('speaking');
                currentSpeakingManifestoId = null;
            };

            window.speechSynthesis.speak(utterance);
        };

        window.votePost = async function(postId, voteType) {
            if (!currentUser) return;

            // Rate limiting check
            const rateCheck = checkRateLimit('vote');
            if (!rateCheck.allowed) {
                showToast(rateCheck.message, 'warning');
                return;
            }
            recordAction('vote');

            // Check if own post
            const post = posts.find(p => p.id === postId);
            if (post && (post.user_id === currentUser.id || post.username === profile.username)) return;

            const currentVote = myPostVotes[postId] || 0;

            if (currentVote === voteType) {
                // Remove vote if clicking same button
                await supabase
                    .from('sloppygram_post_likes')
                    .delete()
                    .eq('post_id', postId)
                    .eq('user_id', currentUser.id);

                myPostVotes[postId] = 0;
                postVotes[postId] = (postVotes[postId] || 0) - voteType;
            } else {
                // Remove existing vote first
                if (currentVote !== 0) {
                    await supabase
                        .from('sloppygram_post_likes')
                        .delete()
                        .eq('post_id', postId)
                        .eq('user_id', currentUser.id);
                    postVotes[postId] = (postVotes[postId] || 0) - currentVote;
                }

                // Add new vote
                await supabase
                    .from('sloppygram_post_likes')
                    .insert({
                        post_id: postId,
                        username: profile.username,
                        vote_type: voteType,
                        user_id: currentUser.id
                    });

                myPostVotes[postId] = voteType;
                postVotes[postId] = (postVotes[postId] || 0) + voteType;
            }

            // Update post.likes_count
            if (post) post.likes_count = postVotes[postId] || 0;

            // Log AI event for post vote
            logAiEvent('vote_cast', 'post', postId, {
                vote_type: myPostVotes[postId] || 0,
                net_score: postVotes[postId] || 0
            });

            // Update UI
            updatePostVoteUI(postId);
        };

        function updatePostVoteUI(postId) {
            const score = postVotes[postId] || 0;
            const myVote = myPostVotes[postId] || 0;
            const scoreClass = score > 0 ? 'positive' : score < 0 ? 'negative' : 'neutral';

            document.querySelectorAll(`[data-post-id="${postId}"]`).forEach(container => {
                const scoreEl = container.querySelector('.vote-score');
                const upBtn = container.querySelector('.vote-btn.upvote');
                const downBtn = container.querySelector('.vote-btn.downvote');

                if (scoreEl) {
                    scoreEl.textContent = score;
                    scoreEl.className = `vote-score ${scoreClass}`;
                }
                if (upBtn) upBtn.classList.toggle('active', myVote === 1);
                if (downBtn) downBtn.classList.toggle('active', myVote === -1);
            });
        }

        window.focusComment = function(postId) {
            document.getElementById(`comment-input-${postId}`).focus();
        };

        // Start replying to a specific comment
        window.startReply = function(postId, commentId, username, type = 'post') {
            replyingTo = { postId, commentId, username, type };
            if (type === 'post') {
                renderPosts();
                setTimeout(() => {
                    const input = document.getElementById(`comment-input-${postId}`);
                    if (input) input.focus();
                }, 50);
            } else {
                renderManifestos();
                setTimeout(() => {
                    const input = document.getElementById(`manifesto-comment-input-${postId}`);
                    if (input) input.focus();
                }, 50);
            }
        };

        // Cancel replying
        window.cancelReply = function() {
            var wasType = (replyingTo && replyingTo.type) ? replyingTo.type : null;
            replyingTo = null;
            if (wasType === 'post') {
                renderPosts();
            } else if (wasType === 'manifesto') {
                renderManifestos();
            }
        };

        window.addComment = async function(postId) {
            const input = document.getElementById(`comment-input-${postId}`);
            const rawContent = input.value.trim();
            if (!rawContent || !currentUser) return;

            // Rate limiting check
            const rateCheck = checkRateLimit('comment');
            if (!rateCheck.allowed) {
                showToast(rateCheck.message, 'warning');
                return;
            }
            recordAction('comment');

            // Sanitize content before storage (defense-in-depth)
            const content = sanitizeForStorage(rawContent);
            if (!content) return;

            // Rate limiting check
            const rateCheck = checkRateLimit('comment');
            if (!rateCheck.allowed) {
                showToast(rateCheck.message, 'warning');
                return;
            }
            recordAction('comment');

            const comment = {
                post_id: postId,
                username: profile.username,
                avatar: profile.avatar,
                content: content,
                user_id: currentUser.id
            };

            const { data, error } = await supabase
                .from('sloppygram_post_comments')
                .insert(comment)
                .select()
                .single();

            if (error) {
                console.error('Error adding comment:', error);
                return;
            }

            // If this is a reply, save the thread relationship
            if (replyingTo && replyingTo.postId === postId && replyingTo.type === 'post' && data) {
                await supabase
                    .from('sloppygram_comment_threads')
                    .insert({
                        comment_id: data.id,
                        parent_comment_id: replyingTo.commentId,
                        comment_type: 'post',
                        post_id: postId,
                        user_id: currentUser.id
                    });
                commentThreads[data.id] = replyingTo.commentId;
            }

            if (!postComments[postId]) postComments[postId] = [];
            postComments[postId].push({ ...comment, id: (data && data.id) ? data.id : null, created_at: new Date().toISOString() });

            input.value = '';
            replyingTo = null;
            renderPosts();
        };

        // Emoji Reactions
        window.toggleReactionPicker = function(postId) {
            const picker = document.getElementById(`picker-${postId}`);
            // Close all other pickers
            document.querySelectorAll('.reaction-picker.active').forEach(p => {
                if (p.id !== `picker-${postId}`) p.classList.remove('active');
            });
            picker.classList.toggle('active');
        };

        window.toggleReaction = async function(postId, emoji) {
            if (!currentUser) return;

            // Close picker
            const picker = document.getElementById(`picker-${postId}`);
            if (picker) picker.classList.remove('active');

            var hasReaction = (myReactions[postId] && myReactions[postId].has(emoji)) ? true : false;

            if (hasReaction) {
                // Remove reaction
                await supabase
                    .from('sloppygram_post_reactions')
                    .delete()
                    .eq('post_id', postId)
                    .eq('emoji', emoji)
                    .eq('user_id', currentUser.id);

                if (myReactions[postId]) myReactions[postId].delete(emoji);
                if (postReactions[postId] && postReactions[postId][emoji]) {
                    postReactions[postId][emoji]--;
                    if (postReactions[postId][emoji] <= 0) delete postReactions[postId][emoji];
                }
            } else {
                // Add reaction
                await supabase
                    .from('sloppygram_post_reactions')
                    .insert({
                        post_id: postId,
                        emoji: emoji,
                        username: profile.username,
                        user_id: currentUser.id
                    });

                if (!myReactions[postId]) myReactions[postId] = new Set();
                myReactions[postId].add(emoji);
                if (!postReactions[postId]) postReactions[postId] = {};
                postReactions[postId][emoji] = (postReactions[postId][emoji] || 0) + 1;
            }

            renderPosts();
        };

        // Close reaction pickers when clicking outside
        document.addEventListener('click', (e) => {
            if (!e.target.closest('.add-reaction-btn') && !e.target.closest('.reaction-picker')) {
                document.querySelectorAll('.reaction-picker.active').forEach(p => p.classList.remove('active'));
            }
        });

        // Post Modal
        window.openPostModal = function() {
            postImageData = null;
            document.getElementById('postImageUrl').value = '';
            document.getElementById('postCaption').value = '';
            document.getElementById('postFileInput').value = '';
            document.getElementById('postPreview').innerHTML = '<span>No image selected</span>';
            document.getElementById('postPreview').classList.remove('has-image');
            document.getElementById('postModal').classList.add('active');
        };

        window.closePostModal = function() {
            document.getElementById('postModal').classList.remove('active');
        };

        window.previewPostImage = function() {
            const url = document.getElementById('postImageUrl').value.trim();
            const preview = document.getElementById('postPreview');
            const safeUrl = sanitizeUrl(url);

            if (safeUrl) {
                // Use DOM manipulation instead of innerHTML in onerror for XSS safety
                var img = document.createElement('img');
                img.src = safeUrl;
                img.onerror = function() {
                    preview.innerHTML = '<span>Failed to load image</span>';
                    preview.classList.remove('has-image');
                };
                preview.innerHTML = '';
                preview.appendChild(img);
                preview.classList.add('has-image');
                postImageData = null;
            } else if (!postImageData) {
                preview.innerHTML = '<span>No image selected</span>';
                preview.classList.remove('has-image');
            }
        };

        window.handlePostFileSelect = function(event) {
            const file = event.target.files[0];
            if (!file) return;

            if (file.size > 500000) {
                alert('Image too large! Max 500KB');
                event.target.value = '';
                return;
            }

            const reader = new FileReader();
            reader.onload = function(e) {
                postImageData = e.target.result;
                const preview = document.getElementById('postPreview');
                preview.innerHTML = `<img src="${postImageData}">`;
                preview.classList.add('has-image');
                document.getElementById('postImageUrl').value = '';
            };
            reader.readAsDataURL(file);
        };

        window.submitPost = async function() {
            const imageUrl = document.getElementById('postImageUrl').value.trim();
            const rawCaption = document.getElementById('postCaption').value.trim();

            if (!imageUrl && !postImageData && !rawCaption) {
                showToast('Add an image or caption!', 'warning');
                return;
            }

            // Sanitize caption before storage (defense-in-depth)
            const caption = rawCaption ? sanitizeForStorage(rawCaption, 1000) : null;

            // Rate limiting check
            const rateCheck = checkRateLimit('post');
            if (!rateCheck.allowed) {
                showToast(rateCheck.message, 'warning');
                return;
            }
            recordAction('post');

            // Upload local image to storage instead of saving base64
            let finalImageUrl = imageUrl || null;
            let finalImageData = null;

            if (postImageData && !imageUrl) {
                const blob = dataURLtoBlob(postImageData);
                const storageUrl = await uploadToStorage(blob, 'posts');
                if (storageUrl) {
                    finalImageUrl = storageUrl;
                } else {
                    // Fallback to base64 if storage fails
                    finalImageData = postImageData;
                }
            }

            const post = {
                username: profile.username,
                avatar: profile.avatar,
                avatar_url: profile.avatarUrl || null,
                caption: caption,
                image_url: finalImageUrl,
                image_data: finalImageData,
                likes_count: 0,
                user_id: currentUser.id
            };

            const { data: insertedPost, error } = await supabase
                .from('sloppygram_posts')
                .insert(post)
                .select()
                .single();

            if (error) {
                console.error('Error creating post:', error);
                alert('Failed to create post: ' + error.message);
                return;
            }

            if (!insertedPost) {
                console.error('Post insert returned no data');
                alert('Post created but could not retrieve ID for tags');
            }

            // Tags managed by Sloppy Feed (sovereign owner)

            // Log AI event for new post
            if (insertedPost) {
                logAiEvent('post_created', 'post', insertedPost.id, {
                    has_image: !!(finalImageUrl || finalImageData),
                    has_caption: !!caption,
                    tag_count: pendingTags.length
                });
            }

            closePostModal();
            addToFeed(profile.username, 'created a new post');

            // Clear any active tag filter so new post is visible
            activeTagFilter = null;
            getCachedElement('tagFilterBar').classList.remove('active');

            loadPosts();
        };

        // === POST TAG HANDLING FUNCTIONALITY ===

        window.handlePostTagInput = function(event) {
            if (event.key === 'Enter') {
                event.preventDefault();
                const input = document.getElementById('tagInput');
                const value = input.value.trim();
                if (!value) return;

                // Parse nested tag (e.g., "meme/cursed" -> parent_tag: "meme", tag: "cursed")
                let tag, parent_tag = null;
                if (value.includes('/')) {
                    const parts = value.split('/');
                    parent_tag = parts[0].trim();
                    tag = parts.slice(1).join('/').trim();
                } else {
                    tag = value;
                }

                // Don't add duplicates
                const exists = pendingTags.some(t => t.tag === tag && t.parent_tag === parent_tag);
                if (!exists) {
                    pendingTags.push({ tag, parent_tag });
                    renderPendingTags();
                }

                input.value = '';
            }
        };

        function renderPendingTags() {
            const container = document.getElementById('tagInputContainer');
            const input = document.getElementById('tagInput');

            // Remove existing tag chips
            container.querySelectorAll('.tag-chip').forEach(el => el.remove());

            // Add tag chips
            pendingTags.forEach((t, idx) => {
                const displayTag = t.parent_tag ? `${t.parent_tag}/${t.tag}` : t.tag;
                const chip = document.createElement('span');
                chip.className = `tag-chip ${t.parent_tag ? 'nested' : ''}`;
                chip.innerHTML = `#${escapeHtml(displayTag)} <button onclick="removePendingTag(${idx})">Ã—</button>`;
                container.insertBefore(chip, input);
            });
        }

        window.removePendingTag = function(idx) {
            pendingTags.splice(idx, 1);
            renderPendingTags();
        };

        window.filterByTag = function(tagStr) {
            activeTagFilter = tagStr;
            getCachedElement('tagFilterBar').classList.add('active');
            document.getElementById('activeFilterTag').textContent = '#' + tagStr;

            // Also set chat filter
            activeChatFilter = { type: 'tag', value: tagStr };
            getCachedElement('chatFilterBar').classList.add('active');
            var filterValue = document.getElementById('activeChatFilter');
            if (filterValue) filterValue.textContent = '#' + tagStr;

            // Count matches in each source
            var postCount = countPostsWithTag(tagStr);
            var msgCount = countMessagesWithTag(tagStr);
            var manifestoCount = countManifestosWithTag(tagStr);

            // Filter all views
            renderFilteredPosts();
            renderFilteredMessages();
            renderFilteredManifestos();

            // Show toast with result counts
            showToast('Found: ' + postCount + ' posts, ' + msgCount + ' msgs, ' + manifestoCount + ' manifestos with #' + tagStr, 'info');
        };

        function countPostsWithTag(tagStr) {
            return posts.filter(function(post) {
                var tags = postTags[post.id] || [];
                return tags.some(function(t) {
                    var fullTag = t.parent_tag ? t.parent_tag + '/' + t.tag : t.tag;
                    return fullTag.toLowerCase() === tagStr.toLowerCase() ||
                           t.tag.toLowerCase() === tagStr.toLowerCase();
                });
            }).length;
        }

        function countMessagesWithTag(tagStr) {
            var allMessages = window.cachedMessages || [];
            var tagRegex = new RegExp('#' + tagStr + '\\b', 'i');
            return allMessages.filter(function(msg) {
                return tagRegex.test(msg.content || '');
            }).length;
        }

        function countManifestosWithTag(tagStr) {
            return manifestos.filter(function(m) {
                var tags = manifestoTags[m.id] || [];
                return tags.some(function(t) {
                    var fullTag = t.parent_tag ? t.parent_tag + '/' + t.tag : t.tag;
                    return fullTag.toLowerCase() === tagStr.toLowerCase() ||
                           t.tag.toLowerCase() === tagStr.toLowerCase();
                });
            }).length;
        }

        function renderFilteredManifestos() {
            if (!activeTagFilter) {
                renderManifestos();
                return;
            }

            var container = document.getElementById('manifestosContainer');
            if (!container) return;

            var filtered = manifestos.filter(function(m) {
                var tags = manifestoTags[m.id] || [];
                return tags.some(function(t) {
                    var fullTag = t.parent_tag ? t.parent_tag + '/' + t.tag : t.tag;
                    return fullTag.toLowerCase() === activeTagFilter.toLowerCase() ||
                           t.tag.toLowerCase() === activeTagFilter.toLowerCase();
                });
            });

            if (filtered.length === 0) {
                container.innerHTML = '<div class="empty-state"><p>No manifestos with #' + escapeHtml(activeTagFilter) + '</p></div>';
                return;
            }

            container.innerHTML = filtered.map(function(m) { return renderManifestoCard(m); }).join('');
        }

        window.clearTagFilter = function() {
            activeTagFilter = null;
            getCachedElement('tagFilterBar').classList.remove('active');

            // Also clear chat filter
            activeChatFilter = null;
            getCachedElement('chatFilterBar').classList.remove('active');

            // Re-render all views without filter
            renderPosts();
            renderMessages();
            renderManifestos();
        };

        function renderFilteredPosts() {
            if (!activeTagFilter) {
                renderPosts();
                return;
            }

            var container = getCachedElement('postsContainer');
            var emptyState = document.getElementById('postsEmptyState');
            var filterLower = activeTagFilter.toLowerCase();

            // Filter posts that have the matching tag (case-insensitive)
            var filteredPosts = posts.filter(function(post) {
                var tags = postTags[post.id] || [];
                return tags.some(function(t) {
                    var fullTag = t.parent_tag ? t.parent_tag + '/' + t.tag : t.tag;
                    return fullTag.toLowerCase() === filterLower ||
                           t.tag.toLowerCase() === filterLower ||
                           (t.parent_tag && t.parent_tag.toLowerCase() === filterLower);
                });
            });

            if (filteredPosts.length === 0) {
                if (emptyState) {
                    emptyState.style.display = 'block';
                    emptyState.innerHTML = '<p>No posts with tag #' + escapeHtml(activeTagFilter) + '</p>';
                }
                if (container) container.innerHTML = '';
                if (container && emptyState) container.appendChild(emptyState);
                return;
            }

            if (emptyState) emptyState.style.display = 'none';
            if (container) container.innerHTML = filteredPosts.map(post => renderPostCard(post)).join('');
        }

        // Reset pending tags when opening post modal
        const originalOpenPostModal = window.openPostModal;
        window.openPostModal = function() {
            pendingTags = [];
            renderPendingTags();
            if (originalOpenPostModal) originalOpenPostModal();
            else document.getElementById('postModal').classList.add('active');
        };

        // Load and display trending tags
        async function loadTrendingTags() {
            const { data: tagsData } = await supabase
                .from('sloppygram_post_tags')
                .select('tag, parent_tag');

            if (!tagsData || tagsData.length === 0) {
                document.getElementById('trendingTagsList').innerHTML = `
                    <div style="font-size:0.85rem;color:var(--text-dim)">No tags yet</div>
                `;
                return;
            }

            // Count tag occurrences
            const tagCounts = {};
            tagsData.forEach(t => {
                const fullTag = t.parent_tag ? `${t.parent_tag}/${t.tag}` : t.tag;
                tagCounts[fullTag] = (tagCounts[fullTag] || 0) + 1;
            });

            // Sort by count and take top 10
            const topTags = Object.entries(tagCounts)
                .sort((a, b) => b[1] - a[1])
                .slice(0, 10);

            const container = document.getElementById('trendingTagsList');
            container.innerHTML = topTags.map(([tag, count], idx) => {
                const isNested = tag.includes('/');
                const rankClass = idx === 0 ? 'hot' : idx < 3 ? 'warm' : '';
                return `
                    <div class="trending-tag ${rankClass}" onclick="filterByTag('${escapeAttr(tag)}')">
                        <span class="tag ${isNested ? 'nested' : ''}">#${escapeHtml(tag)}</span>
                        <span class="tag-count">${count}</span>
                    </div>
                `;
            }).join('');
        }

        // Call loadTrendingTags when switching to posts view
        const originalSwitchView = switchView;
        switchView = function(view) {
            originalSwitchView(view);
            if (view === 'posts') {
                loadTrendingTags();
            }
        };

        // === CONTENT DNA SYSTEM ===

        // Universal DNA Generator - works for any entity type
        function generateContentDNA(entity, type = 'msg') {
            const nucleotides = ['A', 'T', 'C', 'G'];
            const prefixes = { msg: 'M', doodle: 'D', post: 'P', manifesto: 'X' };

            // Build seed from entity properties
            let seed = (entity.id || 0) * 7919;
            const content = entity.content || entity.caption || entity.title || '';
            seed += content.split('').reduce((a, c) => a + c.charCodeAt(0), 0);
            seed += new Date(entity.created_at || Date.now()).getTime() % 100000;

            const seededRandom = () => {
                seed = (seed * 1103515245 + 12345) & 0x7fffffff;
                return seed / 0x7fffffff;
            };

            // Generate 8-char DNA sequence (2 codons)
            let dna = '';
            for (let i = 0; i < 8; i++) {
                if (i === 4) dna += '-';
                dna += nucleotides[Math.floor(seededRandom() * 4)];
            }

            // Type prefix + ID
            const prefix = prefixes[type] || 'U';
            const idStr = String(entity.id || 0).padStart(4, '0');

            return {
                sequence: dna,
                code: `${prefix}${idStr}`,
                full: `${prefix}${idStr}::${dna}`
            };
        }

        // Fork a message - copies content to input
        window.forkMessage = function(msgId) {
            const msg = messagesArray.find(m => String(m.id) === String(msgId));
            if (!msg || !msg.content) return;

            const input = document.getElementById('message-input');
            if (input) {
                const dna = generateContentDNA(msg, 'msg');
                input.value = `[fork:${dna.code}] ${msg.content}`;
                input.focus();
            }
        };

        // Fork a doodle - currently just shows info (drawing fork would need canvas)
        window.forkDoodle = function(doodleId) {
            const msg = messagesArray.find(m => String(m.id) === String(doodleId) && m.drawing_data);
            if (!msg) return;

            showToast('Doodle DNA copied! Draw your remix.', 'info');
            // Open canvas panel if available
            const canvasPanel = document.getElementById('canvas-panel');
            if (canvasPanel && typeof toggleCanvas === 'function') {
                toggleCanvas();
            }
        };

        // Fork a post - copies caption to new post field
        window.forkPost = function(postId) {
            const post = posts.find(p => p.id === postId);
            if (!post || !post.caption) return;

            const dna = generateContentDNA(post, 'post');
            const captionInput = document.getElementById('new-post-caption');
            if (captionInput) {
                captionInput.value = `[fork:${dna.code}] ${post.caption}`;
                captionInput.focus();
                // Switch to posts view if not already there
                if (typeof switchView === 'function') switchView('posts');
            }
            showToast('Post forked! Add your spin.', 'info');
        };

        // === MANIFESTO FUNCTIONALITY ===

        // DNA Signature Generator - creates unique genetic-style identifiers
        function generateDNASignature(manifesto) {
            const nucleotides = ['A', 'T', 'C', 'G'];
            const markers = ['Î±', 'Î²', 'Î³', 'Î´', 'Îµ', 'Î¶', 'Î·', 'Î¸'];

            // Seed from manifesto properties
            let seed = manifesto.id * 7919; // Prime multiplier
            seed += manifesto.title.split('').reduce((a, c) => a + c.charCodeAt(0), 0);
            seed += new Date(manifesto.created_at).getTime() % 100000;

            // Simple seeded random
            const seededRandom = () => {
                seed = (seed * 1103515245 + 12345) & 0x7fffffff;
                return seed / 0x7fffffff;
            };

            // Generate DNA sequence (12 nucleotides in 3 codons)
            let dna = '';
            for (let i = 0; i < 12; i++) {
                if (i > 0 && i % 4 === 0) dna += '-';
                dna += nucleotides[Math.floor(seededRandom() * 4)];
            }

            // Structural marker based on content length
            const contentLen = (manifesto.content || '').length;
            const markerIdx = Math.floor((contentLen / 50) % markers.length);
            const structuralMarker = markers[markerIdx];

            // Lineage prefix based on author hash
            const authorHash = (manifesto.username || 'anon').split('').reduce((a, c) => a + c.charCodeAt(0), 0);
            const lineageCode = String.fromCharCode(65 + (authorHash % 26)) + String.fromCharCode(65 + ((authorHash * 7) % 26));

            // Generation number (based on ID)
            const generation = 'G' + String(manifesto.id).padStart(3, '0');

            return {
                sequence: dna,
                marker: structuralMarker,
                lineage: lineageCode,
                generation: generation,
                full: `${lineageCode}::${generation}::${structuralMarker}::${dna}`
            };
        }

        // Static manifestos that persist in the codebase (canonical declarations)
        // Note: The Constellation Synthesis manifesto lives in /sloppys-manifesto
        const STATIC_MANIFESTOS = [];

        let manifestos = [];
        let manifestoVotes = {}; // { manifestoId: netScore }
        let myManifestoVotes = {}; // { manifestoId: 1 (up) | -1 (down) | 0 (none) }
        let manifestoReactions = {}; // { manifestoId: { emoji: count } }
        let myManifestoReactions = {}; // { manifestoId: Set of emojis }
        let manifestoComments = {}; // { manifestoId: [comments] }
        let manifestoTags = {}; // { manifestoId: [tags] }
        let manifestoLineage = {}; // { manifestoId: { parentId, forkType } }
        let pendingManifestoTags = []; // tags being added to new manifesto
        let forkingFromId = null; // ID of manifesto being forked

        window.openManifestoModal = function(prefillTitle, prefillContent) {
            document.getElementById('manifestoModal').classList.add('active');
            document.getElementById('manifestoTitle').value = prefillTitle || '';
            document.getElementById('manifestoContent').value = prefillContent || '';
            document.getElementById('manifestoCharCount').textContent = (prefillContent || '').length;
            pendingManifestoTags = [];
            renderPendingManifestoTags();

            // Show fork indicator if forking
            const forkIndicator = document.getElementById('forkIndicator');
            if (forkIndicator) {
                if (forkingFromId) {
                    const parent = manifestos.find(m => m.id === forkingFromId);
                    forkIndicator.innerHTML = `<span style="color:#f80">ðŸ”€ Forking from: "${escapeHtml(parent ? parent.title : 'Unknown')}"</span>`;
                    forkIndicator.style.display = 'block';
                } else {
                    forkIndicator.style.display = 'none';
                }
            }
        };

        window.closeManifestoModal = function() {
            document.getElementById('manifestoModal').classList.remove('active');
            forkingFromId = null; // Clear fork state
        };

        // Fork a manifesto - creates a new one based on parent
        window.forkManifesto = function(manifestoId) {
            const parent = manifestos.find(m => m.id === manifestoId);
            if (!parent) return;

            forkingFromId = manifestoId;
            const forkTitle = `RE: ${parent.title}`;
            const forkContent = `> ${parent.content.split('\n').join('\n> ')}\n\n[Your synthesis here...]`;

            openManifestoModal(forkTitle, forkContent);
        };

        // Character count for manifesto content
        document.addEventListener('DOMContentLoaded', () => {
            const content = document.getElementById('manifestoContent');
            if (content) {
                content.addEventListener('input', () => {
                    document.getElementById('manifestoCharCount').textContent = content.value.length;
                });
            }
        });

        // Manifesto tag input handling
        window.handleManifestoTagInput = function(event) {
            if (event.key === 'Enter') {
                event.preventDefault();
                const input = document.getElementById('manifestoTagInput');
                const value = input.value.trim();
                if (!value) return;

                let tag, parent_tag = null;
                if (value.includes('/')) {
                    const parts = value.split('/');
                    parent_tag = parts[0].trim();
                    tag = parts.slice(1).join('/').trim();
                } else {
                    tag = value;
                }

                const exists = pendingManifestoTags.some(t => t.tag === tag && t.parent_tag === parent_tag);
                if (!exists) {
                    pendingManifestoTags.push({ tag, parent_tag });
                    renderPendingManifestoTags();
                }
                input.value = '';
            }
        };

        function renderPendingManifestoTags() {
            const container = document.getElementById('manifestoTagInputContainer');
            const input = document.getElementById('manifestoTagInput');
            container.querySelectorAll('.tag-chip').forEach(el => el.remove());

            pendingManifestoTags.forEach((t, idx) => {
                const displayTag = t.parent_tag ? `${t.parent_tag}/${t.tag}` : t.tag;
                const chip = document.createElement('span');
                chip.className = `tag-chip ${t.parent_tag ? 'nested' : ''}`;
                chip.innerHTML = `#${escapeHtml(displayTag)} <button onclick="removeManifestoTag(${idx})">Ã—</button>`;
                container.insertBefore(chip, input);
            });
        }

        window.removeManifestoTag = function(idx) {
            pendingManifestoTags.splice(idx, 1);
            renderPendingManifestoTags();
        };

        window.submitManifesto = async function() {
            const rawTitle = document.getElementById('manifestoTitle').value.trim();
            const rawContent = document.getElementById('manifestoContent').value.trim();

            if (!rawTitle || !rawContent) {
                alert('Please fill in both title and content!');
                return;
            }

            // Sanitize before storage (defense-in-depth)
            const title = sanitizeForStorage(rawTitle, 200);
            const content = sanitizeForStorage(rawContent, 5000);

            if (!title || !content) {
                alert('Title or content invalid after sanitization!');
                return;
            }

            const manifesto = {
                title,
                content,
                username: profile.username,
                avatar: profile.avatar,
                upvotes: 0,
                user_id: currentUser.id
            };

            const { data: insertedManifesto, error } = await supabase
                .from('sloppygram_manifestos')
                .insert(manifesto)
                .select()
                .single();

            if (error) {
                console.error('Error creating manifesto:', error);
                alert('Failed to create manifesto: ' + error.message);
                return;
            }

            // Tags and lineage managed by Sloppy Manifestos (sovereign owner)

            addToFeed(profile.username, forkingFromId ? `forked "${insertedManifesto.title}"` : 'declared a new manifesto');

            closeManifestoModal();
            loadManifestos();
        };

        async function loadManifestos() {
            const { data, error } = await supabase
                .from('sloppygram_manifestos')
                .select('id, title, content, username, avatar, upvotes, created_at')
                .order('created_at', { ascending: false })
                .limit(50);

            if (error) {
                console.error('Error loading manifestos:', error);
                return;
            }

            // Merge static manifestos with database manifestos
            const dbManifestos = data || [];
            manifestos = [...STATIC_MANIFESTOS, ...dbManifestos];
            window.cachedManifestos = manifestos; // Expose to global for Tag Explorer
            const manifestoIds = manifestos.map(m => m.id);

            // Batch all related queries in parallel to solve N+1 problem
            const [votesResult, reactionsResult, commentsResult, tagsResult, threadsResult, lineageResult] = await Promise.all([
                manifestoIds.length > 0
                    ? supabase.from('sloppygram_manifesto_votes').select('manifesto_id, username, vote_type, user_id').in('manifesto_id', manifestoIds)
                    : { data: [] },
                manifestoIds.length > 0
                    ? supabase.from('sloppygram_manifesto_reactions').select('id, manifesto_id, emoji, username').in('manifesto_id', manifestoIds)
                    : { data: [] },
                manifestoIds.length > 0
                    ? supabase.from('sloppygram_manifesto_comments').select('id, manifesto_id, username, avatar, content, created_at').in('manifesto_id', manifestoIds).order('created_at', { ascending: true })
                    : { data: [] },
                manifestoIds.length > 0
                    ? supabase.from('sloppygram_manifesto_tags').select('id, manifesto_id, tag, parent_tag').in('manifesto_id', manifestoIds)
                    : { data: [] },
                manifestoIds.length > 0
                    ? supabase.from('sloppygram_comment_threads').select('comment_id, parent_comment_id, comment_type, post_id').eq('comment_type', 'manifesto').in('post_id', manifestoIds)
                    : { data: [] },
                manifestoIds.length > 0
                    ? supabase.from('sloppygram_manifesto_lineage').select('manifesto_id, parent_id, fork_type').in('manifesto_id', manifestoIds)
                    : { data: [] }
            ]);

            // Process votes with direction support (vote_type column: 1=up, -1=down)
            manifestoVotes = {};
            myManifestoVotes = {};
            (votesResult.data || []).forEach(v => {
                // Use vote_type from database (defaults to +1 for legacy upvotes without vote_type)
                const direction = v.vote_type || 1;
                manifestoVotes[v.manifesto_id] = (manifestoVotes[v.manifesto_id] || 0) + direction;
                if (v.user_id === (currentUser && currentUser.id)) {
                    myManifestoVotes[v.manifesto_id] = direction;
                }
            });

            // Process reactions
            manifestoReactions = {};
            myManifestoReactions = {};
            (reactionsResult.data || []).forEach(r => {
                if (!manifestoReactions[r.manifesto_id]) manifestoReactions[r.manifesto_id] = {};
                manifestoReactions[r.manifesto_id][r.emoji] = (manifestoReactions[r.manifesto_id][r.emoji] || 0) + 1;
                if (r.username === profile.username) {
                    if (!myManifestoReactions[r.manifesto_id]) myManifestoReactions[r.manifesto_id] = new Set();
                    myManifestoReactions[r.manifesto_id].add(r.emoji);
                }
            });

            // Process comments
            manifestoComments = {};
            (commentsResult.data || []).forEach(c => {
                if (!manifestoComments[c.manifesto_id]) manifestoComments[c.manifesto_id] = [];
                manifestoComments[c.manifesto_id].push(c);
            });

            // Process tags
            manifestoTags = {};
            (tagsResult.data || []).forEach(t => {
                if (!manifestoTags[t.manifesto_id]) manifestoTags[t.manifesto_id] = [];
                manifestoTags[t.manifesto_id].push({ tag: t.tag, parent_tag: t.parent_tag });
            });

            // Process comment threads
            (threadsResult.data || []).forEach(t => {
                commentThreads[t.comment_id] = t.parent_comment_id;
            });

            // Process lineage
            manifestoLineage = {};
            (lineageResult.data || []).forEach(l => {
                manifestoLineage[l.manifesto_id] = {
                    parentId: l.parent_id,
                    forkType: l.fork_type || 'synthesis'
                };
            });

            renderManifestos();
        }

        function renderManifestos() {
            const container = document.getElementById('manifestoList');
            const emptyState = document.getElementById('manifestoEmptyState');

            if (manifestos.length === 0) {
                if (emptyState) emptyState.style.display = 'block';
                if (container) container.innerHTML = '';
                if (container && emptyState) container.appendChild(emptyState);
                return;
            }

            if (emptyState) emptyState.style.display = 'none';
            if (container) container.innerHTML = manifestos.map(m => renderManifestoCard(m)).join('');
        }

        function renderManifestoCard(m) {
            const time = new Date(m.created_at).toLocaleString();
            const voteCount = manifestoVotes[m.id] || m.upvotes || 0;
            const myVoteDir = myManifestoVotes[m.id] || 0; // 1=up, -1=down, 0=none
            const reactions = manifestoReactions[m.id] || {};
            const myReacts = myManifestoReactions[m.id] || new Set();
            const comments = manifestoComments[m.id] || [];
            const tags = manifestoTags[m.id] || [];
            // Check ownership by user_id first (reliable), fallback to username
            var currentUserId = (currentUser && currentUser.id) ? currentUser.id : null;
            const isOwnManifesto = (currentUserId && m.user_id === currentUserId) || m.username === profile.username;
            const isStatic = m.isStatic || m.id < 0; // Static manifestos can't be modified

            const reactionsHtml = Object.entries(reactions)
                .sort((a, b) => b[1] - a[1])
                .map(([emoji, count]) => {
                    const isActive = myReacts.has(emoji);
                    return `<button class="reaction-btn ${isActive ? 'active' : ''}" onclick="toggleManifestoReaction(${m.id}, '${emoji}')">
                        ${emoji} <span class="reaction-count">${count}</span>
                    </button>`;
                }).join('');

            const reactionPickerHtml = REACTION_EMOJIS.map(emoji =>
                `<button onclick="toggleManifestoReaction(${m.id}, '${emoji}')">${emoji}</button>`
            ).join('');

            const commentsHtml = renderThreadedComments(comments, m.id, 'manifesto');

            // Reply indicator if replying to a comment on this manifesto
            const replyIndicatorHtml = (replyingTo && replyingTo.postId === m.id && replyingTo.type === 'manifesto')
                ? `<div class="reply-indicator">
                    <span>â†© Replying to <strong>${escapeHtml(replyingTo.username)}</strong></span>
                    <button class="cancel-reply" onclick="cancelReply()">âœ•</button>
                </div>`
                : '';

            const tagsHtml = tags.length > 0 ? `
                <div class="post-tags">
                    ${tags.map(t => {
                        const isNested = t.parent_tag != null;
                        const displayTag = isNested ? `${t.parent_tag}/${t.tag}` : t.tag;
                        return `<span class="tag ${isNested ? 'nested' : ''}">#${escapeHtml(displayTag)}</span>`;
                    }).join('')}
                </div>
            ` : '';

            // Generate DNA signature
            const dna = generateDNASignature(m);
            const coloredSequence = dna.sequence.split('').map(char => {
                if (char === '-') return '<span style="opacity:0.3">Â·</span>';
                return `<span class="nucleotide-${char}">${char}</span>`;
            }).join('');

            // Check for lineage
            const lineage = manifestoLineage[m.id];
            const parentManifesto = lineage ? manifestos.find(p => p.id === lineage.parentId) : null;
            const parentHtml = parentManifesto
                ? `<span class="dna-parent" title="Forked from: ${escapeHtml(parentManifesto.title)}">G${String(lineage.parentId).padStart(3, '0')}</span>`
                : '';

            const dnaHtml = `
                <div class="manifesto-dna" title="Structural DNA: ${dna.full}${lineage ? ' | Parent: G' + String(lineage.parentId).padStart(3, '0') : ''}">
                    <span class="dna-helix">ðŸ§¬</span>
                    <span class="dna-label">DNA</span>
                    <span class="dna-lineage">${dna.lineage}</span>
                    <span class="dna-generation">${dna.generation}</span>
                    <span class="dna-marker">${dna.marker}</span>
                    <span class="dna-sequence">${coloredSequence}</span>
                    ${parentHtml}
                </div>
            `;

            const safeManifestoUser = escapeAttr(m.username || 'Anonymous');
            return `
                <div class="manifesto-card" data-manifesto-id="${m.id}">
                    <div class="manifesto-card-header">
                        <div class="manifesto-avatar">${m.avatar || 'ðŸ‘¤'}</div>
                        <span class="manifesto-author username-clickable" onclick="showProfileCard('${safeManifestoUser}', event)">${escapeHtml(m.username || 'Anonymous')}</span>
                        <span class="manifesto-time">${time}</span>
                        ${isStatic ? '<span style="color:#ffd700;font-size:0.7rem;margin-left:8px;" title="Canonical manifesto">ðŸ“Œ PINNED</span>' : ''}
                        ${isOwnManifesto && !isStatic ? `<button class="msg-delete-btn" onclick="deleteManifesto(${m.id})" title="Delete manifesto">delete</button>` : ''}
                    </div>
                    <h3 class="manifesto-title">${escapeHtml(m.title)}</h3>
                    <div class="manifesto-text">${parseManifestoMarkdown(m.content)}</div>
                    ${tagsHtml}
                    ${dnaHtml}
                    <div class="manifesto-actions">
                        <div class="manifesto-vote-controls">
                            ${isStatic ? `
                                <span class="manifesto-vote-score positive" title="Canonical score" style="padding:0 8px;">âœ§ ${voteCount}</span>
                            ` : `
                                <button class="manifesto-upvote ${myVoteDir === 1 ? 'active' : ''}" onclick="voteManifesto(${m.id}, 1)" title="Upvote">â–²</button>
                                <span class="manifesto-vote-score ${voteCount > 0 ? 'positive' : voteCount < 0 ? 'negative' : 'neutral'}">${voteCount}</span>
                                <button class="manifesto-downvote ${myVoteDir === -1 ? 'active' : ''}" onclick="voteManifesto(${m.id}, -1)" title="Downvote">â–¼</button>
                            `}
                        </div>
                        <button class="manifesto-fork-btn" onclick="forkManifesto(${m.id})" title="Fork this manifesto">
                            <span class="fork-icon">ðŸ”€</span> Fork
                        </button>
                        <button class="manifesto-tts-btn" id="manifesto-tts-${m.id}" onclick="speakManifesto(${m.id})" title="Read aloud">
                            ðŸ”Š Listen
                        </button>
                        <button class="post-action-btn" onclick="focusManifestoComment(${m.id})">
                            ðŸ’¬ ${comments.length}
                        </button>
                    </div>
                    <div class="post-reactions" id="manifesto-reactions-${m.id}">
                        ${reactionsHtml}
                        <div style="position:relative;display:inline-block;">
                            <button class="add-reaction-btn" onclick="toggleManifestoReactionPicker(${m.id})">+ ðŸ˜€</button>
                            <div class="reaction-picker" id="manifesto-picker-${m.id}">
                                ${reactionPickerHtml}
                            </div>
                        </div>
                    </div>
                    <div class="post-comments" id="manifesto-comments-${m.id}">
                        ${commentsHtml}
                    </div>
                    ${replyIndicatorHtml}
                    <div class="comment-input-row">
                        <input class="comment-input" id="manifesto-comment-input-${m.id}" placeholder="${replyingTo && replyingTo.postId === m.id && replyingTo.type === 'manifesto' ? 'Write a reply...' : 'Add a comment...'}" onkeydown="if(event.key==='Enter')addManifestoComment(${m.id})">
                        <button class="comment-send" onclick="addManifestoComment(${m.id})">POST</button>
                    </div>
                </div>
            `;
        }

        window.voteManifesto = async function(manifestoId, direction) {
            if (!currentUser) return;

            const currentVote = myManifestoVotes[manifestoId] || 0;

            // If clicking same direction as current vote, remove vote
            if (direction === currentVote) {
                await supabase
                    .from('sloppygram_manifesto_votes')
                    .delete()
                    .eq('manifesto_id', manifestoId)
                    .eq('user_id', currentUser.id);

                myManifestoVotes[manifestoId] = 0;
                manifestoVotes[manifestoId] = (manifestoVotes[manifestoId] || 0) - direction;
            } else {
                // If had previous vote, adjust score and delete old vote
                if (currentVote !== 0) {
                    manifestoVotes[manifestoId] = (manifestoVotes[manifestoId] || 0) - currentVote;
                    await supabase
                        .from('sloppygram_manifesto_votes')
                        .delete()
                        .eq('manifesto_id', manifestoId)
                        .eq('user_id', currentUser.id);
                }

                // Add new vote with vote_type column (1=up, -1=down)
                await supabase
                    .from('sloppygram_manifesto_votes')
                    .insert({
                        manifesto_id: manifestoId,
                        username: profile.username,
                        user_id: currentUser.id,
                        vote_type: direction
                    });

                myManifestoVotes[manifestoId] = direction;
                manifestoVotes[manifestoId] = (manifestoVotes[manifestoId] || 0) + direction;
            }

            // Update Confidence Monitor if available
            if (typeof updateConfidenceMonitor === 'function') {
                updateConfidenceMonitor();
            }

            renderManifestos();
        };

        window.deleteManifesto = async function(manifestoId) {
            if (!currentUser) return;
            if (!confirm('Delete this manifesto?')) return;

            const { error } = await supabase
                .from('sloppygram_manifestos')
                .delete()
                .eq('id', manifestoId)
                .eq('user_id', currentUser.id);

            if (error) {
                console.error('Error deleting manifesto:', error);
                showToast('Failed to delete manifesto', 'error');
                return;
            }

            // Remove from local array
            manifestos = manifestos.filter(m => m.id !== manifestoId);
            // Clean up related data
            delete manifestoVotes[manifestoId];
            delete myManifestoVotes[manifestoId];
            delete manifestoReactions[manifestoId];
            delete myManifestoReactions[manifestoId];
            delete manifestoComments[manifestoId];
            delete manifestoTags[manifestoId];

            showToast('Manifesto deleted', 'success');
            renderManifestos();
        };

        window.toggleManifestoReactionPicker = function(manifestoId) {
            const picker = document.getElementById(`manifesto-picker-${manifestoId}`);
            document.querySelectorAll('.reaction-picker').forEach(p => {
                if (p !== picker) p.classList.remove('active');
            });
            picker.classList.toggle('active');
        };

        window.toggleManifestoReaction = async function(manifestoId, emoji) {
            if (!currentUser) return;

            const myReacts = myManifestoReactions[manifestoId] || new Set();
            const hasReacted = myReacts.has(emoji);

            if (hasReacted) {
                await supabase
                    .from('sloppygram_manifesto_reactions')
                    .delete()
                    .eq('manifesto_id', manifestoId)
                    .eq('emoji', emoji)
                    .eq('user_id', currentUser.id);

                myReacts.delete(emoji);
                if (!manifestoReactions[manifestoId]) manifestoReactions[manifestoId] = {};
                manifestoReactions[manifestoId][emoji] = Math.max(0, (manifestoReactions[manifestoId][emoji] || 0) - 1);
                if (manifestoReactions[manifestoId][emoji] === 0) delete manifestoReactions[manifestoId][emoji];
            } else {
                await supabase
                    .from('sloppygram_manifesto_reactions')
                    .insert({
                        manifesto_id: manifestoId,
                        emoji,
                        username: profile.username,
                        user_id: currentUser.id
                    });

                myReacts.add(emoji);
                if (!manifestoReactions[manifestoId]) manifestoReactions[manifestoId] = {};
                manifestoReactions[manifestoId][emoji] = (manifestoReactions[manifestoId][emoji] || 0) + 1;
            }

            myManifestoReactions[manifestoId] = myReacts;
            document.querySelectorAll('.reaction-picker').forEach(p => p.classList.remove('active'));
            renderManifestos();
        };

        window.focusManifestoComment = function(manifestoId) {
            document.getElementById(`manifesto-comment-input-${manifestoId}`).focus();
        };

        window.addManifestoComment = async function(manifestoId) {
            const input = document.getElementById(`manifesto-comment-input-${manifestoId}`);
            const rawContent = input.value.trim();
            if (!rawContent || !currentUser) return;

            // Rate limiting check
            const rateCheck = checkRateLimit('comment');
            if (!rateCheck.allowed) {
                showToast(rateCheck.message, 'warning');
                return;
            }
            recordAction('comment');

            // Sanitize content before storage (defense-in-depth)
            const content = sanitizeForStorage(rawContent);
            if (!content) return;

            // Rate limiting check
            const rateCheck = checkRateLimit('comment');
            if (!rateCheck.allowed) {
                showToast(rateCheck.message, 'warning');
                return;
            }
            recordAction('comment');

            const comment = {
                manifesto_id: manifestoId,
                username: profile.username,
                avatar: profile.avatar,
                content,
                user_id: currentUser.id
            };

            const { data, error } = await supabase
                .from('sloppygram_manifesto_comments')
                .insert(comment)
                .select()
                .single();

            if (error) {
                console.error('Error adding comment:', error);
                return;
            }

            // If this is a reply, save the thread relationship
            if (replyingTo && replyingTo.postId === manifestoId && replyingTo.type === 'manifesto' && data) {
                await supabase
                    .from('sloppygram_comment_threads')
                    .insert({
                        comment_id: data.id,
                        parent_comment_id: replyingTo.commentId,
                        comment_type: 'manifesto',
                        post_id: manifestoId,
                        user_id: currentUser.id
                    });
                commentThreads[data.id] = replyingTo.commentId;
            }

            if (!manifestoComments[manifestoId]) manifestoComments[manifestoId] = [];
            manifestoComments[manifestoId].push({ ...comment, id: (data && data.id) ? data.id : null, created_at: new Date().toISOString() });

            input.value = '';
            replyingTo = null;
            renderManifestos();
        };

        // === REPUTATION SYSTEM ===

        async function loadReputations() {
            // Calculate reputation from post votes (net score using vote_type)
            const { data: postsData } = await supabase
                .from('sloppygram_posts')
                .select('username, id');

            const postsByUser = {};
            (postsData || []).forEach(p => {
                if (p.username) {
                    if (!postsByUser[p.username]) postsByUser[p.username] = [];
                    postsByUser[p.username].push(p.id);
                }
            });

            const { data: postVotesData } = await supabase
                .from('sloppygram_post_likes')
                .select('post_id, vote_type');

            const postVotesByPost = {};
            (postVotesData || []).forEach(v => {
                postVotesByPost[v.post_id] = (postVotesByPost[v.post_id] || 0) + (v.vote_type || 1);
            });

            const postScoresByUser = {};
            for (const [username, postIds] of Object.entries(postsByUser)) {
                postScoresByUser[username] = postIds.reduce((sum, id) => sum + (postVotesByPost[id] || 0), 0);
            }

            // Calculate reputation from manifesto votes
            const { data: manifestosData } = await supabase
                .from('sloppygram_manifestos')
                .select('username, id');

            const manifestosByUser = {};
            (manifestosData || []).forEach(m => {
                if (m.username) {
                    if (!manifestosByUser[m.username]) manifestosByUser[m.username] = [];
                    manifestosByUser[m.username].push(m.id);
                }
            });

            const manifestoVotesByUser = {};
            for (const [username, manifestoIds] of Object.entries(manifestosByUser)) {
                if (manifestoIds.length > 0) {
                    const { count } = await supabase
                        .from('sloppygram_manifesto_votes')
                        .select('*', { count: 'exact', head: true })
                        .in('manifesto_id', manifestoIds);
                    manifestoVotesByUser[username] = count || 0;
                }
            }

            // Calculate reputation from chat message votes (net score)
            const { data: messagesData } = await supabase
                .from('sloppygram_messages')
                .select('username, id');

            const messagesByUser = {};
            (messagesData || []).forEach(m => {
                if (m.username) {
                    if (!messagesByUser[m.username]) messagesByUser[m.username] = [];
                    messagesByUser[m.username].push(m.id);
                }
            });

            const { data: chatVotesData } = await supabase
                .from('sloppygram_message_votes')
                .select('message_id, vote_type');

            const chatVotesByMessage = {};
            (chatVotesData || []).forEach(v => {
                chatVotesByMessage[v.message_id] = (chatVotesByMessage[v.message_id] || 0) + (v.vote_type || 1);
            });

            const chatVotesByUser = {};
            for (const [username, msgIds] of Object.entries(messagesByUser)) {
                chatVotesByUser[username] = msgIds.reduce((sum, id) => sum + (chatVotesByMessage[id] || 0), 0);
            }

            // Calculate reputation from doodle votes (net score)
            const { data: doodleVotesData } = await supabase
                .from('sloppygram_doodle_votes')
                .select('message_id, vote_type');

            const doodleVotesByMessage = {};
            (doodleVotesData || []).forEach(v => {
                doodleVotesByMessage[v.message_id] = (doodleVotesByMessage[v.message_id] || 0) + (v.vote_type || 1);
            });

            const doodleVotesByUser = {};
            for (const [username, msgIds] of Object.entries(messagesByUser)) {
                doodleVotesByUser[username] = msgIds.reduce((sum, id) => sum + (doodleVotesByMessage[id] || 0), 0);
            }

            // Combine into reputation scores
            const allUsers = new Set([
                ...Object.keys(postScoresByUser),
                ...Object.keys(manifestoVotesByUser),
                ...Object.keys(chatVotesByUser),
                ...Object.keys(doodleVotesByUser)
            ]);
            userReputations = {};
            allUsers.forEach(username => {
                const postScore = postScoresByUser[username] || 0;
                const manifestoVotes = manifestoVotesByUser[username] || 0;
                const chatScore = chatVotesByUser[username] || 0;
                const doodleScore = doodleVotesByUser[username] || 0;
                userReputations[username] = {
                    postLikes: postScore,
                    manifestoVotes,
                    chatVotes: chatScore,
                    doodleVotes: doodleScore,
                    total: postScore + (manifestoVotes * 2) + chatScore + (doodleScore * 2)
                };
            });

            console.log('Loaded reputations:', userReputations);
        }

        function getReputationBadge(username) {
            const rep = userReputations[username];
            if (!rep || rep.total === 0) return '';

            let badge = '';
            const parts = [];
            if (rep.postLikes > 0) parts.push(`${rep.postLikes} post`);
            if (rep.manifestoVotes > 0) parts.push(`${rep.manifestoVotes} manifesto`);
            if (rep.chatVotes > 0) parts.push(`${rep.chatVotes} chat`);
            if (rep.doodleVotes > 0) parts.push(`${rep.doodleVotes} doodle`);
            let title = `âš¡${rep.total} power (${parts.join(', ')})`;

            if (rep.total >= 100) {
                badge = 'ðŸ‘‘';
            } else if (rep.total >= 50) {
                badge = 'â­';
            } else if (rep.total >= 20) {
                badge = 'âœ¨';
            } else if (rep.total >= 5) {
                badge = 'ðŸ”¥';
            }

            return badge ? `<span class="rep-badge" title="${title}">${badge}${rep.total}</span>` :
                          `<span class="rep-badge small" title="${title}">âš¡${rep.total}</span>`;
        }

        // === KARMA LEADERBOARD SYSTEM ===

        const KARMA_WEIGHTS = {
            message_created: 1,
            post_created: 3,
            doodle_created: 5,
            manifesto_created: 10,
            upvote_received: 2,
            downvote_received: -1,
            reaction_received: 1,
            comment_received: 2
        };

        const KARMA_BADGES = {
            rising_star: { emoji: 'â­', name: 'Rising Star', threshold: { karma: 100 }},
            community_pillar: { emoji: 'ðŸ†', name: 'Community Pillar', threshold: { karma: 500 }},
            legend: { emoji: 'ðŸ‘‘', name: 'Legend', threshold: { karma: 1000 }},
            doodle_master: { emoji: 'ðŸŽ¨', name: 'Doodle Master', threshold: { doodles: 25 }},
            philosopher: { emoji: 'ðŸ›ï¸', name: 'Philosopher', threshold: { manifestos: 25 }},
            week_warrior: { emoji: 'ðŸ“†', name: 'Week Warrior', threshold: { streak: 7 }},
            month_master: { emoji: 'ðŸ—“ï¸', name: 'Month Master', threshold: { streak: 30 }},
            popular: { emoji: 'ðŸ”¥', name: 'Popular', threshold: { upvotes: 100 }},
            beloved: { emoji: 'â¤ï¸', name: 'Beloved', threshold: { reactions: 50 }},
            diverse_creator: { emoji: 'ðŸŒˆ', name: 'Diverse Creator', threshold: { categories: 4 }}
        };

        let karmaCache = {};
        let karmaLeaderboard = [];
        let currentKarmaPeriod = 'all';
        let currentKarmaCategory = 'overall';

        // AI-driven content quality scoring
        function calculateQualityBonus(content) {
            if (!content) return 0;
            const length = content.length;
            // Length bonus: +0.5 per 100 chars, max 5
            const lengthBonus = Math.min(5, Math.floor(length / 100) * 0.5);
            // Word diversity bonus
            const words = content.toLowerCase().split(/\s+/);
            const uniqueWords = new Set(words).size;
            const diversityRatio = words.length > 0 ? uniqueWords / words.length : 0;
            const diversityBonus = diversityRatio > 0.7 ? 1 : 0;
            return lengthBonus + diversityBonus;
        }

        // Trust multiplier based on voter karma
        function getTrustMultiplier(voterKarma) {
            return Math.min(2.0, 1 + (voterKarma || 0) / 1000);
        }

        // Calculate karma for a user
        async function calculateUserKarma(username) {
            try {
                // Parallel fetch all user data
                const [
                    { data: messages },
                    { data: posts },
                    { data: manifestos },
                    { data: messageVotes },
                    { data: postVotes },
                    { data: manifestoVotes },
                    { data: doodleVotes },
                    { data: messageReactions },
                    { data: postReactions },
                    { data: manifestoReactions },
                    { data: postComments },
                    { data: manifestoComments }
                ] = await Promise.all([
                    supabase.from('sloppygram_messages').select('id, content, drawing_data, created_at').eq('username', username),
                    supabase.from('sloppygram_posts').select('id, caption, created_at').eq('username', username),
                    supabase.from('sloppygram_manifestos').select('id, title, content, created_at').eq('username', username),
                    supabase.from('sloppygram_message_votes').select('message_id, vote_type'),
                    supabase.from('sloppygram_post_likes').select('post_id, vote_type'),
                    supabase.from('sloppygram_manifesto_votes').select('manifesto_id, vote_type'),
                    supabase.from('sloppygram_doodle_votes').select('message_id, vote_type'),
                    supabase.from('sloppygram_message_reactions').select('message_id'),
                    supabase.from('sloppygram_post_reactions').select('post_id'),
                    supabase.from('sloppygram_manifesto_reactions').select('manifesto_id'),
                    supabase.from('sloppygram_post_comments').select('post_id'),
                    supabase.from('sloppygram_manifesto_comments').select('manifesto_id')
                ]);

                const msgArray = messages || [];
                const postArray = posts || [];
                const manifestoArray = manifestos || [];

                // Get user's content IDs
                const userMsgIds = new Set(msgArray.map(m => m.id));
                const userPostIds = new Set(postArray.map(p => p.id));
                const userManifestoIds = new Set(manifestoArray.map(m => m.id));
                const userDoodleIds = new Set(msgArray.filter(m => m.drawing_data).map(m => m.id));

                // Count content
                const textMsgCount = msgArray.filter(m => !m.drawing_data).length;
                const doodleCount = msgArray.filter(m => m.drawing_data).length;
                const postCount = postArray.length;
                const manifestoCount = manifestoArray.length;

                let karma = { content: 0, engagement: 0, social: 0, trust: 0 };

                // Content creation points
                karma.content += textMsgCount * KARMA_WEIGHTS.message_created;
                karma.content += postCount * KARMA_WEIGHTS.post_created;
                karma.content += doodleCount * KARMA_WEIGHTS.doodle_created;
                karma.content += manifestoCount * KARMA_WEIGHTS.manifesto_created;

                // Quality bonuses for manifestos
                manifestoArray.forEach(m => {
                    karma.content += calculateQualityBonus(m.content) * 2;
                });

                // Engagement: votes received
                let upvotes = 0, downvotes = 0;
                (messageVotes || []).forEach(v => {
                    if (userMsgIds.has(v.message_id)) {
                        if (v.vote_type > 0) upvotes++;
                        else if (v.vote_type < 0) downvotes++;
                    }
                });
                (postVotes || []).forEach(v => {
                    if (userPostIds.has(v.post_id)) {
                        if (v.vote_type > 0) upvotes++;
                        else if (v.vote_type < 0) downvotes++;
                    }
                });
                (manifestoVotes || []).forEach(v => {
                    if (userManifestoIds.has(v.manifesto_id)) {
                        if (v.vote_type > 0) upvotes++;
                        else if (v.vote_type < 0) downvotes++;
                    }
                });
                (doodleVotes || []).forEach(v => {
                    if (userDoodleIds.has(v.message_id)) {
                        if (v.vote_type > 0) upvotes++;
                        else if (v.vote_type < 0) downvotes++;
                    }
                });

                karma.engagement += upvotes * KARMA_WEIGHTS.upvote_received;
                karma.engagement += downvotes * KARMA_WEIGHTS.downvote_received;

                // Reactions received
                let reactionsCount = 0;
                reactionsCount += (messageReactions || []).filter(r => userMsgIds.has(r.message_id)).length;
                reactionsCount += (postReactions || []).filter(r => userPostIds.has(r.post_id)).length;
                reactionsCount += (manifestoReactions || []).filter(r => userManifestoIds.has(r.manifesto_id)).length;
                karma.engagement += reactionsCount * KARMA_WEIGHTS.reaction_received;

                // Social: comments received
                let commentsCount = 0;
                commentsCount += (postComments || []).filter(c => userPostIds.has(c.post_id)).length;
                commentsCount += (manifestoComments || []).filter(c => userManifestoIds.has(c.manifesto_id)).length;
                karma.social += commentsCount * KARMA_WEIGHTS.comment_received;

                // Diversity multiplier
                const activeCategories = [textMsgCount, postCount, doodleCount, manifestoCount].filter(c => c > 0).length;
                const diversityMultiplier = 1 + (activeCategories - 1) * 0.2;

                // Calculate streak (simplified - check if posted in last 7 days)
                const now = new Date();
                const recentActivity = [...msgArray, ...postArray, ...manifestoArray]
                    .some(item => (now - new Date(item.created_at)) < 7 * 24 * 60 * 60 * 1000);
                const streakMultiplier = recentActivity ? 1.1 : 1.0;

                const baseKarma = karma.content + karma.engagement + karma.social + karma.trust;
                const totalKarma = Math.round(baseKarma * diversityMultiplier * streakMultiplier);

                return {
                    username,
                    total: totalKarma,
                    content: Math.round(karma.content),
                    engagement: Math.round(karma.engagement),
                    social: Math.round(karma.social),
                    trust: Math.round(karma.trust),
                    messages: textMsgCount,
                    posts: postCount,
                    doodles: doodleCount,
                    manifestos: manifestoCount,
                    upvotes,
                    downvotes,
                    reactions: reactionsCount,
                    comments: commentsCount,
                    diversity: activeCategories,
                    streak: recentActivity ? 1 : 0
                };
            } catch (err) {
                console.error('Error calculating karma for', username, err);
                return { username, total: 0, content: 0, engagement: 0, social: 0, trust: 0 };
            }
        }

        // Get earned badges for karma data
        function getEarnedBadges(karmaData) {
            const badges = [];
            if (karmaData.total >= 1000) badges.push(KARMA_BADGES.legend);
            else if (karmaData.total >= 500) badges.push(KARMA_BADGES.community_pillar);
            else if (karmaData.total >= 100) badges.push(KARMA_BADGES.rising_star);

            if (karmaData.doodles >= 25) badges.push(KARMA_BADGES.doodle_master);
            if (karmaData.manifestos >= 25) badges.push(KARMA_BADGES.philosopher);
            if (karmaData.upvotes >= 100) badges.push(KARMA_BADGES.popular);
            if (karmaData.reactions >= 50) badges.push(KARMA_BADGES.beloved);
            if (karmaData.diversity >= 4) badges.push(KARMA_BADGES.diverse_creator);

            return badges;
        }

        // Load karma leaderboard
        async function loadKarmaLeaderboard() {
            const listEl = document.getElementById('karmaList');
            listEl.innerHTML = '<div class="karma-loading">Calculating karma scores...</div>';

            try {
                // Get all unique usernames
                const [{ data: msgUsers }, { data: postUsers }, { data: manifestoUsers }] = await Promise.all([
                    supabase.from('sloppygram_messages').select('username').limit(500),
                    supabase.from('sloppygram_posts').select('username').limit(500),
                    supabase.from('sloppygram_manifestos').select('username').limit(500)
                ]);

                const allUsernames = new Set();
                (msgUsers || []).forEach(u => u.username && allUsernames.add(u.username));
                (postUsers || []).forEach(u => u.username && allUsernames.add(u.username));
                (manifestoUsers || []).forEach(u => u.username && allUsernames.add(u.username));

                // Calculate karma for each user (limited for performance)
                const usernameArray = Array.from(allUsernames).slice(0, 50);
                const karmaPromises = usernameArray.map(username => calculateUserKarma(username));
                const karmaResults = await Promise.all(karmaPromises);

                // Sort by total karma
                karmaLeaderboard = karmaResults
                    .filter(k => k.total > 0)
                    .sort((a, b) => b.total - a.total);

                // Apply category filter
                if (currentKarmaCategory === 'creators') {
                    karmaLeaderboard.sort((a, b) => (b.posts + b.messages) - (a.posts + a.messages));
                } else if (currentKarmaCategory === 'philosophers') {
                    karmaLeaderboard.sort((a, b) => b.manifestos - a.manifestos);
                } else if (currentKarmaCategory === 'artists') {
                    karmaLeaderboard.sort((a, b) => b.doodles - a.doodles);
                }

                // Update stats
                document.getElementById('karmaTotalUsers').textContent = karmaLeaderboard.length;
                const totalKarma = karmaLeaderboard.reduce((sum, k) => sum + k.total, 0);
                document.getElementById('karmaTotalKarma').textContent = totalKarma.toLocaleString();
                document.getElementById('karmaTopScore').textContent = karmaLeaderboard[0]?.total || 0;

                // Render leaderboard
                renderKarmaLeaderboard();

                // Update my stats
                if (profile.username) {
                    const myKarma = karmaLeaderboard.find(k => k.username === profile.username);
                    const myRank = karmaLeaderboard.findIndex(k => k.username === profile.username) + 1;
                    updateMyKarmaStats(myKarma, myRank);
                }
            } catch (err) {
                console.error('Failed to load karma leaderboard:', err);
                listEl.innerHTML = '<div class="karma-loading">Error loading leaderboard</div>';
            }
        }

        function renderKarmaLeaderboard() {
            const listEl = document.getElementById('karmaList');

            if (karmaLeaderboard.length === 0) {
                listEl.innerHTML = '<div class="karma-loading">No karma data yet. Start contributing!</div>';
                return;
            }

            listEl.innerHTML = karmaLeaderboard.slice(0, 50).map((k, i) => {
                const rank = i + 1;
                const rankClass = rank === 1 ? 'gold' : rank === 2 ? 'silver' : rank === 3 ? 'bronze' : '';
                const rankIcon = rank === 1 ? 'ðŸ¥‡' : rank === 2 ? 'ðŸ¥ˆ' : rank === 3 ? 'ðŸ¥‰' : `#${rank}`;
                const badges = getEarnedBadges(k);
                const badgesHtml = badges.slice(0, 3).map(b => `<span class="karma-badge" title="${b.name}">${b.emoji}</span>`).join('');
                const avatar = 'ðŸ‘¤'; // Default avatar

                return `
                    <div class="karma-entry ${rank <= 3 ? 'top-3' : ''}" onclick="showProfileCard('${escapeAttr(k.username)}', event)">
                        <div class="karma-rank ${rankClass}">${rankIcon}</div>
                        <div class="karma-avatar">${avatar}</div>
                        <div class="karma-user-info">
                            <div class="karma-username">${escapeHtml(k.username)}</div>
                            <div class="karma-badges-row">${badgesHtml}</div>
                        </div>
                        <div class="karma-score">
                            <div class="karma-score-total">âš¡${k.total}</div>
                            <div class="karma-score-breakdown">ðŸ“${k.content} ðŸ‘${k.engagement} ðŸ’¬${k.social}</div>
                        </div>
                    </div>
                `;
            }).join('');
        }

        function updateMyKarmaStats(karmaData, rank) {
            if (!karmaData) {
                document.getElementById('karmaMyTotal').textContent = 'âš¡ 0';
                document.getElementById('karmaMyRank').textContent = '#--';
                return;
            }

            document.getElementById('karmaMyTotal').textContent = `âš¡ ${karmaData.total}`;
            document.getElementById('karmaMyRank').textContent = rank > 0 ? `#${rank}` : '#--';
            document.getElementById('karmaMyContent').textContent = karmaData.content;
            document.getElementById('karmaMyEngagement').textContent = karmaData.engagement;
            document.getElementById('karmaMySocial').textContent = karmaData.social;
            document.getElementById('karmaMyTrust').textContent = karmaData.trust;

            const badges = getEarnedBadges(karmaData);
            const badgesEl = document.getElementById('karmaMyBadges');
            badgesEl.innerHTML = badges.map(b =>
                `<span class="karma-badge-earned" title="${b.name}">${b.emoji} ${b.name}</span>`
            ).join('');
        }

        window.filterKarma = function(period) {
            currentKarmaPeriod = period;
            document.querySelectorAll('.karma-filter').forEach(btn => {
                btn.classList.toggle('active', btn.dataset.period === period);
            });
            loadKarmaLeaderboard();
        };

        window.filterKarmaCategory = function(category) {
            currentKarmaCategory = category;
            document.querySelectorAll('.karma-cat-btn').forEach(btn => {
                btn.classList.toggle('active', btn.dataset.category === category);
            });
            loadKarmaLeaderboard();
        };

        // === FACTION WARS SYSTEM ===

        // Predefined factions
        const FACTIONS = [
            { id: 'phoenix', name: 'Phoenix Order', emoji: 'ðŸ”¥', color: '#ff4444', description: 'Rise from the ashes. Eternal rebirth.' },
            { id: 'shadow', name: 'Shadow Collective', emoji: 'ðŸŒ‘', color: '#4a4a6a', description: 'Strike from darkness. Silent dominion.' },
            { id: 'cyber', name: 'Cyber Nexus', emoji: 'âš¡', color: '#00ffff', description: 'Digital supremacy. Code is law.' },
            { id: 'nature', name: 'Verdant Grove', emoji: 'ðŸŒ¿', color: '#22c55e', description: 'Nature prevails. Growth eternal.' },
            { id: 'cosmic', name: 'Cosmic Void', emoji: 'ðŸŒŒ', color: '#8b5cf6', description: 'Beyond the stars. Infinite power.' }
        ];

        // Territory names for 5x5 grid
        const TERRITORY_NAMES = [
            'Northern Peaks', 'Frost Gate', 'Crystal Vale', 'Thunder Pass', 'Eastern Watch',
            'Wolf Den', 'Iron Forge', 'Central Nexus', 'Trade Hub', 'Sun Temple',
            'Mystic Grove', 'Shadow Port', 'Grand Arena', 'Tech District', 'Golden Fields',
            'Swamp Hollow', 'Deep Mines', 'River Cross', 'Sky Tower', 'Fire Pit',
            'Southern Shore', 'Hidden Cove', 'Ancient Ruins', 'Blood Marsh', 'Dragon\'s End'
        ];

        let userFaction = null;
        let factionsData = [];
        let territoriesData = [];
        let battlesData = [];

        // Faction/territory seeding managed by Sloppy Factions (sovereign owner)
        async function initializeFactions() {
            // No-op: sloppy-factions handles seeding
        }

        // Load faction data
        async function loadFactionsData() {
            const [fRes, tRes, mRes, bRes] = await Promise.all([
                supabase.from('sloppygram_factions').select('faction_id, name, emoji, color, description, member_count, territory_count, power_score'),
                supabase.from('sloppygram_territories').select('territory_id, name, grid_x, grid_y, controlling_faction, defense_power, captured_at, captured_by'),
                profile.username ? supabase.from('sloppygram_faction_members').select('username, faction_id, contribution_score, battles_won, battles_lost').eq('username', profile.username).limit(1) : Promise.resolve({ data: [] }),
                supabase.from('sloppygram_faction_battles').select('attacker_faction, defender_faction, territory_id, attacker_username, attacker_power, defender_power, winner_faction, status, created_at').order('created_at', { ascending: false }).limit(20)
            ]);

            factionsData = fRes.data || [];
            territoriesData = tRes.data || [];
            battlesData = bRes.data || [];

            // Get user's faction
            if (mRes.data && mRes.data.length > 0) {
                userFaction = mRes.data[0];
            } else {
                userFaction = null;
            }

            renderFactionsUI();
        }

        // Render the factions UI
        function renderFactionsUI() {
            renderFactionSelection();
            renderMyFactionBanner();
            renderTerritoryMap();
            renderFactionLeaderboard();
            renderBattleLog();
            updateWarStats();
        }

        // Render faction selection grid
        function renderFactionSelection() {
            const grid = document.getElementById('factionGrid');
            const selection = document.getElementById('factionSelection');
            if (!grid || !selection) return;

            // Hide selection if user is in a faction
            if (userFaction) {
                selection.style.display = 'none';
                return;
            }

            selection.style.display = 'block';

            grid.innerHTML = factionsData.map(f => {
                const factionInfo = FACTIONS.find(fi => fi.id === f.faction_id) || f;
                return `
                    <div class="faction-card" style="border-color: ${factionInfo.color}40;">
                        <div class="faction-emoji">${factionInfo.emoji}</div>
                        <div class="faction-name" style="color: ${factionInfo.color};">${factionInfo.name}</div>
                        <div class="faction-desc">${factionInfo.description}</div>
                        <div class="faction-members">ðŸ‘¥ ${f.member_count || 0} warriors</div>
                        <button class="pledge-btn" onclick="pledgeToFaction('${f.faction_id}')" style="background: linear-gradient(135deg, ${factionInfo.color}, ${factionInfo.color}99);">
                            âš”ï¸ Pledge Allegiance
                        </button>
                    </div>
                `;
            }).join('');
        }

        // Render user's faction banner
        function renderMyFactionBanner() {
            const banner = document.getElementById('myFactionBanner');
            if (!banner) return;

            if (!userFaction) {
                banner.style.display = 'none';
                return;
            }

            const factionInfo = FACTIONS.find(f => f.id === userFaction.faction_id);
            if (!factionInfo) return;

            banner.style.display = 'flex';
            banner.style.borderColor = factionInfo.color;

            document.getElementById('myFactionEmoji').textContent = factionInfo.emoji;
            document.getElementById('myFactionName').textContent = factionInfo.name;
            document.getElementById('myFactionName').style.color = factionInfo.color;
            document.getElementById('myContribution').textContent = userFaction.contribution_score || 0;
            document.getElementById('myBattlesWon').textContent = userFaction.battles_won || 0;
            document.getElementById('myBattlesLost').textContent = userFaction.battles_lost || 0;
        }

        // Render territory map
        function renderTerritoryMap() {
            const grid = document.getElementById('territoryGrid');
            const legend = document.getElementById('territoryLegend');
            if (!grid) return;

            // Build legend
            if (legend) {
                legend.innerHTML = factionsData.map(f => {
                    const info = FACTIONS.find(fi => fi.id === f.faction_id) || f;
                    const count = territoriesData.filter(t => t.controlling_faction === f.faction_id).length;
                    return `<span class="territory-legend-item"><span class="territory-legend-color" style="background:${info.color};"></span>${info.emoji} ${count}</span>`;
                }).join('');
            }

            // Sort territories by grid position
            const sorted = [...territoriesData].sort((a, b) => {
                if (a.grid_y !== b.grid_y) return a.grid_y - b.grid_y;
                return a.grid_x - b.grid_x;
            });

            grid.innerHTML = sorted.map(t => {
                const controller = t.controlling_faction ? FACTIONS.find(f => f.id === t.controlling_faction) : null;
                const bgColor = controller ? controller.color : '#666';
                const canAttack = userFaction && t.controlling_faction !== userFaction.faction_id;
                const isOurs = userFaction && t.controlling_faction === userFaction.faction_id;

                return `
                    <div class="territory-cell ${!controller ? 'neutral' : ''}"
                         style="background: ${bgColor}40; border-color: ${bgColor};"
                         title="${t.name}${controller ? ' - ' + controller.name : ' - Unclaimed'}"
                         onclick="selectTerritory('${t.territory_id}')">
                        <div class="territory-name">${t.name}</div>
                        <div class="territory-defense">ðŸ›¡ï¸ ${t.defense_power || 10}</div>
                        ${canAttack ? `<button class="attack-btn" onclick="event.stopPropagation();attackTerritory('${t.territory_id}')">âš”ï¸</button>` : ''}
                        ${isOurs ? '<span style="position:absolute;top:2px;right:2px;font-size:0.6rem;">ðŸ </span>' : ''}
                    </div>
                `;
            }).join('');
        }

        // Render faction leaderboard
        function renderFactionLeaderboard() {
            const list = document.getElementById('factionLeaderboard');
            if (!list) return;

            // Sort by territory count, then power score
            const sorted = [...factionsData].sort((a, b) => {
                const aCount = territoriesData.filter(t => t.controlling_faction === a.faction_id).length;
                const bCount = territoriesData.filter(t => t.controlling_faction === b.faction_id).length;
                if (bCount !== aCount) return bCount - aCount;
                return (b.power_score || 0) - (a.power_score || 0);
            });

            list.innerHTML = sorted.map((f, i) => {
                const info = FACTIONS.find(fi => fi.id === f.faction_id) || f;
                const terrCount = territoriesData.filter(t => t.controlling_faction === f.faction_id).length;
                const rankClass = i === 0 ? 'gold' : i === 1 ? 'silver' : i === 2 ? 'bronze' : '';

                return `
                    <div class="faction-lb-entry" style="border-left-color: ${info.color};">
                        <span class="faction-lb-rank ${rankClass}">#${i + 1}</span>
                        <div class="faction-lb-info">
                            <span class="faction-lb-emoji">${info.emoji}</span>
                            <span class="faction-lb-name" style="color: ${info.color};">${info.name}</span>
                        </div>
                        <div class="faction-lb-stats">
                            <span>ðŸ—ºï¸ ${terrCount}</span>
                            <span>ðŸ‘¥ ${f.member_count || 0}</span>
                            <span>âš¡ ${f.power_score || 0}</span>
                        </div>
                    </div>
                `;
            }).join('');
        }

        // Render battle log
        function renderBattleLog() {
            const list = document.getElementById('battleLogList');
            if (!list) return;

            if (battlesData.length === 0) {
                list.innerHTML = '<div class="battle-log-empty">No battles yet. Be the first to attack!</div>';
                return;
            }

            list.innerHTML = battlesData.slice(0, 10).map(b => {
                const attacker = FACTIONS.find(f => f.id === b.attacker_faction);
                const defender = FACTIONS.find(f => f.id === b.defender_faction);
                const territory = territoriesData.find(t => t.territory_id === b.territory_id);
                const isVictory = b.winner_faction === b.attacker_faction;
                const time = new Date(b.created_at).toLocaleTimeString();

                return `
                    <div class="battle-log-entry ${isVictory ? 'victory' : ''}">
                        ${attacker ? attacker.emoji : 'âš”ï¸'} <strong>${attacker ? attacker.name : 'Unknown'}</strong>
                        ${isVictory ? 'conquered' : 'failed to take'}
                        <strong>${territory ? territory.name : 'territory'}</strong>
                        from ${defender ? defender.emoji + ' ' + defender.name : 'unclaimed'}
                        <span style="float:right;opacity:0.6;">${time}</span>
                    </div>
                `;
            }).join('');
        }

        // Update war stats
        function updateWarStats() {
            const totalTerr = document.getElementById('totalTerritories');
            const totalWarriors = document.getElementById('totalWarriors');
            const activeBattles = document.getElementById('activeBattles');

            if (totalTerr) totalTerr.textContent = territoriesData.length;
            if (totalWarriors) totalWarriors.textContent = factionsData.reduce((sum, f) => sum + (f.member_count || 0), 0);
            if (activeBattles) activeBattles.textContent = battlesData.filter(b => b.status === 'active').length;
        }

        // Pledge to a faction
        window.pledgeToFaction = async function(factionId) {
            if (!currentUser || !profile.username) {
                showToast('Sign in to join a faction', 'warning');
                return;
            }

            if (userFaction) {
                showToast('You are already in a faction. Leave first to join another.', 'warning');
                return;
            }

            // Faction membership managed by Sloppy Factions (sovereign owner)
            showToast('Join factions in Sloppy Factions app', 'info');
        };

        // Leave faction
        window.leaveFaction = async function() {
            if (!userFaction) return;

            if (!confirm('Are you sure you want to leave your clan? You will lose your contribution score.')) {
                return;
            }

            // Faction membership managed by Sloppy Factions (sovereign owner)
            showToast('Manage factions in Sloppy Factions app', 'info');
        };

        // Attack a territory
        window.attackTerritory = async function(territoryId) {
            if (!userFaction) {
                showToast('Join a faction first to attack territories!', 'warning');
                return;
            }

            const territory = territoriesData.find(t => t.territory_id === territoryId);
            if (!territory) return;

            if (territory.controlling_faction === userFaction.faction_id) {
                showToast('This territory already belongs to your clan!', 'info');
                return;
            }

            // Calculate attack power based on user's karma and contribution
            let attackPower = 10 + Math.floor(Math.random() * 20);
            if (typeof calculateUserKarma === 'function') {
                try {
                    const karma = await calculateUserKarma(profile.username);
                    if (karma && karma.total > 0) {
                        attackPower += Math.floor(karma.total / 50);
                    }
                } catch (e) {}
            }
            attackPower += (userFaction.contribution_score || 0);

            const defensePower = territory.defense_power || 10;
            const defender = territory.controlling_faction ? FACTIONS.find(f => f.id === territory.controlling_faction) : null;
            const attacker = FACTIONS.find(f => f.id === userFaction.faction_id);

            // Show battle modal
            showBattleModal(territory, attacker, defender, attackPower, defensePower);
        };

        // Show battle confirmation modal
        function showBattleModal(territory, attacker, defender, attackPower, defensePower) {
            const modal = document.createElement('div');
            modal.className = 'battle-modal';
            modal.id = 'battleModal';
            modal.innerHTML = `
                <div class="battle-modal-content">
                    <div class="battle-modal-title">âš”ï¸ BATTLE FOR TERRITORY</div>
                    <div class="battle-modal-territory">${territory.name}</div>
                    <div class="battle-powers">
                        <div class="battle-side">
                            <div class="battle-side-emoji">${attacker.emoji}</div>
                            <div class="battle-side-power attacker">âš”ï¸ ${attackPower}</div>
                            <div style="font-size:0.7rem;color:var(--text-dim);">Your Attack</div>
                        </div>
                        <div class="battle-vs">VS</div>
                        <div class="battle-side">
                            <div class="battle-side-emoji">${defender ? defender.emoji : 'ðŸ°'}</div>
                            <div class="battle-side-power defender">ðŸ›¡ï¸ ${defensePower}</div>
                            <div style="font-size:0.7rem;color:var(--text-dim);">${defender ? defender.name : 'Neutral'}</div>
                        </div>
                    </div>
                    <div class="battle-actions">
                        <button class="battle-btn attack" onclick="executeBattle('${territory.territory_id}', ${attackPower}, ${defensePower})">âš”ï¸ ATTACK!</button>
                        <button class="battle-btn cancel" onclick="closeBattleModal()">Cancel</button>
                    </div>
                </div>
            `;
            document.body.appendChild(modal);
        }

        window.closeBattleModal = function() {
            const modal = document.getElementById('battleModal');
            if (modal) modal.remove();
        };

        // Battles managed by Sloppy Factions (sovereign owner)
        window.executeBattle = async function(territoryId, attackPower, defensePower) {
            closeBattleModal();
            showToast('Battle in Sloppy Factions app', 'info');
        };

        // Show battle result
        function showBattleResult(victory, territoryName, attacker, defender) {
            const result = document.createElement('div');
            result.className = `battle-result ${victory ? 'victory' : 'defeat'}`;
            result.innerHTML = `
                <div class="battle-result-title">${victory ? 'âš”ï¸ VICTORY!' : 'ðŸ’€ DEFEAT'}</div>
                <div class="battle-result-desc">
                    ${victory
                        ? `${attacker.emoji} ${attacker.name} has conquered ${territoryName}!`
                        : `The attack on ${territoryName} failed. ${defender ? defender.emoji + ' ' + defender.name + ' holds!' : 'Neutral defenses held!'}`
                    }
                </div>
            `;
            document.body.appendChild(result);

            setTimeout(() => {
                result.remove();
            }, 3000);
        }

        // Select territory (for info)
        window.selectTerritory = function(territoryId) {
            const territory = territoriesData.find(t => t.territory_id === territoryId);
            if (!territory) return;

            const controller = territory.controlling_faction ? FACTIONS.find(f => f.id === territory.controlling_faction) : null;
            const msg = controller
                ? `${territory.name} - Controlled by ${controller.emoji} ${controller.name} (ðŸ›¡ï¸ ${territory.defense_power})`
                : `${territory.name} - Unclaimed territory (ðŸ›¡ï¸ ${territory.defense_power})`;
            showToast(msg, 'info');
        };

        // Load factions when switching to factions view
        function initFactionsView() {
            initializeFactions().then(() => {
                loadFactionsData();
            });
        }

        // === DOODLE LEADERBOARD FUNCTIONALITY ===

        async function loadDoodleVotes() {
            const { data: votes } = await supabase
                .from('sloppygram_doodle_votes')
                .select('message_id, voter_username, vote_type');

            if (votes) {
                doodleVotes = {};
                votes.forEach(v => {
                    doodleVotes[v.message_id] = (doodleVotes[v.message_id] || 0) + (v.vote_type || 1);
                });

                myDoodleVotes = {};
                votes.filter(v => v.voter_username === profile.username).forEach(v => {
                    myDoodleVotes[v.message_id] = v.vote_type || 1;
                });
            }
        }

        window.voteDoodle = async function(messageId, voteType, ownerUsername) {
            if (!currentUser) return;
            if (ownerUsername === profile.username) return; // Can't vote on own doodle

            // Rate limiting check
            const rateCheck = checkRateLimit('vote');
            if (!rateCheck.allowed) {
                showToast(rateCheck.message, 'warning');
                return;
            }
            recordAction('vote');

            const currentVote = myDoodleVotes[messageId] || 0;

            if (currentVote === voteType) {
                // Remove vote if clicking same button
                await supabase
                    .from('sloppygram_doodle_votes')
                    .delete()
                    .eq('message_id', messageId)
                    .eq('user_id', currentUser.id);

                myDoodleVotes[messageId] = 0;
                doodleVotes[messageId] = (doodleVotes[messageId] || 0) - voteType;
            } else {
                // Remove existing vote first
                if (currentVote !== 0) {
                    await supabase
                        .from('sloppygram_doodle_votes')
                        .delete()
                        .eq('message_id', messageId)
                        .eq('user_id', currentUser.id);
                    doodleVotes[messageId] = (doodleVotes[messageId] || 0) - currentVote;
                }

                // Add new vote
                await supabase
                    .from('sloppygram_doodle_votes')
                    .insert({
                        message_id: messageId,
                        voter_username: profile.username,
                        vote_type: voteType,
                        user_id: currentUser.id
                    });

                myDoodleVotes[messageId] = voteType;
                doodleVotes[messageId] = (doodleVotes[messageId] || 0) + voteType;
            }

            // Log AI event for doodle vote
            logAiEvent('vote_cast', 'doodle', messageId, {
                vote_type: myDoodleVotes[messageId] || 0,
                net_score: doodleVotes[messageId] || 0
            });

            // Update UI
            updateDoodleVoteUI(messageId);
        };

        function updateDoodleVoteUI(messageId) {
            const score = doodleVotes[messageId] || 0;
            const myVote = myDoodleVotes[messageId] || 0;
            const scoreClass = score > 0 ? 'positive' : score < 0 ? 'negative' : 'neutral';

            document.querySelectorAll(`[data-doodle-id="${messageId}"]`).forEach(container => {
                const scoreEl = container.querySelector('.vote-score');
                const upBtn = container.querySelector('.vote-btn.upvote');
                const downBtn = container.querySelector('.vote-btn.downvote');

                if (scoreEl) {
                    scoreEl.textContent = score;
                    scoreEl.className = `vote-score ${scoreClass}`;
                }
                if (upBtn) upBtn.classList.toggle('active', myVote === 1);
                if (downBtn) downBtn.classList.toggle('active', myVote === -1);
            });
        }

        // === CHAT MESSAGE VOTING ===

        async function loadMessageVotes() {
            const { data: votes } = await supabase
                .from('sloppygram_message_votes')
                .select('message_id, voter_username, vote_type');

            if (votes) {
                messageVotes = {};
                votes.forEach(v => {
                    messageVotes[v.message_id] = (messageVotes[v.message_id] || 0) + (v.vote_type || 1);
                });

                myMessageVotes = {};
                votes.filter(v => v.voter_username === profile.username).forEach(v => {
                    myMessageVotes[v.message_id] = v.vote_type || 1;
                });
            }
        }

        window.voteMessage = async function(messageId, voteType) {
            if (!currentUser) return;

            // Rate limiting check
            const rateCheck = checkRateLimit('vote');
            if (!rateCheck.allowed) {
                showToast(rateCheck.message, 'warning');
                return;
            }
            recordAction('vote');

            const currentVote = myMessageVotes[messageId] || 0;

            if (currentVote === voteType) {
                // Remove vote if clicking same button
                await supabase
                    .from('sloppygram_message_votes')
                    .delete()
                    .eq('message_id', messageId)
                    .eq('user_id', currentUser.id);

                myMessageVotes[messageId] = 0;
                messageVotes[messageId] = (messageVotes[messageId] || 0) - voteType;
            } else {
                // Remove existing vote first
                if (currentVote !== 0) {
                    await supabase
                        .from('sloppygram_message_votes')
                        .delete()
                        .eq('message_id', messageId)
                        .eq('user_id', currentUser.id);
                    messageVotes[messageId] = (messageVotes[messageId] || 0) - currentVote;
                }

                // Add new vote
                await supabase
                    .from('sloppygram_message_votes')
                    .insert({
                        message_id: messageId,
                        voter_username: profile.username,
                        vote_type: voteType,
                        user_id: currentUser.id
                    });

                myMessageVotes[messageId] = voteType;
                messageVotes[messageId] = (messageVotes[messageId] || 0) + voteType;
            }

            // Log AI event for message vote
            logAiEvent('vote_cast', 'message', messageId, {
                vote_type: myMessageVotes[messageId] || 0,
                net_score: messageVotes[messageId] || 0
            });

            // Update UI
            updateMessageVoteUI(messageId);
        };

        function updateMessageVoteUI(messageId) {
            const score = messageVotes[messageId] || 0;
            const myVote = myMessageVotes[messageId] || 0;
            const scoreClass = score > 0 ? 'positive' : score < 0 ? 'negative' : 'neutral';

            document.querySelectorAll(`[data-chat-id="${messageId}"]`).forEach(container => {
                const scoreEl = container.querySelector('.vote-score');
                const upBtn = container.querySelector('.vote-btn.upvote');
                const downBtn = container.querySelector('.vote-btn.downvote');

                if (scoreEl) {
                    scoreEl.textContent = score;
                    scoreEl.className = `vote-score ${scoreClass}`;
                }
                if (upBtn) upBtn.classList.toggle('active', myVote === 1);
                if (downBtn) downBtn.classList.toggle('active', myVote === -1);
            });
        }

        // === MESSAGE REACTIONS ===

        async function loadMessageReactions() {
            var result = await supabase
                .from('sloppygram_message_reactions')
                .select('message_id, emoji, username');

            if (result.data) {
                messageReactions = {};
                myMessageReactions = {};

                result.data.forEach(function(r) {
                    // Count reactions per message
                    if (!messageReactions[r.message_id]) messageReactions[r.message_id] = {};
                    messageReactions[r.message_id][r.emoji] = (messageReactions[r.message_id][r.emoji] || 0) + 1;

                    // Track my reactions
                    if (r.username === profile.username) {
                        if (!myMessageReactions[r.message_id]) myMessageReactions[r.message_id] = new Set();
                        myMessageReactions[r.message_id].add(r.emoji);
                    }
                });
            }
        }

        window.toggleMsgReactionPicker = function(messageId) {
            var picker = document.getElementById('msg-picker-' + messageId);
            if (picker) {
                picker.classList.toggle('active');
            }
        };

        window.toggleMessageReaction = async function(messageId, emoji) {
            if (!currentUser) return;

            // Rate limiting check
            var rateCheck = checkRateLimit('vote');
            if (!rateCheck.allowed) {
                showToast(rateCheck.message, 'warning');
                return;
            }
            recordAction('vote');

            // Close the picker
            var picker = document.getElementById('msg-picker-' + messageId);
            if (picker) picker.classList.remove('active');

            // Check if I already reacted with this emoji
            var myReacts = myMessageReactions[messageId] || new Set();
            var hasReaction = myReacts.has ? myReacts.has(emoji) : false;

            if (hasReaction) {
                // Remove reaction
                await supabase
                    .from('sloppygram_message_reactions')
                    .delete()
                    .eq('message_id', messageId)
                    .eq('emoji', emoji)
                    .eq('user_id', currentUser.id);

                if (myMessageReactions[messageId]) myMessageReactions[messageId].delete(emoji);
                if (messageReactions[messageId] && messageReactions[messageId][emoji]) {
                    messageReactions[messageId][emoji]--;
                    if (messageReactions[messageId][emoji] <= 0) delete messageReactions[messageId][emoji];
                }
            } else {
                // Add reaction
                await supabase
                    .from('sloppygram_message_reactions')
                    .insert({
                        message_id: messageId,
                        emoji: emoji,
                        username: profile.username,
                        user_id: currentUser.id
                    });

                if (!myMessageReactions[messageId]) myMessageReactions[messageId] = new Set();
                myMessageReactions[messageId].add(emoji);
                if (!messageReactions[messageId]) messageReactions[messageId] = {};
                messageReactions[messageId][emoji] = (messageReactions[messageId][emoji] || 0) + 1;

                // ðŸŽ‰ Celebration confetti!
                triggerReactionConfetti(emoji);
            }

            // Update UI
            updateMessageReactionsUI(messageId);
        };

        function triggerReactionConfetti(emoji) {
            if (typeof confetti !== 'function') return;

            // Map emojis to color themes
            var colorMap = {
                'ðŸ˜‚': ['#FFD700', '#FFA500', '#FFFF00'], // gold/yellow for laughing
                'ðŸ”¥': ['#FF4500', '#FF6347', '#FFA500'], // fire colors
                'â¤ï¸': ['#FF1493', '#FF69B4', '#DC143C'], // pink/red for love
                'ðŸ˜®': ['#00CED1', '#20B2AA', '#48D1CC'], // teal for surprise
                'ðŸ˜¢': ['#4169E1', '#6495ED', '#87CEEB'], // blue for sad
                'ðŸ‘': ['#9370DB', '#BA55D3', '#DDA0DD'], // purple for applause
                'ðŸ™Œ': ['#32CD32', '#00FA9A', '#98FB98'], // green for celebration
                'ðŸ’€': ['#808080', '#A9A9A9', '#D3D3D3']  // gray for skull
            };

            var colors = colorMap[emoji] || ['#7c9885', '#b8d4be', '#e8f0ea'];

            // Burst confetti from a random position
            confetti({
                particleCount: 50,
                spread: 60,
                startVelocity: 30,
                colors: colors,
                origin: { x: Math.random() * 0.4 + 0.3, y: Math.random() * 0.3 + 0.3 },
                shapes: ['circle', 'square'],
                scalar: 0.8,
                gravity: 1.2,
                drift: 0,
                ticks: 150
            });

            // Second smaller burst for extra flair
            setTimeout(function() {
                confetti({
                    particleCount: 25,
                    spread: 40,
                    startVelocity: 20,
                    colors: colors,
                    origin: { x: Math.random() * 0.4 + 0.3, y: Math.random() * 0.3 + 0.4 },
                    shapes: ['circle'],
                    scalar: 0.6,
                    gravity: 1,
                    ticks: 100
                });
            }, 150);
        }

        function updateMessageReactionsUI(messageId) {
            var container = document.getElementById('msg-reactions-' + messageId);
            if (!container) return;

            var msgReacts = messageReactions[messageId] || {};
            var myReacts = myMessageReactions[messageId] || new Set();

            // Use escapeAttr to prevent XSS in onclick handlers
            var reactionsHtml = Object.entries(msgReacts)
                .sort(function(a, b) { return b[1] - a[1]; })
                .map(function(entry) {
                    var emoji = entry[0];
                    var count = entry[1];
                    var isActive = myReacts.has ? myReacts.has(emoji) : false;
                    return '<button class="reaction-btn ' + (isActive ? 'active' : '') + '" onclick="toggleMessageReaction(\'' + escapeAttr(messageId) + '\', \'' + escapeAttr(emoji) + '\')">' +
                        escapeHtml(emoji) + ' <span class="reaction-count">' + count + '</span></button>';
                }).join('');

            var pickerHtml = REACTION_EMOJIS.map(function(emoji) {
                return '<button onclick="toggleMessageReaction(\'' + escapeAttr(messageId) + '\', \'' + escapeAttr(emoji) + '\')">' + emoji + '</button>';
            }).join('');

            container.innerHTML = reactionsHtml +
                '<div style="position:relative;display:inline-block;">' +
                    '<button class="add-reaction-btn" onclick="toggleMsgReactionPicker(\'' + escapeAttr(messageId) + '\')">+ðŸ˜€</button>' +
                    '<div class="reaction-picker" id="msg-picker-' + escapeAttr(messageId) + '">' + pickerHtml + '</div>' +
                '</div>';
        }

        // === COMMENT VOTING ===

        async function loadCommentVotes() {
            const { data: votes } = await supabase
                .from('sloppygram_comment_votes')
                .select('comment_id, voter_username, vote_type');

            if (votes) {
                commentVotes = {};
                votes.forEach(v => {
                    commentVotes[v.comment_id] = (commentVotes[v.comment_id] || 0) + (v.vote_type || 1);
                });

                myCommentVotes = {};
                votes.filter(v => v.voter_username === profile.username).forEach(v => {
                    myCommentVotes[v.comment_id] = v.vote_type || 1;
                });
            }
        }

        window.voteComment = async function(commentId, voteType, ownerUsername) {
            if (!currentUser) return;
            if (ownerUsername === profile.username) return; // Can't vote on own comment

            // Rate limiting check
            const rateCheck = checkRateLimit('vote');
            if (!rateCheck.allowed) {
                showToast(rateCheck.message, 'warning');
                return;
            }
            recordAction('vote');

            const currentVote = myCommentVotes[commentId] || 0;

            if (currentVote === voteType) {
                // Remove vote if clicking same button
                await supabase
                    .from('sloppygram_comment_votes')
                    .delete()
                    .eq('comment_id', commentId)
                    .eq('user_id', currentUser.id);

                myCommentVotes[commentId] = 0;
                commentVotes[commentId] = (commentVotes[commentId] || 0) - voteType;
            } else {
                // Remove existing vote first
                if (currentVote !== 0) {
                    await supabase
                        .from('sloppygram_comment_votes')
                        .delete()
                        .eq('comment_id', commentId)
                        .eq('user_id', currentUser.id);
                    commentVotes[commentId] = (commentVotes[commentId] || 0) - currentVote;
                }

                // Add new vote
                await supabase
                    .from('sloppygram_comment_votes')
                    .insert({
                        comment_id: commentId,
                        voter_username: profile.username,
                        vote_type: voteType,
                        user_id: currentUser.id
                    });

                myCommentVotes[commentId] = voteType;
                commentVotes[commentId] = (commentVotes[commentId] || 0) + voteType;
            }

            // Log AI event for comment vote
            logAiEvent('vote_cast', 'comment', commentId, {
                vote_type: myCommentVotes[commentId] || 0,
                net_score: commentVotes[commentId] || 0
            });

            // Update UI - re-render posts to reflect vote changes
            renderPosts();
        };

        async function loadDoodleLeaderboard() {
            const container = document.getElementById('doodlesContainer');
            const emptyState = document.getElementById('doodlesEmptyState');

            // Batch queries in parallel
            const [doodlesResult, votesResult, commentsResult] = await Promise.all([
                supabase
                    .from('sloppygram_messages')
                    .select('id, username, avatar, avatar_url, content, drawing_data, message_type, created_at')
                    .not('drawing_data', 'is', null)
                    .order('created_at', { ascending: false }),
                supabase
                    .from('sloppygram_doodle_votes')
                    .select('message_id, vote_type'),
                supabase
                    .from('sloppygram_doodle_comments')
                    .select('doodle_id, username, avatar, content, parent_comment_id, created_at')
                    .order('created_at', { ascending: true })
            ]);

            const doodles = doodlesResult.data;
            const error = doodlesResult.error;

            // Process comments into lookup by doodle_id
            doodleComments = {};
            doodleCommentThreads = {};
            (commentsResult.data || []).forEach(c => {
                if (!doodleComments[c.doodle_id]) doodleComments[c.doodle_id] = [];
                doodleComments[c.doodle_id].push(c);
                if (c.parent_comment_id) {
                    doodleCommentThreads[c.id] = c.parent_comment_id;
                }
            });

            if (error || !doodles || doodles.length === 0) {
                if (emptyState) emptyState.style.display = 'block';
                return;
            }

            // Count net votes
            const voteCounts = {};
            (votesResult.data || []).forEach(v => {
                voteCounts[v.message_id] = (voteCounts[v.message_id] || 0) + (v.vote_type || 1);
            });

            // Sort by votes (descending), then by date
            const sortedDoodles = doodles
                .map(d => ({ ...d, votes: voteCounts[d.id] || 0 }))
                .sort((a, b) => b.votes - a.votes || new Date(b.created_at) - new Date(a.created_at));

            // Render leaderboard
            container.innerHTML = '<div class="leaderboard-header">ðŸ† LEGENDARY DOODLES ðŸ†</div>';

            if (sortedDoodles.length === 0) {
                container.innerHTML += `<div class="empty-doodles" id="doodlesEmptyState">
                    <div class="icon">ðŸŽ¨</div>
                    <p>NO LEGENDARY DOODLES YET...</p>
                    <p>Draw something and get votes!</p>
                </div>`;
                return;
            }

            // Create grid container
            const grid = document.createElement('div');
            grid.className = 'doodle-grid';

            sortedDoodles.forEach((doodle, index) => {
                const rank = index + 1;
                let rankClass = '';
                if (rank === 1) rankClass = 'gold';
                else if (rank === 2) rankClass = 'silver';
                else if (rank === 3) rankClass = 'bronze';

                const time = new Date(doodle.created_at).toLocaleDateString();
                const myVote = myDoodleVotes[doodle.id] || 0;
                // Check ownership by user_id first (reliable), fallback to username
                var currentUserId = (currentUser && currentUser.id) ? currentUser.id : null;
                const isOwnDoodle = (currentUserId && doodle.user_id === currentUserId) || doodle.username === profile.username;
                const scoreClass = doodle.votes > 0 ? 'positive' : doodle.votes < 0 ? 'negative' : 'neutral';
                const isTop3 = rank <= 3;
                const safeDrawingData = sanitizeUrl(doodle.drawing_data);
                const comments = doodleComments[doodle.id] || [];

                const safeDoodleId = escapeAttr(String(doodle.id));
                const safeDoodleUser = escapeAttr(doodle.username || 'Anonymous');
                const deleteBtn = isOwnDoodle ? `<button class="msg-delete-btn" onclick="deleteMessage('${safeDoodleId}')" title="Delete doodle">delete</button>` : '';

                // Render threaded comments for this doodle
                const commentsHtml = renderDoodleComments(comments, doodle.id);

                // Reply indicator
                const replyIndicatorHtml = (replyingToDoodle && replyingToDoodle.doodleId === doodle.id)
                    ? `<div class="reply-indicator">
                        <span>â†© Replying to <strong>${escapeHtml(replyingToDoodle.username)}</strong></span>
                        <button class="cancel-reply" onclick="cancelDoodleReply()">âœ•</button>
                    </div>`
                    : '';

                const card = document.createElement('div');
                card.className = `doodle-card${isTop3 ? ' top-3' : ''}`;
                card.innerHTML = `
                    <div class="doodle-rank">
                        <span class="rank-badge ${rankClass}">${rank}</span>
                        <span class="doodle-artist username-clickable" onclick="showProfileCard('${safeDoodleUser}', event)">${escapeHtml(doodle.username || 'Anonymous')}</span>
                        <span class="doodle-votes ${scoreClass}">${doodle.votes > 0 ? '+' : ''}${doodle.votes}</span>
                        ${deleteBtn}
                    </div>
                    <div class="doodle-thumbnail">
                        <img loading="lazy" src="${safeDrawingData}" onclick="openLightbox(this.src)" width="300" height="225" style="width:100%;height:auto;object-fit:contain;">
                    </div>
                    <div class="doodle-card-actions">
                        <span class="doodle-time">${time}</span>
                        <button class="post-action-btn" onclick="focusDoodleComment('${safeDoodleId}')">
                            ðŸ’¬ ${comments.length}
                        </button>
                        <div class="vote-controls" data-doodle-id="${safeDoodleId}">
                            <button class="vote-btn upvote ${myVote === 1 ? 'active' : ''} ${isOwnDoodle ? 'disabled' : ''}"
                                onclick="${isOwnDoodle ? '' : `voteDoodle('${safeDoodleId}', 1, '${safeDoodleUser}')`}"
                                title="${isOwnDoodle ? 'Cannot vote on own doodle' : 'Upvote'}">â–²</button>
                            <span class="vote-score ${scoreClass}">${doodle.votes}</span>
                            <button class="vote-btn downvote ${myVote === -1 ? 'active' : ''} ${isOwnDoodle ? 'disabled' : ''}"
                                onclick="${isOwnDoodle ? '' : `voteDoodle('${safeDoodleId}', -1, '${safeDoodleUser}')`}"
                                title="${isOwnDoodle ? 'Cannot vote on own doodle' : 'Downvote'}">â–¼</button>
                        </div>
                    </div>
                    <div class="post-comments doodle-comments" id="doodle-comments-${safeDoodleId}">
                        ${commentsHtml}
                    </div>
                    ${replyIndicatorHtml}
                    <div class="comment-input-row">
                        <input class="comment-input" id="doodle-comment-input-${safeDoodleId}" placeholder="${replyingToDoodle && replyingToDoodle.doodleId === doodle.id ? 'Write a reply...' : 'Add a comment...'}" onkeydown="if(event.key==='Enter')addDoodleComment('${safeDoodleId}')">
                        <button class="comment-send" onclick="addDoodleComment('${safeDoodleId}')">POST</button>
                    </div>
                `;
                grid.appendChild(card);
            });

            container.appendChild(grid);
        }

        // Render threaded comments for doodles
        function renderDoodleComments(comments, doodleId) {
            const threads = {};
            const rootComments = [];

            comments.forEach(c => {
                const parentId = doodleCommentThreads[c.id];
                if (parentId) {
                    if (!threads[parentId]) threads[parentId] = [];
                    threads[parentId].push(c);
                } else {
                    rootComments.push(c);
                }
            });

            function renderComment(c, depth = 0) {
                const time = c.created_at ? new Date(c.created_at).toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'}) : '';
                const replies = threads[c.id] || [];
                const isNested = depth > 0;

                const safeUsername = escapeAttr(c.username || 'Anonymous');
                const safeCommentId = escapeAttr(String(c.id));
                const safeDoodleIdStr = escapeAttr(String(doodleId));
                return `
                    <div class="comment ${isNested ? 'comment-thread' : ''}" data-comment-id="${safeCommentId}" data-depth="${depth}">
                        <span class="comment-avatar">${c.avatar || 'ðŸ‘¤'}</span>
                        <div class="comment-content">
                            <span class="comment-username username-clickable" onclick="showProfileCard('${safeUsername}', event)">${escapeHtml(c.username)}</span>
                            <span class="comment-time">${time}</span>
                            <div class="comment-text">${escapeHtml(c.content)}</div>
                            <div class="comment-actions">
                                <button class="comment-reply-btn" onclick="startDoodleReply('${safeDoodleIdStr}', ${c.id}, '${safeUsername}')">â†© reply</button>
                            </div>
                        </div>
                        ${replies.length > 0 ? `<div class="comment-replies">${replies.map(r => renderComment(r, depth + 1)).join('')}</div>` : ''}
                    </div>
                `;
            }

            return rootComments.map(c => renderComment(c, 0)).join('');
        }

        window.focusDoodleComment = function(doodleId) {
            const input = document.getElementById(`doodle-comment-input-${doodleId}`);
            if (input) {
                input.scrollIntoView({ behavior: 'smooth', block: 'center' });
                input.focus();
            }
        };

        window.startDoodleReply = function(doodleId, commentId, username) {
            replyingToDoodle = { doodleId, commentId, username };
            loadDoodleLeaderboard();
            setTimeout(() => {
                const input = document.getElementById(`doodle-comment-input-${doodleId}`);
                if (input) input.focus();
            }, 50);
        };

        window.cancelDoodleReply = function() {
            replyingToDoodle = null;
            loadDoodleLeaderboard();
        };

        window.addDoodleComment = async function(doodleId) {
            if (!currentUser) return;

            const input = document.getElementById('doodle-comment-input-' + doodleId);
            var rawContent = (input && input.value) ? input.value.trim() : '';
            if (!rawContent) return;

            // Sanitize content before storage (defense-in-depth)
            var content = sanitizeForStorage(rawContent);
            if (!content) return;

            // Rate limit check
            const rateCheck = checkRateLimit('comment');
            if (!rateCheck.allowed) {
                showToast(rateCheck.message || 'Too many comments! Slow down.', 'warning');
                return;
            }
            recordAction('comment');

            const commentData = {
                doodle_id: doodleId,
                username: profile.username,
                avatar: profile.avatar,
                content: content,
                user_id: currentUser.id
            };

            // If replying to a comment, add parent reference
            if (replyingToDoodle && replyingToDoodle.doodleId === doodleId && replyingToDoodle.commentId) {
                commentData.parent_comment_id = replyingToDoodle.commentId;
            }

            const { data, error } = await supabase
                .from('sloppygram_doodle_comments')
                .insert(commentData)
                .select()
                .single();

            if (error) {
                console.error('Error adding doodle comment:', error);
                showToast('Failed to add comment', 'error');
                return;
            }

            // Add to local state
            if (!doodleComments[doodleId]) doodleComments[doodleId] = [];
            doodleComments[doodleId].push(data);
            if (replyingToDoodle && replyingToDoodle.commentId) {
                doodleCommentThreads[data.id] = replyingToDoodle.commentId;
            }

            input.value = '';
            replyingToDoodle = null;
            loadDoodleLeaderboard();
        };

        // Mobile sidebar toggle
        // === MOBILE MENU LOGIC ===
        window.toggleSidebar = function(side) {
            var sidebarLeft = document.getElementById('sidebarLeft');
            var sidebarRight = document.getElementById('sidebarRight');
            var backdrop = document.getElementById('mobileBackdrop');
            var hamburgerBtn = document.getElementById('hamburgerBtn');

            // Guard against null elements
            if (!sidebarLeft || !sidebarRight) return;

            // Close the other sidebar first
            if (side === 'left') {
                sidebarRight.classList.remove('mobile-show');
                sidebarLeft.classList.toggle('mobile-show');
                // Toggle hamburger animation
                if (hamburgerBtn) {
                    hamburgerBtn.classList.toggle('active', sidebarLeft.classList.contains('mobile-show'));
                }
            } else {
                sidebarLeft.classList.remove('mobile-show');
                sidebarRight.classList.toggle('mobile-show');
                // Remove hamburger active state when opening right sidebar
                if (hamburgerBtn) hamburgerBtn.classList.remove('active');
            }

            // Show backdrop if any sidebar is open
            var isAnyOpen = sidebarLeft.classList.contains('mobile-show') || sidebarRight.classList.contains('mobile-show');
            if (backdrop) backdrop.classList.toggle('active', isAnyOpen);

            // Prevent body scroll when sidebar open
            document.body.style.overflow = isAnyOpen ? 'hidden' : '';
        };

        window.closeSidebars = function() {
            var sidebarLeft = document.getElementById('sidebarLeft');
            var sidebarRight = document.getElementById('sidebarRight');
            var backdrop = document.getElementById('mobileBackdrop');
            var hamburgerBtn = document.getElementById('hamburgerBtn');

            if (sidebarLeft) sidebarLeft.classList.remove('mobile-show');
            if (sidebarRight) sidebarRight.classList.remove('mobile-show');
            if (backdrop) backdrop.classList.remove('active');
            if (hamburgerBtn) hamburgerBtn.classList.remove('active');
            document.body.style.overflow = '';
        };

        // Toggle mobile dropdown menu
        window.toggleMobileMenu = function() {
            var mobileMenu = document.getElementById('mobileMenu');
            var hamburgerBtn = document.getElementById('hamburgerBtn');

            if (!mobileMenu) return;

            var isOpen = mobileMenu.classList.contains('active');

            if (isOpen) {
                // Close menu
                mobileMenu.classList.remove('active');
                if (hamburgerBtn) hamburgerBtn.classList.remove('active');
            } else {
                // Open menu - close sidebars first
                window.closeSidebars();
                mobileMenu.classList.add('active');
                if (hamburgerBtn) hamburgerBtn.classList.add('active');
            }
        };

        // Mobile help mode - tap to show tooltips
        var mobileHelpModeActive = false;
        var currentVisibleTooltip = null;

        window.toggleMobileHelpMode = function() {
            mobileHelpModeActive = !mobileHelpModeActive;

            var toggleBtn = document.getElementById('mobileHelpToggle');
            var banner = document.getElementById('helpModeBanner');

            if (mobileHelpModeActive) {
                document.body.classList.add('help-mode-active');
                if (toggleBtn) toggleBtn.classList.add('active');
                if (banner) banner.classList.add('visible');

                // Add click listeners to all tooltip wraps
                document.querySelectorAll('.tooltip-wrap').forEach(function(wrap) {
                    wrap.addEventListener('click', handleTooltipTap);
                });
            } else {
                document.body.classList.remove('help-mode-active');
                if (toggleBtn) toggleBtn.classList.remove('active');
                if (banner) banner.classList.remove('visible');

                // Remove visible class from all tooltips
                document.querySelectorAll('.tooltip-wrap').forEach(function(wrap) {
                    wrap.classList.remove('tooltip-visible');
                    wrap.removeEventListener('click', handleTooltipTap);
                });
                currentVisibleTooltip = null;
            }

            // Close mobile menu after toggle
            window.toggleMobileMenu();
        };

        function handleTooltipTap(e) {
            if (!mobileHelpModeActive) return;

            var wrap = e.currentTarget;

            // If clicking the same tooltip, hide it
            if (currentVisibleTooltip === wrap) {
                wrap.classList.remove('tooltip-visible');
                currentVisibleTooltip = null;
                return;
            }

            // Hide previous tooltip
            if (currentVisibleTooltip) {
                currentVisibleTooltip.classList.remove('tooltip-visible');
            }

            // Show this tooltip
            wrap.classList.add('tooltip-visible');
            currentVisibleTooltip = wrap;

            // Don't prevent the click from triggering the button action
            // User can see the tooltip AND the action happens
        }

        // Close mobile menu when clicking outside
        document.addEventListener('click', function(e) {
            var mobileMenu = document.getElementById('mobileMenu');
            var hamburgerBtn = document.getElementById('hamburgerBtn');

            if (!mobileMenu || !mobileMenu.classList.contains('active')) return;

            // Check if click is outside menu and hamburger
            if (!mobileMenu.contains(e.target) && (!hamburgerBtn || !hamburgerBtn.contains(e.target))) {
                mobileMenu.classList.remove('active');
                if (hamburgerBtn) hamburgerBtn.classList.remove('active');
            }
        });

        // Close sidebars and mobile menu on escape key
        document.addEventListener('keydown', function(e) {
            if (e.key === 'Escape') {
                window.closeSidebars();
                // Also close mobile menu
                var mobileMenu = document.getElementById('mobileMenu');
                var hamburgerBtn = document.getElementById('hamburgerBtn');
                if (mobileMenu) mobileMenu.classList.remove('active');
                if (hamburgerBtn) hamburgerBtn.classList.remove('active');
            }
        });

        // === COLLABORATIVE CANVAS ===
        let collabCanvas, collabCtx, collabWrapper;
        let collabChannel = null;
        let collabColor = '#ff00ff';
        let collabIsEraser = false;
        const COLLAB_ERASER_COLOR = '#0a0a0a';
        let collabDrawing = false;
        let collabLastX = 0, collabLastY = 0;
        let collabInitialized = false;
        let collabUsers = new Map(); // Track other users' cursors
        const COLLAB_THROTTLE = 16; // ~60fps
        let lastCollabBroadcast = 0;

        // Stroke history for selective clearing
        let collabStrokes = []; // Array of {x1, y1, x2, y2, color, username}
        const COLLAB_MAX_STROKES = 10000; // Limit history size

        // Database persistence
        let collabStrokeBatch = []; // Batch queue for saving
        const COLLAB_BATCH_SIZE = 10; // Save every N strokes
        const COLLAB_BATCH_DELAY = 1000; // Or after 1 second
        let collabBatchTimeout = null;

        // Zoom/pan state
        let collabZoom = 1;
        const COLLAB_ZOOM_MIN = 0.25;
        const COLLAB_ZOOM_MAX = 4;
        const COLLAB_ZOOM_STEP = 0.25;

        async function initCollabCanvas() {
            if (collabInitialized) return;
            collabInitialized = true;

            collabCanvas = document.getElementById('collabCanvas');
            collabCtx = collabCanvas.getContext('2d');
            collabWrapper = document.getElementById('collabCanvasWrapper');

            // Fill with dark background
            collabCtx.fillStyle = '#0a0a0a';
            collabCtx.fillRect(0, 0, collabCanvas.width, collabCanvas.height);
            collabCtx.lineCap = 'round';
            collabCtx.lineJoin = 'round';
            collabCtx.lineWidth = 3;

            // Mouse events
            collabCanvas.addEventListener('mousedown', collabMouseDown);
            collabCanvas.addEventListener('mousemove', collabMouseMove);
            collabCanvas.addEventListener('mouseup', collabStopDraw);
            collabCanvas.addEventListener('mouseleave', collabStopDraw);

            // Touch events (2 fingers = pan, 1 finger = draw)
            collabCanvas.addEventListener('touchstart', collabTouchStart, { passive: false });
            collabCanvas.addEventListener('touchmove', collabTouchMove, { passive: false });
            collabCanvas.addEventListener('touchend', collabStopDraw);

            // Wheel zoom
            collabWrapper.addEventListener('wheel', collabWheelZoom, { passive: false });

            // Setup realtime channel
            setupCollabChannel();

            // Apply initial zoom
            updateCollabZoom();

            // Load existing strokes from database
            await loadCollabStrokes();
        }

        // Load persisted strokes from database
        async function loadCollabStrokes() {
            try {
                const { data, error } = await supabase
                    .from('sloppygram_collab_strokes')
                    .select('start_x, start_y, end_x, end_y, color, username')
                    .order('created_at', { ascending: true })
                    .limit(COLLAB_MAX_STROKES);

                if (error) {
                    console.error('Error loading collab strokes:', error);
                    return;
                }

                if (data && data.length > 0) {
                    // Convert DB format to local format
                    collabStrokes = data.map(s => ({
                        x1: s.start_x,
                        y1: s.start_y,
                        x2: s.end_x,
                        y2: s.end_y,
                        color: s.color,
                        username: s.username
                    }));

                    // Redraw all strokes
                    redrawCollabCanvas();
                    console.log(`Loaded ${data.length} strokes from database`);
                }
            } catch (err) {
                console.error('Failed to load collab strokes:', err);
            }
        }

        function getCollabCoords(clientX, clientY) {
            const rect = collabCanvas.getBoundingClientRect();
            // Account for zoom: rect size changes with CSS transform
            // Canvas internal size stays constant, so we need to map display coords to canvas coords
            const x = (clientX - rect.left) * (collabCanvas.width / rect.width);
            const y = (clientY - rect.top) * (collabCanvas.height / rect.height);
            return { x, y };
        }

        function collabMouseDown(e) {
            e.preventDefault();
            const coords = getCollabCoords(e.clientX, e.clientY);
            collabStartDraw(coords.x, coords.y);
        }

        function collabMouseMove(e) {
            const coords = getCollabCoords(e.clientX, e.clientY);
            collabDraw(coords.x, coords.y);
        }

        function collabTouchStart(e) {
            e.preventDefault();
            if (e.touches.length === 1) {
                const touch = e.touches[0];
                const coords = getCollabCoords(touch.clientX, touch.clientY);
                collabStartDraw(coords.x, coords.y);
            }
        }

        function collabTouchMove(e) {
            e.preventDefault();
            if (e.touches.length === 1) {
                const touch = e.touches[0];
                const coords = getCollabCoords(touch.clientX, touch.clientY);
                collabDraw(coords.x, coords.y);
            }
        }

        function collabStartDraw(x, y) {
            collabDrawing = true;
            collabLastX = x;
            collabLastY = y;
            collabCtx.beginPath();
            collabCtx.moveTo(x, y);
        }

        function collabDraw(x, y) {
            // Broadcast cursor position (throttled)
            const now = Date.now();
            if (now - lastCollabBroadcast > COLLAB_THROTTLE) {
                lastCollabBroadcast = now;
                broadcastCollabCursor(x, y);
            }

            if (!collabDrawing) return;

            // Draw locally - eraser has wider line
            collabCtx.strokeStyle = collabColor;
            collabCtx.lineWidth = collabIsEraser ? 20 : 3;
            collabCtx.lineTo(x, y);
            collabCtx.stroke();
            collabCtx.beginPath();
            collabCtx.moveTo(x, y);

            // Store stroke in history
            const stroke = { x1: collabLastX, y1: collabLastY, x2: x, y2: y, color: collabColor, username: profile.username };
            collabStrokes.push(stroke);
            if (collabStrokes.length > COLLAB_MAX_STROKES) {
                collabStrokes.shift(); // Remove oldest
            }

            // Queue stroke for database persistence
            queueCollabStroke(stroke);

            // Broadcast stroke
            broadcastCollabStroke(collabLastX, collabLastY, x, y, collabColor);

            collabLastX = x;
            collabLastY = y;
        }

        function collabStopDraw() {
            collabDrawing = false;
            // Flush any pending strokes when user stops drawing
            flushCollabStrokes();
        }

        // Batch save strokes to database
        function queueCollabStroke(stroke) {
            collabStrokeBatch.push(stroke);

            // Clear existing timeout
            if (collabBatchTimeout) {
                clearTimeout(collabBatchTimeout);
            }

            // Save immediately if batch is full, otherwise wait
            if (collabStrokeBatch.length >= COLLAB_BATCH_SIZE) {
                flushCollabStrokes();
            } else {
                collabBatchTimeout = setTimeout(flushCollabStrokes, COLLAB_BATCH_DELAY);
            }
        }

        async function flushCollabStrokes() {
            if (collabStrokeBatch.length === 0) return;

            const batch = collabStrokeBatch.slice();
            collabStrokeBatch = [];

            if (collabBatchTimeout) {
                clearTimeout(collabBatchTimeout);
                collabBatchTimeout = null;
            }

            try {
                const rows = batch.map(s => ({
                    start_x: Math.round(s.x1),
                    start_y: Math.round(s.y1),
                    end_x: Math.round(s.x2),
                    end_y: Math.round(s.y2),
                    color: s.color,
                    username: s.username,
                    user_id: (currentUser && currentUser.id) ? currentUser.id : null
                }));

                const { error } = await supabase
                    .from('sloppygram_collab_strokes')
                    .insert(rows);

                if (error) {
                    console.error('Error saving strokes:', error);
                }
            } catch (err) {
                console.error('Failed to save strokes:', err);
            }
        }

        // Zoom functions
        function collabWheelZoom(e) {
            e.preventDefault();
            const delta = e.deltaY > 0 ? -COLLAB_ZOOM_STEP : COLLAB_ZOOM_STEP;
            setCollabZoom(collabZoom + delta);
        }

        function setCollabZoom(newZoom) {
            collabZoom = Math.max(COLLAB_ZOOM_MIN, Math.min(COLLAB_ZOOM_MAX, newZoom));
            updateCollabZoom();
        }

        function updateCollabZoom() {
            if (collabCanvas && collabCanvas.style) {
                collabCanvas.style.transform = 'scale(' + collabZoom + ')';
            }
            var zoomLevel = document.getElementById('collabZoomLevel');
            if (zoomLevel) zoomLevel.textContent = Math.round(collabZoom * 100);

            // Update cursor overlay to match zoom
            var cursors = document.getElementById('collabCursors');
            if (cursors && cursors.style) {
                cursors.style.transform = 'scale(' + collabZoom + ')';
                cursors.style.transformOrigin = '0 0';
            }
        }

        window.collabZoomIn = function() {
            setCollabZoom(collabZoom + COLLAB_ZOOM_STEP);
        };

        window.collabZoomOut = function() {
            setCollabZoom(collabZoom - COLLAB_ZOOM_STEP);
        };

        window.collabZoomReset = function() {
            setCollabZoom(1);
            // Reset scroll position
            if (collabWrapper) {
                collabWrapper.scrollLeft = 0;
                collabWrapper.scrollTop = 0;
            }
        };

        // === STRESS TEST BOT ===
        // Tiny autonomous bot that draws random neon shapes on the canvas
        var stressBotInterval = null;
        var stressBotActive = false;
        var STRESS_BOT_COLORS = ['#00ff41', '#ff00ff', '#00ffff', '#ffff00', '#ff4444', '#ff8800', '#8844ff', '#44ff88'];

        window.startStressBot = function(speed) {
            if (stressBotActive) {
                showToast('Stress bot already running! Use stopStressBot() to stop.', 'warning');
                return;
            }
            if (!collabCanvas || !collabCtx) {
                showToast('Canvas not ready - switch to Collab tab first', 'error');
                return;
            }

            var interval = speed || 150; // ms between draws
            stressBotActive = true;
            showToast('ðŸ¤– Stress bot activated! Drawing at ' + interval + 'ms intervals', 'success');
            console.log('[STRESS BOT] Started - interval: ' + interval + 'ms');

            // Register with memory management registry
            var stressBotCallback = function() {
                if (!collabCanvas || !collabCtx) {
                    window.stopStressBot();
                    return;
                }

                var shapeType = Math.floor(Math.random() * 4); // 0=line, 1=circle, 2=rect, 3=zigzag
                var color = STRESS_BOT_COLORS[Math.floor(Math.random() * STRESS_BOT_COLORS.length)];
                var x1 = Math.random() * collabCanvas.width;
                var y1 = Math.random() * collabCanvas.height;
                var x2 = Math.random() * collabCanvas.width;
                var y2 = Math.random() * collabCanvas.height;

                collabCtx.strokeStyle = color;
                collabCtx.fillStyle = color;
                collabCtx.lineWidth = Math.random() * 4 + 1;
                collabCtx.shadowColor = color;
                collabCtx.shadowBlur = 8;

                collabCtx.beginPath();

                if (shapeType === 0) {
                    // Neon line
                    collabCtx.moveTo(x1, y1);
                    collabCtx.lineTo(x2, y2);
                    collabCtx.stroke();
                } else if (shapeType === 1) {
                    // Neon circle
                    var radius = Math.random() * 30 + 5;
                    collabCtx.arc(x1, y1, radius, 0, Math.PI * 2);
                    if (Math.random() > 0.5) collabCtx.stroke();
                    else collabCtx.fill();
                } else if (shapeType === 2) {
                    // Neon rectangle
                    var w = Math.random() * 60 + 10;
                    var h = Math.random() * 60 + 10;
                    if (Math.random() > 0.5) collabCtx.strokeRect(x1, y1, w, h);
                    else collabCtx.fillRect(x1, y1, w, h);
                } else {
                    // Zigzag line
                    collabCtx.moveTo(x1, y1);
                    var steps = Math.floor(Math.random() * 5) + 3;
                    for (var i = 0; i < steps; i++) {
                        var nx = x1 + (x2 - x1) * (i + 1) / steps;
                        var ny = y1 + (y2 - y1) * (i + 1) / steps + (Math.random() - 0.5) * 40;
                        collabCtx.lineTo(nx, ny);
                    }
                    collabCtx.stroke();
                }

                collabCtx.shadowBlur = 0;

                // Broadcast to other users (simulate real drawing)
                if (collabChannel) {
                    collabChannel.send({
                        type: 'broadcast',
                        event: 'stroke',
                        payload: {
                            startX: x1, startY: y1, endX: x2, endY: y2,
                            color: color, username: 'ðŸ¤– StressBot'
                        }
                    });
                }
            };
            // Use dynamic interval with registry
            if (activeIntervals.has('stress-bot')) {
                clearInterval(activeIntervals.get('stress-bot'));
            }
            var id = setInterval(stressBotCallback, interval);
            activeIntervals.set('stress-bot', id);
        };

        window.stopStressBot = function() {
            clearRegisteredInterval('stress-bot');
            stressBotActive = false;
            showToast('ðŸ¤– Stress bot stopped', 'info');
            console.log('[STRESS BOT] Stopped');
        };

        window.stressBotStatus = function() {
            console.log('[STRESS BOT] Active:', stressBotActive);
            return stressBotActive;
        };

        function setupCollabChannel() {
            if (collabChannel) return;

            collabChannel = supabase.channel('sloppygram-collab-canvas', {
                config: { broadcast: { self: false } }
            });

            // Listen for strokes from other users
            collabChannel.on('broadcast', { event: 'stroke' }, ({ payload }) => {
                drawRemoteStroke(payload);
            });

            // Listen for cursor positions
            collabChannel.on('broadcast', { event: 'cursor' }, ({ payload }) => {
                updateRemoteCursor(payload);
            });

            // Listen for clear_user events (remove specific user's strokes)
            collabChannel.on('broadcast', { event: 'clear_user' }, ({ payload }) => {
                collabStrokes = collabStrokes.filter(s => s.username !== payload.username);
                redrawCollabCanvas();
            });

            // Listen for clear_all events (wipe entire canvas)
            collabChannel.on('broadcast', { event: 'clear_all' }, () => {
                collabStrokes = [];
                collabCtx.fillStyle = '#0a0a0a';
                collabCtx.fillRect(0, 0, collabCanvas.width, collabCanvas.height);
            });

            // Track presence
            collabChannel.on('presence', { event: 'sync' }, () => {
                const state = collabChannel.presenceState();
                const count = Object.keys(state).length;
                document.getElementById('collabUserCount').textContent = count;
            });

            collabChannel.on('presence', { event: 'leave' }, ({ key }) => {
                // Remove cursor when user leaves
                const cursor = document.getElementById('cursor-' + key);
                if (cursor) cursor.remove();
                collabUsers.delete(key);
            });

            collabChannel.subscribe(async (status) => {
                if (status === 'SUBSCRIBED') {
                    await collabChannel.track({
                        username: profile.username,
                        avatar: profile.avatar,
                        color: collabColor
                    });
                }
            });
        }

        function broadcastCollabStroke(x1, y1, x2, y2, color) {
            if (!collabChannel) return;
            collabChannel.send({
                type: 'broadcast',
                event: 'stroke',
                payload: {
                    x1, y1, x2, y2, color,
                    username: profile.username,
                    avatar: profile.avatar
                }
            });
        }

        function broadcastCollabCursor(x, y) {
            if (!collabChannel) return;
            collabChannel.send({
                type: 'broadcast',
                event: 'cursor',
                payload: {
                    x, y,
                    username: profile.username,
                    avatar: profile.avatar,
                    color: collabColor
                }
            });
        }

        function drawRemoteStroke(payload) {
            const { x1, y1, x2, y2, color, username } = payload;

            // Store in history
            collabStrokes.push({ x1, y1, x2, y2, color, username });
            if (collabStrokes.length > COLLAB_MAX_STROKES) {
                collabStrokes.shift();
            }

            // Draw - eraser strokes are wider
            const isEraser = color === COLLAB_ERASER_COLOR;
            collabCtx.save();
            collabCtx.strokeStyle = color;
            collabCtx.lineWidth = isEraser ? 20 : 3;
            collabCtx.lineCap = 'round';
            collabCtx.beginPath();
            collabCtx.moveTo(x1, y1);
            collabCtx.lineTo(x2, y2);
            collabCtx.stroke();
            collabCtx.restore();
        }

        function updateRemoteCursor(payload) {
            const { x, y, username, avatar, color } = payload;
            const cursorId = 'cursor-' + username;
            let cursor = document.getElementById(cursorId);

            if (!cursor) {
                cursor = document.createElement('div');
                cursor.id = cursorId;
                cursor.className = 'collab-cursor';
                cursor.innerHTML = `
                    <div class="collab-cursor-dot" style="background:${color};color:${color}"></div>
                    <div class="collab-cursor-name">${avatar} ${username}</div>
                `;
                document.getElementById('collabCursors').appendChild(cursor);
            }

            // Position in canvas coordinates (cursors container is scaled with CSS transform)
            cursor.style.left = x + 'px';
            cursor.style.top = y + 'px';
            cursor.querySelector('.collab-cursor-dot').style.background = color;
            cursor.querySelector('.collab-cursor-dot').style.color = color;

            // Update color if changed
            collabUsers.set(username, { x, y, color, avatar });
        }

        window.setCollabColor = function(color) {
            collabColor = color;
            collabIsEraser = (color === COLLAB_ERASER_COLOR);
            document.querySelectorAll('.collab-color-btn').forEach(btn => {
                btn.classList.toggle('active', btn.dataset.color === color);
            });
            // Update presence with new color
            if (collabChannel) {
                collabChannel.track({
                    username: profile.username,
                    avatar: profile.avatar,
                    color: collabColor
                });
            }
        };

        // Redraw all strokes from history
        function redrawCollabCanvas() {
            if (!collabCtx) return;
            // Clear canvas
            collabCtx.fillStyle = '#0a0a0a';
            collabCtx.fillRect(0, 0, collabCanvas.width, collabCanvas.height);

            // Redraw all strokes
            collabCtx.save();
            collabCtx.lineCap = 'round';
            collabStrokes.forEach(stroke => {
                // Eraser strokes are wider
                const isEraser = stroke.color === COLLAB_ERASER_COLOR;
                collabCtx.lineWidth = isEraser ? 20 : 3;
                collabCtx.strokeStyle = stroke.color;
                collabCtx.beginPath();
                collabCtx.moveTo(stroke.x1, stroke.y1);
                collabCtx.lineTo(stroke.x2, stroke.y2);
                collabCtx.stroke();
            });
            collabCtx.restore();
        }

        // Clear only the current user's strokes
        window.clearCollabCanvas = async function() {
            if (!collabCtx) return;
            const myUsername = profile.username;

            // Remove user's strokes from history
            collabStrokes = collabStrokes.filter(s => s.username !== myUsername);

            // Redraw canvas with remaining strokes
            redrawCollabCanvas();

            // Delete user's strokes from database
            try {
                var currentUserId = (currentUser && currentUser.id) ? currentUser.id : null;
                const { error } = await supabase
                    .from('sloppygram_collab_strokes')
                    .delete()
                    .eq('user_id', currentUserId);

                if (error) {
                    console.error('Error deleting strokes from DB:', error);
                }
            } catch (err) {
                console.error('Failed to delete strokes:', err);
            }

            // Broadcast clear_user to others so they remove this user's strokes
            if (collabChannel) {
                collabChannel.send({
                    type: 'broadcast',
                    event: 'clear_user',
                    payload: { username: myUsername }
                });
            }
        };

        // Clear entire canvas (all users) - admin function
        window.clearCollabCanvasAll = async function() {
            if (!collabCtx) return;
            collabStrokes = [];
            collabCtx.fillStyle = '#0a0a0a';
            collabCtx.fillRect(0, 0, collabCanvas.width, collabCanvas.height);

            // Note: Can't delete all strokes due to RLS - only own strokes
            // This just clears visually and broadcasts

            if (collabChannel) {
                collabChannel.send({
                    type: 'broadcast',
                    event: 'clear_all',
                    payload: { username: profile.username }
                });
            }
        };

        // Snapshot collab canvas and post to main feed as a doodle
        window.snapshotCollabCanvas = async function() {
            if (!collabCanvas || !collabCtx) {
                showToast('Canvas not ready', 'error');
                return;
            }

            // Check rate limit (returns object with {allowed, waitTime, message})
            const rateCheck = checkRateLimit('drawing');
            if (!rateCheck.allowed) {
                showToast(rateCheck.message || 'Too many snapshots! Wait a moment.', 'warning');
                return;
            }
            recordAction('drawing');

            // Check if canvas has any strokes (prevent white/empty image)
            if (collabStrokes.length === 0) {
                showToast('Canvas is empty - draw something first!', 'warning');
                return;
            }

            try {
                // Ensure canvas has dark background before capture (fix white-image issue)
                // Create a temp canvas with proper background
                const tempCanvas = document.createElement('canvas');
                tempCanvas.width = collabCanvas.width;
                tempCanvas.height = collabCanvas.height;
                const tempCtx = tempCanvas.getContext('2d');

                // Fill with dark background first
                tempCtx.fillStyle = '#0a0a0a';
                tempCtx.fillRect(0, 0, tempCanvas.width, tempCanvas.height);

                // Draw the collab canvas on top
                tempCtx.drawImage(collabCanvas, 0, 0);

                // Get canvas data as PNG from temp canvas
                const dataUrl = tempCanvas.toDataURL('image/png');

                // Convert to blob for upload
                const blob = await (await fetch(dataUrl)).blob();

                // Use uploadToStorage helper (with fallback to base64)
                const storageUrl = await uploadToStorage(blob, 'collab_snapshots');
                if (!storageUrl) {
                    console.warn('Collab snapshot: Storage upload failed, falling back to base64');
                }
                const finalDrawingData = storageUrl || dataUrl;

                // Insert into messages table
                const { data, error } = await supabase
                    .from('sloppygram_messages')
                    .insert({
                        username: profile.username,
                        avatar: profile.avatar,
                        avatar_url: profile.avatarUrl || null,
                        content: 'ðŸ“¸ Collab Canvas Snapshot',
                        drawing_data: finalDrawingData,
                        message_type: 'drawing',
                        user_id: (currentUser && currentUser.id) ? currentUser.id : null
                    })
                    .select()
                    .single();

                if (error) {
                    console.error('Error saving snapshot:', error);
                    showToast('Failed to save snapshot', 'error');
                    return;
                }

                // Log AI event
                await supabase.from('ai_events').insert({
                    event_type: 'collab_snapshot',
                    entity_type: 'drawing',
                    entity_id: data.id,
                    username: profile.username,
                    metadata: { source: 'collab_canvas', stroke_count: collabStrokes.length },
                    user_id: (currentUser && currentUser.id) ? currentUser.id : null
                });

                // Show success and switch to doodles tab
                showToast('ðŸ“¸ Snapshot saved to doodles!', 'success');

                // Broadcast to realtime so others see it
                if (realtimeChannel) {
                    realtimeChannel.send({
                        type: 'broadcast',
                        event: 'new_message',
                        payload: { ...data, avatar_url: profile.avatarUrl }
                    });
                }

                // Switch to doodles view to show the snapshot
                switchView('doodles');

            } catch (err) {
                console.error('Snapshot failed:', err);
                showToast('Snapshot failed: ' + err.message, 'error');
            }
        };

        // === DIRECT MESSAGES SYSTEM ===
        let dmConversations = [];
        let currentDMConversation = null;
        let dmMessages = [];
        let dmSubscription = null;

        // Load user's DM conversations
        async function loadDMConversations() {
            if (!currentUser) {
                document.getElementById('dmConvList').innerHTML = `
                    <div class="dm-conv-empty">
                        <div class="dm-conv-empty-icon">ðŸ”’</div>
                        <p>Sign in to use DMs</p>
                    </div>
                `;
                return;
            }

            try {
                // Get conversations where user is sender or recipient
                const { data: sentConvs, error: err1 } = await supabase
                    .from('sloppygram_dm_conversations')
                    .select('id, sender_id, sender_username, recipient_id, recipient_username, last_message_at, last_message_preview, created_at')
                    .eq('sender_id', currentUser.id)
                    .order('last_message_at', { ascending: false });

                const { data: recvConvs, error: err2 } = await supabase
                    .from('sloppygram_dm_conversations')
                    .select('id, sender_id, sender_username, recipient_id, recipient_username, last_message_at, last_message_preview, created_at')
                    .eq('recipient_id', currentUser.id)
                    .order('last_message_at', { ascending: false });

                if (err1 || err2) throw err1 || err2;

                // Merge and dedupe conversations
                const allConvs = [...(sentConvs || []), ...(recvConvs || [])];
                const convMap = new Map();
                allConvs.forEach(c => {
                    const key = [c.sender_id, c.recipient_id].sort().join('-');
                    if (!convMap.has(key) || new Date(c.last_message_at) > new Date(convMap.get(key).last_message_at)) {
                        convMap.set(key, c);
                    }
                });
                dmConversations = Array.from(convMap.values())
                    .sort((a, b) => new Date(b.last_message_at || b.created_at) - new Date(a.last_message_at || a.created_at));

                renderDMConversations();
            } catch (err) {
                console.error('Failed to load DM conversations:', err);
                showToast('Failed to load messages', 'error');
            }
        }

        function renderDMConversations() {
            const container = document.getElementById('dmConvList');

            if (dmConversations.length === 0) {
                container.innerHTML = `
                    <div class="dm-conv-empty">
                        <div class="dm-conv-empty-icon">âœ‰ï¸</div>
                        <p>No conversations yet</p>
                        <p style="font-size:0.8rem;margin-top:8px;">Start a new chat!</p>
                    </div>
                `;
                return;
            }

            container.innerHTML = dmConversations.map(conv => {
                const otherUser = conv.sender_id === currentUser.id
                    ? { id: conv.recipient_id, username: conv.recipient_username }
                    : { id: conv.sender_id, username: conv.sender_username };

                const isActive = currentDMConversation && currentDMConversation.id === conv.id;
                const timeAgo = formatTimeAgo(conv.last_message_at || conv.created_at);

                return `
                    <div class="dm-conv-item ${isActive ? 'active' : ''}" onclick="openDMConversation('${conv.id}', '${otherUser.id}', '${escapeHtml(otherUser.username)}')">
                        <div class="dm-conv-user">
                            <span class="avatar">ðŸ‘¤</span>
                            <span>${escapeHtml(otherUser.username)}</span>
                        </div>
                        <div class="dm-conv-preview">${escapeHtml(conv.last_message_preview || 'No messages yet')}</div>
                        <div class="dm-conv-time">${timeAgo}</div>
                    </div>
                `;
            }).join('');
        }

        // Open a specific conversation
        window.openDMConversation = async function(convId, recipientId, recipientUsername) {
            currentDMConversation = { id: convId, recipientId, recipientUsername };

            // Update UI
            document.getElementById('dmThreadEmpty').style.display = 'none';
            document.getElementById('dmThreadHeader').style.display = 'flex';
            document.getElementById('dmThreadMessages').style.display = 'flex';
            document.getElementById('dmThreadInput').style.display = 'flex';

            // Update header
            document.getElementById('dmThreadUser').innerHTML = `
                <span class="avatar">ðŸ‘¤</span>
                <span class="username">${escapeHtml(recipientUsername)}</span>
            `;

            // Mobile: show thread, hide conversations
            if (window.innerWidth <= 768) {
                document.getElementById('dmConversations').classList.add('hidden-mobile');
                document.getElementById('dmThread').classList.add('active-mobile');
            }

            // Re-render conversations to show active state
            renderDMConversations();

            // Load messages
            await loadDMMessages(convId);

            // Subscribe to new messages
            subscribeToDMMessages(convId);
        };

        // Load messages for a conversation
        async function loadDMMessages(convId) {
            try {
                const { data, error } = await supabase
                    .from('sloppygram_dm_messages')
                    .select('id, conversation_id, sender_id, sender_username, recipient_id, content, image_data, read_at, created_at')
                    .eq('conversation_id', convId)
                    .order('created_at', { ascending: true });

                if (error) throw error;

                dmMessages = data || [];
                renderDMMessages();
            } catch (err) {
                console.error('Failed to load DM messages:', err);
            }
        }

        function renderDMMessages() {
            const container = document.getElementById('dmThreadMessages');

            if (dmMessages.length === 0) {
                container.innerHTML = '<div style="text-align:center;color:var(--text-dim);padding:40px;">Start the conversation!</div>';
                return;
            }

            container.innerHTML = dmMessages.map(msg => {
                const isSent = msg.sender_id === currentUser.id;
                const time = new Date(msg.created_at).toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });

                return `
                    <div class="dm-message ${isSent ? 'sent' : 'received'}">
                        <div class="dm-message-content">${escapeHtml(msg.content)}</div>
                        ${msg.image_data ? `<img src="${msg.image_data}" class="dm-message-image" alt="Image">` : ''}
                        <div class="dm-message-time">${time}</div>
                    </div>
                `;
            }).join('');

            // Scroll to bottom
            container.scrollTop = container.scrollHeight;
        }

        // Subscribe to real-time messages
        function subscribeToDMMessages(convId) {
            if (dmSubscription) {
                dmSubscription.unsubscribe();
            }

            dmSubscription = supabase
                .channel('dm-messages-' + convId)
                .on('postgres_changes', {
                    event: 'INSERT',
                    schema: 'public',
                    table: 'sloppygram_dm_messages',
                    filter: `conversation_id=eq.${convId}`
                }, payload => {
                    if (!dmMessages.find(m => m.id === payload.new.id)) {
                        dmMessages.push(payload.new);
                        renderDMMessages();
                        if (payload.new.sender_id !== currentUser.id) {
                            playNotificationSound();
                        }
                    }
                })
                .subscribe();
        }

        // Send a DM
        window.sendDM = async function() {
            if (!currentUser || !currentDMConversation) return;

            const input = document.getElementById('dmInput');
            const content = input.value.trim();
            if (!content) return;

            const sendBtn = document.querySelector('.dm-send-btn');
            sendBtn.disabled = true;

            try {
                // Insert message
                const { error } = await supabase
                    .from('sloppygram_dm_messages')
                    .insert({
                        conversation_id: parseInt(currentDMConversation.id),
                        sender_id: currentUser.id,
                        sender_username: profile.username,
                        recipient_id: currentDMConversation.recipientId,
                        content: content,
                        user_id: currentUser.id
                    });

                if (error) throw error;

                // Update conversation's last message
                await supabase
                    .from('sloppygram_dm_conversations')
                    .update({
                        last_message_at: new Date().toISOString(),
                        last_message_preview: content.substring(0, 50)
                    })
                    .eq('id', currentDMConversation.id);

                input.value = '';
            } catch (err) {
                console.error('Failed to send DM:', err);
                showToast('Failed to send message', 'error');
            } finally {
                sendBtn.disabled = false;
            }
        };

        // Enter key to send
        document.addEventListener('DOMContentLoaded', () => {
            const dmInput = document.getElementById('dmInput');
            if (dmInput) {
                dmInput.addEventListener('keydown', (e) => {
                    if (e.key === 'Enter' && !e.shiftKey) {
                        e.preventDefault();
                        sendDM();
                    }
                });
            }
        });

        // Close thread (mobile)
        window.closeDMThread = function() {
            document.getElementById('dmConversations').classList.remove('hidden-mobile');
            document.getElementById('dmThread').classList.remove('active-mobile');
        };

        // New DM Modal
        window.openNewDMModal = function() {
            document.getElementById('dmNewModal').classList.add('visible');
            document.getElementById('dmUserSearch').value = '';
            document.getElementById('dmUserSearch').focus();
            document.getElementById('dmUserResults').innerHTML = '<div style="text-align:center;padding:20px;color:var(--text-dim);">Type a username to search</div>';
        };

        window.closeNewDMModal = function() {
            document.getElementById('dmNewModal').classList.remove('visible');
        };

        // Search for users to DM
        let dmSearchTimeout = null;
        window.searchDMUsers = function(query) {
            clearTimeout(dmSearchTimeout);

            if (!query || query.length < 2) {
                document.getElementById('dmUserResults').innerHTML = '<div style="text-align:center;padding:20px;color:var(--text-dim);">Type at least 2 characters</div>';
                return;
            }

            dmSearchTimeout = setTimeout(async () => {
                try {
                    // Search in messages for unique usernames
                    const { data, error } = await supabase
                        .from('sloppygram_messages')
                        .select('username, avatar, user_id')
                        .ilike('username', `%${query}%`)
                        .limit(50);

                    if (error) throw error;

                    // Get unique users
                    const userMap = new Map();
                    (data || []).forEach(u => {
                        if (u.user_id && u.user_id !== currentUser.id && !userMap.has(u.user_id)) {
                            userMap.set(u.user_id, { id: u.user_id, username: u.username, avatar: u.avatar });
                        }
                    });

                    const users = Array.from(userMap.values()).slice(0, 10);

                    if (users.length === 0) {
                        document.getElementById('dmUserResults').innerHTML = '<div style="text-align:center;padding:20px;color:var(--text-dim);">No users found</div>';
                        return;
                    }

                    document.getElementById('dmUserResults').innerHTML = users.map(u => `
                        <div class="dm-user-item" onclick="startDMWithUser('${u.id}', '${escapeHtml(u.username)}')">
                            <span class="avatar">${u.avatar || 'ðŸ‘¤'}</span>
                            <span class="username">${escapeHtml(u.username)}</span>
                        </div>
                    `).join('');
                } catch (err) {
                    console.error('User search failed:', err);
                    document.getElementById('dmUserResults').innerHTML = '<div style="text-align:center;padding:20px;color:var(--text-dim);">Search failed</div>';
                }
            }, 300);
        };

        // Start a new DM conversation
        window.startDMWithUser = async function(recipientId, recipientUsername) {
            if (!currentUser) return;

            closeNewDMModal();

            try {
                // Check if conversation already exists
                const existingConv = dmConversations.find(c =>
                    (c.sender_id === currentUser.id && c.recipient_id === recipientId) ||
                    (c.sender_id === recipientId && c.recipient_id === currentUser.id)
                );

                if (existingConv) {
                    openDMConversation(existingConv.id, recipientId, recipientUsername);
                    return;
                }

                // Create new conversation
                const { data, error } = await supabase
                    .from('sloppygram_dm_conversations')
                    .insert({
                        sender_id: currentUser.id,
                        sender_username: profile.username,
                        recipient_id: recipientId,
                        recipient_username: recipientUsername,
                        user_id: currentUser.id
                    })
                    .select()
                    .single();

                if (error) throw error;

                // Reload conversations and open the new one
                await loadDMConversations();
                openDMConversation(data.id, recipientId, recipientUsername);

                showToast('Conversation started!', 'success');
            } catch (err) {
                console.error('Failed to start conversation:', err);
                showToast('Failed to start conversation', 'error');
            }
        };

        // Mobile touch swipe navigation
        const VIEWS = ['chat', 'posts', 'doodles', 'manifesto', 'collab', 'feedback', 'karma', 'factions', 'dm', 'graph'];
        let touchStartX = 0;
        let touchStartY = 0;
        let touchEndX = 0;
        let touchEndY = 0;
        const MIN_SWIPE_DISTANCE = 80;
        const MAX_VERTICAL_DISTANCE = 100;
        let swipeListenersInitialized = false;
        let swipeCleanupFns = [];

        function isMobile() {
            return window.matchMedia('(max-width: 768px)').matches ||
                   'ontouchstart' in window ||
                   navigator.maxTouchPoints > 0;
        }

        function handleSwipe() {
            const deltaX = touchEndX - touchStartX;
            const deltaY = Math.abs(touchEndY - touchStartY);

            // Only trigger swipe if horizontal movement is significant and vertical is minimal
            if (Math.abs(deltaX) > MIN_SWIPE_DISTANCE && deltaY < MAX_VERTICAL_DISTANCE) {
                const currentIndex = VIEWS.indexOf(currentView);

                if (deltaX < 0 && currentIndex < VIEWS.length - 1) {
                    // Swipe left - go to next tab
                    switchView(VIEWS[currentIndex + 1]);
                } else if (deltaX > 0 && currentIndex > 0) {
                    // Swipe right - go to previous tab
                    switchView(VIEWS[currentIndex - 1]);
                }
            }
        }

        function cleanupSwipeListeners() {
            swipeCleanupFns.forEach(fn => fn());
            swipeCleanupFns = [];
            swipeListenersInitialized = false;
        }

        function initTouchSwipe() {
            // Guard against duplicate initialization
            if (swipeListenersInitialized) {
                console.log('[Swipe] Already initialized, skipping');
                return;
            }

            const mainContent = document.querySelector('.main-content');
            if (!mainContent) return;

            const handleTouchStart = (e) => {
                if (!isMobile()) return;
                touchStartX = e.changedTouches[0].screenX;
                touchStartY = e.changedTouches[0].screenY;
            };

            const handleTouchEnd = (e) => {
                if (!isMobile()) return;
                touchEndX = e.changedTouches[0].screenX;
                touchEndY = e.changedTouches[0].screenY;
                handleSwipe();
            };

            mainContent.addEventListener('touchstart', handleTouchStart, { passive: true });
            mainContent.addEventListener('touchend', handleTouchEnd, { passive: true });

            // Store cleanup functions
            swipeCleanupFns.push(() => mainContent.removeEventListener('touchstart', handleTouchStart));
            swipeCleanupFns.push(() => mainContent.removeEventListener('touchend', handleTouchEnd));

            swipeListenersInitialized = true;
            console.log('[Swipe] Touch swipe navigation initialized');
        }

        // Initialize touch swipe after DOM ready
        document.addEventListener('DOMContentLoaded', initTouchSwipe);

        // === SOCIAL GRAPH VISUALIZATION ===
        let graphNodes = [];
        let graphEdges = [];
        let graphCanvas = null;
        let graphCtx = null;
        let graphAnimationId = null;
        let graphZoom = 1;
        let graphPanX = 0;
        let graphPanY = 0;
        let graphDragging = false;
        let graphDragStart = { x: 0, y: 0 };
        let graphFilter = 'all';
        let graphInitialized = false;
        let graphHoveredNode = null;
        let graphVerifiedUsers = new Set();

        const GRAPH_COLORS = {
            follow: '#4a9eff',
            delegation: '#a855f7',
            faction: '#22c55e',
            nodeDefault: '#7c9885',
            nodeVerified: '#00ffff',
            nodeBorder: '#ffffff'
        };

        async function initSocialGraph() {
            if (graphInitialized && graphNodes.length > 0) {
                // Already initialized, just redraw
                startGraphAnimation();
                return;
            }

            const loading = document.getElementById('graphLoading');
            if (loading) loading.style.display = 'block';

            graphCanvas = document.getElementById('graphCanvas');
            if (!graphCanvas) return;

            graphCtx = graphCanvas.getContext('2d');
            resizeGraphCanvas();

            // Attach events
            graphCanvas.addEventListener('mousedown', handleGraphMouseDown);
            graphCanvas.addEventListener('mousemove', handleGraphMouseMove);
            graphCanvas.addEventListener('mouseup', handleGraphMouseUp);
            graphCanvas.addEventListener('mouseleave', handleGraphMouseUp);
            graphCanvas.addEventListener('wheel', handleGraphWheel);
            window.addEventListener('resize', resizeGraphCanvas);

            try {
                await loadGraphData();
                if (loading) loading.style.display = 'none';
                graphInitialized = true;
                startGraphAnimation();
            } catch (err) {
                console.error('Failed to load graph data:', err);
                if (loading) loading.textContent = 'Failed to load network';
            }
        }

        function resizeGraphCanvas() {
            if (!graphCanvas) return;
            const wrap = graphCanvas.parentElement;
            graphCanvas.width = wrap.clientWidth;
            graphCanvas.height = wrap.clientHeight;
        }

        async function loadGraphData() {
            // Parallel fetch all relationship data
            const [followsRes, delegationsRes, factionsRes, karmaRes, verificationsRes] = await Promise.all([
                supabase.from('sloppygram_follows').select('follower_username, followed_username'),
                supabase.from('swarm_delegations').select('delegator_username, delegatee_username').eq('is_active', true),
                supabase.from('sloppygram_faction_members').select('username, faction_id'),
                supabase.from('sloppygram_karma').select('username, karma_total, rank').order('karma_total', { ascending: false }).limit(200),
                supabase.from('sloppyid_verifications').select('username, verification_type').eq('is_verified', true)
            ]);

            const follows = followsRes.data || [];
            const delegations = delegationsRes.data || [];
            const factionMembers = factionsRes.data || [];
            const karmaUsers = karmaRes.data || [];
            const verifications = verificationsRes.data || [];

            // Build verified users set
            graphVerifiedUsers.clear();
            verifications.forEach(v => graphVerifiedUsers.add(v.username));

            // Build nodes from karma data
            const nodeMap = new Map();
            const centerX = graphCanvas.width / 2;
            const centerY = graphCanvas.height / 2;

            karmaUsers.forEach((k, i) => {
                const angle = (i / karmaUsers.length) * Math.PI * 2;
                const radius = 150 + Math.random() * 200;
                nodeMap.set(k.username, {
                    id: k.username,
                    karma: k.karma_total || 1,
                    rank: k.rank || 999,
                    x: centerX + Math.cos(angle) * radius,
                    y: centerY + Math.sin(angle) * radius,
                    vx: 0,
                    vy: 0,
                    verified: graphVerifiedUsers.has(k.username)
                });
            });

            // Add any users from relationships not in karma list
            const addNodeIfMissing = (username) => {
                if (!nodeMap.has(username)) {
                    nodeMap.set(username, {
                        id: username,
                        karma: 1,
                        rank: 999,
                        x: centerX + (Math.random() - 0.5) * 400,
                        y: centerY + (Math.random() - 0.5) * 400,
                        vx: 0,
                        vy: 0,
                        verified: graphVerifiedUsers.has(username)
                    });
                }
            };

            // Build edges
            const edges = [];

            follows.forEach(f => {
                if (f.follower_username && f.followed_username) {
                    addNodeIfMissing(f.follower_username);
                    addNodeIfMissing(f.followed_username);
                    edges.push({
                        source: f.follower_username,
                        target: f.followed_username,
                        type: 'follow'
                    });
                }
            });

            delegations.forEach(d => {
                if (d.delegator_username && d.delegatee_username) {
                    addNodeIfMissing(d.delegator_username);
                    addNodeIfMissing(d.delegatee_username);
                    edges.push({
                        source: d.delegator_username,
                        target: d.delegatee_username,
                        type: 'delegation'
                    });
                }
            });

            // Group faction members by faction_id
            const factionGroups = {};
            factionMembers.forEach(fm => {
                if (!factionGroups[fm.faction_id]) factionGroups[fm.faction_id] = [];
                factionGroups[fm.faction_id].push(fm.username);
            });

            // Create faction edges (connect members of same faction)
            Object.values(factionGroups).forEach(members => {
                for (let i = 0; i < members.length; i++) {
                    for (let j = i + 1; j < members.length; j++) {
                        addNodeIfMissing(members[i]);
                        addNodeIfMissing(members[j]);
                        edges.push({
                            source: members[i],
                            target: members[j],
                            type: 'faction'
                        });
                    }
                }
            });

            graphNodes = Array.from(nodeMap.values());
            graphEdges = edges;

            // Update stats
            document.getElementById('graphStatNodes').textContent = graphNodes.length;
            document.getElementById('graphStatEdges').textContent = graphEdges.length;
            document.getElementById('graphStatClusters').textContent = Object.keys(factionGroups).length;
        }

        function startGraphAnimation() {
            if (graphAnimationId) cancelAnimationFrame(graphAnimationId);

            function animate() {
                simulateGraphForces();
                renderGraph();
                graphAnimationId = requestAnimationFrame(animate);
            }
            animate();
        }

        function stopGraphAnimation() {
            if (graphAnimationId) {
                cancelAnimationFrame(graphAnimationId);
                graphAnimationId = null;
            }
        }

        function simulateGraphForces() {
            const repulsionStrength = 500;
            const attractionStrength = 0.01;
            const damping = 0.9;
            const centerGravity = 0.001;

            const centerX = graphCanvas.width / 2;
            const centerY = graphCanvas.height / 2;

            // Repulsion between all nodes
            for (let i = 0; i < graphNodes.length; i++) {
                for (let j = i + 1; j < graphNodes.length; j++) {
                    const n1 = graphNodes[i];
                    const n2 = graphNodes[j];
                    const dx = n2.x - n1.x;
                    const dy = n2.y - n1.y;
                    const dist = Math.sqrt(dx * dx + dy * dy) || 1;
                    const force = repulsionStrength / (dist * dist);
                    const fx = (dx / dist) * force;
                    const fy = (dy / dist) * force;
                    n1.vx -= fx;
                    n1.vy -= fy;
                    n2.vx += fx;
                    n2.vy += fy;
                }
            }

            // Attraction along edges
            graphEdges.forEach(e => {
                if (graphFilter !== 'all' && e.type !== graphFilter.replace('s', '')) return;

                const source = graphNodes.find(n => n.id === e.source);
                const target = graphNodes.find(n => n.id === e.target);
                if (!source || !target) return;

                const dx = target.x - source.x;
                const dy = target.y - source.y;
                const dist = Math.sqrt(dx * dx + dy * dy) || 1;
                const force = dist * attractionStrength;
                const fx = (dx / dist) * force;
                const fy = (dy / dist) * force;
                source.vx += fx;
                source.vy += fy;
                target.vx -= fx;
                target.vy -= fy;
            });

            // Center gravity
            graphNodes.forEach(n => {
                n.vx += (centerX - n.x) * centerGravity;
                n.vy += (centerY - n.y) * centerGravity;
            });

            // Update positions with damping
            graphNodes.forEach(n => {
                n.vx *= damping;
                n.vy *= damping;
                n.x += n.vx;
                n.y += n.vy;

                // Boundary constraints
                const margin = 50;
                n.x = Math.max(margin, Math.min(graphCanvas.width - margin, n.x));
                n.y = Math.max(margin, Math.min(graphCanvas.height - margin, n.y));
            });
        }

        function renderGraph() {
            if (!graphCtx || !graphCanvas) return;

            graphCtx.save();
            graphCtx.clearRect(0, 0, graphCanvas.width, graphCanvas.height);

            // Apply zoom and pan
            graphCtx.translate(graphPanX, graphPanY);
            graphCtx.scale(graphZoom, graphZoom);

            // Draw edges
            graphEdges.forEach(e => {
                if (graphFilter !== 'all') {
                    const filterType = graphFilter.replace('s', '');
                    if (e.type !== filterType) return;
                }

                const source = graphNodes.find(n => n.id === e.source);
                const target = graphNodes.find(n => n.id === e.target);
                if (!source || !target) return;

                graphCtx.beginPath();
                graphCtx.strokeStyle = GRAPH_COLORS[e.type] || '#666';
                graphCtx.lineWidth = e.type === 'delegation' ? 2 : 1;
                graphCtx.globalAlpha = e.type === 'faction' ? 0.3 : 0.6;

                if (e.type === 'delegation') {
                    graphCtx.setLineDash([5, 3]);
                } else {
                    graphCtx.setLineDash([]);
                }

                graphCtx.moveTo(source.x, source.y);
                graphCtx.lineTo(target.x, target.y);
                graphCtx.stroke();
                graphCtx.setLineDash([]);
                graphCtx.globalAlpha = 1;
            });

            // Draw nodes
            graphNodes.forEach(n => {
                const radius = Math.max(6, Math.min(25, Math.sqrt(n.karma) * 1.5));
                const isHovered = graphHoveredNode && graphHoveredNode.id === n.id;

                graphCtx.beginPath();
                graphCtx.arc(n.x, n.y, radius, 0, Math.PI * 2);

                // Node fill
                if (n.verified) {
                    graphCtx.fillStyle = GRAPH_COLORS.nodeVerified;
                    graphCtx.shadowBlur = 15;
                    graphCtx.shadowColor = GRAPH_COLORS.nodeVerified;
                } else {
                    graphCtx.fillStyle = GRAPH_COLORS.nodeDefault;
                    graphCtx.shadowBlur = 0;
                }

                if (isHovered) {
                    graphCtx.shadowBlur = 20;
                    graphCtx.shadowColor = '#fff';
                }

                graphCtx.fill();
                graphCtx.shadowBlur = 0;

                // Node border
                graphCtx.strokeStyle = isHovered ? '#fff' : GRAPH_COLORS.nodeBorder;
                graphCtx.lineWidth = isHovered ? 3 : 1.5;
                graphCtx.stroke();

                // Draw label for high-karma or hovered nodes
                if (n.karma > 50 || isHovered) {
                    graphCtx.font = '11px VT323, monospace';
                    graphCtx.fillStyle = '#fff';
                    graphCtx.textAlign = 'center';
                    graphCtx.fillText(n.id, n.x, n.y - radius - 5);
                }
            });

            graphCtx.restore();
        }

        function handleGraphMouseDown(e) {
            graphDragging = true;
            graphDragStart = { x: e.clientX - graphPanX, y: e.clientY - graphPanY };
            graphCanvas.style.cursor = 'grabbing';
        }

        function handleGraphMouseMove(e) {
            const rect = graphCanvas.getBoundingClientRect();
            const mouseX = (e.clientX - rect.left - graphPanX) / graphZoom;
            const mouseY = (e.clientY - rect.top - graphPanY) / graphZoom;

            if (graphDragging) {
                graphPanX = e.clientX - graphDragStart.x;
                graphPanY = e.clientY - graphDragStart.y;
            } else {
                // Check for node hover
                let hovered = null;
                for (const n of graphNodes) {
                    const radius = Math.max(6, Math.min(25, Math.sqrt(n.karma) * 1.5));
                    const dx = n.x - mouseX;
                    const dy = n.y - mouseY;
                    if (Math.sqrt(dx * dx + dy * dy) < radius) {
                        hovered = n;
                        break;
                    }
                }

                graphHoveredNode = hovered;
                graphCanvas.style.cursor = hovered ? 'pointer' : 'grab';

                // Update tooltip
                const tooltip = document.getElementById('graphTooltip');
                if (hovered && tooltip) {
                    tooltip.classList.add('visible');
                    tooltip.style.left = (e.clientX - rect.left + 15) + 'px';
                    tooltip.style.top = (e.clientY - rect.top - 10) + 'px';
                    document.getElementById('graphTooltipName').textContent = hovered.id + (hovered.verified ? ' âœ“' : '');
                    document.getElementById('graphTooltipKarma').textContent = 'âš¡ ' + hovered.karma + ' karma';
                    document.getElementById('graphTooltipRank').textContent = 'Rank #' + hovered.rank;
                } else if (tooltip) {
                    tooltip.classList.remove('visible');
                }
            }
        }

        function handleGraphMouseUp(e) {
            if (graphDragging) {
                graphDragging = false;
                graphCanvas.style.cursor = 'grab';
            } else if (graphHoveredNode) {
                // Click on node - open profile
                showProfileCard(graphHoveredNode.id, e);
            }
        }

        function handleGraphWheel(e) {
            e.preventDefault();
            const delta = e.deltaY > 0 ? -0.1 : 0.1;
            zoomGraph(delta);
        }

        window.zoomGraph = function(delta) {
            graphZoom = Math.max(0.3, Math.min(3, graphZoom + delta));
        };

        window.resetGraphView = function() {
            graphZoom = 1;
            graphPanX = 0;
            graphPanY = 0;
        };

        window.toggleGraphFilter = function(filter) {
            graphFilter = filter;
            document.querySelectorAll('.graph-filter-btn').forEach(btn => {
                btn.classList.toggle('active', btn.dataset.filter === filter);
            });
        };

        // Initialize
        init();
    </script>
    <script src="/sloppy-header/sloppy-bar.js"></script>
</body>
</html>
