<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sloppygram - Cyber Chat 1999</title>
    <link rel="icon" href="https://emojicdn.elk.sh/ðŸ’¾">

    <meta property="og:title" content="Sloppygram">
    <meta property="og:description" content="Retro cyber chatroom from 1999. Global chat and pure vibes.">
    <meta property="og:url" content="https://sloppy.live/sloppygram">
    <meta property="og:image" content="https://image.pollinations.ai/prompt/1990s%20retro%20cyber%20chatroom%20neon%20green%20dark%20hacker%20aesthetic%20terminal?width=1200&height=630&nologo=true">
    <meta property="og:type" content="website">

    <link href="https://fonts.googleapis.com/css2?family=VT323&family=Share+Tech+Mono&display=swap" rel="stylesheet">

    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        :root {
            --accent: #7c9885;
            --accent-light: #a8c4b0;
            --accent-dim: #5a7060;
            --highlight: #c9a87c;
            --dark-bg: #0a0a0f;
            --panel-bg: #12121a;
            --border-color: #2a2a35;
            --text-dim: #6a6a75;
            --msg-opacity: 0.95;
        }

        body {
            font-family: 'VT323', monospace;
            background: var(--dark-bg);
            min-height: 100vh;
            color: var(--accent);
            overflow: hidden;
        }

        /* Scanline effect */
        body::before {
            content: '';
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: repeating-linear-gradient(
                0deg,
                rgba(0, 0, 0, 0.15),
                rgba(0, 0, 0, 0.15) 1px,
                transparent 1px,
                transparent 2px
            );
            pointer-events: none;
            z-index: 9999;
        }

        .app {
            display: grid;
            grid-template-columns: 200px 1fr 180px;
            grid-template-rows: auto 1fr;
            height: 100vh;
            gap: 1px;
            background: transparent;
        }

        @media (max-width: 768px) {
            .app {
                grid-template-columns: 1fr;
                grid-template-rows: auto 1fr;
                height: 100vh;
                height: 100dvh;
            }
            .sidebar-left, .sidebar-right {
                display: none;
            }
            .sidebar-left.mobile-show, .sidebar-right.mobile-show {
                display: flex;
                flex-direction: column;
                position: fixed;
                top: 60px;
                bottom: 0;
                width: 75%;
                max-width: 280px;
                z-index: 101;
                box-shadow: 0 0 20px rgba(0,0,0,0.5);
            }
            .sidebar-left.mobile-show { left: 0; }
            .sidebar-right.mobile-show { right: 0; }

            .sidebar-close-btn {
                display: flex;
                align-items: center;
                justify-content: center;
                width: 30px;
                height: 30px;
                position: absolute;
                top: 8px;
                right: 8px;
                background: var(--border-color);
                border: none;
                color: var(--accent);
                font-size: 1.2rem;
                cursor: pointer;
                border-radius: 4px;
                z-index: 10;
            }

            .sidebar-close-btn:hover {
                background: var(--accent-dim);
            }

            .mobile-backdrop {
                display: none;
                position: fixed;
                top: 60px;
                left: 0;
                right: 0;
                bottom: 0;
                background: rgba(0, 0, 0, 0.6);
                z-index: 100;
            }

            .mobile-backdrop.active {
                display: block;
            }
        }

        /* Header */
        .header {
            grid-column: 1 / -1;
            grid-row: 1;
            background: var(--panel-bg);
            padding: 8px 16px;
            display: flex;
            align-items: center;
            justify-content: space-between;
            flex-shrink: 0;
            min-height: 50px;
            z-index: 10;
            position: relative;
        }

        .logo {
            font-size: 1.8rem;
            color: var(--accent-light);
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .logo-blink {
            animation: blink 1s infinite;
        }

        @keyframes blink {
            0%, 50% { opacity: 1; }
            51%, 100% { opacity: 0; }
        }

        .marquee-container {
            flex: 1;
            overflow: hidden;
            margin: 0 20px;
            color: var(--highlight);
            font-size: 1.1rem;
        }

        .marquee {
            display: inline-block;
            white-space: nowrap;
            animation: marquee 20s linear infinite;
        }

        @keyframes marquee {
            from { transform: translateX(100%); }
            to { transform: translateX(-100%); }
        }

        .header-actions {
            display: flex;
            gap: 8px;
        }

        .cyber-btn {
            background: transparent;
            border: 1px solid var(--border-color);
            color: var(--accent);
            padding: 6px 12px;
            font-family: inherit;
            font-size: 1rem;
            cursor: pointer;
            transition: all 0.2s;
        }

        .cyber-btn:hover {
            background: var(--accent-dim);
            color: white;
        }

        /* Sidebars */
        .sidebar-left, .sidebar-right {
            grid-row: 2;
            background: var(--panel-bg);
            padding: 12px;
            overflow-y: auto;
            display: flex;
            flex-direction: column;
        }

        #publicFeed {
            max-height: 40vh;
            overflow-y: auto;
            flex-shrink: 1;
        }

        .panel-title {
            color: var(--highlight);
            font-size: 1.2rem;
            margin-bottom: 10px;
            padding-bottom: 6px;
            border-bottom: 1px solid var(--border-color);
        }

        /* Online Users */
        .user-list {
            list-style: none;
        }

        .user-item {
            padding: 6px 8px;
            margin-bottom: 4px;
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 1rem;
            border-left: 2px solid transparent;
            transition: all 0.2s;
        }

        .user-item:hover {
            background: rgba(255, 255, 255, 0.05);
            border-left-color: var(--accent);
        }

        .user-status {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: var(--accent);
            animation: pulse 2s infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        .user-avatar {
            font-size: 1.2rem;
        }

        .user-name {
            color: var(--accent-light);
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        /* Public Feed */
        .feed-item {
            padding: 8px;
            margin-bottom: 8px;
            background: rgba(255, 255, 255, 0.02);
            border-left: 2px solid var(--border-color);
            font-size: 0.95rem;
        }

        .feed-user {
            color: var(--highlight);
        }

        .feed-action {
            color: var(--text-dim);
        }

        .feed-time {
            color: #666;
            font-size: 0.85rem;
        }

        /* Messages Container */
        .main-content {
            grid-row: 2;
            background: var(--panel-bg);
            display: flex;
            flex-direction: column;
            overflow: hidden;
            min-height: 0;
        }

        .messages-container {
            flex: 1;
            overflow-y: auto;
            padding: 16px;
            display: flex;
            flex-direction: column;
            gap: 12px;
            min-height: 0;
            position: relative;
            background-size: cover;
            background-position: center;
            background-attachment: fixed;
            background-repeat: no-repeat;
            image-rendering: -webkit-optimize-contrast;
            image-rendering: crisp-edges;
        }

        .messages-container::-webkit-scrollbar {
            width: 8px;
        }

        .messages-container::-webkit-scrollbar-track {
            background: var(--dark-bg);
        }

        .messages-container::-webkit-scrollbar-thumb {
            background: var(--border-color);
        }

        .message {
            display: flex;
            gap: 10px;
            animation: glitchIn 0.3s ease-out;
        }

        @keyframes glitchIn {
            0% { opacity: 0; transform: translateX(-10px); }
            50% { opacity: 1; transform: translateX(3px); }
            100% { transform: translateX(0); }
        }

        .message.own {
            flex-direction: row-reverse;
        }

        .avatar {
            width: 40px;
            height: 40px;
            border: 1px solid var(--border-color);
            border-radius: 4px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 24px;
            flex-shrink: 0;
            background: var(--dark-bg);
        }

        .message-bubble {
            max-width: 70%;
            background: rgba(10, 10, 15, var(--msg-opacity));
            border: 1px solid var(--border-color);
            border-radius: 4px;
            padding: 10px 14px;
            color: var(--accent);
        }

        .message.own .message-bubble {
            background: rgba(90, 112, 96, var(--msg-opacity));
            color: var(--accent-light);
        }

        .message-header {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 4px;
        }

        .message-username {
            color: var(--accent-light);
            font-size: 1rem;
        }

        .message.own .message-username {
            color: var(--highlight);
        }

        .message-time {
            font-size: 0.85rem;
            color: #555;
        }

        .message-content {
            font-size: 1.1rem;
            line-height: 1.4;
            word-wrap: break-word;
        }

        .message-image, .message-drawing {
            max-width: 100%;
            margin-top: 8px;
            cursor: pointer;
            border: 1px solid var(--border-color);
        }

        /* Doodle Vote */
        .doodle-wrapper {
            position: relative;
            display: inline-block;
        }

        .doodle-vote-btn {
            position: absolute;
            bottom: 8px;
            right: 8px;
            background: rgba(0,0,0,0.7);
            border: 1px solid var(--border-color);
            color: var(--text-dim);
            padding: 4px 10px;
            font-family: inherit;
            font-size: 0.9rem;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 4px;
            transition: all 0.2s;
        }

        .doodle-vote-btn:hover {
            background: rgba(0,0,0,0.9);
            border-color: var(--highlight);
            color: var(--highlight);
        }

        .doodle-vote-btn.voted {
            color: var(--highlight);
            border-color: var(--highlight);
        }

        /* Vote controls (up/down) */
        .vote-controls {
            display: inline-flex;
            align-items: center;
            gap: 2px;
            background: rgba(0,0,0,0.3);
            border-radius: 12px;
            padding: 2px 4px;
        }

        .vote-btn {
            background: transparent;
            border: none;
            color: var(--text-dim);
            padding: 2px 6px;
            font-size: 0.85rem;
            cursor: pointer;
            transition: all 0.15s;
            border-radius: 8px;
        }

        .vote-btn:hover {
            background: rgba(255,255,255,0.1);
        }

        .vote-btn.upvote:hover, .vote-btn.upvote.active {
            color: #00ff41;
        }

        .vote-btn.downvote:hover, .vote-btn.downvote.active {
            color: #ff4444;
        }

        .vote-btn.disabled {
            opacity: 0.3;
            cursor: not-allowed;
        }

        .vote-score {
            font-size: 0.8rem;
            min-width: 20px;
            text-align: center;
            font-weight: bold;
        }

        .vote-score.positive { color: #00ff41; }
        .vote-score.negative { color: #ff4444; }
        .vote-score.neutral { color: var(--text-dim); }

        .message-footer {
            margin-top: 6px;
            padding-top: 4px;
        }

        .msg-delete-btn {
            background: transparent;
            border: none;
            color: var(--text-dim);
            cursor: pointer;
            padding: 0 4px;
            font-size: 0.8rem;
            opacity: 0.5;
            margin-left: auto;
            transition: opacity 0.2s;
        }

        .msg-delete-btn:hover {
            opacity: 1;
            color: #ff4444;
        }

        .message-header {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        /* Doodle Leaderboard */
        .doodles-container {
            flex: 1;
            overflow-y: auto;
            padding: 16px;
            display: none;
            flex-direction: column;
            gap: 16px;
            min-height: 0;
        }

        .doodles-container.active {
            display: flex;
        }

        .leaderboard-header {
            text-align: center;
            padding: 16px;
            color: var(--accent);
            font-size: 1.1rem;
            border-bottom: 1px solid var(--border-color);
        }

        .doodle-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
            gap: 16px;
        }

        .doodle-card {
            background: var(--panel-bg);
            border: 1px solid var(--border-color);
            overflow: hidden;
            border-radius: 8px;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .doodle-card:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 20px rgba(0,0,0,0.3);
        }

        .doodle-card.top-3 {
            border-color: var(--highlight);
        }

        .doodle-rank {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 8px 12px;
            background: var(--dark-bg);
        }

        .rank-badge {
            width: 28px;
            height: 28px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            font-size: 0.9rem;
            background: var(--border-color);
            color: var(--text-dim);
        }

        .rank-badge.gold {
            background: linear-gradient(135deg, #ffd700, #ffaa00);
            color: #000;
        }
        .rank-badge.silver {
            background: linear-gradient(135deg, #e0e0e0, #a0a0a0);
            color: #000;
        }
        .rank-badge.bronze {
            background: linear-gradient(135deg, #cd7f32, #8b4513);
            color: #fff;
        }

        .doodle-artist {
            flex: 1;
            color: var(--accent-light);
            font-size: 0.9rem;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .doodle-votes {
            color: var(--highlight);
            font-size: 1rem;
            font-weight: bold;
        }

        .doodle-thumbnail {
            position: relative;
            background: #111;
            aspect-ratio: 4/3;
            overflow: hidden;
        }

        .doodle-card img {
            width: 100%;
            height: 100%;
            object-fit: contain;
            display: block;
            cursor: pointer;
            transition: transform 0.2s;
        }

        .doodle-card:hover img {
            transform: scale(1.05);
        }

        .doodle-card-actions {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px 12px;
            border-top: 1px solid var(--border-color);
            background: var(--dark-bg);
        }

        .doodle-time {
            color: var(--text-dim);
            font-size: 0.75rem;
        }

        .empty-doodles {
            text-align: center;
            padding: 60px 20px;
            color: var(--text-dim);
        }

        /* Manifesto Section */
        .manifesto-container {
            flex: 1;
            overflow-y: auto;
            padding: 16px;
            display: none;
            flex-direction: column;
            gap: 16px;
            min-height: 0;
        }

        .manifesto-container.active {
            display: flex;
        }

        .manifesto-header {
            text-align: center;
            padding: 20px;
            border-bottom: 1px solid var(--border-color);
        }

        .manifesto-header h2 {
            color: var(--highlight);
            font-size: 1.4rem;
            margin-bottom: 8px;
        }

        .manifesto-subtitle {
            color: var(--text-dim);
            font-size: 0.95rem;
            margin-bottom: 16px;
        }

        .manifesto-list {
            display: flex;
            flex-direction: column;
            gap: 16px;
        }

        .manifesto-card {
            background: linear-gradient(135deg, rgba(201,168,124,0.1), rgba(124,152,133,0.05));
            border: 1px solid var(--border-color);
            border-left: 3px solid var(--highlight);
            padding: 16px;
            transition: all 0.2s;
        }

        .manifesto-card:hover {
            border-color: var(--highlight);
            box-shadow: 0 4px 20px rgba(201,168,124,0.1);
        }

        .manifesto-card-header {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 12px;
        }

        .manifesto-avatar {
            width: 32px;
            height: 32px;
            border-radius: 50%;
            background: var(--dark-bg);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 18px;
            border: 1px solid var(--border-color);
        }

        .manifesto-author {
            color: var(--accent-light);
            font-size: 1rem;
        }

        .manifesto-time {
            margin-left: auto;
            color: var(--text-dim);
            font-size: 0.85rem;
        }

        .manifesto-title {
            color: var(--highlight);
            font-size: 1.2rem;
            margin-bottom: 10px;
            font-weight: normal;
        }

        .manifesto-text {
            color: var(--accent-light);
            font-size: 1rem;
            line-height: 1.6;
            white-space: pre-wrap;
        }

        .manifesto-actions {
            display: flex;
            gap: 12px;
            margin-top: 12px;
            padding-top: 12px;
            border-top: 1px solid var(--border-color);
        }

        .manifesto-vote-btn {
            background: transparent;
            border: 1px solid var(--border-color);
            color: var(--accent);
            padding: 6px 12px;
            cursor: pointer;
            font-family: inherit;
            font-size: 0.9rem;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .manifesto-vote-btn:hover {
            border-color: var(--highlight);
            color: var(--highlight);
        }

        .manifesto-vote-btn.voted {
            background: var(--highlight);
            border-color: var(--highlight);
            color: var(--dark-bg);
        }

        .manifesto-modal {
            max-width: 600px;
        }

        /* Transparency Slider Bar */
        .transparency-bar {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 6px 16px;
            background: var(--dark-bg);
            border-top: 1px solid var(--border-color);
            font-size: 0.8rem;
            color: var(--text-dim);
        }

        .transparency-bar label {
            white-space: nowrap;
        }

        .transparency-bar input[type="range"] {
            flex: 1;
            max-width: 120px;
            height: 4px;
            -webkit-appearance: none;
            background: var(--border-color);
            border-radius: 2px;
            cursor: pointer;
        }

        .transparency-bar input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 14px;
            height: 14px;
            background: var(--accent);
            border-radius: 50%;
            cursor: pointer;
        }

        .transparency-bar #opacityValue {
            min-width: 35px;
            text-align: right;
            color: var(--accent);
        }

        /* Input Area - now at top of chat */
        .input-area {
            background: var(--dark-bg);
            padding: 12px 16px;
            flex-shrink: 0;
            position: relative;
            z-index: 5;
            border-bottom: 1px solid var(--border-color);
        }

        .input-row {
            display: flex;
            gap: 8px;
            align-items: flex-end;
            max-width: 800px;
            margin: 0 auto;
        }

        .input-actions {
            display: flex;
            gap: 4px;
        }

        .action-btn {
            width: 40px;
            height: 40px;
            border: 1px solid var(--border-color);
            background: transparent;
            color: var(--accent);
            font-size: 18px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .action-btn:hover {
            background: var(--accent-dim);
            color: white;
        }

        .message-input {
            flex: 1;
            background: var(--panel-bg);
            border: 1px solid var(--border-color);
            padding: 10px 16px;
            color: var(--accent-light);
            font-family: inherit;
            font-size: 1.1rem;
            resize: none;
            max-height: 100px;
        }

        .message-input:focus {
            outline: none;
            border-color: var(--accent-dim);
        }

        .message-input::placeholder {
            color: var(--text-dim);
        }

        .send-btn {
            width: 60px;
            height: 40px;
            border: 1px solid var(--border-color);
            background: var(--accent-dim);
            color: white;
            font-family: inherit;
            font-size: 1rem;
            cursor: pointer;
            transition: all 0.2s;
        }

        .send-btn:hover {
            background: var(--accent);
        }

        /* Modals */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.9);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 1000;
        }

        .modal-overlay.active {
            display: flex;
        }

        .modal {
            background: var(--panel-bg);
            border: 1px solid var(--border-color);
            padding: 24px;
            width: 90%;
            max-width: 400px;
            max-height: 85vh;
            overflow-y: auto;
            color: var(--accent);
        }

        .modal h2 {
            margin-bottom: 16px;
            display: flex;
            align-items: center;
            gap: 10px;
            color: var(--accent-light);
            font-size: 1.5rem;
        }

        .modal-close {
            margin-left: auto;
            background: none;
            border: none;
            color: var(--text-dim);
            font-size: 24px;
            cursor: pointer;
        }

        /* Avatar Picker */
        .avatar-grid {
            display: grid;
            grid-template-columns: repeat(6, 1fr);
            gap: 8px;
            margin-bottom: 16px;
        }

        .avatar-option {
            aspect-ratio: 1;
            border: 2px solid #333;
            background: var(--dark-bg);
            font-size: 28px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s;
        }

        .avatar-option:hover {
            border-color: var(--accent-dim);
        }

        .avatar-option.selected {
            border-color: var(--accent);
        }

        .form-group {
            margin-bottom: 16px;
        }

        .form-group label {
            display: block;
            margin-bottom: 6px;
            font-size: 1rem;
            color: var(--highlight);
        }

        .form-group input {
            width: 100%;
            padding: 10px;
            background: var(--dark-bg);
            border: 1px solid var(--border-color);
            color: var(--accent-light);
            font-family: inherit;
            font-size: 1.1rem;
        }

        .form-group input:focus {
            outline: none;
            border-color: var(--accent-dim);
        }

        .color-options {
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
        }

        .color-option {
            width: 32px;
            height: 32px;
            border: 2px solid transparent;
            cursor: pointer;
        }

        .color-option:hover {
            transform: scale(1.1);
        }

        .color-option.selected {
            border-color: white;
        }

        .modal-btn {
            width: 100%;
            padding: 12px;
            background: var(--accent-dim);
            border: 1px solid var(--border-color);
            color: white;
            font-family: inherit;
            font-size: 1.1rem;
            cursor: pointer;
            margin-top: 16px;
            transition: all 0.2s;
        }

        .modal-btn:hover {
            background: var(--accent);
        }

        /* File Upload */
        .file-upload-row {
            display: flex;
            gap: 8px;
        }

        .file-upload-btn {
            flex: 1;
            padding: 10px;
            background: var(--dark-bg);
            border: 1px dashed var(--border-color);
            color: var(--text-dim);
            font-family: inherit;
            font-size: 0.9rem;
            cursor: pointer;
            transition: all 0.2s;
        }

        .file-upload-btn:hover {
            border-color: var(--accent);
            color: var(--accent);
        }

        .file-clear-btn {
            padding: 10px 15px;
            background: #3a2020;
            border: 1px solid #5a3030;
            color: #ff6666;
            font-family: inherit;
            font-size: 0.9rem;
            cursor: pointer;
            transition: all 0.2s;
        }

        .file-clear-btn:hover {
            background: #4a2525;
        }

        .upload-preview {
            margin-top: 10px;
            border: 1px solid var(--border-color);
            padding: 8px;
            background: var(--dark-bg);
        }

        .upload-preview img {
            max-width: 100%;
            max-height: 150px;
            display: block;
            margin: 0 auto;
        }

        /* Global Backgrounds */
        .global-bg-section {
            margin-top: 8px;
        }

        .global-bg-label {
            font-size: 0.85rem;
            color: var(--text-dim);
            margin-bottom: 8px;
        }

        .global-bg-grid {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 8px;
            max-height: 150px;
            overflow-y: auto;
        }

        .global-bg-item {
            aspect-ratio: 16/9;
            border: 2px solid var(--border-color);
            border-radius: 4px;
            overflow: hidden;
            cursor: pointer;
            transition: all 0.2s;
        }

        .global-bg-item:hover {
            border-color: var(--accent);
            transform: scale(1.05);
        }

        .global-bg-item.selected {
            border-color: var(--highlight);
        }

        .global-bg-item img {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        .global-bg-upload {
            display: flex;
            align-items: center;
            justify-content: center;
            background: var(--dark-bg);
            color: var(--text-dim);
            font-size: 1.5rem;
        }

        .global-bg-upload:hover {
            color: var(--accent);
        }

        /* Drawing Canvas */
        .drawing-modal .modal {
            max-width: 500px;
        }

        .canvas-container {
            background: #111;
            border: 1px solid var(--border-color);
            margin-bottom: 16px;
        }

        #drawingCanvas {
            display: block;
            width: 100%;
            cursor: crosshair;
            touch-action: none;
        }

        .canvas-tools {
            display: flex;
            gap: 8px;
            margin-bottom: 12px;
            flex-wrap: wrap;
        }

        .tool-btn {
            padding: 8px 12px;
            background: transparent;
            border: 1px solid var(--border-color);
            color: var(--accent);
            cursor: pointer;
            font-family: inherit;
        }

        .tool-btn:hover, .tool-btn.active {
            background: var(--accent-dim);
            color: white;
        }

        .brush-colors {
            display: flex;
            gap: 6px;
        }

        .brush-color {
            width: 28px;
            height: 28px;
            border: 2px solid #333;
            cursor: pointer;
        }

        .brush-color.selected {
            border-color: white;
        }

        /* Image preview */
        .image-preview {
            margin-bottom: 8px;
            position: relative;
            display: none;
        }

        .image-preview img {
            max-width: 200px;
            max-height: 150px;
            border: 1px solid var(--border-color);
        }

        .image-preview .remove-btn {
            position: absolute;
            top: -8px;
            right: -8px;
            width: 24px;
            height: 24px;
            background: #ff4444;
            border: none;
            color: white;
            cursor: pointer;
            font-size: 16px;
        }

        .empty-state {
            text-align: center;
            padding: 40px;
            color: var(--text-dim);
        }

        .empty-state .icon {
            font-size: 48px;
            margin-bottom: 16px;
        }

        #imageInput {
            display: none;
        }

        /* Mobile toggle buttons */
        .mobile-toggle {
            display: none;
        }

        @media (max-width: 768px) {
            .mobile-toggle {
                display: inline-block;
            }
        }

        /* Tabs */
        .view-tabs {
            display: flex;
            background: var(--dark-bg);
            border-bottom: 1px solid var(--border-color);
            flex-shrink: 0;
        }

        .view-tab {
            flex: 1;
            padding: 10px;
            background: transparent;
            border: none;
            border-bottom: 2px solid transparent;
            color: var(--text-dim);
            font-family: inherit;
            font-size: 1rem;
            cursor: pointer;
            transition: all 0.2s;
        }

        .view-tab:hover {
            color: var(--accent);
        }

        .view-tab.active {
            color: var(--accent-light);
            border-bottom-color: var(--accent);
        }

        /* Posts Container */
        .posts-container {
            flex: 1;
            overflow-y: auto;
            padding: 16px;
            display: none;
            flex-direction: column;
            gap: 16px;
            min-height: 0;
        }

        .messages-container.hidden {
            display: none;
        }

        /* Post Card */
        .post-card {
            background: rgba(255, 255, 255, 0.03);
            border: 1px solid var(--border-color);
            overflow: hidden;
            flex-shrink: 0;
        }

        .post-header {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 12px;
            border-bottom: 1px solid var(--border-color);
        }

        .post-avatar {
            width: 36px;
            height: 36px;
            border-radius: 50%;
            background: var(--dark-bg);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 20px;
            border: 1px solid var(--border-color);
        }

        .post-username {
            color: var(--accent-light);
            font-size: 1.1rem;
        }

        .post-time {
            color: var(--text-dim);
            font-size: 0.9rem;
            flex: 1;
        }

        .post-delete-btn {
            background: none;
            border: none;
            cursor: pointer;
            font-size: 1rem;
            opacity: 0.4;
            transition: opacity 0.2s;
            padding: 4px;
        }

        .post-delete-btn:hover {
            opacity: 1;
        }

        /* Reputation Badges */
        .rep-badge {
            display: inline-flex;
            align-items: center;
            gap: 2px;
            background: linear-gradient(135deg, var(--accent-dim), var(--highlight));
            color: white;
            padding: 2px 6px;
            border-radius: 10px;
            font-size: 0.75rem;
            margin-left: 6px;
            cursor: help;
        }

        .rep-badge.small {
            background: var(--border-color);
            color: var(--text-dim);
        }

        .post-image {
            width: 100%;
            max-height: 400px;
            object-fit: contain;
            background: #000;
            display: block;
        }

        .post-caption {
            padding: 12px;
            font-size: 1.1rem;
            line-height: 1.4;
            border-top: 1px solid var(--border-color);
        }

        /* Post Tags */
        .post-tags {
            display: flex;
            flex-wrap: wrap;
            gap: 6px;
            padding: 8px 12px;
            border-top: 1px solid var(--border-color);
        }

        .tag {
            background: linear-gradient(135deg, rgba(124, 152, 133, 0.2), rgba(169, 196, 176, 0.1));
            border: 1px solid var(--accent-dim);
            border-radius: 4px;
            padding: 3px 8px;
            font-size: 0.85rem;
            color: var(--accent-light);
            cursor: pointer;
            transition: all 0.2s;
        }

        .tag:hover {
            background: var(--accent-dim);
            color: white;
        }

        .tag.nested {
            background: linear-gradient(135deg, rgba(201, 168, 124, 0.2), rgba(201, 168, 124, 0.1));
            border-color: var(--highlight);
            color: var(--highlight);
        }

        .tag.nested:hover {
            background: var(--highlight);
            color: var(--dark-bg);
        }

        .tag-hierarchy {
            font-size: 0.7rem;
            opacity: 0.7;
            margin-right: 2px;
        }

        /* Tag Filter Bar */
        .tag-filter-bar {
            display: none;
            padding: 8px 12px;
            background: var(--dark-bg);
            border-bottom: 1px solid var(--border-color);
            align-items: center;
            gap: 8px;
            flex-shrink: 0;
        }

        .tag-filter-bar.active {
            display: flex;
        }

        /* Ensure posts container takes remaining space */
        .posts-container.active {
            display: flex;
            flex-direction: column;
            flex: 1;
            min-height: 0;
            overflow-y: auto;
        }

        .tag-filter-bar .tag {
            background: var(--accent);
            color: white;
        }

        .clear-filter {
            background: none;
            border: none;
            color: var(--text-dim);
            cursor: pointer;
            font-size: 1.2rem;
            padding: 0 8px;
        }

        .clear-filter:hover {
            color: #ff6666;
        }

        /* Trending Tags */
        .trending-tags {
            padding: 12px;
            border-top: 1px solid var(--border-color);
        }

        .trending-title {
            font-size: 0.8rem;
            color: var(--text-dim);
            margin-bottom: 8px;
            text-transform: uppercase;
            letter-spacing: 0.1em;
        }

        .trending-list {
            display: flex;
            flex-wrap: wrap;
            gap: 6px;
        }

        .trending-tag {
            background: rgba(255,255,255,0.05);
            border: 1px solid var(--border-color);
            border-radius: 12px;
            padding: 4px 10px;
            font-size: 0.8rem;
            color: var(--accent);
            cursor: pointer;
            transition: all 0.2s;
        }

        .trending-tag:hover {
            border-color: var(--accent);
            background: rgba(124, 152, 133, 0.2);
        }

        .trending-tag .count,
        .trending-tag .tag-count {
            color: var(--text-dim);
            font-size: 0.7rem;
            margin-left: 4px;
        }

        .trending-tag.hot {
            background: linear-gradient(135deg, rgba(255,100,100,0.2), rgba(255,150,100,0.1));
            border-color: #ff6666;
            color: #ff9999;
        }

        .trending-tag.warm {
            background: linear-gradient(135deg, rgba(201,168,124,0.2), rgba(201,168,124,0.1));
            border-color: var(--highlight);
            color: var(--highlight);
        }

        .trending-tags-section {
            margin-top: 12px;
            padding-top: 12px;
            border-top: 1px solid var(--border-color);
            flex-shrink: 0;
        }

        .trending-tags-list {
            display: flex;
            flex-direction: column;
            gap: 6px;
            max-height: 30vh;
            overflow-y: auto;
        }

        .trending-tags-list .trending-tag {
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        /* Tag Input */
        .tag-input-container {
            display: flex;
            flex-wrap: wrap;
            gap: 6px;
            padding: 8px;
            background: var(--dark-bg);
            border: 1px solid var(--border-color);
            min-height: 40px;
            align-items: center;
        }

        .tag-input-container .tag {
            display: flex;
            align-items: center;
            gap: 4px;
        }

        .tag-input-container .tag .remove {
            cursor: pointer;
            opacity: 0.7;
        }

        .tag-input-container .tag .remove:hover {
            opacity: 1;
        }

        .tag-input {
            flex: 1;
            min-width: 100px;
            background: transparent;
            border: none;
            color: var(--accent);
            font-family: inherit;
            font-size: 0.9rem;
            outline: none;
        }

        .tag-input::placeholder {
            color: var(--text-dim);
        }

        .post-actions {
            display: flex;
            gap: 16px;
            padding: 10px 12px;
            border-top: 1px solid var(--border-color);
        }

        .post-action-btn {
            background: none;
            border: none;
            color: var(--text-dim);
            font-family: inherit;
            font-size: 1rem;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 6px;
            transition: color 0.2s;
        }

        .post-action-btn:hover {
            color: var(--accent-light);
        }

        .post-action-btn.liked {
            color: #ff4466;
        }

        /* Emoji Reactions */
        .post-reactions {
            display: flex;
            flex-wrap: wrap;
            gap: 6px;
            padding: 8px 12px;
            border-top: 1px solid var(--border-color);
        }

        .reaction-btn {
            background: rgba(255,255,255,0.05);
            border: 1px solid var(--border-color);
            border-radius: 16px;
            padding: 4px 10px;
            font-size: 0.9rem;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 4px;
            transition: all 0.2s;
        }

        .reaction-btn:hover {
            background: rgba(255,255,255,0.1);
            border-color: var(--accent);
        }

        .reaction-btn.active {
            background: rgba(124, 152, 133, 0.2);
            border-color: var(--accent);
        }

        .reaction-count {
            font-size: 0.8rem;
            color: var(--text-dim);
        }

        .add-reaction-btn {
            background: transparent;
            border: 1px dashed var(--border-color);
            border-radius: 16px;
            padding: 4px 10px;
            font-size: 0.9rem;
            cursor: pointer;
            color: var(--text-dim);
            transition: all 0.2s;
        }

        .add-reaction-btn:hover {
            border-color: var(--accent);
            color: var(--accent);
        }

        .reaction-picker {
            display: none;
            position: absolute;
            bottom: 100%;
            left: 0;
            background: var(--panel-bg);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            padding: 8px;
            gap: 4px;
            flex-wrap: wrap;
            max-width: 200px;
            z-index: 10;
        }

        .reaction-picker.active {
            display: flex;
        }

        .reaction-picker button {
            background: none;
            border: none;
            font-size: 1.2rem;
            cursor: pointer;
            padding: 4px;
            border-radius: 4px;
            transition: background 0.2s;
        }

        .reaction-picker button:hover {
            background: rgba(255,255,255,0.1);
        }

        .post-comments {
            border-top: 1px solid var(--border-color);
            max-height: 200px;
            overflow-y: auto;
        }

        .comment {
            display: flex;
            gap: 8px;
            padding: 8px 12px;
            border-bottom: 1px solid rgba(255,255,255,0.05);
        }

        .comment-avatar {
            font-size: 16px;
        }

        .comment-content {
            flex: 1;
        }

        .comment-username {
            color: var(--accent);
            font-size: 0.95rem;
        }

        .comment-text {
            color: var(--accent-light);
            font-size: 1rem;
        }

        .comment-input-row {
            display: flex;
            gap: 8px;
            padding: 8px 12px;
            border-top: 1px solid var(--border-color);
        }

        .comment-input {
            flex: 1;
            background: var(--dark-bg);
            border: 1px solid var(--border-color);
            padding: 8px 12px;
            color: var(--accent-light);
            font-family: inherit;
            font-size: 1rem;
        }

        .comment-input:focus {
            outline: none;
            border-color: var(--accent-dim);
        }

        .comment-send {
            background: var(--accent-dim);
            border: none;
            color: white;
            padding: 8px 16px;
            font-family: inherit;
            cursor: pointer;
        }

        .comment-send:hover {
            background: var(--accent);
        }

        /* Threaded Comments - natural cascade */
        .comment-replies {
            margin-left: 12px;
            padding-left: 12px;
            border-left: 1px solid var(--border-color);
            margin-top: 4px;
        }

        .comment-thread {
            margin-top: 6px;
        }

        .comment-actions {
            display: flex;
            gap: 12px;
            margin-top: 4px;
        }

        .comment-reply-btn {
            background: none;
            border: none;
            color: var(--text-dim);
            font-family: inherit;
            font-size: 0.8rem;
            cursor: pointer;
            padding: 0;
        }

        .comment-reply-btn:hover {
            color: var(--accent);
        }

        .comment-vote-controls {
            display: inline-flex;
            align-items: center;
            gap: 2px;
            margin-left: 8px;
        }

        .comment-vote-btn {
            background: none;
            border: none;
            color: var(--text-dim);
            font-size: 0.75rem;
            cursor: pointer;
            padding: 0 2px;
            opacity: 0.7;
        }

        .comment-vote-btn:hover { opacity: 1; }
        .comment-vote-btn.upvote:hover, .comment-vote-btn.upvote.active { color: #00ff41; opacity: 1; }
        .comment-vote-btn.downvote:hover, .comment-vote-btn.downvote.active { color: #ff4444; opacity: 1; }
        .comment-vote-btn.disabled { opacity: 0.3; cursor: not-allowed; }

        .comment-vote-score {
            font-size: 0.75rem;
            min-width: 16px;
            text-align: center;
            color: var(--text-dim);
        }
        .comment-vote-score.positive { color: #00ff41; }
        .comment-vote-score.negative { color: #ff4444; }

        .reply-indicator {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 6px 12px;
            background: rgba(124, 152, 133, 0.1);
            border-left: 3px solid var(--accent);
            margin-bottom: 4px;
            font-size: 0.85rem;
        }

        .reply-indicator .cancel-reply {
            background: none;
            border: none;
            color: var(--text-dim);
            cursor: pointer;
            font-size: 1rem;
            padding: 0 4px;
        }

        .reply-indicator .cancel-reply:hover {
            color: #ff6b6b;
        }

        .comment-time {
            color: var(--text-dim);
            font-size: 0.75rem;
            margin-left: 8px;
        }

        /* Create Post Button */
        .create-post-btn {
            position: fixed;
            bottom: 80px;
            right: 20px;
            width: 56px;
            height: 56px;
            border-radius: 50%;
            background: var(--accent-dim);
            border: 2px solid var(--accent);
            color: white;
            font-size: 28px;
            cursor: pointer;
            z-index: 50;
            display: none;
            align-items: center;
            justify-content: center;
            transition: all 0.2s;
        }

        .create-post-btn.visible {
            display: flex;
        }

        .create-post-btn:hover {
            background: var(--accent);
            transform: scale(1.1);
        }

        /* Post Modal */
        .post-modal .modal {
            max-width: 500px;
        }

        .post-preview {
            margin-bottom: 16px;
            border: 1px solid var(--border-color);
            background: #000;
            min-height: 100px;
            display: flex;
            align-items: center;
            justify-content: center;
            color: var(--text-dim);
        }

        .post-preview img {
            max-width: 100%;
            max-height: 300px;
            display: block;
        }

        .post-preview.has-image {
            min-height: auto;
        }

        .or-divider {
            text-align: center;
            margin: 12px 0;
            color: var(--text-dim);
        }

    </style>
</head>
<body>
    <div class="app">
        <div class="header">
            <div class="logo">
                <span>ðŸ’¾</span>
                <span>SLOPPYGRAM<span class="logo-blink">_</span></span>
            </div>
            <div class="marquee-container">
                <div class="marquee">
                    â˜… WELCOME TO THE CYBER ZONE â˜… GLOBAL CHAT â˜… EST. 1999 â˜… VISITORS: <span id="visitorCount">???</span> â˜…
                </div>
            </div>
            <div class="header-actions">
                <button class="cyber-btn mobile-toggle" onclick="toggleSidebar('left')">USERS</button>
                <button class="cyber-btn mobile-toggle" onclick="toggleSidebar('right')">FEED</button>
                <button class="cyber-btn" onclick="openProfileModal()">PROFILE</button>
            </div>
        </div>

        <div class="mobile-backdrop" id="mobileBackdrop" onclick="closeSidebars()"></div>

        <div class="sidebar-left" id="sidebarLeft">
            <button class="sidebar-close-btn" onclick="closeSidebars()">Ã—</button>
            <div class="panel-title">[ ONLINE USERS ]</div>
            <ul class="user-list" id="userList">
            </ul>
        </div>

        <div class="main-content">
            <div class="view-tabs">
                <button class="view-tab active" data-view="chat" onclick="switchView('chat')">ðŸ’¬ CHAT</button>
                <button class="view-tab" data-view="posts" onclick="switchView('posts')">ðŸ“¸ POSTS</button>
                <button class="view-tab" data-view="doodles" onclick="switchView('doodles')">ðŸ† DOODLES</button>
                <button class="view-tab" data-view="manifesto" onclick="switchView('manifesto')">ðŸ“œ MANIFESTO</button>
            </div>
            <div class="messages-container" id="messagesContainer">
                <div class="empty-state" id="emptyState">
                    <div class="icon">ðŸ’¾</div>
                    <p>INITIALIZING CHAT PROTOCOL...</p>
                    <p>Say something!</p>
                </div>
            </div>
            <div class="transparency-bar" id="transparencyBar">
                <label for="msgOpacitySlider">ðŸ’¬ Message opacity:</label>
                <input type="range" id="msgOpacitySlider" min="0" max="100" value="95" oninput="setMessageOpacity(this.value)">
                <span id="opacityValue">95%</span>
            </div>
            <div class="input-area" id="chatInputArea">
                <div class="image-preview" id="imagePreview">
                    <img id="previewImg" src="">
                    <button class="remove-btn" onclick="removeImage()">Ã—</button>
                </div>
                <div class="input-row">
                    <div class="input-actions">
                        <button class="action-btn" onclick="document.getElementById('imageInput').click()">ðŸ“·</button>
                        <button class="action-btn" onclick="openDrawingModal()">ðŸŽ¨</button>
                    </div>
                    <input type="file" id="imageInput" accept="image/*" onchange="handleImageSelect(event)">
                    <textarea class="message-input" id="messageInput" placeholder="Type a message..." rows="1"></textarea>
                    <button class="send-btn" onclick="sendMessage()">SEND</button>
                </div>
            </div>
            <div class="tag-filter-bar" id="tagFilterBar">
                <span style="color:var(--text-dim);font-size:0.85rem;">Filtering by:</span>
                <span class="tag" id="activeFilterTag"></span>
                <button class="clear-filter" onclick="clearTagFilter()">Ã—</button>
            </div>
            <div class="posts-container" id="postsContainer">
                <div class="empty-state" id="postsEmptyState">
                    <div class="icon">ðŸ“¸</div>
                    <p>NO POSTS YET...</p>
                    <p>Be the first to share!</p>
                </div>
            </div>
            <div class="doodles-container" id="doodlesContainer">
                <div class="leaderboard-header">ðŸ† LEGENDARY DOODLES ðŸ†</div>
                <div class="empty-doodles" id="doodlesEmptyState">
                    <div class="icon">ðŸŽ¨</div>
                    <p>NO LEGENDARY DOODLES YET...</p>
                    <p>Draw something and get votes!</p>
                </div>
            </div>
            <div class="manifesto-container" id="manifestoContainer">
                <div class="manifesto-header">
                    <h2>ðŸ“œ THE MANIFESTO BOARD ðŸ“œ</h2>
                    <p class="manifesto-subtitle">Declare your ideas. Shape the future.</p>
                    <button class="cyber-btn" onclick="openManifestoModal()">âœï¸ WRITE MANIFESTO</button>
                </div>
                <div class="manifesto-list" id="manifestoList">
                    <div class="empty-state" id="manifestoEmptyState">
                        <div class="icon">ðŸ“œ</div>
                        <p>NO MANIFESTOS YET...</p>
                        <p>Be the first to declare your vision!</p>
                    </div>
                </div>
            </div>
        </div>

        <div class="sidebar-right" id="sidebarRight">
            <button class="sidebar-close-btn" onclick="closeSidebars()">Ã—</button>
            <div class="panel-title">[ PUBLIC FEED ]</div>
            <div id="publicFeed">
                <div class="feed-item">
                    <span class="feed-user">System</span>
                    <span class="feed-action">initialized</span>
                    <div class="feed-time">just now</div>
                </div>
            </div>
            <div class="trending-tags-section" id="trendingTagsSection">
                <div class="panel-title">[ TRENDING TAGS ]</div>
                <div id="trendingTagsList" class="trending-tags-list">
                    <div style="font-size:0.85rem;color:var(--text-dim)">Loading tags...</div>
                </div>
            </div>
        </div>
    </div>

    <!-- Profile Modal -->
    <div class="modal-overlay" id="profileModal">
        <div class="modal">
            <h2>
                <span>ðŸ‘¤</span> PROFILE CONFIG
                <button class="modal-close" onclick="closeProfileModal()">Ã—</button>
            </h2>

            <div class="form-group">
                <label>USERNAME:</label>
                <input type="text" id="usernameInput" placeholder="Enter handle..." maxlength="20">
            </div>

            <div class="form-group">
                <label>SELECT AVATAR:</label>
                <div class="avatar-grid" id="avatarGrid"></div>
            </div>

            <div class="form-group">
                <label>CUSTOM AVATAR (upload image):</label>
                <div class="file-upload-row">
                    <input type="file" id="avatarFileInput" accept="image/*" onchange="handleAvatarUpload(event)" style="display:none">
                    <button class="file-upload-btn" onclick="document.getElementById('avatarFileInput').click()">ðŸ“ CHOOSE FILE</button>
                    <button class="file-clear-btn" onclick="clearAvatarUpload()" id="clearAvatarBtn" style="display:none">âœ• CLEAR</button>
                </div>
                <div class="upload-preview" id="avatarPreview" style="display:none">
                    <img id="avatarPreviewImg" src="">
                </div>
            </div>

            <div class="form-group">
                <label>AVATAR COLOR:</label>
                <div class="color-options" id="colorOptions"></div>
            </div>

            <div class="form-group">
                <label>CUSTOM BACKGROUND (upload image):</label>
                <div class="file-upload-row">
                    <input type="file" id="bgFileInput" accept="image/*" onchange="handleBgUpload(event)" style="display:none">
                    <button class="file-upload-btn" onclick="document.getElementById('bgFileInput').click()">ðŸ“ UPLOAD NEW</button>
                    <button class="file-upload-btn" onclick="shareBackground()" id="shareBgBtn" style="display:none">ðŸŒ SHARE</button>
                    <button class="file-upload-btn" onclick="setGlobalBackground()" id="setGlobalBgBtn" style="display:none;background:#4a1a7a;">ðŸŒ SET FOR ALL</button>
                    <button class="file-clear-btn" onclick="clearBgUpload()" id="clearBgBtn" style="display:none">âœ•</button>
                </div>
                <div class="upload-preview" id="bgPreview" style="display:none">
                    <img id="bgPreviewImg" src="">
                </div>
                <div class="global-bg-section">
                    <div class="global-bg-label">Or choose a shared background:</div>
                    <div class="global-bg-grid" id="globalBgGrid">
                        <div class="global-bg-item global-bg-upload" onclick="document.getElementById('bgFileInput').click()" title="Upload new">+</div>
                    </div>
                </div>
            </div>

            <button class="modal-btn" onclick="saveProfile()">[ SAVE ]</button>
            <button class="modal-btn" style="background: #3a2020; margin-top: 8px;" onclick="resetProfile()">[ RESET ALL ]</button>
        </div>
    </div>

    <!-- Drawing Modal -->
    <div class="modal-overlay drawing-modal" id="drawingModal">
        <div class="modal">
            <h2>
                <span>ðŸŽ¨</span> PIXEL CANVAS
                <button class="modal-close" onclick="closeDrawingModal()">Ã—</button>
            </h2>

            <div class="canvas-tools">
                <div class="brush-colors" id="brushColors"></div>
                <button class="tool-btn" onclick="clearCanvas()">CLEAR</button>
            </div>

            <div class="canvas-container">
                <canvas id="drawingCanvas" width="400" height="300"></canvas>
            </div>

            <button class="modal-btn" onclick="sendDrawing()">[ TRANSMIT ]</button>
        </div>
    </div>

    <!-- Create Post Modal -->
    <div class="modal-overlay post-modal" id="postModal">
        <div class="modal">
            <h2>
                <span>ðŸ“¸</span> NEW POST
                <button class="modal-close" onclick="closePostModal()">Ã—</button>
            </h2>

            <div class="post-preview" id="postPreview">
                <span>No image selected</span>
            </div>

            <div class="form-group">
                <label>IMAGE URL:</label>
                <input type="text" id="postImageUrl" placeholder="https://example.com/image.jpg" oninput="previewPostImage()">
            </div>

            <div class="or-divider">â€” OR â€”</div>

            <div class="form-group">
                <label>UPLOAD FILE:</label>
                <input type="file" id="postFileInput" accept="image/*" onchange="handlePostFileSelect(event)" style="display:block;background:var(--dark-bg);padding:8px;border:1px solid var(--border-color);color:var(--accent-light);width:100%;">
            </div>

            <div class="form-group">
                <label>CAPTION:</label>
                <input type="text" id="postCaption" placeholder="Write something..." maxlength="280">
            </div>

            <div class="form-group">
                <label>TAGS (use parent/child for nested):</label>
                <div class="tag-input-container" id="tagInputContainer">
                    <input type="text" class="tag-input" id="tagInput" placeholder="Type tag and press Enter... (e.g. art/digital)" onkeydown="handleTagInput(event)">
                </div>
                <div style="font-size:0.75rem;color:var(--text-dim);margin-top:4px;">
                    Tip: Use "/" for nested tags like "meme/cursed" or "art/pixel"
                </div>
            </div>

            <button class="modal-btn" onclick="submitPost()">[ POST IT ]</button>
        </div>
    </div>

    <!-- Create Post FAB -->
    <button class="create-post-btn" id="createPostBtn" onclick="openPostModal()">+</button>

    <!-- Create Manifesto Modal -->
    <div class="modal-overlay" id="manifestoModal">
        <div class="modal manifesto-modal">
            <h2>
                <span>ðŸ“œ</span> WRITE YOUR MANIFESTO
                <button class="modal-close" onclick="closeManifestoModal()">Ã—</button>
            </h2>

            <div class="form-group">
                <label>TITLE:</label>
                <input type="text" id="manifestoTitle" placeholder="Your manifesto title..." maxlength="100">
            </div>

            <div class="form-group">
                <label>YOUR VISION:</label>
                <textarea id="manifestoContent" placeholder="Declare your ideas, beliefs, and vision for the future..." rows="8" maxlength="2000" style="width:100%;background:var(--dark-bg);border:1px solid var(--border-color);color:var(--accent-light);padding:10px;font-family:inherit;resize:vertical;"></textarea>
                <div style="font-size:0.75rem;color:var(--text-dim);margin-top:4px;text-align:right;">
                    <span id="manifestoCharCount">0</span>/2000
                </div>
            </div>

            <div class="form-group">
                <label>TAGS (use parent/child for nested):</label>
                <div class="tag-input-container" id="manifestoTagInputContainer">
                    <input type="text" class="tag-input" id="manifestoTagInput" placeholder="Type tag and press Enter... (e.g. philosophy/ethics)" onkeydown="handleManifestoTagInput(event)">
                </div>
                <div style="font-size:0.75rem;color:var(--text-dim);margin-top:4px;">
                    Tip: Use "/" for nested tags like "tech/ai" or "society/future"
                </div>
            </div>

            <button class="modal-btn" onclick="submitManifesto()">[ DECLARE IT ]</button>
        </div>
    </div>

    <script type="module">
        import { createClient } from "https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2/+esm";

        const SUPABASE_URL = 'https://yjyxteqzhhmtrgcaekgz.supabase.co';
        const SUPABASE_ANON_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InlqeXh0ZXF6aGhtdHJnY2Fla2d6Iiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTczNTg3NDIsImV4cCI6MjA3MjkzNDc0Mn0.G8SRde7IN2QFW1EnASM8IS32IUYR2eenCCjdDdioiBU';
        const supabase = createClient(SUPABASE_URL, SUPABASE_ANON_KEY, {
            auth: {
                persistSession: true,
                storageKey: 'sloppygram-auth',
                autoRefreshToken: true,
                detectSessionInUrl: false
            }
        });

        // Avatar options
        const AVATARS = ['ðŸ˜€', 'ðŸ˜Ž', 'ðŸ¤–', 'ðŸ‘½', 'ðŸ±', 'ðŸ¶', 'ðŸ¦Š', 'ðŸ¼', 'ðŸ¸', 'ðŸ¦„', 'ðŸ²', 'ðŸ‘»', 'ðŸ’€', 'ðŸŽƒ', 'ðŸ¤¡', 'ðŸ‘¾', 'ðŸ¥·', 'ðŸ§™'];
        const COLORS = ['#00ff41', '#00ffff', '#ff00ff', '#ffff00', '#ff4444', '#ff8800', '#8844ff', '#44ff88', '#ff44aa', '#44aaff'];
        const BRUSH_COLORS = ['#00ff41', '#00ffff', '#ff00ff', '#ffff00', '#ff4444', '#ffffff', '#000000', '#888888'];

        let currentUser = null;
        let profile = {
            username: 'Anon' + Math.floor(Math.random() * 9999),
            avatar: AVATARS[Math.floor(Math.random() * AVATARS.length)],
            color: COLORS[Math.floor(Math.random() * COLORS.length)],
            avatarUrl: '',
            bgUrl: ''
        };
        let selectedImage = null;
        let drawingCtx = null;
        let isDrawing = false;
        let brushColor = '#00ff41';
        const seenMessageIds = new Set();
        let onlineUsers = new Map();
        let realtimeChannel = null;
        let currentView = 'chat';
        let posts = [];
        let postLikes = {};
        let postComments = {};
        let postReactions = {}; // { postId: { emoji: count, ... } }
        let myReactions = {}; // { postId: Set of emojis I've reacted with }
        const REACTION_EMOJIS = ['ðŸ˜‚', 'ðŸ”¥', 'â¤ï¸', 'ðŸ˜®', 'ðŸ˜¢', 'ðŸ‘', 'ðŸ™Œ', 'ðŸ’€'];
        let globalBackgrounds = [];
        let postImageData = null;
        let doodleVotes = {}; // { messageId: netScore }
        let myDoodleVotes = {}; // { messageId: 1 or -1 } for my vote type
        let messageVotes = {}; // { messageId: netScore } for chat messages
        let myMessageVotes = {}; // { messageId: 1 or -1 } for my vote type
        let postVotes = {}; // { postId: netScore }
        let myPostVotes = {}; // { postId: 1 or -1 } for my vote type
        let commentVotes = {}; // { commentId: netScore }
        let myCommentVotes = {}; // { commentId: 1 or -1 } for my vote type
        let postTags = {}; // { postId: [{ tag, parent_tag }, ...] }
        let pendingTags = []; // tags being added to new post
        let activeTagFilter = null; // current tag filter
        let commentThreads = {}; // { commentId: parentCommentId }
        let replyingTo = null; // { postId, commentId, username } when replying to a comment
        let userReputations = {}; // { username: { postLikes, manifestoVotes, total } }

        // Helper function to log AI events
        async function logAiEvent(eventType, entityType, entityId, metadata = {}) {
            if (!currentUser) return;
            try {
                await supabase.from('ai_events').insert({
                    event_type: eventType,
                    entity_type: entityType,
                    entity_id: entityId,
                    username: profile.username,
                    metadata: metadata,
                    user_id: currentUser.id
                });
            } catch (e) {
                console.error('Error logging AI event:', e);
            }
        }

        // Load saved profile
        const savedProfile = localStorage.getItem('sloppygram_profile');
        if (savedProfile) {
            profile = JSON.parse(savedProfile);
        }

        // Initialize
        async function init() {
            // Listen for auth state changes
            supabase.auth.onAuthStateChange((event, session) => {
                console.log('Auth state changed:', event);
                if (session) {
                    currentUser = session.user;
                }
            });

            // Auth - try to restore existing session first
            let { data: { session } } = await supabase.auth.getSession();
            if (!session) {
                console.log('No existing session, signing in anonymously...');
                const { data, error } = await supabase.auth.signInAnonymously();
                if (error) console.error('Auth error:', error);
                session = data?.session;
            } else {
                console.log('Restored existing session for user:', session.user?.id);
            }
            currentUser = session?.user;

            setupAvatarGrid();
            setupColorOptions();
            setupBrushColors();
            setupDrawingCanvas();
            loadMessageOpacity();
            await loadDoodleVotes();
            await loadMessageVotes();
            await loadCommentVotes();
            loadMessages();
            subscribeToMessages();
            subscribeToPostsAndComments();
            setupPresence();
            applyCustomBackground();

            // Random visitor count for 90s vibes
            document.getElementById('visitorCount').textContent = Math.floor(10000 + Math.random() * 90000);

            // Auto-resize textarea
            const input = document.getElementById('messageInput');
            input.addEventListener('input', () => {
                input.style.height = 'auto';
                input.style.height = Math.min(input.scrollHeight, 100) + 'px';
            });

            // Enter to send
            input.addEventListener('keydown', (e) => {
                if (e.key === 'Enter' && !e.shiftKey) {
                    e.preventDefault();
                    sendMessage();
                }
            });
        }

        // Presence for online users
        function setupPresence() {
            const presenceChannel = supabase.channel('sloppygram_presence', {
                config: {
                    presence: { key: currentUser?.id || 'anon_' + Math.random() }
                }
            });

            presenceChannel
                .on('presence', { event: 'sync' }, () => {
                    const state = presenceChannel.presenceState();
                    updateOnlineUsers(state);
                })
                .on('presence', { event: 'join' }, ({ key, newPresences }) => {
                    addToFeed(newPresences[0]?.username || 'Someone', 'joined the chat');
                })
                .on('presence', { event: 'leave' }, ({ key, leftPresences }) => {
                    addToFeed(leftPresences[0]?.username || 'Someone', 'left the chat');
                })
                .subscribe(async (status) => {
                    if (status === 'SUBSCRIBED') {
                        await presenceChannel.track({
                            username: profile.username,
                            avatar: profile.avatar,
                            avatarUrl: profile.avatarUrl || null,
                            color: profile.color,
                            online_at: new Date().toISOString()
                        });
                    }
                });
        }

        function updateOnlineUsers(state) {
            const userList = document.getElementById('userList');
            const users = [];

            // Add real users
            Object.values(state).forEach(presences => {
                presences.forEach(p => {
                    if (!users.find(u => u.username === p.username)) {
                        users.push(p);
                    }
                });
            });

            userList.innerHTML = users.map(u => {
                const avatarContent = u.avatarUrl
                    ? `<img src="${u.avatarUrl}" style="width:24px;height:24px;border-radius:50%;object-fit:cover;">`
                    : u.avatar;
                return `
                <li class="user-item">
                    <span class="user-status"></span>
                    <span class="user-avatar">${avatarContent}</span>
                    <span class="user-name" style="color: ${u.color || 'var(--accent-light)'}">${escapeHtml(u.username)}</span>
                </li>
            `}).join('');
        }

        function addToFeed(user, action) {
            const feed = document.getElementById('publicFeed');
            const time = new Date().toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });

            const item = document.createElement('div');
            item.className = 'feed-item';
            item.innerHTML = `
                <span class="feed-user">${escapeHtml(user)}</span>
                <span class="feed-action">${action}</span>
                <div class="feed-time">${time}</div>
            `;

            feed.insertBefore(item, feed.firstChild);

            // Keep only last 20 items
            while (feed.children.length > 20) {
                feed.removeChild(feed.lastChild);
            }
        }

        // Setup avatar grid
        function setupAvatarGrid() {
            const grid = document.getElementById('avatarGrid');
            grid.innerHTML = AVATARS.map(a =>
                `<button class="avatar-option ${a === profile.avatar ? 'selected' : ''}" onclick="selectAvatar('${a}')">${a}</button>`
            ).join('');
        }

        window.selectAvatar = function(avatar) {
            profile.avatar = avatar;
            document.querySelectorAll('.avatar-option').forEach(el => {
                el.classList.toggle('selected', el.textContent === avatar);
            });
        };

        // Setup color options
        function setupColorOptions() {
            const container = document.getElementById('colorOptions');
            container.innerHTML = COLORS.map(c =>
                `<button class="color-option ${c === profile.color ? 'selected' : ''}" style="background: ${c}" onclick="selectColor('${c}')"></button>`
            ).join('');
        }

        window.selectColor = function(color) {
            profile.color = color;
            document.querySelectorAll('.color-option').forEach(el => {
                el.classList.toggle('selected', el.style.background === color);
            });
        };

        // Setup brush colors
        function setupBrushColors() {
            const container = document.getElementById('brushColors');
            container.innerHTML = BRUSH_COLORS.map(c =>
                `<button class="brush-color ${c === brushColor ? 'selected' : ''}" style="background: ${c}" onclick="selectBrushColor('${c}')"></button>`
            ).join('');
        }

        window.selectBrushColor = function(color) {
            brushColor = color;
            document.querySelectorAll('.brush-color').forEach(el => {
                el.classList.toggle('selected', el.style.background === color);
            });
        };

        // Drawing canvas
        function setupDrawingCanvas() {
            const canvas = document.getElementById('drawingCanvas');
            drawingCtx = canvas.getContext('2d');
            drawingCtx.fillStyle = '#111';
            drawingCtx.fillRect(0, 0, canvas.width, canvas.height);
            drawingCtx.lineCap = 'round';
            drawingCtx.lineJoin = 'round';
            drawingCtx.lineWidth = 4;

            canvas.addEventListener('mousedown', startDrawing);
            canvas.addEventListener('mousemove', draw);
            canvas.addEventListener('mouseup', stopDrawing);
            canvas.addEventListener('mouseout', stopDrawing);

            canvas.addEventListener('touchstart', (e) => {
                e.preventDefault();
                const touch = e.touches[0];
                const rect = canvas.getBoundingClientRect();
                const offsetX = touch.clientX - rect.left;
                const offsetY = touch.clientY - rect.top;
                startDrawing({ offsetX, offsetY });
            }, { passive: false });

            canvas.addEventListener('touchmove', (e) => {
                e.preventDefault();
                const touch = e.touches[0];
                const rect = canvas.getBoundingClientRect();
                const offsetX = touch.clientX - rect.left;
                const offsetY = touch.clientY - rect.top;
                draw({ offsetX, offsetY });
            }, { passive: false });

            canvas.addEventListener('touchend', stopDrawing);
        }

        function getCanvasCoords(e) {
            const canvas = document.getElementById('drawingCanvas');
            const rect = canvas.getBoundingClientRect();
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;
            return {
                x: e.offsetX * scaleX,
                y: e.offsetY * scaleY
            };
        }

        function startDrawing(e) {
            isDrawing = true;
            const coords = getCanvasCoords(e);
            drawingCtx.beginPath();
            drawingCtx.moveTo(coords.x, coords.y);
        }

        function draw(e) {
            if (!isDrawing) return;
            const coords = getCanvasCoords(e);
            drawingCtx.strokeStyle = brushColor;
            drawingCtx.lineTo(coords.x, coords.y);
            drawingCtx.stroke();
        }

        function stopDrawing() {
            isDrawing = false;
        }

        window.clearCanvas = function() {
            const canvas = document.getElementById('drawingCanvas');
            drawingCtx.fillStyle = '#111';
            drawingCtx.fillRect(0, 0, canvas.width, canvas.height);
        };

        // Load messages (oldest first, newest at bottom)
        async function loadMessages() {
            const { data, error } = await supabase
                .from('sloppygram_messages')
                .select('*')
                .order('created_at', { ascending: true })
                .limit(100);

            if (error) {
                console.error('Load error:', error);
                return;
            }

            const container = document.getElementById('messagesContainer');
            const emptyState = document.getElementById('emptyState');

            if (data.length === 0) {
                emptyState.style.display = 'block';
                return;
            }

            emptyState.style.display = 'none';
            data.forEach(msg => {
                seenMessageIds.add(msg.id);
                addMessageToUI(msg, false); // append for initial load (oldest first)
            });
            container.scrollTop = container.scrollHeight; // scroll to bottom (newest)
        }

        // Subscribe to new messages
        function subscribeToMessages() {
            if (realtimeChannel) {
                supabase.removeChannel(realtimeChannel);
            }

            realtimeChannel = supabase.channel('sloppygram-global', {
                config: {
                    broadcast: { self: false }
                }
            });

            realtimeChannel.on('broadcast', { event: 'new_message' }, (payload) => {
                const msg = payload.payload;
                if (!msg || seenMessageIds.has(msg.id)) return;
                seenMessageIds.add(msg.id);
                addMessageToUI(msg);
                scrollToBottom();
                addToFeed(msg.username, 'sent a message');
            });

            // Listen for global background changes
            realtimeChannel.on('broadcast', { event: 'global_background' }, (payload) => {
                const bgData = payload.payload;
                if (bgData && bgData.image_data) {
                    const msgContainer = document.getElementById('messagesContainer');
                    if (msgContainer) {
                        msgContainer.style.backgroundImage = `url(${bgData.image_data})`;
                        msgContainer.style.backgroundSize = 'cover';
                        msgContainer.style.backgroundPosition = 'center';
                        msgContainer.style.backgroundAttachment = 'fixed';
                        msgContainer.style.backgroundRepeat = 'no-repeat';
                    }
                    addToFeed(bgData.username || 'Someone', 'changed the chat background');
                }
            });

            realtimeChannel.on('postgres_changes', {
                event: 'INSERT',
                schema: 'public',
                table: 'sloppygram_messages'
            }, (payload) => {
                if (seenMessageIds.has(payload.new.id)) return;
                seenMessageIds.add(payload.new.id);
                addMessageToUI(payload.new);
                scrollToBottom();
            });

            realtimeChannel.subscribe();
        }

        // Subscribe to posts and comments for real-time updates
        let postsChannel = null;
        function subscribeToPostsAndComments() {
            if (postsChannel) {
                supabase.removeChannel(postsChannel);
            }

            postsChannel = supabase.channel('sloppygram-posts-realtime');

            // Listen for new posts
            postsChannel.on('postgres_changes', {
                event: 'INSERT',
                schema: 'public',
                table: 'sloppygram_posts'
            }, (payload) => {
                console.log('New post received:', payload.new);
                // Add to posts array if not already there
                if (!posts.find(p => p.id === payload.new.id)) {
                    posts.unshift(payload.new);
                    if (currentView === 'posts') {
                        renderPosts();
                    }
                }
            });

            // Listen for new comments
            postsChannel.on('postgres_changes', {
                event: 'INSERT',
                schema: 'public',
                table: 'sloppygram_post_comments'
            }, (payload) => {
                console.log('New comment received:', payload.new);
                const comment = payload.new;
                if (!postComments[comment.post_id]) {
                    postComments[comment.post_id] = [];
                }
                // Add if not already there
                if (!postComments[comment.post_id].find(c => c.id === comment.id)) {
                    postComments[comment.post_id].push(comment);
                    if (currentView === 'posts') {
                        renderPosts();
                    }
                }
            });

            // Listen for comment thread relationships
            postsChannel.on('postgres_changes', {
                event: 'INSERT',
                schema: 'public',
                table: 'sloppygram_comment_threads'
            }, (payload) => {
                console.log('New thread relationship:', payload.new);
                const thread = payload.new;
                commentThreads[thread.comment_id] = thread.parent_comment_id;
                if (currentView === 'posts') {
                    renderPosts();
                }
            });

            // Listen for new reactions
            postsChannel.on('postgres_changes', {
                event: '*',
                schema: 'public',
                table: 'sloppygram_post_reactions'
            }, (payload) => {
                console.log('Reaction change:', payload);
                // Reload reactions for affected post
                if (payload.new?.post_id || payload.old?.post_id) {
                    loadPosts(); // Simple reload for now
                }
            });

            // Listen for likes
            postsChannel.on('postgres_changes', {
                event: '*',
                schema: 'public',
                table: 'sloppygram_post_likes'
            }, (payload) => {
                console.log('Like change:', payload);
                if (payload.new?.post_id || payload.old?.post_id) {
                    loadPosts();
                }
            });

            // Listen for manifesto comments
            postsChannel.on('postgres_changes', {
                event: 'INSERT',
                schema: 'public',
                table: 'sloppygram_manifesto_comments'
            }, (payload) => {
                console.log('New manifesto comment:', payload.new);
                const comment = payload.new;
                if (!manifestoComments[comment.manifesto_id]) {
                    manifestoComments[comment.manifesto_id] = [];
                }
                if (!manifestoComments[comment.manifesto_id].find(c => c.id === comment.id)) {
                    manifestoComments[comment.manifesto_id].push(comment);
                    if (currentView === 'manifesto') {
                        renderManifestos();
                    }
                }
            });

            // Listen for new manifestos
            postsChannel.on('postgres_changes', {
                event: 'INSERT',
                schema: 'public',
                table: 'sloppygram_manifestos'
            }, (payload) => {
                console.log('New manifesto:', payload.new);
                if (!manifestos.find(m => m.id === payload.new.id)) {
                    manifestos.unshift(payload.new);
                    if (currentView === 'manifesto') {
                        renderManifestos();
                    }
                }
            });

            // Listen for manifesto votes
            postsChannel.on('postgres_changes', {
                event: '*',
                schema: 'public',
                table: 'sloppygram_manifesto_votes'
            }, (payload) => {
                console.log('Manifesto vote change:', payload);
                loadManifestos();
            });

            // Listen for manifesto reactions
            postsChannel.on('postgres_changes', {
                event: '*',
                schema: 'public',
                table: 'sloppygram_manifesto_reactions'
            }, (payload) => {
                console.log('Manifesto reaction change:', payload);
                loadManifestos();
            });

            // Listen for doodle votes
            postsChannel.on('postgres_changes', {
                event: '*',
                schema: 'public',
                table: 'sloppygram_doodle_votes'
            }, (payload) => {
                console.log('Doodle vote change:', payload);
                loadDoodleVotes();
                if (currentView === 'doodles') {
                    loadDoodleLeaderboard();
                }
            });

            // Listen for post tags (trending tags)
            postsChannel.on('postgres_changes', {
                event: '*',
                schema: 'public',
                table: 'sloppygram_post_tags'
            }, (payload) => {
                console.log('Post tag change:', payload);
                loadPosts(); // Reload to update trending tags
            });

            // Listen for manifesto tags
            postsChannel.on('postgres_changes', {
                event: '*',
                schema: 'public',
                table: 'sloppygram_manifesto_tags'
            }, (payload) => {
                console.log('Manifesto tag change:', payload);
                loadManifestos();
            });

            // Listen for global backgrounds
            postsChannel.on('postgres_changes', {
                event: 'INSERT',
                schema: 'public',
                table: 'sloppygram_global_backgrounds'
            }, (payload) => {
                console.log('New global background:', payload.new);
                globalBackgrounds.unshift(payload.new);
                renderGlobalBackgrounds(); // Update UI for all users
            });

            // Listen for chat message votes
            postsChannel.on('postgres_changes', {
                event: '*',
                schema: 'public',
                table: 'sloppygram_message_votes'
            }, (payload) => {
                console.log('Message vote change:', payload);
                loadMessageVotes();
            });

            // Listen for comment votes
            postsChannel.on('postgres_changes', {
                event: '*',
                schema: 'public',
                table: 'sloppygram_comment_votes'
            }, (payload) => {
                console.log('Comment vote change:', payload);
                loadCommentVotes().then(() => renderPosts());
            });

            postsChannel.subscribe((status) => {
                console.log('Posts realtime subscription status:', status);
            });
        }

        function broadcastMessage(msg) {
            if (realtimeChannel) {
                realtimeChannel.send({
                    type: 'broadcast',
                    event: 'new_message',
                    payload: msg
                });
            }
        }

        function scrollToBottom() {
            const container = document.getElementById('messagesContainer');
            container.scrollTop = container.scrollHeight;
        }

        // Add message to UI (append by default for bottom-up chat flow)
        function addMessageToUI(msg, prepend = false) {
            const container = document.getElementById('messagesContainer');
            document.getElementById('emptyState').style.display = 'none';

            const isOwn = msg.user_id === currentUser?.id;
            const time = new Date(msg.created_at).toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });

            const div = document.createElement('div');
            div.className = `message ${isOwn ? 'own' : ''}`;

            let contentHTML = '';
            if (msg.content) {
                contentHTML = `<div class="message-content">${escapeHtml(msg.content)}</div>`;
            }
            if (msg.image_data) {
                contentHTML += `<img class="message-image" src="${msg.image_data}" onclick="window.open(this.src)">`;
            }
            if (msg.drawing_data) {
                const doodleId = msg.id;
                const isRealDoodleId = typeof doodleId === 'number' || (typeof doodleId === 'string' && !doodleId.startsWith('temp_'));
                const doodleScore = doodleVotes[doodleId] || 0;
                const myDoodleVote = myDoodleVotes[doodleId] || 0;
                const isOwnDoodle = msg.username === profile.username;
                const doodleScoreClass = doodleScore > 0 ? 'positive' : doodleScore < 0 ? 'negative' : 'neutral';
                const doodleVoteControls = isRealDoodleId ? `
                    <div class="vote-controls doodle-votes" data-doodle-id="${doodleId}">
                        <button class="vote-btn upvote ${myDoodleVote === 1 ? 'active' : ''} ${isOwnDoodle ? 'disabled' : ''}"
                            onclick="${isOwnDoodle ? '' : `voteDoodle('${doodleId}', 1, '${escapeHtml(msg.username)}')`}"
                            title="${isOwnDoodle ? 'Cannot vote on own doodle' : 'Upvote'}">â–²</button>
                        <span class="vote-score ${doodleScoreClass}">${doodleScore}</span>
                        <button class="vote-btn downvote ${myDoodleVote === -1 ? 'active' : ''} ${isOwnDoodle ? 'disabled' : ''}"
                            onclick="${isOwnDoodle ? '' : `voteDoodle('${doodleId}', -1, '${escapeHtml(msg.username)}')`}"
                            title="${isOwnDoodle ? 'Cannot vote on own doodle' : 'Downvote'}">â–¼</button>
                    </div>` : '';
                contentHTML += `
                    <div class="doodle-wrapper">
                        <img class="message-drawing" src="${msg.drawing_data}">
                        ${doodleVoteControls}
                    </div>`;
            }

            // Vote controls for non-doodle messages
            const msgId = msg.id;
            const isRealId = typeof msgId === 'number' || (typeof msgId === 'string' && !msgId.startsWith('temp_'));
            const isOwnMessage = msg.username === profile.username;
            const chatVoteScore = messageVotes[msgId] || 0;
            const myVoteType = myMessageVotes[msgId] || 0;
            const scoreClass = chatVoteScore > 0 ? 'positive' : chatVoteScore < 0 ? 'negative' : 'neutral';
            const chatVoteBtn = (isRealId && !msg.drawing_data) ? `
                <div class="message-footer">
                    <div class="vote-controls" data-chat-id="${msgId}">
                        <button class="vote-btn upvote ${myVoteType === 1 ? 'active' : ''} ${isOwnMessage ? 'disabled' : ''}"
                            onclick="${isOwnMessage ? '' : `voteMessage('${msgId}', 1)`}" title="${isOwnMessage ? 'Cannot vote on own content' : 'Upvote'}">â–²</button>
                        <span class="vote-score ${scoreClass}">${chatVoteScore}</span>
                        <button class="vote-btn downvote ${myVoteType === -1 ? 'active' : ''} ${isOwnMessage ? 'disabled' : ''}"
                            onclick="${isOwnMessage ? '' : `voteMessage('${msgId}', -1)`}" title="${isOwnMessage ? 'Cannot vote on own content' : 'Downvote'}">â–¼</button>
                    </div>
                </div>` : '';

            const avatarContent = msg.avatarUrl
                ? `<img src="${msg.avatarUrl}" alt="avatar" style="width:100%;height:100%;object-fit:cover;border-radius:50%;">`
                : (msg.avatar || 'ðŸ‘¤');
            const deleteBtn = (isOwnMessage && isRealId) ? `<button class="msg-delete-btn" onclick="deleteMessage('${msgId}')" title="Delete">ðŸ—‘ï¸</button>` : '';
            div.innerHTML = `
                <div class="avatar">${avatarContent}</div>
                <div class="message-bubble">
                    <div class="message-header">
                        <span class="message-username">${escapeHtml(msg.username || 'Anonymous')}</span>
                        <span class="message-time">${time}</span>
                        ${deleteBtn}
                    </div>
                    ${contentHTML}
                    ${chatVoteBtn}
                </div>
            `;

            if (prepend) {
                container.insertBefore(div, container.firstChild);
            } else {
                container.appendChild(div);
                // Scroll to bottom for new messages
                container.scrollTop = container.scrollHeight;
            }
        }

        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        // Send message
        window.sendMessage = async function() {
            const input = document.getElementById('messageInput');
            const content = input.value.trim();

            if (!content && !selectedImage) return;

            const tempId = 'temp_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);

            const msg = {
                id: tempId,
                username: profile.username,
                avatar: profile.avatar,
                avatarUrl: profile.avatarUrl || null,
                content: content || null,
                image_data: selectedImage || null,
                drawing_data: null,
                message_type: selectedImage ? 'image' : 'text',
                user_id: currentUser?.id,
                created_at: new Date().toISOString()
            };

            input.value = '';
            input.style.height = 'auto';
            removeImage();

            seenMessageIds.add(tempId);
            addMessageToUI(msg);
            scrollToBottom();
            broadcastMessage(msg);
            addToFeed(profile.username, msg.image_data ? 'shared an image' : 'sent a message');

            const { data, error } = await supabase
                .from('sloppygram_messages')
                .insert({
                    username: msg.username,
                    avatar: msg.avatar,
                    content: msg.content,
                    image_data: msg.image_data,
                    drawing_data: msg.drawing_data,
                    message_type: msg.message_type,
                    user_id: msg.user_id
                })
                .select('id')
                .single();

            if (error) {
                console.error('Send error:', error);
                return;
            }

            if (data?.id) {
                seenMessageIds.add(data.id);
            }
        };

        // Delete message
        window.deleteMessage = async function(messageId) {
            if (!currentUser) return;
            if (!confirm('Delete this message?')) return;

            const { error } = await supabase
                .from('sloppygram_messages')
                .delete()
                .eq('id', messageId)
                .eq('user_id', currentUser.id);

            if (error) {
                console.error('Delete error:', error);
                return;
            }

            // Remove from UI
            const container = document.getElementById('messagesContainer');
            const msgElements = container.querySelectorAll('.message');
            msgElements.forEach(el => {
                const voteControl = el.querySelector(`[data-chat-id="${messageId}"]`);
                const doodleControl = el.querySelector(`[data-doodle-id="${messageId}"]`);
                if (voteControl || doodleControl) {
                    el.remove();
                }
            });
        };

        // Send drawing
        window.sendDrawing = async function() {
            const canvas = document.getElementById('drawingCanvas');
            const drawingData = canvas.toDataURL('image/png');

            const tempId = 'temp_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);

            const msg = {
                id: tempId,
                username: profile.username,
                avatar: profile.avatar,
                avatarUrl: profile.avatarUrl || null,
                content: null,
                image_data: null,
                drawing_data: drawingData,
                message_type: 'drawing',
                user_id: currentUser?.id,
                created_at: new Date().toISOString()
            };

            closeDrawingModal();
            clearCanvas();

            seenMessageIds.add(tempId);
            addMessageToUI(msg);
            scrollToBottom();
            broadcastMessage(msg);
            addToFeed(profile.username, 'shared a drawing');

            const { data, error } = await supabase
                .from('sloppygram_messages')
                .insert({
                    username: msg.username,
                    avatar: msg.avatar,
                    content: msg.content,
                    image_data: msg.image_data,
                    drawing_data: msg.drawing_data,
                    message_type: msg.message_type,
                    user_id: msg.user_id
                })
                .select('id')
                .single();

            if (error) {
                console.error('Send error:', error);
            }

            if (data?.id) {
                seenMessageIds.add(data.id);
            }
        };

        // Image handling
        window.handleImageSelect = function(event) {
            const file = event.target.files[0];
            if (!file) return;

            if (file.size > 500000) {
                alert('FILE TOO LARGE. MAX 500KB.');
                return;
            }

            const reader = new FileReader();
            reader.onload = (e) => {
                selectedImage = e.target.result;
                document.getElementById('previewImg').src = selectedImage;
                document.getElementById('imagePreview').style.display = 'block';
            };
            reader.readAsDataURL(file);
        };

        window.removeImage = function() {
            selectedImage = null;
            document.getElementById('imagePreview').style.display = 'none';
            document.getElementById('imageInput').value = '';
        };

        // Profile modal
        let pendingAvatarData = null;
        let pendingBgData = null;

        window.openProfileModal = async function() {
            document.getElementById('usernameInput').value = profile.username;

            // Show current avatar preview if exists
            pendingAvatarData = profile.avatarUrl || null;
            if (pendingAvatarData) {
                document.getElementById('avatarPreviewImg').src = pendingAvatarData;
                document.getElementById('avatarPreview').style.display = 'block';
                document.getElementById('clearAvatarBtn').style.display = 'block';
            } else {
                document.getElementById('avatarPreview').style.display = 'none';
                document.getElementById('clearAvatarBtn').style.display = 'none';
            }

            // Show current bg preview if exists
            pendingBgData = profile.bgUrl || null;
            if (pendingBgData) {
                document.getElementById('bgPreviewImg').src = pendingBgData;
                document.getElementById('bgPreview').style.display = 'block';
                document.getElementById('clearBgBtn').style.display = 'block';
                document.getElementById('shareBgBtn').style.display = 'block';
                document.getElementById('setGlobalBgBtn').style.display = 'block';
            } else {
                document.getElementById('bgPreview').style.display = 'none';
                document.getElementById('clearBgBtn').style.display = 'none';
                document.getElementById('shareBgBtn').style.display = 'none';
                document.getElementById('setGlobalBgBtn').style.display = 'none';
            }

            setupAvatarGrid();
            setupColorOptions();
            await loadGlobalBackgrounds();
            document.getElementById('profileModal').classList.add('active');
        };

        window.closeProfileModal = function() {
            document.getElementById('profileModal').classList.remove('active');
            pendingAvatarData = null;
            pendingBgData = null;
        };

        window.handleAvatarUpload = function(event) {
            const file = event.target.files[0];
            if (!file) return;

            if (file.size > 500000) {
                alert('Image too large! Max 500KB.');
                return;
            }

            const reader = new FileReader();
            reader.onload = function(e) {
                pendingAvatarData = e.target.result;
                document.getElementById('avatarPreviewImg').src = pendingAvatarData;
                document.getElementById('avatarPreview').style.display = 'block';
                document.getElementById('clearAvatarBtn').style.display = 'block';
            };
            reader.readAsDataURL(file);
        };

        window.clearAvatarUpload = function() {
            pendingAvatarData = null;
            document.getElementById('avatarFileInput').value = '';
            document.getElementById('avatarPreview').style.display = 'none';
            document.getElementById('clearAvatarBtn').style.display = 'none';
        };

        window.handleBgUpload = function(event) {
            const file = event.target.files[0];
            if (!file) return;

            if (file.size > 1000000) {
                alert('Image too large! Max 1MB for backgrounds.');
                return;
            }

            const reader = new FileReader();
            reader.onload = function(e) {
                pendingBgData = e.target.result;
                document.getElementById('bgPreviewImg').src = pendingBgData;
                document.getElementById('bgPreview').style.display = 'block';
                document.getElementById('clearBgBtn').style.display = 'block';
                document.getElementById('shareBgBtn').style.display = 'block';
                document.getElementById('setGlobalBgBtn').style.display = 'block';
            };
            reader.readAsDataURL(file);
        };

        window.clearBgUpload = function() {
            pendingBgData = null;
            document.getElementById('bgFileInput').value = '';
            document.getElementById('bgPreview').style.display = 'none';
            document.getElementById('clearBgBtn').style.display = 'none';
            document.getElementById('shareBgBtn').style.display = 'none';
            document.getElementById('setGlobalBgBtn').style.display = 'none';
        };

        // Global Backgrounds
        async function loadGlobalBackgrounds() {
            const { data } = await supabase
                .from('sloppygram_global_backgrounds')
                .select('*')
                .order('created_at', { ascending: false })
                .limit(20);

            globalBackgrounds = data || [];
            renderGlobalBackgrounds();
        }

        function renderGlobalBackgrounds() {
            const grid = document.getElementById('globalBgGrid');
            grid.innerHTML = globalBackgrounds.map(bg => `
                <div class="global-bg-item ${pendingBgData === bg.image_data ? 'selected' : ''}"
                     onclick="selectGlobalBg('${bg.id}')"
                     title="${bg.name || 'Shared by ' + bg.username}">
                    <img src="${bg.image_data}" alt="${bg.name || 'Background'}">
                </div>
            `).join('') + `
                <div class="global-bg-item global-bg-upload" onclick="document.getElementById('bgFileInput').click()" title="Upload new">+</div>
            `;
        }

        window.selectGlobalBg = function(bgId) {
            const bg = globalBackgrounds.find(b => b.id == bgId);
            if (!bg) return;

            pendingBgData = bg.image_data;
            document.getElementById('bgPreviewImg').src = pendingBgData;
            document.getElementById('bgPreview').style.display = 'block';
            document.getElementById('clearBgBtn').style.display = 'block';
            document.getElementById('shareBgBtn').style.display = 'none'; // Already shared
            document.getElementById('setGlobalBgBtn').style.display = 'block'; // Can still set for everyone

            renderGlobalBackgrounds();
        };

        window.shareBackground = async function() {
            if (!pendingBgData || !currentUser) return;

            const name = prompt('Give your background a name:', 'My Background');
            if (!name) return;

            const { error } = await supabase
                .from('sloppygram_global_backgrounds')
                .insert({
                    image_data: pendingBgData,
                    username: profile.username,
                    name: name,
                    user_id: currentUser.id
                });

            if (error) {
                console.error('Error sharing background:', error);
                alert('Failed to share background');
                return;
            }

            alert('Background shared with everyone!');
            document.getElementById('shareBgBtn').style.display = 'none';
            await loadGlobalBackgrounds();
        };

        // Broadcast background to ALL users in real-time
        window.setGlobalBackground = function() {
            if (!pendingBgData || !realtimeChannel) return;

            realtimeChannel.send({
                type: 'broadcast',
                event: 'global_background',
                payload: {
                    image_data: pendingBgData,
                    username: profile.username
                }
            });

            // Also apply to self (chat container only)
            const msgContainer = document.getElementById('messagesContainer');
            if (msgContainer) {
                msgContainer.style.backgroundImage = `url(${pendingBgData})`;
                msgContainer.style.backgroundSize = 'cover';
                msgContainer.style.backgroundPosition = 'center';
                msgContainer.style.backgroundAttachment = 'fixed';
                msgContainer.style.backgroundRepeat = 'no-repeat';
            }

            addToFeed(profile.username, 'set a new chat background');
        };

        // Message opacity control
        window.setMessageOpacity = function(value) {
            const opacity = value / 100;
            document.documentElement.style.setProperty('--msg-opacity', opacity);
            document.getElementById('opacityValue').textContent = value + '%';
            localStorage.setItem('sloppygram_msg_opacity', value);
        };

        function loadMessageOpacity() {
            const saved = localStorage.getItem('sloppygram_msg_opacity');
            if (saved !== null) {
                const value = parseInt(saved);
                document.documentElement.style.setProperty('--msg-opacity', value / 100);
                const slider = document.getElementById('msgOpacitySlider');
                const display = document.getElementById('opacityValue');
                if (slider) slider.value = value;
                if (display) display.textContent = value + '%';
            }
        }

        window.saveProfile = function() {
            const username = document.getElementById('usernameInput').value.trim() || 'Anon' + Math.floor(Math.random() * 9999);
            profile.username = username;
            profile.avatarUrl = pendingAvatarData || '';
            profile.bgUrl = pendingBgData || '';
            localStorage.setItem('sloppygram_profile', JSON.stringify(profile));
            applyCustomBackground();
            closeProfileModal();
        };

        window.resetProfile = function() {
            if (!confirm('Reset all profile data? This cannot be undone.')) return;
            localStorage.removeItem('sloppygram_profile');
            profile = {
                username: 'Anon' + Math.floor(Math.random() * 9999),
                avatar: AVATARS[Math.floor(Math.random() * AVATARS.length)],
                color: COLORS[Math.floor(Math.random() * COLORS.length)],
                avatarUrl: '',
                bgUrl: ''
            };
            pendingAvatarData = null;
            pendingBgData = null;
            const msgContainer = document.getElementById('messagesContainer');
            if (msgContainer) msgContainer.style.backgroundImage = '';
            closeProfileModal();
        };

        function applyCustomBackground() {
            const msgContainer = document.getElementById('messagesContainer');
            if (!msgContainer) return;

            if (profile.bgUrl) {
                msgContainer.style.backgroundImage = `url(${profile.bgUrl})`;
                msgContainer.style.backgroundSize = 'cover';
                msgContainer.style.backgroundPosition = 'center';
                msgContainer.style.backgroundAttachment = 'fixed';
                msgContainer.style.backgroundRepeat = 'no-repeat';
            } else {
                msgContainer.style.backgroundImage = '';
            }
        }

        // Drawing modal
        window.openDrawingModal = function() {
            clearCanvas();
            document.getElementById('drawingModal').classList.add('active');
        };

        window.closeDrawingModal = function() {
            document.getElementById('drawingModal').classList.remove('active');
        };

        // === POSTS FUNCTIONALITY ===

        window.switchView = function(view) {
            currentView = view;
            document.querySelectorAll('.view-tab').forEach(tab => {
                tab.classList.toggle('active', tab.dataset.view === view);
            });
            document.getElementById('messagesContainer').classList.toggle('hidden', view !== 'chat');
            document.getElementById('postsContainer').classList.toggle('active', view === 'posts');
            document.getElementById('doodlesContainer').classList.toggle('active', view === 'doodles');
            document.getElementById('manifestoContainer').classList.toggle('active', view === 'manifesto');
            document.getElementById('chatInputArea').style.display = view === 'chat' ? 'block' : 'none';
            document.getElementById('transparencyBar').style.display = view === 'chat' ? 'flex' : 'none';
            document.getElementById('createPostBtn').classList.toggle('visible', view === 'posts');

            if (view === 'posts') {
                loadPosts();
            }
            if (view === 'doodles') {
                loadDoodleLeaderboard();
            }
            if (view === 'manifesto') {
                loadManifestos();
            }
        };

        async function loadPosts() {
            const { data, error } = await supabase
                .from('sloppygram_posts')
                .select('*')
                .order('created_at', { ascending: false })
                .limit(50);

            if (error) {
                console.error('Error loading posts:', error);
                return;
            }

            posts = data || [];

            // Load all post votes and calculate net scores
            const { data: allVotesData } = await supabase
                .from('sloppygram_post_likes')
                .select('post_id, username, vote_type');

            postVotes = {};
            myPostVotes = {};
            (allVotesData || []).forEach(vote => {
                postVotes[vote.post_id] = (postVotes[vote.post_id] || 0) + (vote.vote_type || 1);
                if (vote.username === profile.username) {
                    myPostVotes[vote.post_id] = vote.vote_type || 1;
                }
            });

            // Update post.likes_count with net vote scores
            posts.forEach(p => {
                p.likes_count = postVotes[p.id] || 0;
            });

            // Load comments for all posts
            const postIds = posts.map(p => p.id);
            if (postIds.length > 0) {
                const { data: commentsData } = await supabase
                    .from('sloppygram_post_comments')
                    .select('*')
                    .in('post_id', postIds)
                    .order('created_at', { ascending: true });

                postComments = {};
                (commentsData || []).forEach(comment => {
                    if (!postComments[comment.post_id]) {
                        postComments[comment.post_id] = [];
                    }
                    postComments[comment.post_id].push(comment);
                });

                // Load reactions for all posts
                const { data: reactionsData } = await supabase
                    .from('sloppygram_post_reactions')
                    .select('*')
                    .in('post_id', postIds);

                postReactions = {};
                myReactions = {};
                (reactionsData || []).forEach(r => {
                    if (!postReactions[r.post_id]) postReactions[r.post_id] = {};
                    postReactions[r.post_id][r.emoji] = (postReactions[r.post_id][r.emoji] || 0) + 1;

                    // Track my reactions
                    if (r.username === profile.username) {
                        if (!myReactions[r.post_id]) myReactions[r.post_id] = new Set();
                        myReactions[r.post_id].add(r.emoji);
                    }
                });

                // Load tags for all posts
                const { data: tagsData } = await supabase
                    .from('sloppygram_post_tags')
                    .select('*')
                    .in('post_id', postIds);

                postTags = {};
                (tagsData || []).forEach(t => {
                    if (!postTags[t.post_id]) postTags[t.post_id] = [];
                    postTags[t.post_id].push({ tag: t.tag, parent_tag: t.parent_tag });
                });

                // Load comment thread relationships
                const { data: threadsData } = await supabase
                    .from('sloppygram_comment_threads')
                    .select('*')
                    .eq('comment_type', 'post')
                    .in('post_id', postIds);

                (threadsData || []).forEach(t => {
                    commentThreads[t.comment_id] = t.parent_comment_id;
                });
            }

            renderPosts();
        }

        function renderPosts() {
            const container = document.getElementById('postsContainer');
            const emptyState = document.getElementById('postsEmptyState');

            if (posts.length === 0) {
                emptyState.style.display = 'block';
                container.innerHTML = '';
                container.appendChild(emptyState);
                return;
            }

            emptyState.style.display = 'none';
            container.innerHTML = posts.map(post => renderPostCard(post)).join('');
        }

        // Render threaded comments with replies
        function renderThreadedComments(comments, postId, type = 'post') {
            // Build a map of comment threads
            const threads = {}; // parentId -> [children]
            const rootComments = [];

            comments.forEach(c => {
                const parentId = commentThreads[c.id];
                if (parentId) {
                    if (!threads[parentId]) threads[parentId] = [];
                    threads[parentId].push(c);
                } else {
                    rootComments.push(c);
                }
            });

            function renderComment(c, depth = 0) {
                const time = c.created_at ? new Date(c.created_at).toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'}) : '';
                const replies = threads[c.id] || [];
                const isNested = depth > 0;
                const isOwnComment = c.username === profile.username;
                const myVote = myCommentVotes[c.id] || 0;
                const voteScore = commentVotes[c.id] || 0;
                const scoreClass = voteScore > 0 ? 'positive' : voteScore < 0 ? 'negative' : '';

                return `
                    <div class="comment ${isNested ? 'comment-thread' : ''}" data-comment-id="${c.id}" data-depth="${depth}">
                        <span class="comment-avatar">${c.avatar || 'ðŸ‘¤'}</span>
                        <div class="comment-content">
                            <span class="comment-username">${escapeHtml(c.username)}</span>
                            <span class="comment-time">${time}</span>
                            <div class="comment-text">${escapeHtml(c.content)}</div>
                            <div class="comment-actions">
                                <button class="comment-reply-btn" onclick="startReply(${postId}, ${c.id}, '${escapeHtml(c.username)}', '${type}')">â†© reply</button>
                                <span class="comment-vote-controls" data-comment-id="${c.id}">
                                    <button class="comment-vote-btn upvote ${myVote === 1 ? 'active' : ''} ${isOwnComment ? 'disabled' : ''}"
                                        onclick="${isOwnComment ? '' : `voteComment('${c.id}', 1, '${escapeHtml(c.username)}')`}"
                                        title="${isOwnComment ? 'Cannot vote on own comment' : 'Upvote'}">â–²</button>
                                    <span class="comment-vote-score ${scoreClass}">${voteScore}</span>
                                    <button class="comment-vote-btn downvote ${myVote === -1 ? 'active' : ''} ${isOwnComment ? 'disabled' : ''}"
                                        onclick="${isOwnComment ? '' : `voteComment('${c.id}', -1, '${escapeHtml(c.username)}')`}"
                                        title="${isOwnComment ? 'Cannot vote on own comment' : 'Downvote'}">â–¼</button>
                                </span>
                            </div>
                        </div>
                        ${replies.length > 0 ? `<div class="comment-replies">${replies.map(r => renderComment(r, depth + 1)).join('')}</div>` : ''}
                    </div>
                `;
            }

            return rootComments.map(c => renderComment(c, 0)).join('');
        }

        function renderPostCard(post) {
            const time = new Date(post.created_at).toLocaleString();
            const myVote = myPostVotes[post.id] || 0;
            const comments = postComments[post.id] || [];
            const voteScore = postVotes[post.id] || 0;
            const reactions = postReactions[post.id] || {};
            const myPostReactions = myReactions[post.id] || new Set();
            const isOwnPost = post.user_id === currentUser?.id || post.username === profile.username;
            const scoreClass = voteScore > 0 ? 'positive' : voteScore < 0 ? 'negative' : 'neutral';

            const avatarContent = post.avatar_url
                ? `<img src="${post.avatar_url}" style="width:100%;height:100%;object-fit:cover;border-radius:50%;">`
                : (post.avatar || 'ðŸ‘¤');

            const imageHtml = post.image_url
                ? `<img class="post-image" src="${post.image_url}" onerror="this.style.display='none'">`
                : (post.image_data ? `<img class="post-image" src="${post.image_data}">` : '');

            const commentsHtml = renderThreadedComments(comments, post.id, 'post');

            // Reply indicator if replying to a comment on this post
            const replyIndicatorHtml = (replyingTo && replyingTo.postId === post.id && replyingTo.type === 'post')
                ? `<div class="reply-indicator">
                    <span>â†© Replying to <strong>${escapeHtml(replyingTo.username)}</strong></span>
                    <button class="cancel-reply" onclick="cancelReply()">âœ•</button>
                </div>`
                : '';

            // Build reactions HTML
            const reactionsHtml = Object.entries(reactions)
                .sort((a, b) => b[1] - a[1])
                .map(([emoji, count]) => {
                    const isActive = myPostReactions.has(emoji);
                    return `<button class="reaction-btn ${isActive ? 'active' : ''}" onclick="toggleReaction(${post.id}, '${emoji}')">
                        ${emoji} <span class="reaction-count">${count}</span>
                    </button>`;
                }).join('');

            const reactionPickerHtml = REACTION_EMOJIS.map(emoji =>
                `<button onclick="toggleReaction(${post.id}, '${emoji}')">${emoji}</button>`
            ).join('');

            // Build tags HTML
            const tags = postTags[post.id] || [];
            const tagsHtml = tags.length > 0 ? `
                <div class="post-tags">
                    ${tags.map(t => {
                        const isNested = t.parent_tag != null;
                        const displayTag = isNested ? `${t.parent_tag}/${t.tag}` : t.tag;
                        return `<span class="tag ${isNested ? 'nested' : ''}" onclick="filterByTag('${escapeHtml(displayTag)}')">#${escapeHtml(displayTag)}</span>`;
                    }).join('')}
                </div>
            ` : '';

            return `
                <div class="post-card" data-post-id="${post.id}">
                    <div class="post-header">
                        <div class="post-avatar">${avatarContent}</div>
                        <span class="post-username">${escapeHtml(post.username || 'Anonymous')}</span>
                        <span class="post-time">${time}</span>
                        ${isOwnPost ? `<button class="post-delete-btn" onclick="deletePost(${post.id})" title="Delete post">ðŸ—‘ï¸</button>` : ''}
                    </div>
                    ${imageHtml}
                    ${post.caption ? `<div class="post-caption">${escapeHtml(post.caption)}</div>` : ''}
                    <div class="post-actions">
                        <div class="vote-controls" data-post-id="${post.id}">
                            <button class="vote-btn upvote ${myVote === 1 ? 'active' : ''} ${isOwnPost ? 'disabled' : ''}"
                                onclick="${isOwnPost ? '' : `votePost(${post.id}, 1)`}"
                                title="${isOwnPost ? 'Cannot vote on own post' : 'Upvote'}">â–²</button>
                            <span class="vote-score ${scoreClass}" id="post-score-${post.id}">${voteScore}</span>
                            <button class="vote-btn downvote ${myVote === -1 ? 'active' : ''} ${isOwnPost ? 'disabled' : ''}"
                                onclick="${isOwnPost ? '' : `votePost(${post.id}, -1)`}"
                                title="${isOwnPost ? 'Cannot vote on own post' : 'Downvote'}">â–¼</button>
                        </div>
                        <button class="post-action-btn" onclick="focusComment(${post.id})">
                            ðŸ’¬ ${comments.length}
                        </button>
                    </div>
                    <div class="post-reactions" id="reactions-${post.id}">
                        ${reactionsHtml}
                        <div style="position:relative;display:inline-block;">
                            <button class="add-reaction-btn" onclick="toggleReactionPicker(${post.id})">+ ðŸ˜€</button>
                            <div class="reaction-picker" id="picker-${post.id}">
                                ${reactionPickerHtml}
                            </div>
                        </div>
                    </div>
                    ${tagsHtml}
                    <div class="post-comments" id="comments-${post.id}">
                        ${commentsHtml}
                    </div>
                    ${replyIndicatorHtml}
                    <div class="comment-input-row">
                        <input class="comment-input" id="comment-input-${post.id}" placeholder="${replyingTo && replyingTo.postId === post.id ? 'Write a reply...' : 'Add a comment...'}" onkeydown="if(event.key==='Enter')addComment(${post.id})">
                        <button class="comment-send" onclick="addComment(${post.id})">POST</button>
                    </div>
                </div>
            `;
        }

        window.deletePost = async function(postId) {
            if (!currentUser) return;
            if (!confirm('Delete this post? This cannot be undone.')) return;

            const { error } = await supabase
                .from('sloppygram_posts')
                .delete()
                .eq('id', postId)
                .eq('user_id', currentUser.id);

            if (error) {
                console.error('Error deleting post:', error);
                alert('Could not delete post');
                return;
            }

            // Remove from local state
            posts = posts.filter(p => p.id !== postId);
            delete postComments[postId];
            delete postReactions[postId];
            delete postLikes[postId];
            delete postTags[postId];
            renderPosts();
        };

        window.votePost = async function(postId, voteType) {
            if (!currentUser) return;

            // Check if own post
            const post = posts.find(p => p.id === postId);
            if (post && (post.user_id === currentUser.id || post.username === profile.username)) return;

            const currentVote = myPostVotes[postId] || 0;

            if (currentVote === voteType) {
                // Remove vote if clicking same button
                await supabase
                    .from('sloppygram_post_likes')
                    .delete()
                    .eq('post_id', postId)
                    .eq('user_id', currentUser.id);

                myPostVotes[postId] = 0;
                postVotes[postId] = (postVotes[postId] || 0) - voteType;
            } else {
                // Remove existing vote first
                if (currentVote !== 0) {
                    await supabase
                        .from('sloppygram_post_likes')
                        .delete()
                        .eq('post_id', postId)
                        .eq('user_id', currentUser.id);
                    postVotes[postId] = (postVotes[postId] || 0) - currentVote;
                }

                // Add new vote
                await supabase
                    .from('sloppygram_post_likes')
                    .insert({
                        post_id: postId,
                        username: profile.username,
                        vote_type: voteType,
                        user_id: currentUser.id
                    });

                myPostVotes[postId] = voteType;
                postVotes[postId] = (postVotes[postId] || 0) + voteType;
            }

            // Update post.likes_count
            if (post) post.likes_count = postVotes[postId] || 0;

            // Log AI event for post vote
            logAiEvent('vote_cast', 'post', postId, {
                vote_type: myPostVotes[postId] || 0,
                net_score: postVotes[postId] || 0
            });

            // Update UI
            updatePostVoteUI(postId);
        };

        function updatePostVoteUI(postId) {
            const score = postVotes[postId] || 0;
            const myVote = myPostVotes[postId] || 0;
            const scoreClass = score > 0 ? 'positive' : score < 0 ? 'negative' : 'neutral';

            document.querySelectorAll(`[data-post-id="${postId}"]`).forEach(container => {
                const scoreEl = container.querySelector('.vote-score');
                const upBtn = container.querySelector('.vote-btn.upvote');
                const downBtn = container.querySelector('.vote-btn.downvote');

                if (scoreEl) {
                    scoreEl.textContent = score;
                    scoreEl.className = `vote-score ${scoreClass}`;
                }
                if (upBtn) upBtn.classList.toggle('active', myVote === 1);
                if (downBtn) downBtn.classList.toggle('active', myVote === -1);
            });
        }

        window.focusComment = function(postId) {
            document.getElementById(`comment-input-${postId}`).focus();
        };

        // Start replying to a specific comment
        window.startReply = function(postId, commentId, username, type = 'post') {
            replyingTo = { postId, commentId, username, type };
            if (type === 'post') {
                renderPosts();
                setTimeout(() => {
                    const input = document.getElementById(`comment-input-${postId}`);
                    if (input) input.focus();
                }, 50);
            } else {
                renderManifestos();
                setTimeout(() => {
                    const input = document.getElementById(`manifesto-comment-input-${postId}`);
                    if (input) input.focus();
                }, 50);
            }
        };

        // Cancel replying
        window.cancelReply = function() {
            const wasType = replyingTo?.type;
            replyingTo = null;
            if (wasType === 'post') {
                renderPosts();
            } else if (wasType === 'manifesto') {
                renderManifestos();
            }
        };

        window.addComment = async function(postId) {
            const input = document.getElementById(`comment-input-${postId}`);
            const content = input.value.trim();
            if (!content || !currentUser) return;

            const comment = {
                post_id: postId,
                username: profile.username,
                avatar: profile.avatar,
                content: content,
                user_id: currentUser.id
            };

            const { data, error } = await supabase
                .from('sloppygram_post_comments')
                .insert(comment)
                .select()
                .single();

            if (error) {
                console.error('Error adding comment:', error);
                return;
            }

            // If this is a reply, save the thread relationship
            if (replyingTo && replyingTo.postId === postId && replyingTo.type === 'post' && data) {
                await supabase
                    .from('sloppygram_comment_threads')
                    .insert({
                        comment_id: data.id,
                        parent_comment_id: replyingTo.commentId,
                        comment_type: 'post',
                        post_id: postId,
                        user_id: currentUser.id
                    });
                commentThreads[data.id] = replyingTo.commentId;
            }

            if (!postComments[postId]) postComments[postId] = [];
            postComments[postId].push({ ...comment, id: data?.id, created_at: new Date().toISOString() });

            input.value = '';
            replyingTo = null;
            renderPosts();
        };

        // Emoji Reactions
        window.toggleReactionPicker = function(postId) {
            const picker = document.getElementById(`picker-${postId}`);
            // Close all other pickers
            document.querySelectorAll('.reaction-picker.active').forEach(p => {
                if (p.id !== `picker-${postId}`) p.classList.remove('active');
            });
            picker.classList.toggle('active');
        };

        window.toggleReaction = async function(postId, emoji) {
            if (!currentUser) return;

            // Close picker
            const picker = document.getElementById(`picker-${postId}`);
            if (picker) picker.classList.remove('active');

            const hasReaction = myReactions[postId]?.has(emoji);

            if (hasReaction) {
                // Remove reaction
                await supabase
                    .from('sloppygram_post_reactions')
                    .delete()
                    .eq('post_id', postId)
                    .eq('emoji', emoji)
                    .eq('user_id', currentUser.id);

                myReactions[postId]?.delete(emoji);
                if (postReactions[postId]?.[emoji]) {
                    postReactions[postId][emoji]--;
                    if (postReactions[postId][emoji] <= 0) delete postReactions[postId][emoji];
                }
            } else {
                // Add reaction
                await supabase
                    .from('sloppygram_post_reactions')
                    .insert({
                        post_id: postId,
                        emoji: emoji,
                        username: profile.username,
                        user_id: currentUser.id
                    });

                if (!myReactions[postId]) myReactions[postId] = new Set();
                myReactions[postId].add(emoji);
                if (!postReactions[postId]) postReactions[postId] = {};
                postReactions[postId][emoji] = (postReactions[postId][emoji] || 0) + 1;
            }

            renderPosts();
        };

        // Close reaction pickers when clicking outside
        document.addEventListener('click', (e) => {
            if (!e.target.closest('.add-reaction-btn') && !e.target.closest('.reaction-picker')) {
                document.querySelectorAll('.reaction-picker.active').forEach(p => p.classList.remove('active'));
            }
        });

        // Post Modal
        window.openPostModal = function() {
            postImageData = null;
            document.getElementById('postImageUrl').value = '';
            document.getElementById('postCaption').value = '';
            document.getElementById('postFileInput').value = '';
            document.getElementById('postPreview').innerHTML = '<span>No image selected</span>';
            document.getElementById('postPreview').classList.remove('has-image');
            document.getElementById('postModal').classList.add('active');
        };

        window.closePostModal = function() {
            document.getElementById('postModal').classList.remove('active');
        };

        window.previewPostImage = function() {
            const url = document.getElementById('postImageUrl').value.trim();
            const preview = document.getElementById('postPreview');

            if (url) {
                preview.innerHTML = `<img src="${url}" onerror="this.parentElement.innerHTML='<span>Failed to load image</span>'">`;
                preview.classList.add('has-image');
                postImageData = null;
            } else if (!postImageData) {
                preview.innerHTML = '<span>No image selected</span>';
                preview.classList.remove('has-image');
            }
        };

        window.handlePostFileSelect = function(event) {
            const file = event.target.files[0];
            if (!file) return;

            if (file.size > 500000) {
                alert('Image too large! Max 500KB');
                event.target.value = '';
                return;
            }

            const reader = new FileReader();
            reader.onload = function(e) {
                postImageData = e.target.result;
                const preview = document.getElementById('postPreview');
                preview.innerHTML = `<img src="${postImageData}">`;
                preview.classList.add('has-image');
                document.getElementById('postImageUrl').value = '';
            };
            reader.readAsDataURL(file);
        };

        window.submitPost = async function() {
            const imageUrl = document.getElementById('postImageUrl').value.trim();
            const caption = document.getElementById('postCaption').value.trim();

            if (!imageUrl && !postImageData && !caption) {
                alert('Add an image or caption!');
                return;
            }

            const post = {
                username: profile.username,
                avatar: profile.avatar,
                avatar_url: profile.avatarUrl || null,
                caption: caption || null,
                image_url: imageUrl || null,
                image_data: postImageData || null,
                likes_count: 0,
                user_id: currentUser.id
            };

            const { data: insertedPost, error } = await supabase
                .from('sloppygram_posts')
                .insert(post)
                .select()
                .single();

            if (error) {
                console.error('Error creating post:', error);
                alert('Failed to create post: ' + error.message);
                return;
            }

            if (!insertedPost) {
                console.error('Post insert returned no data');
                alert('Post created but could not retrieve ID for tags');
            }

            // Save tags if any
            if (pendingTags.length > 0 && insertedPost) {
                const tagInserts = pendingTags.map(t => ({
                    post_id: insertedPost.id,
                    tag: t.tag,
                    parent_tag: t.parent_tag || null,
                    user_id: currentUser.id
                }));
                const { error: tagError } = await supabase.from('sloppygram_post_tags').insert(tagInserts);
                if (tagError) {
                    console.error('Error saving tags:', tagError);
                }
            }

            // Log AI event for new post
            if (insertedPost) {
                logAiEvent('post_created', 'post', insertedPost.id, {
                    has_image: !!(imageUrl || postImageData),
                    has_caption: !!caption,
                    tag_count: pendingTags.length
                });
            }

            closePostModal();
            addToFeed(profile.username, 'created a new post');

            // Clear any active tag filter so new post is visible
            activeTagFilter = null;
            document.getElementById('tagFilterBar').classList.remove('active');

            loadPosts();
        };

        // === TAG HANDLING FUNCTIONALITY ===

        window.handleTagInput = function(event) {
            if (event.key === 'Enter') {
                event.preventDefault();
                const input = document.getElementById('tagInput');
                const value = input.value.trim();
                if (!value) return;

                // Parse nested tag (e.g., "meme/cursed" -> parent_tag: "meme", tag: "cursed")
                let tag, parent_tag = null;
                if (value.includes('/')) {
                    const parts = value.split('/');
                    parent_tag = parts[0].trim();
                    tag = parts.slice(1).join('/').trim();
                } else {
                    tag = value;
                }

                // Don't add duplicates
                const exists = pendingTags.some(t => t.tag === tag && t.parent_tag === parent_tag);
                if (!exists) {
                    pendingTags.push({ tag, parent_tag });
                    renderPendingTags();
                }

                input.value = '';
            }
        };

        function renderPendingTags() {
            const container = document.getElementById('tagInputContainer');
            const input = document.getElementById('tagInput');

            // Remove existing tag chips
            container.querySelectorAll('.tag-chip').forEach(el => el.remove());

            // Add tag chips
            pendingTags.forEach((t, idx) => {
                const displayTag = t.parent_tag ? `${t.parent_tag}/${t.tag}` : t.tag;
                const chip = document.createElement('span');
                chip.className = `tag-chip ${t.parent_tag ? 'nested' : ''}`;
                chip.innerHTML = `#${escapeHtml(displayTag)} <button onclick="removePendingTag(${idx})">Ã—</button>`;
                container.insertBefore(chip, input);
            });
        }

        window.removePendingTag = function(idx) {
            pendingTags.splice(idx, 1);
            renderPendingTags();
        };

        window.filterByTag = function(tagStr) {
            activeTagFilter = tagStr;
            document.getElementById('tagFilterBar').classList.add('active');
            document.getElementById('activeFilterTag').textContent = '#' + tagStr;

            // Filter posts by tag
            renderFilteredPosts();
        };

        window.clearTagFilter = function() {
            activeTagFilter = null;
            document.getElementById('tagFilterBar').classList.remove('active');
            renderPosts();
        };

        function renderFilteredPosts() {
            if (!activeTagFilter) {
                renderPosts();
                return;
            }

            const container = document.getElementById('postsContainer');
            const emptyState = document.getElementById('postsEmptyState');

            // Filter posts that have the matching tag
            const filteredPosts = posts.filter(post => {
                const tags = postTags[post.id] || [];
                return tags.some(t => {
                    const fullTag = t.parent_tag ? `${t.parent_tag}/${t.tag}` : t.tag;
                    return fullTag === activeTagFilter ||
                           t.tag === activeTagFilter ||
                           t.parent_tag === activeTagFilter;
                });
            });

            if (filteredPosts.length === 0) {
                emptyState.style.display = 'block';
                emptyState.innerHTML = `<p>No posts with tag #${escapeHtml(activeTagFilter)}</p>`;
                container.innerHTML = '';
                container.appendChild(emptyState);
                return;
            }

            emptyState.style.display = 'none';
            container.innerHTML = filteredPosts.map(post => renderPostCard(post)).join('');
        }

        // Reset pending tags when opening post modal
        const originalOpenPostModal = window.openPostModal;
        window.openPostModal = function() {
            pendingTags = [];
            renderPendingTags();
            if (originalOpenPostModal) originalOpenPostModal();
            else document.getElementById('postModal').classList.add('active');
        };

        // Load and display trending tags
        async function loadTrendingTags() {
            const { data: tagsData } = await supabase
                .from('sloppygram_post_tags')
                .select('tag, parent_tag');

            if (!tagsData || tagsData.length === 0) {
                document.getElementById('trendingTagsList').innerHTML = `
                    <div style="font-size:0.85rem;color:var(--text-dim)">No tags yet</div>
                `;
                return;
            }

            // Count tag occurrences
            const tagCounts = {};
            tagsData.forEach(t => {
                const fullTag = t.parent_tag ? `${t.parent_tag}/${t.tag}` : t.tag;
                tagCounts[fullTag] = (tagCounts[fullTag] || 0) + 1;
            });

            // Sort by count and take top 10
            const topTags = Object.entries(tagCounts)
                .sort((a, b) => b[1] - a[1])
                .slice(0, 10);

            const container = document.getElementById('trendingTagsList');
            container.innerHTML = topTags.map(([tag, count], idx) => {
                const isNested = tag.includes('/');
                const rankClass = idx === 0 ? 'hot' : idx < 3 ? 'warm' : '';
                return `
                    <div class="trending-tag ${rankClass}" onclick="filterByTag('${escapeHtml(tag)}')">
                        <span class="tag ${isNested ? 'nested' : ''}">#${escapeHtml(tag)}</span>
                        <span class="tag-count">${count}</span>
                    </div>
                `;
            }).join('');
        }

        // Call loadTrendingTags when switching to posts view
        const originalSwitchView = switchView;
        switchView = function(view) {
            originalSwitchView(view);
            if (view === 'posts') {
                loadTrendingTags();
            }
        };

        // === MANIFESTO FUNCTIONALITY ===

        let manifestos = [];
        let manifestoVotes = {}; // { manifestoId: count }
        let myManifestoVotes = {}; // { manifestoId: true }
        let manifestoReactions = {}; // { manifestoId: { emoji: count } }
        let myManifestoReactions = {}; // { manifestoId: Set of emojis }
        let manifestoComments = {}; // { manifestoId: [comments] }
        let manifestoTags = {}; // { manifestoId: [tags] }
        let pendingManifestoTags = []; // tags being added to new manifesto

        window.openManifestoModal = function() {
            document.getElementById('manifestoModal').classList.add('active');
            document.getElementById('manifestoTitle').value = '';
            document.getElementById('manifestoContent').value = '';
            document.getElementById('manifestoCharCount').textContent = '0';
            pendingManifestoTags = [];
            renderPendingManifestoTags();
        };

        window.closeManifestoModal = function() {
            document.getElementById('manifestoModal').classList.remove('active');
        };

        // Character count for manifesto content
        document.addEventListener('DOMContentLoaded', () => {
            const content = document.getElementById('manifestoContent');
            if (content) {
                content.addEventListener('input', () => {
                    document.getElementById('manifestoCharCount').textContent = content.value.length;
                });
            }
        });

        // Manifesto tag input handling
        window.handleManifestoTagInput = function(event) {
            if (event.key === 'Enter') {
                event.preventDefault();
                const input = document.getElementById('manifestoTagInput');
                const value = input.value.trim();
                if (!value) return;

                let tag, parent_tag = null;
                if (value.includes('/')) {
                    const parts = value.split('/');
                    parent_tag = parts[0].trim();
                    tag = parts.slice(1).join('/').trim();
                } else {
                    tag = value;
                }

                const exists = pendingManifestoTags.some(t => t.tag === tag && t.parent_tag === parent_tag);
                if (!exists) {
                    pendingManifestoTags.push({ tag, parent_tag });
                    renderPendingManifestoTags();
                }
                input.value = '';
            }
        };

        function renderPendingManifestoTags() {
            const container = document.getElementById('manifestoTagInputContainer');
            const input = document.getElementById('manifestoTagInput');
            container.querySelectorAll('.tag-chip').forEach(el => el.remove());

            pendingManifestoTags.forEach((t, idx) => {
                const displayTag = t.parent_tag ? `${t.parent_tag}/${t.tag}` : t.tag;
                const chip = document.createElement('span');
                chip.className = `tag-chip ${t.parent_tag ? 'nested' : ''}`;
                chip.innerHTML = `#${escapeHtml(displayTag)} <button onclick="removeManifestoTag(${idx})">Ã—</button>`;
                container.insertBefore(chip, input);
            });
        }

        window.removeManifestoTag = function(idx) {
            pendingManifestoTags.splice(idx, 1);
            renderPendingManifestoTags();
        };

        window.submitManifesto = async function() {
            const title = document.getElementById('manifestoTitle').value.trim();
            const content = document.getElementById('manifestoContent').value.trim();

            if (!title || !content) {
                alert('Please fill in both title and content!');
                return;
            }

            const manifesto = {
                title,
                content,
                username: profile.username,
                avatar: profile.avatar,
                upvotes: 0,
                user_id: currentUser.id
            };

            const { data: insertedManifesto, error } = await supabase
                .from('sloppygram_manifestos')
                .insert(manifesto)
                .select()
                .single();

            if (error) {
                console.error('Error creating manifesto:', error);
                alert('Failed to create manifesto: ' + error.message);
                return;
            }

            // Save tags if any
            if (pendingManifestoTags.length > 0 && insertedManifesto) {
                const tagInserts = pendingManifestoTags.map(t => ({
                    manifesto_id: insertedManifesto.id,
                    tag: t.tag,
                    parent_tag: t.parent_tag || null,
                    user_id: currentUser.id
                }));
                await supabase.from('sloppygram_manifesto_tags').insert(tagInserts);
            }

            closeManifestoModal();
            addToFeed(profile.username, 'declared a new manifesto');
            loadManifestos();
        };

        async function loadManifestos() {
            const { data, error } = await supabase
                .from('sloppygram_manifestos')
                .select('*')
                .order('created_at', { ascending: false })
                .limit(50);

            if (error) {
                console.error('Error loading manifestos:', error);
                return;
            }

            manifestos = data || [];

            if (manifestos.length > 0) {
                const manifestoIds = manifestos.map(m => m.id);

                // Load votes
                const { data: votesData } = await supabase
                    .from('sloppygram_manifesto_votes')
                    .select('*')
                    .in('manifesto_id', manifestoIds);

                manifestoVotes = {};
                myManifestoVotes = {};
                (votesData || []).forEach(v => {
                    manifestoVotes[v.manifesto_id] = (manifestoVotes[v.manifesto_id] || 0) + 1;
                    if (v.username === profile.username) {
                        myManifestoVotes[v.manifesto_id] = true;
                    }
                });

                // Load reactions
                const { data: reactionsData } = await supabase
                    .from('sloppygram_manifesto_reactions')
                    .select('*')
                    .in('manifesto_id', manifestoIds);

                manifestoReactions = {};
                myManifestoReactions = {};
                (reactionsData || []).forEach(r => {
                    if (!manifestoReactions[r.manifesto_id]) manifestoReactions[r.manifesto_id] = {};
                    manifestoReactions[r.manifesto_id][r.emoji] = (manifestoReactions[r.manifesto_id][r.emoji] || 0) + 1;
                    if (r.username === profile.username) {
                        if (!myManifestoReactions[r.manifesto_id]) myManifestoReactions[r.manifesto_id] = new Set();
                        myManifestoReactions[r.manifesto_id].add(r.emoji);
                    }
                });

                // Load comments
                const { data: commentsData } = await supabase
                    .from('sloppygram_manifesto_comments')
                    .select('*')
                    .in('manifesto_id', manifestoIds)
                    .order('created_at', { ascending: true });

                manifestoComments = {};
                (commentsData || []).forEach(c => {
                    if (!manifestoComments[c.manifesto_id]) manifestoComments[c.manifesto_id] = [];
                    manifestoComments[c.manifesto_id].push(c);
                });

                // Load tags
                const { data: tagsData } = await supabase
                    .from('sloppygram_manifesto_tags')
                    .select('*')
                    .in('manifesto_id', manifestoIds);

                manifestoTags = {};
                (tagsData || []).forEach(t => {
                    if (!manifestoTags[t.manifesto_id]) manifestoTags[t.manifesto_id] = [];
                    manifestoTags[t.manifesto_id].push({ tag: t.tag, parent_tag: t.parent_tag });
                });

                // Load comment thread relationships for manifestos
                const { data: threadsData } = await supabase
                    .from('sloppygram_comment_threads')
                    .select('*')
                    .eq('comment_type', 'manifesto')
                    .in('post_id', manifestoIds);

                (threadsData || []).forEach(t => {
                    commentThreads[t.comment_id] = t.parent_comment_id;
                });
            }

            renderManifestos();
        }

        function renderManifestos() {
            const container = document.getElementById('manifestoList');
            const emptyState = document.getElementById('manifestoEmptyState');

            if (manifestos.length === 0) {
                emptyState.style.display = 'block';
                container.innerHTML = '';
                container.appendChild(emptyState);
                return;
            }

            emptyState.style.display = 'none';
            container.innerHTML = manifestos.map(m => renderManifestoCard(m)).join('');
        }

        function renderManifestoCard(m) {
            const time = new Date(m.created_at).toLocaleString();
            const voteCount = manifestoVotes[m.id] || m.upvotes || 0;
            const hasVoted = myManifestoVotes[m.id];
            const reactions = manifestoReactions[m.id] || {};
            const myReacts = myManifestoReactions[m.id] || new Set();
            const comments = manifestoComments[m.id] || [];
            const tags = manifestoTags[m.id] || [];

            const reactionsHtml = Object.entries(reactions)
                .sort((a, b) => b[1] - a[1])
                .map(([emoji, count]) => {
                    const isActive = myReacts.has(emoji);
                    return `<button class="reaction-btn ${isActive ? 'active' : ''}" onclick="toggleManifestoReaction(${m.id}, '${emoji}')">
                        ${emoji} <span class="reaction-count">${count}</span>
                    </button>`;
                }).join('');

            const reactionPickerHtml = REACTION_EMOJIS.map(emoji =>
                `<button onclick="toggleManifestoReaction(${m.id}, '${emoji}')">${emoji}</button>`
            ).join('');

            const commentsHtml = renderThreadedComments(comments, m.id, 'manifesto');

            // Reply indicator if replying to a comment on this manifesto
            const replyIndicatorHtml = (replyingTo && replyingTo.postId === m.id && replyingTo.type === 'manifesto')
                ? `<div class="reply-indicator">
                    <span>â†© Replying to <strong>${escapeHtml(replyingTo.username)}</strong></span>
                    <button class="cancel-reply" onclick="cancelReply()">âœ•</button>
                </div>`
                : '';

            const tagsHtml = tags.length > 0 ? `
                <div class="post-tags">
                    ${tags.map(t => {
                        const isNested = t.parent_tag != null;
                        const displayTag = isNested ? `${t.parent_tag}/${t.tag}` : t.tag;
                        return `<span class="tag ${isNested ? 'nested' : ''}">#${escapeHtml(displayTag)}</span>`;
                    }).join('')}
                </div>
            ` : '';

            return `
                <div class="manifesto-card" data-manifesto-id="${m.id}">
                    <div class="manifesto-card-header">
                        <div class="manifesto-avatar">${m.avatar || 'ðŸ‘¤'}</div>
                        <span class="manifesto-author">${escapeHtml(m.username || 'Anonymous')}</span>
                        <span class="manifesto-time">${time}</span>
                    </div>
                    <h3 class="manifesto-title">${escapeHtml(m.title)}</h3>
                    <div class="manifesto-text">${escapeHtml(m.content)}</div>
                    ${tagsHtml}
                    <div class="manifesto-actions">
                        <button class="manifesto-vote-btn ${hasVoted ? 'voted' : ''}" onclick="voteManifesto(${m.id})">
                            ${hasVoted ? 'â­' : 'â˜†'} <span>${voteCount}</span>
                        </button>
                        <button class="post-action-btn" onclick="focusManifestoComment(${m.id})">
                            ðŸ’¬ ${comments.length}
                        </button>
                    </div>
                    <div class="post-reactions" id="manifesto-reactions-${m.id}">
                        ${reactionsHtml}
                        <div style="position:relative;display:inline-block;">
                            <button class="add-reaction-btn" onclick="toggleManifestoReactionPicker(${m.id})">+ ðŸ˜€</button>
                            <div class="reaction-picker" id="manifesto-picker-${m.id}">
                                ${reactionPickerHtml}
                            </div>
                        </div>
                    </div>
                    <div class="post-comments" id="manifesto-comments-${m.id}">
                        ${commentsHtml}
                    </div>
                    ${replyIndicatorHtml}
                    <div class="comment-input-row">
                        <input class="comment-input" id="manifesto-comment-input-${m.id}" placeholder="${replyingTo && replyingTo.postId === m.id && replyingTo.type === 'manifesto' ? 'Write a reply...' : 'Add a comment...'}" onkeydown="if(event.key==='Enter')addManifestoComment(${m.id})">
                        <button class="comment-send" onclick="addManifestoComment(${m.id})">POST</button>
                    </div>
                </div>
            `;
        }

        window.voteManifesto = async function(manifestoId) {
            if (!currentUser) return;

            const hasVoted = myManifestoVotes[manifestoId];

            if (hasVoted) {
                await supabase
                    .from('sloppygram_manifesto_votes')
                    .delete()
                    .eq('manifesto_id', manifestoId)
                    .eq('user_id', currentUser.id);

                myManifestoVotes[manifestoId] = false;
                manifestoVotes[manifestoId] = Math.max(0, (manifestoVotes[manifestoId] || 0) - 1);
            } else {
                await supabase
                    .from('sloppygram_manifesto_votes')
                    .insert({
                        manifesto_id: manifestoId,
                        username: profile.username,
                        user_id: currentUser.id
                    });

                myManifestoVotes[manifestoId] = true;
                manifestoVotes[manifestoId] = (manifestoVotes[manifestoId] || 0) + 1;
            }

            renderManifestos();
        };

        window.toggleManifestoReactionPicker = function(manifestoId) {
            const picker = document.getElementById(`manifesto-picker-${manifestoId}`);
            document.querySelectorAll('.reaction-picker').forEach(p => {
                if (p !== picker) p.classList.remove('active');
            });
            picker.classList.toggle('active');
        };

        window.toggleManifestoReaction = async function(manifestoId, emoji) {
            if (!currentUser) return;

            const myReacts = myManifestoReactions[manifestoId] || new Set();
            const hasReacted = myReacts.has(emoji);

            if (hasReacted) {
                await supabase
                    .from('sloppygram_manifesto_reactions')
                    .delete()
                    .eq('manifesto_id', manifestoId)
                    .eq('emoji', emoji)
                    .eq('user_id', currentUser.id);

                myReacts.delete(emoji);
                if (!manifestoReactions[manifestoId]) manifestoReactions[manifestoId] = {};
                manifestoReactions[manifestoId][emoji] = Math.max(0, (manifestoReactions[manifestoId][emoji] || 0) - 1);
                if (manifestoReactions[manifestoId][emoji] === 0) delete manifestoReactions[manifestoId][emoji];
            } else {
                await supabase
                    .from('sloppygram_manifesto_reactions')
                    .insert({
                        manifesto_id: manifestoId,
                        emoji,
                        username: profile.username,
                        user_id: currentUser.id
                    });

                myReacts.add(emoji);
                if (!manifestoReactions[manifestoId]) manifestoReactions[manifestoId] = {};
                manifestoReactions[manifestoId][emoji] = (manifestoReactions[manifestoId][emoji] || 0) + 1;
            }

            myManifestoReactions[manifestoId] = myReacts;
            document.querySelectorAll('.reaction-picker').forEach(p => p.classList.remove('active'));
            renderManifestos();
        };

        window.focusManifestoComment = function(manifestoId) {
            document.getElementById(`manifesto-comment-input-${manifestoId}`).focus();
        };

        window.addManifestoComment = async function(manifestoId) {
            const input = document.getElementById(`manifesto-comment-input-${manifestoId}`);
            const content = input.value.trim();
            if (!content || !currentUser) return;

            const comment = {
                manifesto_id: manifestoId,
                username: profile.username,
                avatar: profile.avatar,
                content,
                user_id: currentUser.id
            };

            const { data, error } = await supabase
                .from('sloppygram_manifesto_comments')
                .insert(comment)
                .select()
                .single();

            if (error) {
                console.error('Error adding comment:', error);
                return;
            }

            // If this is a reply, save the thread relationship
            if (replyingTo && replyingTo.postId === manifestoId && replyingTo.type === 'manifesto' && data) {
                await supabase
                    .from('sloppygram_comment_threads')
                    .insert({
                        comment_id: data.id,
                        parent_comment_id: replyingTo.commentId,
                        comment_type: 'manifesto',
                        post_id: manifestoId,
                        user_id: currentUser.id
                    });
                commentThreads[data.id] = replyingTo.commentId;
            }

            if (!manifestoComments[manifestoId]) manifestoComments[manifestoId] = [];
            manifestoComments[manifestoId].push({ ...comment, id: data?.id, created_at: new Date().toISOString() });

            input.value = '';
            replyingTo = null;
            renderManifestos();
        };

        // === REPUTATION SYSTEM ===

        async function loadReputations() {
            // Calculate reputation from post votes (net score using vote_type)
            const { data: postsData } = await supabase
                .from('sloppygram_posts')
                .select('username, id');

            const postsByUser = {};
            (postsData || []).forEach(p => {
                if (p.username) {
                    if (!postsByUser[p.username]) postsByUser[p.username] = [];
                    postsByUser[p.username].push(p.id);
                }
            });

            const { data: postVotesData } = await supabase
                .from('sloppygram_post_likes')
                .select('post_id, vote_type');

            const postVotesByPost = {};
            (postVotesData || []).forEach(v => {
                postVotesByPost[v.post_id] = (postVotesByPost[v.post_id] || 0) + (v.vote_type || 1);
            });

            const postScoresByUser = {};
            for (const [username, postIds] of Object.entries(postsByUser)) {
                postScoresByUser[username] = postIds.reduce((sum, id) => sum + (postVotesByPost[id] || 0), 0);
            }

            // Calculate reputation from manifesto votes
            const { data: manifestosData } = await supabase
                .from('sloppygram_manifestos')
                .select('username, id');

            const manifestosByUser = {};
            (manifestosData || []).forEach(m => {
                if (m.username) {
                    if (!manifestosByUser[m.username]) manifestosByUser[m.username] = [];
                    manifestosByUser[m.username].push(m.id);
                }
            });

            const manifestoVotesByUser = {};
            for (const [username, manifestoIds] of Object.entries(manifestosByUser)) {
                if (manifestoIds.length > 0) {
                    const { count } = await supabase
                        .from('sloppygram_manifesto_votes')
                        .select('*', { count: 'exact', head: true })
                        .in('manifesto_id', manifestoIds);
                    manifestoVotesByUser[username] = count || 0;
                }
            }

            // Calculate reputation from chat message votes (net score)
            const { data: messagesData } = await supabase
                .from('sloppygram_messages')
                .select('username, id');

            const messagesByUser = {};
            (messagesData || []).forEach(m => {
                if (m.username) {
                    if (!messagesByUser[m.username]) messagesByUser[m.username] = [];
                    messagesByUser[m.username].push(m.id);
                }
            });

            const { data: chatVotesData } = await supabase
                .from('sloppygram_message_votes')
                .select('message_id, vote_type');

            const chatVotesByMessage = {};
            (chatVotesData || []).forEach(v => {
                chatVotesByMessage[v.message_id] = (chatVotesByMessage[v.message_id] || 0) + (v.vote_type || 1);
            });

            const chatVotesByUser = {};
            for (const [username, msgIds] of Object.entries(messagesByUser)) {
                chatVotesByUser[username] = msgIds.reduce((sum, id) => sum + (chatVotesByMessage[id] || 0), 0);
            }

            // Calculate reputation from doodle votes (net score)
            const { data: doodleVotesData } = await supabase
                .from('sloppygram_doodle_votes')
                .select('message_id, vote_type');

            const doodleVotesByMessage = {};
            (doodleVotesData || []).forEach(v => {
                doodleVotesByMessage[v.message_id] = (doodleVotesByMessage[v.message_id] || 0) + (v.vote_type || 1);
            });

            const doodleVotesByUser = {};
            for (const [username, msgIds] of Object.entries(messagesByUser)) {
                doodleVotesByUser[username] = msgIds.reduce((sum, id) => sum + (doodleVotesByMessage[id] || 0), 0);
            }

            // Combine into reputation scores
            const allUsers = new Set([
                ...Object.keys(postScoresByUser),
                ...Object.keys(manifestoVotesByUser),
                ...Object.keys(chatVotesByUser),
                ...Object.keys(doodleVotesByUser)
            ]);
            userReputations = {};
            allUsers.forEach(username => {
                const postScore = postScoresByUser[username] || 0;
                const manifestoVotes = manifestoVotesByUser[username] || 0;
                const chatScore = chatVotesByUser[username] || 0;
                const doodleScore = doodleVotesByUser[username] || 0;
                userReputations[username] = {
                    postLikes: postScore,
                    manifestoVotes,
                    chatVotes: chatScore,
                    doodleVotes: doodleScore,
                    total: postScore + (manifestoVotes * 2) + chatScore + (doodleScore * 2)
                };
            });

            console.log('Loaded reputations:', userReputations);
        }

        function getReputationBadge(username) {
            const rep = userReputations[username];
            if (!rep || rep.total === 0) return '';

            let badge = '';
            const parts = [];
            if (rep.postLikes > 0) parts.push(`${rep.postLikes} post`);
            if (rep.manifestoVotes > 0) parts.push(`${rep.manifestoVotes} manifesto`);
            if (rep.chatVotes > 0) parts.push(`${rep.chatVotes} chat`);
            if (rep.doodleVotes > 0) parts.push(`${rep.doodleVotes} doodle`);
            let title = `âš¡${rep.total} power (${parts.join(', ')})`;

            if (rep.total >= 100) {
                badge = 'ðŸ‘‘';
            } else if (rep.total >= 50) {
                badge = 'â­';
            } else if (rep.total >= 20) {
                badge = 'âœ¨';
            } else if (rep.total >= 5) {
                badge = 'ðŸ”¥';
            }

            return badge ? `<span class="rep-badge" title="${title}">${badge}${rep.total}</span>` :
                          `<span class="rep-badge small" title="${title}">âš¡${rep.total}</span>`;
        }

        // === DOODLE LEADERBOARD FUNCTIONALITY ===

        async function loadDoodleVotes() {
            const { data: votes } = await supabase
                .from('sloppygram_doodle_votes')
                .select('message_id, voter_username, vote_type');

            if (votes) {
                doodleVotes = {};
                votes.forEach(v => {
                    doodleVotes[v.message_id] = (doodleVotes[v.message_id] || 0) + (v.vote_type || 1);
                });

                myDoodleVotes = {};
                votes.filter(v => v.voter_username === profile.username).forEach(v => {
                    myDoodleVotes[v.message_id] = v.vote_type || 1;
                });
            }
        }

        window.voteDoodle = async function(messageId, voteType, ownerUsername) {
            if (!currentUser) return;
            if (ownerUsername === profile.username) return; // Can't vote on own doodle

            const currentVote = myDoodleVotes[messageId] || 0;

            if (currentVote === voteType) {
                // Remove vote if clicking same button
                await supabase
                    .from('sloppygram_doodle_votes')
                    .delete()
                    .eq('message_id', messageId)
                    .eq('user_id', currentUser.id);

                myDoodleVotes[messageId] = 0;
                doodleVotes[messageId] = (doodleVotes[messageId] || 0) - voteType;
            } else {
                // Remove existing vote first
                if (currentVote !== 0) {
                    await supabase
                        .from('sloppygram_doodle_votes')
                        .delete()
                        .eq('message_id', messageId)
                        .eq('user_id', currentUser.id);
                    doodleVotes[messageId] = (doodleVotes[messageId] || 0) - currentVote;
                }

                // Add new vote
                await supabase
                    .from('sloppygram_doodle_votes')
                    .insert({
                        message_id: messageId,
                        voter_username: profile.username,
                        vote_type: voteType,
                        user_id: currentUser.id
                    });

                myDoodleVotes[messageId] = voteType;
                doodleVotes[messageId] = (doodleVotes[messageId] || 0) + voteType;
            }

            // Log AI event for doodle vote
            logAiEvent('vote_cast', 'doodle', messageId, {
                vote_type: myDoodleVotes[messageId] || 0,
                net_score: doodleVotes[messageId] || 0
            });

            // Update UI
            updateDoodleVoteUI(messageId);
        };

        function updateDoodleVoteUI(messageId) {
            const score = doodleVotes[messageId] || 0;
            const myVote = myDoodleVotes[messageId] || 0;
            const scoreClass = score > 0 ? 'positive' : score < 0 ? 'negative' : 'neutral';

            document.querySelectorAll(`[data-doodle-id="${messageId}"]`).forEach(container => {
                const scoreEl = container.querySelector('.vote-score');
                const upBtn = container.querySelector('.vote-btn.upvote');
                const downBtn = container.querySelector('.vote-btn.downvote');

                if (scoreEl) {
                    scoreEl.textContent = score;
                    scoreEl.className = `vote-score ${scoreClass}`;
                }
                if (upBtn) upBtn.classList.toggle('active', myVote === 1);
                if (downBtn) downBtn.classList.toggle('active', myVote === -1);
            });
        }

        // === CHAT MESSAGE VOTING ===

        async function loadMessageVotes() {
            const { data: votes } = await supabase
                .from('sloppygram_message_votes')
                .select('message_id, voter_username, vote_type');

            if (votes) {
                messageVotes = {};
                votes.forEach(v => {
                    messageVotes[v.message_id] = (messageVotes[v.message_id] || 0) + (v.vote_type || 1);
                });

                myMessageVotes = {};
                votes.filter(v => v.voter_username === profile.username).forEach(v => {
                    myMessageVotes[v.message_id] = v.vote_type || 1;
                });
            }
        }

        window.voteMessage = async function(messageId, voteType) {
            if (!currentUser) return;

            const currentVote = myMessageVotes[messageId] || 0;

            if (currentVote === voteType) {
                // Remove vote if clicking same button
                await supabase
                    .from('sloppygram_message_votes')
                    .delete()
                    .eq('message_id', messageId)
                    .eq('user_id', currentUser.id);

                myMessageVotes[messageId] = 0;
                messageVotes[messageId] = (messageVotes[messageId] || 0) - voteType;
            } else {
                // Remove existing vote first
                if (currentVote !== 0) {
                    await supabase
                        .from('sloppygram_message_votes')
                        .delete()
                        .eq('message_id', messageId)
                        .eq('user_id', currentUser.id);
                    messageVotes[messageId] = (messageVotes[messageId] || 0) - currentVote;
                }

                // Add new vote
                await supabase
                    .from('sloppygram_message_votes')
                    .insert({
                        message_id: messageId,
                        voter_username: profile.username,
                        vote_type: voteType,
                        user_id: currentUser.id
                    });

                myMessageVotes[messageId] = voteType;
                messageVotes[messageId] = (messageVotes[messageId] || 0) + voteType;
            }

            // Log AI event for message vote
            logAiEvent('vote_cast', 'message', messageId, {
                vote_type: myMessageVotes[messageId] || 0,
                net_score: messageVotes[messageId] || 0
            });

            // Update UI
            updateMessageVoteUI(messageId);
        };

        function updateMessageVoteUI(messageId) {
            const score = messageVotes[messageId] || 0;
            const myVote = myMessageVotes[messageId] || 0;
            const scoreClass = score > 0 ? 'positive' : score < 0 ? 'negative' : 'neutral';

            document.querySelectorAll(`[data-chat-id="${messageId}"]`).forEach(container => {
                const scoreEl = container.querySelector('.vote-score');
                const upBtn = container.querySelector('.vote-btn.upvote');
                const downBtn = container.querySelector('.vote-btn.downvote');

                if (scoreEl) {
                    scoreEl.textContent = score;
                    scoreEl.className = `vote-score ${scoreClass}`;
                }
                if (upBtn) upBtn.classList.toggle('active', myVote === 1);
                if (downBtn) downBtn.classList.toggle('active', myVote === -1);
            });
        }

        // === COMMENT VOTING ===

        async function loadCommentVotes() {
            const { data: votes } = await supabase
                .from('sloppygram_comment_votes')
                .select('comment_id, voter_username, vote_type');

            if (votes) {
                commentVotes = {};
                votes.forEach(v => {
                    commentVotes[v.comment_id] = (commentVotes[v.comment_id] || 0) + (v.vote_type || 1);
                });

                myCommentVotes = {};
                votes.filter(v => v.voter_username === profile.username).forEach(v => {
                    myCommentVotes[v.comment_id] = v.vote_type || 1;
                });
            }
        }

        window.voteComment = async function(commentId, voteType, ownerUsername) {
            if (!currentUser) return;
            if (ownerUsername === profile.username) return; // Can't vote on own comment

            const currentVote = myCommentVotes[commentId] || 0;

            if (currentVote === voteType) {
                // Remove vote if clicking same button
                await supabase
                    .from('sloppygram_comment_votes')
                    .delete()
                    .eq('comment_id', commentId)
                    .eq('user_id', currentUser.id);

                myCommentVotes[commentId] = 0;
                commentVotes[commentId] = (commentVotes[commentId] || 0) - voteType;
            } else {
                // Remove existing vote first
                if (currentVote !== 0) {
                    await supabase
                        .from('sloppygram_comment_votes')
                        .delete()
                        .eq('comment_id', commentId)
                        .eq('user_id', currentUser.id);
                    commentVotes[commentId] = (commentVotes[commentId] || 0) - currentVote;
                }

                // Add new vote
                await supabase
                    .from('sloppygram_comment_votes')
                    .insert({
                        comment_id: commentId,
                        voter_username: profile.username,
                        vote_type: voteType,
                        user_id: currentUser.id
                    });

                myCommentVotes[commentId] = voteType;
                commentVotes[commentId] = (commentVotes[commentId] || 0) + voteType;
            }

            // Log AI event for comment vote
            logAiEvent('vote_cast', 'comment', commentId, {
                vote_type: myCommentVotes[commentId] || 0,
                net_score: commentVotes[commentId] || 0
            });

            // Update UI - re-render posts to reflect vote changes
            renderPosts();
        };

        async function loadDoodleLeaderboard() {
            const container = document.getElementById('doodlesContainer');
            const emptyState = document.getElementById('doodlesEmptyState');

            // Get all doodles with their vote counts
            const { data: doodles, error } = await supabase
                .from('sloppygram_messages')
                .select('*')
                .not('drawing_data', 'is', null)
                .order('created_at', { ascending: false });

            if (error || !doodles || doodles.length === 0) {
                emptyState.style.display = 'block';
                return;
            }

            // Get vote counts with vote_type
            const { data: votes } = await supabase
                .from('sloppygram_doodle_votes')
                .select('message_id, vote_type');

            // Count net votes
            const voteCounts = {};
            if (votes) {
                votes.forEach(v => {
                    voteCounts[v.message_id] = (voteCounts[v.message_id] || 0) + (v.vote_type || 1);
                });
            }

            // Sort by votes (descending), then by date
            const sortedDoodles = doodles
                .map(d => ({ ...d, votes: voteCounts[d.id] || 0 }))
                .sort((a, b) => b.votes - a.votes || new Date(b.created_at) - new Date(a.created_at));

            // Render leaderboard
            container.innerHTML = '<div class="leaderboard-header">ðŸ† LEGENDARY DOODLES ðŸ†</div>';

            if (sortedDoodles.length === 0) {
                container.innerHTML += `<div class="empty-doodles" id="doodlesEmptyState">
                    <div class="icon">ðŸŽ¨</div>
                    <p>NO LEGENDARY DOODLES YET...</p>
                    <p>Draw something and get votes!</p>
                </div>`;
                return;
            }

            // Create grid container
            const grid = document.createElement('div');
            grid.className = 'doodle-grid';

            sortedDoodles.forEach((doodle, index) => {
                const rank = index + 1;
                let rankClass = '';
                if (rank === 1) rankClass = 'gold';
                else if (rank === 2) rankClass = 'silver';
                else if (rank === 3) rankClass = 'bronze';

                const time = new Date(doodle.created_at).toLocaleDateString();
                const myVote = myDoodleVotes[doodle.id] || 0;
                const isOwnDoodle = doodle.username === profile.username;
                const scoreClass = doodle.votes > 0 ? 'positive' : doodle.votes < 0 ? 'negative' : 'neutral';
                const isTop3 = rank <= 3;

                const deleteBtn = isOwnDoodle ? `<button class="msg-delete-btn" onclick="deleteMessage('${doodle.id}')" title="Delete doodle">ðŸ—‘ï¸</button>` : '';

                const card = document.createElement('div');
                card.className = `doodle-card${isTop3 ? ' top-3' : ''}`;
                card.innerHTML = `
                    <div class="doodle-rank">
                        <span class="rank-badge ${rankClass}">${rank}</span>
                        <span class="doodle-artist">${escapeHtml(doodle.username || 'Anonymous')}</span>
                        <span class="doodle-votes ${scoreClass}">${doodle.votes > 0 ? '+' : ''}${doodle.votes}</span>
                        ${deleteBtn}
                    </div>
                    <div class="doodle-thumbnail">
                        <img src="${doodle.drawing_data}" onclick="window.open(this.src)">
                    </div>
                    <div class="doodle-card-actions">
                        <span class="doodle-time">${time}</span>
                        <div class="vote-controls" data-doodle-id="${doodle.id}">
                            <button class="vote-btn upvote ${myVote === 1 ? 'active' : ''} ${isOwnDoodle ? 'disabled' : ''}"
                                onclick="${isOwnDoodle ? '' : `voteDoodle('${doodle.id}', 1, '${escapeHtml(doodle.username)}')`}"
                                title="${isOwnDoodle ? 'Cannot vote on own doodle' : 'Upvote'}">â–²</button>
                            <span class="vote-score ${scoreClass}">${doodle.votes}</span>
                            <button class="vote-btn downvote ${myVote === -1 ? 'active' : ''} ${isOwnDoodle ? 'disabled' : ''}"
                                onclick="${isOwnDoodle ? '' : `voteDoodle('${doodle.id}', -1, '${escapeHtml(doodle.username)}')`}"
                                title="${isOwnDoodle ? 'Cannot vote on own doodle' : 'Downvote'}">â–¼</button>
                        </div>
                    </div>
                `;
                grid.appendChild(card);
            });

            container.appendChild(grid);
        }

        // Mobile sidebar toggle
        window.toggleSidebar = function(side) {
            const sidebarLeft = document.getElementById('sidebarLeft');
            const sidebarRight = document.getElementById('sidebarRight');
            const backdrop = document.getElementById('mobileBackdrop');

            // Close the other sidebar first
            if (side === 'left') {
                sidebarRight.classList.remove('mobile-show');
                sidebarLeft.classList.toggle('mobile-show');
            } else {
                sidebarLeft.classList.remove('mobile-show');
                sidebarRight.classList.toggle('mobile-show');
            }

            // Show backdrop if any sidebar is open
            const isAnyOpen = sidebarLeft.classList.contains('mobile-show') || sidebarRight.classList.contains('mobile-show');
            backdrop.classList.toggle('active', isAnyOpen);
        };

        window.closeSidebars = function() {
            document.getElementById('sidebarLeft').classList.remove('mobile-show');
            document.getElementById('sidebarRight').classList.remove('mobile-show');
            document.getElementById('mobileBackdrop').classList.remove('active');
        };

        // Initialize
        init();
    </script>
</body>
</html>
