<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>Sloppygram - Cyber Chat 1999</title>
    <link rel="icon" href="https://emojicdn.elk.sh/ðŸ’¾">

    <!-- Open Graph -->
    <meta property="og:title" content="Sloppygram - Cyber Chat 1999">
    <meta property="og:description" content="Retro cyber chatroom from 1999. Global chat, doodles, manifestos, and pure neon vibes.">
    <meta property="og:url" content="https://sloppy.live/sloppygram">
    <meta property="og:image" content="https://image.pollinations.ai/prompt/cyberpunk%20neon%20chatroom%20interface%20glowing%20magenta%20cyan%20green%20terminals%20dark%20background%20retro%20hacker%20aesthetic%20vaporwave%20grid%201999?width=1200&height=630&nologo=true&referrer=sloppy.live">
    <meta property="og:type" content="website">
    <meta property="og:site_name" content="Sloppy.live">

    <!-- Twitter Card -->
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:title" content="Sloppygram - Cyber Chat 1999">
    <meta name="twitter:description" content="Retro cyber chatroom from 1999. Global chat, doodles, manifestos, and pure neon vibes.">
    <meta name="twitter:image" content="https://image.pollinations.ai/prompt/cyberpunk%20neon%20chatroom%20interface%20glowing%20magenta%20cyan%20green%20terminals%20dark%20background%20retro%20hacker%20aesthetic%20vaporwave%20grid%201999?width=1200&height=630&nologo=true&referrer=sloppy.live">

    <!-- Additional Meta -->
    <meta name="description" content="Retro cyber chatroom from 1999. Global chat, doodles, manifestos, and pure neon vibes.">
    <meta name="theme-color" content="#0a0a0f">

    <link href="https://fonts.googleapis.com/css2?family=VT323&family=Share+Tech+Mono&display=swap" rel="stylesheet">

    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        :root {
            --accent: #7c9885;
            --accent-light: #a8c4b0;
            --accent-dim: #5a7060;
            --highlight: #c9a87c;
            --dark-bg: #0a0a0f;
            --panel-bg: #12121a;
            --border-color: #2a2a35;
            --text-dim: #6a6a75;
            --msg-opacity: 0.95;
            --msg-color: 10, 10, 15;
            --msg-own-color: 90, 112, 96;
        }

        body {
            font-family: 'VT323', monospace;
            background: var(--dark-bg);
            min-height: 100vh;
            color: var(--accent);
            overflow: hidden;
        }

        /* Scanline effect */
        body::before {
            content: '';
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: repeating-linear-gradient(
                0deg,
                rgba(0, 0, 0, 0.15),
                rgba(0, 0, 0, 0.15) 1px,
                transparent 1px,
                transparent 2px
            );
            pointer-events: none;
            z-index: 9999;
        }

        .app {
            display: grid;
            grid-template-columns: 200px 1fr 180px;
            grid-template-rows: auto 1fr;
            height: 100vh;
            gap: 1px;
            background: transparent;
        }

        /* Hide sidebar close buttons on desktop */
        .sidebar-close-btn {
            display: none;
        }

        @media (max-width: 768px) {
            .app {
                display: flex;
                flex-direction: column;
                height: 100vh;
                height: 100dvh;
                width: 100%;
                max-width: 100vw;
                overflow-x: hidden;
                padding-top: env(safe-area-inset-top, 0);
                padding-bottom: env(safe-area-inset-bottom, 0);
                padding-left: env(safe-area-inset-left, 0);
                padding-right: env(safe-area-inset-right, 0);
            }

            .sidebar-close-btn {
                display: flex;
                align-items: center;
                justify-content: center;
                width: 30px;
                height: 30px;
                position: absolute;
                top: 8px;
                right: 8px;
                background: var(--border-color);
                border: none;
                color: var(--accent);
                font-size: 1.2rem;
                cursor: pointer;
                border-radius: 4px;
                z-index: 10;
            }

            .sidebar-close-btn:hover {
                background: var(--accent-dim);
            }

            .drawer-header {
                display: flex;
                justify-content: space-between;
                align-items: center;
                padding-bottom: 12px;
                border-bottom: 1px solid var(--border-color);
                margin-bottom: 12px;
            }

            .drawer-header .panel-title {
                margin: 0;
            }

            .drawer-header .sidebar-close-btn {
                position: static;
            }

            .drawer-footer {
                margin-top: auto;
                padding-top: 12px;
                border-top: 1px solid var(--border-color);
            }

            .stream-link {
                color: var(--text-dim);
                text-decoration: none;
                font-size: 0.85rem;
                display: block;
                padding: 8px;
                text-align: center;
                transition: color 0.2s;
            }

            .stream-link:hover {
                color: var(--accent);
            }

            .mobile-backdrop {
                display: none;
                position: fixed;
                top: 60px;
                left: 0;
                right: 0;
                bottom: 0;
                background: rgba(0, 0, 0, 0.6);
                z-index: 100;
            }

            .mobile-backdrop.active {
                display: block;
            }
        }

        /* Header */
        .header {
            grid-column: 1 / -1;
            grid-row: 1;
            background: var(--panel-bg);
            padding: 8px 16px;
            display: flex;
            align-items: center;
            justify-content: space-between;
            flex-shrink: 0;
            min-height: 50px;
            z-index: 10;
            position: relative;
        }

        .logo {
            font-size: 1.8rem;
            color: var(--accent-light);
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .logo-blink {
            animation: blink 1s infinite;
        }

        @keyframes blink {
            0%, 50% { opacity: 1; }
            51%, 100% { opacity: 0; }
        }

        .marquee-container {
            flex: 1;
            overflow: hidden;
            margin: 0 20px;
            color: var(--highlight);
            font-size: 1.1rem;
        }

        .marquee {
            display: inline-block;
            white-space: nowrap;
            animation: marquee 20s linear infinite;
        }

        @keyframes marquee {
            from { transform: translateX(100%); }
            to { transform: translateX(-100%); }
        }

        .header-actions {
            display: flex;
            gap: 8px;
        }

        .cyber-btn {
            background: transparent;
            border: 1px solid var(--border-color);
            color: var(--accent);
            padding: 6px 12px;
            font-family: inherit;
            font-size: 1rem;
            cursor: pointer;
            transition: all 0.2s;
        }

        .cyber-btn:hover {
            background: var(--accent-dim);
            color: white;
        }

        .reboot-btn {
            background: transparent;
            border: 1px solid #00ff00;
            color: #00ff00;
            padding: 6px 10px;
            font-size: 1.1rem;
            cursor: pointer;
            transition: all 0.2s;
            position: relative;
        }

        .reboot-btn:hover {
            background: rgba(0, 255, 0, 0.1);
            animation: rebootBtnGlitch 0.3s infinite;
            text-shadow: 0 0 5px #00ff00;
        }

        @keyframes rebootBtnGlitch {
            0%, 100% { transform: translate(0); }
            25% { transform: translate(-1px, 1px); }
            50% { transform: translate(1px, -1px); }
            75% { transform: translate(-1px, -1px); }
        }

        /* === SUPPORT MODAL SYSTEM === */
        .support-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0,0,0,0.92);
            z-index: 2000;
            align-items: center;
            justify-content: center;
            backdrop-filter: blur(6px);
            overflow-y: auto;
            padding: 20px;
        }

        .support-modal.visible {
            display: flex;
        }

        .support-modal-content {
            background: linear-gradient(145deg, #0a0a0a 0%, #151515 100%);
            border: 2px solid var(--accent);
            border-radius: 12px;
            padding: 24px;
            max-width: 600px;
            width: 100%;
            box-shadow: 0 0 60px rgba(0, 255, 136, 0.1);
            max-height: 90vh;
            overflow-y: auto;
        }

        .support-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            padding-bottom: 16px;
            border-bottom: 1px solid var(--border-color);
        }

        .support-header h2 {
            color: var(--accent);
            font-size: 1.4rem;
            margin: 0;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .support-close {
            background: transparent;
            border: none;
            color: var(--text-dim);
            font-size: 1.8rem;
            cursor: pointer;
            padding: 4px 8px;
            line-height: 1;
            transition: color 0.2s;
        }

        .support-close:hover {
            color: #ff4444;
        }

        .support-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 14px;
            margin-bottom: 16px;
        }

        @media (max-width: 550px) {
            .support-grid {
                grid-template-columns: 1fr;
            }
            .support-modal-content {
                padding: 16px;
            }
        }

        .support-option {
            background: #0d0d0d;
            border: 1px solid var(--border-color);
            border-radius: 8px;
            padding: 14px;
            text-align: center;
            transition: all 0.2s;
            cursor: pointer;
        }

        .support-option:hover {
            transform: translateY(-2px);
        }

        /* Crypto-specific colors */
        .support-option.btc { border-color: #f7931a; }
        .support-option.btc:hover { box-shadow: 0 4px 20px rgba(247, 147, 26, 0.25); }
        .support-option.btc .support-icon { color: #f7931a; }

        .support-option.eth { border-color: #627eea; }
        .support-option.eth:hover { box-shadow: 0 4px 20px rgba(98, 126, 234, 0.25); }
        .support-option.eth .support-icon { color: #627eea; }

        .support-option.sol { border-color: #14f195; }
        .support-option.sol:hover { box-shadow: 0 4px 20px rgba(20, 241, 149, 0.25); }
        .support-option.sol .support-icon { color: #14f195; }

        .support-option.xmr { border-color: #ff6600; }
        .support-option.xmr:hover { box-shadow: 0 4px 20px rgba(255, 102, 0, 0.25); }
        .support-option.xmr .support-icon { color: #ff6600; }

        .support-option.stripe { border-color: #635bff; }
        .support-option.stripe:hover { box-shadow: 0 4px 20px rgba(99, 91, 255, 0.25); }

        .support-icon {
            font-size: 1.8rem;
            margin-bottom: 6px;
        }

        .support-option h3 {
            color: var(--text);
            font-size: 0.9rem;
            margin-bottom: 10px;
            font-weight: bold;
        }

        .crypto-address {
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.55rem;
            background: #050505;
            padding: 8px;
            border-radius: 4px;
            word-break: break-all;
            cursor: pointer;
            border: 1px dashed currentColor;
            transition: all 0.2s;
            opacity: 0.9;
        }

        .support-option.btc .crypto-address { color: #f7931a; }
        .support-option.eth .crypto-address { color: #627eea; }
        .support-option.sol .crypto-address { color: #14f195; }
        .support-option.xmr .crypto-address { color: #ff6600; }

        .crypto-address:hover {
            background: #111;
            border-style: solid;
            opacity: 1;
        }

        .copy-hint {
            font-size: 0.65rem;
            color: var(--text-dim);
            margin-top: 6px;
            opacity: 0.7;
        }

        /* Fiat Section */
        .support-section-label {
            font-size: 0.75rem;
            color: var(--text-dim);
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-bottom: 12px;
            padding-bottom: 6px;
            border-bottom: 1px dashed var(--border-color);
        }

        .fiat-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 10px;
            margin-bottom: 20px;
        }

        @media (max-width: 550px) {
            .fiat-grid {
                grid-template-columns: 1fr;
            }
        }

        .fiat-btn {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            padding: 12px 16px;
            border-radius: 6px;
            font-weight: bold;
            font-size: 0.85rem;
            text-decoration: none;
            transition: all 0.2s;
            border: none;
            cursor: pointer;
        }

        .fiat-btn:hover {
            transform: translateY(-2px);
        }

        .fiat-btn.kofi {
            background: linear-gradient(135deg, #ff5e5b 0%, #ff4444 100%);
            color: white;
        }
        .fiat-btn.kofi:hover {
            box-shadow: 0 4px 15px rgba(255, 94, 91, 0.4);
        }

        .fiat-btn.paypal {
            background: linear-gradient(135deg, #003087 0%, #001f5c 100%);
            color: white;
        }
        .fiat-btn.paypal:hover {
            box-shadow: 0 4px 15px rgba(0, 48, 135, 0.4);
        }

        .fiat-btn.patreon {
            background: linear-gradient(135deg, #ff424d 0%, #e63946 100%);
            color: white;
        }
        .fiat-btn.patreon:hover {
            box-shadow: 0 4px 15px rgba(255, 66, 77, 0.4);
        }

        .stripe-btn {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            background: linear-gradient(135deg, #635bff 0%, #7c3aed 100%);
            color: white;
            padding: 12px 24px;
            text-decoration: none;
            border-radius: 6px;
            font-weight: bold;
            font-size: 0.9rem;
            border: none;
            cursor: pointer;
            transition: all 0.2s;
            width: 100%;
        }

        .stripe-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(99, 91, 255, 0.4);
        }

        .support-footer {
            text-align: center;
            color: var(--text-dim);
            font-size: 0.75rem;
            padding-top: 12px;
            border-top: 1px solid var(--border-color);
        }

        .copied-toast {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: linear-gradient(135deg, #f7931a 0%, #ff6b00 100%);
            color: #000;
            padding: 12px 20px;
            border-radius: 6px;
            font-weight: bold;
            z-index: 3000;
            display: flex;
            align-items: center;
            gap: 8px;
            animation: toastSlide 2.5s forwards;
            box-shadow: 0 4px 20px rgba(247, 147, 26, 0.4);
        }

        @keyframes toastSlide {
            0% { opacity: 0; transform: translateX(-50%) translateY(20px); }
            10% { opacity: 1; transform: translateX(-50%) translateY(0); }
            80% { opacity: 1; transform: translateX(-50%) translateY(0); }
            100% { opacity: 0; transform: translateX(-50%) translateY(-10px); }
        }

        .donate-btn {
            background: linear-gradient(135deg, #f7931a 0%, #ff6b00 100%);
            border: none;
            color: #000;
            padding: 6px 12px;
            font-size: 0.9rem;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.2s;
            border-radius: 4px;
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .donate-btn:hover {
            box-shadow: 0 0 12px rgba(247, 147, 26, 0.5);
            transform: scale(1.02);
        }

        /* Image Lightbox */
        .lightbox {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.95);
            z-index: 10000;
            justify-content: center;
            align-items: center;
            cursor: pointer;
        }

        .lightbox.active {
            display: flex;
        }

        .lightbox-image {
            max-width: 90%;
            max-height: 90%;
            object-fit: contain;
            border: 2px solid var(--accent);
            box-shadow: 0 0 30px rgba(0, 255, 136, 0.5), 0 0 60px rgba(0, 255, 136, 0.3);
            animation: lightboxFadeIn 0.3s ease-out;
        }

        .lightbox-close {
            position: absolute;
            top: 20px;
            right: 30px;
            font-size: 2.5rem;
            color: var(--accent);
            background: none;
            border: none;
            cursor: pointer;
            text-shadow: 0 0 10px var(--accent);
            transition: all 0.2s;
        }

        .lightbox-close:hover {
            color: #fff;
            transform: scale(1.2);
        }

        @keyframes lightboxFadeIn {
            from {
                opacity: 0;
                transform: scale(0.8);
            }
            to {
                opacity: 1;
                transform: scale(1);
            }
        }

        /* Share Modal - Glassmorphism */
        .share-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.7);
            backdrop-filter: blur(8px);
            -webkit-backdrop-filter: blur(8px);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 2000;
            opacity: 0;
            visibility: hidden;
            transition: all 0.3s ease;
        }

        .share-modal.visible {
            opacity: 1;
            visibility: visible;
        }

        .share-modal-content {
            background: rgba(18, 18, 26, 0.85);
            backdrop-filter: blur(20px);
            -webkit-backdrop-filter: blur(20px);
            border: 1px solid rgba(124, 152, 133, 0.3);
            border-radius: 16px;
            padding: 28px;
            width: 90%;
            max-width: 380px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.5);
            transform: translateY(20px);
            transition: transform 0.3s ease;
        }

        .share-modal.visible .share-modal-content {
            transform: translateY(0);
        }

        .share-modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 24px;
        }

        .share-modal-title {
            font-size: 1.4rem;
            color: var(--accent-light);
            letter-spacing: 1px;
        }

        .share-modal-close {
            background: none;
            border: none;
            color: var(--text-dim);
            font-size: 1.5rem;
            cursor: pointer;
            padding: 4px 8px;
            transition: color 0.2s;
        }

        .share-modal-close:hover {
            color: var(--accent);
        }

        .share-buttons {
            display: flex;
            flex-direction: column;
            gap: 12px;
        }

        .share-btn {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 12px;
            padding: 14px 20px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 12px;
            font-size: 1rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.25s ease;
            text-decoration: none;
            background: rgba(255, 255, 255, 0.05);
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
        }

        .share-btn:hover {
            transform: translateY(-2px);
            border-color: rgba(255, 255, 255, 0.2);
        }

        .share-btn.x-twitter {
            color: #fff;
            background: linear-gradient(135deg, rgba(0, 0, 0, 0.6) 0%, rgba(30, 30, 30, 0.6) 100%);
        }
        .share-btn.x-twitter:hover {
            box-shadow: 0 4px 20px rgba(255, 255, 255, 0.15);
            background: linear-gradient(135deg, rgba(20, 20, 20, 0.8) 0%, rgba(50, 50, 50, 0.8) 100%);
        }

        .share-btn.reddit {
            color: #ff4500;
            background: linear-gradient(135deg, rgba(255, 69, 0, 0.1) 0%, rgba(255, 69, 0, 0.05) 100%);
        }
        .share-btn.reddit:hover {
            box-shadow: 0 4px 20px rgba(255, 69, 0, 0.25);
            background: linear-gradient(135deg, rgba(255, 69, 0, 0.2) 0%, rgba(255, 69, 0, 0.1) 100%);
        }

        .share-btn.copy-link {
            color: var(--accent);
            background: linear-gradient(135deg, rgba(124, 152, 133, 0.1) 0%, rgba(124, 152, 133, 0.05) 100%);
        }
        .share-btn.copy-link:hover {
            box-shadow: 0 4px 20px rgba(124, 152, 133, 0.25);
            background: linear-gradient(135deg, rgba(124, 152, 133, 0.2) 0%, rgba(124, 152, 133, 0.1) 100%);
        }

        .share-btn-icon {
            font-size: 1.3rem;
            width: 28px;
            text-align: center;
        }

        .share-btn.copied {
            background: linear-gradient(135deg, rgba(0, 255, 65, 0.2) 0%, rgba(0, 255, 65, 0.1) 100%) !important;
            color: #00ff41 !important;
            border-color: rgba(0, 255, 65, 0.3) !important;
        }

        .share-btn {
            font-family: 'VT323', monospace;
        }

        /* Sidebars */
        .sidebar-left, .sidebar-right {
            grid-row: 2;
            background: var(--panel-bg);
            padding: 12px;
            overflow-y: auto;
            display: flex;
            flex-direction: column;
        }

        /* Mobile: completely hide sidebars when not active */
        @media (max-width: 768px) {
            .sidebar-left, .sidebar-right {
                display: none;
                position: fixed;
                top: 60px;
                bottom: 0;
                width: 75%;
                max-width: 280px;
                z-index: 101;
                box-shadow: 0 0 20px rgba(0,0,0,0.5);
            }
            .sidebar-left.mobile-show, .sidebar-right.mobile-show {
                display: flex;
            }
            .sidebar-left.mobile-show { left: 0; }
            .sidebar-right.mobile-show { right: 0; }

            .main-content {
                width: 100%;
                flex: 1;
                min-height: 0;
                overflow: hidden;
                display: flex;
                flex-direction: column;
            }

            .input-area {
                flex-shrink: 0;
                position: sticky;
                top: 0;
                z-index: 10;
                background: var(--panel-bg);
            }

            .messages-container,
            .posts-container,
            .doodles-container,
            .manifesto-container {
                flex: 1;
                min-height: 0;
                max-height: none;
                overflow-y: auto;
                -webkit-overflow-scrolling: touch;
                width: 100%;
                padding: 8px;
                box-sizing: border-box;
            }

            .view-tabs {
                flex-shrink: 0;
                width: 100%;
            }

            .input-area {
                width: 100%;
                padding: 8px;
                box-sizing: border-box;
            }

            .input-row {
                width: 100%;
                max-width: 100%;
            }

            .message, .post, .doodle-card, .manifesto-item {
                width: 100%;
                max-width: 100%;
                box-sizing: border-box;
            }

            /* Prevent iOS auto-zoom on inputs */
            input, textarea, select {
                font-size: 16px !important;
            }
        }

        #publicFeed {
            max-height: 40vh;
            overflow-y: auto;
            flex-shrink: 1;
        }

        .panel-title {
            color: var(--highlight);
            font-size: 1.2rem;
            margin-bottom: 10px;
            padding-bottom: 6px;
            border-bottom: 1px solid var(--border-color);
        }

        /* Online Users */
        .user-list {
            list-style: none;
        }

        .user-item {
            padding: 6px 8px;
            margin-bottom: 4px;
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 1rem;
            border-left: 2px solid transparent;
            transition: all 0.2s;
        }

        .user-item:hover {
            background: rgba(255, 255, 255, 0.05);
            border-left-color: var(--accent);
        }

        .user-status {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: var(--accent);
            animation: pulse 2s infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        .user-avatar {
            font-size: 1.2rem;
        }

        .user-name {
            color: var(--accent-light);
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        .user-away-status {
            font-size: 0.75rem;
            color: var(--text-dim);
            font-style: italic;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
            max-width: 120px;
        }

        .user-item-content {
            display: flex;
            flex-direction: column;
            overflow: hidden;
            flex: 1;
        }

        /* Away Status Input */
        .away-status-section {
            padding: 12px;
            border-bottom: 1px solid var(--border-color);
            margin-bottom: 8px;
        }

        .away-status-input-wrapper {
            display: flex;
            gap: 8px;
            align-items: center;
        }

        .away-status-input {
            flex: 1;
            background: var(--dark-bg);
            border: 1px solid var(--border-color);
            color: var(--accent-light);
            padding: 6px 10px;
            font-family: inherit;
            font-size: 0.85rem;
            border-radius: 4px;
            outline: none;
        }

        .away-status-input:focus {
            border-color: var(--accent);
            box-shadow: 0 0 8px rgba(0, 255, 136, 0.2);
        }

        .away-status-input::placeholder {
            color: var(--text-dim);
            font-style: italic;
        }

        .away-status-btn {
            background: var(--accent);
            color: var(--dark-bg);
            border: none;
            padding: 6px 12px;
            font-family: inherit;
            font-size: 0.8rem;
            font-weight: bold;
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .away-status-btn:hover {
            filter: brightness(1.2);
        }

        .away-status-current {
            margin-top: 8px;
            font-size: 0.8rem;
            color: var(--text-dim);
        }

        .away-status-current .status-text {
            color: var(--accent-light);
            font-style: italic;
        }

        .clear-status-btn {
            background: none;
            border: none;
            color: #ff6666;
            cursor: pointer;
            font-size: 0.75rem;
            margin-left: 8px;
        }

        .clear-status-btn:hover {
            text-decoration: underline;
        }

        /* Tag Cloud */
        .tag-cloud-section {
            margin-top: 16px;
            padding-top: 16px;
            border-top: 1px solid var(--border-color);
        }

        .tag-cloud-section .panel-title {
            margin-bottom: 12px;
        }

        .tag-cloud {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            align-items: center;
            justify-content: center;
            min-height: 60px;
            padding: 8px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            border: 1px solid var(--border-color);
        }

        .tag-cloud-empty {
            color: var(--text-dim);
            font-size: 0.85rem;
            font-style: italic;
        }

        .tag-cloud-item {
            display: inline-block;
            padding: 4px 10px;
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.3s ease;
            text-shadow: 0 0 8px currentColor;
            animation: tagPulse 3s ease-in-out infinite;
            animation-delay: var(--pulse-delay, 0s);
        }

        .tag-cloud-item:hover {
            transform: scale(1.15);
            filter: brightness(1.3);
        }

        /* Neon color palette for tags */
        .tag-cloud-item.neon-cyan {
            color: #00ffff;
            background: rgba(0, 255, 255, 0.15);
            border: 1px solid rgba(0, 255, 255, 0.4);
            box-shadow: 0 0 10px rgba(0, 255, 255, 0.3), inset 0 0 10px rgba(0, 255, 255, 0.1);
        }

        .tag-cloud-item.neon-magenta {
            color: #ff00ff;
            background: rgba(255, 0, 255, 0.15);
            border: 1px solid rgba(255, 0, 255, 0.4);
            box-shadow: 0 0 10px rgba(255, 0, 255, 0.3), inset 0 0 10px rgba(255, 0, 255, 0.1);
        }

        .tag-cloud-item.neon-green {
            color: #00ff88;
            background: rgba(0, 255, 136, 0.15);
            border: 1px solid rgba(0, 255, 136, 0.4);
            box-shadow: 0 0 10px rgba(0, 255, 136, 0.3), inset 0 0 10px rgba(0, 255, 136, 0.1);
        }

        .tag-cloud-item.neon-yellow {
            color: #ffff00;
            background: rgba(255, 255, 0, 0.15);
            border: 1px solid rgba(255, 255, 0, 0.4);
            box-shadow: 0 0 10px rgba(255, 255, 0, 0.3), inset 0 0 10px rgba(255, 255, 0, 0.1);
        }

        .tag-cloud-item.neon-orange {
            color: #ff8800;
            background: rgba(255, 136, 0, 0.15);
            border: 1px solid rgba(255, 136, 0, 0.4);
            box-shadow: 0 0 10px rgba(255, 136, 0, 0.3), inset 0 0 10px rgba(255, 136, 0, 0.1);
        }

        .tag-cloud-item.neon-pink {
            color: #ff66b2;
            background: rgba(255, 102, 178, 0.15);
            border: 1px solid rgba(255, 102, 178, 0.4);
            box-shadow: 0 0 10px rgba(255, 102, 178, 0.3), inset 0 0 10px rgba(255, 102, 178, 0.1);
        }

        /* Size classes based on frequency */
        .tag-cloud-item.size-1 { font-size: 0.75rem; }
        .tag-cloud-item.size-2 { font-size: 0.9rem; }
        .tag-cloud-item.size-3 { font-size: 1.05rem; }
        .tag-cloud-item.size-4 { font-size: 1.2rem; }
        .tag-cloud-item.size-5 { font-size: 1.4rem; font-weight: bold; }

        @keyframes tagPulse {
            0%, 100% { opacity: 0.9; }
            50% { opacity: 1; text-shadow: 0 0 12px currentColor, 0 0 20px currentColor; }
        }

        @keyframes tagAppear {
            from {
                opacity: 0;
                transform: scale(0.5);
            }
            to {
                opacity: 1;
                transform: scale(1);
            }
        }

        /* Tag Explorer Modal */
        .tag-explorer-modal .modal {
            max-width: 500px;
        }

        .tag-explorer-header {
            display: flex;
            align-items: center;
            gap: 12px;
            margin-bottom: 20px;
        }

        .tag-explorer-tag {
            font-size: 2rem;
            font-weight: bold;
            background: linear-gradient(135deg, var(--accent), var(--secondary));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .tag-explorer-stats {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 12px;
            margin-bottom: 20px;
        }

        .tag-stat {
            background: rgba(0, 255, 65, 0.05);
            border: 1px solid var(--border-color);
            padding: 12px;
            text-align: center;
        }

        .tag-stat-count {
            font-size: 1.5rem;
            font-weight: bold;
            color: var(--accent-light);
        }

        .tag-stat-label {
            font-size: 0.7rem;
            color: var(--text-dim);
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .tag-explorer-section {
            margin-bottom: 20px;
        }

        .tag-explorer-section h3 {
            font-size: 0.85rem;
            color: var(--accent);
            margin-bottom: 12px;
            text-transform: uppercase;
            letter-spacing: 1px;
            border-bottom: 1px solid var(--border-color);
            padding-bottom: 6px;
        }

        .tag-users {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
        }

        .tag-user {
            display: flex;
            align-items: center;
            gap: 6px;
            background: rgba(0, 255, 65, 0.08);
            border: 1px solid var(--border-color);
            padding: 6px 10px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .tag-user:hover {
            background: rgba(0, 255, 65, 0.15);
            border-color: var(--accent);
        }

        .tag-user-avatar {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.75rem;
            overflow: hidden;
        }

        .tag-user-avatar img {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        .tag-user-name {
            font-size: 0.8rem;
            color: var(--accent-light);
        }

        .tag-user-count {
            font-size: 0.7rem;
            color: var(--text-dim);
        }

        .tag-content-list {
            max-height: 200px;
            overflow-y: auto;
        }

        .tag-content-item {
            padding: 10px;
            border-bottom: 1px solid var(--border-color);
            display: flex;
            gap: 10px;
        }

        .tag-content-item:last-child {
            border-bottom: none;
        }

        .tag-content-avatar {
            width: 28px;
            height: 28px;
            border-radius: 50%;
            flex-shrink: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.85rem;
            overflow: hidden;
        }

        .tag-content-avatar img {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        .tag-content-body {
            flex: 1;
            min-width: 0;
        }

        .tag-content-username {
            font-size: 0.75rem;
            color: var(--accent);
            font-weight: bold;
        }

        .tag-content-type {
            font-size: 0.65rem;
            color: var(--text-dim);
            margin-left: 6px;
        }

        .tag-content-text {
            font-size: 0.8rem;
            color: var(--accent-light);
            margin-top: 4px;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        .tag-explorer-loading {
            text-align: center;
            padding: 40px;
            color: var(--text-dim);
        }

        .tag-explorer-empty {
            text-align: center;
            padding: 20px;
            color: var(--text-dim);
            font-size: 0.85rem;
        }

        .tag-explorer-tabs {
            display: flex;
            gap: 8px;
            margin-bottom: 16px;
            border-bottom: 1px solid var(--border-color);
            padding-bottom: 12px;
        }

        .tag-tab {
            background: transparent;
            border: 1px solid var(--border-color);
            color: var(--text-dim);
            padding: 8px 16px;
            cursor: pointer;
            font-family: inherit;
            font-size: 0.85rem;
            transition: all 0.2s;
        }

        .tag-tab:hover {
            border-color: var(--accent);
            color: var(--accent-light);
        }

        .tag-tab.active {
            background: rgba(0, 255, 65, 0.1);
            border-color: var(--accent);
            color: var(--accent);
        }

        .tag-explorer-tab-content {
            max-height: 400px;
            overflow-y: auto;
        }

        .tag-explorer-posts .post-card,
        .tag-explorer-manifestos .manifesto-card {
            margin-bottom: 12px;
        }

        .tag-explorer-message {
            display: flex;
            align-items: flex-start;
            gap: 10px;
            padding: 10px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            margin-bottom: 10px;
            border-left: 3px solid var(--accent-color, #0ff);
        }

        .tag-explorer-message .avatar {
            width: 36px;
            height: 36px;
            min-width: 36px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.4em;
            background: rgba(0, 0, 0, 0.4);
            border-radius: 50%;
            overflow: hidden;
        }

        .tag-explorer-message .tag-msg-bubble {
            flex: 1;
            min-width: 0;
        }

        .tag-explorer-message .tag-msg-header {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 4px;
        }

        .tag-explorer-message .msg-username {
            color: var(--accent-color, #0ff);
            cursor: pointer;
            font-weight: bold;
        }

        .tag-explorer-message .msg-username:hover {
            text-decoration: underline;
        }

        .tag-explorer-message .msg-time {
            font-size: 0.75em;
            opacity: 0.5;
        }

        .tag-explorer-message .msg-content {
            word-break: break-word;
            line-height: 1.4;
        }

        .tag-filter-btn {
            background: linear-gradient(135deg, var(--accent-dim), var(--accent)) !important;
            border: 2px solid var(--accent-color, #0ff) !important;
            font-weight: bold;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .tag-filter-btn:hover {
            box-shadow: 0 0 15px var(--accent-color, #0ff);
            transform: translateY(-1px);
        }

        .tag-explorer-modal .modal {
            max-width: 600px;
            max-height: 90vh;
            overflow-y: auto;
        }

        .tag-cloud-item.new-tag {
            animation: tagAppear 0.4s ease-out, tagPulse 3s ease-in-out infinite 0.4s;
        }

        /* Feedback Hub Integration */
        .feedback-container {
            display: none;
            padding: 16px;
            height: calc(100vh - 200px);
            overflow-y: auto;
        }

        .feedback-container.active {
            display: block;
        }

        .feedback-stats {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 10px;
            margin-bottom: 16px;
        }

        .feedback-stat {
            background: rgba(0, 255, 65, 0.05);
            border: 1px solid var(--border-color);
            padding: 12px;
            text-align: center;
        }

        .feedback-stat-num {
            font-size: 1.4rem;
            font-weight: bold;
            color: var(--accent-light);
        }

        .feedback-stat-label {
            font-size: 0.65rem;
            color: var(--text-dim);
            text-transform: uppercase;
        }

        .feedback-filters {
            display: flex;
            gap: 6px;
            margin-bottom: 16px;
            flex-wrap: wrap;
        }

        .feedback-filter {
            padding: 6px 12px;
            background: rgba(0, 255, 65, 0.05);
            border: 1px solid var(--border-color);
            color: var(--text-dim);
            font-size: 0.75rem;
            cursor: pointer;
            transition: all 0.2s;
        }

        .feedback-filter:hover {
            background: rgba(0, 255, 65, 0.1);
        }

        .feedback-filter.active {
            background: rgba(0, 255, 65, 0.15);
            border-color: var(--accent);
            color: var(--accent-light);
        }

        .feedback-new-btn {
            width: 100%;
            padding: 12px;
            background: linear-gradient(135deg, var(--accent), var(--secondary));
            border: none;
            color: #000;
            font-weight: bold;
            cursor: pointer;
            margin-bottom: 16px;
            font-size: 0.85rem;
        }

        .feedback-new-btn:hover {
            opacity: 0.9;
        }

        .feedback-form {
            background: rgba(0, 255, 65, 0.03);
            border: 1px solid var(--border-color);
            padding: 16px;
            margin-bottom: 16px;
            display: none;
        }

        .feedback-form.active {
            display: block;
        }

        .feedback-form input,
        .feedback-form textarea {
            width: 100%;
            padding: 10px;
            background: var(--dark-bg);
            border: 1px solid var(--border-color);
            color: var(--accent-light);
            font-family: inherit;
            margin-bottom: 10px;
            font-size: 0.85rem;
        }

        .feedback-form textarea {
            min-height: 80px;
            resize: vertical;
        }

        .feedback-categories {
            display: flex;
            gap: 6px;
            margin-bottom: 12px;
            flex-wrap: wrap;
        }

        .feedback-cat-btn {
            padding: 6px 12px;
            background: rgba(0, 255, 65, 0.05);
            border: 1px solid var(--border-color);
            color: var(--text-dim);
            font-size: 0.75rem;
            cursor: pointer;
        }

        .feedback-cat-btn.selected {
            background: rgba(0, 255, 65, 0.15);
            border-color: var(--accent);
            color: var(--accent-light);
        }

        .feedback-submit-btn {
            width: 100%;
            padding: 10px;
            background: var(--accent);
            border: none;
            color: #000;
            font-weight: bold;
            cursor: pointer;
        }

        .feedback-list {
            display: flex;
            flex-direction: column;
            gap: 12px;
        }

        .feedback-card {
            background: rgba(0, 255, 65, 0.03);
            border: 1px solid var(--border-color);
            padding: 14px;
            display: flex;
            gap: 12px;
        }

        .feedback-card.own {
            border-left: 3px solid var(--accent);
        }

        .feedback-vote {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 4px;
            min-width: 45px;
        }

        .feedback-vote-btn {
            width: 36px;
            height: 36px;
            background: rgba(0, 255, 65, 0.05);
            border: 1px solid var(--border-color);
            color: var(--text-dim);
            font-size: 1.1rem;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s;
        }

        .feedback-vote-btn:hover {
            background: rgba(0, 255, 65, 0.15);
            border-color: var(--accent);
        }

        .feedback-vote-btn.voted {
            background: var(--accent);
            border-color: var(--accent);
            color: #000;
        }

        .feedback-vote-count {
            font-size: 1.1rem;
            font-weight: bold;
            color: var(--accent);
        }

        .feedback-content {
            flex: 1;
            min-width: 0;
        }

        .feedback-title {
            font-weight: bold;
            color: var(--accent-light);
            margin-bottom: 6px;
            font-size: 0.95rem;
        }

        .feedback-desc {
            color: var(--text-dim);
            font-size: 0.8rem;
            line-height: 1.4;
            margin-bottom: 8px;
        }

        .feedback-meta {
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
            align-items: center;
        }

        .feedback-category-tag {
            padding: 3px 8px;
            background: rgba(139, 92, 246, 0.2);
            font-size: 0.65rem;
            font-weight: bold;
            color: #a78bfa;
            text-transform: uppercase;
        }

        .feedback-category-tag.sloppy { background: rgba(236, 72, 153, 0.2); color: #f472b6; }
        .feedback-category-tag.streamer { background: rgba(245, 158, 11, 0.2); color: #fbbf24; }
        .feedback-category-tag.apps { background: rgba(34, 197, 94, 0.2); color: #4ade80; }

        .feedback-time {
            font-size: 0.7rem;
            color: var(--text-dim);
        }

        .feedback-delete {
            padding: 3px 8px;
            background: rgba(239, 68, 68, 0.15);
            border: 1px solid rgba(239, 68, 68, 0.25);
            color: #f87171;
            font-size: 0.65rem;
            cursor: pointer;
        }

        .feedback-empty {
            text-align: center;
            padding: 40px;
            color: var(--text-dim);
        }

        /* Cross-app Profile Stats */
        .profile-crossapp {
            margin-top: 12px;
            padding-top: 12px;
            border-top: 1px solid var(--border-color);
        }

        .profile-crossapp-title {
            font-size: 0.7rem;
            color: var(--text-dim);
            text-transform: uppercase;
            margin-bottom: 8px;
        }

        .profile-game-scores {
            display: flex;
            flex-wrap: wrap;
            gap: 6px;
        }

        .profile-game-score {
            background: rgba(139, 92, 246, 0.1);
            border: 1px solid rgba(139, 92, 246, 0.2);
            padding: 4px 8px;
            font-size: 0.7rem;
        }

        .profile-game-score .game-name {
            color: var(--text-dim);
        }

        .profile-game-score .game-score {
            color: #a78bfa;
            font-weight: bold;
            margin-left: 4px;
        }

        /* Public Feed */
        .feed-item {
            padding: 8px;
            margin-bottom: 8px;
            background: rgba(255, 255, 255, 0.02);
            border-left: 2px solid var(--border-color);
            font-size: 0.95rem;
        }

        .feed-user {
            color: var(--highlight);
        }

        .feed-action {
            color: var(--text-dim);
        }

        .feed-time {
            color: #666;
            font-size: 0.85rem;
        }

        /* Messages Container */
        .main-content {
            grid-row: 2;
            background: var(--panel-bg);
            display: flex;
            flex-direction: column;
            overflow: hidden;
            min-height: 0;
        }

        .messages-container {
            flex: 1;
            overflow-y: auto;
            padding: 16px;
            display: flex;
            flex-direction: column;
            gap: 12px;
            min-height: 0;
            position: relative;
            background-size: cover;
            background-position: center;
            background-attachment: fixed;
            background-repeat: no-repeat;
            image-rendering: -webkit-optimize-contrast;
            image-rendering: crisp-edges;
        }

        .messages-container::-webkit-scrollbar {
            width: 8px;
        }

        .messages-container::-webkit-scrollbar-track {
            background: var(--dark-bg);
        }

        .messages-container::-webkit-scrollbar-thumb {
            background: var(--border-color);
        }

        .message {
            display: flex;
            gap: 10px;
            animation: glitchIn 0.3s ease-out;
        }

        @keyframes glitchIn {
            0% { opacity: 0; transform: translateX(-10px); }
            50% { opacity: 1; transform: translateX(3px); }
            100% { transform: translateX(0); }
        }

        .message.own {
            flex-direction: row-reverse;
        }

        .avatar {
            width: 40px;
            height: 40px;
            border: 1px solid var(--border-color);
            border-radius: 4px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 24px;
            flex-shrink: 0;
            background: var(--dark-bg);
        }

        .message-bubble {
            max-width: 70%;
            background: rgba(var(--msg-color), var(--msg-opacity));
            border: 1px solid var(--border-color);
            border-radius: 4px;
            padding: 10px 14px;
            color: var(--accent);
        }

        .message.own .message-bubble {
            background: rgba(var(--msg-own-color), var(--msg-opacity));
            color: var(--accent-light);
        }

        .message-header {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 4px;
        }

        .message-username {
            color: var(--accent-light);
            font-size: 1rem;
        }

        .message.own .message-username {
            color: var(--highlight);
        }

        .message-time {
            font-size: 0.85rem;
            color: #555;
        }

        .message-content {
            font-size: 1.1rem;
            line-height: 1.4;
            word-wrap: break-word;
        }

        /* Chat Tags */
        .chat-tag {
            display: inline-block;
            background: linear-gradient(135deg, rgba(124, 152, 133, 0.2) 0%, rgba(124, 152, 133, 0.1) 100%);
            color: var(--accent-light);
            padding: 1px 6px;
            border-radius: 4px;
            font-size: 0.95em;
            cursor: pointer;
            transition: all 0.2s;
            border: 1px solid rgba(124, 152, 133, 0.3);
        }

        .chat-tag:hover {
            background: linear-gradient(135deg, rgba(124, 152, 133, 0.35) 0%, rgba(124, 152, 133, 0.2) 100%);
            transform: translateY(-1px);
        }

        .chat-mention {
            display: inline-block;
            background: linear-gradient(135deg, rgba(255, 0, 255, 0.2) 0%, rgba(255, 0, 255, 0.1) 100%);
            color: #ff88ff;
            padding: 1px 6px;
            border-radius: 4px;
            font-size: 0.95em;
            cursor: pointer;
            transition: all 0.2s;
            border: 1px solid rgba(255, 0, 255, 0.3);
        }

        .chat-mention:hover {
            background: linear-gradient(135deg, rgba(255, 0, 255, 0.35) 0%, rgba(255, 0, 255, 0.2) 100%);
            transform: translateY(-1px);
        }

        .tag-hint {
            position: absolute;
            bottom: 100%;
            left: 0;
            right: 0;
            background: var(--panel-bg);
            border: 1px solid var(--border-color);
            border-bottom: none;
            border-radius: 6px 6px 0 0;
            padding: 8px 12px;
            font-size: 0.85rem;
            color: var(--text-dim);
            display: none;
            z-index: 10;
        }

        .tag-hint.visible {
            display: block;
        }

        .tag-hint-item {
            display: inline-block;
            background: rgba(124, 152, 133, 0.15);
            padding: 2px 8px;
            margin: 2px 4px 2px 0;
            border-radius: 4px;
            cursor: pointer;
            transition: background 0.2s;
        }

        .tag-hint-item:hover {
            background: rgba(124, 152, 133, 0.3);
        }

        .input-area {
            position: relative;
        }

        .message-image, .message-drawing {
            max-width: 100%;
            margin-top: 8px;
            cursor: pointer;
            border: 1px solid var(--border-color);
        }

        /* Doodle Vote */
        .doodle-wrapper {
            position: relative;
            display: inline-block;
        }

        .doodle-vote-btn {
            position: absolute;
            bottom: 8px;
            right: 8px;
            background: rgba(0,0,0,0.7);
            border: 1px solid var(--border-color);
            color: var(--text-dim);
            padding: 4px 10px;
            font-family: inherit;
            font-size: 0.9rem;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 4px;
            transition: all 0.2s;
        }

        .doodle-vote-btn:hover {
            background: rgba(0,0,0,0.9);
            border-color: var(--highlight);
            color: var(--highlight);
        }

        .doodle-vote-btn.voted {
            color: var(--highlight);
            border-color: var(--highlight);
        }

        /* Vote controls (up/down) */
        .vote-controls {
            display: inline-flex;
            align-items: center;
            gap: 2px;
            background: rgba(0,0,0,0.3);
            border-radius: 12px;
            padding: 2px 4px;
        }

        .vote-btn {
            background: transparent;
            border: none;
            color: var(--text-dim);
            padding: 2px 6px;
            font-size: 0.85rem;
            cursor: pointer;
            transition: all 0.15s;
            border-radius: 8px;
        }

        .vote-btn:hover {
            background: rgba(255,255,255,0.1);
        }

        .vote-btn.upvote:hover, .vote-btn.upvote.active {
            color: #00ff41;
        }

        .vote-btn.downvote:hover, .vote-btn.downvote.active {
            color: #ff4444;
        }

        .vote-btn.disabled {
            opacity: 0.3;
            cursor: not-allowed;
        }

        .vote-score {
            font-size: 0.8rem;
            min-width: 20px;
            text-align: center;
            font-weight: bold;
        }

        .vote-score.positive { color: #00ff41; }
        .vote-score.negative { color: #ff4444; }
        .vote-score.neutral { color: var(--text-dim); }

        .message-footer {
            margin-top: 6px;
            padding-top: 4px;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .msg-tts-btn {
            background: transparent;
            border: none;
            color: var(--text-dim);
            cursor: pointer;
            padding: 2px 6px;
            font-size: 0.9rem;
            opacity: 0.7;
            transition: all 0.2s;
        }

        .msg-tts-btn:hover {
            opacity: 1;
            color: var(--accent-light);
        }

        .msg-tts-btn.speaking {
            opacity: 1;
            color: var(--accent-light);
            animation: pulse-speak 1s ease-in-out infinite;
        }

        .msg-delete-btn {
            background: transparent;
            border: none;
            color: var(--text-dim);
            cursor: pointer;
            padding: 2px 6px;
            font-size: 0.9rem;
            opacity: 0.7;
            margin-left: auto;
            transition: all 0.2s;
        }

        .msg-delete-btn:hover {
            opacity: 1;
            color: #ff6666;
            background: rgba(255, 100, 100, 0.1);
            border-radius: 4px;
        }

        .message-header {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        /* Doodle Leaderboard */
        .doodles-container {
            flex: 1;
            overflow-y: auto;
            padding: 16px;
            display: none;
            flex-direction: column;
            gap: 16px;
            min-height: 0;
        }

        .doodles-container.active {
            display: flex;
        }

        .leaderboard-header {
            text-align: center;
            padding: 16px;
            color: var(--accent);
            font-size: 1.1rem;
            border-bottom: 1px solid var(--border-color);
        }

        .doodle-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
            gap: 16px;
        }

        .doodle-card {
            background: var(--panel-bg);
            border: 1px solid var(--border-color);
            overflow: hidden;
            border-radius: 8px;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .doodle-card:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 20px rgba(0,0,0,0.3);
        }

        .doodle-card.top-3 {
            border-color: var(--highlight);
        }

        .doodle-rank {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 8px 12px;
            background: var(--dark-bg);
        }

        .rank-badge {
            width: 28px;
            height: 28px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            font-size: 0.9rem;
            background: var(--border-color);
            color: var(--text-dim);
        }

        .rank-badge.gold {
            background: linear-gradient(135deg, #ffd700, #ffaa00);
            color: #000;
        }
        .rank-badge.silver {
            background: linear-gradient(135deg, #e0e0e0, #a0a0a0);
            color: #000;
        }
        .rank-badge.bronze {
            background: linear-gradient(135deg, #cd7f32, #8b4513);
            color: #fff;
        }

        .doodle-artist {
            flex: 1;
            color: var(--accent-light);
            font-size: 0.9rem;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .doodle-votes {
            color: var(--highlight);
            font-size: 1rem;
            font-weight: bold;
        }

        .doodle-thumbnail {
            position: relative;
            background: #111;
            aspect-ratio: 4/3;
            overflow: hidden;
        }

        .doodle-card img {
            width: 100%;
            height: 100%;
            object-fit: contain;
            display: block;
            cursor: pointer;
            transition: transform 0.2s;
        }

        .doodle-card:hover img {
            transform: scale(1.05);
        }

        .doodle-card-actions {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px 12px;
            border-top: 1px solid var(--border-color);
            background: var(--dark-bg);
        }

        .doodle-time {
            color: var(--text-dim);
            font-size: 0.75rem;
        }

        .empty-doodles {
            text-align: center;
            padding: 60px 20px;
            color: var(--text-dim);
        }

        .doodle-comments {
            max-height: 200px;
            overflow-y: auto;
            padding: 8px 12px;
            border-top: 1px solid var(--border-color);
        }

        .doodle-card .comment-input-row {
            padding: 8px 12px;
            border-top: 1px solid var(--border-color);
        }

        .doodle-card .reply-indicator {
            padding: 4px 12px;
            border-top: 1px solid var(--border-color);
        }

        /* Manifesto Section */
        .manifesto-container {
            flex: 1;
            overflow-y: auto;
            padding: 16px;
            display: none;
            flex-direction: column;
            gap: 16px;
            min-height: 0;
        }

        .manifesto-container.active {
            display: flex;
        }

        /* Collaborative Canvas */
        .collab-container {
            flex: 1;
            overflow-y: auto;
            padding: 16px;
            display: none;
            flex-direction: column;
            gap: 16px;
            min-height: 0;
            align-items: center;
        }

        .collab-container.active {
            display: flex;
        }

        .collab-header {
            text-align: center;
            padding: 10px 20px;
        }

        .collab-header h2 {
            color: var(--accent);
            font-size: 1.3rem;
            margin-bottom: 4px;
        }

        .collab-subtitle {
            color: var(--text-dim);
            font-size: 0.85rem;
            margin-bottom: 8px;
        }

        .collab-users {
            display: flex;
            justify-content: center;
            gap: 8px;
        }

        .collab-user-count,
        .collab-zoom-level {
            background: rgba(0,255,65,0.1);
            border: 1px solid var(--accent);
            padding: 4px 12px;
            border-radius: 20px;
            font-size: 0.8rem;
            color: var(--accent);
        }

        .collab-canvas-wrapper {
            position: relative;
            border: 2px solid var(--accent);
            box-shadow: 0 0 20px rgba(0,255,65,0.2);
            background: #0a0a0a;
            width: 100%;
            max-width: 900px;
            height: 500px;
            overflow: auto;
        }

        #collabCanvas {
            display: block;
            cursor: crosshair;
            transform-origin: 0 0;
            transition: transform 0.1s ease-out;
            touch-action: none;
        }

        .collab-zoom-controls {
            display: flex;
            gap: 4px;
        }

        .collab-zoom-btn {
            padding: 6px 12px;
            font-size: 0.9rem;
            min-width: 36px;
        }

        .collab-cursors {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            pointer-events: none;
            overflow: hidden;
        }

        .collab-cursor {
            position: absolute;
            pointer-events: none;
            transition: left 0.05s linear, top 0.05s linear;
            z-index: 10;
        }

        .collab-cursor-dot {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            border: 2px solid #fff;
            box-shadow: 0 0 8px currentColor;
        }

        .collab-cursor-name {
            position: absolute;
            top: 14px;
            left: 8px;
            font-size: 0.65rem;
            background: rgba(0,0,0,0.8);
            padding: 2px 6px;
            border-radius: 4px;
            white-space: nowrap;
            color: #fff;
        }

        .collab-controls {
            display: flex;
            flex-wrap: wrap;
            gap: 16px;
            align-items: center;
            justify-content: center;
            padding: 10px;
        }

        .collab-colors {
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
            justify-content: center;
        }

        .collab-color-btn {
            width: 32px;
            height: 32px;
            border-radius: 50%;
            border: 2px solid transparent;
            cursor: pointer;
            transition: all 0.2s;
        }

        .collab-color-btn:hover {
            transform: scale(1.1);
        }

        .collab-color-btn.active {
            border-color: #fff;
            box-shadow: 0 0 10px currentColor;
        }

        .collab-eraser-btn {
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1rem;
        }

        .collab-eraser-btn.active {
            box-shadow: 0 0 10px #666;
        }

        .collab-clear-btn {
            font-size: 0.8rem;
            padding: 8px 16px;
        }

        .collab-snapshot-btn {
            font-size: 0.8rem;
            padding: 8px 16px;
            background: linear-gradient(135deg, var(--accent), var(--highlight));
            border-color: var(--accent);
        }

        .collab-snapshot-btn:hover {
            box-shadow: 0 0 15px var(--accent);
        }

        @media (max-width: 768px) {
            .collab-canvas-wrapper {
                width: 100%;
            }
            #collabCanvas {
                width: 100%;
                height: auto;
            }
        }

        .manifesto-header {
            text-align: center;
            padding: 20px;
            border-bottom: 1px solid var(--border-color);
        }

        .manifesto-header h2 {
            color: var(--highlight);
            font-size: 1.4rem;
            margin-bottom: 8px;
        }

        .manifesto-subtitle {
            color: var(--text-dim);
            font-size: 0.95rem;
            margin-bottom: 16px;
        }

        .manifesto-list {
            display: flex;
            flex-direction: column;
            gap: 16px;
        }

        .manifesto-card {
            background: linear-gradient(135deg, rgba(201,168,124,0.1), rgba(124,152,133,0.05));
            border: 1px solid var(--border-color);
            border-left: 3px solid var(--highlight);
            padding: 16px;
            transition: all 0.2s;
        }

        .manifesto-card:hover {
            border-color: var(--highlight);
            box-shadow: 0 4px 20px rgba(201,168,124,0.1);
        }

        .manifesto-card-header {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 12px;
        }

        .manifesto-avatar {
            width: 32px;
            height: 32px;
            border-radius: 50%;
            background: var(--dark-bg);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 18px;
            border: 1px solid var(--border-color);
        }

        .manifesto-author {
            color: var(--accent-light);
            font-size: 1rem;
        }

        .manifesto-time {
            margin-left: auto;
            color: var(--text-dim);
            font-size: 0.85rem;
        }

        .manifesto-title {
            color: var(--highlight);
            font-size: 1.2rem;
            margin-bottom: 10px;
            font-weight: normal;
        }

        .manifesto-text {
            color: var(--accent-light);
            font-size: 1rem;
            line-height: 1.6;
            white-space: pre-wrap;
        }

        .manifesto-actions {
            display: flex;
            gap: 12px;
            margin-top: 12px;
            padding-top: 12px;
            border-top: 1px solid var(--border-color);
        }

        .manifesto-vote-btn {
            background: transparent;
            border: 1px solid var(--border-color);
            color: var(--accent);
            padding: 6px 12px;
            cursor: pointer;
            font-family: inherit;
            font-size: 0.9rem;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .manifesto-vote-btn:hover {
            border-color: var(--highlight);
            color: var(--highlight);
        }

        .manifesto-vote-btn.voted {
            background: var(--highlight);
            border-color: var(--highlight);
            color: var(--dark-bg);
        }

        .manifesto-modal {
            max-width: 600px;
        }

        /* Transparency Slider Bar */
        .transparency-bar {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 6px 16px;
            background: var(--dark-bg);
            border-top: 1px solid var(--border-color);
            font-size: 0.8rem;
            color: var(--text-dim);
        }

        .transparency-bar label {
            white-space: nowrap;
        }

        .transparency-bar input[type="range"] {
            flex: 1;
            max-width: 120px;
            height: 4px;
            -webkit-appearance: none;
            background: var(--border-color);
            border-radius: 2px;
            cursor: pointer;
        }

        .transparency-bar input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 14px;
            height: 14px;
            background: var(--accent);
            border-radius: 50%;
            cursor: pointer;
        }

        .transparency-bar #opacityValue {
            min-width: 35px;
            text-align: right;
            color: var(--accent);
        }

        /* Input Area - now at top of chat */
        .input-area {
            background: var(--dark-bg);
            padding: 12px 16px;
            flex-shrink: 0;
            position: relative;
            z-index: 5;
            border-bottom: 1px solid var(--border-color);
        }

        .input-row {
            display: flex;
            gap: 8px;
            align-items: flex-end;
            max-width: 800px;
            margin: 0 auto;
        }

        .input-actions {
            display: flex;
            gap: 4px;
        }

        .action-btn {
            width: 40px;
            height: 40px;
            border: 1px solid var(--border-color);
            background: transparent;
            color: var(--accent);
            font-size: 18px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .action-btn:hover {
            background: var(--accent-dim);
            color: white;
        }

        .message-input {
            flex: 1;
            background: var(--panel-bg);
            border: 1px solid var(--border-color);
            padding: 10px 16px;
            color: var(--accent-light);
            font-family: inherit;
            font-size: 1.1rem;
            resize: none;
            max-height: 100px;
        }

        .message-input:focus {
            outline: none;
            border-color: var(--accent-dim);
        }

        .message-input::placeholder {
            color: var(--text-dim);
        }

        .send-btn {
            width: 60px;
            height: 40px;
            border: 1px solid var(--border-color);
            background: var(--accent-dim);
            color: white;
            font-family: inherit;
            font-size: 1rem;
            cursor: pointer;
            transition: all 0.2s;
        }

        .send-btn:hover {
            background: var(--accent);
        }

        /* Modals */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.9);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 1000;
        }

        .modal-overlay.active {
            display: flex;
        }

        .modal {
            background: var(--panel-bg);
            border: 1px solid var(--border-color);
            padding: 24px;
            width: 90%;
            max-width: 400px;
            max-height: 85vh;
            overflow-y: auto;
            color: var(--accent);
        }

        .modal h2 {
            margin-bottom: 16px;
            display: flex;
            align-items: center;
            gap: 10px;
            color: var(--accent-light);
            font-size: 1.5rem;
        }

        .modal-close {
            margin-left: auto;
            background: none;
            border: none;
            color: var(--text-dim);
            font-size: 24px;
            cursor: pointer;
        }

        /* Settings Tabs */
        .settings-tabs {
            display: flex;
            gap: 0;
            margin-bottom: 20px;
            border-bottom: 1px solid var(--border-color);
        }

        .settings-tab {
            padding: 10px 20px;
            background: transparent;
            border: none;
            border-bottom: 2px solid transparent;
            color: var(--text-dim);
            font-family: inherit;
            font-size: 1.1rem;
            cursor: pointer;
            transition: all 0.2s;
        }

        .settings-tab:hover {
            color: var(--accent);
        }

        .settings-tab.active {
            color: var(--accent-light);
            border-bottom-color: var(--accent);
        }

        .settings-panel {
            display: none;
        }

        .settings-panel.active {
            display: block;
        }

        /* Sound Library */
        .sound-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 10px;
            margin-bottom: 16px;
        }

        .sound-option {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 10px 12px;
            background: var(--dark-bg);
            border: 2px solid var(--border-color);
            cursor: pointer;
            transition: all 0.2s;
        }

        .sound-option:hover {
            border-color: var(--accent-dim);
        }

        .sound-option.selected {
            border-color: var(--accent);
            background: rgba(124, 152, 133, 0.1);
        }

        .sound-option .sound-icon {
            font-size: 1.5rem;
        }

        .sound-option .sound-name {
            font-size: 1rem;
            color: var(--accent-light);
        }

        .sound-preview-btn {
            margin-left: auto;
            background: var(--border-color);
            border: none;
            color: var(--accent);
            padding: 4px 8px;
            font-family: inherit;
            font-size: 0.9rem;
            cursor: pointer;
        }

        .sound-preview-btn:hover {
            background: var(--accent-dim);
        }

        .volume-control {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-top: 16px;
            padding-top: 16px;
            border-top: 1px solid var(--border-color);
        }

        .volume-control label {
            color: var(--text-dim);
        }

        .volume-control input[type="range"] {
            flex: 1;
        }

        /* Message Color Picker */
        .color-picker-grid {
            display: grid;
            grid-template-columns: repeat(5, 1fr);
            gap: 8px;
            margin-bottom: 16px;
        }

        .msg-color-option {
            aspect-ratio: 1;
            border: 2px solid var(--border-color);
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.2s;
            min-height: 36px;
        }

        .msg-color-option:hover {
            border-color: var(--accent);
            transform: scale(1.05);
        }

        .msg-color-option.selected {
            border-color: var(--accent-light);
            box-shadow: 0 0 8px var(--accent);
        }

        .theme-slider-row {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 16px;
        }

        .theme-slider-row label {
            min-width: 80px;
            color: var(--text-dim);
        }

        .theme-slider-row input[type="range"] {
            flex: 1;
        }

        .theme-slider-row span {
            min-width: 40px;
            text-align: right;
            color: var(--accent);
        }

        /* Avatar Picker */
        .avatar-grid {
            display: grid;
            grid-template-columns: repeat(6, 1fr);
            gap: 8px;
            margin-bottom: 16px;
        }

        .avatar-option {
            aspect-ratio: 1;
            border: 2px solid #333;
            background: var(--dark-bg);
            font-size: 28px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s;
        }

        .avatar-option:hover {
            border-color: var(--accent-dim);
        }

        .avatar-option.selected {
            border-color: var(--accent);
        }

        .form-group {
            margin-bottom: 16px;
        }

        .form-group label {
            display: block;
            margin-bottom: 6px;
            font-size: 1rem;
            color: var(--highlight);
        }

        .form-group input {
            width: 100%;
            padding: 10px;
            background: var(--dark-bg);
            border: 1px solid var(--border-color);
            color: var(--accent-light);
            font-family: inherit;
            font-size: 1.1rem;
        }

        .form-group input:focus {
            outline: none;
            border-color: var(--accent-dim);
        }

        .color-options {
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
        }

        .color-option {
            width: 32px;
            height: 32px;
            border: 2px solid transparent;
            cursor: pointer;
        }

        .color-option:hover {
            transform: scale(1.1);
        }

        .color-option.selected {
            border-color: white;
        }

        .modal-btn {
            width: 100%;
            padding: 12px;
            background: var(--accent-dim);
            border: 1px solid var(--border-color);
            color: white;
            font-family: inherit;
            font-size: 1.1rem;
            cursor: pointer;
            margin-top: 16px;
            transition: all 0.2s;
        }

        .modal-btn:hover {
            background: var(--accent);
        }

        /* File Upload */
        .file-upload-row {
            display: flex;
            gap: 8px;
        }

        .file-upload-btn {
            flex: 1;
            padding: 10px;
            background: var(--dark-bg);
            border: 1px dashed var(--border-color);
            color: var(--text-dim);
            font-family: inherit;
            font-size: 0.9rem;
            cursor: pointer;
            transition: all 0.2s;
        }

        .file-upload-btn:hover {
            border-color: var(--accent);
            color: var(--accent);
        }

        .file-clear-btn {
            padding: 10px 15px;
            background: #3a2020;
            border: 1px solid #5a3030;
            color: #ff6666;
            font-family: inherit;
            font-size: 0.9rem;
            cursor: pointer;
            transition: all 0.2s;
        }

        .file-clear-btn:hover {
            background: #4a2525;
        }

        .upload-preview {
            margin-top: 10px;
            border: 1px solid var(--border-color);
            padding: 8px;
            background: var(--dark-bg);
        }

        .upload-preview img {
            max-width: 100%;
            max-height: 150px;
            display: block;
            margin: 0 auto;
        }

        /* Global Backgrounds */
        .global-bg-section {
            margin-top: 8px;
        }

        .global-bg-label {
            font-size: 0.85rem;
            color: var(--text-dim);
            margin-bottom: 8px;
        }

        .global-bg-grid {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 8px;
            max-height: 150px;
            overflow-y: auto;
        }

        .global-bg-item {
            aspect-ratio: 16/9;
            border: 2px solid var(--border-color);
            border-radius: 4px;
            overflow: hidden;
            cursor: pointer;
            transition: all 0.2s;
        }

        .global-bg-item:hover {
            border-color: var(--accent);
            transform: scale(1.05);
        }

        .global-bg-item.selected {
            border-color: var(--highlight);
        }

        .global-bg-item img {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        .global-bg-upload {
            display: flex;
            align-items: center;
            justify-content: center;
            background: var(--dark-bg);
            color: var(--text-dim);
            font-size: 1.5rem;
        }

        .global-bg-upload:hover {
            color: var(--accent);
        }

        /* Drawing Canvas */
        .drawing-modal .modal {
            max-width: 500px;
        }

        .canvas-container {
            background: #111;
            border: 1px solid var(--border-color);
            margin-bottom: 16px;
        }

        #drawingCanvas {
            display: block;
            width: 100%;
            cursor: crosshair;
            touch-action: none;
        }

        .canvas-tools {
            display: flex;
            gap: 8px;
            margin-bottom: 12px;
            flex-wrap: wrap;
        }

        .tool-btn {
            padding: 8px 12px;
            background: transparent;
            border: 1px solid var(--border-color);
            color: var(--accent);
            cursor: pointer;
            font-family: inherit;
        }

        .tool-btn:hover, .tool-btn.active {
            background: var(--accent-dim);
            color: white;
        }

        .tool-btn:disabled {
            opacity: 0.4;
            cursor: not-allowed;
        }

        .tool-btn:disabled:hover {
            background: transparent;
            color: var(--accent);
        }

        .canvas-actions {
            display: flex;
            gap: 6px;
            margin-left: auto;
        }

        .brush-colors {
            display: flex;
            gap: 6px;
        }

        .brush-color {
            width: 28px;
            height: 28px;
            border: 2px solid #333;
            cursor: pointer;
        }

        .brush-color.selected {
            border-color: white;
        }

        /* Image preview */
        .image-preview {
            margin-bottom: 8px;
            position: relative;
            display: none;
        }

        .image-preview img {
            max-width: 200px;
            max-height: 150px;
            border: 1px solid var(--border-color);
        }

        .image-preview .remove-btn {
            position: absolute;
            top: -8px;
            right: -8px;
            width: 24px;
            height: 24px;
            background: #ff4444;
            border: none;
            color: white;
            cursor: pointer;
            font-size: 16px;
        }

        .empty-state {
            text-align: center;
            padding: 40px;
            color: var(--text-dim);
        }

        .empty-state .icon {
            font-size: 48px;
            margin-bottom: 16px;
        }

        /* Infinite scroll loading indicator */
        .loading-indicator {
            text-align: center;
            padding: 16px;
            color: var(--accent);
            font-size: 0.85rem;
            animation: pulse 1.5s ease-in-out infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 0.5; }
            50% { opacity: 1; }
        }

        /* System Toast Notifications */
        .toast-container {
            position: fixed;
            top: 20px;
            right: 20px;
            z-index: 10000;
            display: flex;
            flex-direction: column;
            gap: 10px;
            pointer-events: none;
        }

        .system-toast {
            background: var(--panel-bg, #1a1a2e);
            border: 1px solid var(--border-color, #333);
            border-left: 4px solid var(--accent, #00ff41);
            padding: 12px 16px;
            border-radius: 4px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4);
            max-width: 320px;
            font-size: 0.85rem;
            color: var(--text-light, #e0e0e0);
            pointer-events: auto;
            animation: slideIn 0.3s ease-out;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .system-toast.success { border-left-color: #00ff41; }
        .system-toast.error { border-left-color: #ff4444; }
        .system-toast.warning { border-left-color: #ffaa00; }
        .system-toast.info { border-left-color: #00aaff; }

        .system-toast .toast-icon {
            font-size: 1.2rem;
            flex-shrink: 0;
        }

        .system-toast .toast-message {
            flex: 1;
        }

        .system-toast .toast-close {
            background: none;
            border: none;
            color: var(--text-dim, #888);
            cursor: pointer;
            padding: 0;
            font-size: 1rem;
            line-height: 1;
            opacity: 0.7;
        }

        .system-toast .toast-close:hover {
            opacity: 1;
        }

        .system-toast.fade-out {
            animation: slideOut 0.3s ease-in forwards;
        }

        @keyframes slideIn {
            from { transform: translateX(100%); opacity: 0; }
            to { transform: translateX(0); opacity: 1; }
        }

        @keyframes slideOut {
            from { transform: translateX(0); opacity: 1; }
            to { transform: translateX(100%); opacity: 0; }
        }

        @media (max-width: 600px) {
            .toast-container {
                top: auto;
                bottom: 80px;
                right: 10px;
                left: 10px;
            }
            .system-toast {
                max-width: none;
            }
        }

        #imageInput {
            display: none;
        }

        /* Mobile toggle buttons */
        .mobile-toggle {
            display: none;
        }

        /* Hamburger menu button */
        .hamburger-btn {
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            width: 40px;
            height: 40px;
            background: var(--dark-bg);
            border: 1px solid var(--border-color);
            border-radius: 6px;
            cursor: pointer;
            padding: 8px;
            gap: 4px;
            transition: all 0.2s;
        }

        .hamburger-btn:hover {
            background: var(--border-color);
        }

        .hamburger-btn span {
            display: block;
            width: 20px;
            height: 2px;
            background: var(--accent);
            border-radius: 1px;
            transition: all 0.3s;
        }

        .hamburger-btn.active span:nth-child(1) {
            transform: rotate(45deg) translate(4px, 4px);
        }

        .hamburger-btn.active span:nth-child(2) {
            opacity: 0;
        }

        .hamburger-btn.active span:nth-child(3) {
            transform: rotate(-45deg) translate(4px, -4px);
        }

        @media (max-width: 768px) {
            .mobile-toggle {
                display: inline-block;
            }

            .hamburger-btn {
                display: flex;
            }

            .desktop-only {
                display: none !important;
            }
        }

        /* Desktop-only buttons hidden on mobile */
        .desktop-only {
            display: inline-flex;
        }

        /* Mobile dropdown menu */
        .mobile-menu {
            display: none;
            position: absolute;
            top: 100%;
            right: 0;
            background: var(--panel-bg);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5);
            min-width: 180px;
            z-index: 200;
            overflow: hidden;
        }

        .mobile-menu.active {
            display: block;
        }

        .mobile-menu-item {
            display: flex;
            align-items: center;
            gap: 10px;
            width: 100%;
            padding: 14px 16px;
            background: transparent;
            border: none;
            border-bottom: 1px solid var(--border-color);
            color: var(--text-main);
            font-family: inherit;
            font-size: 0.95rem;
            text-align: left;
            cursor: pointer;
            transition: background 0.2s, color 0.2s;
        }

        .mobile-menu-item:last-child {
            border-bottom: none;
        }

        .mobile-menu-item:hover {
            background: var(--dark-bg);
            color: var(--accent);
        }

        .mobile-menu-item:active {
            background: var(--border-color);
        }

        .mobile-menu-item .menu-icon {
            display: inline-block;
            width: 24px;
            text-align: center;
        }

        /* Tabs */
        .view-tabs {
            display: flex;
            background: var(--dark-bg);
            border-bottom: 1px solid var(--border-color);
            flex-shrink: 0;
        }

        .view-tab {
            flex: 1;
            padding: 10px;
            background: transparent;
            border: none;
            border-bottom: 2px solid transparent;
            color: var(--text-dim);
            font-family: inherit;
            font-size: 1rem;
            cursor: pointer;
            transition: all 0.2s;
        }

        .view-tab:hover {
            color: var(--accent);
        }

        .view-tab.active {
            color: var(--accent-light);
            border-bottom-color: var(--accent);
        }

        /* Posts Container */
        .posts-container {
            flex: 1;
            overflow-y: auto;
            padding: 16px;
            display: none;
            flex-direction: column;
            gap: 16px;
            min-height: 0;
        }

        .messages-container.hidden {
            display: none;
        }

        /* Post Card */
        .post-card {
            background: rgba(255, 255, 255, 0.03);
            border: 1px solid var(--border-color);
            overflow: hidden;
            flex-shrink: 0;
        }

        .post-header {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 12px;
            border-bottom: 1px solid var(--border-color);
        }

        .post-avatar {
            width: 36px;
            height: 36px;
            border-radius: 50%;
            background: var(--dark-bg);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 20px;
            border: 1px solid var(--border-color);
        }

        .post-username {
            color: var(--accent-light);
            font-size: 1.1rem;
        }

        .post-time {
            color: var(--text-dim);
            font-size: 0.9rem;
            flex: 1;
        }

        .post-delete-btn {
            background: none;
            border: none;
            cursor: pointer;
            font-size: 1.1rem;
            opacity: 0.7;
            transition: all 0.2s;
            padding: 4px 8px;
            border-radius: 4px;
        }

        .post-delete-btn:hover {
            opacity: 1;
            background: rgba(255, 100, 100, 0.15);
        }

        /* Reputation Badges */
        .rep-badge {
            display: inline-flex;
            align-items: center;
            gap: 2px;
            background: linear-gradient(135deg, var(--accent-dim), var(--highlight));
            color: white;
            padding: 2px 6px;
            border-radius: 10px;
            font-size: 0.75rem;
            margin-left: 6px;
            cursor: help;
        }

        .rep-badge.small {
            background: var(--border-color);
            color: var(--text-dim);
        }

        .post-image {
            width: 100%;
            max-height: 400px;
            object-fit: contain;
            background: #000;
            display: block;
        }

        .post-caption {
            padding: 12px;
            font-size: 1.1rem;
            line-height: 1.4;
            border-top: 1px solid var(--border-color);
        }

        /* Post Tags */
        .post-tags {
            display: flex;
            flex-wrap: wrap;
            gap: 6px;
            padding: 8px 12px;
            border-top: 1px solid var(--border-color);
        }

        .tag {
            background: linear-gradient(135deg, rgba(124, 152, 133, 0.2), rgba(169, 196, 176, 0.1));
            border: 1px solid var(--accent-dim);
            border-radius: 4px;
            padding: 3px 8px;
            font-size: 0.85rem;
            color: var(--accent-light);
            cursor: pointer;
            transition: all 0.2s;
        }

        .tag:hover {
            background: var(--accent-dim);
            color: white;
        }

        .tag.nested {
            background: linear-gradient(135deg, rgba(201, 168, 124, 0.2), rgba(201, 168, 124, 0.1));
            border-color: var(--highlight);
            color: var(--highlight);
        }

        .tag.nested:hover {
            background: var(--highlight);
            color: var(--dark-bg);
        }

        .tag-hierarchy {
            font-size: 0.7rem;
            opacity: 0.7;
            margin-right: 2px;
        }

        /* Tag Filter Bar */
        .tag-filter-bar {
            display: none;
            padding: 8px 12px;
            background: var(--dark-bg);
            border-bottom: 1px solid var(--border-color);
            align-items: center;
            gap: 8px;
            flex-shrink: 0;
        }

        .tag-filter-bar.active {
            display: flex;
        }

        /* Ensure posts container takes remaining space */
        .posts-container.active {
            display: flex;
            flex-direction: column;
            flex: 1;
            min-height: 0;
            overflow-y: auto;
        }

        .tag-filter-bar .tag {
            background: var(--accent);
            color: white;
        }

        .clear-filter {
            background: none;
            border: none;
            color: var(--text-dim);
            cursor: pointer;
            font-size: 1.2rem;
            padding: 0 8px;
        }

        .clear-filter:hover {
            color: #ff6666;
        }

        /* Chat Filter Bar */
        .chat-filter-bar {
            display: none;
            padding: 8px 12px;
            background: linear-gradient(135deg, rgba(124, 152, 133, 0.15) 0%, rgba(124, 152, 133, 0.05) 100%);
            border-bottom: 1px solid var(--border-color);
            align-items: center;
            gap: 8px;
            flex-shrink: 0;
        }

        .chat-filter-bar.active {
            display: flex;
        }

        .chat-filter-value {
            display: inline-block;
            background: var(--accent);
            color: var(--dark-bg);
            padding: 2px 10px;
            border-radius: 4px;
            font-weight: bold;
            font-size: 0.9rem;
        }

        .chat-filter-value.mention {
            background: linear-gradient(135deg, #ff00ff 0%, #ff88ff 100%);
        }

        /* Trending Tags */
        .trending-tags {
            padding: 12px;
            border-top: 1px solid var(--border-color);
        }

        .trending-title {
            font-size: 0.8rem;
            color: var(--text-dim);
            margin-bottom: 8px;
            text-transform: uppercase;
            letter-spacing: 0.1em;
        }

        .trending-list {
            display: flex;
            flex-wrap: wrap;
            gap: 6px;
        }

        .trending-tag {
            background: rgba(255,255,255,0.05);
            border: 1px solid var(--border-color);
            border-radius: 12px;
            padding: 4px 10px;
            font-size: 0.8rem;
            color: var(--accent);
            cursor: pointer;
            transition: all 0.2s;
        }

        .trending-tag:hover {
            border-color: var(--accent);
            background: rgba(124, 152, 133, 0.2);
        }

        .trending-tag .count,
        .trending-tag .tag-count {
            color: var(--text-dim);
            font-size: 0.7rem;
            margin-left: 4px;
        }

        .trending-tag.hot {
            background: linear-gradient(135deg, rgba(255,100,100,0.2), rgba(255,150,100,0.1));
            border-color: #ff6666;
            color: #ff9999;
        }

        .trending-tag.warm {
            background: linear-gradient(135deg, rgba(201,168,124,0.2), rgba(201,168,124,0.1));
            border-color: var(--highlight);
            color: var(--highlight);
        }

        .trending-tags-section {
            margin-top: 12px;
            padding-top: 12px;
            border-top: 1px solid var(--border-color);
            flex-shrink: 0;
        }

        .trending-tags-list {
            display: flex;
            flex-direction: column;
            gap: 6px;
            max-height: 30vh;
            overflow-y: auto;
        }

        .trending-tags-list .trending-tag {
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        /* Tag Input */
        .tag-input-container {
            display: flex;
            flex-wrap: wrap;
            gap: 6px;
            padding: 8px;
            background: var(--dark-bg);
            border: 1px solid var(--border-color);
            min-height: 40px;
            align-items: center;
        }

        .tag-input-container .tag {
            display: flex;
            align-items: center;
            gap: 4px;
        }

        .tag-input-container .tag .remove {
            cursor: pointer;
            opacity: 0.7;
        }

        .tag-input-container .tag .remove:hover {
            opacity: 1;
        }

        .tag-input {
            flex: 1;
            min-width: 100px;
            background: transparent;
            border: none;
            color: var(--accent);
            font-family: inherit;
            font-size: 0.9rem;
            outline: none;
            padding: 4px 0;
        }

        .tag-input::placeholder {
            color: var(--text-dim);
        }

        .tag-input:focus {
            box-shadow: none;
        }

        /* Tag input field in message area */
        .message-input[data-tag-mode="true"] {
            border-color: var(--accent);
            box-shadow: 0 0 8px rgba(0, 255, 136, 0.3);
        }

        .post-actions {
            display: flex;
            gap: 16px;
            padding: 10px 12px;
            border-top: 1px solid var(--border-color);
        }

        .post-action-btn {
            background: none;
            border: none;
            color: var(--text-dim);
            font-family: inherit;
            font-size: 1rem;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 6px;
            transition: color 0.2s;
        }

        .post-action-btn:hover {
            color: var(--accent-light);
        }

        .post-action-btn.liked {
            color: #ff4466;
        }

        .post-action-btn.speaking {
            color: var(--accent-light);
            animation: pulse-speak 1s ease-in-out infinite;
        }

        @keyframes pulse-speak {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        /* Emoji Reactions */
        .post-reactions {
            display: flex;
            flex-wrap: wrap;
            gap: 6px;
            padding: 8px 12px;
            border-top: 1px solid var(--border-color);
        }

        .reaction-btn {
            background: rgba(255,255,255,0.05);
            border: 1px solid var(--border-color);
            border-radius: 16px;
            padding: 4px 10px;
            font-size: 0.9rem;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 4px;
            transition: all 0.2s;
        }

        .reaction-btn:hover {
            background: rgba(255,255,255,0.1);
            border-color: var(--accent);
        }

        .reaction-btn.active {
            background: rgba(124, 152, 133, 0.2);
            border-color: var(--accent);
        }

        .reaction-count {
            font-size: 0.8rem;
            color: var(--text-dim);
        }

        .add-reaction-btn {
            background: transparent;
            border: 1px dashed var(--border-color);
            border-radius: 16px;
            padding: 4px 10px;
            font-size: 0.9rem;
            cursor: pointer;
            color: var(--text-dim);
            transition: all 0.2s;
        }

        .add-reaction-btn:hover {
            border-color: var(--accent);
            color: var(--accent);
        }

        .reaction-picker {
            display: none;
            position: absolute;
            bottom: 100%;
            left: 0;
            background: var(--panel-bg);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            padding: 8px;
            gap: 4px;
            flex-wrap: wrap;
            max-width: 200px;
            z-index: 10;
        }

        .reaction-picker.active {
            display: flex;
        }

        .reaction-picker button {
            background: none;
            border: none;
            font-size: 1.2rem;
            cursor: pointer;
            padding: 4px;
            border-radius: 4px;
            transition: background 0.2s;
        }

        .reaction-picker button:hover {
            background: rgba(255,255,255,0.1);
        }

        .post-comments {
            border-top: 1px solid var(--border-color);
            max-height: 200px;
            overflow-y: auto;
        }

        .comment {
            display: flex;
            gap: 8px;
            padding: 8px 12px;
            border-bottom: 1px solid rgba(255,255,255,0.05);
        }

        .comment-avatar {
            font-size: 16px;
        }

        .comment-content {
            flex: 1;
        }

        .comment-username {
            color: var(--accent);
            font-size: 0.95rem;
        }

        .comment-text {
            color: var(--accent-light);
            font-size: 1rem;
        }

        .comment-input-row {
            display: flex;
            gap: 8px;
            padding: 8px 12px;
            border-top: 1px solid var(--border-color);
        }

        .comment-input {
            flex: 1;
            background: var(--dark-bg);
            border: 1px solid var(--border-color);
            padding: 8px 12px;
            color: var(--accent-light);
            font-family: inherit;
            font-size: 1rem;
        }

        .comment-input:focus {
            outline: none;
            border-color: var(--accent-dim);
        }

        .comment-send {
            background: var(--accent-dim);
            border: none;
            color: white;
            padding: 8px 16px;
            font-family: inherit;
            cursor: pointer;
        }

        .comment-send:hover {
            background: var(--accent);
        }

        /* Threaded Comments - natural cascade */
        .comment-replies {
            margin-left: 12px;
            padding-left: 12px;
            border-left: 1px solid var(--border-color);
            margin-top: 4px;
        }

        .comment-thread {
            margin-top: 6px;
        }

        .comment-actions {
            display: flex;
            gap: 12px;
            margin-top: 4px;
        }

        .comment-reply-btn {
            background: none;
            border: none;
            color: var(--text-dim);
            font-family: inherit;
            font-size: 0.8rem;
            cursor: pointer;
            padding: 0;
        }

        .comment-reply-btn:hover {
            color: var(--accent);
        }

        .comment-vote-controls {
            display: inline-flex;
            align-items: center;
            gap: 2px;
            margin-left: 8px;
        }

        .comment-vote-btn {
            background: none;
            border: none;
            color: var(--text-dim);
            font-size: 0.75rem;
            cursor: pointer;
            padding: 0 2px;
            opacity: 0.7;
        }

        .comment-vote-btn:hover { opacity: 1; }
        .comment-vote-btn.upvote:hover, .comment-vote-btn.upvote.active { color: #00ff41; opacity: 1; }
        .comment-vote-btn.downvote:hover, .comment-vote-btn.downvote.active { color: #ff4444; opacity: 1; }
        .comment-vote-btn.disabled { opacity: 0.3; cursor: not-allowed; }

        .comment-vote-score {
            font-size: 0.75rem;
            min-width: 16px;
            text-align: center;
            color: var(--text-dim);
        }
        .comment-vote-score.positive { color: #00ff41; }
        .comment-vote-score.negative { color: #ff4444; }

        .reply-indicator {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 6px 12px;
            background: rgba(124, 152, 133, 0.1);
            border-left: 3px solid var(--accent);
            margin-bottom: 4px;
            font-size: 0.85rem;
        }

        .reply-indicator .cancel-reply {
            background: none;
            border: none;
            color: var(--text-dim);
            cursor: pointer;
            font-size: 1rem;
            padding: 0 4px;
        }

        .reply-indicator .cancel-reply:hover {
            color: #ff6b6b;
        }

        .comment-time {
            color: var(--text-dim);
            font-size: 0.75rem;
            margin-left: 8px;
        }

        /* Create Post Button */
        .create-post-btn {
            position: fixed;
            bottom: 80px;
            right: 20px;
            width: 56px;
            height: 56px;
            border-radius: 50%;
            background: var(--accent-dim);
            border: 2px solid var(--accent);
            color: white;
            font-size: 28px;
            cursor: pointer;
            z-index: 50;
            display: none;
            align-items: center;
            justify-content: center;
            transition: all 0.2s;
        }

        .create-post-btn.visible {
            display: flex;
        }

        .create-post-btn:hover {
            background: var(--accent);
            transform: scale(1.1);
        }

        /* Post Modal */
        .post-modal .modal {
            max-width: 500px;
        }

        .post-preview {
            margin-bottom: 16px;
            border: 1px solid var(--border-color);
            background: #000;
            min-height: 100px;
            display: flex;
            align-items: center;
            justify-content: center;
            color: var(--text-dim);
        }

        .post-preview img {
            max-width: 100%;
            max-height: 300px;
            display: block;
        }

        .post-preview.has-image {
            min-height: auto;
        }

        .or-divider {
            text-align: center;
            margin: 12px 0;
            color: var(--text-dim);
        }

        /* Profile Card */
        .profile-card {
            position: fixed;
            z-index: 10000;
            background: var(--dark-bg);
            border: 1px solid var(--accent);
            border-radius: 8px;
            padding: 16px;
            min-width: 220px;
            max-width: 280px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.5);
            display: none;
            animation: profileCardIn 0.15s ease-out;
        }

        @keyframes profileCardIn {
            from { opacity: 0; transform: translateY(-8px) scale(0.95); }
            to { opacity: 1; transform: translateY(0) scale(1); }
        }

        .profile-card.visible {
            display: block;
        }

        .profile-card-header {
            display: flex;
            align-items: center;
            gap: 12px;
            margin-bottom: 12px;
        }

        .profile-card-avatar {
            width: 48px;
            height: 48px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 28px;
            background: var(--panel-bg);
            border: 2px solid var(--accent);
            overflow: hidden;
        }

        .profile-card-avatar img {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        .profile-card-name {
            font-size: 1.2rem;
            color: var(--accent-light);
            font-weight: bold;
        }

        .profile-card-stats {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 8px;
            margin-bottom: 12px;
            text-align: center;
        }

        .profile-card-stat {
            background: var(--panel-bg);
            padding: 8px 4px;
            border-radius: 4px;
        }

        .profile-card-stat-value {
            font-size: 1.1rem;
            color: var(--highlight);
            font-weight: bold;
        }

        .profile-card-stat-label {
            font-size: 0.7rem;
            color: var(--text-dim);
            text-transform: uppercase;
        }

        .profile-card-loading {
            text-align: center;
            padding: 20px;
            color: var(--text-dim);
        }

        .username-clickable {
            cursor: pointer;
            transition: color 0.15s;
        }

        .username-clickable:hover {
            color: var(--highlight);
            text-decoration: underline;
        }

        /* Lazy loading placeholder */
        .lazy-image {
            background: var(--panel-bg);
            min-height: 100px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .lazy-image.loading::after {
            content: 'â—Œ';
            font-size: 24px;
            color: var(--text-dim);
            animation: lazyPulse 1s infinite;
        }

        @keyframes lazyPulse {
            0%, 100% { opacity: 0.3; }
            50% { opacity: 1; }
        }

        /* Hacker Markup Effects */
        .hacker-shake {
            display: inline-block;
            animation: hackerShake 0.1s infinite;
        }

        @keyframes hackerShake {
            0%, 100% { transform: translate(0, 0); }
            25% { transform: translate(-2px, 1px); }
            50% { transform: translate(2px, -1px); }
            75% { transform: translate(-1px, -2px); }
        }

        .hacker-rainbow {
            display: inline-block;
            background: linear-gradient(90deg, #ff0000, #ff7f00, #ffff00, #00ff00, #0000ff, #4b0082, #9400d3, #ff0000);
            background-size: 400% 100%;
            -webkit-background-clip: text;
            background-clip: text;
            -webkit-text-fill-color: transparent;
            animation: hackerRainbow 2s linear infinite;
        }

        @keyframes hackerRainbow {
            0% { background-position: 0% 50%; }
            100% { background-position: 400% 50%; }
        }

        .hacker-matrix {
            display: inline-block;
            color: #00ff00;
            text-shadow: 0 0 5px #00ff00, 0 0 10px #00ff00;
            animation: hackerMatrix 0.5s steps(3) infinite;
            font-family: 'Courier New', monospace;
        }

        @keyframes hackerMatrix {
            0%, 100% { opacity: 1; filter: brightness(1); }
            33% { opacity: 0.8; filter: brightness(1.2); }
            66% { opacity: 0.9; filter: brightness(0.9); }
        }

        .hacker-matrix::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(transparent 50%, rgba(0, 255, 0, 0.03) 50%);
            background-size: 100% 4px;
            pointer-events: none;
        }

        .hacker-glitch {
            display: inline-block;
            position: relative;
            animation: hackerGlitch 0.3s infinite;
        }

        @keyframes hackerGlitch {
            0%, 100% { transform: translate(0); filter: hue-rotate(0deg); }
            20% { transform: translate(-2px, 2px); filter: hue-rotate(90deg); }
            40% { transform: translate(2px, -2px); filter: hue-rotate(180deg); }
            60% { transform: translate(-1px, -1px); filter: hue-rotate(270deg); }
            80% { transform: translate(1px, 1px); filter: hue-rotate(360deg); }
        }

        .hacker-pulse {
            display: inline-block;
            animation: hackerPulse 1s ease-in-out infinite;
        }

        @keyframes hackerPulse {
            0%, 100% { transform: scale(1); opacity: 1; }
            50% { transform: scale(1.1); opacity: 0.8; }
        }

        .hacker-wave {
            display: inline-block;
        }

        .hacker-wave span {
            display: inline-block;
            animation: hackerWave 1s ease-in-out infinite;
        }

        @keyframes hackerWave {
            0%, 100% { transform: translateY(0); }
            50% { transform: translateY(-5px); }
        }

        .hacker-spoiler {
            display: inline-block;
            background: var(--text-dim);
            color: transparent;
            border-radius: 3px;
            padding: 0 4px;
            cursor: pointer;
            transition: all 0.2s ease;
            user-select: none;
        }

        .hacker-spoiler:hover,
        .hacker-spoiler.revealed {
            background: transparent;
            color: var(--text-color);
        }

        .hacker-spoiler::before {
            content: '[spoiler]';
            color: var(--accent);
            font-size: 0.7em;
            opacity: 0.7;
        }

        .hacker-spoiler:hover::before,
        .hacker-spoiler.revealed::before {
            content: '';
        }

        /* Reboot System Overlay */
        .reboot-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: #000;
            z-index: 99999;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            font-family: 'Courier New', monospace;
            color: #00ff00;
            animation: rebootFlicker 0.1s infinite;
        }

        .reboot-overlay .reboot-text {
            font-size: 2rem;
            text-shadow: 0 0 10px #00ff00, 0 0 20px #00ff00;
            animation: rebootGlitch 0.3s infinite;
        }

        .reboot-overlay .reboot-progress {
            margin-top: 20px;
            font-size: 1rem;
            opacity: 0.8;
        }

        .reboot-overlay .reboot-bar {
            width: 300px;
            height: 4px;
            background: #003300;
            margin-top: 15px;
            border: 1px solid #00ff00;
        }

        .reboot-overlay .reboot-bar-fill {
            height: 100%;
            background: #00ff00;
            box-shadow: 0 0 10px #00ff00;
            transition: width 0.1s linear;
        }

        @keyframes rebootFlicker {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.95; }
        }

        @keyframes rebootGlitch {
            0%, 100% { transform: translate(0); text-shadow: 0 0 10px #00ff00; }
            25% { transform: translate(-2px, 1px); text-shadow: 2px 0 #ff0000, -2px 0 #0000ff; }
            50% { transform: translate(2px, -1px); text-shadow: -2px 0 #ff0000, 2px 0 #0000ff; }
            75% { transform: translate(-1px, -1px); text-shadow: 1px 0 #ff0000, -1px 0 #0000ff; }
        }

        /* === SLOPPYFM WINAMP WIDGET === */
        .sloppyfm-widget {
            position: fixed;
            bottom: 20px;
            right: 20px;
            width: 275px;
            background: linear-gradient(180deg, #3a3a4a 0%, #232328 50%, #1a1a1f 100%);
            border: 2px solid #555;
            border-radius: 4px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.5), inset 0 1px 0 rgba(255,255,255,0.1);
            z-index: 9999;
            font-family: 'Arial', sans-serif;
            user-select: none;
            display: none;
        }
        .sloppyfm-widget.visible { display: block; }
        .sloppyfm-titlebar {
            background: linear-gradient(90deg, #1a3a6e 0%, #0a1a3e 50%, #1a3a6e 100%);
            padding: 3px 6px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            cursor: move;
            border-bottom: 1px solid #000;
        }
        .sloppyfm-title {
            color: #fff;
            font-size: 11px;
            font-weight: bold;
            text-shadow: 1px 1px 0 #000;
            letter-spacing: 1px;
        }
        .sloppyfm-close {
            background: linear-gradient(180deg, #6a6a7a, #3a3a4a);
            border: 1px solid #222;
            color: #fff;
            width: 14px;
            height: 14px;
            font-size: 10px;
            line-height: 12px;
            text-align: center;
            cursor: pointer;
            border-radius: 2px;
        }
        .sloppyfm-close:hover { background: #ff6b6b; }
        .sloppyfm-display {
            background: #000;
            margin: 4px;
            padding: 6px 8px;
            border: 1px inset #333;
            border-radius: 2px;
        }
        .sloppyfm-visualizer {
            height: 20px;
            display: flex;
            align-items: flex-end;
            gap: 2px;
            margin-bottom: 4px;
        }
        .sloppyfm-bar {
            flex: 1;
            background: linear-gradient(180deg, #0f0 0%, #0a0 50%, #060 100%);
            min-height: 2px;
            transition: height 0.1s ease;
        }
        .sloppyfm-bar.mid { background: linear-gradient(180deg, #ff0 0%, #aa0 50%, #660 100%); }
        .sloppyfm-bar.high { background: linear-gradient(180deg, #f00 0%, #a00 50%, #600 100%); }
        .sloppyfm-trackinfo {
            color: #0f0;
            font-size: 10px;
            font-family: 'Courier New', monospace;
            white-space: nowrap;
            overflow: hidden;
        }
        .sloppyfm-trackname {
            animation: sloppyfm-scroll 10s linear infinite;
            display: inline-block;
            padding-left: 100%;
        }
        @keyframes sloppyfm-scroll {
            0% { transform: translateX(0); }
            100% { transform: translateX(-100%); }
        }
        .sloppyfm-time {
            color: #0f0;
            font-size: 16px;
            font-family: 'Courier New', monospace;
            text-align: right;
            margin-top: 2px;
        }
        .sloppyfm-controls {
            display: flex;
            justify-content: center;
            gap: 4px;
            padding: 6px;
            background: linear-gradient(180deg, #2a2a2f, #1a1a1f);
        }
        .sloppyfm-btn {
            background: linear-gradient(180deg, #4a4a5a 0%, #2a2a3a 50%, #1a1a2a 100%);
            border: 1px solid #555;
            border-radius: 2px;
            color: #ccc;
            width: 28px;
            height: 20px;
            font-size: 10px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .sloppyfm-btn:hover { background: linear-gradient(180deg, #5a5a6a 0%, #3a3a4a 50%, #2a2a3a 100%); color: #fff; }
        .sloppyfm-btn:active { transform: scale(0.95); }
        .sloppyfm-btn.playing { color: #0f0; }
        .sloppyfm-volume {
            display: flex;
            align-items: center;
            padding: 0 8px 6px;
            gap: 6px;
        }
        .sloppyfm-volume-label {
            color: #888;
            font-size: 9px;
        }
        .sloppyfm-volume-slider {
            flex: 1;
            height: 6px;
            -webkit-appearance: none;
            background: linear-gradient(180deg, #222, #111);
            border: 1px inset #333;
            border-radius: 2px;
        }
        .sloppyfm-volume-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 10px;
            height: 14px;
            background: linear-gradient(180deg, #6a6a7a, #3a3a4a);
            border: 1px solid #222;
            border-radius: 2px;
            cursor: pointer;
        }
        .sloppyfm-add-track {
            display: flex;
            gap: 4px;
            margin: 4px;
        }
        .sloppyfm-url-input {
            flex: 1;
            background: #0a0a0f;
            border: 1px inset #333;
            color: #0f0;
            padding: 4px 6px;
            font-size: 10px;
            font-family: 'Courier New', monospace;
        }
        .sloppyfm-url-input::placeholder {
            color: #444;
        }
        .sloppyfm-add-btn {
            background: linear-gradient(180deg, #2a4a2a 0%, #1a2a1a 50%, #0a1a0a 100%);
            border: 1px solid #0f0;
            color: #0f0;
            padding: 4px 10px;
            cursor: pointer;
            font-weight: bold;
            font-size: 12px;
        }
        .sloppyfm-add-btn:hover {
            background: linear-gradient(180deg, #3a5a3a 0%, #2a3a2a 50%, #1a2a1a 100%);
        }
        .sloppyfm-playlist {
            max-height: 100px;
            overflow-y: auto;
            background: #0a0a0f;
            margin: 0 4px 4px;
            border: 1px inset #333;
            font-size: 10px;
        }
        .sloppyfm-track {
            padding: 3px 6px;
            color: #0f0;
            cursor: pointer;
            border-bottom: 1px solid #1a1a1f;
            font-family: 'Courier New', monospace;
        }
        .sloppyfm-track:hover { background: #1a2a1a; }
        .sloppyfm-track.active { background: #0a3a0a; color: #0f0; }
        .sloppyfm-genre {
            color: #888;
            font-size: 8px;
            margin-left: 4px;
        }
        .sloppyfm-toggle {
            position: fixed;
            bottom: 20px;
            right: 20px;
            width: 50px;
            height: 50px;
            background: linear-gradient(180deg, #3a3a6a 0%, #1a1a3a 100%);
            border: 2px solid #555;
            border-radius: 50%;
            color: #0f0;
            font-size: 20px;
            cursor: pointer;
            z-index: 9998;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 2px 10px rgba(0,0,0,0.5);
        }
        .sloppyfm-toggle:hover { background: linear-gradient(180deg, #4a4a7a 0%, #2a2a4a 100%); }
        .sloppyfm-toggle.hidden { display: none; }
        @media (max-width: 768px) {
            .sloppyfm-widget { width: 260px; bottom: 70px; right: 10px; }
            .sloppyfm-toggle { bottom: 70px; }
        }

        /* === GHOST RADAR WIDGET === */
        .ghost-radar {
            position: fixed;
            bottom: 20px;
            left: 20px;
            width: 80px;
            height: 80px;
            background: radial-gradient(circle, #0a1a0a 0%, #001100 70%, #000800 100%);
            border: 2px solid #0f0;
            border-radius: 50%;
            box-shadow: 0 0 15px rgba(0,255,0,0.3), inset 0 0 20px rgba(0,255,0,0.1);
            z-index: 9997;
            overflow: hidden;
            cursor: pointer;
        }
        .ghost-radar::before {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 100%;
            height: 2px;
            background: linear-gradient(90deg, transparent, #0f0 50%, transparent);
            transform-origin: left center;
            animation: radarSweep 3s linear infinite;
        }
        @keyframes radarSweep {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        .ghost-radar::after {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 4px;
            height: 4px;
            background: #0f0;
            border-radius: 50%;
            transform: translate(-50%, -50%);
            box-shadow: 0 0 5px #0f0;
        }
        .ghost-radar-rings {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 90%;
            height: 90%;
            border: 1px solid rgba(0,255,0,0.2);
            border-radius: 50%;
        }
        .ghost-radar-rings::before {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 60%;
            height: 60%;
            border: 1px solid rgba(0,255,0,0.15);
            border-radius: 50%;
        }
        .ghost-radar-rings::after {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 30%;
            height: 30%;
            border: 1px solid rgba(0,255,0,0.1);
            border-radius: 50%;
        }
        .ghost-radar-count {
            position: absolute;
            bottom: -22px;
            left: 50%;
            transform: translateX(-50%);
            background: #001a00;
            border: 1px solid #0f0;
            padding: 2px 8px;
            font-size: 10px;
            color: #0f0;
            font-family: 'Courier New', monospace;
            white-space: nowrap;
            border-radius: 3px;
            text-shadow: 0 0 5px #0f0;
        }
        .ghost-radar-blip {
            position: absolute;
            width: 6px;
            height: 6px;
            background: #0f0;
            border-radius: 50%;
            opacity: 0;
            animation: blipFade 3s ease-out infinite;
            box-shadow: 0 0 8px #0f0;
        }
        @keyframes blipFade {
            0% { opacity: 0.8; transform: scale(1); }
            100% { opacity: 0; transform: scale(0.5); }
        }
        .ghost-radar-label {
            position: absolute;
            top: -18px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 8px;
            color: #0f0;
            font-family: 'Courier New', monospace;
            text-transform: uppercase;
            letter-spacing: 1px;
            text-shadow: 0 0 5px #0f0;
        }
        @media (max-width: 768px) {
            .ghost-radar { bottom: 80px; left: 10px; width: 60px; height: 60px; }
            .ghost-radar-count { font-size: 8px; bottom: -18px; }
            .ghost-radar-label { font-size: 6px; top: -14px; }
        }

    </style>
    <!-- EARLY ERROR CATCHER - Runs before everything else to catch all errors -->
    <script>
    (function() {
        var errorBox = null;
        var errorCount = 0;

        function showError(type, msg, extra) {
            errorCount++;
            console.error('[' + type + ']', msg, extra || '');

            if (!errorBox) {
                errorBox = document.createElement('div');
                errorBox.id = 'globalErrorBox';
                errorBox.style.cssText = 'position:fixed;top:0;left:0;right:0;background:#ff0000;color:#fff;padding:15px 40px 15px 15px;font-family:monospace;font-size:13px;z-index:999999;max-height:40vh;overflow:auto;box-shadow:0 4px 20px rgba(0,0,0,0.5);';
                errorBox.innerHTML = '<strong style="font-size:15px;">ERRORS DETECTED</strong><button onclick="this.parentNode.remove()" style="position:absolute;top:10px;right:10px;background:#000;color:#fff;border:none;padding:5px 12px;cursor:pointer;font-size:14px;">X</button><div id="errorList" style="margin-top:10px;"></div>';
                (document.body || document.documentElement).appendChild(errorBox);
            }

            var list = document.getElementById('errorList');
            if (list) {
                var item = document.createElement('div');
                item.style.cssText = 'padding:8px;margin-top:8px;background:rgba(0,0,0,0.3);border-radius:4px;word-break:break-word;';
                item.innerHTML = '<strong>[' + errorCount + '] ' + type + ':</strong> ' + msg + (extra ? '<br><span style="color:#faa;font-size:11px;">' + extra + '</span>' : '');
                list.appendChild(item);
            }
        }

        window.onerror = function(message, source, lineno, colno, error) {
            var extra = 'Line ' + lineno + ', Col ' + colno;
            if (source) extra += ' in ' + source.split('/').pop();
            showError('JS ERROR', message, extra);
            return false;
        };

        window.onunhandledrejection = function(event) {
            var reason = event.reason || 'Unknown';
            var msg = (reason && reason.message) ? reason.message : String(reason);
            var stack = (reason && reason.stack) ? reason.stack.split('\n')[1] || '' : '';
            showError('PROMISE REJECTED', msg, stack.trim());
        };

        window.addEventListener('error', function(e) {
            if (e.target && (e.target.tagName === 'SCRIPT' || e.target.tagName === 'LINK')) {
                showError('LOAD FAILED', (e.target.src || e.target.href || 'unknown resource'));
            }
        }, true);
    })();
    </script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/dompurify/3.0.6/purify.min.js"></script>
</head>
<body>
    <!-- Toast notification container -->
    <div class="toast-container" id="toastContainer"></div>

    <!-- SloppyFM Winamp Widget with YouTube Sync -->
    <button class="sloppyfm-toggle" id="sloppyfmToggle" onclick="toggleSloppyFM()" title="SloppyFM Radio">ðŸŽµ</button>
    <div class="sloppyfm-widget" id="sloppyfmWidget">
        <div class="sloppyfm-titlebar" id="sloppyfmTitlebar">
            <span class="sloppyfm-title">SLOPPYFM v2.0 ðŸ“¡</span>
            <button class="sloppyfm-close" onclick="toggleSloppyFM()">Ã—</button>
        </div>
        <div class="sloppyfm-display">
            <div class="sloppyfm-visualizer" id="sloppyfmVisualizer">
                <div class="sloppyfm-bar"></div><div class="sloppyfm-bar"></div><div class="sloppyfm-bar"></div>
                <div class="sloppyfm-bar"></div><div class="sloppyfm-bar"></div><div class="sloppyfm-bar"></div>
                <div class="sloppyfm-bar"></div><div class="sloppyfm-bar"></div><div class="sloppyfm-bar"></div>
                <div class="sloppyfm-bar"></div><div class="sloppyfm-bar"></div><div class="sloppyfm-bar"></div>
                <div class="sloppyfm-bar"></div><div class="sloppyfm-bar"></div><div class="sloppyfm-bar"></div>
                <div class="sloppyfm-bar"></div>
            </div>
            <div class="sloppyfm-trackinfo">
                <span class="sloppyfm-trackname" id="sloppyfmTrackName">[ SYNCED RADIO ]</span>
            </div>
            <div class="sloppyfm-time" id="sloppyfmTime">00:00</div>
        </div>
        <div class="sloppyfm-controls">
            <button class="sloppyfm-btn" onclick="sloppyfmPrev()" title="Previous">â®</button>
            <button class="sloppyfm-btn" onclick="sloppyfmStop()" title="Stop">â¹</button>
            <button class="sloppyfm-btn" id="sloppyfmPlayBtn" onclick="sloppyfmPlay()" title="Play">â–¶</button>
            <button class="sloppyfm-btn" onclick="sloppyfmNext()" title="Next">â­</button>
            <button class="sloppyfm-btn" onclick="sloppyfmShuffle()" title="Shuffle">ðŸ”€</button>
        </div>
        <div class="sloppyfm-volume">
            <span class="sloppyfm-volume-label">VOL</span>
            <input type="range" class="sloppyfm-volume-slider" id="sloppyfmVolume" min="0" max="100" value="70" onchange="sloppyfmSetVolume(this.value)">
        </div>
        <div class="sloppyfm-add-track">
            <input type="text" class="sloppyfm-url-input" id="sloppyfmUrlInput" placeholder="YouTube URL or ID..." onkeydown="if(event.key==='Enter')sloppyfmAddTrack()">
            <button class="sloppyfm-add-btn" onclick="sloppyfmAddTrack()" title="Add to queue">+</button>
        </div>
        <div class="sloppyfm-playlist" id="sloppyfmPlaylist"></div>
        <!-- Hidden YouTube Player -->
        <div id="sloppyfmYTPlayer" style="position:absolute;width:1px;height:1px;overflow:hidden;opacity:0;pointer-events:none;"></div>
    </div>

    <!-- Ghost Radar Widget -->
    <div class="ghost-radar" id="ghostRadar" onclick="ghostRadarPing()" title="Ghost Radar - Silent Lurkers">
        <span class="ghost-radar-label">GHOSTS</span>
        <div class="ghost-radar-rings"></div>
        <div id="ghostRadarBlips"></div>
        <span class="ghost-radar-count" id="ghostRadarCount">0 lurking</span>
    </div>

    <!-- Profile card popup -->
    <div class="profile-card" id="profileCard">
        <div class="profile-card-loading">Loading...</div>
    </div>

    <div class="app">
        <div class="header">
            <div class="logo">
                <span>ðŸ’¾</span>
                <span>SLOPPYGRAM<span class="logo-blink">_</span></span>
            </div>
            <div class="marquee-container">
                <div class="marquee">
                    â˜… WELCOME TO THE CYBER ZONE â˜… GLOBAL CHAT â˜… EST. 1999 â˜… VISITORS: <span id="visitorCount">???</span> â˜…
                </div>
            </div>
            <div class="header-actions">
                <!-- Desktop-only action buttons (hidden on mobile via CSS) -->
                <button class="cyber-btn desktop-only" onclick="toggleSidebar('left')" title="Show online users">ðŸ‘¥ USERS</button>
                <button class="cyber-btn desktop-only" onclick="toggleSidebar('right')" title="Show activity feed">ðŸ“‹ FEED</button>
                <button class="reboot-btn desktop-only" onclick="window.rebootSystem()" title="Reboot System">âš¡</button>
                <button class="donate-btn desktop-only" onclick="openSupportModal()" title="Support the stream">ðŸ’° DONATE</button>
                <button class="cyber-btn desktop-only" onclick="openShareModal()" title="Share with the world">ðŸ“¡ SHARE</button>
                <button class="cyber-btn desktop-only" onclick="openSettingsModal()" title="Open settings">âš™ï¸ SETTINGS</button>

                <!-- Mobile hamburger menu button (visible only on mobile) -->
                <button class="hamburger-btn" id="hamburgerBtn" onclick="toggleMobileMenu()" aria-label="Toggle mobile menu">
                    <span></span>
                    <span></span>
                    <span></span>
                </button>
            </div>

            <!-- Mobile dropdown menu (toggled by hamburger button) -->
            <div class="mobile-menu" id="mobileMenu">
                <button class="mobile-menu-item" onclick="toggleSidebar('left'); toggleMobileMenu();">
                    <span class="menu-icon">ðŸ‘¥</span> Online Users
                </button>
                <button class="mobile-menu-item" onclick="toggleSidebar('right'); toggleMobileMenu();">
                    <span class="menu-icon">ðŸ“‹</span> Activity Feed
                </button>
                <button class="mobile-menu-item" onclick="openSettingsModal(); toggleMobileMenu();">
                    <span class="menu-icon">âš™ï¸</span> Settings
                </button>
                <button class="mobile-menu-item" onclick="openShareModal(); toggleMobileMenu();">
                    <span class="menu-icon">ðŸ“¡</span> Share
                </button>
                <button class="mobile-menu-item" onclick="openSupportModal(); toggleMobileMenu();">
                    <span class="menu-icon">ðŸ’°</span> Donate
                </button>
                <button class="mobile-menu-item" onclick="window.rebootSystem(); toggleMobileMenu();">
                    <span class="menu-icon">âš¡</span> Reboot System
                </button>
            </div>
        </div>

        <div class="mobile-backdrop" id="mobileBackdrop" onclick="closeSidebars()"></div>

        <div class="sidebar-left" id="sidebarLeft">
            <div class="drawer-header">
                <div class="panel-title">[ ONLINE USERS ]</div>
                <button class="sidebar-close-btn" onclick="closeSidebars()" aria-label="Close menu">Ã—</button>
            </div>

            <!-- Away Status Input -->
            <div class="away-status-section">
                <div class="away-status-input-wrapper">
                    <input type="text" class="away-status-input" id="awayStatusInput"
                        placeholder="Set your status..." maxlength="50"
                        onkeydown="if(event.key==='Enter')setAwayStatus()">
                    <button class="away-status-btn" onclick="setAwayStatus()">SET</button>
                </div>
                <div class="away-status-current" id="awayStatusCurrent" style="display:none;">
                    Status: <span class="status-text" id="currentStatusText"></span>
                    <button class="clear-status-btn" onclick="clearAwayStatus()">clear</button>
                </div>
            </div>

            <ul class="user-list" id="userList">
            </ul>

            <!-- Dynamic Tag Cloud -->
            <div class="tag-cloud-section">
                <div class="panel-title">[ TAG CLOUD ]</div>
                <div class="tag-cloud" id="tagCloud">
                    <div class="tag-cloud-empty">No tags yet...</div>
                </div>
            </div>

            <div class="drawer-footer">
                <a href="https://sloppy.live" class="stream-link" target="_blank">â† Back to Stream</a>
            </div>
        </div>

        <div class="main-content">
            <div class="view-tabs">
                <button class="view-tab active" data-view="chat" onclick="switchView('chat')">ðŸ’¬ CHAT</button>
                <button class="view-tab" data-view="posts" onclick="switchView('posts')">ðŸ“¸ POSTS</button>
                <button class="view-tab" data-view="doodles" onclick="switchView('doodles')">ðŸ† DOODLES</button>
                <button class="view-tab" data-view="manifesto" onclick="switchView('manifesto')">ðŸ“œ MANIFESTO</button>
                <button class="view-tab" data-view="collab" onclick="switchView('collab')">ðŸŽ¨ COLLAB</button>
                <button class="view-tab" data-view="feedback" onclick="switchView('feedback')">ðŸ’¡ IDEAS</button>
            </div>
            <div class="input-area" id="chatInputArea">
                <div class="tag-hint" id="tagHint">
                    <span style="margin-right:8px;">ðŸ’¡ Use:</span>
                    <span class="tag-hint-item" onclick="insertTag('#vibe')">#vibe</span>
                    <span class="tag-hint-item" onclick="insertTag('#art')">#art</span>
                    <span class="tag-hint-item" onclick="insertTag('#music')">#music</span>
                    <span class="tag-hint-item" onclick="insertTag('#code')">#code</span>
                    <span class="tag-hint-item" onclick="insertTag('#meme')">#meme</span>
                </div>
                <div class="image-preview" id="imagePreview">
                    <img id="previewImg" src="">
                    <button class="remove-btn" onclick="removeImage()">Ã—</button>
                </div>
                <div class="input-row">
                    <div class="input-actions">
                        <button class="action-btn" onclick="document.getElementById('imageInput').click()">ðŸ“·</button>
                        <button class="action-btn" onclick="openDrawingModal()">ðŸŽ¨</button>
                    </div>
                    <input type="file" id="imageInput" accept="image/*" onchange="handleImageSelect(event)">
                    <textarea class="message-input" id="messageInput" placeholder="Type a message... (use #tags and @mentions)" rows="1" oninput="handleTagInput(this)"></textarea>
                    <button class="send-btn" onclick="sendMessage()">SEND</button>
                </div>
            </div>
            <div class="chat-filter-bar" id="chatFilterBar">
                <span style="color:var(--text-dim);font-size:0.85rem;">Filtering by:</span>
                <span class="chat-filter-value" id="activeChatFilter"></span>
                <button class="clear-filter" onclick="clearChatFilter()">Ã—</button>
            </div>
            <div class="messages-container" id="messagesContainer">
                <div class="empty-state" id="emptyState">
                    <div class="icon">ðŸ’¾</div>
                    <p>INITIALIZING CHAT PROTOCOL...</p>
                    <p>Say something!</p>
                </div>
            </div>
            <div class="tag-filter-bar" id="tagFilterBar">
                <span style="color:var(--text-dim);font-size:0.85rem;">Filtering by:</span>
                <span class="tag" id="activeFilterTag"></span>
                <button class="clear-filter" onclick="clearTagFilter()">Ã—</button>
            </div>
            <div class="posts-container" id="postsContainer">
                <div class="empty-state" id="postsEmptyState">
                    <div class="icon">ðŸ“¸</div>
                    <p>NO POSTS YET...</p>
                    <p>Be the first to share!</p>
                </div>
            </div>
            <div class="doodles-container" id="doodlesContainer">
                <div class="leaderboard-header">ðŸ† LEGENDARY DOODLES ðŸ†</div>
                <div class="empty-doodles" id="doodlesEmptyState">
                    <div class="icon">ðŸŽ¨</div>
                    <p>NO LEGENDARY DOODLES YET...</p>
                    <p>Draw something and get votes!</p>
                </div>
            </div>
            <div class="manifesto-container" id="manifestoContainer">
                <div class="manifesto-header">
                    <h2>ðŸ“œ THE MANIFESTO BOARD ðŸ“œ</h2>
                    <p class="manifesto-subtitle">Declare your ideas. Shape the future.</p>
                    <button class="cyber-btn" onclick="openManifestoModal()">âœï¸ WRITE MANIFESTO</button>
                </div>
                <div class="manifesto-list" id="manifestoList">
                    <div class="empty-state" id="manifestoEmptyState">
                        <div class="icon">ðŸ“œ</div>
                        <p>NO MANIFESTOS YET...</p>
                        <p>Be the first to declare your vision!</p>
                    </div>
                </div>
            </div>
            <div class="collab-container" id="collabContainer">
                <div class="collab-header">
                    <h2>ðŸŽ¨ COLLABORATIVE CANVAS ðŸŽ¨</h2>
                    <p class="collab-subtitle">Draw together in real-time. Scroll to zoom, drag to pan!</p>
                    <div class="collab-users" id="collabUsers">
                        <span class="collab-user-count">ðŸ‘¥ <span id="collabUserCount">0</span> drawing</span>
                        <span class="collab-zoom-level">ðŸ” <span id="collabZoomLevel">100</span>%</span>
                    </div>
                </div>
                <div class="collab-canvas-wrapper" id="collabCanvasWrapper">
                    <canvas id="collabCanvas" width="1600" height="1000"></canvas>
                    <div class="collab-cursors" id="collabCursors"></div>
                </div>
                <div class="collab-controls">
                    <div class="collab-zoom-controls">
                        <button class="cyber-btn collab-zoom-btn" onclick="collabZoomIn()">âž•</button>
                        <button class="cyber-btn collab-zoom-btn" onclick="collabZoomReset()">âŸ²</button>
                        <button class="cyber-btn collab-zoom-btn" onclick="collabZoomOut()">âž–</button>
                    </div>
                    <div class="collab-colors">
                        <button class="collab-color-btn active" data-color="#ff00ff" style="background:#ff00ff" onclick="setCollabColor('#ff00ff')"></button>
                        <button class="collab-color-btn" data-color="#00ffff" style="background:#00ffff" onclick="setCollabColor('#00ffff')"></button>
                        <button class="collab-color-btn" data-color="#00ff41" style="background:#00ff41" onclick="setCollabColor('#00ff41')"></button>
                        <button class="collab-color-btn" data-color="#ffff00" style="background:#ffff00" onclick="setCollabColor('#ffff00')"></button>
                        <button class="collab-color-btn" data-color="#ff6600" style="background:#ff6600" onclick="setCollabColor('#ff6600')"></button>
                        <button class="collab-color-btn" data-color="#ff0066" style="background:#ff0066" onclick="setCollabColor('#ff0066')"></button>
                        <button class="collab-color-btn" data-color="#ffffff" style="background:#ffffff" onclick="setCollabColor('#ffffff')"></button>
                        <button class="collab-color-btn" data-color="#000000" style="background:#000000;border:1px solid #333" onclick="setCollabColor('#000000')"></button>
                        <button class="collab-color-btn collab-eraser-btn" data-color="#0a0a0a" style="background:linear-gradient(135deg,#0a0a0a 50%,#333 50%);border:1px solid #666" onclick="setCollabColor('#0a0a0a')" title="Eraser">ðŸ§½</button>
                    </div>
                    <div class="collab-actions">
                        <button class="cyber-btn collab-snapshot-btn" onclick="snapshotCollabCanvas()">ðŸ“¸ SNAPSHOT</button>
                        <button class="cyber-btn collab-clear-btn" onclick="clearCollabCanvas()">ðŸ§¹ CLEAR MINE</button>
                    </div>
                </div>
            </div>

            <!-- Feedback/Ideas Container -->
            <div class="feedback-container" id="feedbackContainer">
                <div class="feedback-stats">
                    <div class="feedback-stat">
                        <div class="feedback-stat-num" id="feedbackTotalIdeas">0</div>
                        <div class="feedback-stat-label">Ideas</div>
                    </div>
                    <div class="feedback-stat">
                        <div class="feedback-stat-num" id="feedbackTotalVotes">0</div>
                        <div class="feedback-stat-label">Votes</div>
                    </div>
                    <div class="feedback-stat">
                        <div class="feedback-stat-num" id="feedbackContributors">0</div>
                        <div class="feedback-stat-label">Contributors</div>
                    </div>
                </div>

                <button class="feedback-new-btn" onclick="toggleFeedbackForm()">âœ¨ SUBMIT NEW IDEA</button>

                <div class="feedback-form" id="feedbackForm">
                    <input type="text" id="feedbackTitle" placeholder="Short summary of your idea..." maxlength="100">
                    <textarea id="feedbackDesc" placeholder="Describe your suggestion in detail (optional)..." maxlength="500"></textarea>
                    <div class="feedback-categories">
                        <button class="feedback-cat-btn selected" data-category="apps" onclick="selectFeedbackCategory('apps')">Apps</button>
                        <button class="feedback-cat-btn" data-category="sloppy" onclick="selectFeedbackCategory('sloppy')">Sloppy/AI</button>
                        <button class="feedback-cat-btn" data-category="streamer" onclick="selectFeedbackCategory('streamer')">Streamer</button>
                        <button class="feedback-cat-btn" data-category="general" onclick="selectFeedbackCategory('general')">General</button>
                    </div>
                    <button class="feedback-submit-btn" onclick="submitFeedback()">[ SUBMIT ]</button>
                </div>

                <div class="feedback-filters">
                    <button class="feedback-filter active" data-filter="all" onclick="filterFeedback('all')">All</button>
                    <button class="feedback-filter" data-filter="apps" onclick="filterFeedback('apps')">Apps</button>
                    <button class="feedback-filter" data-filter="sloppy" onclick="filterFeedback('sloppy')">Sloppy/AI</button>
                    <button class="feedback-filter" data-filter="streamer" onclick="filterFeedback('streamer')">Streamer</button>
                    <button class="feedback-filter" data-filter="mine" onclick="filterFeedback('mine')">My Ideas</button>
                </div>

                <div class="feedback-list" id="feedbackList">
                    <div class="feedback-empty">Loading ideas...</div>
                </div>
            </div>
        </div>

        <div class="sidebar-right" id="sidebarRight">
            <button class="sidebar-close-btn" onclick="closeSidebars()">Ã—</button>
            <div class="panel-title">[ PUBLIC FEED ]</div>
            <div id="publicFeed">
                <div class="feed-item">
                    <span class="feed-user">System</span>
                    <span class="feed-action">initialized</span>
                    <div class="feed-time">just now</div>
                </div>
            </div>
            <div class="trending-tags-section" id="trendingTagsSection">
                <div class="panel-title">[ TRENDING TAGS ]</div>
                <div id="trendingTagsList" class="trending-tags-list">
                    <div style="font-size:0.85rem;color:var(--text-dim)">Loading tags...</div>
                </div>
            </div>
        </div>
    </div>

    <!-- Support Modal -->
    <div class="support-modal" id="supportModal" onclick="if(event.target===this)closeSupportModal()">
        <div class="support-modal-content">
            <div class="support-header">
                <h2>ðŸ’° Support the Stream</h2>
                <button class="support-close" onclick="closeSupportModal()">Ã—</button>
            </div>

            <!-- Fiat Section -->
            <div class="support-section-label">ðŸ’µ Fiat</div>
            <div class="fiat-grid">
                <a href="https://ko-fi.com/sloppylive" target="_blank" class="fiat-btn kofi">
                    â˜• Ko-fi
                </a>
                <a href="https://paypal.me/sloppylive" target="_blank" class="fiat-btn paypal">
                    ðŸ’³ PayPal
                </a>
                <a href="https://patreon.com/sloppylive" target="_blank" class="fiat-btn patreon">
                    ðŸŽ¨ Patreon
                </a>
            </div>

            <!-- Crypto Section -->
            <div class="support-section-label">ðŸ” Crypto</div>
            <div class="support-grid">
                <!-- Bitcoin -->
                <div class="support-option btc" onclick="copyCryptoAddress('btc')">
                    <div class="support-icon">â‚¿</div>
                    <h3>Bitcoin</h3>
                    <div class="crypto-address" id="addr-btc">bc1qxy2kgdygjrsqtzq2n0yrf2493p83kkfjhx0wlh</div>
                    <div class="copy-hint">ðŸ“‹ Click to copy</div>
                </div>

                <!-- Ethereum -->
                <div class="support-option eth" onclick="copyCryptoAddress('eth')">
                    <div class="support-icon">Îž</div>
                    <h3>Ethereum</h3>
                    <div class="crypto-address" id="addr-eth">0x742d35Cc6634C0532925a3b844Bc9e7595f...</div>
                    <div class="copy-hint">ðŸ“‹ Click to copy</div>
                </div>

                <!-- Solana -->
                <div class="support-option sol" onclick="copyCryptoAddress('sol')">
                    <div class="support-icon">â—Ž</div>
                    <h3>Solana</h3>
                    <div class="crypto-address" id="addr-sol">7EcDhSYGxXyscszYEp35KHN8vvw3svAuLKTzXwCFLtV...</div>
                    <div class="copy-hint">ðŸ“‹ Click to copy</div>
                </div>

                <!-- Monero -->
                <div class="support-option xmr" onclick="copyCryptoAddress('xmr')">
                    <div class="support-icon">É±</div>
                    <h3>Monero</h3>
                    <div class="crypto-address" id="addr-xmr">888tNkZrPN6JsEgekjMnABU4TBzc2Dt29EPAvkRx...</div>
                    <div class="copy-hint">ðŸ“‹ Click to copy</div>
                </div>

                <!-- Stripe -->
                <div class="support-option stripe" style="grid-column: span 2;">
                    <div class="support-icon">ðŸ’³</div>
                    <h3>Card Payment</h3>
                    <a href="https://buy.stripe.com/placeholder" target="_blank" class="stripe-btn" onclick="event.preventDefault();alert('Stripe payment link coming soon!');">
                        Pay with Stripe
                    </a>
                </div>
            </div>

            <div class="support-footer">
                All contributions help keep the stream running 24/7 ðŸ–¤
            </div>
        </div>
    </div>

    <!-- Image Lightbox -->
    <div class="lightbox" id="imageLightbox" onclick="closeLightbox()">
        <button class="lightbox-close" onclick="closeLightbox()">Ã—</button>
        <img class="lightbox-image" id="lightboxImage" src="" alt="Full size image">
    </div>

    <!-- Share Modal -->
    <div class="share-modal" id="shareModal" onclick="if(event.target===this)closeShareModal()">
        <div class="share-modal-content">
            <div class="share-modal-header">
                <span class="share-modal-title">ðŸ“¡ SHARE</span>
                <button class="share-modal-close" onclick="closeShareModal()">Ã—</button>
            </div>
            <div class="share-buttons">
                <a href="#" class="share-btn x-twitter" id="shareTwitterBtn" target="_blank">
                    <span class="share-btn-icon">ð•</span>
                    <span>Share on X</span>
                </a>
                <a href="#" class="share-btn reddit" id="shareRedditBtn" target="_blank">
                    <span class="share-btn-icon">ðŸ¤–</span>
                    <span>Share on Reddit</span>
                </a>
                <button class="share-btn copy-link" id="shareCopyBtn" onclick="copyShareLink()">
                    <span class="share-btn-icon">ðŸ”—</span>
                    <span>Copy Link</span>
                </button>
            </div>
        </div>
    </div>

    <!-- Settings Modal -->
    <div class="modal-overlay" id="settingsModal">
        <div class="modal" style="max-width: 450px;">
            <h2>
                <span>âš™ï¸</span> SETTINGS
                <button class="modal-close" onclick="closeSettingsModal()">Ã—</button>
            </h2>

            <div class="settings-tabs">
                <button class="settings-tab active" onclick="switchSettingsTab('profile')">ðŸ‘¤ PROFILE</button>
                <button class="settings-tab" onclick="switchSettingsTab('themes')">ðŸŽ¨ THEMES</button>
                <button class="settings-tab" onclick="switchSettingsTab('sounds')">ðŸ”” SOUNDS</button>
                <button class="settings-tab" onclick="switchSettingsTab('system')">âš¡ SYSTEM</button>
            </div>

            <!-- Profile Tab -->
            <div class="settings-panel active" id="profilePanel">
                <div class="form-group">
                    <label>USERNAME:</label>
                    <input type="text" id="usernameInput" placeholder="Enter handle..." maxlength="20">
                </div>

                <div class="form-group">
                    <label>SELECT AVATAR:</label>
                    <div class="avatar-grid" id="avatarGrid"></div>
                </div>

                <div class="form-group">
                    <label>CUSTOM AVATAR (upload image):</label>
                    <div class="file-upload-row">
                        <input type="file" id="avatarFileInput" accept="image/*" onchange="handleAvatarUpload(event)" style="display:none">
                        <button class="file-upload-btn" onclick="document.getElementById('avatarFileInput').click()">ðŸ“ CHOOSE FILE</button>
                        <button class="file-clear-btn" onclick="clearAvatarUpload()" id="clearAvatarBtn" style="display:none">âœ• CLEAR</button>
                    </div>
                    <div class="upload-preview" id="avatarPreview" style="display:none">
                        <img id="avatarPreviewImg" src="">
                    </div>
                </div>

                <div class="form-group">
                    <label>AVATAR COLOR:</label>
                    <div class="color-options" id="colorOptions"></div>
                </div>

                <div class="form-group">
                    <label>CUSTOM BACKGROUND (upload image):</label>
                    <div class="file-upload-row">
                        <input type="file" id="bgFileInput" accept="image/*" onchange="handleBgUpload(event)" style="display:none">
                        <button class="file-upload-btn" onclick="document.getElementById('bgFileInput').click()">ðŸ“ UPLOAD NEW</button>
                        <button class="file-upload-btn" onclick="shareBackground()" id="shareBgBtn" style="display:none">ðŸŒ SHARE</button>
                        <button class="file-upload-btn" onclick="setGlobalBackground()" id="setGlobalBgBtn" style="display:none;background:#4a1a7a;">ðŸŒ SET FOR ALL</button>
                        <button class="file-clear-btn" onclick="clearBgUpload()" id="clearBgBtn" style="display:none">âœ•</button>
                    </div>
                    <div class="upload-preview" id="bgPreview" style="display:none">
                        <img id="bgPreviewImg" src="">
                    </div>
                    <div class="global-bg-section">
                        <div class="global-bg-label">Or choose a shared background:</div>
                        <div class="global-bg-grid" id="globalBgGrid">
                            <div class="global-bg-item global-bg-upload" onclick="document.getElementById('bgFileInput').click()" title="Upload new">+</div>
                        </div>
                    </div>
                </div>

                <button class="modal-btn" onclick="saveProfile()">[ SAVE ]</button>
                <button class="modal-btn" style="background: #3a2020; margin-top: 8px;" onclick="resetProfile()">[ RESET ALL ]</button>
            </div>

            <!-- Themes Tab -->
            <div class="settings-panel" id="themesPanel">
                <div class="form-group">
                    <label>MESSAGE OPACITY:</label>
                    <div class="theme-slider-row">
                        <input type="range" id="msgOpacitySlider" min="0" max="100" value="95" oninput="setMessageOpacity(this.value)">
                        <span id="opacityValue">95%</span>
                    </div>
                </div>

                <div class="form-group">
                    <label>MESSAGE COLOR (others):</label>
                    <div class="color-picker-grid" id="msgColorGrid">
                        <div class="msg-color-option selected" style="background: rgb(10, 10, 15);" onclick="selectMsgColor('10, 10, 15')" title="Default Dark"></div>
                        <div class="msg-color-option" style="background: rgb(20, 20, 30);" onclick="selectMsgColor('20, 20, 30')" title="Midnight"></div>
                        <div class="msg-color-option" style="background: rgb(30, 20, 40);" onclick="selectMsgColor('30, 20, 40')" title="Purple Night"></div>
                        <div class="msg-color-option" style="background: rgb(20, 30, 30);" onclick="selectMsgColor('20, 30, 30')" title="Teal Dark"></div>
                        <div class="msg-color-option" style="background: rgb(40, 30, 20);" onclick="selectMsgColor('40, 30, 20')" title="Warm Brown"></div>
                        <div class="msg-color-option" style="background: rgb(15, 25, 35);" onclick="selectMsgColor('15, 25, 35')" title="Deep Blue"></div>
                        <div class="msg-color-option" style="background: rgb(35, 15, 25);" onclick="selectMsgColor('35, 15, 25')" title="Wine"></div>
                        <div class="msg-color-option" style="background: rgb(25, 35, 25);" onclick="selectMsgColor('25, 35, 25')" title="Forest"></div>
                        <div class="msg-color-option" style="background: rgb(45, 35, 45);" onclick="selectMsgColor('45, 35, 45')" title="Mauve"></div>
                        <div class="msg-color-option" style="background: rgb(50, 50, 50);" onclick="selectMsgColor('50, 50, 50')" title="Gray"></div>
                    </div>
                </div>

                <div class="form-group">
                    <label>YOUR MESSAGE COLOR:</label>
                    <div class="color-picker-grid" id="msgOwnColorGrid">
                        <div class="msg-color-option selected" style="background: rgb(90, 112, 96);" onclick="selectMsgOwnColor('90, 112, 96')" title="Default Green"></div>
                        <div class="msg-color-option" style="background: rgb(70, 90, 120);" onclick="selectMsgOwnColor('70, 90, 120')" title="Steel Blue"></div>
                        <div class="msg-color-option" style="background: rgb(100, 80, 120);" onclick="selectMsgOwnColor('100, 80, 120')" title="Lavender"></div>
                        <div class="msg-color-option" style="background: rgb(120, 90, 70);" onclick="selectMsgOwnColor('120, 90, 70')" title="Copper"></div>
                        <div class="msg-color-option" style="background: rgb(80, 110, 100);" onclick="selectMsgOwnColor('80, 110, 100')" title="Sage"></div>
                        <div class="msg-color-option" style="background: rgb(110, 85, 85);" onclick="selectMsgOwnColor('110, 85, 85')" title="Dusty Rose"></div>
                        <div class="msg-color-option" style="background: rgb(85, 100, 85);" onclick="selectMsgOwnColor('85, 100, 85')" title="Olive"></div>
                        <div class="msg-color-option" style="background: rgb(95, 95, 115);" onclick="selectMsgOwnColor('95, 95, 115')" title="Slate"></div>
                        <div class="msg-color-option" style="background: rgb(115, 100, 80);" onclick="selectMsgOwnColor('115, 100, 80')" title="Sand"></div>
                        <div class="msg-color-option" style="background: rgb(75, 105, 115);" onclick="selectMsgOwnColor('75, 105, 115')" title="Ocean"></div>
                    </div>
                </div>

                <div class="form-group">
                    <label>ACCENT COLOR:</label>
                    <div class="color-picker-grid" id="accentColorGrid">
                        <div class="msg-color-option selected" style="background: #7c9885;" onclick="selectAccentColor('#7c9885')" title="Default Green"></div>
                        <div class="msg-color-option" style="background: #8590a8;" onclick="selectAccentColor('#8590a8')" title="Steel"></div>
                        <div class="msg-color-option" style="background: #a085a0;" onclick="selectAccentColor('#a085a0')" title="Mauve"></div>
                        <div class="msg-color-option" style="background: #85a0a8;" onclick="selectAccentColor('#85a0a8')" title="Cyan"></div>
                        <div class="msg-color-option" style="background: #a89885;" onclick="selectAccentColor('#a89885')" title="Sand"></div>
                        <div class="msg-color-option" style="background: #a88585;" onclick="selectAccentColor('#a88585')" title="Rose"></div>
                        <div class="msg-color-option" style="background: #85a890;" onclick="selectAccentColor('#85a890')" title="Mint"></div>
                        <div class="msg-color-option" style="background: #9085a8;" onclick="selectAccentColor('#9085a8')" title="Violet"></div>
                        <div class="msg-color-option" style="background: #a8a085;" onclick="selectAccentColor('#a8a085')" title="Gold"></div>
                        <div class="msg-color-option" style="background: #85a8a8;" onclick="selectAccentColor('#85a8a8')" title="Teal"></div>
                    </div>
                </div>

                <div class="form-group">
                    <label>HIGHLIGHT COLOR:</label>
                    <div class="color-picker-grid" id="highlightColorGrid">
                        <div class="msg-color-option selected" style="background: #c9a87c;" onclick="selectHighlightColor('#c9a87c')" title="Default Gold"></div>
                        <div class="msg-color-option" style="background: #7ca8c9;" onclick="selectHighlightColor('#7ca8c9')" title="Sky"></div>
                        <div class="msg-color-option" style="background: #c97ca8;" onclick="selectHighlightColor('#c97ca8')" title="Pink"></div>
                        <div class="msg-color-option" style="background: #a8c97c;" onclick="selectHighlightColor('#a8c97c')" title="Lime"></div>
                        <div class="msg-color-option" style="background: #c9c97c;" onclick="selectHighlightColor('#c9c97c')" title="Yellow"></div>
                        <div class="msg-color-option" style="background: #7cc9a8;" onclick="selectHighlightColor('#7cc9a8')" title="Aqua"></div>
                        <div class="msg-color-option" style="background: #c97c7c;" onclick="selectHighlightColor('#c97c7c')" title="Coral"></div>
                        <div class="msg-color-option" style="background: #a87cc9;" onclick="selectHighlightColor('#a87cc9')" title="Purple"></div>
                        <div class="msg-color-option" style="background: #7cc9c9;" onclick="selectHighlightColor('#7cc9c9')" title="Cyan"></div>
                        <div class="msg-color-option" style="background: #c9c9c9;" onclick="selectHighlightColor('#c9c9c9')" title="Silver"></div>
                    </div>
                </div>

                <div class="form-group">
                    <label>PANEL BACKGROUND:</label>
                    <div class="color-picker-grid" id="panelBgGrid">
                        <div class="msg-color-option selected" style="background: #12121a;" onclick="selectPanelBg('#12121a')" title="Default Dark"></div>
                        <div class="msg-color-option" style="background: #0a0a0f;" onclick="selectPanelBg('#0a0a0f')" title="Pure Black"></div>
                        <div class="msg-color-option" style="background: #1a1218;" onclick="selectPanelBg('#1a1218')" title="Wine Dark"></div>
                        <div class="msg-color-option" style="background: #12181a;" onclick="selectPanelBg('#12181a')" title="Teal Dark"></div>
                        <div class="msg-color-option" style="background: #18121a;" onclick="selectPanelBg('#18121a')" title="Purple Dark"></div>
                        <div class="msg-color-option" style="background: #1a1812;" onclick="selectPanelBg('#1a1812')" title="Warm Dark"></div>
                        <div class="msg-color-option" style="background: #121a14;" onclick="selectPanelBg('#121a14')" title="Forest Dark"></div>
                        <div class="msg-color-option" style="background: #1a1a1a;" onclick="selectPanelBg('#1a1a1a')" title="Gray"></div>
                        <div class="msg-color-option" style="background: #121418;" onclick="selectPanelBg('#121418')" title="Navy"></div>
                        <div class="msg-color-option" style="background: #181414;" onclick="selectPanelBg('#181414')" title="Charcoal"></div>
                    </div>
                </div>

                <button class="modal-btn" onclick="saveThemeSettings()">[ SAVE THEME ]</button>
                <button class="modal-btn" style="background: #3a2020; margin-top: 8px;" onclick="resetTheme()">[ RESET THEME ]</button>
            </div>

            <!-- Sounds Tab -->
            <div class="settings-panel" id="soundsPanel">
                <div class="form-group">
                    <label>NOTIFICATION SOUND:</label>
                    <div class="sound-grid" id="soundGrid">
                        <div class="sound-option selected" onclick="selectSound('none')">
                            <span class="sound-icon">ðŸ”‡</span>
                            <span class="sound-name">None</span>
                        </div>
                        <div class="sound-option" onclick="selectSound('blip')">
                            <span class="sound-icon">ðŸ’«</span>
                            <span class="sound-name">Blip</span>
                            <button class="sound-preview-btn" onclick="event.stopPropagation(); previewSound('blip')">â–¶</button>
                        </div>
                        <div class="sound-option" onclick="selectSound('chime')">
                            <span class="sound-icon">ðŸ””</span>
                            <span class="sound-name">Chime</span>
                            <button class="sound-preview-btn" onclick="event.stopPropagation(); previewSound('chime')">â–¶</button>
                        </div>
                        <div class="sound-option" onclick="selectSound('pop')">
                            <span class="sound-icon">ðŸ’¬</span>
                            <span class="sound-name">Pop</span>
                            <button class="sound-preview-btn" onclick="event.stopPropagation(); previewSound('pop')">â–¶</button>
                        </div>
                        <div class="sound-option" onclick="selectSound('retro')">
                            <span class="sound-icon">ðŸ‘¾</span>
                            <span class="sound-name">Retro</span>
                            <button class="sound-preview-btn" onclick="event.stopPropagation(); previewSound('retro')">â–¶</button>
                        </div>
                        <div class="sound-option" onclick="selectSound('cyber')">
                            <span class="sound-icon">ðŸ¤–</span>
                            <span class="sound-name">Cyber</span>
                            <button class="sound-preview-btn" onclick="event.stopPropagation(); previewSound('cyber')">â–¶</button>
                        </div>
                        <div class="sound-option" onclick="selectSound('whoosh')">
                            <span class="sound-icon">ðŸ’¨</span>
                            <span class="sound-name">Whoosh</span>
                            <button class="sound-preview-btn" onclick="event.stopPropagation(); previewSound('whoosh')">â–¶</button>
                        </div>
                        <div class="sound-option" onclick="selectSound('ding')">
                            <span class="sound-icon">âœ¨</span>
                            <span class="sound-name">Ding</span>
                            <button class="sound-preview-btn" onclick="event.stopPropagation(); previewSound('ding')">â–¶</button>
                        </div>
                        <div class="sound-option" onclick="selectSound('custom')">
                            <span class="sound-icon">ðŸ”—</span>
                            <span class="sound-name">Custom</span>
                            <button class="sound-preview-btn" onclick="event.stopPropagation(); previewSound('custom')">â–¶</button>
                        </div>
                    </div>
                </div>

                <div class="form-group">
                    <label>CUSTOM SOUND:</label>
                    <div class="file-upload-row">
                        <input type="file" id="customSoundFile" accept="audio/*" onchange="handleSoundUpload(event)" style="display:none">
                        <button class="file-upload-btn" onclick="document.getElementById('customSoundFile').click()">ðŸ“ UPLOAD AUDIO</button>
                        <button class="file-clear-btn" onclick="clearCustomSound()" id="clearSoundBtn" style="display:none">âœ• CLEAR</button>
                    </div>
                    <div id="customSoundName" style="font-size:0.85rem;color:var(--accent);margin-top:6px;display:none;"></div>
                    <div style="font-size:0.8rem;color:var(--text-dim);margin-top:4px;">Upload .mp3, .wav, or .ogg (max 500KB)</div>
                </div>

                <div class="volume-control">
                    <label>ðŸ”Š VOLUME:</label>
                    <input type="range" id="volumeSlider" min="0" max="100" value="50" oninput="setVolume(this.value)">
                    <span id="volumeValue">50%</span>
                </div>

                <button class="modal-btn" style="margin-top: 20px;" onclick="saveSoundSettings()">[ SAVE SOUNDS ]</button>
            </div>

            <!-- System Tab -->
            <div class="settings-panel" id="systemPanel">
                <div class="form-group">
                    <label>âš¡ SYSTEM CONTROLS:</label>
                    <p style="color: var(--text-dim); font-size: 0.85rem; margin: 10px 0;">
                        Flush memory caches and reinitialize all connections. Use when experiencing sync issues or stale data.
                    </p>
                </div>

                <button class="modal-btn" style="background: linear-gradient(135deg, #003300, #001100); border-color: #00ff00; color: #00ff00;" onclick="closeSettingsModal(); window.rebootSystem();">
                    [ âš¡ REBOOT SYSTEM ]
                </button>

                <div class="form-group" style="margin-top: 30px;">
                    <label>ðŸŽ® HACKER MARKUP:</label>
                    <p style="color: var(--text-dim); font-size: 0.85rem; margin: 10px 0;">
                        Use these tags in chat messages for effects:
                    </p>
                    <div style="font-family: monospace; font-size: 0.8rem; color: var(--accent); line-height: 1.8;">
                        [shake]text[/shake] - shaking text<br>
                        [rainbow]text[/rainbow] - rainbow colors<br>
                        [matrix]text[/matrix] - matrix style<br>
                        [glitch]text[/glitch] - glitch effect<br>
                        [pulse]text[/pulse] - pulsing text<br>
                        [wave]text[/wave] - wave motion<br>
                        [spoiler]text[/spoiler] - hidden text
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Drawing Modal -->
    <div class="modal-overlay drawing-modal" id="drawingModal">
        <div class="modal">
            <h2>
                <span>ðŸŽ¨</span> PIXEL CANVAS
                <button class="modal-close" onclick="closeDrawingModal()">Ã—</button>
            </h2>

            <div class="canvas-tools">
                <div class="brush-colors" id="brushColors"></div>
                <div class="canvas-actions">
                    <button class="tool-btn" id="undoBtn" onclick="undoCanvas()" disabled title="Undo (Ctrl+Z)">â†© UNDO</button>
                    <button class="tool-btn" id="redoBtn" onclick="redoCanvas()" disabled title="Redo (Ctrl+Y)">â†ª REDO</button>
                    <button class="tool-btn" onclick="clearCanvas()">CLEAR</button>
                </div>
            </div>

            <div class="canvas-container">
                <canvas id="drawingCanvas" width="400" height="300"></canvas>
            </div>

            <button class="modal-btn" onclick="sendDrawing()">[ TRANSMIT ]</button>
        </div>
    </div>

    <!-- Create Post Modal -->
    <div class="modal-overlay post-modal" id="postModal">
        <div class="modal">
            <h2>
                <span>ðŸ“¸</span> NEW POST
                <button class="modal-close" onclick="closePostModal()">Ã—</button>
            </h2>

            <div class="post-preview" id="postPreview">
                <span>No image selected</span>
            </div>

            <div class="form-group">
                <label>IMAGE URL:</label>
                <input type="text" id="postImageUrl" placeholder="https://example.com/image.jpg" oninput="previewPostImage()">
            </div>

            <div class="or-divider">â€” OR â€”</div>

            <div class="form-group">
                <label>UPLOAD FILE:</label>
                <input type="file" id="postFileInput" accept="image/*" onchange="handlePostFileSelect(event)" style="display:block;background:var(--dark-bg);padding:8px;border:1px solid var(--border-color);color:var(--accent-light);width:100%;">
            </div>

            <div class="form-group">
                <label>CAPTION:</label>
                <input type="text" id="postCaption" placeholder="Write something..." maxlength="500">
            </div>

            <div class="form-group">
                <label>TAGS (use parent/child for nested):</label>
                <div class="tag-input-container" id="tagInputContainer">
                    <input type="text" class="tag-input" id="tagInput" placeholder="Type tag and press Enter... (e.g. art/digital)" onkeydown="handlePostTagInput(event)">
                </div>
                <div style="font-size:0.75rem;color:var(--text-dim);margin-top:4px;">
                    Tip: Use "/" for nested tags like "meme/cursed" or "art/pixel"
                </div>
            </div>

            <button class="modal-btn" onclick="submitPost()">[ POST IT ]</button>
        </div>
    </div>

    <!-- Create Post FAB -->
    <button class="create-post-btn" id="createPostBtn" onclick="openPostModal()">+</button>

    <!-- Create Manifesto Modal -->
    <div class="modal-overlay" id="manifestoModal">
        <div class="modal manifesto-modal">
            <h2>
                <span>ðŸ“œ</span> WRITE YOUR MANIFESTO
                <button class="modal-close" onclick="closeManifestoModal()">Ã—</button>
            </h2>

            <div class="form-group">
                <label>TITLE:</label>
                <input type="text" id="manifestoTitle" placeholder="Your manifesto title..." maxlength="100">
            </div>

            <div class="form-group">
                <label>YOUR VISION:</label>
                <textarea id="manifestoContent" placeholder="Declare your ideas, beliefs, and vision for the future..." rows="8" maxlength="2000" style="width:100%;background:var(--dark-bg);border:1px solid var(--border-color);color:var(--accent-light);padding:10px;font-family:inherit;resize:vertical;"></textarea>
                <div style="font-size:0.75rem;color:var(--text-dim);margin-top:4px;text-align:right;">
                    <span id="manifestoCharCount">0</span>/2000
                </div>
            </div>

            <div class="form-group">
                <label>TAGS (use parent/child for nested):</label>
                <div class="tag-input-container" id="manifestoTagInputContainer">
                    <input type="text" class="tag-input" id="manifestoTagInput" placeholder="Type tag and press Enter... (e.g. philosophy/ethics)" onkeydown="handleManifestoTagInput(event)">
                </div>
                <div style="font-size:0.75rem;color:var(--text-dim);margin-top:4px;">
                    Tip: Use "/" for nested tags like "tech/ai" or "society/future"
                </div>
            </div>

            <button class="modal-btn" onclick="submitManifesto()">[ DECLARE IT ]</button>
        </div>
    </div>

    <!-- Tag Explorer Modal -->
    <div class="modal-overlay tag-explorer-modal" id="tagExplorerModal">
        <div class="modal">
            <h2>
                <span>ðŸ·ï¸</span> TAG EXPLORER
                <button class="modal-close" onclick="closeTagExplorer()">Ã—</button>
            </h2>
            <div id="tagExplorerContent">
                <div class="tag-explorer-loading">Loading tag data...</div>
            </div>
        </div>
    </div>

    <script type="module">
        // Error handlers are now in the early error catcher script in <head>

        import { createClient } from "https://esm.sh/@supabase/supabase-js@2";

        const SUPABASE_URL = 'https://yjyxteqzhhmtrgcaekgz.supabase.co';
        const SUPABASE_ANON_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InlqeXh0ZXF6aGhtdHJnY2Fla2d6Iiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTczNTg3NDIsImV4cCI6MjA3MjkzNDc0Mn0.G8SRde7IN2QFW1EnASM8IS32IUYR2eenCCjdDdioiBU';
        const supabase = createClient(SUPABASE_URL, SUPABASE_ANON_KEY, {
            auth: {
                persistSession: true,
                storageKey: 'sloppygram-auth',
                autoRefreshToken: true,
                detectSessionInUrl: false
            }
        });

        // Storage bucket name
        const STORAGE_BUCKET = 'sloppygram';

        // Safe style setter - prevents null reference errors
        function safeSetStyle(elementOrId, property, value) {
            var el = (typeof elementOrId === 'string') ? document.getElementById(elementOrId) : elementOrId;
            if (el && el.style) {
                el.style[property] = value;
            }
        }

        // Safe display setter shorthand
        function safeSetDisplay(id, value) {
            var el = document.getElementById(id);
            if (el && el.style) el.style.display = value;
        }

        // Upload image to Supabase Storage, returns public URL or null on failure
        async function uploadToStorage(blob, folder = 'images') {
            try {
                const ext = blob.type === 'image/png' ? 'png' : 'jpg';
                const filename = `${folder}/${Date.now()}_${Math.random().toString(36).slice(2)}.${ext}`;

                const { data, error } = await supabase.storage
                    .from(STORAGE_BUCKET)
                    .upload(filename, blob, {
                        contentType: blob.type,
                        cacheControl: '3600',
                        upsert: false
                    });

                if (error) {
                    console.error('Storage upload error:', error);
                    return null;
                }

                // Get public URL
                const { data: urlData } = supabase.storage
                    .from(STORAGE_BUCKET)
                    .getPublicUrl(data.path);

                return (urlData && urlData.publicUrl) ? urlData.publicUrl : null;
            } catch (err) {
                console.error('Upload failed:', err);
                return null;
            }
        }

        // Convert base64 data URL to Blob
        // Convert data URI/URL to Blob - Gold Master version with error handling
        function dataURLtoBlob(dataURL) {
            if (!dataURL || typeof dataURL !== 'string') {
                console.error('[dataURLtoBlob] Invalid input:', typeof dataURL);
                return null;
            }

            try {
                // Handle both data URI formats
                var parts = dataURL.split(',');
                if (parts.length < 2) {
                    console.error('[dataURLtoBlob] Invalid data URL format');
                    return null;
                }

                var mimeMatch = parts[0].match(/:(.*?);/);
                var mime = mimeMatch ? mimeMatch[1] : 'application/octet-stream';
                var binary = atob(parts[1]);
                var array = new Uint8Array(binary.length);

                for (var i = 0; i < binary.length; i++) {
                    array[i] = binary.charCodeAt(i);
                }

                return new Blob([array], { type: mime });
            } catch (err) {
                console.error('[dataURLtoBlob] Conversion failed:', err);
                return null;
            }
        }

        // Alias for compatibility
        var dataURItoBlob = dataURLtoBlob;

        // Avatar options
        const AVATARS = ['ðŸ˜€', 'ðŸ˜Ž', 'ðŸ¤–', 'ðŸ‘½', 'ðŸ±', 'ðŸ¶', 'ðŸ¦Š', 'ðŸ¼', 'ðŸ¸', 'ðŸ¦„', 'ðŸ²', 'ðŸ‘»', 'ðŸ’€', 'ðŸŽƒ', 'ðŸ¤¡', 'ðŸ‘¾', 'ðŸ¥·', 'ðŸ§™'];
        const COLORS = ['#00ff41', '#00ffff', '#ff00ff', '#ffff00', '#ff4444', '#ff8800', '#8844ff', '#44ff88', '#ff44aa', '#44aaff'];
        const BRUSH_COLORS = ['#00ff41', '#00ffff', '#ff00ff', '#ffff00', '#ff4444', '#ffffff', '#000000', '#888888'];

        let currentUser = null;
        let profile = {
            username: 'Anon' + Math.floor(Math.random() * 9999),
            avatar: AVATARS[Math.floor(Math.random() * AVATARS.length)],
            color: COLORS[Math.floor(Math.random() * COLORS.length)],
            avatarUrl: '',
            bgUrl: '',
            status: '' // Away message status
        };
        let selectedImage = null;
        let drawingCtx = null;
        let isDrawing = false;
        let brushColor = '#00ff41';
        const seenMessageIds = new Set();
        let onlineUsers = new Map();
        let realtimeChannel = null;
        let currentView = 'chat';
        let posts = [];
        let postLikes = {};
        let postComments = {};
        let postReactions = {}; // { postId: { emoji: count, ... } }
        let myReactions = {}; // { postId: Set of emojis I've reacted with }
        const REACTION_EMOJIS = ['ðŸ˜‚', 'ðŸ”¥', 'â¤ï¸', 'ðŸ˜®', 'ðŸ˜¢', 'ðŸ‘', 'ðŸ™Œ', 'ðŸ’€'];
        let globalBackgrounds = [];
        let postImageData = null;
        let doodleVotes = {}; // { messageId: netScore }
        let myDoodleVotes = {}; // { messageId: 1 or -1 } for my vote type
        let doodleComments = {}; // { doodleId: [comments] }
        let doodleCommentThreads = {}; // { commentId: parentCommentId }
        let replyingToDoodle = null; // { doodleId, commentId, username }
        let messageVotes = {}; // { messageId: netScore } for chat messages
        let myMessageVotes = {}; // { messageId: 1 or -1 } for my vote type
        let postVotes = {}; // { postId: netScore }
        let myPostVotes = {}; // { postId: 1 or -1 } for my vote type
        let commentVotes = {}; // { commentId: netScore }
        let myCommentVotes = {}; // { commentId: 1 or -1 } for my vote type
        let postTags = {}; // { postId: [{ tag, parent_tag }, ...] }
        let pendingTags = []; // tags being added to new post
        let activeTagFilter = null; // current tag filter for posts
        let activeChatFilter = null; // { type: 'tag'|'mention', value: string } for chat
        let commentThreads = {}; // { commentId: parentCommentId }
        let replyingTo = null; // { postId, commentId, username } when replying to a comment
        let userReputations = {}; // { username: { postLikes, manifestoVotes, total } }

        // Pagination state
        const PAGE_SIZE = 30;
        let messagesPage = 0;
        let messagesHasMore = true;
        let messagesLoading = false;
        let postsPage = 0;
        let postsHasMore = true;
        let postsLoading = false;

        // === SLOPPYFM WINAMP PLAYER ===
        // === SLOPPYFM v2.0 - SYNCHRONIZED YOUTUBE RADIO ===
        var sloppyfmPlayer = null;
        var sloppyfmReady = false;
        var sloppyfmCurrentTrack = null;
        var sloppyfmIsPlaying = false;
        var sloppyfmVolume = 70;
        var sloppyfmVisualizerInterval = null;
        var sloppyfmQueue = [];
        var sloppyfmSyncInterval = null;
        var sloppyfmChannel = null;

        // Default tracks (YouTube IDs) - can be expanded via queue
        var sloppyfmDefaultTracks = [
            { youtube_id: 'jfKfPfyJRdk', title: 'lofi hip hop radio', artist: 'Lofi Girl', duration: 0 },
            { youtube_id: '5qap5aO4i9A', title: 'chillhop radio', artist: 'Chillhop Music', duration: 0 },
            { youtube_id: 'rUxyKA_-grg', title: 'synthwave radio', artist: 'Synthwave', duration: 0 },
            { youtube_id: 'kgx4WGK0oNU', title: 'jazz vibes', artist: 'Cafe Music BGM', duration: 0 }
        ];

        // Load YouTube IFrame API
        function loadYouTubeAPI() {
            if (window.YT && window.YT.Player) {
                initSloppyFMPlayer();
                return;
            }
            var tag = document.createElement('script');
            tag.src = 'https://www.youtube.com/iframe_api';
            var firstScript = document.getElementsByTagName('script')[0];
            firstScript.parentNode.insertBefore(tag, firstScript);
        }

        // Called by YouTube API when ready
        window.onYouTubeIframeAPIReady = function() {
            initSloppyFMPlayer();
        };

        function initSloppyFMPlayer() {
            var container = document.getElementById('sloppyfmYTPlayer');
            if (!container || sloppyfmPlayer) return;

            sloppyfmPlayer = new YT.Player('sloppyfmYTPlayer', {
                height: '1',
                width: '1',
                playerVars: {
                    autoplay: 0,
                    controls: 0,
                    disablekb: 1,
                    fs: 0,
                    modestbranding: 1,
                    playsinline: 1
                },
                events: {
                    onReady: onSloppyFMReady,
                    onStateChange: onSloppyFMStateChange,
                    onError: onSloppyFMError
                }
            });
        }

        function onSloppyFMReady(event) {
            sloppyfmReady = true;
            sloppyfmPlayer.setVolume(sloppyfmVolume);
            loadSloppyFMQueue();
            syncSloppyFMState();
            setupSloppyFMRealtime();
        }

        // Set up realtime channel for SloppyFM sync
        function setupSloppyFMRealtime() {
            if (sloppyfmChannel) {
                supabase.removeChannel(sloppyfmChannel);
            }

            sloppyfmChannel = supabase.channel('sloppyfm-radio', {
                config: { broadcast: { self: false } }
            });

            sloppyfmChannel.on('broadcast', { event: 'track_change' }, function(msg) {
                var payload = msg.payload;
                if (payload && payload.youtube_id && sloppyfmReady && sloppyfmPlayer) {
                    // Calculate seek position from started_at
                    var startedAt = new Date(payload.started_at).getTime();
                    var elapsed = Math.floor((Date.now() - startedAt) / 1000);

                    sloppyfmCurrentTrack = payload;
                    sloppyfmPlayer.loadVideoById({
                        videoId: payload.youtube_id,
                        startSeconds: Math.max(0, elapsed)
                    });
                    updateSloppyFMUI();
                    loadSloppyFMQueue(); // Refresh playlist
                }
            });

            sloppyfmChannel.on('broadcast', { event: 'queue_update' }, function() {
                loadSloppyFMQueue();
            });

            sloppyfmChannel.subscribe();
        }

        function onSloppyFMStateChange(event) {
            if (event.data === YT.PlayerState.PLAYING) {
                sloppyfmIsPlaying = true;
                sloppyfmStartVisualizer();
                updateSloppyFMUI();
            } else if (event.data === YT.PlayerState.PAUSED || event.data === YT.PlayerState.ENDED) {
                sloppyfmIsPlaying = false;
                stopSloppyFMVisualizer();
                updateSloppyFMUI();
                if (event.data === YT.PlayerState.ENDED) {
                    sloppyfmNext();
                }
            }
        }

        function onSloppyFMError(event) {
            console.error('[SloppyFM] YouTube error:', event.data);
            showToast('Track unavailable, skipping...', 'warning');
            setTimeout(sloppyfmNext, 1000);
        }

        // Load queue from Supabase
        async function loadSloppyFMQueue() {
            var result = await supabase
                .from('sloppygram_radio')
                .select('*')
                .order('created_at', { ascending: true })
                .limit(50);

            if (result.data && result.data.length > 0) {
                sloppyfmQueue = result.data;
            } else {
                // Use defaults if queue is empty
                sloppyfmQueue = sloppyfmDefaultTracks.map(function(t, i) {
                    return { id: 'default-' + i, ...t };
                });
            }
            sloppyfmRenderPlaylist();
        }

        // Sync playback state from Supabase
        async function syncSloppyFMState() {
            var result = await supabase
                .from('sloppygram_radio')
                .select('*')
                .eq('is_playing', true)
                .limit(1)
                .single();

            if (result.data && result.data.started_at) {
                var track = result.data;
                var startedAt = new Date(track.started_at).getTime();
                var now = Date.now();
                var elapsed = Math.floor((now - startedAt) / 1000);

                // Find track in queue or use directly
                sloppyfmCurrentTrack = track;

                if (sloppyfmReady && sloppyfmPlayer) {
                    sloppyfmPlayer.loadVideoById({
                        videoId: track.youtube_id,
                        startSeconds: elapsed
                    });
                    updateSloppyFMTrackInfo();
                }
            }

            // Set up periodic sync
            if (!sloppyfmSyncInterval) {
                sloppyfmSyncInterval = setInterval(syncSloppyFMState, 30000); // Sync every 30s
            }
        }

        // Broadcast current track to all users
        async function broadcastSloppyFMTrack(track) {
            if (!currentUser) return;

            var startedAt = new Date().toISOString();

            // Clear any existing playing tracks
            await supabase
                .from('sloppygram_radio')
                .update({ is_playing: false })
                .eq('is_playing', true);

            // Set new playing track
            if (track.id && !String(track.id).startsWith('default-')) {
                await supabase
                    .from('sloppygram_radio')
                    .update({ is_playing: true, started_at: startedAt })
                    .eq('id', track.id);
            } else {
                // Insert new track for defaults
                await supabase
                    .from('sloppygram_radio')
                    .insert({
                        youtube_id: track.youtube_id,
                        title: track.title,
                        artist: track.artist,
                        duration: track.duration || 0,
                        added_by: profile.username,
                        started_at: startedAt,
                        is_playing: true,
                        user_id: currentUser.id
                    });
            }

            // Send realtime broadcast to sync all clients
            if (sloppyfmChannel) {
                sloppyfmChannel.send({
                    type: 'broadcast',
                    event: 'track_change',
                    payload: {
                        youtube_id: track.youtube_id,
                        title: track.title,
                        artist: track.artist,
                        started_at: startedAt
                    }
                });
            }
        }

        window.toggleSloppyFM = function() {
            var widget = document.getElementById('sloppyfmWidget');
            var toggle = document.getElementById('sloppyfmToggle');
            if (widget.classList.contains('visible')) {
                widget.classList.remove('visible');
                toggle.classList.remove('hidden');
            } else {
                widget.classList.add('visible');
                toggle.classList.add('hidden');
                // Load YouTube API on first open
                if (!sloppyfmReady) loadYouTubeAPI();
                sloppyfmRenderPlaylist();
            }
        };

        function sloppyfmRenderPlaylist() {
            var playlist = document.getElementById('sloppyfmPlaylist');
            if (!playlist) return;
            var tracks = sloppyfmQueue.length > 0 ? sloppyfmQueue : sloppyfmDefaultTracks;
            playlist.innerHTML = tracks.map(function(track, idx) {
                var isActive = sloppyfmCurrentTrack && sloppyfmCurrentTrack.youtube_id === track.youtube_id;
                var activeClass = isActive ? 'active' : '';
                return '<div class="sloppyfm-track ' + activeClass + '" onclick="sloppyfmSelectTrack(' + idx + ')">' +
                    (idx + 1) + '. ' + escapeHtml(track.title) +
                    '<span class="sloppyfm-genre">[' + escapeHtml(track.artist || 'Unknown') + ']</span></div>';
            }).join('');
        }

        function updateSloppyFMUI() {
            var playBtn = document.getElementById('sloppyfmPlayBtn');
            if (playBtn) {
                playBtn.textContent = sloppyfmIsPlaying ? 'â¸' : 'â–¶';
                if (sloppyfmIsPlaying) playBtn.classList.add('playing');
                else playBtn.classList.remove('playing');
            }
            sloppyfmRenderPlaylist();
        }

        function updateSloppyFMTrackInfo() {
            if (!sloppyfmCurrentTrack) return;
            var nameEl = document.getElementById('sloppyfmTrackName');
            if (nameEl) nameEl.textContent = sloppyfmCurrentTrack.title + ' - ' + (sloppyfmCurrentTrack.artist || 'Radio');
        }

        window.sloppyfmSelectTrack = function(idx) {
            var tracks = sloppyfmQueue.length > 0 ? sloppyfmQueue : sloppyfmDefaultTracks;
            if (idx < 0 || idx >= tracks.length) return;
            sloppyfmCurrentTrack = tracks[idx];
            if (sloppyfmReady && sloppyfmPlayer) {
                sloppyfmPlayer.loadVideoById(sloppyfmCurrentTrack.youtube_id);
                broadcastSloppyFMTrack(sloppyfmCurrentTrack);
            }
            updateSloppyFMTrackInfo();
            sloppyfmRenderPlaylist();
        };

        window.sloppyfmPlay = function() {
            if (!sloppyfmReady || !sloppyfmPlayer) {
                loadYouTubeAPI();
                return;
            }
            if (sloppyfmIsPlaying) {
                sloppyfmPlayer.pauseVideo();
            } else {
                if (!sloppyfmCurrentTrack) {
                    sloppyfmSelectTrack(0);
                } else {
                    sloppyfmPlayer.playVideo();
                }
            }
        };

        window.sloppyfmStop = function() {
            if (sloppyfmPlayer && sloppyfmReady) {
                sloppyfmPlayer.stopVideo();
            }
            sloppyfmIsPlaying = false;
            updateSloppyFMUI();
            stopSloppyFMVisualizer();
        };

        window.sloppyfmNext = function() {
            var tracks = sloppyfmQueue.length > 0 ? sloppyfmQueue : sloppyfmDefaultTracks;
            var currentIdx = tracks.findIndex(function(t) {
                return sloppyfmCurrentTrack && t.youtube_id === sloppyfmCurrentTrack.youtube_id;
            });
            var nextIdx = (currentIdx + 1) % tracks.length;
            sloppyfmSelectTrack(nextIdx);
        };

        window.sloppyfmPrev = function() {
            var tracks = sloppyfmQueue.length > 0 ? sloppyfmQueue : sloppyfmDefaultTracks;
            var currentIdx = tracks.findIndex(function(t) {
                return sloppyfmCurrentTrack && t.youtube_id === sloppyfmCurrentTrack.youtube_id;
            });
            var prevIdx = currentIdx <= 0 ? tracks.length - 1 : currentIdx - 1;
            sloppyfmSelectTrack(prevIdx);
        };

        window.sloppyfmShuffle = function() {
            var tracks = sloppyfmQueue.length > 0 ? sloppyfmQueue : sloppyfmDefaultTracks;
            var randomIdx = Math.floor(Math.random() * tracks.length);
            sloppyfmSelectTrack(randomIdx);
            showToast('Shuffled to: ' + tracks[randomIdx].title);
        };

        window.sloppyfmSetVolume = function(val) {
            sloppyfmVolume = parseInt(val);
            if (sloppyfmPlayer && sloppyfmReady) {
                sloppyfmPlayer.setVolume(sloppyfmVolume);
            }
        };

        // Add track from YouTube URL or ID
        window.sloppyfmAddTrack = async function() {
            var input = document.getElementById('sloppyfmUrlInput');
            if (!input) return;
            var val = input.value.trim();
            if (!val) return;

            // Extract YouTube video ID from various URL formats
            var videoId = null;
            var patterns = [
                /(?:youtube\.com\/watch\?v=|youtu\.be\/|youtube\.com\/embed\/|youtube\.com\/v\/)([a-zA-Z0-9_-]{11})/,
                /^([a-zA-Z0-9_-]{11})$/
            ];
            for (var i = 0; i < patterns.length; i++) {
                var match = val.match(patterns[i]);
                if (match) {
                    videoId = match[1];
                    break;
                }
            }

            if (!videoId) {
                showToast('Invalid YouTube URL or ID', 'error');
                return;
            }

            input.disabled = true;
            var btn = input.nextElementSibling;
            if (btn) btn.disabled = true;

            try {
                // Try to get video title via oEmbed
                var title = 'Unknown Track';
                var artist = profile.username;
                try {
                    var oembedUrl = 'https://www.youtube.com/oembed?url=https://www.youtube.com/watch?v=' + videoId + '&format=json';
                    var response = await fetch(oembedUrl);
                    if (response.ok) {
                        var data = await response.json();
                        if (data.title) {
                            title = data.title;
                            if (data.author_name) artist = data.author_name;
                        }
                    }
                } catch(e) {
                    console.log('oEmbed fetch failed, using default title');
                }

                // Insert into sloppygram_radio
                var result = await supabase.from('sloppygram_radio').insert({
                    youtube_id: videoId,
                    title: title,
                    artist: artist,
                    duration: 0,
                    added_by: profile.username,
                    is_playing: false,
                    user_id: (currentUser && currentUser.id) ? currentUser.id : null
                });

                if (result.error) {
                    showToast('Failed to add track: ' + result.error.message, 'error');
                } else {
                    showToast('Added: ' + title, 'success');
                    input.value = '';
                    await loadSloppyFMQueue(); // Refresh playlist
                    // Auto-scroll playlist to show newly added track
                    var playlist = document.getElementById('sloppyfmPlaylist');
                    if (playlist) {
                        playlist.scrollTop = playlist.scrollHeight;
                    }
                    // Broadcast queue update to other clients
                    if (sloppyfmChannel) {
                        sloppyfmChannel.send({
                            type: 'broadcast',
                            event: 'queue_update',
                            payload: {}
                        });
                    }
                }
            } catch(e) {
                showToast('Error adding track', 'error');
                console.error('sloppyfmAddTrack error:', e);
            } finally {
                input.disabled = false;
                if (btn) btn.disabled = false;
            }
        };

        // SloppyFM visualizer
        var sloppyfmCache = { bars: null, timeEl: null, lastBarClasses: [] };

        function sloppyfmStartVisualizer() {
            if (sloppyfmVisualizerInterval) clearInterval(sloppyfmVisualizerInterval);
            if (!sloppyfmCache.bars) {
                sloppyfmCache.bars = Array.from(document.querySelectorAll('.sloppyfm-bar'));
                sloppyfmCache.lastBarClasses = sloppyfmCache.bars.map(function() { return ''; });
            }
            var bars = sloppyfmCache.bars;
            var lastClasses = sloppyfmCache.lastBarClasses;

            sloppyfmVisualizerInterval = setInterval(function() {
                if (!sloppyfmIsPlaying) return;
                for (var i = 0; i < bars.length; i++) {
                    var height = Math.random() * 18 + 2;
                    bars[i].style.height = height + 'px';
                    var newClass = height > 15 ? 'high' : (height > 10 ? 'mid' : '');
                    if (lastClasses[i] !== newClass) {
                        bars[i].className = 'sloppyfm-bar' + (newClass ? ' ' + newClass : '');
                        lastClasses[i] = newClass;
                    }
                }
            }, 100);

            // Update time display
            sloppyfmUpdateTime();
        }

        function stopSloppyFMVisualizer() {
            if (sloppyfmVisualizerInterval) {
                clearInterval(sloppyfmVisualizerInterval);
                sloppyfmVisualizerInterval = null;
            }
            var bars = document.querySelectorAll('.sloppyfm-bar');
            bars.forEach(function(bar) {
                bar.style.height = '2px';
                bar.className = 'sloppyfm-bar';
            });
        }

        function sloppyfmUpdateTime() {
            if (!sloppyfmIsPlaying || !sloppyfmPlayer || !sloppyfmReady) return;
            try {
                var currentTime = sloppyfmPlayer.getCurrentTime() || 0;
                var mins = Math.floor(currentTime / 60);
                var secs = Math.floor(currentTime % 60);
                if (!sloppyfmCache.timeEl) {
                    sloppyfmCache.timeEl = document.getElementById('sloppyfmTime');
                }
                if (sloppyfmCache.timeEl) {
                    sloppyfmCache.timeEl.textContent = (mins < 10 ? '0' : '') + mins + ':' + (secs < 10 ? '0' : '') + secs;
                }
            } catch(e) {}
            setTimeout(sloppyfmUpdateTime, 1000);
        }

        // Make SloppyFM widget draggable
        (function() {
            var widget = document.getElementById('sloppyfmWidget');
            var titlebar = document.getElementById('sloppyfmTitlebar');
            if (!widget || !titlebar) return;

            var isDragging = false;
            var offsetX = 0, offsetY = 0;

            titlebar.addEventListener('mousedown', function(e) {
                if (e.target.classList.contains('sloppyfm-close')) return;
                isDragging = true;
                offsetX = e.clientX - widget.offsetLeft;
                offsetY = e.clientY - widget.offsetTop;
                widget.style.transition = 'none';
            });

            document.addEventListener('mousemove', function(e) {
                if (!isDragging) return;
                var newX = e.clientX - offsetX;
                var newY = e.clientY - offsetY;
                // Keep within viewport
                newX = Math.max(0, Math.min(newX, window.innerWidth - widget.offsetWidth));
                newY = Math.max(0, Math.min(newY, window.innerHeight - widget.offsetHeight));
                widget.style.left = newX + 'px';
                widget.style.top = newY + 'px';
                widget.style.right = 'auto';
                widget.style.bottom = 'auto';
            });

            document.addEventListener('mouseup', function() {
                isDragging = false;
            });

            // Touch support for mobile
            titlebar.addEventListener('touchstart', function(e) {
                if (e.target.classList.contains('sloppyfm-close')) return;
                var touch = e.touches[0];
                isDragging = true;
                offsetX = touch.clientX - widget.offsetLeft;
                offsetY = touch.clientY - widget.offsetTop;
            });

            document.addEventListener('touchmove', function(e) {
                if (!isDragging) return;
                var touch = e.touches[0];
                var newX = touch.clientX - offsetX;
                var newY = touch.clientY - offsetY;
                newX = Math.max(0, Math.min(newX, window.innerWidth - widget.offsetWidth));
                newY = Math.max(0, Math.min(newY, window.innerHeight - widget.offsetHeight));
                widget.style.left = newX + 'px';
                widget.style.top = newY + 'px';
                widget.style.right = 'auto';
                widget.style.bottom = 'auto';
            });

            document.addEventListener('touchend', function() {
                isDragging = false;
            });
        })();

        // === GHOST RADAR (optimized) ===
        var ghostRadarUsers = [];
        var ghostRadarInterval = null;
        var ghostRadarCache = { countEl: null, blipsEl: null, lastCount: -1 };

        function updateGhostRadar(presenceState) {
            var users = [];
            var seen = {};
            Object.values(presenceState).forEach(function(presences) {
                presences.forEach(function(p) {
                    if (!seen[p.username]) {
                        seen[p.username] = true;
                        users.push(p);
                    }
                });
            });
            ghostRadarUsers = users;
            renderGhostRadar();
        }

        function renderGhostRadar() {
            // Cache DOM references
            if (!ghostRadarCache.countEl) {
                ghostRadarCache.countEl = document.getElementById('ghostRadarCount');
                ghostRadarCache.blipsEl = document.getElementById('ghostRadarBlips');
            }
            var countEl = ghostRadarCache.countEl;
            var blipsEl = ghostRadarCache.blipsEl;
            if (!countEl || !blipsEl) return;

            var ghostCount = ghostRadarUsers.length;

            // Only update if count changed
            if (ghostCount === ghostRadarCache.lastCount) return;
            ghostRadarCache.lastCount = ghostCount;

            countEl.textContent = ghostCount + ' lurking';

            // Create blips for each ghost (max 8 visible)
            var maxBlips = Math.min(ghostCount, 8);
            var blipsHtml = '';
            for (var i = 0; i < maxBlips; i++) {
                var angle = (i / maxBlips) * Math.PI * 2 + Math.random() * 0.5;
                var radius = 15 + Math.random() * 20;
                var x = 40 + Math.cos(angle) * radius - 3;
                var y = 40 + Math.sin(angle) * radius - 3;
                blipsHtml += '<div class="ghost-radar-blip" style="left:' + x + 'px;top:' + y + 'px;animation-delay:' + (i * 0.3) + 's;"></div>';
            }
            blipsEl.innerHTML = blipsHtml;
        }

        window.ghostRadarPing = function() {
            var ghostCount = ghostRadarUsers.length;
            if (ghostCount === 0) {
                showToast('ðŸ‘» No ghosts detected...', 'info');
            } else if (ghostCount === 1) {
                showToast('ðŸ‘» 1 silent lurker detected!', 'info');
            } else {
                showToast('ðŸ‘» ' + ghostCount + ' ghosts in the shadows!', 'info');
            }
        };

        // Start ghost radar updates (reduced frequency)
        ghostRadarInterval = setInterval(function() {
            renderGhostRadar();
        }, 5000);

        // === RATE LIMITING ===
        const rateLimits = {
            message: { limit: 5, window: 10000 },    // 5 messages per 10 seconds
            post: { limit: 3, window: 60000 },       // 3 posts per minute
            vote: { limit: 20, window: 60000 },      // 20 votes per minute
            comment: { limit: 10, window: 60000 },   // 10 comments per minute
            drawing: { limit: 3, window: 30000 }     // 3 drawings per 30 seconds
        };
        const actionTimestamps = {};  // { actionType: [timestamps] }

        function checkRateLimit(actionType) {
            const config = rateLimits[actionType];
            if (!config) return { allowed: true };

            const now = Date.now();
            const timestamps = actionTimestamps[actionType] || [];

            // Remove expired timestamps
            const validTimestamps = timestamps.filter(t => now - t < config.window);
            actionTimestamps[actionType] = validTimestamps;

            if (validTimestamps.length >= config.limit) {
                const oldestValid = validTimestamps[0];
                const waitTime = Math.ceil((config.window - (now - oldestValid)) / 1000);
                return { allowed: false, waitTime, message: `Rate limited. Wait ${waitTime}s` };
            }

            return { allowed: true };
        }

        function recordAction(actionType) {
            if (!actionTimestamps[actionType]) {
                actionTimestamps[actionType] = [];
            }
            actionTimestamps[actionType].push(Date.now());
        }

        // === CANVAS UNDO/REDO ===
        const MAX_HISTORY = 20;
        let canvasHistory = [];
        let canvasHistoryIndex = -1;

        function saveCanvasState() {
            const canvas = document.getElementById('drawingCanvas');
            if (!canvas) return;

            // Remove any states after current index (for redo overwrite)
            canvasHistory = canvasHistory.slice(0, canvasHistoryIndex + 1);

            // Save current state
            canvasHistory.push(canvas.toDataURL());

            // Limit history size
            if (canvasHistory.length > MAX_HISTORY) {
                canvasHistory.shift();
            } else {
                canvasHistoryIndex++;
            }

            updateUndoRedoButtons();
        }

        function undoCanvas() {
            if (canvasHistoryIndex <= 0) return;
            canvasHistoryIndex--;
            restoreCanvasState(canvasHistory[canvasHistoryIndex]);
            updateUndoRedoButtons();
        }

        function redoCanvas() {
            if (canvasHistoryIndex >= canvasHistory.length - 1) return;
            canvasHistoryIndex++;
            restoreCanvasState(canvasHistory[canvasHistoryIndex]);
            updateUndoRedoButtons();
        }

        function restoreCanvasState(dataUrl) {
            const canvas = document.getElementById('drawingCanvas');
            if (!canvas || !dataUrl) return;

            const img = new Image();
            img.onload = function() {
                drawingCtx.clearRect(0, 0, canvas.width, canvas.height);
                drawingCtx.drawImage(img, 0, 0);
            };
            img.src = dataUrl;
        }

        function updateUndoRedoButtons() {
            const undoBtn = document.getElementById('undoBtn');
            const redoBtn = document.getElementById('redoBtn');
            if (undoBtn) undoBtn.disabled = canvasHistoryIndex <= 0;
            if (redoBtn) redoBtn.disabled = canvasHistoryIndex >= canvasHistory.length - 1;
        }

        function resetCanvasHistory() {
            canvasHistory = [];
            canvasHistoryIndex = -1;
            saveCanvasState(); // Save initial blank state
        }

        // Expose undo/redo globally
        window.undoCanvas = undoCanvas;
        window.redoCanvas = redoCanvas;

        // === PROFILE CARD SYSTEM ===
        let profileCardTimeout = null;

        async function getUserStats(username) {
            try {
                // Fetch user stats and avatar from database in parallel
                const [messagesRes, postsRes, doodlesRes, manifestosRes, avatarMsgRes, avatarPostRes] = await Promise.all([
                    supabase.from('sloppygram_messages').select('id', { count: 'exact', head: true }).eq('username', username),
                    supabase.from('sloppygram_posts').select('id, likes_count', { count: 'exact' }).eq('username', username),
                    supabase.from('sloppygram_messages').select('id', { count: 'exact', head: true }).eq('username', username).eq('message_type', 'drawing'),
                    supabase.from('sloppygram_manifestos').select('id', { count: 'exact', head: true }).eq('username', username),
                    // Fetch most recent message with avatar info
                    supabase.from('sloppygram_messages').select('avatar, avatar_url').eq('username', username).order('created_at', { ascending: false }).limit(1),
                    // Fetch most recent post with avatar info
                    supabase.from('sloppygram_posts').select('avatar, avatar_url').eq('username', username).order('created_at', { ascending: false }).limit(1)
                ]);

                const totalPosts = postsRes.count || 0;
                const totalMessages = messagesRes.count || 0;
                const totalDoodles = doodlesRes.count || 0;
                const totalManifestos = manifestosRes.count || 0;
                const totalLikes = (postsRes.data || []).reduce((sum, p) => sum + (p.likes_count || 0), 0);

                // Fetch vote totals for user's posts
                let totalUpvotes = 0;
                let totalDownvotes = 0;
                const userPostIds = (postsRes.data || []).map(p => p.id);
                if (userPostIds.length > 0) {
                    const { data: votesData } = await supabase
                        .from('sloppygram_post_likes')
                        .select('vote_type')
                        .in('post_id', userPostIds);

                    (votesData || []).forEach(v => {
                        if (v.vote_type > 0) totalUpvotes += v.vote_type;
                        else if (v.vote_type < 0) totalDownvotes += Math.abs(v.vote_type);
                    });
                }

                // Get avatar from most recent activity
                let avatar = 'ðŸ‘¤';
                let avatarUrl = null;

                const latestMsg = (avatarMsgRes.data && avatarMsgRes.data[0]) ? avatarMsgRes.data[0] : null;
                const latestPost = (avatarPostRes.data && avatarPostRes.data[0]) ? avatarPostRes.data[0] : null;

                if (latestMsg) {
                    avatar = latestMsg.avatar || avatar;
                    avatarUrl = latestMsg.avatar_url || avatarUrl;
                }
                if (latestPost) {
                    avatar = latestPost.avatar || avatar;
                    avatarUrl = latestPost.avatar_url || avatarUrl;
                }

                const stats = {
                    messages: totalMessages,
                    posts: totalPosts,
                    doodles: totalDoodles,
                    manifestos: totalManifestos,
                    likes: totalLikes,
                    upvotes: totalUpvotes,
                    downvotes: totalDownvotes,
                    avatar: avatar,
                    avatarUrl: avatarUrl
                };

                return stats;
            } catch (err) {
                console.error('Error fetching user stats:', err);
                return {
                    messages: 0,
                    posts: 0,
                    doodles: 0,
                    manifestos: 0,
                    likes: 0,
                    upvotes: 0,
                    downvotes: 0,
                    avatar: 'ðŸ‘¤',
                    avatarUrl: null
                };
            }
        }

        // Kept for backwards compatibility but now uses cached data from getUserStats
        async function findUserInfo(username) {
            const stats = await getUserStats(username);
            return { avatar: stats.avatar, avatarUrl: stats.avatarUrl };
        }

        async function showProfileCard(username, event) {
            const card = document.getElementById('profileCard');
            if (!card) return;

            // Clear any pending hide timeout
            if (profileCardTimeout) {
                clearTimeout(profileCardTimeout);
                profileCardTimeout = null;
            }

            // Position card near click
            const rect = event.target.getBoundingClientRect();
            const cardWidth = 250;
            const cardHeight = 180;

            let left = rect.left;
            let top = rect.bottom + 8;

            // Keep card within viewport
            if (left + cardWidth > window.innerWidth) {
                left = window.innerWidth - cardWidth - 16;
            }
            if (top + cardHeight > window.innerHeight) {
                top = rect.top - cardHeight - 8;
            }

            card.style.left = Math.max(8, left) + 'px';
            card.style.top = Math.max(8, top) + 'px';

            // Show loading state
            card.innerHTML = '<div class="profile-card-loading">Loading...</div>';
            card.classList.add('visible');

            try {
                // Fetch both sloppygram stats and cross-app stats in parallel
                const [stats, gameScores] = await Promise.all([
                    getUserStats(username),
                    getCrossAppStats(username)
                ]);

                // Avatar is now included in stats from database
                const safeAvatarUrl = sanitizeUrl(stats.avatarUrl);
                const avatarContent = safeAvatarUrl
                    ? `<img src="${safeAvatarUrl}" alt="${escapeHtml(username)}">`
                    : (stats.avatar || 'ðŸ‘¤');

                // Build game scores HTML if any exist
                let gameScoresHtml = '';
                if (gameScores && gameScores.length > 0) {
                    const scoresHtml = gameScores.map(function(g) {
                        return '<div class="profile-game-score"><span class="game-name">' + escapeHtml(g.game) + ':</span><span class="game-score">' + g.score.toLocaleString() + '</span></div>';
                    }).join('');
                    gameScoresHtml = '<div class="profile-crossapp"><div class="profile-crossapp-title">ðŸŽ® Game High Scores</div><div class="profile-game-scores">' + scoresHtml + '</div></div>';
                }

                card.innerHTML = `
                    <div class="profile-card-header">
                        <div class="profile-card-avatar">${avatarContent}</div>
                        <div class="profile-card-name">${escapeHtml(username)}</div>
                    </div>
                    <div class="profile-card-stats">
                        <div class="profile-card-stat">
                            <div class="profile-card-stat-value">${stats.messages}</div>
                            <div class="profile-card-stat-label">Messages</div>
                        </div>
                        <div class="profile-card-stat">
                            <div class="profile-card-stat-value">${stats.posts}</div>
                            <div class="profile-card-stat-label">Posts</div>
                        </div>
                        <div class="profile-card-stat">
                            <div class="profile-card-stat-value">${stats.doodles}</div>
                            <div class="profile-card-stat-label">Doodles</div>
                        </div>
                    </div>
                    <div class="profile-card-stats" style="margin-bottom:0;">
                        <div class="profile-card-stat">
                            <div class="profile-card-stat-value">${stats.manifestos}</div>
                            <div class="profile-card-stat-label">Manifestos</div>
                        </div>
                        <div class="profile-card-stat">
                            <div class="profile-card-stat-value" style="color: #4a9">â–²${stats.upvotes || 0}</div>
                            <div class="profile-card-stat-label">Upvotes</div>
                        </div>
                        <div class="profile-card-stat">
                            <div class="profile-card-stat-value" style="color: #c66">â–¼${stats.downvotes || 0}</div>
                            <div class="profile-card-stat-label">Downvotes</div>
                        </div>
                    </div>
                    ${gameScoresHtml}
                `;
            } catch (err) {
                console.error('Error loading profile:', err);
                card.innerHTML = '<div class="profile-card-loading">Could not load profile</div>';
            }
        }

        function hideProfileCard() {
            const card = document.getElementById('profileCard');
            if (card) {
                card.classList.remove('visible');
            }
        }

        function scheduleHideProfileCard() {
            profileCardTimeout = setTimeout(hideProfileCard, 300);
        }

        // Close profile card on click outside
        document.addEventListener('click', (e) => {
            const card = document.getElementById('profileCard');
            if (card && !card.contains(e.target) && !e.target.classList.contains('username-clickable')) {
                hideProfileCard();
            }
        });

        // Expose profile card functions
        window.showProfileCard = showProfileCard;
        window.hideProfileCard = hideProfileCard;

        // === LAZY LOADING OPTIMIZER ===
        let imageObserver = null;

        function initLazyLoading() {
            if (!('IntersectionObserver' in window)) {
                // Fallback: load all images immediately
                document.querySelectorAll('img[data-src]').forEach(img => {
                    img.src = img.dataset.src;
                });
                return;
            }

            imageObserver = new IntersectionObserver((entries, observer) => {
                entries.forEach(entry => {
                    if (entry.isIntersecting) {
                        const img = entry.target;
                        if (img.dataset.src) {
                            img.src = img.dataset.src;
                            img.removeAttribute('data-src');
                            img.classList.remove('loading');
                        }
                        observer.unobserve(img);
                    }
                });
            }, {
                rootMargin: '100px 0px', // Start loading 100px before visible
                threshold: 0.01
            });
        }

        function observeLazyImage(img) {
            if (imageObserver && img.dataset.src) {
                img.classList.add('loading');
                imageObserver.observe(img);
            }
        }

        function lazyLoadNewImages() {
            document.querySelectorAll('img[data-src]:not(.observed)').forEach(img => {
                img.classList.add('observed');
                observeLazyImage(img);
            });
        }

        // Initialize lazy loading on page load
        initLazyLoading();

        // Helper function to log AI events
        async function logAiEvent(eventType, entityType, entityId, metadata = {}) {
            if (!currentUser) return;
            try {
                await supabase.from('ai_events').insert({
                    event_type: eventType,
                    entity_type: entityType,
                    entity_id: entityId,
                    username: profile.username,
                    metadata: metadata,
                    user_id: currentUser.id
                });
            } catch (e) {
                console.error('Error logging AI event:', e);
            }
        }

        // Load saved profile
        const savedProfile = localStorage.getItem('sloppygram_profile');
        if (savedProfile) {
            profile = JSON.parse(savedProfile);
            // Restore status UI if one was saved
            if (profile.status) {
                setTimeout(() => {
                    const statusCurrent = document.getElementById('awayStatusCurrent');
                    const statusText = document.getElementById('currentStatusText');
                    if (statusCurrent && statusText) {
                        statusCurrent.style.display = 'flex';
                        statusText.textContent = profile.status;
                    }
                }, 100);
            }
        }

        // === TOAST NOTIFICATION SYSTEM ===
        const toastTimers = new Map(); // Track active toast timers for cleanup

        function showToast(message, type = 'info', duration = 4000) {
            const container = document.getElementById('toastContainer');
            if (!container) return;

            const icons = {
                success: 'âœ“',
                error: 'âœ•',
                warning: 'âš ',
                info: 'â„¹'
            };

            const toast = document.createElement('div');
            toast.className = `system-toast ${type}`;
            const toastId = 'toast_' + Date.now() + '_' + Math.random().toString(36).slice(2);
            toast.id = toastId;

            toast.innerHTML = `
                <span class="toast-icon">${icons[type] || icons.info}</span>
                <span class="toast-message">${escapeHtml(message)}</span>
                <button class="toast-close" onclick="dismissToast('${toastId}')">&times;</button>
            `;

            container.appendChild(toast);

            // Auto-dismiss after duration
            const timerId = setTimeout(() => {
                dismissToast(toastId);
            }, duration);

            toastTimers.set(toastId, timerId);

            return toastId;
        }

        window.dismissToast = function(toastId) {
            const toast = document.getElementById(toastId);
            if (!toast) return;

            // Clear the timer
            const timerId = toastTimers.get(toastId);
            if (timerId) {
                clearTimeout(timerId);
                toastTimers.delete(toastId);
            }

            // Animate out
            toast.classList.add('fade-out');
            setTimeout(() => {
                toast.remove();
            }, 300);
        };

        // Expose globally for use in other functions
        window.showToast = showToast;

        // === MEMORY LEAK PREVENTION ===
        let presenceChannel = null;
        let postsChannel = null;
        let globalSettingsChannel = null;

        function cleanupChannels() {
            console.log('Cleaning up Supabase channels...');
            if (realtimeChannel) {
                supabase.removeChannel(realtimeChannel);
                realtimeChannel = null;
            }
            if (presenceChannel) {
                supabase.removeChannel(presenceChannel);
                presenceChannel = null;
            }
            if (postsChannel) {
                supabase.removeChannel(postsChannel);
                postsChannel = null;
            }
            if (globalSettingsChannel) {
                supabase.removeChannel(globalSettingsChannel);
                globalSettingsChannel = null;
            }

            // Clear all toast timers
            toastTimers.forEach((timerId) => clearTimeout(timerId));
            toastTimers.clear();
        }

        // Cleanup on page unload
        window.addEventListener('beforeunload', cleanupChannels);
        window.addEventListener('pagehide', cleanupChannels);

        // Reboot System - glitchy reset with visual effect
        window.rebootSystem = async function() {
            // Create overlay
            const overlay = document.createElement('div');
            overlay.className = 'reboot-overlay';
            overlay.innerHTML = `
                <div class="reboot-text">[ SYSTEM REBOOT ]</div>
                <div class="reboot-progress">Flushing memory...</div>
                <div class="reboot-bar"><div class="reboot-bar-fill" style="width: 0%"></div></div>
            `;
            document.body.appendChild(overlay);

            const progressText = overlay.querySelector('.reboot-progress');
            const progressBar = overlay.querySelector('.reboot-bar-fill');

            const steps = [
                { text: 'Flushing message cache...', action: () => { seenMessageIds.clear(); } },
                { text: 'Clearing post memory...', action: () => { posts = []; postLikes = {}; postComments = {}; postReactions = {}; myReactions = {}; postVotes = {}; myPostVotes = {}; postTags = {}; } },
                { text: 'Purging doodle data...', action: () => { doodleVotes = {}; myDoodleVotes = {}; doodleComments = {}; doodleCommentThreads = {}; } },
                { text: 'Wiping manifesto state...', action: () => { manifestos = []; manifestoVotes = {}; myManifestoVotes = {}; manifestoReactions = {}; myManifestoReactions = {}; manifestoComments = {}; manifestoTags = {}; } },
                { text: 'Resetting vote matrices...', action: () => { messageVotes = {}; myMessageVotes = {}; commentVotes = {}; myCommentVotes = {}; } },
                { text: 'Clearing collab canvas...', action: () => { collabStrokes = []; if (collabCtx) collabCtx.clearRect(0, 0, collabCanvas.width, collabCanvas.height); } },
                { text: 'Disconnecting channels...', action: () => { cleanupChannels(); } },
                { text: 'Reinitializing system...', action: () => {} }
            ];

            for (let i = 0; i < steps.length; i++) {
                if (progressText) progressText.textContent = steps[i].text;
                if (progressBar && progressBar.style) progressBar.style.width = ((i + 1) / steps.length * 100) + '%';
                steps[i].action();
                await new Promise(r => setTimeout(r, 300));
            }

            // Final glitch effect
            if (progressText) progressText.textContent = '[ REBOOT COMPLETE ]';
            await new Promise(r => setTimeout(r, 500));

            // Remove overlay and reinitialize
            overlay.remove();

            // Reload fresh data
            await loadDoodleVotes();
            await loadMessageVotes();
            await loadCommentVotes();
            loadMessages();
            loadPosts();
            loadManifestos();
            loadDoodleLeaderboard();
            subscribeToMessages();
            subscribeToPostsAndComments();
            setupPresence();

            showToast('System rebooted successfully', 'success');
        };

        // Compatibility debugger - checks browser support for required features
        window.checkCompatibility = function() {
            var results = [];
            var passed = 0;
            var failed = 0;

            // Check for required features
            var checks = [
                { name: 'Promise', test: function() { return typeof Promise !== 'undefined'; } },
                { name: 'fetch API', test: function() { return typeof fetch !== 'undefined'; } },
                { name: 'localStorage', test: function() { return typeof localStorage !== 'undefined'; } },
                { name: 'IntersectionObserver', test: function() { return 'IntersectionObserver' in window; } },
                { name: 'Canvas 2D', test: function() { var c = document.createElement('canvas'); return !!(c.getContext && c.getContext('2d')); } },
                { name: 'Web Audio', test: function() { return !!(window.AudioContext || window.webkitAudioContext); } },
                { name: 'Clipboard API', test: function() { return !!(navigator.clipboard && navigator.clipboard.writeText); } },
                { name: 'CSS Variables', test: function() { return window.CSS && window.CSS.supports && window.CSS.supports('--test', '0'); } },
                { name: 'Flexbox', test: function() { return window.CSS && window.CSS.supports && window.CSS.supports('display', 'flex'); } },
                { name: 'Grid', test: function() { return window.CSS && window.CSS.supports && window.CSS.supports('display', 'grid'); } }
            ];

            for (var i = 0; i < checks.length; i++) {
                var check = checks[i];
                var supported = false;
                try {
                    supported = check.test();
                } catch (e) {
                    supported = false;
                }
                if (supported) {
                    passed++;
                    results.push('[âœ“] ' + check.name);
                } else {
                    failed++;
                    results.push('[âœ—] ' + check.name);
                }
            }

            var summary = '\n=== COMPATIBILITY REPORT ===\n' +
                results.join('\n') +
                '\n\nPassed: ' + passed + '/' + checks.length +
                (failed > 0 ? '\nWARNING: ' + failed + ' feature(s) not supported' : '\nAll features supported!');

            console.log(summary);
            showToast('Compatibility: ' + passed + '/' + checks.length + ' features OK', failed > 0 ? 'warning' : 'success');
            return { passed: passed, failed: failed, total: checks.length, details: results };
        };

        // Initialize
        async function init() {
            // Listen for auth state changes
            supabase.auth.onAuthStateChange((event, session) => {
                console.log('Auth state changed:', event);
                if (session) {
                    currentUser = session.user;
                }
            });

            // Auth - try to restore existing session first
            let { data: { session } } = await supabase.auth.getSession();
            if (!session) {
                console.log('No existing session, signing in anonymously...');
                const { data, error } = await supabase.auth.signInAnonymously();
                if (error) console.error('Auth error:', error);
                session = (data && data.session) ? data.session : null;
            } else {
                console.log('Restored existing session for user:', session.user ? session.user.id : 'unknown');
            }
            currentUser = (session && session.user) ? session.user : null;

            setupAvatarGrid();
            setupColorOptions();
            setupBrushColors();
            setupDrawingCanvas();
            loadMessageOpacity();
            loadThemeSettings();
            // Load saved sound settings
            const savedSounds = localStorage.getItem('sloppygram_sounds');
            if (savedSounds) {
                soundSettings = JSON.parse(savedSounds);
            }
            await loadDoodleVotes();
            await loadMessageVotes();
            await loadCommentVotes();
            loadMessages();
            subscribeToMessages();
            subscribeToPostsAndComments();
            setupPresence();
            applyCustomBackground();

            // Load and subscribe to global settings (backgrounds, sounds, avatars)
            subscribeToGlobalSettings();
            loadGlobalSettings();

            // Random visitor count for 90s vibes
            document.getElementById('visitorCount').textContent = Math.floor(10000 + Math.random() * 90000);

            // Auto-resize textarea
            const input = document.getElementById('messageInput');
            input.addEventListener('input', () => {
                input.style.height = 'auto';
                input.style.height = Math.min(input.scrollHeight, 100) + 'px';
            });

            // Enter to send
            input.addEventListener('keydown', (e) => {
                if (e.key === 'Enter' && !e.shiftKey) {
                    e.preventDefault();
                    sendMessage();
                }
            });

            // Infinite scroll for messages (load older messages when scrolling down)
            const messagesContainer = document.getElementById('messagesContainer');
            messagesContainer.addEventListener('scroll', () => {
                const { scrollTop, scrollHeight, clientHeight } = messagesContainer;
                // Load more when near bottom (older messages are at bottom)
                if (scrollHeight - scrollTop - clientHeight < 200) {
                    loadMessages(true);
                }
            });

            // Infinite scroll for posts
            const postsContainer = document.getElementById('postsContainer');
            postsContainer.addEventListener('scroll', () => {
                const { scrollTop, scrollHeight, clientHeight } = postsContainer;
                if (scrollHeight - scrollTop - clientHeight < 200) {
                    loadMorePosts();
                }
            });
        }

        // Load more posts for infinite scroll
        async function loadMorePosts() {
            if (postsLoading || !postsHasMore) return;
            postsLoading = true;

            const container = document.getElementById('postsContainer');
            const loader = document.createElement('div');
            loader.className = 'loading-indicator';
            loader.id = 'postsLoader';
            loader.textContent = 'Loading more posts...';
            container.appendChild(loader);

            const from = postsPage * PAGE_SIZE;
            const to = from + PAGE_SIZE - 1;

            const { data, error } = await supabase
                .from('sloppygram_posts')
                .select('*')
                .order('created_at', { ascending: false })
                .range(from, to);

            var postsLoaderEl = document.getElementById('postsLoader');
            if (postsLoaderEl) postsLoaderEl.remove();
            postsLoading = false;

            if (error || !data) return;

            postsHasMore = data.length === PAGE_SIZE;
            postsPage++;

            // Add new posts to existing array and re-render
            posts = [...posts, ...data];

            // Need to reload related data for new posts
            const newPostIds = data.map(p => p.id);
            if (newPostIds.length > 0) {
                await loadPostRelatedData(newPostIds);
            }

            renderPosts();
        }

        // Load related data (votes, comments, etc.) for specific post IDs
        async function loadPostRelatedData(postIds) {
            const [votesResult, commentsResult, reactionsResult, tagsResult, threadsResult] = await Promise.all([
                supabase.from('sloppygram_post_likes').select('post_id, username, vote_type').in('post_id', postIds),
                supabase.from('sloppygram_post_comments').select('*').in('post_id', postIds).order('created_at', { ascending: true }),
                supabase.from('sloppygram_post_reactions').select('*').in('post_id', postIds),
                supabase.from('sloppygram_post_tags').select('*').in('post_id', postIds),
                supabase.from('sloppygram_comment_threads').select('*').eq('comment_type', 'post').in('post_id', postIds)
            ]);

            // Process and merge votes
            (votesResult.data || []).forEach(vote => {
                postVotes[vote.post_id] = (postVotes[vote.post_id] || 0) + (vote.vote_type || 1);
                if (vote.username === profile.username) {
                    myPostVotes[vote.post_id] = vote.vote_type || 1;
                }
            });

            // Process comments
            (commentsResult.data || []).forEach(comment => {
                if (!postComments[comment.post_id]) postComments[comment.post_id] = [];
                postComments[comment.post_id].push(comment);
            });

            // Process reactions
            (reactionsResult.data || []).forEach(r => {
                if (!postReactions[r.post_id]) postReactions[r.post_id] = {};
                postReactions[r.post_id][r.emoji] = (postReactions[r.post_id][r.emoji] || 0) + 1;
                if (r.username === profile.username) {
                    if (!myReactions[r.post_id]) myReactions[r.post_id] = new Set();
                    myReactions[r.post_id].add(r.emoji);
                }
            });

            // Process tags
            (tagsResult.data || []).forEach(t => {
                if (!postTags[t.post_id]) postTags[t.post_id] = [];
                postTags[t.post_id].push({ tag: t.tag, parent_tag: t.parent_tag });
            });

            // Process comment threads
            (threadsResult.data || []).forEach(t => {
                commentThreads[t.comment_id] = t.parent_comment_id;
            });
        }

        // Presence for online users
        function setupPresence() {
            // Clean up existing presence channel if any
            if (presenceChannel) {
                supabase.removeChannel(presenceChannel);
            }

            presenceChannel = supabase.channel('sloppygram_presence', {
                config: {
                    presence: { key: (currentUser && currentUser.id) ? currentUser.id : 'anon_' + Math.random() }
                }
            });

            presenceChannel
                .on('presence', { event: 'sync' }, () => {
                    const state = presenceChannel.presenceState();
                    updateOnlineUsers(state);
                    updateGhostRadar(state);
                })
                .on('presence', { event: 'join' }, ({ key, newPresences }) => {
                    var joinUser = (newPresences && newPresences[0] && newPresences[0].username) ? newPresences[0].username : 'Someone';
                    addToFeed(joinUser, 'joined the chat');
                })
                .on('presence', { event: 'leave' }, ({ key, leftPresences }) => {
                    var leftUser = (leftPresences && leftPresences[0] && leftPresences[0].username) ? leftPresences[0].username : 'Someone';
                    addToFeed(leftUser, 'left the chat');
                })
                .subscribe(async (status) => {
                    if (status === 'SUBSCRIBED') {
                        await presenceChannel.track({
                            username: profile.username,
                            avatar: profile.avatar,
                            avatarUrl: profile.avatarUrl || null,
                            color: profile.color,
                            status: profile.status || '',
                            online_at: new Date().toISOString()
                        });
                    }
                });
        }

        // Update presence with new status
        async function updatePresenceStatus() {
            if (presenceChannel) {
                await presenceChannel.track({
                    username: profile.username,
                    avatar: profile.avatar,
                    avatarUrl: profile.avatarUrl || null,
                    color: profile.color,
                    status: profile.status || '',
                    online_at: new Date().toISOString()
                });
            }
        }

        window.setAwayStatus = function() {
            const input = document.getElementById('awayStatusInput');
            if (!input) return;
            const status = input.value.trim();
            if (status) {
                profile.status = status;
                localStorage.setItem('sloppygram_profile', JSON.stringify(profile));
                updatePresenceStatus();
                // Update UI
                var statusCurrent = document.getElementById('awayStatusCurrent');
                var statusText = document.getElementById('currentStatusText');
                if (statusCurrent) statusCurrent.style.display = 'flex';
                if (statusText) statusText.textContent = status;
                input.value = '';
                showToast('Status set: ' + status);
            }
        };

        window.clearAwayStatus = function() {
            profile.status = '';
            localStorage.setItem('sloppygram_profile', JSON.stringify(profile));
            updatePresenceStatus();
            // Update UI
            var statusCurrent = document.getElementById('awayStatusCurrent');
            var statusText = document.getElementById('currentStatusText');
            var statusInput = document.getElementById('awayStatusInput');
            if (statusCurrent) statusCurrent.style.display = 'none';
            if (statusText) statusText.textContent = '';
            if (statusInput) statusInput.value = '';
            showToast('Status cleared');
        };

        function updateOnlineUsers(state) {
            const userList = document.getElementById('userList');
            const users = [];

            // Add real users
            Object.values(state).forEach(presences => {
                presences.forEach(p => {
                    if (!users.find(u => u.username === p.username)) {
                        users.push(p);
                    }
                });
            });

            userList.innerHTML = users.map(u => {
                const safeAvatarUrl = sanitizeUrl(u.avatarUrl);
                const avatarContent = safeAvatarUrl
                    ? `<img src="${safeAvatarUrl}" style="width:24px;height:24px;border-radius:50%;object-fit:cover;">`
                    : u.avatar;
                const statusHtml = u.status
                    ? `<span class="user-away-status">${escapeHtml(u.status)}</span>`
                    : '';
                return `
                <li class="user-item">
                    <span class="user-status"></span>
                    <span class="user-avatar">${avatarContent}</span>
                    <div class="user-item-content">
                        <span class="user-name" style="color: ${u.color || 'var(--accent-light)'}">${escapeHtml(u.username)}</span>
                        ${statusHtml}
                    </div>
                </li>
            `}).join('');
        }

        function addToFeed(user, action) {
            const feed = document.getElementById('publicFeed');
            const time = new Date().toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });

            const item = document.createElement('div');
            item.className = 'feed-item';
            item.innerHTML = `
                <span class="feed-user username-clickable" onclick="showProfileCard('${escapeHtml(user)}', event)">${escapeHtml(user)}</span>
                <span class="feed-action">${action}</span>
                <div class="feed-time">${time}</div>
            `;

            feed.insertBefore(item, feed.firstChild);

            // Keep only last 20 items
            while (feed.children.length > 20) {
                feed.removeChild(feed.lastChild);
            }
        }

        // Setup avatar grid
        function setupAvatarGrid() {
            const grid = document.getElementById('avatarGrid');
            grid.innerHTML = AVATARS.map(a =>
                `<button class="avatar-option ${a === profile.avatar ? 'selected' : ''}" onclick="selectAvatar('${a}')">${a}</button>`
            ).join('');
        }

        window.selectAvatar = function(avatar) {
            profile.avatar = avatar;
            document.querySelectorAll('.avatar-option').forEach(el => {
                el.classList.toggle('selected', el.textContent === avatar);
            });
        };

        // Setup color options
        function setupColorOptions() {
            const container = document.getElementById('colorOptions');
            container.innerHTML = COLORS.map(c =>
                `<button class="color-option ${c === profile.color ? 'selected' : ''}" style="background: ${c}" onclick="selectColor('${c}')"></button>`
            ).join('');
        }

        window.selectColor = function(color) {
            profile.color = color;
            document.querySelectorAll('.color-option').forEach(el => {
                el.classList.toggle('selected', el.style.background === color);
            });
        };

        // Setup brush colors
        function setupBrushColors() {
            const container = document.getElementById('brushColors');
            container.innerHTML = BRUSH_COLORS.map(c =>
                `<button class="brush-color ${c === brushColor ? 'selected' : ''}" style="background: ${c}" onclick="selectBrushColor('${c}')"></button>`
            ).join('');
        }

        window.selectBrushColor = function(color) {
            brushColor = color;
            document.querySelectorAll('.brush-color').forEach(el => {
                el.classList.toggle('selected', el.style.background === color);
            });
        };

        // Drawing canvas
        function setupDrawingCanvas() {
            const canvas = document.getElementById('drawingCanvas');
            drawingCtx = canvas.getContext('2d');
            drawingCtx.fillStyle = '#111';
            drawingCtx.fillRect(0, 0, canvas.width, canvas.height);
            drawingCtx.lineCap = 'round';
            drawingCtx.lineJoin = 'round';
            drawingCtx.lineWidth = 4;

            canvas.addEventListener('mousedown', startDrawing);
            canvas.addEventListener('mousemove', draw);
            canvas.addEventListener('mouseup', stopDrawing);
            canvas.addEventListener('mouseout', stopDrawing);

            canvas.addEventListener('touchstart', (e) => {
                e.preventDefault();
                const touch = e.touches[0];
                const rect = canvas.getBoundingClientRect();
                const offsetX = touch.clientX - rect.left;
                const offsetY = touch.clientY - rect.top;
                startDrawing({ offsetX, offsetY });
            }, { passive: false });

            canvas.addEventListener('touchmove', (e) => {
                e.preventDefault();
                const touch = e.touches[0];
                const rect = canvas.getBoundingClientRect();
                const offsetX = touch.clientX - rect.left;
                const offsetY = touch.clientY - rect.top;
                draw({ offsetX, offsetY });
            }, { passive: false });

            canvas.addEventListener('touchend', stopDrawing);
        }

        function getCanvasCoords(e) {
            const canvas = document.getElementById('drawingCanvas');
            const rect = canvas.getBoundingClientRect();
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;
            return {
                x: e.offsetX * scaleX,
                y: e.offsetY * scaleY
            };
        }

        function startDrawing(e) {
            isDrawing = true;
            const coords = getCanvasCoords(e);
            drawingCtx.beginPath();
            drawingCtx.moveTo(coords.x, coords.y);
        }

        function draw(e) {
            if (!isDrawing) return;
            const coords = getCanvasCoords(e);
            drawingCtx.strokeStyle = brushColor;
            drawingCtx.lineTo(coords.x, coords.y);
            drawingCtx.stroke();
        }

        function stopDrawing() {
            if (isDrawing) {
                isDrawing = false;
                saveCanvasState(); // Save state after each stroke
            }
        }

        window.clearCanvas = function() {
            const canvas = document.getElementById('drawingCanvas');
            drawingCtx.fillStyle = '#111';
            drawingCtx.fillRect(0, 0, canvas.width, canvas.height);
            resetCanvasHistory(); // Reset undo history on clear
        };

        // Load messages (newest first, at top)
        async function loadMessages(loadMore = false) {
            if (messagesLoading) return;
            if (loadMore && !messagesHasMore) return;

            messagesLoading = true;
            const container = document.getElementById('messagesContainer');

            // Show loading indicator
            if (loadMore) {
                const loader = document.createElement('div');
                loader.className = 'loading-indicator';
                loader.id = 'messagesLoader';
                loader.textContent = 'Loading...';
                container.appendChild(loader);
            }

            const from = loadMore ? messagesPage * PAGE_SIZE : 0;
            const to = from + PAGE_SIZE - 1;

            const { data, error } = await supabase
                .from('sloppygram_messages')
                .select('*')
                .order('created_at', { ascending: false })
                .range(from, to);

            // Remove loading indicator
            const loader = document.getElementById('messagesLoader');
            if (loader) loader.remove();

            messagesLoading = false;

            if (error) {
                console.error('Load error:', error);
                return;
            }

            const emptyState = document.getElementById('emptyState');

            if (!loadMore && data.length === 0) {
                if (emptyState) emptyState.style.display = 'block';
                return;
            }

            if (emptyState) emptyState.style.display = 'none';

            // Check if there are more messages
            messagesHasMore = data.length === PAGE_SIZE;
            if (loadMore) {
                messagesPage++;
            } else {
                messagesPage = 1;
            }

            // Cache messages for filtering (reset on initial load)
            if (!loadMore) window.cachedMessages = [];
            if (!window.cachedMessages) window.cachedMessages = [];

            data.forEach(msg => {
                if (!seenMessageIds.has(msg.id)) {
                    seenMessageIds.add(msg.id);
                    window.cachedMessages.push(msg);
                    addMessageToUI(msg, false); // append at end (older messages)
                }
            });

            // Scroll to top only on initial load
            if (!loadMore) {
                container.scrollTop = 0;
            }
        }

        // Subscribe to new messages
        function subscribeToMessages() {
            if (realtimeChannel) {
                supabase.removeChannel(realtimeChannel);
            }

            realtimeChannel = supabase.channel('sloppygram-global', {
                config: {
                    broadcast: { self: false }
                }
            });

            realtimeChannel.on('broadcast', { event: 'new_message' }, (payload) => {
                const msg = payload.payload;
                if (!msg || seenMessageIds.has(msg.id)) return;
                seenMessageIds.add(msg.id);
                // Cache for filtering
                if (!window.cachedMessages) window.cachedMessages = [];
                window.cachedMessages.unshift(msg);
                addMessageToUI(msg, true); // prepend new messages at top
                addToFeed(msg.username, 'sent a message');
                // Play sound for messages from others
                var currentUserId = (currentUser && currentUser.id) ? currentUser.id : null;
                if (msg.user_id !== currentUserId) {
                    playNotificationSound();
                }
            });

            // Listen for global background changes
            realtimeChannel.on('broadcast', { event: 'global_background' }, (payload) => {
                const bgData = payload.payload;
                if (bgData && bgData.image_data) {
                    const msgContainer = document.getElementById('messagesContainer');
                    if (msgContainer) {
                        msgContainer.style.backgroundImage = 'url(' + bgData.image_data + ')';
                        msgContainer.style.backgroundSize = 'cover';
                        msgContainer.style.backgroundPosition = 'center';
                        msgContainer.style.backgroundAttachment = 'fixed';
                        msgContainer.style.backgroundRepeat = 'no-repeat';
                    }
                    addToFeed(bgData.username || 'Someone', 'changed the chat background');
                }
            });

            realtimeChannel.on('postgres_changes', {
                event: 'INSERT',
                schema: 'public',
                table: 'sloppygram_messages'
            }, (payload) => {
                if (seenMessageIds.has(payload.new.id)) return;
                seenMessageIds.add(payload.new.id);
                // Cache for filtering
                if (!window.cachedMessages) window.cachedMessages = [];
                window.cachedMessages.unshift(payload.new);
                addMessageToUI(payload.new, true); // prepend new messages at top
                // Play sound for messages from others
                var currentUserId2 = (currentUser && currentUser.id) ? currentUser.id : null;
                if (payload.new.user_id !== currentUserId2) {
                    playNotificationSound();
                }
            });

            realtimeChannel.subscribe();
        }

        // Subscribe to posts and comments for real-time updates
        function subscribeToPostsAndComments() {
            if (postsChannel) {
                supabase.removeChannel(postsChannel);
            }

            postsChannel = supabase.channel('sloppygram-posts-realtime');

            // Listen for new posts
            postsChannel.on('postgres_changes', {
                event: 'INSERT',
                schema: 'public',
                table: 'sloppygram_posts'
            }, (payload) => {
                console.log('New post received:', payload.new);
                // Add to posts array if not already there
                if (!posts.find(p => p.id === payload.new.id)) {
                    posts.unshift(payload.new);
                    window.cachedPosts = posts; // Keep global cache in sync
                    if (currentView === 'posts') {
                        renderPosts();
                    }
                }
            });

            // Listen for new comments
            postsChannel.on('postgres_changes', {
                event: 'INSERT',
                schema: 'public',
                table: 'sloppygram_post_comments'
            }, (payload) => {
                console.log('New comment received:', payload.new);
                const comment = payload.new;
                if (!postComments[comment.post_id]) {
                    postComments[comment.post_id] = [];
                }
                // Add if not already there
                if (!postComments[comment.post_id].find(c => c.id === comment.id)) {
                    postComments[comment.post_id].push(comment);
                    if (currentView === 'posts') {
                        renderPosts();
                    }
                }
            });

            // Listen for comment thread relationships
            postsChannel.on('postgres_changes', {
                event: 'INSERT',
                schema: 'public',
                table: 'sloppygram_comment_threads'
            }, (payload) => {
                console.log('New thread relationship:', payload.new);
                const thread = payload.new;
                commentThreads[thread.comment_id] = thread.parent_comment_id;
                if (currentView === 'posts') {
                    renderPosts();
                }
            });

            // Listen for new reactions
            postsChannel.on('postgres_changes', {
                event: '*',
                schema: 'public',
                table: 'sloppygram_post_reactions'
            }, (payload) => {
                console.log('Reaction change:', payload);
                // Reload reactions for affected post
                var newPostId = (payload.new && payload.new.post_id) ? payload.new.post_id : null;
                var oldPostId = (payload.old && payload.old.post_id) ? payload.old.post_id : null;
                if (newPostId || oldPostId) {
                    loadPosts(); // Simple reload for now
                }
            });

            // Listen for likes
            postsChannel.on('postgres_changes', {
                event: '*',
                schema: 'public',
                table: 'sloppygram_post_likes'
            }, (payload) => {
                console.log('Like change:', payload);
                var newPostId2 = (payload.new && payload.new.post_id) ? payload.new.post_id : null;
                var oldPostId2 = (payload.old && payload.old.post_id) ? payload.old.post_id : null;
                if (newPostId2 || oldPostId2) {
                    loadPosts();
                }
            });

            // Listen for manifesto comments
            postsChannel.on('postgres_changes', {
                event: 'INSERT',
                schema: 'public',
                table: 'sloppygram_manifesto_comments'
            }, (payload) => {
                console.log('New manifesto comment:', payload.new);
                const comment = payload.new;
                if (!manifestoComments[comment.manifesto_id]) {
                    manifestoComments[comment.manifesto_id] = [];
                }
                if (!manifestoComments[comment.manifesto_id].find(c => c.id === comment.id)) {
                    manifestoComments[comment.manifesto_id].push(comment);
                    if (currentView === 'manifesto') {
                        renderManifestos();
                    }
                }
            });

            // Listen for new manifestos
            postsChannel.on('postgres_changes', {
                event: 'INSERT',
                schema: 'public',
                table: 'sloppygram_manifestos'
            }, (payload) => {
                console.log('New manifesto:', payload.new);
                if (!manifestos.find(m => m.id === payload.new.id)) {
                    manifestos.unshift(payload.new);
                    window.cachedManifestos = manifestos; // Keep global cache in sync
                    if (currentView === 'manifesto') {
                        renderManifestos();
                    }
                }
            });

            // Listen for manifesto votes
            postsChannel.on('postgres_changes', {
                event: '*',
                schema: 'public',
                table: 'sloppygram_manifesto_votes'
            }, (payload) => {
                console.log('Manifesto vote change:', payload);
                loadManifestos();
            });

            // Listen for manifesto reactions
            postsChannel.on('postgres_changes', {
                event: '*',
                schema: 'public',
                table: 'sloppygram_manifesto_reactions'
            }, (payload) => {
                console.log('Manifesto reaction change:', payload);
                loadManifestos();
            });

            // Listen for doodle votes
            postsChannel.on('postgres_changes', {
                event: '*',
                schema: 'public',
                table: 'sloppygram_doodle_votes'
            }, (payload) => {
                console.log('Doodle vote change:', payload);
                loadDoodleVotes();
                if (currentView === 'doodles') {
                    loadDoodleLeaderboard();
                }
            });

            // Listen for post tags (trending tags)
            postsChannel.on('postgres_changes', {
                event: '*',
                schema: 'public',
                table: 'sloppygram_post_tags'
            }, (payload) => {
                console.log('Post tag change:', payload);
                loadPosts(); // Reload to update trending tags
            });

            // Listen for manifesto tags
            postsChannel.on('postgres_changes', {
                event: '*',
                schema: 'public',
                table: 'sloppygram_manifesto_tags'
            }, (payload) => {
                console.log('Manifesto tag change:', payload);
                loadManifestos();
            });

            // Listen for global backgrounds
            postsChannel.on('postgres_changes', {
                event: 'INSERT',
                schema: 'public',
                table: 'sloppygram_global_backgrounds'
            }, (payload) => {
                console.log('New global background:', payload.new);
                globalBackgrounds.unshift(payload.new);
                renderGlobalBackgrounds(); // Update UI for all users
            });

            // Listen for chat message votes
            postsChannel.on('postgres_changes', {
                event: '*',
                schema: 'public',
                table: 'sloppygram_message_votes'
            }, (payload) => {
                console.log('Message vote change:', payload);
                loadMessageVotes();
            });

            // Listen for comment votes
            postsChannel.on('postgres_changes', {
                event: '*',
                schema: 'public',
                table: 'sloppygram_comment_votes'
            }, (payload) => {
                console.log('Comment vote change:', payload);
                loadCommentVotes().then(() => renderPosts());
            });

            // Listen for doodle comments
            postsChannel.on('postgres_changes', {
                event: 'INSERT',
                schema: 'public',
                table: 'sloppygram_doodle_comments'
            }, (payload) => {
                const comment = payload.new;
                if (comment) {
                    if (!doodleComments[comment.doodle_id]) doodleComments[comment.doodle_id] = [];
                    // Avoid duplicates
                    if (!doodleComments[comment.doodle_id].find(c => c.id === comment.id)) {
                        doodleComments[comment.doodle_id].push(comment);
                        if (comment.parent_comment_id) {
                            doodleCommentThreads[comment.id] = comment.parent_comment_id;
                        }
                        if (currentView === 'doodles') {
                            loadDoodleLeaderboard();
                        }
                    }
                }
            });

            postsChannel.subscribe((status) => {
                console.log('Posts realtime subscription status:', status);
            });

            // === FEEDBACK REALTIME SUBSCRIPTION ===
            var feedbackChannel = supabase.channel('sloppygram-feedback-realtime');

            // Listen for new feedback submissions
            feedbackChannel.on('postgres_changes', {
                event: 'INSERT',
                schema: 'public',
                table: 'feedback'
            }, function(payload) {
                console.log('[Feedback] New idea received:', payload.new);
                // Add to feedbackData if not already there
                if (!feedbackData.find(function(f) { return f.id === payload.new.id; })) {
                    feedbackData.unshift(payload.new);
                    updateFeedbackStats();
                    if (currentView === 'feedback') {
                        renderFeedback();
                        showToast('ðŸ’¡ New idea submitted!', 'info');
                    }
                }
            });

            // Listen for feedback updates (votes, status changes)
            feedbackChannel.on('postgres_changes', {
                event: 'UPDATE',
                schema: 'public',
                table: 'feedback'
            }, function(payload) {
                console.log('[Feedback] Idea updated:', payload.new);
                var index = feedbackData.findIndex(function(f) { return f.id === payload.new.id; });
                if (index !== -1) {
                    feedbackData[index] = payload.new;
                    updateFeedbackStats();
                    if (currentView === 'feedback') {
                        renderFeedback();
                    }
                }
            });

            // Listen for feedback deletions
            feedbackChannel.on('postgres_changes', {
                event: 'DELETE',
                schema: 'public',
                table: 'feedback'
            }, function(payload) {
                console.log('[Feedback] Idea deleted:', payload.old);
                feedbackData = feedbackData.filter(function(f) { return f.id !== payload.old.id; });
                updateFeedbackStats();
                if (currentView === 'feedback') {
                    renderFeedback();
                }
            });

            // Listen for vote changes
            feedbackChannel.on('postgres_changes', {
                event: '*',
                schema: 'public',
                table: 'feedback_votes'
            }, function(payload) {
                console.log('[Feedback] Vote change:', payload);
                // Reload feedback to get updated vote counts
                if (currentView === 'feedback') {
                    loadFeedback();
                }
            });

            feedbackChannel.subscribe(function(status) {
                console.log('[Feedback] Realtime subscription status:', status);
            });
        }

        function broadcastMessage(msg) {
            if (realtimeChannel) {
                realtimeChannel.send({
                    type: 'broadcast',
                    event: 'new_message',
                    payload: msg
                });
            }
        }

        function scrollToBottom() {
            const container = document.getElementById('messagesContainer');
            container.scrollTop = container.scrollHeight;
        }

        // Add message to UI (append by default for bottom-up chat flow)
        function addMessageToUI(msg, prepend = false) {
            const container = document.getElementById('messagesContainer');
            safeSetDisplay('emptyState', 'none');

            var currentUserId = (currentUser && currentUser.id) ? currentUser.id : null;
            const isOwn = msg.user_id === currentUserId;
            const time = new Date(msg.created_at).toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });

            const div = document.createElement('div');
            div.className = `message ${isOwn ? 'own' : ''}`;

            let contentHTML = '';
            if (msg.content) {
                // Parse tags/mentions, escape HTML, then parse hacker markup
                contentHTML = '<div class="message-content">' + parseHackerMarkup(parseChatTags(msg.content)) + '</div>';
            }
            const safeImageData = sanitizeUrl(msg.image_data);
            if (safeImageData) {
                contentHTML += `<img class="message-image" src="${safeImageData}" onclick="openLightbox(this.src)">`;
            }
            const safeDrawingData = sanitizeUrl(msg.drawing_data);
            if (safeDrawingData) {
                const doodleId = msg.id;
                const isRealDoodleId = typeof doodleId === 'number' || (typeof doodleId === 'string' && !doodleId.startsWith('temp_'));
                const doodleScore = doodleVotes[doodleId] || 0;
                const myDoodleVote = myDoodleVotes[doodleId] || 0;
                // Check ownership by user_id first (reliable), fallback to username
                const isOwnDoodle = (currentUserId && msg.user_id === currentUserId) || msg.username === profile.username;
                const doodleScoreClass = doodleScore > 0 ? 'positive' : doodleScore < 0 ? 'negative' : 'neutral';
                const doodleVoteControls = isRealDoodleId ? `
                    <div class="vote-controls doodle-votes" data-doodle-id="${doodleId}">
                        <button class="vote-btn upvote ${myDoodleVote === 1 ? 'active' : ''} ${isOwnDoodle ? 'disabled' : ''}"
                            onclick="${isOwnDoodle ? '' : `voteDoodle('${doodleId}', 1, '${escapeHtml(msg.username)}')`}"
                            title="${isOwnDoodle ? 'Cannot vote on own doodle' : 'Upvote'}">â–²</button>
                        <span class="vote-score ${doodleScoreClass}">${doodleScore}</span>
                        <button class="vote-btn downvote ${myDoodleVote === -1 ? 'active' : ''} ${isOwnDoodle ? 'disabled' : ''}"
                            onclick="${isOwnDoodle ? '' : `voteDoodle('${doodleId}', -1, '${escapeHtml(msg.username)}')`}"
                            title="${isOwnDoodle ? 'Cannot vote on own doodle' : 'Downvote'}">â–¼</button>
                    </div>` : '';
                contentHTML += `
                    <div class="doodle-wrapper">
                        <img class="message-drawing" src="${safeDrawingData}">
                        ${doodleVoteControls}
                    </div>`;
            }

            // Vote controls for non-doodle messages
            const msgId = msg.id;
            const isRealId = typeof msgId === 'number' || (typeof msgId === 'string' && !msgId.startsWith('temp_'));
            // Check ownership by user_id first (reliable), fallback to username comparison
            const isOwnMessage = (currentUserId && msg.user_id === currentUserId) || msg.username === profile.username;
            const chatVoteScore = messageVotes[msgId] || 0;
            const myVoteType = myMessageVotes[msgId] || 0;
            const scoreClass = chatVoteScore > 0 ? 'positive' : chatVoteScore < 0 ? 'negative' : 'neutral';
            const ttsBtn = (msg.content && !msg.drawing_data) ? `<button class="msg-tts-btn" id="msg-tts-${msgId}" onclick="speakMessage('${msgId}')" title="Read aloud">ðŸ”Š</button>` : '';
            const chatVoteBtn = (isRealId && !msg.drawing_data) ? `
                <div class="message-footer">
                    <div class="vote-controls" data-chat-id="${msgId}">
                        <button class="vote-btn upvote ${myVoteType === 1 ? 'active' : ''} ${isOwnMessage ? 'disabled' : ''}"
                            onclick="${isOwnMessage ? '' : `voteMessage('${msgId}', 1)`}" title="${isOwnMessage ? 'Cannot vote on own content' : 'Upvote'}">â–²</button>
                        <span class="vote-score ${scoreClass}">${chatVoteScore}</span>
                        <button class="vote-btn downvote ${myVoteType === -1 ? 'active' : ''} ${isOwnMessage ? 'disabled' : ''}"
                            onclick="${isOwnMessage ? '' : `voteMessage('${msgId}', -1)`}" title="${isOwnMessage ? 'Cannot vote on own content' : 'Downvote'}">â–¼</button>
                    </div>
                    ${ttsBtn}
                </div>` : '';

            const safeAvatarUrl = sanitizeUrl(msg.avatar_url || msg.avatarUrl);
            const avatarContent = safeAvatarUrl
                ? `<img src="${safeAvatarUrl}" alt="avatar" style="width:100%;height:100%;object-fit:cover;border-radius:50%;">`
                : (msg.avatar || 'ðŸ‘¤');
            const deleteBtn = (isOwnMessage && isRealId) ? `<button class="msg-delete-btn" onclick="deleteMessage('${msgId}')" title="Delete">delete</button>` : '';
            div.innerHTML = `
                <div class="avatar">${avatarContent}</div>
                <div class="message-bubble">
                    <div class="message-header">
                        <span class="message-username username-clickable" onclick="showProfileCard('${escapeHtml(msg.username || 'Anonymous')}', event)">${escapeHtml(msg.username || 'Anonymous')}</span>
                        <span class="message-time">${time}</span>
                        ${deleteBtn}
                    </div>
                    ${contentHTML}
                    ${chatVoteBtn}
                </div>
            `;

            if (prepend) {
                container.insertBefore(div, container.firstChild);
            } else {
                container.appendChild(div);
                // Scroll to bottom for new messages
                container.scrollTop = container.scrollHeight;
            }
        }

        // Sanitize text content using DOMPurify - removes all HTML/scripts
        function escapeHtml(text) {
            if (!text) return '';
            // Use DOMPurify to strip all HTML tags, keeping only text
            return DOMPurify.sanitize(String(text), { ALLOWED_TAGS: [] });
        }

        // Parse hacker markup tags like [shake]text[/shake], [rainbow]text[/rainbow], etc.
        function parseHackerMarkup(text) {
            if (!text) return '';

            // Define supported tags and their CSS classes
            const hackerTags = {
                'shake': 'hacker-shake',
                'rainbow': 'hacker-rainbow',
                'matrix': 'hacker-matrix',
                'glitch': 'hacker-glitch',
                'pulse': 'hacker-pulse',
                'wave': 'hacker-wave',
                'spoiler': 'hacker-spoiler'
            };

            let result = text;

            // Process each tag type
            for (const [tag, cssClass] of Object.entries(hackerTags)) {
                // Match [tag]content[/tag] pattern (case insensitive)
                const regex = new RegExp(`\\[${tag}\\](.+?)\\[\\/${tag}\\]`, 'gi');

                if (tag === 'spoiler') {
                    // Spoiler: click to reveal permanently
                    result = result.replace(regex, `<span class="${cssClass}" onclick="this.classList.toggle('revealed')">$1</span>`);
                } else if (tag === 'wave') {
                    // Wave effect: wrap each character in a span with animation delay
                    result = result.replace(regex, (match, content) => {
                        const chars = content.split('').map((char, i) => {
                            if (char === ' ') return ' ';
                            return `<span style="animation-delay:${i * 0.05}s">${char}</span>`;
                        }).join('');
                        return `<span class="${cssClass}">${chars}</span>`;
                    });
                } else {
                    result = result.replace(regex, `<span class="${cssClass}">$1</span>`);
                }
            }

            return result;
        }

        // Sanitize HTML content - allows safe tags but removes scripts
        function sanitizeHtml(html) {
            if (!html) return '';
            return DOMPurify.sanitize(html, {
                ALLOWED_TAGS: ['b', 'i', 'em', 'strong', 'br', 'p', 'span'],
                ALLOWED_ATTR: []
            });
        }

        // Sanitize URLs - block dangerous protocols but allow image data URLs
        function sanitizeUrl(url) {
            if (!url) return '';
            const str = String(url).trim();

            // Allow data:image URLs (base64 images) - match image MIME types
            if (/^data:image\/(png|jpeg|jpg|gif|webp|svg\+xml);base64,/i.test(str)) {
                return str;
            }

            // Block javascript:, other data:, vbscript:, file: protocols
            if (/^(javascript|data|vbscript|file):/i.test(str)) {
                console.warn('Blocked dangerous URL:', str.slice(0, 50));
                return '';
            }

            // Allow http/https URLs and relative paths
            return DOMPurify.sanitize(str, { ALLOWED_TAGS: [] });
        }

        // === CHAT TAGGING SYSTEM ===
        // Show tag hints when user types # or @
        window.handleTagInput = function(textarea) {
            var hint = document.getElementById('tagHint');
            if (!hint) return;

            var val = textarea.value || '';
            var lastChar = val.slice(-1);
            var lastWord = val.split(/\s/).pop() || '';

            // Show hint if typing # or @ at start of word
            if (lastChar === '#' || lastChar === '@' || lastWord.startsWith('#') || lastWord.startsWith('@')) {
                hint.classList.add('visible');
            } else if (val.length === 0) {
                hint.classList.remove('visible');
            }

            // Hide after a few characters of a tag
            if (lastWord.length > 8 && (lastWord.startsWith('#') || lastWord.startsWith('@'))) {
                hint.classList.remove('visible');
            }
        };

        // Insert a tag into the message input
        window.insertTag = function(tag) {
            var input = document.getElementById('messageInput');
            if (!input) return;

            var val = input.value || '';
            // If last char is # or @, replace it with the full tag
            if (val.endsWith('#') || val.endsWith('@')) {
                input.value = val.slice(0, -1) + tag + ' ';
            } else if (val.length > 0 && !val.endsWith(' ')) {
                input.value = val + ' ' + tag + ' ';
            } else {
                input.value = val + tag + ' ';
            }

            input.focus();
            var hint = document.getElementById('tagHint');
            if (hint) hint.classList.remove('visible');
        };

        // Parse #tags and @mentions in message content for display
        function parseChatTags(text) {
            if (!text) return '';

            // Escape HTML first
            var escaped = escapeHtml(text);

            // Replace #tags with styled spans
            escaped = escaped.replace(/#(\w+)/g, function(match, tag) {
                return '<span class="chat-tag" onclick="filterChatByTag(\'' + tag + '\')">#' + tag + '</span>';
            });

            // Replace @mentions with styled spans
            escaped = escaped.replace(/@(\w+)/g, function(match, username) {
                return '<span class="chat-mention" onclick="showUserProfile(\'' + username + '\')">@' + username + '</span>';
            });

            return escaped;
        }

        // Filter chat by tag
        window.filterChatByTag = function(tag) {
            activeChatFilter = { type: 'tag', value: tag };
            var filterBar = document.getElementById('chatFilterBar');
            var filterValue = document.getElementById('activeChatFilter');

            if (filterBar) filterBar.classList.add('active');
            if (filterValue) {
                filterValue.textContent = '#' + tag;
                filterValue.classList.remove('mention');
            }

            renderFilteredMessages();
            showToast('Filtering by #' + tag, 'info');
        };

        // Filter chat by mention (show messages from/mentioning user)
        window.filterChatByMention = function(username) {
            activeChatFilter = { type: 'mention', value: username };
            var filterBar = document.getElementById('chatFilterBar');
            var filterValue = document.getElementById('activeChatFilter');

            if (filterBar) filterBar.classList.add('active');
            if (filterValue) {
                filterValue.textContent = '@' + username;
                filterValue.classList.add('mention');
            }

            renderFilteredMessages();
            showToast('Showing messages from @' + username, 'info');
        };

        // Clear chat filter
        window.clearChatFilter = function() {
            activeChatFilter = null;
            var filterBar = document.getElementById('chatFilterBar');
            if (filterBar) filterBar.classList.remove('active');

            // Also clear tag filter if it was a tag filter
            if (activeTagFilter) {
                activeTagFilter = null;
                document.getElementById('tagFilterBar').classList.remove('active');
                renderPosts();
                renderManifestos();
            }

            renderMessages();
        };

        // Render all cached messages (used after clearing filter)
        function renderMessages() {
            var container = document.getElementById('messagesContainer');
            var emptyState = document.getElementById('emptyState');
            if (!container) return;

            var allMessages = window.cachedMessages || [];

            if (allMessages.length === 0) {
                if (emptyState) {
                    emptyState.innerHTML = '<div class="icon">ðŸ’¾</div><p>INITIALIZING CHAT PROTOCOL...</p><p>Say something!</p>';
                    emptyState.style.display = 'block';
                }
                container.innerHTML = '';
                if (emptyState) container.appendChild(emptyState);
                return;
            }

            if (emptyState) emptyState.style.display = 'none';

            // Clear and re-render all messages
            container.innerHTML = '';
            allMessages.forEach(function(msg) {
                addMessageToUI(msg, false);
            });

            // Scroll to top (newest messages)
            container.scrollTop = 0;
        }

        // Show user profile (for @mention clicks)
        window.showUserProfile = function(username) {
            // Show their profile card
            showProfileCard(username);
        };

        // Render messages with active filter applied
        function renderFilteredMessages() {
            if (!activeChatFilter) {
                renderMessages();
                return;
            }

            var container = document.getElementById('messagesContainer');
            var emptyState = document.getElementById('emptyState');
            if (!container) return;

            // Get cached messages from the container's data or global state
            var allMessages = window.cachedMessages || [];

            var filtered = allMessages.filter(function(msg) {
                var content = msg.content || '';

                if (activeChatFilter.type === 'tag') {
                    // Check if message contains this hashtag
                    var tagRegex = new RegExp('#' + activeChatFilter.value + '\\b', 'i');
                    return tagRegex.test(content);
                } else if (activeChatFilter.type === 'mention') {
                    // Check if message is from this user OR mentions them
                    var mentionRegex = new RegExp('@' + activeChatFilter.value + '\\b', 'i');
                    return msg.username === activeChatFilter.value || mentionRegex.test(content);
                }
                return true;
            });

            if (filtered.length === 0) {
                if (emptyState) {
                    var filterText = activeChatFilter.type === 'tag'
                        ? '#' + activeChatFilter.value
                        : '@' + activeChatFilter.value;
                    emptyState.innerHTML = '<div class="icon">ðŸ”</div><p>No messages with ' + escapeHtml(filterText) + '</p>';
                    emptyState.style.display = 'block';
                }
                container.innerHTML = '';
                if (emptyState) container.appendChild(emptyState);
                return;
            }

            if (emptyState) emptyState.style.display = 'none';

            // Render filtered messages
            container.innerHTML = '';
            filtered.forEach(function(msg) {
                addMessageToUI(msg, false);
            });
        }

        // Extract tags from message content
        function extractTags(text) {
            if (!text) return [];
            var tags = [];
            var tagRegex = /#(\w+(?:\/\w+)?)/g;
            var match;
            while ((match = tagRegex.exec(text)) !== null) {
                var fullTag = match[1];
                var parts = fullTag.split('/');
                if (parts.length === 2) {
                    // Hierarchical tag like #art/pixel
                    tags.push({ tag: parts[1], parent_tag: parts[0] });
                } else {
                    // Simple tag like #vibe
                    tags.push({ tag: parts[0], parent_tag: null });
                }
            }
            return tags;
        }

        // Save tags to database
        async function persistMessageTags(messageId, content, userId) {
            var tags = extractTags(content);
            if (tags.length === 0) return;

            var tagRecords = tags.map(function(t) {
                return {
                    message_id: messageId,
                    tag: t.tag,
                    parent_tag: t.parent_tag,
                    user_id: userId
                };
            });

            var result = await supabase
                .from('sloppygram_message_tags')
                .insert(tagRecords);

            if (result.error) {
                console.error('[persistMessageTags] Error:', result.error);
            } else {
                console.log('[persistMessageTags] Saved', tags.length, 'tags for message', messageId);
            }
        }

        // === TAG CLOUD VISUALIZATION ===
        var tagCloudData = {}; // { tag: count }
        var tagCloudSources = {}; // { tag: { message, post, manifesto } }
        var NEON_COLORS = ['neon-cyan', 'neon-magenta', 'neon-green', 'neon-yellow', 'neon-orange', 'neon-pink'];

        // Load tags from database
        async function loadTagCloud() {
            // Query all three tag sources directly via Supabase
            try {
                var results = await Promise.all([
                    supabase.from('sloppygram_message_tags').select('tag, parent_tag').limit(500),
                    supabase.from('sloppygram_post_tags').select('tag, parent_tag').limit(500),
                    supabase.from('sloppygram_manifesto_tags').select('tag, parent_tag').limit(500)
                ]);

                var messageTags = results[0];
                var postTags = results[1];
                var manifestoTags = results[2];

                // Aggregate tag counts with source breakdown
                tagCloudData = {};
                tagCloudSources = {};

                (messageTags.data || []).forEach(function(row) {
                    var fullTag = row.parent_tag ? row.parent_tag + '/' + row.tag : row.tag;
                    var key = fullTag.toLowerCase();
                    tagCloudData[key] = (tagCloudData[key] || 0) + 1;
                    if (!tagCloudSources[key]) tagCloudSources[key] = { message: 0, post: 0, manifesto: 0, displayTag: fullTag };
                    tagCloudSources[key].message++;
                });

                (postTags.data || []).forEach(function(row) {
                    var fullTag = row.parent_tag ? row.parent_tag + '/' + row.tag : row.tag;
                    var key = fullTag.toLowerCase();
                    tagCloudData[key] = (tagCloudData[key] || 0) + 1;
                    if (!tagCloudSources[key]) tagCloudSources[key] = { message: 0, post: 0, manifesto: 0, displayTag: fullTag };
                    tagCloudSources[key].post++;
                });

                (manifestoTags.data || []).forEach(function(row) {
                    var fullTag = row.parent_tag ? row.parent_tag + '/' + row.tag : row.tag;
                    var key = fullTag.toLowerCase();
                    tagCloudData[key] = (tagCloudData[key] || 0) + 1;
                    if (!tagCloudSources[key]) tagCloudSources[key] = { message: 0, post: 0, manifesto: 0, displayTag: fullTag };
                    tagCloudSources[key].manifesto++;
                });

                renderTagCloud();
            } catch (err) {
                console.error('[TagCloud] Error loading tags:', err);
            }
        }

        // Render the tag cloud
        function renderTagCloud() {
            var container = document.getElementById('tagCloud');
            if (!container) return;

            var tags = Object.keys(tagCloudData);
            if (tags.length === 0) {
                container.innerHTML = '<div class="tag-cloud-empty">No tags yet... use #hashtags in chat!</div>';
                return;
            }

            // Sort by frequency (descending)
            tags.sort(function(a, b) {
                return tagCloudData[b] - tagCloudData[a];
            });

            // Take top 20 tags
            tags = tags.slice(0, 20);

            // Find max count for sizing
            var maxCount = Math.max.apply(null, tags.map(function(t) { return tagCloudData[t]; }));

            // Build tag elements
            var html = tags.map(function(tag, index) {
                var count = tagCloudData[tag];
                var sources = tagCloudSources[tag] || { message: 0, post: 0, manifesto: 0, displayTag: tag };
                var displayTag = sources.displayTag || tag;
                var sizeClass = 'size-' + Math.min(5, Math.ceil((count / maxCount) * 5));
                var colorClass = NEON_COLORS[index % NEON_COLORS.length];
                var pulseDelay = (index * 0.2) % 3;

                // Build tooltip with source breakdown
                var tooltip = count + ' total: ' + sources.message + ' msgs, ' + sources.post + ' posts, ' + sources.manifesto + ' manifestos';

                return '<span class="tag-cloud-item ' + sizeClass + ' ' + colorClass + '" ' +
                    'style="--pulse-delay: ' + pulseDelay + 's" ' +
                    'onclick="showTagExplorer(\'' + escapeHtml(displayTag) + '\')" ' +
                    'title="' + tooltip + '">' +
                    '#' + escapeHtml(displayTag) +
                    '</span>';
            }).join('');

            container.innerHTML = html;
        }

        // Add a new tag to the cloud (for real-time updates)
        function addToTagCloud(tag, parentTag) {
            var fullTag = parentTag ? parentTag + '/' + tag : tag;
            var wasNew = !tagCloudData[fullTag];
            tagCloudData[fullTag] = (tagCloudData[fullTag] || 0) + 1;

            renderTagCloud();

            // Add "new" animation to the tag if it's new
            if (wasNew) {
                var container = document.getElementById('tagCloud');
                if (container) {
                    var tagEl = container.querySelector('[onclick*="' + fullTag + '"]');
                    if (tagEl) {
                        tagEl.classList.add('new-tag');
                        setTimeout(function() {
                            tagEl.classList.remove('new-tag');
                        }, 500);
                    }
                }
            }
        }

        // Hook into message sending to update tag cloud in real-time
        var originalPersistMessageTags = persistMessageTags;
        persistMessageTags = async function(messageId, content, userId) {
            // Call original
            await originalPersistMessageTags(messageId, content, userId);

            // Update tag cloud locally
            var tags = extractTags(content);
            tags.forEach(function(t) {
                addToTagCloud(t.tag, t.parent_tag);
            });
        };

        // Load tag cloud on init
        document.addEventListener('DOMContentLoaded', function() {
            setTimeout(loadTagCloud, 1000);
        });

        // Refresh tag cloud periodically
        setInterval(loadTagCloud, 60000); // Every minute

        // === TAG EXPLORER ===
        window.showTagExplorer = async function(tag) {
            var modal = document.getElementById('tagExplorerModal');
            var content = document.getElementById('tagExplorerContent');
            if (!modal || !content) return;

            // Show modal with loading state
            modal.classList.add('active');
            content.innerHTML = '<div class="tag-explorer-loading">Loading tag data...</div>';

            try {
                // Get tag stats from cache
                var tagLower = tag.toLowerCase();
                var sources = tagCloudSources[tagLower] || { message: 0, post: 0, manifesto: 0 };

                // Fetch messages, posts and manifestos with this tag from the tag tables in parallel
                var [messageTagsRes, postTagsRes, manifestoTagsRes] = await Promise.all([
                    supabase.from('sloppygram_message_tags')
                        .select('message_id')
                        .or('tag.ilike.' + tag + ',parent_tag.ilike.' + tag)
                        .limit(20),
                    supabase.from('sloppygram_post_tags')
                        .select('post_id')
                        .or('tag.ilike.' + tag + ',parent_tag.ilike.' + tag)
                        .limit(20),
                    supabase.from('sloppygram_manifesto_tags')
                        .select('manifesto_id')
                        .or('tag.ilike.' + tag + ',parent_tag.ilike.' + tag)
                        .limit(20)
                ]);

                // Get unique IDs
                var messageIds = (messageTagsRes.data || []).map(function(t) { return t.message_id; });
                var postIds = (postTagsRes.data || []).map(function(t) { return t.post_id; });
                var manifestoIds = (manifestoTagsRes.data || []).map(function(t) { return t.manifesto_id; });

                // Fetch all content directly from Supabase by ID for full archive access
                var [messagesRes, postsRes, manifestosRes] = await Promise.all([
                    messageIds.length > 0
                        ? supabase.from('sloppygram_messages').select('*').in('id', messageIds).order('created_at', { ascending: false })
                        : { data: [] },
                    postIds.length > 0
                        ? supabase.from('sloppygram_posts').select('*').in('id', postIds).order('created_at', { ascending: false })
                        : { data: [] },
                    manifestoIds.length > 0
                        ? supabase.from('sloppygram_manifestos').select('*').in('id', manifestoIds).order('created_at', { ascending: false })
                        : { data: [] }
                ]);

                var matchingMessages = messagesRes.data || [];
                var matchingPosts = postsRes.data || [];
                var matchingManifestos = manifestosRes.data || [];

                // Build messages HTML
                var messagesHtml = '';
                if (matchingMessages.length > 0) {
                    messagesHtml = '<div class="tag-explorer-messages">' +
                        matchingMessages.slice(0, 10).map(function(msg) {
                            var time = new Date(msg.created_at).toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
                            var safeAvatarUrl = sanitizeUrl(msg.avatar_url || msg.avatarUrl);
                            var avatarContent = safeAvatarUrl
                                ? '<img src="' + safeAvatarUrl + '" alt="avatar" style="width:100%;height:100%;object-fit:cover;border-radius:50%;">'
                                : (msg.avatar || 'ðŸ‘¤');
                            var contentHtml = msg.content ? parseHackerMarkup(parseChatTags(msg.content)) : '';
                            return '<div class="tag-explorer-message">' +
                                '<div class="avatar">' + avatarContent + '</div>' +
                                '<div class="tag-msg-bubble">' +
                                '<div class="tag-msg-header">' +
                                '<span class="msg-username" onclick="showProfileCard(\'' + escapeHtml(msg.username) + '\', event)">' + escapeHtml(msg.username || 'Anonymous') + '</span>' +
                                '<span class="msg-time">' + time + '</span>' +
                                '</div>' +
                                '<div class="msg-content">' + contentHtml + '</div>' +
                                '</div>' +
                                '</div>';
                        }).join('') +
                        '</div>';
                } else {
                    messagesHtml = '<div class="tag-explorer-empty">No messages with this tag</div>';
                }

                // Build posts HTML using actual post cards
                var postsHtml = '';
                if (matchingPosts.length > 0) {
                    postsHtml = '<div class="tag-explorer-posts">' +
                        matchingPosts.slice(0, 5).map(function(post) {
                            return renderPostCard(post);
                        }).join('') +
                        '</div>';
                } else {
                    postsHtml = '<div class="tag-explorer-empty">No posts with this tag</div>';
                }

                // Build manifestos HTML using actual manifesto cards
                var manifestosHtml = '';
                if (matchingManifestos.length > 0) {
                    manifestosHtml = '<div class="tag-explorer-manifestos">' +
                        matchingManifestos.slice(0, 5).map(function(m) {
                            return renderManifestoCard(m);
                        }).join('') +
                        '</div>';
                } else {
                    manifestosHtml = '<div class="tag-explorer-empty">No manifestos with this tag</div>';
                }

                // Build full content with tabs
                content.innerHTML =
                    '<div class="tag-explorer-header">' +
                    '<span class="tag-explorer-tag">#' + escapeHtml(tag) + '</span>' +
                    '</div>' +
                    '<div class="tag-explorer-stats">' +
                    '<div class="tag-stat"><div class="tag-stat-count">' + sources.message + '</div><div class="tag-stat-label">Messages</div></div>' +
                    '<div class="tag-stat"><div class="tag-stat-count">' + sources.post + '</div><div class="tag-stat-label">Posts</div></div>' +
                    '<div class="tag-stat"><div class="tag-stat-count">' + sources.manifesto + '</div><div class="tag-stat-label">Manifestos</div></div>' +
                    '</div>' +
                    '<div class="tag-explorer-tabs">' +
                    '<button class="tag-tab active" onclick="switchTagExplorerTab(\'messages\', this)">ðŸ’¬ Messages (' + matchingMessages.length + ')</button>' +
                    '<button class="tag-tab" onclick="switchTagExplorerTab(\'posts\', this)">ðŸ“¸ Posts (' + matchingPosts.length + ')</button>' +
                    '<button class="tag-tab" onclick="switchTagExplorerTab(\'manifestos\', this)">ðŸ“œ Manifestos (' + matchingManifestos.length + ')</button>' +
                    '</div>' +
                    '<div class="tag-explorer-tab-content" id="tagExplorerMessages">' + messagesHtml + '</div>' +
                    '<div class="tag-explorer-tab-content" id="tagExplorerPosts" style="display:none;">' + postsHtml + '</div>' +
                    '<div class="tag-explorer-tab-content" id="tagExplorerManifestos" style="display:none;">' + manifestosHtml + '</div>' +
                    '<button class="modal-btn tag-filter-btn" onclick="setGlobalTagFilter(\'' + escapeHtml(tag) + '\')">ðŸ” SET AS GLOBAL FILTER: #' + escapeHtml(tag).toUpperCase() + '</button>';

            } catch (err) {
                console.error('[TagExplorer] Error:', err);
                content.innerHTML = '<div class="tag-explorer-empty">Error loading tag data</div>';
            }
        };

        window.switchTagExplorerTab = function(tab, btn) {
            // Update tab buttons
            var tabs = document.querySelectorAll('.tag-explorer-tabs .tag-tab');
            tabs.forEach(function(t) { t.classList.remove('active'); });
            btn.classList.add('active');

            // Show/hide content for all three tabs
            document.getElementById('tagExplorerMessages').style.display = tab === 'messages' ? 'block' : 'none';
            document.getElementById('tagExplorerPosts').style.display = tab === 'posts' ? 'block' : 'none';
            document.getElementById('tagExplorerManifestos').style.display = tab === 'manifestos' ? 'block' : 'none';
        };

        window.closeTagExplorer = function() {
            var modal = document.getElementById('tagExplorerModal');
            if (modal) modal.classList.remove('active');
        };

        // Set global tag filter from Tag Explorer
        window.setGlobalTagFilter = function(tag) {
            closeTagExplorer();
            filterByTag(tag);
        };

        // Close tag explorer on overlay click
        document.addEventListener('click', function(e) {
            if (e.target.id === 'tagExplorerModal') {
                closeTagExplorer();
            }
        });

        // === FEEDBACK HUB INTEGRATION ===
        var feedbackData = [];
        var feedbackVotes = {};
        var feedbackFilter = 'all';
        var feedbackCategory = 'apps';

        // Format time ago for feedback cards
        function formatTimeAgo(date) {
            var now = new Date();
            var seconds = Math.floor((now - date) / 1000);

            if (seconds < 60) return 'just now';
            if (seconds < 3600) return Math.floor(seconds / 60) + 'm ago';
            if (seconds < 86400) return Math.floor(seconds / 3600) + 'h ago';
            if (seconds < 604800) return Math.floor(seconds / 86400) + 'd ago';
            return date.toLocaleDateString();
        }

        async function loadFeedback() {
            var listEl = document.getElementById('feedbackList');
            if (!listEl) return;

            listEl.innerHTML = '<div class="feedback-empty">Loading ideas...</div>';

            try {
                // Load feedback
                var { data, error } = await supabase
                    .from('feedback')
                    .select('*')
                    .order('votes', { ascending: false });

                if (error) throw error;
                feedbackData = data || [];

                // Load user's votes
                if (currentUser) {
                    var { data: votes } = await supabase
                        .from('feedback_votes')
                        .select('feedback_id, vote_type')
                        .eq('user_id', currentUser.id);

                    feedbackVotes = {};
                    (votes || []).forEach(function(v) {
                        feedbackVotes[v.feedback_id] = v.vote_type;
                    });
                }

                updateFeedbackStats();
                renderFeedback();
            } catch (err) {
                console.error('[Feedback] Load error:', err);
                listEl.innerHTML = '<div class="feedback-empty">Error loading ideas</div>';
            }
        }

        function updateFeedbackStats() {
            var totalVotes = feedbackData.reduce(function(sum, f) { return sum + (f.votes || 0); }, 0);
            var contributors = new Set(feedbackData.map(function(f) { return f.user_id; })).size;

            var ideasEl = document.getElementById('feedbackTotalIdeas');
            var votesEl = document.getElementById('feedbackTotalVotes');
            var contribEl = document.getElementById('feedbackContributors');

            if (ideasEl) ideasEl.textContent = feedbackData.length;
            if (votesEl) votesEl.textContent = totalVotes;
            if (contribEl) contribEl.textContent = contributors;
        }

        function renderFeedback() {
            var listEl = document.getElementById('feedbackList');
            if (!listEl) return;

            var filtered = feedbackData.filter(function(f) {
                if (feedbackFilter === 'all') return true;
                if (feedbackFilter === 'mine') return currentUser && f.user_id === currentUser.id;
                return f.category === feedbackFilter;
            });

            if (filtered.length === 0) {
                listEl.innerHTML = '<div class="feedback-empty">No ideas yet. Be the first!</div>';
                return;
            }

            listEl.innerHTML = filtered.map(function(f) {
                var isOwn = currentUser && f.user_id === currentUser.id;
                var hasVoted = feedbackVotes[f.id];
                var timeAgo = formatTimeAgo(new Date(f.created_at));

                return '<div class="feedback-card' + (isOwn ? ' own' : '') + '">' +
                    '<div class="feedback-vote">' +
                    '<button class="feedback-vote-btn' + (hasVoted ? ' voted' : '') + '" onclick="voteFeedback(' + f.id + ')">â–²</button>' +
                    '<span class="feedback-vote-count">' + (f.votes || 0) + '</span>' +
                    '</div>' +
                    '<div class="feedback-content">' +
                    '<div class="feedback-title">' + escapeHtml(f.title) + '</div>' +
                    (f.description ? '<div class="feedback-desc">' + escapeHtml(f.description) + '</div>' : '') +
                    '<div class="feedback-meta">' +
                    '<span class="feedback-category-tag ' + f.category + '">' + f.category + '</span>' +
                    '<span class="feedback-time">' + timeAgo + '</span>' +
                    (isOwn ? '<button class="feedback-delete" onclick="deleteFeedback(' + f.id + ')">Delete</button>' : '') +
                    '</div>' +
                    '</div>' +
                    '</div>';
            }).join('');
        }

        window.toggleFeedbackForm = function() {
            var form = document.getElementById('feedbackForm');
            if (form) form.classList.toggle('active');
        };

        window.selectFeedbackCategory = function(cat) {
            feedbackCategory = cat;
            document.querySelectorAll('.feedback-cat-btn').forEach(function(btn) {
                btn.classList.toggle('selected', btn.dataset.category === cat);
            });
        };

        window.filterFeedback = function(filter) {
            feedbackFilter = filter;
            document.querySelectorAll('.feedback-filter').forEach(function(btn) {
                btn.classList.toggle('active', btn.dataset.filter === filter);
            });
            renderFeedback();
        };

        window.submitFeedback = async function() {
            if (!currentUser) {
                showToast('Please sign in to submit feedback', 'error');
                return;
            }

            var title = document.getElementById('feedbackTitle').value.trim();
            var desc = document.getElementById('feedbackDesc').value.trim();

            if (!title) {
                showToast('Please enter a title', 'error');
                return;
            }

            try {
                var { error } = await supabase.from('feedback').insert({
                    title: title,
                    description: desc || null,
                    category: feedbackCategory,
                    votes: 0,
                    status: 'new',
                    user_id: currentUser.id
                });

                if (error) throw error;

                document.getElementById('feedbackTitle').value = '';
                document.getElementById('feedbackDesc').value = '';
                document.getElementById('feedbackForm').classList.remove('active');

                showToast('Idea submitted!', 'success');
                loadFeedback();
            } catch (err) {
                console.error('[Feedback] Submit error:', err);
                showToast('Error submitting idea', 'error');
            }
        };

        window.voteFeedback = async function(feedbackId) {
            if (!currentUser) {
                showToast('Please sign in to vote', 'error');
                return;
            }

            var hasVoted = feedbackVotes[feedbackId];

            try {
                if (hasVoted) {
                    // Remove vote
                    await supabase.from('feedback_votes')
                        .delete()
                        .eq('feedback_id', feedbackId)
                        .eq('user_id', currentUser.id);

                    await supabase.from('feedback')
                        .update({ votes: supabase.rpc ? undefined : 0 })
                        .eq('id', feedbackId);

                    // Decrement votes manually
                    var feedback = feedbackData.find(function(f) { return f.id === feedbackId; });
                    if (feedback) {
                        await supabase.from('feedback')
                            .update({ votes: Math.max(0, (feedback.votes || 1) - 1) })
                            .eq('id', feedbackId);
                    }

                    delete feedbackVotes[feedbackId];
                } else {
                    // Add vote
                    await supabase.from('feedback_votes').insert({
                        feedback_id: feedbackId,
                        vote_type: 1,
                        user_id: currentUser.id
                    });

                    var feedback = feedbackData.find(function(f) { return f.id === feedbackId; });
                    if (feedback) {
                        await supabase.from('feedback')
                            .update({ votes: (feedback.votes || 0) + 1 })
                            .eq('id', feedbackId);
                    }

                    feedbackVotes[feedbackId] = 1;
                }

                loadFeedback();
            } catch (err) {
                console.error('[Feedback] Vote error:', err);
                showToast('Error voting', 'error');
            }
        };

        window.deleteFeedback = async function(feedbackId) {
            if (!currentUser) return;

            if (!confirm('Delete this idea?')) return;

            try {
                await supabase.from('feedback')
                    .delete()
                    .eq('id', feedbackId)
                    .eq('user_id', currentUser.id);

                showToast('Idea deleted', 'info');
                loadFeedback();
            } catch (err) {
                console.error('[Feedback] Delete error:', err);
                showToast('Error deleting idea', 'error');
            }
        };

        // === CROSS-APP PROFILE STATS ===
        async function getCrossAppStats(username) {
            var gameScores = [];

            try {
                // Query multiple leaderboard tables in parallel
                var [breakout, icyTower, tetris, starCatcher] = await Promise.all([
                    supabase.from('breakout_terminal_scores').select('score, display_name').eq('display_name', username).order('score', { ascending: false }).limit(1),
                    supabase.from('icy_tower_scores').select('score, display_name').eq('display_name', username).order('score', { ascending: false }).limit(1),
                    supabase.from('tetris_leaderboard').select('score, display_name').eq('display_name', username).order('score', { ascending: false }).limit(1),
                    supabase.from('star_catcher_leaderboard').select('score, display_name').eq('display_name', username).order('score', { ascending: false }).limit(1)
                ]);

                if (breakout.data && breakout.data[0]) {
                    gameScores.push({ game: 'Breakout', score: breakout.data[0].score });
                }
                if (icyTower.data && icyTower.data[0]) {
                    gameScores.push({ game: 'Icy Tower', score: icyTower.data[0].score });
                }
                if (tetris.data && tetris.data[0]) {
                    gameScores.push({ game: 'Tetris', score: tetris.data[0].score });
                }
                if (starCatcher.data && starCatcher.data[0]) {
                    gameScores.push({ game: 'Star Catcher', score: starCatcher.data[0].score });
                }
            } catch (err) {
                console.error('[CrossApp] Error fetching scores:', err);
            }

            return gameScores;
        }

        // === RALPH WIGGUM BOT ===
        // "Me fail code? That's unpossible!"
        var RALPH_QUOTES = [
            "Me fail English? That's unpossible!",
            "I'm learnding!",
            "I bent my wookie.",
            "My cat's breath smells like cat food.",
            "I'm in danger!",
            "I found a moon rock in my nose!",
            "The doctor said I wouldn't have so many nose bleeds if I kept my finger outta there.",
            "My knob tastes funny.",
            "I'm a unitard!",
            "I heard your dad went into a restaurant and ate everything in the restaurant.",
            "That's where I saw the leprechaun. He tells me to burn things.",
            "I'm Idaho!",
            "When I grow up, I want to be a principal or a caterpillar.",
            "I sleep in a drawer!",
            "My parents won't let me use scissors.",
            "I glued my head to my shoulder once.",
            "I'm going to Bovine University!",
            "What's a battle?",
            "Mrs. Krabappel and Principal Skinner were in the closet making babies and I saw one of the babies and the baby looked at me.",
            "Go banana!",
            "I dress myself!",
            "Bushes are nice cause they don't have prickers. Unless they do. This one did. Ouch!",
            "I eated the purple berries.",
            "My sandbox at home is full of cat poop!",
            "Hi Super Nintendo Chalmers!",
            "I'm a brick!",
            "Slow down, I want to get off!",
            "Can you open my milk, Mommy?",
            "The pointy kitty took it!",
            "I put the glue inside the computer now!"
        ];

        window.summonRalph = function() {
            var quote = RALPH_QUOTES[Math.floor(Math.random() * RALPH_QUOTES.length)];

            var ralphMsg = {
                id: 'ralph_' + Date.now(),
                username: 'ðŸ§’ Ralph Wiggum',
                avatar: 'ðŸ§’',
                avatarUrl: null,
                content: quote,
                image_data: null,
                drawing_data: null,
                message_type: 'text',
                user_id: 'ralph_bot',
                created_at: new Date().toISOString()
            };

            addMessageToUI(ralphMsg, true);
            broadcastMessage(ralphMsg);
            addToFeed('ðŸ§’ Ralph Wiggum', 'shared wisdom');
            showToast('ðŸ§’ Ralph has spoken!', 'info');
        };

        // Ralph-ify text transformation
        window.ralphify = function(text) {
            var suffixes = [
                " My cat's breath smells like cat food.",
                " I'm learnding!",
                " That's unpossible!",
                " I bent my wookie.",
                " Go banana!",
                " I'm a brick!"
            ];
            return text + suffixes[Math.floor(Math.random() * suffixes.length)];
        };

        // Listen for /ralph command in messages
        function checkForRalphCommand(content) {
            if (content && content.toLowerCase().trim() === '/ralph') {
                setTimeout(function() {
                    window.summonRalph();
                }, 500);
                return true;
            }
            return false;
        }

        // Send message
        window.sendMessage = async function() {
            const input = document.getElementById('messageInput');
            const content = input.value.trim();

            if (!content && !selectedImage) return;

            // Check for /ralph command
            if (checkForRalphCommand(content)) {
                input.value = '';
                return;
            }

            // Rate limiting check
            const rateCheck = checkRateLimit('message');
            if (!rateCheck.allowed) {
                showToast(rateCheck.message, 'warning');
                return;
            }
            recordAction('message');

            const tempId = 'temp_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
            const hasImage = !!selectedImage;
            const localImageData = selectedImage; // keep reference for optimistic UI

            const msg = {
                id: tempId,
                username: profile.username,
                avatar: profile.avatar,
                avatarUrl: profile.avatarUrl || null,
                content: content || null,
                image_data: localImageData || null, // temp local preview
                drawing_data: null,
                message_type: hasImage ? 'image' : 'text',
                user_id: (currentUser && currentUser.id) ? currentUser.id : null,
                created_at: new Date().toISOString()
            };

            input.value = '';
            input.style.height = 'auto';
            removeImage();

            seenMessageIds.add(tempId);
            addMessageToUI(msg, true); // prepend at top
            broadcastMessage(msg);
            addToFeed(profile.username, hasImage ? 'shared an image' : 'sent a message');

            // Upload image to storage if present
            let finalImageData = null;
            if (localImageData) {
                const blob = dataURLtoBlob(localImageData);
                const storageUrl = await uploadToStorage(blob, 'chat');
                finalImageData = storageUrl || localImageData; // fallback to base64
            }

            const { data, error } = await supabase
                .from('sloppygram_messages')
                .insert({
                    username: msg.username,
                    avatar: msg.avatar,
                    avatar_url: msg.avatarUrl,
                    content: msg.content,
                    image_data: finalImageData,
                    drawing_data: msg.drawing_data,
                    message_type: msg.message_type,
                    user_id: msg.user_id
                })
                .select('id')
                .single();

            if (error) {
                console.error('Send error:', error);
                return;
            }

            if (data && data.id) {
                seenMessageIds.add(data.id);

                // Persist tags to database
                if (content) {
                    persistMessageTags(data.id, content, msg.user_id);
                }
            }
        };

        // Delete message
        window.deleteMessage = async function(messageId) {
            if (!currentUser) return;
            if (!confirm('Delete this message?')) return;

            const { error } = await supabase
                .from('sloppygram_messages')
                .delete()
                .eq('id', messageId)
                .eq('user_id', currentUser.id);

            if (error) {
                console.error('Delete error:', error);
                return;
            }

            // Remove from UI
            const container = document.getElementById('messagesContainer');
            const msgElements = container.querySelectorAll('.message');
            msgElements.forEach(el => {
                const voteControl = el.querySelector(`[data-chat-id="${messageId}"]`);
                const doodleControl = el.querySelector(`[data-doodle-id="${messageId}"]`);
                if (voteControl || doodleControl) {
                    el.remove();
                }
            });
        };

        // Send drawing
        window.sendDrawing = async function() {
            // Rate limiting check
            const rateCheck = checkRateLimit('drawing');
            if (!rateCheck.allowed) {
                showToast(rateCheck.message, 'warning');
                return;
            }
            recordAction('drawing');

            const canvas = document.getElementById('drawingCanvas');
            const drawingDataUrl = canvas.toDataURL('image/png');

            const tempId = 'temp_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);

            // Show optimistic UI with local data URL first
            const msg = {
                id: tempId,
                username: profile.username,
                avatar: profile.avatar,
                avatarUrl: profile.avatarUrl || null,
                content: null,
                image_data: null,
                drawing_data: drawingDataUrl, // temporary local preview
                message_type: 'drawing',
                user_id: (currentUser && currentUser.id) ? currentUser.id : null,
                created_at: new Date().toISOString()
            };

            closeDrawingModal();
            clearCanvas();

            seenMessageIds.add(tempId);
            addMessageToUI(msg, true); // prepend at top
            broadcastMessage(msg);
            addToFeed(profile.username, 'shared a drawing');

            // Upload to storage instead of saving base64
            const blob = dataURLtoBlob(drawingDataUrl);
            const storageUrl = await uploadToStorage(blob, 'doodles');

            // Use storage URL if upload succeeded, otherwise fallback to base64
            const finalDrawingData = storageUrl || drawingDataUrl;

            const { data, error } = await supabase
                .from('sloppygram_messages')
                .insert({
                    username: msg.username,
                    avatar: msg.avatar,
                    avatar_url: msg.avatarUrl,
                    content: msg.content,
                    image_data: msg.image_data,
                    drawing_data: finalDrawingData,
                    message_type: msg.message_type,
                    user_id: msg.user_id
                })
                .select('id')
                .single();

            if (error) {
                console.error('Send error:', error);
            }

            if (data && data.id) {
                seenMessageIds.add(data.id);
            }
        };

        // Image handling
        window.handleImageSelect = function(event) {
            const file = event.target.files[0];
            if (!file) return;

            if (file.size > 500000) {
                alert('FILE TOO LARGE. MAX 500KB.');
                return;
            }

            const reader = new FileReader();
            reader.onload = (e) => {
                selectedImage = e.target.result;
                document.getElementById('previewImg').src = selectedImage;
                document.getElementById('imagePreview').style.display = 'block';
            };
            reader.readAsDataURL(file);
        };

        window.removeImage = function() {
            selectedImage = null;
            safeSetDisplay('imagePreview', 'none');
            var imageInput = document.getElementById('imageInput');
            if (imageInput) imageInput.value = '';
        };

        // Settings modal
        let pendingAvatarData = null;
        let pendingBgData = null;

        // Sound settings
        let soundSettings = {
            sound: 'none',
            volume: 50,
            customData: '',
            customName: ''
        };

        // Audio context for generating sounds
        let audioContext = null;
        let customSoundAudio = null;

        function getAudioContext() {
            if (!audioContext) {
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
            }
            // Resume if suspended (browser autoplay policy)
            if (audioContext.state === 'suspended') {
                audioContext.resume();
            }
            return audioContext;
        }

        // Sound library using Web Audio API (procedural sounds)
        const soundLibrary = {
            blip: function(ctx, vol) {
                const osc = ctx.createOscillator();
                const gain = ctx.createGain();
                osc.connect(gain);
                gain.connect(ctx.destination);
                osc.frequency.setValueAtTime(800, ctx.currentTime);
                osc.frequency.exponentialRampToValueAtTime(400, ctx.currentTime + 0.1);
                gain.gain.setValueAtTime(vol, ctx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, ctx.currentTime + 0.1);
                osc.start(ctx.currentTime);
                osc.stop(ctx.currentTime + 0.1);
            },
            chime: function(ctx, vol) {
                [523, 659, 784].forEach((freq, i) => {
                    const osc = ctx.createOscillator();
                    const gain = ctx.createGain();
                    osc.type = 'sine';
                    osc.connect(gain);
                    gain.connect(ctx.destination);
                    osc.frequency.setValueAtTime(freq, ctx.currentTime + i * 0.08);
                    gain.gain.setValueAtTime(vol * 0.6, ctx.currentTime + i * 0.08);
                    gain.gain.exponentialRampToValueAtTime(0.01, ctx.currentTime + i * 0.08 + 0.3);
                    osc.start(ctx.currentTime + i * 0.08);
                    osc.stop(ctx.currentTime + i * 0.08 + 0.3);
                });
            },
            pop: function(ctx, vol) {
                const osc = ctx.createOscillator();
                const gain = ctx.createGain();
                osc.type = 'sine';
                osc.connect(gain);
                gain.connect(ctx.destination);
                osc.frequency.setValueAtTime(600, ctx.currentTime);
                osc.frequency.exponentialRampToValueAtTime(200, ctx.currentTime + 0.05);
                gain.gain.setValueAtTime(vol, ctx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, ctx.currentTime + 0.05);
                osc.start(ctx.currentTime);
                osc.stop(ctx.currentTime + 0.05);
            },
            retro: function(ctx, vol) {
                const osc = ctx.createOscillator();
                const gain = ctx.createGain();
                osc.type = 'square';
                osc.connect(gain);
                gain.connect(ctx.destination);
                osc.frequency.setValueAtTime(440, ctx.currentTime);
                osc.frequency.setValueAtTime(880, ctx.currentTime + 0.05);
                osc.frequency.setValueAtTime(440, ctx.currentTime + 0.1);
                gain.gain.setValueAtTime(vol * 0.3, ctx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, ctx.currentTime + 0.15);
                osc.start(ctx.currentTime);
                osc.stop(ctx.currentTime + 0.15);
            },
            cyber: function(ctx, vol) {
                const osc = ctx.createOscillator();
                const osc2 = ctx.createOscillator();
                const gain = ctx.createGain();
                osc.type = 'sawtooth';
                osc2.type = 'square';
                osc.connect(gain);
                osc2.connect(gain);
                gain.connect(ctx.destination);
                osc.frequency.setValueAtTime(150, ctx.currentTime);
                osc.frequency.linearRampToValueAtTime(600, ctx.currentTime + 0.1);
                osc2.frequency.setValueAtTime(300, ctx.currentTime);
                osc2.frequency.linearRampToValueAtTime(100, ctx.currentTime + 0.1);
                gain.gain.setValueAtTime(vol * 0.2, ctx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, ctx.currentTime + 0.12);
                osc.start(ctx.currentTime);
                osc2.start(ctx.currentTime);
                osc.stop(ctx.currentTime + 0.12);
                osc2.stop(ctx.currentTime + 0.12);
            },
            whoosh: function(ctx, vol) {
                const bufferSize = ctx.sampleRate * 0.15;
                const buffer = ctx.createBuffer(1, bufferSize, ctx.sampleRate);
                const data = buffer.getChannelData(0);
                for (let i = 0; i < bufferSize; i++) {
                    data[i] = (Math.random() * 2 - 1) * (1 - i / bufferSize);
                }
                const noise = ctx.createBufferSource();
                const filter = ctx.createBiquadFilter();
                const gain = ctx.createGain();
                noise.buffer = buffer;
                filter.type = 'bandpass';
                filter.frequency.setValueAtTime(1000, ctx.currentTime);
                filter.frequency.exponentialRampToValueAtTime(200, ctx.currentTime + 0.15);
                noise.connect(filter);
                filter.connect(gain);
                gain.connect(ctx.destination);
                gain.gain.setValueAtTime(vol, ctx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, ctx.currentTime + 0.15);
                noise.start(ctx.currentTime);
            },
            ding: function(ctx, vol) {
                const osc = ctx.createOscillator();
                const gain = ctx.createGain();
                osc.type = 'sine';
                osc.connect(gain);
                gain.connect(ctx.destination);
                osc.frequency.setValueAtTime(1200, ctx.currentTime);
                gain.gain.setValueAtTime(vol * 0.5, ctx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, ctx.currentTime + 0.4);
                osc.start(ctx.currentTime);
                osc.stop(ctx.currentTime + 0.4);
            }
        };

        function playNotificationSound() {
            if (soundSettings.sound === 'none') return;
            const vol = soundSettings.volume / 100;

            // Custom sound (base64 data)
            if (soundSettings.sound === 'custom' && soundSettings.customData) {
                try {
                    if (!customSoundAudio || customSoundAudio.src !== soundSettings.customData) {
                        customSoundAudio = new Audio(soundSettings.customData);
                    }
                    customSoundAudio.volume = vol;
                    customSoundAudio.currentTime = 0;
                    customSoundAudio.play().catch(e => console.log('Audio play failed:', e));
                } catch (e) {
                    console.log('Custom sound error:', e);
                }
                return;
            }

            // Built-in sounds
            const ctx = getAudioContext();
            if (soundLibrary[soundSettings.sound]) {
                soundLibrary[soundSettings.sound](ctx, vol);
            }
        }

        window.previewSound = function(soundName) {
            const vol = soundSettings.volume / 100;

            if (soundName === 'custom') {
                const data = soundSettings.customData;
                if (data) {
                    try {
                        const audio = new Audio(data);
                        audio.volume = vol;
                        audio.play().catch(e => console.log('Audio play failed:', e));
                    } catch (e) {
                        console.log('Custom sound error:', e);
                    }
                } else {
                    alert('Upload a custom sound file first');
                }
                return;
            }

            const ctx = getAudioContext();
            if (soundLibrary[soundName]) {
                soundLibrary[soundName](ctx, vol);
            }
        };

        window.handleSoundUpload = function(event) {
            const file = event.target.files[0];
            if (!file) return;

            if (file.size > 500000) {
                alert('Audio file too large! Max 500KB.');
                return;
            }

            const reader = new FileReader();
            reader.onload = function(e) {
                soundSettings.customData = e.target.result;
                soundSettings.customName = file.name;
                document.getElementById('customSoundName').textContent = 'â™ª ' + file.name;
                document.getElementById('customSoundName').style.display = 'block';
                document.getElementById('clearSoundBtn').style.display = 'inline-block';
                // Auto-select custom sound
                selectSound('custom');
            };
            reader.readAsDataURL(file);
        };

        window.clearCustomSound = function() {
            soundSettings.customData = '';
            soundSettings.customName = '';
            document.getElementById('customSoundFile').value = '';
            document.getElementById('customSoundName').style.display = 'none';
            document.getElementById('clearSoundBtn').style.display = 'none';
            if (soundSettings.sound === 'custom') {
                selectSound('none');
            }
        };

        window.selectSound = function(soundName) {
            soundSettings.sound = soundName;
            document.querySelectorAll('.sound-option').forEach(opt => opt.classList.remove('selected'));
            document.querySelector(`.sound-option[onclick*="'${soundName}'"]`).classList.add('selected');
        };

        window.setVolume = function(value) {
            soundSettings.volume = parseInt(value);
            document.getElementById('volumeValue').textContent = value + '%';
        };

        window.saveSoundSettings = function() {
            localStorage.setItem('sloppygram_sounds', JSON.stringify(soundSettings));

            // Broadcast sound setting globally
            broadcastGlobalSetting('sound', soundSettings.sound, soundSettings.customData || '');

            closeSettingsModal();
        };

        function loadSoundSettings() {
            const saved = localStorage.getItem('sloppygram_sounds');
            if (saved) {
                soundSettings = JSON.parse(saved);
                document.getElementById('volumeSlider').value = soundSettings.volume;
                document.getElementById('volumeValue').textContent = soundSettings.volume + '%';
                document.querySelectorAll('.sound-option').forEach(opt => opt.classList.remove('selected'));
                const selectedOpt = document.querySelector(`.sound-option[onclick*="'${soundSettings.sound}'"]`);
                if (selectedOpt) selectedOpt.classList.add('selected');
                // Load custom sound info
                if (soundSettings.customData && soundSettings.customName) {
                    document.getElementById('customSoundName').textContent = 'â™ª ' + soundSettings.customName;
                    document.getElementById('customSoundName').style.display = 'block';
                    document.getElementById('clearSoundBtn').style.display = 'inline-block';
                }
            }
        }

        // === GLOBAL SETTINGS SYNC ===
        async function broadcastGlobalSetting(settingType, settingValue, extraData = '') {
            if (!currentUser) return;

            // Broadcast via realtime channel for instant update
            if (globalSettingsChannel) {
                globalSettingsChannel.send({
                    type: 'broadcast',
                    event: 'global_setting',
                    payload: {
                        setting_type: settingType,
                        setting_value: settingValue,
                        username: profile.username,
                        extra_data: extraData
                    }
                });
            }

            // Also save to database for persistence
            try {
                await supabase.from('sloppygram_global_settings').insert({
                    setting_type: settingType,
                    setting_value: settingValue,
                    username: profile.username,
                    extra_data: extraData,
                    user_id: currentUser.id
                });
            } catch (e) {
                console.error('Error saving global setting:', e);
            }
        }

        function applyGlobalSetting(settingType, settingValue, username, extraData) {
            const notification = `ðŸŒ ${username} changed global ${settingType}!`;

            switch (settingType) {
                case 'background':
                    const msgContainer = document.getElementById('messagesContainer');
                    if (msgContainer && settingValue) {
                        msgContainer.style.backgroundImage = `url(${settingValue})`;
                        msgContainer.style.backgroundSize = 'cover';
                        msgContainer.style.backgroundPosition = 'center';
                        msgContainer.style.backgroundAttachment = 'fixed';
                        addToFeed(username, 'set global background');
                    }
                    break;

                case 'sound':
                    soundSettings.sound = settingValue;
                    if (extraData) {
                        soundSettings.customData = extraData;
                    }
                    document.querySelectorAll('.sound-option').forEach(opt => opt.classList.remove('selected'));
                    const selectedOpt = document.querySelector(`.sound-option[onclick*="'${settingValue}'"]`);
                    if (selectedOpt) selectedOpt.classList.add('selected');
                    addToFeed(username, `set global sound to ${settingValue}`);
                    // Play the sound so everyone hears it
                    playNotificationSound();
                    break;

                case 'avatar':
                    // Show notification that someone changed their avatar globally
                    addToFeed(username, 'updated their avatar');
                    break;
            }
        }

        async function loadGlobalSettings() {
            // Load most recent global settings from database
            const { data: bgData } = await supabase
                .from('sloppygram_global_settings')
                .select('*')
                .eq('setting_type', 'background')
                .order('created_at', { ascending: false })
                .limit(1);

            if (bgData && bgData[0] && bgData[0].setting_value) {
                applyGlobalSetting('background', bgData[0].setting_value, bgData[0].username, '');
            }

            const { data: soundData } = await supabase
                .from('sloppygram_global_settings')
                .select('*')
                .eq('setting_type', 'sound')
                .order('created_at', { ascending: false })
                .limit(1);

            if (soundData && soundData[0]) {
                applyGlobalSetting('sound', soundData[0].setting_value, soundData[0].username, soundData[0].extra_data);
            }
        }

        function subscribeToGlobalSettings() {
            globalSettingsChannel = supabase.channel('sloppygram-global-settings', {
                config: { broadcast: { self: false } }
            });

            globalSettingsChannel.on('broadcast', { event: 'global_setting' }, (payload) => {
                const { setting_type, setting_value, username, extra_data } = payload.payload;
                applyGlobalSetting(setting_type, setting_value, username, extra_data);
            });

            globalSettingsChannel.subscribe();
        }

        window.switchSettingsTab = function(tab) {
            document.querySelectorAll('.settings-tab').forEach(t => t.classList.remove('active'));
            document.querySelectorAll('.settings-panel').forEach(p => p.classList.remove('active'));
            document.querySelector(`.settings-tab[onclick*="'${tab}'"]`).classList.add('active');
            document.getElementById(tab + 'Panel').classList.add('active');
        };

        window.openSettingsModal = async function() {
            document.getElementById('usernameInput').value = profile.username;

            // Show current avatar preview if exists
            pendingAvatarData = profile.avatarUrl || null;
            if (pendingAvatarData) {
                document.getElementById('avatarPreviewImg').src = pendingAvatarData;
                document.getElementById('avatarPreview').style.display = 'block';
                document.getElementById('clearAvatarBtn').style.display = 'block';
            } else {
                document.getElementById('avatarPreview').style.display = 'none';
                document.getElementById('clearAvatarBtn').style.display = 'none';
            }

            // Show current bg preview if exists
            pendingBgData = profile.bgUrl || null;
            if (pendingBgData) {
                document.getElementById('bgPreviewImg').src = pendingBgData;
                document.getElementById('bgPreview').style.display = 'block';
                document.getElementById('clearBgBtn').style.display = 'block';
                document.getElementById('shareBgBtn').style.display = 'block';
                document.getElementById('setGlobalBgBtn').style.display = 'block';
            } else {
                document.getElementById('bgPreview').style.display = 'none';
                document.getElementById('clearBgBtn').style.display = 'none';
                document.getElementById('shareBgBtn').style.display = 'none';
                document.getElementById('setGlobalBgBtn').style.display = 'none';
            }

            setupAvatarGrid();
            setupColorOptions();
            loadSoundSettings();
            updateThemeUI();
            await loadGlobalBackgrounds();
            document.getElementById('settingsModal').classList.add('active');
        };

        window.closeSettingsModal = function() {
            document.getElementById('settingsModal').classList.remove('active');
            pendingAvatarData = null;
            pendingBgData = null;
        };

        // === SUPPORT MODAL SYSTEM ===
        const CRYPTO_ADDRESSES = {
            btc: 'bc1qxy2kgdygjrsqtzq2n0yrf2493p83kkfjhx0wlh',      // TODO: Replace with actual BTC address
            eth: '0x742d35Cc6634C0532925a3b844Bc9e7595f000000',     // TODO: Replace with actual ETH address
            sol: '7EcDhSYGxXyscszYEp35KHN8vvw3svAuLKTzXwCFLtV0',   // TODO: Replace with actual SOL address
            xmr: '888tNkZrPN6JsEgekjMnABU4TBzc2Dt29EPAvkRx00000'   // TODO: Replace with actual XMR address
        };

        const CRYPTO_NAMES = {
            btc: 'Bitcoin',
            eth: 'Ethereum',
            sol: 'Solana',
            xmr: 'Monero'
        };

        window.openSupportModal = function() {
            document.getElementById('supportModal').classList.add('visible');
        };

        window.closeSupportModal = function() {
            document.getElementById('supportModal').classList.remove('visible');
        };

        // Share Modal Functions - Gold Master version
        var SHARE_CONFIG = {
            baseUrl: 'https://sloppy.live/sloppygram',
            defaultText: 'Check out Sloppygram - retro cyber chatroom vibes from 1999! ðŸ–¥ï¸ðŸ’¾',
            hashtags: 'sloppygram,retro,chat'
        };

        // Get current share URL (allows for future deep linking)
        function getShareUrl(context) {
            var base = SHARE_CONFIG.baseUrl;
            // Could extend for deep links: /sloppygram?post=123 or /sloppygram#doodle/456
            if (context && context.type && context.id) {
                return base + '#' + context.type + '/' + context.id;
            }
            return base;
        }

        // Get share text based on context
        function getShareText(context) {
            if (context && context.text) {
                return context.text;
            }
            return SHARE_CONFIG.defaultText;
        }

        // === IMAGE LIGHTBOX ===
        window.openLightbox = function(src) {
            var lightbox = document.getElementById('imageLightbox');
            var img = document.getElementById('lightboxImage');
            if (lightbox && img) {
                img.src = src;
                lightbox.classList.add('active');
                document.body.style.overflow = 'hidden';
            }
        };

        window.closeLightbox = function() {
            var lightbox = document.getElementById('imageLightbox');
            if (lightbox) {
                lightbox.classList.remove('active');
                document.body.style.overflow = '';
            }
        };

        // Close lightbox on Escape key
        document.addEventListener('keydown', function(e) {
            if (e.key === 'Escape') {
                var lightbox = document.getElementById('imageLightbox');
                if (lightbox && lightbox.classList.contains('active')) {
                    closeLightbox();
                }
            }
        });

        window.openShareModal = function(context) {
            var modal = document.getElementById('shareModal');
            if (modal) modal.classList.add('visible');

            var shareUrl = getShareUrl(context);
            var shareText = getShareText(context);

            // Update share URLs with proper encoding
            var twitterBtn = document.getElementById('shareTwitterBtn');
            var redditBtn = document.getElementById('shareRedditBtn');
            var copyBtn = document.getElementById('shareCopyBtn');

            if (twitterBtn) {
                var twitterUrl = 'https://twitter.com/intent/tweet?' +
                    'text=' + encodeURIComponent(shareText) +
                    '&url=' + encodeURIComponent(shareUrl) +
                    '&hashtags=' + encodeURIComponent(SHARE_CONFIG.hashtags);
                twitterBtn.href = twitterUrl;
            }

            if (redditBtn) {
                var redditUrl = 'https://reddit.com/submit?' +
                    'url=' + encodeURIComponent(shareUrl) +
                    '&title=' + encodeURIComponent(shareText);
                redditBtn.href = redditUrl;
            }

            // Store URL for copy button
            if (copyBtn) {
                copyBtn.setAttribute('data-share-url', shareUrl);
            }
        };

        window.closeShareModal = function() {
            var modal = document.getElementById('shareModal');
            if (modal) modal.classList.remove('visible');
        };

        window.copyShareLink = async function() {
            var copyBtn = document.getElementById('shareCopyBtn');

            // Get URL from data attribute or fall back to default
            var shareUrl = (copyBtn && copyBtn.getAttribute('data-share-url')) || SHARE_CONFIG.baseUrl;

            try {
                if (navigator.clipboard && navigator.clipboard.writeText) {
                    await navigator.clipboard.writeText(shareUrl);
                } else {
                    // Fallback for older browsers
                    var textarea = document.createElement('textarea');
                    textarea.value = shareUrl;
                    textarea.style.position = 'fixed';
                    textarea.style.opacity = '0';
                    textarea.style.left = '-9999px';
                    document.body.appendChild(textarea);
                    textarea.focus();
                    textarea.select();

                    var success = false;
                    try {
                        success = document.execCommand('copy');
                    } catch (e) {
                        success = false;
                    }
                    document.body.removeChild(textarea);

                    if (!success) {
                        throw new Error('execCommand failed');
                    }
                }

                // Show copied state
                if (copyBtn) {
                    copyBtn.classList.add('copied');
                    copyBtn.innerHTML = '<span class="share-btn-icon">âœ“</span><span>Copied!</span>';
                    setTimeout(function() {
                        copyBtn.classList.remove('copied');
                        copyBtn.innerHTML = '<span class="share-btn-icon">ðŸ”—</span><span>Copy Link</span>';
                    }, 2000);
                }

                showToast('Link copied to clipboard!', 'success');
            } catch (err) {
                console.error('[copyShareLink] Failed:', err);
                showToast('Failed to copy link', 'error');
            }
        };

        window.copyCryptoAddress = async function(crypto) {
            const address = CRYPTO_ADDRESSES[crypto];
            if (!address) return;

            try {
                await navigator.clipboard.writeText(address);
                showCopiedToast(crypto);
            } catch (err) {
                // Fallback for older browsers
                const textarea = document.createElement('textarea');
                textarea.value = address;
                textarea.style.position = 'fixed';
                textarea.style.opacity = '0';
                document.body.appendChild(textarea);
                textarea.select();
                try {
                    document.execCommand('copy');
                    showCopiedToast(crypto);
                } catch (e) {
                    alert('Failed to copy. Address: ' + address);
                }
                document.body.removeChild(textarea);
            }
        };

        // Keep old function for backwards compatibility
        window.copyBtcAddress = function() {
            copyCryptoAddress('btc');
        };

        function showCopiedToast(crypto = 'btc') {
            // Remove existing toasts
            document.querySelectorAll('.copied-toast').forEach(t => t.remove());

            const name = CRYPTO_NAMES[crypto] || 'Address';
            const toast = document.createElement('div');
            toast.className = 'copied-toast';
            toast.innerHTML = `âœ“ ${name} address copied!`;
            document.body.appendChild(toast);

            setTimeout(() => {
                if (toast.parentNode) toast.remove();
            }, 2500);
        }

        window.handleAvatarUpload = function(event) {
            const file = event.target.files[0];
            if (!file) return;

            if (file.size > 500000) {
                alert('Image too large! Max 500KB.');
                return;
            }

            const reader = new FileReader();
            reader.onload = function(e) {
                pendingAvatarData = e.target.result;
                document.getElementById('avatarPreviewImg').src = pendingAvatarData;
                document.getElementById('avatarPreview').style.display = 'block';
                document.getElementById('clearAvatarBtn').style.display = 'block';
            };
            reader.readAsDataURL(file);
        };

        window.clearAvatarUpload = function() {
            pendingAvatarData = null;
            document.getElementById('avatarFileInput').value = '';
            document.getElementById('avatarPreview').style.display = 'none';
            document.getElementById('clearAvatarBtn').style.display = 'none';
        };

        window.handleBgUpload = function(event) {
            const file = event.target.files[0];
            if (!file) return;

            if (file.size > 1000000) {
                alert('Image too large! Max 1MB for backgrounds.');
                return;
            }

            const reader = new FileReader();
            reader.onload = function(e) {
                pendingBgData = e.target.result;
                document.getElementById('bgPreviewImg').src = pendingBgData;
                document.getElementById('bgPreview').style.display = 'block';
                document.getElementById('clearBgBtn').style.display = 'block';
                document.getElementById('shareBgBtn').style.display = 'block';
                document.getElementById('setGlobalBgBtn').style.display = 'block';
            };
            reader.readAsDataURL(file);
        };

        window.clearBgUpload = function() {
            pendingBgData = null;
            document.getElementById('bgFileInput').value = '';
            document.getElementById('bgPreview').style.display = 'none';
            document.getElementById('clearBgBtn').style.display = 'none';
            document.getElementById('shareBgBtn').style.display = 'none';
            document.getElementById('setGlobalBgBtn').style.display = 'none';
        };

        // Global Backgrounds
        async function loadGlobalBackgrounds() {
            const { data } = await supabase
                .from('sloppygram_global_backgrounds')
                .select('*')
                .order('created_at', { ascending: false })
                .limit(20);

            globalBackgrounds = data || [];
            renderGlobalBackgrounds();
        }

        function renderGlobalBackgrounds() {
            const grid = document.getElementById('globalBgGrid');
            grid.innerHTML = globalBackgrounds.map(bg => {
                const safeBgData = sanitizeUrl(bg.image_data);
                return `
                <div class="global-bg-item ${pendingBgData === bg.image_data ? 'selected' : ''}"
                     onclick="selectGlobalBg('${bg.id}')"
                     title="${escapeHtml(bg.name || 'Shared by ' + bg.username)}">
                    <img src="${safeBgData}" alt="${escapeHtml(bg.name || 'Background')}">
                </div>`;
            }).join('') + `
                <div class="global-bg-item global-bg-upload" onclick="document.getElementById('bgFileInput').click()" title="Upload new">+</div>
            `;
        }

        window.selectGlobalBg = function(bgId) {
            const bg = globalBackgrounds.find(b => b.id == bgId);
            if (!bg) return;

            pendingBgData = bg.image_data;
            document.getElementById('bgPreviewImg').src = pendingBgData;
            document.getElementById('bgPreview').style.display = 'block';
            document.getElementById('clearBgBtn').style.display = 'block';
            document.getElementById('shareBgBtn').style.display = 'none'; // Already shared
            document.getElementById('setGlobalBgBtn').style.display = 'block'; // Can still set for everyone

            renderGlobalBackgrounds();
        };

        window.shareBackground = async function() {
            if (!pendingBgData || !currentUser) return;

            const name = prompt('Give your background a name:', 'My Background');
            if (!name) return;

            const { error } = await supabase
                .from('sloppygram_global_backgrounds')
                .insert({
                    image_data: pendingBgData,
                    username: profile.username,
                    name: name,
                    user_id: currentUser.id
                });

            if (error) {
                console.error('Error sharing background:', error);
                alert('Failed to share background');
                return;
            }

            alert('Background shared with everyone!');
            document.getElementById('shareBgBtn').style.display = 'none';
            await loadGlobalBackgrounds();
        };

        // Broadcast background to ALL users in real-time
        window.setGlobalBackground = function() {
            if (!pendingBgData || !realtimeChannel) return;

            realtimeChannel.send({
                type: 'broadcast',
                event: 'global_background',
                payload: {
                    image_data: pendingBgData,
                    username: profile.username
                }
            });

            // Also apply to self (chat container only)
            const msgContainer = document.getElementById('messagesContainer');
            if (msgContainer) {
                msgContainer.style.backgroundImage = `url(${pendingBgData})`;
                msgContainer.style.backgroundSize = 'cover';
                msgContainer.style.backgroundPosition = 'center';
                msgContainer.style.backgroundAttachment = 'fixed';
                msgContainer.style.backgroundRepeat = 'no-repeat';
            }

            addToFeed(profile.username, 'set a new chat background');
        };

        // Message opacity control
        window.setMessageOpacity = function(value) {
            const opacity = value / 100;
            document.documentElement.style.setProperty('--msg-opacity', opacity);
            document.getElementById('opacityValue').textContent = value + '%';
            localStorage.setItem('sloppygram_msg_opacity', value);
        };

        function loadMessageOpacity() {
            const saved = localStorage.getItem('sloppygram_msg_opacity');
            if (saved !== null) {
                const value = parseInt(saved);
                document.documentElement.style.setProperty('--msg-opacity', value / 100);
                const slider = document.getElementById('msgOpacitySlider');
                const display = document.getElementById('opacityValue');
                if (slider) slider.value = value;
                if (display) display.textContent = value + '%';
            }
        }

        // Theme color settings
        let themeSettings = {
            msgColor: '10, 10, 15',
            msgOwnColor: '90, 112, 96',
            accentColor: '#7c9885',
            highlightColor: '#c9a87c',
            panelBg: '#12121a'
        };

        window.selectMsgColor = function(color) {
            themeSettings.msgColor = color;
            document.documentElement.style.setProperty('--msg-color', color);
            document.querySelectorAll('#msgColorGrid .msg-color-option').forEach(opt => opt.classList.remove('selected'));
            var msgColorEl = document.querySelector('#msgColorGrid .msg-color-option[onclick*="\'' + color + '\'"]');
            if (msgColorEl) msgColorEl.classList.add('selected');
        };

        window.selectMsgOwnColor = function(color) {
            themeSettings.msgOwnColor = color;
            document.documentElement.style.setProperty('--msg-own-color', color);
            document.querySelectorAll('#msgOwnColorGrid .msg-color-option').forEach(opt => opt.classList.remove('selected'));
            var msgOwnColorEl = document.querySelector('#msgOwnColorGrid .msg-color-option[onclick*="\'' + color + '\'"]');
            if (msgOwnColorEl) msgOwnColorEl.classList.add('selected');
        };

        window.selectAccentColor = function(color) {
            themeSettings.accentColor = color;
            document.documentElement.style.setProperty('--accent', color);
            // Generate lighter and dimmer variants
            const hex = color.replace('#', '');
            const r = parseInt(hex.substr(0, 2), 16);
            const g = parseInt(hex.substr(2, 2), 16);
            const b = parseInt(hex.substr(4, 2), 16);
            const light = `rgb(${Math.min(255, r + 40)}, ${Math.min(255, g + 40)}, ${Math.min(255, b + 40)})`;
            const dim = `rgb(${Math.max(0, r - 30)}, ${Math.max(0, g - 30)}, ${Math.max(0, b - 30)})`;
            document.documentElement.style.setProperty('--accent-light', light);
            document.documentElement.style.setProperty('--accent-dim', dim);
            document.querySelectorAll('#accentColorGrid .msg-color-option').forEach(opt => opt.classList.remove('selected'));
            var accentColorEl = document.querySelector('#accentColorGrid .msg-color-option[onclick*="\'' + color + '\'"]');
            if (accentColorEl) accentColorEl.classList.add('selected');
        };

        window.selectHighlightColor = function(color) {
            themeSettings.highlightColor = color;
            document.documentElement.style.setProperty('--highlight', color);
            document.querySelectorAll('#highlightColorGrid .msg-color-option').forEach(opt => opt.classList.remove('selected'));
            var highlightColorEl = document.querySelector('#highlightColorGrid .msg-color-option[onclick*="\'' + color + '\'"]');
            if (highlightColorEl) highlightColorEl.classList.add('selected');
        };

        window.selectPanelBg = function(color) {
            themeSettings.panelBg = color;
            document.documentElement.style.setProperty('--panel-bg', color);
            // Also update dark-bg to be slightly darker than panel-bg
            const hex = color.replace('#', '');
            const r = Math.max(0, parseInt(hex.substr(0, 2), 16) - 8);
            const g = Math.max(0, parseInt(hex.substr(2, 2), 16) - 8);
            const b = Math.max(0, parseInt(hex.substr(4, 2), 16) - 5);
            const darkBg = `rgb(${r}, ${g}, ${b})`;
            document.documentElement.style.setProperty('--dark-bg', darkBg);
            // Also update border color to complement the panel
            const br = Math.min(255, parseInt(hex.substr(0, 2), 16) + 24);
            const bg = Math.min(255, parseInt(hex.substr(2, 2), 16) + 24);
            const bb = Math.min(255, parseInt(hex.substr(4, 2), 16) + 27);
            document.documentElement.style.setProperty('--border-color', `rgb(${br}, ${bg}, ${bb})`);
            document.querySelectorAll('#panelBgGrid .msg-color-option').forEach(opt => opt.classList.remove('selected'));
            var panelBgEl = document.querySelector('#panelBgGrid .msg-color-option[onclick*="\'' + color + '\'"]');
            if (panelBgEl) panelBgEl.classList.add('selected');
        };

        window.saveThemeSettings = function() {
            localStorage.setItem('sloppygram_theme', JSON.stringify(themeSettings));
            localStorage.setItem('sloppygram_msg_opacity', document.getElementById('msgOpacitySlider').value);
            closeSettingsModal();
        };

        window.resetTheme = function() {
            if (!confirm('Reset all theme settings to default?')) return;
            themeSettings = {
                msgColor: '10, 10, 15',
                msgOwnColor: '90, 112, 96',
                accentColor: '#7c9885',
                highlightColor: '#c9a87c',
                panelBg: '#12121a'
            };
            document.documentElement.style.setProperty('--msg-color', themeSettings.msgColor);
            document.documentElement.style.setProperty('--msg-own-color', themeSettings.msgOwnColor);
            document.documentElement.style.setProperty('--accent', themeSettings.accentColor);
            document.documentElement.style.setProperty('--accent-light', '#a8c4b0');
            document.documentElement.style.setProperty('--accent-dim', '#5a7060');
            document.documentElement.style.setProperty('--highlight', themeSettings.highlightColor);
            document.documentElement.style.setProperty('--panel-bg', themeSettings.panelBg);
            document.documentElement.style.setProperty('--dark-bg', '#0a0a0f');
            document.documentElement.style.setProperty('--border-color', '#2a2a35');
            localStorage.removeItem('sloppygram_theme');
            updateThemeUI();
        };

        function loadThemeSettings() {
            const saved = localStorage.getItem('sloppygram_theme');
            if (saved) {
                themeSettings = JSON.parse(saved);
                document.documentElement.style.setProperty('--msg-color', themeSettings.msgColor);
                document.documentElement.style.setProperty('--msg-own-color', themeSettings.msgOwnColor);
                if (themeSettings.accentColor) {
                    selectAccentColor(themeSettings.accentColor);
                }
                if (themeSettings.highlightColor) {
                    document.documentElement.style.setProperty('--highlight', themeSettings.highlightColor);
                }
                if (themeSettings.panelBg) {
                    // Use selectPanelBg to properly update all related variables
                    selectPanelBg(themeSettings.panelBg);
                }
            }
        }

        function updateThemeUI() {
            // Update color selection UI
            document.querySelectorAll('#msgColorGrid .msg-color-option').forEach(opt => opt.classList.remove('selected'));
            const msgColorOpt = document.querySelector(`#msgColorGrid .msg-color-option[onclick*="'${themeSettings.msgColor}'"]`);
            if (msgColorOpt) msgColorOpt.classList.add('selected');

            document.querySelectorAll('#msgOwnColorGrid .msg-color-option').forEach(opt => opt.classList.remove('selected'));
            const ownColorOpt = document.querySelector(`#msgOwnColorGrid .msg-color-option[onclick*="'${themeSettings.msgOwnColor}'"]`);
            if (ownColorOpt) ownColorOpt.classList.add('selected');

            document.querySelectorAll('#accentColorGrid .msg-color-option').forEach(opt => opt.classList.remove('selected'));
            const accentOpt = document.querySelector(`#accentColorGrid .msg-color-option[onclick*="'${themeSettings.accentColor}'"]`);
            if (accentOpt) accentOpt.classList.add('selected');

            document.querySelectorAll('#highlightColorGrid .msg-color-option').forEach(opt => opt.classList.remove('selected'));
            const highlightOpt = document.querySelector(`#highlightColorGrid .msg-color-option[onclick*="'${themeSettings.highlightColor}'"]`);
            if (highlightOpt) highlightOpt.classList.add('selected');

            document.querySelectorAll('#panelBgGrid .msg-color-option').forEach(opt => opt.classList.remove('selected'));
            const panelOpt = document.querySelector(`#panelBgGrid .msg-color-option[onclick*="'${themeSettings.panelBg}'"]`);
            if (panelOpt) panelOpt.classList.add('selected');
        }

        window.saveProfile = function() {
            const username = document.getElementById('usernameInput').value.trim() || 'Anon' + Math.floor(Math.random() * 9999);
            profile.username = username;
            profile.avatarUrl = pendingAvatarData || '';
            profile.bgUrl = pendingBgData || '';
            localStorage.setItem('sloppygram_profile', JSON.stringify(profile));
            applyCustomBackground();

            // Broadcast background globally if set
            if (profile.bgUrl) {
                broadcastGlobalSetting('background', profile.bgUrl);
            }
            // Broadcast avatar change globally if set
            if (profile.avatarUrl) {
                broadcastGlobalSetting('avatar', profile.avatarUrl);
            }

            closeSettingsModal();
        };

        window.resetProfile = function() {
            if (!confirm('Reset all profile data? This cannot be undone.')) return;
            localStorage.removeItem('sloppygram_profile');
            profile = {
                username: 'Anon' + Math.floor(Math.random() * 9999),
                avatar: AVATARS[Math.floor(Math.random() * AVATARS.length)],
                color: COLORS[Math.floor(Math.random() * COLORS.length)],
                avatarUrl: '',
                bgUrl: ''
            };
            pendingAvatarData = null;
            pendingBgData = null;
            const msgContainer = document.getElementById('messagesContainer');
            if (msgContainer) msgContainer.style.backgroundImage = '';
            closeSettingsModal();
        };

        function applyCustomBackground() {
            const msgContainer = document.getElementById('messagesContainer');
            if (!msgContainer) return;

            if (profile.bgUrl) {
                msgContainer.style.backgroundImage = `url(${profile.bgUrl})`;
                msgContainer.style.backgroundSize = 'cover';
                msgContainer.style.backgroundPosition = 'center';
                msgContainer.style.backgroundAttachment = 'fixed';
                msgContainer.style.backgroundRepeat = 'no-repeat';
            } else {
                msgContainer.style.backgroundImage = '';
            }
        }

        // Drawing modal
        window.openDrawingModal = function() {
            clearCanvas();
            document.getElementById('drawingModal').classList.add('active');

            // Add keyboard shortcuts for undo/redo when modal is open
            document.addEventListener('keydown', handleDrawingKeyboard);
        };

        window.closeDrawingModal = function() {
            document.getElementById('drawingModal').classList.remove('active');
            document.removeEventListener('keydown', handleDrawingKeyboard);
        };

        function handleDrawingKeyboard(e) {
            // Only handle if drawing modal is open
            if (!document.getElementById('drawingModal').classList.contains('active')) return;

            if (e.ctrlKey || e.metaKey) {
                if (e.key === 'z' && !e.shiftKey) {
                    e.preventDefault();
                    undoCanvas();
                } else if (e.key === 'y' || (e.key === 'z' && e.shiftKey)) {
                    e.preventDefault();
                    redoCanvas();
                }
            }
        }

        // === POSTS FUNCTIONALITY ===

        window.switchView = function(view) {
            currentView = view;
            document.querySelectorAll('.view-tab').forEach(tab => {
                tab.classList.toggle('active', tab.dataset.view === view);
            });
            document.getElementById('messagesContainer').classList.toggle('hidden', view !== 'chat');
            document.getElementById('postsContainer').classList.toggle('active', view === 'posts');
            document.getElementById('doodlesContainer').classList.toggle('active', view === 'doodles');
            document.getElementById('manifestoContainer').classList.toggle('active', view === 'manifesto');
            document.getElementById('collabContainer').classList.toggle('active', view === 'collab');
            document.getElementById('feedbackContainer').classList.toggle('active', view === 'feedback');
            safeSetDisplay('chatInputArea', view === 'chat' ? 'block' : 'none');
            document.getElementById('createPostBtn').classList.toggle('visible', view === 'posts');

            if (view === 'posts') {
                loadPosts();
            }
            if (view === 'doodles') {
                loadDoodleLeaderboard();
            }
            if (view === 'manifesto') {
                loadManifestos();
            }
            if (view === 'collab') {
                initCollabCanvas();
            }
            if (view === 'feedback') {
                loadFeedback();
            }
        };

        async function loadPosts() {
            // Reset pagination state for fresh load
            postsPage = 0;
            postsHasMore = true;
            postsLoading = false;

            const { data, error } = await supabase
                .from('sloppygram_posts')
                .select('*')
                .order('created_at', { ascending: false })
                .range(0, PAGE_SIZE - 1);

            if (error) {
                console.error('Error loading posts:', error);
                return;
            }

            posts = data || [];
            window.cachedPosts = posts; // Expose to global for Tag Explorer
            const postIds = posts.map(p => p.id);

            // Batch all related queries in parallel to solve N+1 problem
            const [votesResult, commentsResult, reactionsResult, tagsResult, threadsResult] = await Promise.all([
                supabase.from('sloppygram_post_likes').select('post_id, username, vote_type'),
                postIds.length > 0
                    ? supabase.from('sloppygram_post_comments').select('*').in('post_id', postIds).order('created_at', { ascending: true })
                    : { data: [] },
                postIds.length > 0
                    ? supabase.from('sloppygram_post_reactions').select('*').in('post_id', postIds)
                    : { data: [] },
                postIds.length > 0
                    ? supabase.from('sloppygram_post_tags').select('*').in('post_id', postIds)
                    : { data: [] },
                postIds.length > 0
                    ? supabase.from('sloppygram_comment_threads').select('*').eq('comment_type', 'post').in('post_id', postIds)
                    : { data: [] }
            ]);

            // Process votes
            postVotes = {};
            myPostVotes = {};
            (votesResult.data || []).forEach(vote => {
                postVotes[vote.post_id] = (postVotes[vote.post_id] || 0) + (vote.vote_type || 1);
                if (vote.username === profile.username) {
                    myPostVotes[vote.post_id] = vote.vote_type || 1;
                }
            });

            // Update post.likes_count with net vote scores
            posts.forEach(p => {
                p.likes_count = postVotes[p.id] || 0;
            });

            // Process comments
            postComments = {};
            (commentsResult.data || []).forEach(comment => {
                if (!postComments[comment.post_id]) postComments[comment.post_id] = [];
                postComments[comment.post_id].push(comment);
            });

            // Process reactions
            postReactions = {};
            myReactions = {};
            (reactionsResult.data || []).forEach(r => {
                if (!postReactions[r.post_id]) postReactions[r.post_id] = {};
                postReactions[r.post_id][r.emoji] = (postReactions[r.post_id][r.emoji] || 0) + 1;
                if (r.username === profile.username) {
                    if (!myReactions[r.post_id]) myReactions[r.post_id] = new Set();
                    myReactions[r.post_id].add(r.emoji);
                }
            });

            // Process tags
            postTags = {};
            (tagsResult.data || []).forEach(t => {
                if (!postTags[t.post_id]) postTags[t.post_id] = [];
                postTags[t.post_id].push({ tag: t.tag, parent_tag: t.parent_tag });
            });

            // Process comment threads
            (threadsResult.data || []).forEach(t => {
                commentThreads[t.comment_id] = t.parent_comment_id;
            });

            // Update pagination state
            postsHasMore = posts.length === PAGE_SIZE;
            postsPage = 1;

            renderPosts();
        }

        function renderPosts() {
            const container = document.getElementById('postsContainer');
            const emptyState = document.getElementById('postsEmptyState');

            if (posts.length === 0) {
                if (emptyState) emptyState.style.display = 'block';
                if (container) container.innerHTML = '';
                if (container && emptyState) container.appendChild(emptyState);
                return;
            }

            if (emptyState) emptyState.style.display = 'none';
            container.innerHTML = posts.map(post => renderPostCard(post)).join('');

            // Trigger lazy loading for new images
            lazyLoadNewImages();
        }

        // Render threaded comments with replies
        function renderThreadedComments(comments, postId, type = 'post') {
            // Build a map of comment threads
            const threads = {}; // parentId -> [children]
            const rootComments = [];

            comments.forEach(c => {
                const parentId = commentThreads[c.id];
                if (parentId) {
                    if (!threads[parentId]) threads[parentId] = [];
                    threads[parentId].push(c);
                } else {
                    rootComments.push(c);
                }
            });

            function renderComment(c, depth = 0) {
                const time = c.created_at ? new Date(c.created_at).toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'}) : '';
                const replies = threads[c.id] || [];
                const isNested = depth > 0;
                const isOwnComment = c.username === profile.username;
                const myVote = myCommentVotes[c.id] || 0;
                const voteScore = commentVotes[c.id] || 0;
                const scoreClass = voteScore > 0 ? 'positive' : voteScore < 0 ? 'negative' : '';

                return `
                    <div class="comment ${isNested ? 'comment-thread' : ''}" data-comment-id="${c.id}" data-depth="${depth}">
                        <span class="comment-avatar">${c.avatar || 'ðŸ‘¤'}</span>
                        <div class="comment-content">
                            <span class="comment-username username-clickable" onclick="showProfileCard('${escapeHtml(c.username)}', event)">${escapeHtml(c.username)}</span>
                            <span class="comment-time">${time}</span>
                            <div class="comment-text">${escapeHtml(c.content)}</div>
                            <div class="comment-actions">
                                <button class="comment-reply-btn" onclick="startReply(${postId}, ${c.id}, '${escapeHtml(c.username)}', '${type}')">â†© reply</button>
                                <span class="comment-vote-controls" data-comment-id="${c.id}">
                                    <button class="comment-vote-btn upvote ${myVote === 1 ? 'active' : ''} ${isOwnComment ? 'disabled' : ''}"
                                        onclick="${isOwnComment ? '' : `voteComment('${c.id}', 1, '${escapeHtml(c.username)}')`}"
                                        title="${isOwnComment ? 'Cannot vote on own comment' : 'Upvote'}">â–²</button>
                                    <span class="comment-vote-score ${scoreClass}">${voteScore}</span>
                                    <button class="comment-vote-btn downvote ${myVote === -1 ? 'active' : ''} ${isOwnComment ? 'disabled' : ''}"
                                        onclick="${isOwnComment ? '' : `voteComment('${c.id}', -1, '${escapeHtml(c.username)}')`}"
                                        title="${isOwnComment ? 'Cannot vote on own comment' : 'Downvote'}">â–¼</button>
                                </span>
                            </div>
                        </div>
                        ${replies.length > 0 ? `<div class="comment-replies">${replies.map(r => renderComment(r, depth + 1)).join('')}</div>` : ''}
                    </div>
                `;
            }

            return rootComments.map(c => renderComment(c, 0)).join('');
        }

        function renderPostCard(post) {
            const time = new Date(post.created_at).toLocaleString();
            const myVote = myPostVotes[post.id] || 0;
            const comments = postComments[post.id] || [];
            const voteScore = postVotes[post.id] || 0;
            const reactions = postReactions[post.id] || {};
            const myPostReactions = myReactions[post.id] || new Set();
            var currentUserId = (currentUser && currentUser.id) ? currentUser.id : null;
            const isOwnPost = post.user_id === currentUserId || post.username === profile.username;
            const scoreClass = voteScore > 0 ? 'positive' : voteScore < 0 ? 'negative' : 'neutral';

            const safeAvatarUrl = sanitizeUrl(post.avatar_url);
            const avatarContent = safeAvatarUrl
                ? `<img src="${safeAvatarUrl}" style="width:100%;height:100%;object-fit:cover;border-radius:50%;">`
                : (post.avatar || 'ðŸ‘¤');

            const safeImageUrl = sanitizeUrl(post.image_url);
            const safeImageData = sanitizeUrl(post.image_data);
            const imageHtml = safeImageUrl
                ? `<img class="post-image lazy-image" loading="lazy" data-src="${safeImageUrl}" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.style.display='none'">`
                : (safeImageData ? `<img class="post-image" loading="lazy" src="${safeImageData}">` : '');

            const commentsHtml = renderThreadedComments(comments, post.id, 'post');

            // Reply indicator if replying to a comment on this post
            const replyIndicatorHtml = (replyingTo && replyingTo.postId === post.id && replyingTo.type === 'post')
                ? `<div class="reply-indicator">
                    <span>â†© Replying to <strong>${escapeHtml(replyingTo.username)}</strong></span>
                    <button class="cancel-reply" onclick="cancelReply()">âœ•</button>
                </div>`
                : '';

            // Build reactions HTML
            const reactionsHtml = Object.entries(reactions)
                .sort((a, b) => b[1] - a[1])
                .map(([emoji, count]) => {
                    const isActive = myPostReactions.has(emoji);
                    return `<button class="reaction-btn ${isActive ? 'active' : ''}" onclick="toggleReaction(${post.id}, '${emoji}')">
                        ${emoji} <span class="reaction-count">${count}</span>
                    </button>`;
                }).join('');

            const reactionPickerHtml = REACTION_EMOJIS.map(emoji =>
                `<button onclick="toggleReaction(${post.id}, '${emoji}')">${emoji}</button>`
            ).join('');

            // Build tags HTML
            const tags = postTags[post.id] || [];
            const tagsHtml = tags.length > 0 ? `
                <div class="post-tags">
                    ${tags.map(t => {
                        const isNested = t.parent_tag != null;
                        const displayTag = isNested ? `${t.parent_tag}/${t.tag}` : t.tag;
                        return `<span class="tag ${isNested ? 'nested' : ''}" onclick="filterByTag('${escapeHtml(displayTag)}')">#${escapeHtml(displayTag)}</span>`;
                    }).join('')}
                </div>
            ` : '';

            return `
                <div class="post-card" data-post-id="${post.id}">
                    <div class="post-header">
                        <div class="post-avatar">${avatarContent}</div>
                        <span class="post-username username-clickable" onclick="showProfileCard('${escapeHtml(post.username || 'Anonymous')}', event)">${escapeHtml(post.username || 'Anonymous')}</span>
                        <span class="post-time">${time}</span>
                        ${isOwnPost ? `<button class="post-delete-btn" onclick="deletePost(${post.id})" title="Delete post">delete</button>` : ''}
                    </div>
                    ${imageHtml}
                    ${post.caption ? `<div class="post-caption">${escapeHtml(post.caption)}</div>` : ''}
                    <div class="post-actions">
                        <div class="vote-controls" data-post-id="${post.id}">
                            <button class="vote-btn upvote ${myVote === 1 ? 'active' : ''} ${isOwnPost ? 'disabled' : ''}"
                                onclick="${isOwnPost ? '' : `votePost(${post.id}, 1)`}"
                                title="${isOwnPost ? 'Cannot vote on own post' : 'Upvote'}">â–²</button>
                            <span class="vote-score ${scoreClass}" id="post-score-${post.id}">${voteScore}</span>
                            <button class="vote-btn downvote ${myVote === -1 ? 'active' : ''} ${isOwnPost ? 'disabled' : ''}"
                                onclick="${isOwnPost ? '' : `votePost(${post.id}, -1)`}"
                                title="${isOwnPost ? 'Cannot vote on own post' : 'Downvote'}">â–¼</button>
                        </div>
                        <button class="post-action-btn" onclick="focusComment(${post.id})">
                            ðŸ’¬ ${comments.length}
                        </button>
                        ${post.caption ? `<button class="post-action-btn tts-btn" id="tts-btn-${post.id}" onclick="speakPost(${post.id})" title="Read aloud">ðŸ”Š</button>` : ''}
                    </div>
                    <div class="post-reactions" id="reactions-${post.id}">
                        ${reactionsHtml}
                        <div style="position:relative;display:inline-block;">
                            <button class="add-reaction-btn" onclick="toggleReactionPicker(${post.id})">+ ðŸ˜€</button>
                            <div class="reaction-picker" id="picker-${post.id}">
                                ${reactionPickerHtml}
                            </div>
                        </div>
                    </div>
                    ${tagsHtml}
                    <div class="post-comments" id="comments-${post.id}">
                        ${commentsHtml}
                    </div>
                    ${replyIndicatorHtml}
                    <div class="comment-input-row">
                        <input class="comment-input" id="comment-input-${post.id}" placeholder="${replyingTo && replyingTo.postId === post.id ? 'Write a reply...' : 'Add a comment...'}" onkeydown="if(event.key==='Enter')addComment(${post.id})">
                        <button class="comment-send" onclick="addComment(${post.id})">POST</button>
                    </div>
                </div>
            `;
        }

        window.deletePost = async function(postId) {
            if (!currentUser) return;
            if (!confirm('Delete this post? This cannot be undone.')) return;

            const { error } = await supabase
                .from('sloppygram_posts')
                .delete()
                .eq('id', postId)
                .eq('user_id', currentUser.id);

            if (error) {
                console.error('Error deleting post:', error);
                alert('Could not delete post');
                return;
            }

            // Remove from local state
            posts = posts.filter(p => p.id !== postId);
            delete postComments[postId];
            delete postReactions[postId];
            delete postLikes[postId];
            delete postTags[postId];
            renderPosts();
        };

        // Text-to-speech for posts
        var currentSpeech = null;
        var currentSpeakingPostId = null;

        window.speakPost = function(postId) {
            var post = posts.find(function(p) { return p.id === postId; });
            if (!post || !post.caption) return;

            // If already speaking this post, stop it
            if (currentSpeakingPostId === postId && window.speechSynthesis.speaking) {
                window.speechSynthesis.cancel();
                var btn = document.getElementById('tts-btn-' + postId);
                if (btn) btn.classList.remove('speaking');
                currentSpeakingPostId = null;
                return;
            }

            // Stop any current speech
            if (window.speechSynthesis.speaking) {
                window.speechSynthesis.cancel();
                if (currentSpeakingPostId) {
                    var oldBtn = document.getElementById('tts-btn-' + currentSpeakingPostId);
                    if (oldBtn) oldBtn.classList.remove('speaking');
                }
            }

            // Create and speak the utterance
            var utterance = new SpeechSynthesisUtterance(post.caption);
            utterance.rate = 1.0;
            utterance.pitch = 1.0;

            // Update button state
            var btn = document.getElementById('tts-btn-' + postId);
            if (btn) btn.classList.add('speaking');
            currentSpeakingPostId = postId;

            utterance.onend = function() {
                if (btn) btn.classList.remove('speaking');
                currentSpeakingPostId = null;
            };

            utterance.onerror = function() {
                if (btn) btn.classList.remove('speaking');
                currentSpeakingPostId = null;
            };

            window.speechSynthesis.speak(utterance);
        };

        // Text-to-speech for chat messages
        var currentSpeakingMsgId = null;

        window.speakMessage = function(msgId) {
            var allMessages = window.cachedMessages || [];
            var msg = allMessages.find(function(m) { return String(m.id) === String(msgId); });
            if (!msg || !msg.content) return;

            // Strip hacker markup tags for clean speech
            var cleanText = msg.content
                .replace(/\[shake\]|\[\/shake\]/gi, '')
                .replace(/\[rainbow\]|\[\/rainbow\]/gi, '')
                .replace(/\[matrix\]|\[\/matrix\]/gi, '')
                .replace(/\[glitch\]|\[\/glitch\]/gi, '')
                .replace(/\[pulse\]|\[\/pulse\]/gi, '')
                .replace(/\[wave\]|\[\/wave\]/gi, '')
                .replace(/\[spoiler\]|\[\/spoiler\]/gi, '');

            // If already speaking this message, stop it
            if (currentSpeakingMsgId === msgId && window.speechSynthesis.speaking) {
                window.speechSynthesis.cancel();
                var btn = document.getElementById('msg-tts-' + msgId);
                if (btn) btn.classList.remove('speaking');
                currentSpeakingMsgId = null;
                return;
            }

            // Stop any current speech (posts or messages)
            if (window.speechSynthesis.speaking) {
                window.speechSynthesis.cancel();
                if (currentSpeakingMsgId) {
                    var oldMsgBtn = document.getElementById('msg-tts-' + currentSpeakingMsgId);
                    if (oldMsgBtn) oldMsgBtn.classList.remove('speaking');
                }
                if (currentSpeakingPostId) {
                    var oldPostBtn = document.getElementById('tts-btn-' + currentSpeakingPostId);
                    if (oldPostBtn) oldPostBtn.classList.remove('speaking');
                    currentSpeakingPostId = null;
                }
            }

            // Create and speak the utterance
            var utterance = new SpeechSynthesisUtterance(cleanText);
            utterance.rate = 1.0;
            utterance.pitch = 1.0;

            // Update button state
            var btn = document.getElementById('msg-tts-' + msgId);
            if (btn) btn.classList.add('speaking');
            currentSpeakingMsgId = msgId;

            utterance.onend = function() {
                if (btn) btn.classList.remove('speaking');
                currentSpeakingMsgId = null;
            };

            utterance.onerror = function() {
                if (btn) btn.classList.remove('speaking');
                currentSpeakingMsgId = null;
            };

            window.speechSynthesis.speak(utterance);
        };

        window.votePost = async function(postId, voteType) {
            if (!currentUser) return;

            // Rate limiting check
            const rateCheck = checkRateLimit('vote');
            if (!rateCheck.allowed) {
                showToast(rateCheck.message, 'warning');
                return;
            }
            recordAction('vote');

            // Check if own post
            const post = posts.find(p => p.id === postId);
            if (post && (post.user_id === currentUser.id || post.username === profile.username)) return;

            const currentVote = myPostVotes[postId] || 0;

            if (currentVote === voteType) {
                // Remove vote if clicking same button
                await supabase
                    .from('sloppygram_post_likes')
                    .delete()
                    .eq('post_id', postId)
                    .eq('user_id', currentUser.id);

                myPostVotes[postId] = 0;
                postVotes[postId] = (postVotes[postId] || 0) - voteType;
            } else {
                // Remove existing vote first
                if (currentVote !== 0) {
                    await supabase
                        .from('sloppygram_post_likes')
                        .delete()
                        .eq('post_id', postId)
                        .eq('user_id', currentUser.id);
                    postVotes[postId] = (postVotes[postId] || 0) - currentVote;
                }

                // Add new vote
                await supabase
                    .from('sloppygram_post_likes')
                    .insert({
                        post_id: postId,
                        username: profile.username,
                        vote_type: voteType,
                        user_id: currentUser.id
                    });

                myPostVotes[postId] = voteType;
                postVotes[postId] = (postVotes[postId] || 0) + voteType;
            }

            // Update post.likes_count
            if (post) post.likes_count = postVotes[postId] || 0;

            // Log AI event for post vote
            logAiEvent('vote_cast', 'post', postId, {
                vote_type: myPostVotes[postId] || 0,
                net_score: postVotes[postId] || 0
            });

            // Update UI
            updatePostVoteUI(postId);
        };

        function updatePostVoteUI(postId) {
            const score = postVotes[postId] || 0;
            const myVote = myPostVotes[postId] || 0;
            const scoreClass = score > 0 ? 'positive' : score < 0 ? 'negative' : 'neutral';

            document.querySelectorAll(`[data-post-id="${postId}"]`).forEach(container => {
                const scoreEl = container.querySelector('.vote-score');
                const upBtn = container.querySelector('.vote-btn.upvote');
                const downBtn = container.querySelector('.vote-btn.downvote');

                if (scoreEl) {
                    scoreEl.textContent = score;
                    scoreEl.className = `vote-score ${scoreClass}`;
                }
                if (upBtn) upBtn.classList.toggle('active', myVote === 1);
                if (downBtn) downBtn.classList.toggle('active', myVote === -1);
            });
        }

        window.focusComment = function(postId) {
            document.getElementById(`comment-input-${postId}`).focus();
        };

        // Start replying to a specific comment
        window.startReply = function(postId, commentId, username, type = 'post') {
            replyingTo = { postId, commentId, username, type };
            if (type === 'post') {
                renderPosts();
                setTimeout(() => {
                    const input = document.getElementById(`comment-input-${postId}`);
                    if (input) input.focus();
                }, 50);
            } else {
                renderManifestos();
                setTimeout(() => {
                    const input = document.getElementById(`manifesto-comment-input-${postId}`);
                    if (input) input.focus();
                }, 50);
            }
        };

        // Cancel replying
        window.cancelReply = function() {
            var wasType = (replyingTo && replyingTo.type) ? replyingTo.type : null;
            replyingTo = null;
            if (wasType === 'post') {
                renderPosts();
            } else if (wasType === 'manifesto') {
                renderManifestos();
            }
        };

        window.addComment = async function(postId) {
            const input = document.getElementById(`comment-input-${postId}`);
            const content = input.value.trim();
            if (!content || !currentUser) return;

            // Rate limiting check
            const rateCheck = checkRateLimit('comment');
            if (!rateCheck.allowed) {
                showToast(rateCheck.message, 'warning');
                return;
            }
            recordAction('comment');

            const comment = {
                post_id: postId,
                username: profile.username,
                avatar: profile.avatar,
                content: content,
                user_id: currentUser.id
            };

            const { data, error } = await supabase
                .from('sloppygram_post_comments')
                .insert(comment)
                .select()
                .single();

            if (error) {
                console.error('Error adding comment:', error);
                return;
            }

            // If this is a reply, save the thread relationship
            if (replyingTo && replyingTo.postId === postId && replyingTo.type === 'post' && data) {
                await supabase
                    .from('sloppygram_comment_threads')
                    .insert({
                        comment_id: data.id,
                        parent_comment_id: replyingTo.commentId,
                        comment_type: 'post',
                        post_id: postId,
                        user_id: currentUser.id
                    });
                commentThreads[data.id] = replyingTo.commentId;
            }

            if (!postComments[postId]) postComments[postId] = [];
            postComments[postId].push({ ...comment, id: (data && data.id) ? data.id : null, created_at: new Date().toISOString() });

            input.value = '';
            replyingTo = null;
            renderPosts();
        };

        // Emoji Reactions
        window.toggleReactionPicker = function(postId) {
            const picker = document.getElementById(`picker-${postId}`);
            // Close all other pickers
            document.querySelectorAll('.reaction-picker.active').forEach(p => {
                if (p.id !== `picker-${postId}`) p.classList.remove('active');
            });
            picker.classList.toggle('active');
        };

        window.toggleReaction = async function(postId, emoji) {
            if (!currentUser) return;

            // Close picker
            const picker = document.getElementById(`picker-${postId}`);
            if (picker) picker.classList.remove('active');

            var hasReaction = (myReactions[postId] && myReactions[postId].has(emoji)) ? true : false;

            if (hasReaction) {
                // Remove reaction
                await supabase
                    .from('sloppygram_post_reactions')
                    .delete()
                    .eq('post_id', postId)
                    .eq('emoji', emoji)
                    .eq('user_id', currentUser.id);

                if (myReactions[postId]) myReactions[postId].delete(emoji);
                if (postReactions[postId] && postReactions[postId][emoji]) {
                    postReactions[postId][emoji]--;
                    if (postReactions[postId][emoji] <= 0) delete postReactions[postId][emoji];
                }
            } else {
                // Add reaction
                await supabase
                    .from('sloppygram_post_reactions')
                    .insert({
                        post_id: postId,
                        emoji: emoji,
                        username: profile.username,
                        user_id: currentUser.id
                    });

                if (!myReactions[postId]) myReactions[postId] = new Set();
                myReactions[postId].add(emoji);
                if (!postReactions[postId]) postReactions[postId] = {};
                postReactions[postId][emoji] = (postReactions[postId][emoji] || 0) + 1;
            }

            renderPosts();
        };

        // Close reaction pickers when clicking outside
        document.addEventListener('click', (e) => {
            if (!e.target.closest('.add-reaction-btn') && !e.target.closest('.reaction-picker')) {
                document.querySelectorAll('.reaction-picker.active').forEach(p => p.classList.remove('active'));
            }
        });

        // Post Modal
        window.openPostModal = function() {
            postImageData = null;
            document.getElementById('postImageUrl').value = '';
            document.getElementById('postCaption').value = '';
            document.getElementById('postFileInput').value = '';
            document.getElementById('postPreview').innerHTML = '<span>No image selected</span>';
            document.getElementById('postPreview').classList.remove('has-image');
            document.getElementById('postModal').classList.add('active');
        };

        window.closePostModal = function() {
            document.getElementById('postModal').classList.remove('active');
        };

        window.previewPostImage = function() {
            const url = document.getElementById('postImageUrl').value.trim();
            const preview = document.getElementById('postPreview');
            const safeUrl = sanitizeUrl(url);

            if (safeUrl) {
                preview.innerHTML = `<img src="${safeUrl}" onerror="this.parentElement.innerHTML='<span>Failed to load image</span>'">`;
                preview.classList.add('has-image');
                postImageData = null;
            } else if (!postImageData) {
                preview.innerHTML = '<span>No image selected</span>';
                preview.classList.remove('has-image');
            }
        };

        window.handlePostFileSelect = function(event) {
            const file = event.target.files[0];
            if (!file) return;

            if (file.size > 500000) {
                alert('Image too large! Max 500KB');
                event.target.value = '';
                return;
            }

            const reader = new FileReader();
            reader.onload = function(e) {
                postImageData = e.target.result;
                const preview = document.getElementById('postPreview');
                preview.innerHTML = `<img src="${postImageData}">`;
                preview.classList.add('has-image');
                document.getElementById('postImageUrl').value = '';
            };
            reader.readAsDataURL(file);
        };

        window.submitPost = async function() {
            const imageUrl = document.getElementById('postImageUrl').value.trim();
            const caption = document.getElementById('postCaption').value.trim();

            if (!imageUrl && !postImageData && !caption) {
                showToast('Add an image or caption!', 'warning');
                return;
            }

            // Rate limiting check
            const rateCheck = checkRateLimit('post');
            if (!rateCheck.allowed) {
                showToast(rateCheck.message, 'warning');
                return;
            }
            recordAction('post');

            // Upload local image to storage instead of saving base64
            let finalImageUrl = imageUrl || null;
            let finalImageData = null;

            if (postImageData && !imageUrl) {
                const blob = dataURLtoBlob(postImageData);
                const storageUrl = await uploadToStorage(blob, 'posts');
                if (storageUrl) {
                    finalImageUrl = storageUrl;
                } else {
                    // Fallback to base64 if storage fails
                    finalImageData = postImageData;
                }
            }

            const post = {
                username: profile.username,
                avatar: profile.avatar,
                avatar_url: profile.avatarUrl || null,
                caption: caption || null,
                image_url: finalImageUrl,
                image_data: finalImageData,
                likes_count: 0,
                user_id: currentUser.id
            };

            const { data: insertedPost, error } = await supabase
                .from('sloppygram_posts')
                .insert(post)
                .select()
                .single();

            if (error) {
                console.error('Error creating post:', error);
                alert('Failed to create post: ' + error.message);
                return;
            }

            if (!insertedPost) {
                console.error('Post insert returned no data');
                alert('Post created but could not retrieve ID for tags');
            }

            // Save tags if any
            if (pendingTags.length > 0 && insertedPost) {
                const tagInserts = pendingTags.map(t => ({
                    post_id: insertedPost.id,
                    tag: t.tag,
                    parent_tag: t.parent_tag || null,
                    user_id: currentUser.id
                }));
                const { error: tagError } = await supabase.from('sloppygram_post_tags').insert(tagInserts);
                if (tagError) {
                    console.error('Error saving tags:', tagError);
                }
            }

            // Log AI event for new post
            if (insertedPost) {
                logAiEvent('post_created', 'post', insertedPost.id, {
                    has_image: !!(finalImageUrl || finalImageData),
                    has_caption: !!caption,
                    tag_count: pendingTags.length
                });
            }

            closePostModal();
            addToFeed(profile.username, 'created a new post');

            // Clear any active tag filter so new post is visible
            activeTagFilter = null;
            document.getElementById('tagFilterBar').classList.remove('active');

            loadPosts();
        };

        // === POST TAG HANDLING FUNCTIONALITY ===

        window.handlePostTagInput = function(event) {
            if (event.key === 'Enter') {
                event.preventDefault();
                const input = document.getElementById('tagInput');
                const value = input.value.trim();
                if (!value) return;

                // Parse nested tag (e.g., "meme/cursed" -> parent_tag: "meme", tag: "cursed")
                let tag, parent_tag = null;
                if (value.includes('/')) {
                    const parts = value.split('/');
                    parent_tag = parts[0].trim();
                    tag = parts.slice(1).join('/').trim();
                } else {
                    tag = value;
                }

                // Don't add duplicates
                const exists = pendingTags.some(t => t.tag === tag && t.parent_tag === parent_tag);
                if (!exists) {
                    pendingTags.push({ tag, parent_tag });
                    renderPendingTags();
                }

                input.value = '';
            }
        };

        function renderPendingTags() {
            const container = document.getElementById('tagInputContainer');
            const input = document.getElementById('tagInput');

            // Remove existing tag chips
            container.querySelectorAll('.tag-chip').forEach(el => el.remove());

            // Add tag chips
            pendingTags.forEach((t, idx) => {
                const displayTag = t.parent_tag ? `${t.parent_tag}/${t.tag}` : t.tag;
                const chip = document.createElement('span');
                chip.className = `tag-chip ${t.parent_tag ? 'nested' : ''}`;
                chip.innerHTML = `#${escapeHtml(displayTag)} <button onclick="removePendingTag(${idx})">Ã—</button>`;
                container.insertBefore(chip, input);
            });
        }

        window.removePendingTag = function(idx) {
            pendingTags.splice(idx, 1);
            renderPendingTags();
        };

        window.filterByTag = function(tagStr) {
            activeTagFilter = tagStr;
            document.getElementById('tagFilterBar').classList.add('active');
            document.getElementById('activeFilterTag').textContent = '#' + tagStr;

            // Also set chat filter
            activeChatFilter = { type: 'tag', value: tagStr };
            document.getElementById('chatFilterBar').classList.add('active');
            var filterValue = document.getElementById('activeChatFilter');
            if (filterValue) filterValue.textContent = '#' + tagStr;

            // Count matches in each source
            var postCount = countPostsWithTag(tagStr);
            var msgCount = countMessagesWithTag(tagStr);
            var manifestoCount = countManifestosWithTag(tagStr);

            // Filter all views
            renderFilteredPosts();
            renderFilteredMessages();
            renderFilteredManifestos();

            // Show toast with result counts
            showToast('Found: ' + postCount + ' posts, ' + msgCount + ' msgs, ' + manifestoCount + ' manifestos with #' + tagStr, 'info');
        };

        function countPostsWithTag(tagStr) {
            return posts.filter(function(post) {
                var tags = postTags[post.id] || [];
                return tags.some(function(t) {
                    var fullTag = t.parent_tag ? t.parent_tag + '/' + t.tag : t.tag;
                    return fullTag.toLowerCase() === tagStr.toLowerCase() ||
                           t.tag.toLowerCase() === tagStr.toLowerCase();
                });
            }).length;
        }

        function countMessagesWithTag(tagStr) {
            var allMessages = window.cachedMessages || [];
            var tagRegex = new RegExp('#' + tagStr + '\\b', 'i');
            return allMessages.filter(function(msg) {
                return tagRegex.test(msg.content || '');
            }).length;
        }

        function countManifestosWithTag(tagStr) {
            return manifestos.filter(function(m) {
                var tags = manifestoTags[m.id] || [];
                return tags.some(function(t) {
                    var fullTag = t.parent_tag ? t.parent_tag + '/' + t.tag : t.tag;
                    return fullTag.toLowerCase() === tagStr.toLowerCase() ||
                           t.tag.toLowerCase() === tagStr.toLowerCase();
                });
            }).length;
        }

        function renderFilteredManifestos() {
            if (!activeTagFilter) {
                renderManifestos();
                return;
            }

            var container = document.getElementById('manifestosContainer');
            if (!container) return;

            var filtered = manifestos.filter(function(m) {
                var tags = manifestoTags[m.id] || [];
                return tags.some(function(t) {
                    var fullTag = t.parent_tag ? t.parent_tag + '/' + t.tag : t.tag;
                    return fullTag.toLowerCase() === activeTagFilter.toLowerCase() ||
                           t.tag.toLowerCase() === activeTagFilter.toLowerCase();
                });
            });

            if (filtered.length === 0) {
                container.innerHTML = '<div class="empty-state"><p>No manifestos with #' + escapeHtml(activeTagFilter) + '</p></div>';
                return;
            }

            container.innerHTML = filtered.map(function(m) { return renderManifestoCard(m); }).join('');
        }

        window.clearTagFilter = function() {
            activeTagFilter = null;
            document.getElementById('tagFilterBar').classList.remove('active');

            // Also clear chat filter
            activeChatFilter = null;
            document.getElementById('chatFilterBar').classList.remove('active');

            // Re-render all views without filter
            renderPosts();
            renderMessages();
            renderManifestos();
        };

        function renderFilteredPosts() {
            if (!activeTagFilter) {
                renderPosts();
                return;
            }

            var container = document.getElementById('postsContainer');
            var emptyState = document.getElementById('postsEmptyState');
            var filterLower = activeTagFilter.toLowerCase();

            // Filter posts that have the matching tag (case-insensitive)
            var filteredPosts = posts.filter(function(post) {
                var tags = postTags[post.id] || [];
                return tags.some(function(t) {
                    var fullTag = t.parent_tag ? t.parent_tag + '/' + t.tag : t.tag;
                    return fullTag.toLowerCase() === filterLower ||
                           t.tag.toLowerCase() === filterLower ||
                           (t.parent_tag && t.parent_tag.toLowerCase() === filterLower);
                });
            });

            if (filteredPosts.length === 0) {
                if (emptyState) {
                    emptyState.style.display = 'block';
                    emptyState.innerHTML = '<p>No posts with tag #' + escapeHtml(activeTagFilter) + '</p>';
                }
                if (container) container.innerHTML = '';
                if (container && emptyState) container.appendChild(emptyState);
                return;
            }

            if (emptyState) emptyState.style.display = 'none';
            if (container) container.innerHTML = filteredPosts.map(post => renderPostCard(post)).join('');
        }

        // Reset pending tags when opening post modal
        const originalOpenPostModal = window.openPostModal;
        window.openPostModal = function() {
            pendingTags = [];
            renderPendingTags();
            if (originalOpenPostModal) originalOpenPostModal();
            else document.getElementById('postModal').classList.add('active');
        };

        // Load and display trending tags
        async function loadTrendingTags() {
            const { data: tagsData } = await supabase
                .from('sloppygram_post_tags')
                .select('tag, parent_tag');

            if (!tagsData || tagsData.length === 0) {
                document.getElementById('trendingTagsList').innerHTML = `
                    <div style="font-size:0.85rem;color:var(--text-dim)">No tags yet</div>
                `;
                return;
            }

            // Count tag occurrences
            const tagCounts = {};
            tagsData.forEach(t => {
                const fullTag = t.parent_tag ? `${t.parent_tag}/${t.tag}` : t.tag;
                tagCounts[fullTag] = (tagCounts[fullTag] || 0) + 1;
            });

            // Sort by count and take top 10
            const topTags = Object.entries(tagCounts)
                .sort((a, b) => b[1] - a[1])
                .slice(0, 10);

            const container = document.getElementById('trendingTagsList');
            container.innerHTML = topTags.map(([tag, count], idx) => {
                const isNested = tag.includes('/');
                const rankClass = idx === 0 ? 'hot' : idx < 3 ? 'warm' : '';
                return `
                    <div class="trending-tag ${rankClass}" onclick="filterByTag('${escapeHtml(tag)}')">
                        <span class="tag ${isNested ? 'nested' : ''}">#${escapeHtml(tag)}</span>
                        <span class="tag-count">${count}</span>
                    </div>
                `;
            }).join('');
        }

        // Call loadTrendingTags when switching to posts view
        const originalSwitchView = switchView;
        switchView = function(view) {
            originalSwitchView(view);
            if (view === 'posts') {
                loadTrendingTags();
            }
        };

        // === MANIFESTO FUNCTIONALITY ===

        let manifestos = [];
        let manifestoVotes = {}; // { manifestoId: count }
        let myManifestoVotes = {}; // { manifestoId: true }
        let manifestoReactions = {}; // { manifestoId: { emoji: count } }
        let myManifestoReactions = {}; // { manifestoId: Set of emojis }
        let manifestoComments = {}; // { manifestoId: [comments] }
        let manifestoTags = {}; // { manifestoId: [tags] }
        let pendingManifestoTags = []; // tags being added to new manifesto

        window.openManifestoModal = function() {
            document.getElementById('manifestoModal').classList.add('active');
            document.getElementById('manifestoTitle').value = '';
            document.getElementById('manifestoContent').value = '';
            document.getElementById('manifestoCharCount').textContent = '0';
            pendingManifestoTags = [];
            renderPendingManifestoTags();
        };

        window.closeManifestoModal = function() {
            document.getElementById('manifestoModal').classList.remove('active');
        };

        // Character count for manifesto content
        document.addEventListener('DOMContentLoaded', () => {
            const content = document.getElementById('manifestoContent');
            if (content) {
                content.addEventListener('input', () => {
                    document.getElementById('manifestoCharCount').textContent = content.value.length;
                });
            }
        });

        // Manifesto tag input handling
        window.handleManifestoTagInput = function(event) {
            if (event.key === 'Enter') {
                event.preventDefault();
                const input = document.getElementById('manifestoTagInput');
                const value = input.value.trim();
                if (!value) return;

                let tag, parent_tag = null;
                if (value.includes('/')) {
                    const parts = value.split('/');
                    parent_tag = parts[0].trim();
                    tag = parts.slice(1).join('/').trim();
                } else {
                    tag = value;
                }

                const exists = pendingManifestoTags.some(t => t.tag === tag && t.parent_tag === parent_tag);
                if (!exists) {
                    pendingManifestoTags.push({ tag, parent_tag });
                    renderPendingManifestoTags();
                }
                input.value = '';
            }
        };

        function renderPendingManifestoTags() {
            const container = document.getElementById('manifestoTagInputContainer');
            const input = document.getElementById('manifestoTagInput');
            container.querySelectorAll('.tag-chip').forEach(el => el.remove());

            pendingManifestoTags.forEach((t, idx) => {
                const displayTag = t.parent_tag ? `${t.parent_tag}/${t.tag}` : t.tag;
                const chip = document.createElement('span');
                chip.className = `tag-chip ${t.parent_tag ? 'nested' : ''}`;
                chip.innerHTML = `#${escapeHtml(displayTag)} <button onclick="removeManifestoTag(${idx})">Ã—</button>`;
                container.insertBefore(chip, input);
            });
        }

        window.removeManifestoTag = function(idx) {
            pendingManifestoTags.splice(idx, 1);
            renderPendingManifestoTags();
        };

        window.submitManifesto = async function() {
            const title = document.getElementById('manifestoTitle').value.trim();
            const content = document.getElementById('manifestoContent').value.trim();

            if (!title || !content) {
                alert('Please fill in both title and content!');
                return;
            }

            const manifesto = {
                title,
                content,
                username: profile.username,
                avatar: profile.avatar,
                upvotes: 0,
                user_id: currentUser.id
            };

            const { data: insertedManifesto, error } = await supabase
                .from('sloppygram_manifestos')
                .insert(manifesto)
                .select()
                .single();

            if (error) {
                console.error('Error creating manifesto:', error);
                alert('Failed to create manifesto: ' + error.message);
                return;
            }

            // Save tags if any
            if (pendingManifestoTags.length > 0 && insertedManifesto) {
                const tagInserts = pendingManifestoTags.map(t => ({
                    manifesto_id: insertedManifesto.id,
                    tag: t.tag,
                    parent_tag: t.parent_tag || null,
                    user_id: currentUser.id
                }));
                await supabase.from('sloppygram_manifesto_tags').insert(tagInserts);
            }

            closeManifestoModal();
            addToFeed(profile.username, 'declared a new manifesto');
            loadManifestos();
        };

        async function loadManifestos() {
            const { data, error } = await supabase
                .from('sloppygram_manifestos')
                .select('*')
                .order('created_at', { ascending: false })
                .limit(50);

            if (error) {
                console.error('Error loading manifestos:', error);
                return;
            }

            manifestos = data || [];
            window.cachedManifestos = manifestos; // Expose to global for Tag Explorer
            const manifestoIds = manifestos.map(m => m.id);

            // Batch all related queries in parallel to solve N+1 problem
            const [votesResult, reactionsResult, commentsResult, tagsResult, threadsResult] = await Promise.all([
                manifestoIds.length > 0
                    ? supabase.from('sloppygram_manifesto_votes').select('*').in('manifesto_id', manifestoIds)
                    : { data: [] },
                manifestoIds.length > 0
                    ? supabase.from('sloppygram_manifesto_reactions').select('*').in('manifesto_id', manifestoIds)
                    : { data: [] },
                manifestoIds.length > 0
                    ? supabase.from('sloppygram_manifesto_comments').select('*').in('manifesto_id', manifestoIds).order('created_at', { ascending: true })
                    : { data: [] },
                manifestoIds.length > 0
                    ? supabase.from('sloppygram_manifesto_tags').select('*').in('manifesto_id', manifestoIds)
                    : { data: [] },
                manifestoIds.length > 0
                    ? supabase.from('sloppygram_comment_threads').select('*').eq('comment_type', 'manifesto').in('post_id', manifestoIds)
                    : { data: [] }
            ]);

            // Process votes
            manifestoVotes = {};
            myManifestoVotes = {};
            (votesResult.data || []).forEach(v => {
                manifestoVotes[v.manifesto_id] = (manifestoVotes[v.manifesto_id] || 0) + 1;
                if (v.username === profile.username) {
                    myManifestoVotes[v.manifesto_id] = true;
                }
            });

            // Process reactions
            manifestoReactions = {};
            myManifestoReactions = {};
            (reactionsResult.data || []).forEach(r => {
                if (!manifestoReactions[r.manifesto_id]) manifestoReactions[r.manifesto_id] = {};
                manifestoReactions[r.manifesto_id][r.emoji] = (manifestoReactions[r.manifesto_id][r.emoji] || 0) + 1;
                if (r.username === profile.username) {
                    if (!myManifestoReactions[r.manifesto_id]) myManifestoReactions[r.manifesto_id] = new Set();
                    myManifestoReactions[r.manifesto_id].add(r.emoji);
                }
            });

            // Process comments
            manifestoComments = {};
            (commentsResult.data || []).forEach(c => {
                if (!manifestoComments[c.manifesto_id]) manifestoComments[c.manifesto_id] = [];
                manifestoComments[c.manifesto_id].push(c);
            });

            // Process tags
            manifestoTags = {};
            (tagsResult.data || []).forEach(t => {
                if (!manifestoTags[t.manifesto_id]) manifestoTags[t.manifesto_id] = [];
                manifestoTags[t.manifesto_id].push({ tag: t.tag, parent_tag: t.parent_tag });
            });

            // Process comment threads
            (threadsResult.data || []).forEach(t => {
                commentThreads[t.comment_id] = t.parent_comment_id;
            });

            renderManifestos();
        }

        function renderManifestos() {
            const container = document.getElementById('manifestoList');
            const emptyState = document.getElementById('manifestoEmptyState');

            if (manifestos.length === 0) {
                if (emptyState) emptyState.style.display = 'block';
                if (container) container.innerHTML = '';
                if (container && emptyState) container.appendChild(emptyState);
                return;
            }

            if (emptyState) emptyState.style.display = 'none';
            if (container) container.innerHTML = manifestos.map(m => renderManifestoCard(m)).join('');
        }

        function renderManifestoCard(m) {
            const time = new Date(m.created_at).toLocaleString();
            const voteCount = manifestoVotes[m.id] || m.upvotes || 0;
            const hasVoted = myManifestoVotes[m.id];
            const reactions = manifestoReactions[m.id] || {};
            const myReacts = myManifestoReactions[m.id] || new Set();
            const comments = manifestoComments[m.id] || [];
            const tags = manifestoTags[m.id] || [];
            // Check ownership by user_id first (reliable), fallback to username
            var currentUserId = (currentUser && currentUser.id) ? currentUser.id : null;
            const isOwnManifesto = (currentUserId && m.user_id === currentUserId) || m.username === profile.username;

            const reactionsHtml = Object.entries(reactions)
                .sort((a, b) => b[1] - a[1])
                .map(([emoji, count]) => {
                    const isActive = myReacts.has(emoji);
                    return `<button class="reaction-btn ${isActive ? 'active' : ''}" onclick="toggleManifestoReaction(${m.id}, '${emoji}')">
                        ${emoji} <span class="reaction-count">${count}</span>
                    </button>`;
                }).join('');

            const reactionPickerHtml = REACTION_EMOJIS.map(emoji =>
                `<button onclick="toggleManifestoReaction(${m.id}, '${emoji}')">${emoji}</button>`
            ).join('');

            const commentsHtml = renderThreadedComments(comments, m.id, 'manifesto');

            // Reply indicator if replying to a comment on this manifesto
            const replyIndicatorHtml = (replyingTo && replyingTo.postId === m.id && replyingTo.type === 'manifesto')
                ? `<div class="reply-indicator">
                    <span>â†© Replying to <strong>${escapeHtml(replyingTo.username)}</strong></span>
                    <button class="cancel-reply" onclick="cancelReply()">âœ•</button>
                </div>`
                : '';

            const tagsHtml = tags.length > 0 ? `
                <div class="post-tags">
                    ${tags.map(t => {
                        const isNested = t.parent_tag != null;
                        const displayTag = isNested ? `${t.parent_tag}/${t.tag}` : t.tag;
                        return `<span class="tag ${isNested ? 'nested' : ''}">#${escapeHtml(displayTag)}</span>`;
                    }).join('')}
                </div>
            ` : '';

            return `
                <div class="manifesto-card" data-manifesto-id="${m.id}">
                    <div class="manifesto-card-header">
                        <div class="manifesto-avatar">${m.avatar || 'ðŸ‘¤'}</div>
                        <span class="manifesto-author username-clickable" onclick="showProfileCard('${escapeHtml(m.username || 'Anonymous')}', event)">${escapeHtml(m.username || 'Anonymous')}</span>
                        <span class="manifesto-time">${time}</span>
                        ${isOwnManifesto ? `<button class="msg-delete-btn" onclick="deleteManifesto(${m.id})" title="Delete manifesto">delete</button>` : ''}
                    </div>
                    <h3 class="manifesto-title">${escapeHtml(m.title)}</h3>
                    <div class="manifesto-text">${escapeHtml(m.content)}</div>
                    ${tagsHtml}
                    <div class="manifesto-actions">
                        <button class="manifesto-vote-btn ${hasVoted ? 'voted' : ''}" onclick="voteManifesto(${m.id})">
                            ${hasVoted ? 'â­' : 'â˜†'} <span>${voteCount}</span>
                        </button>
                        <button class="post-action-btn" onclick="focusManifestoComment(${m.id})">
                            ðŸ’¬ ${comments.length}
                        </button>
                    </div>
                    <div class="post-reactions" id="manifesto-reactions-${m.id}">
                        ${reactionsHtml}
                        <div style="position:relative;display:inline-block;">
                            <button class="add-reaction-btn" onclick="toggleManifestoReactionPicker(${m.id})">+ ðŸ˜€</button>
                            <div class="reaction-picker" id="manifesto-picker-${m.id}">
                                ${reactionPickerHtml}
                            </div>
                        </div>
                    </div>
                    <div class="post-comments" id="manifesto-comments-${m.id}">
                        ${commentsHtml}
                    </div>
                    ${replyIndicatorHtml}
                    <div class="comment-input-row">
                        <input class="comment-input" id="manifesto-comment-input-${m.id}" placeholder="${replyingTo && replyingTo.postId === m.id && replyingTo.type === 'manifesto' ? 'Write a reply...' : 'Add a comment...'}" onkeydown="if(event.key==='Enter')addManifestoComment(${m.id})">
                        <button class="comment-send" onclick="addManifestoComment(${m.id})">POST</button>
                    </div>
                </div>
            `;
        }

        window.voteManifesto = async function(manifestoId) {
            if (!currentUser) return;

            const hasVoted = myManifestoVotes[manifestoId];

            if (hasVoted) {
                await supabase
                    .from('sloppygram_manifesto_votes')
                    .delete()
                    .eq('manifesto_id', manifestoId)
                    .eq('user_id', currentUser.id);

                myManifestoVotes[manifestoId] = false;
                manifestoVotes[manifestoId] = Math.max(0, (manifestoVotes[manifestoId] || 0) - 1);
            } else {
                await supabase
                    .from('sloppygram_manifesto_votes')
                    .insert({
                        manifesto_id: manifestoId,
                        username: profile.username,
                        user_id: currentUser.id
                    });

                myManifestoVotes[manifestoId] = true;
                manifestoVotes[manifestoId] = (manifestoVotes[manifestoId] || 0) + 1;
            }

            renderManifestos();
        };

        window.deleteManifesto = async function(manifestoId) {
            if (!currentUser) return;
            if (!confirm('Delete this manifesto?')) return;

            const { error } = await supabase
                .from('sloppygram_manifestos')
                .delete()
                .eq('id', manifestoId)
                .eq('user_id', currentUser.id);

            if (error) {
                console.error('Error deleting manifesto:', error);
                showToast('Failed to delete manifesto', 'error');
                return;
            }

            // Remove from local array
            manifestos = manifestos.filter(m => m.id !== manifestoId);
            // Clean up related data
            delete manifestoVotes[manifestoId];
            delete myManifestoVotes[manifestoId];
            delete manifestoReactions[manifestoId];
            delete myManifestoReactions[manifestoId];
            delete manifestoComments[manifestoId];
            delete manifestoTags[manifestoId];

            showToast('Manifesto deleted', 'success');
            renderManifestos();
        };

        window.toggleManifestoReactionPicker = function(manifestoId) {
            const picker = document.getElementById(`manifesto-picker-${manifestoId}`);
            document.querySelectorAll('.reaction-picker').forEach(p => {
                if (p !== picker) p.classList.remove('active');
            });
            picker.classList.toggle('active');
        };

        window.toggleManifestoReaction = async function(manifestoId, emoji) {
            if (!currentUser) return;

            const myReacts = myManifestoReactions[manifestoId] || new Set();
            const hasReacted = myReacts.has(emoji);

            if (hasReacted) {
                await supabase
                    .from('sloppygram_manifesto_reactions')
                    .delete()
                    .eq('manifesto_id', manifestoId)
                    .eq('emoji', emoji)
                    .eq('user_id', currentUser.id);

                myReacts.delete(emoji);
                if (!manifestoReactions[manifestoId]) manifestoReactions[manifestoId] = {};
                manifestoReactions[manifestoId][emoji] = Math.max(0, (manifestoReactions[manifestoId][emoji] || 0) - 1);
                if (manifestoReactions[manifestoId][emoji] === 0) delete manifestoReactions[manifestoId][emoji];
            } else {
                await supabase
                    .from('sloppygram_manifesto_reactions')
                    .insert({
                        manifesto_id: manifestoId,
                        emoji,
                        username: profile.username,
                        user_id: currentUser.id
                    });

                myReacts.add(emoji);
                if (!manifestoReactions[manifestoId]) manifestoReactions[manifestoId] = {};
                manifestoReactions[manifestoId][emoji] = (manifestoReactions[manifestoId][emoji] || 0) + 1;
            }

            myManifestoReactions[manifestoId] = myReacts;
            document.querySelectorAll('.reaction-picker').forEach(p => p.classList.remove('active'));
            renderManifestos();
        };

        window.focusManifestoComment = function(manifestoId) {
            document.getElementById(`manifesto-comment-input-${manifestoId}`).focus();
        };

        window.addManifestoComment = async function(manifestoId) {
            const input = document.getElementById(`manifesto-comment-input-${manifestoId}`);
            const content = input.value.trim();
            if (!content || !currentUser) return;

            // Rate limiting check
            const rateCheck = checkRateLimit('comment');
            if (!rateCheck.allowed) {
                showToast(rateCheck.message, 'warning');
                return;
            }
            recordAction('comment');

            const comment = {
                manifesto_id: manifestoId,
                username: profile.username,
                avatar: profile.avatar,
                content,
                user_id: currentUser.id
            };

            const { data, error } = await supabase
                .from('sloppygram_manifesto_comments')
                .insert(comment)
                .select()
                .single();

            if (error) {
                console.error('Error adding comment:', error);
                return;
            }

            // If this is a reply, save the thread relationship
            if (replyingTo && replyingTo.postId === manifestoId && replyingTo.type === 'manifesto' && data) {
                await supabase
                    .from('sloppygram_comment_threads')
                    .insert({
                        comment_id: data.id,
                        parent_comment_id: replyingTo.commentId,
                        comment_type: 'manifesto',
                        post_id: manifestoId,
                        user_id: currentUser.id
                    });
                commentThreads[data.id] = replyingTo.commentId;
            }

            if (!manifestoComments[manifestoId]) manifestoComments[manifestoId] = [];
            manifestoComments[manifestoId].push({ ...comment, id: (data && data.id) ? data.id : null, created_at: new Date().toISOString() });

            input.value = '';
            replyingTo = null;
            renderManifestos();
        };

        // === REPUTATION SYSTEM ===

        async function loadReputations() {
            // Calculate reputation from post votes (net score using vote_type)
            const { data: postsData } = await supabase
                .from('sloppygram_posts')
                .select('username, id');

            const postsByUser = {};
            (postsData || []).forEach(p => {
                if (p.username) {
                    if (!postsByUser[p.username]) postsByUser[p.username] = [];
                    postsByUser[p.username].push(p.id);
                }
            });

            const { data: postVotesData } = await supabase
                .from('sloppygram_post_likes')
                .select('post_id, vote_type');

            const postVotesByPost = {};
            (postVotesData || []).forEach(v => {
                postVotesByPost[v.post_id] = (postVotesByPost[v.post_id] || 0) + (v.vote_type || 1);
            });

            const postScoresByUser = {};
            for (const [username, postIds] of Object.entries(postsByUser)) {
                postScoresByUser[username] = postIds.reduce((sum, id) => sum + (postVotesByPost[id] || 0), 0);
            }

            // Calculate reputation from manifesto votes
            const { data: manifestosData } = await supabase
                .from('sloppygram_manifestos')
                .select('username, id');

            const manifestosByUser = {};
            (manifestosData || []).forEach(m => {
                if (m.username) {
                    if (!manifestosByUser[m.username]) manifestosByUser[m.username] = [];
                    manifestosByUser[m.username].push(m.id);
                }
            });

            const manifestoVotesByUser = {};
            for (const [username, manifestoIds] of Object.entries(manifestosByUser)) {
                if (manifestoIds.length > 0) {
                    const { count } = await supabase
                        .from('sloppygram_manifesto_votes')
                        .select('*', { count: 'exact', head: true })
                        .in('manifesto_id', manifestoIds);
                    manifestoVotesByUser[username] = count || 0;
                }
            }

            // Calculate reputation from chat message votes (net score)
            const { data: messagesData } = await supabase
                .from('sloppygram_messages')
                .select('username, id');

            const messagesByUser = {};
            (messagesData || []).forEach(m => {
                if (m.username) {
                    if (!messagesByUser[m.username]) messagesByUser[m.username] = [];
                    messagesByUser[m.username].push(m.id);
                }
            });

            const { data: chatVotesData } = await supabase
                .from('sloppygram_message_votes')
                .select('message_id, vote_type');

            const chatVotesByMessage = {};
            (chatVotesData || []).forEach(v => {
                chatVotesByMessage[v.message_id] = (chatVotesByMessage[v.message_id] || 0) + (v.vote_type || 1);
            });

            const chatVotesByUser = {};
            for (const [username, msgIds] of Object.entries(messagesByUser)) {
                chatVotesByUser[username] = msgIds.reduce((sum, id) => sum + (chatVotesByMessage[id] || 0), 0);
            }

            // Calculate reputation from doodle votes (net score)
            const { data: doodleVotesData } = await supabase
                .from('sloppygram_doodle_votes')
                .select('message_id, vote_type');

            const doodleVotesByMessage = {};
            (doodleVotesData || []).forEach(v => {
                doodleVotesByMessage[v.message_id] = (doodleVotesByMessage[v.message_id] || 0) + (v.vote_type || 1);
            });

            const doodleVotesByUser = {};
            for (const [username, msgIds] of Object.entries(messagesByUser)) {
                doodleVotesByUser[username] = msgIds.reduce((sum, id) => sum + (doodleVotesByMessage[id] || 0), 0);
            }

            // Combine into reputation scores
            const allUsers = new Set([
                ...Object.keys(postScoresByUser),
                ...Object.keys(manifestoVotesByUser),
                ...Object.keys(chatVotesByUser),
                ...Object.keys(doodleVotesByUser)
            ]);
            userReputations = {};
            allUsers.forEach(username => {
                const postScore = postScoresByUser[username] || 0;
                const manifestoVotes = manifestoVotesByUser[username] || 0;
                const chatScore = chatVotesByUser[username] || 0;
                const doodleScore = doodleVotesByUser[username] || 0;
                userReputations[username] = {
                    postLikes: postScore,
                    manifestoVotes,
                    chatVotes: chatScore,
                    doodleVotes: doodleScore,
                    total: postScore + (manifestoVotes * 2) + chatScore + (doodleScore * 2)
                };
            });

            console.log('Loaded reputations:', userReputations);
        }

        function getReputationBadge(username) {
            const rep = userReputations[username];
            if (!rep || rep.total === 0) return '';

            let badge = '';
            const parts = [];
            if (rep.postLikes > 0) parts.push(`${rep.postLikes} post`);
            if (rep.manifestoVotes > 0) parts.push(`${rep.manifestoVotes} manifesto`);
            if (rep.chatVotes > 0) parts.push(`${rep.chatVotes} chat`);
            if (rep.doodleVotes > 0) parts.push(`${rep.doodleVotes} doodle`);
            let title = `âš¡${rep.total} power (${parts.join(', ')})`;

            if (rep.total >= 100) {
                badge = 'ðŸ‘‘';
            } else if (rep.total >= 50) {
                badge = 'â­';
            } else if (rep.total >= 20) {
                badge = 'âœ¨';
            } else if (rep.total >= 5) {
                badge = 'ðŸ”¥';
            }

            return badge ? `<span class="rep-badge" title="${title}">${badge}${rep.total}</span>` :
                          `<span class="rep-badge small" title="${title}">âš¡${rep.total}</span>`;
        }

        // === DOODLE LEADERBOARD FUNCTIONALITY ===

        async function loadDoodleVotes() {
            const { data: votes } = await supabase
                .from('sloppygram_doodle_votes')
                .select('message_id, voter_username, vote_type');

            if (votes) {
                doodleVotes = {};
                votes.forEach(v => {
                    doodleVotes[v.message_id] = (doodleVotes[v.message_id] || 0) + (v.vote_type || 1);
                });

                myDoodleVotes = {};
                votes.filter(v => v.voter_username === profile.username).forEach(v => {
                    myDoodleVotes[v.message_id] = v.vote_type || 1;
                });
            }
        }

        window.voteDoodle = async function(messageId, voteType, ownerUsername) {
            if (!currentUser) return;
            if (ownerUsername === profile.username) return; // Can't vote on own doodle

            // Rate limiting check
            const rateCheck = checkRateLimit('vote');
            if (!rateCheck.allowed) {
                showToast(rateCheck.message, 'warning');
                return;
            }
            recordAction('vote');

            const currentVote = myDoodleVotes[messageId] || 0;

            if (currentVote === voteType) {
                // Remove vote if clicking same button
                await supabase
                    .from('sloppygram_doodle_votes')
                    .delete()
                    .eq('message_id', messageId)
                    .eq('user_id', currentUser.id);

                myDoodleVotes[messageId] = 0;
                doodleVotes[messageId] = (doodleVotes[messageId] || 0) - voteType;
            } else {
                // Remove existing vote first
                if (currentVote !== 0) {
                    await supabase
                        .from('sloppygram_doodle_votes')
                        .delete()
                        .eq('message_id', messageId)
                        .eq('user_id', currentUser.id);
                    doodleVotes[messageId] = (doodleVotes[messageId] || 0) - currentVote;
                }

                // Add new vote
                await supabase
                    .from('sloppygram_doodle_votes')
                    .insert({
                        message_id: messageId,
                        voter_username: profile.username,
                        vote_type: voteType,
                        user_id: currentUser.id
                    });

                myDoodleVotes[messageId] = voteType;
                doodleVotes[messageId] = (doodleVotes[messageId] || 0) + voteType;
            }

            // Log AI event for doodle vote
            logAiEvent('vote_cast', 'doodle', messageId, {
                vote_type: myDoodleVotes[messageId] || 0,
                net_score: doodleVotes[messageId] || 0
            });

            // Update UI
            updateDoodleVoteUI(messageId);
        };

        function updateDoodleVoteUI(messageId) {
            const score = doodleVotes[messageId] || 0;
            const myVote = myDoodleVotes[messageId] || 0;
            const scoreClass = score > 0 ? 'positive' : score < 0 ? 'negative' : 'neutral';

            document.querySelectorAll(`[data-doodle-id="${messageId}"]`).forEach(container => {
                const scoreEl = container.querySelector('.vote-score');
                const upBtn = container.querySelector('.vote-btn.upvote');
                const downBtn = container.querySelector('.vote-btn.downvote');

                if (scoreEl) {
                    scoreEl.textContent = score;
                    scoreEl.className = `vote-score ${scoreClass}`;
                }
                if (upBtn) upBtn.classList.toggle('active', myVote === 1);
                if (downBtn) downBtn.classList.toggle('active', myVote === -1);
            });
        }

        // === CHAT MESSAGE VOTING ===

        async function loadMessageVotes() {
            const { data: votes } = await supabase
                .from('sloppygram_message_votes')
                .select('message_id, voter_username, vote_type');

            if (votes) {
                messageVotes = {};
                votes.forEach(v => {
                    messageVotes[v.message_id] = (messageVotes[v.message_id] || 0) + (v.vote_type || 1);
                });

                myMessageVotes = {};
                votes.filter(v => v.voter_username === profile.username).forEach(v => {
                    myMessageVotes[v.message_id] = v.vote_type || 1;
                });
            }
        }

        window.voteMessage = async function(messageId, voteType) {
            if (!currentUser) return;

            // Rate limiting check
            const rateCheck = checkRateLimit('vote');
            if (!rateCheck.allowed) {
                showToast(rateCheck.message, 'warning');
                return;
            }
            recordAction('vote');

            const currentVote = myMessageVotes[messageId] || 0;

            if (currentVote === voteType) {
                // Remove vote if clicking same button
                await supabase
                    .from('sloppygram_message_votes')
                    .delete()
                    .eq('message_id', messageId)
                    .eq('user_id', currentUser.id);

                myMessageVotes[messageId] = 0;
                messageVotes[messageId] = (messageVotes[messageId] || 0) - voteType;
            } else {
                // Remove existing vote first
                if (currentVote !== 0) {
                    await supabase
                        .from('sloppygram_message_votes')
                        .delete()
                        .eq('message_id', messageId)
                        .eq('user_id', currentUser.id);
                    messageVotes[messageId] = (messageVotes[messageId] || 0) - currentVote;
                }

                // Add new vote
                await supabase
                    .from('sloppygram_message_votes')
                    .insert({
                        message_id: messageId,
                        voter_username: profile.username,
                        vote_type: voteType,
                        user_id: currentUser.id
                    });

                myMessageVotes[messageId] = voteType;
                messageVotes[messageId] = (messageVotes[messageId] || 0) + voteType;
            }

            // Log AI event for message vote
            logAiEvent('vote_cast', 'message', messageId, {
                vote_type: myMessageVotes[messageId] || 0,
                net_score: messageVotes[messageId] || 0
            });

            // Update UI
            updateMessageVoteUI(messageId);
        };

        function updateMessageVoteUI(messageId) {
            const score = messageVotes[messageId] || 0;
            const myVote = myMessageVotes[messageId] || 0;
            const scoreClass = score > 0 ? 'positive' : score < 0 ? 'negative' : 'neutral';

            document.querySelectorAll(`[data-chat-id="${messageId}"]`).forEach(container => {
                const scoreEl = container.querySelector('.vote-score');
                const upBtn = container.querySelector('.vote-btn.upvote');
                const downBtn = container.querySelector('.vote-btn.downvote');

                if (scoreEl) {
                    scoreEl.textContent = score;
                    scoreEl.className = `vote-score ${scoreClass}`;
                }
                if (upBtn) upBtn.classList.toggle('active', myVote === 1);
                if (downBtn) downBtn.classList.toggle('active', myVote === -1);
            });
        }

        // === COMMENT VOTING ===

        async function loadCommentVotes() {
            const { data: votes } = await supabase
                .from('sloppygram_comment_votes')
                .select('comment_id, voter_username, vote_type');

            if (votes) {
                commentVotes = {};
                votes.forEach(v => {
                    commentVotes[v.comment_id] = (commentVotes[v.comment_id] || 0) + (v.vote_type || 1);
                });

                myCommentVotes = {};
                votes.filter(v => v.voter_username === profile.username).forEach(v => {
                    myCommentVotes[v.comment_id] = v.vote_type || 1;
                });
            }
        }

        window.voteComment = async function(commentId, voteType, ownerUsername) {
            if (!currentUser) return;
            if (ownerUsername === profile.username) return; // Can't vote on own comment

            // Rate limiting check
            const rateCheck = checkRateLimit('vote');
            if (!rateCheck.allowed) {
                showToast(rateCheck.message, 'warning');
                return;
            }
            recordAction('vote');

            const currentVote = myCommentVotes[commentId] || 0;

            if (currentVote === voteType) {
                // Remove vote if clicking same button
                await supabase
                    .from('sloppygram_comment_votes')
                    .delete()
                    .eq('comment_id', commentId)
                    .eq('user_id', currentUser.id);

                myCommentVotes[commentId] = 0;
                commentVotes[commentId] = (commentVotes[commentId] || 0) - voteType;
            } else {
                // Remove existing vote first
                if (currentVote !== 0) {
                    await supabase
                        .from('sloppygram_comment_votes')
                        .delete()
                        .eq('comment_id', commentId)
                        .eq('user_id', currentUser.id);
                    commentVotes[commentId] = (commentVotes[commentId] || 0) - currentVote;
                }

                // Add new vote
                await supabase
                    .from('sloppygram_comment_votes')
                    .insert({
                        comment_id: commentId,
                        voter_username: profile.username,
                        vote_type: voteType,
                        user_id: currentUser.id
                    });

                myCommentVotes[commentId] = voteType;
                commentVotes[commentId] = (commentVotes[commentId] || 0) + voteType;
            }

            // Log AI event for comment vote
            logAiEvent('vote_cast', 'comment', commentId, {
                vote_type: myCommentVotes[commentId] || 0,
                net_score: commentVotes[commentId] || 0
            });

            // Update UI - re-render posts to reflect vote changes
            renderPosts();
        };

        async function loadDoodleLeaderboard() {
            const container = document.getElementById('doodlesContainer');
            const emptyState = document.getElementById('doodlesEmptyState');

            // Batch queries in parallel
            const [doodlesResult, votesResult, commentsResult] = await Promise.all([
                supabase
                    .from('sloppygram_messages')
                    .select('*')
                    .not('drawing_data', 'is', null)
                    .order('created_at', { ascending: false }),
                supabase
                    .from('sloppygram_doodle_votes')
                    .select('message_id, vote_type'),
                supabase
                    .from('sloppygram_doodle_comments')
                    .select('*')
                    .order('created_at', { ascending: true })
            ]);

            const doodles = doodlesResult.data;
            const error = doodlesResult.error;

            // Process comments into lookup by doodle_id
            doodleComments = {};
            doodleCommentThreads = {};
            (commentsResult.data || []).forEach(c => {
                if (!doodleComments[c.doodle_id]) doodleComments[c.doodle_id] = [];
                doodleComments[c.doodle_id].push(c);
                if (c.parent_comment_id) {
                    doodleCommentThreads[c.id] = c.parent_comment_id;
                }
            });

            if (error || !doodles || doodles.length === 0) {
                if (emptyState) emptyState.style.display = 'block';
                return;
            }

            // Count net votes
            const voteCounts = {};
            (votesResult.data || []).forEach(v => {
                voteCounts[v.message_id] = (voteCounts[v.message_id] || 0) + (v.vote_type || 1);
            });

            // Sort by votes (descending), then by date
            const sortedDoodles = doodles
                .map(d => ({ ...d, votes: voteCounts[d.id] || 0 }))
                .sort((a, b) => b.votes - a.votes || new Date(b.created_at) - new Date(a.created_at));

            // Render leaderboard
            container.innerHTML = '<div class="leaderboard-header">ðŸ† LEGENDARY DOODLES ðŸ†</div>';

            if (sortedDoodles.length === 0) {
                container.innerHTML += `<div class="empty-doodles" id="doodlesEmptyState">
                    <div class="icon">ðŸŽ¨</div>
                    <p>NO LEGENDARY DOODLES YET...</p>
                    <p>Draw something and get votes!</p>
                </div>`;
                return;
            }

            // Create grid container
            const grid = document.createElement('div');
            grid.className = 'doodle-grid';

            sortedDoodles.forEach((doodle, index) => {
                const rank = index + 1;
                let rankClass = '';
                if (rank === 1) rankClass = 'gold';
                else if (rank === 2) rankClass = 'silver';
                else if (rank === 3) rankClass = 'bronze';

                const time = new Date(doodle.created_at).toLocaleDateString();
                const myVote = myDoodleVotes[doodle.id] || 0;
                // Check ownership by user_id first (reliable), fallback to username
                var currentUserId = (currentUser && currentUser.id) ? currentUser.id : null;
                const isOwnDoodle = (currentUserId && doodle.user_id === currentUserId) || doodle.username === profile.username;
                const scoreClass = doodle.votes > 0 ? 'positive' : doodle.votes < 0 ? 'negative' : 'neutral';
                const isTop3 = rank <= 3;
                const safeDrawingData = sanitizeUrl(doodle.drawing_data);
                const comments = doodleComments[doodle.id] || [];

                const deleteBtn = isOwnDoodle ? `<button class="msg-delete-btn" onclick="deleteMessage('${doodle.id}')" title="Delete doodle">delete</button>` : '';

                // Render threaded comments for this doodle
                const commentsHtml = renderDoodleComments(comments, doodle.id);

                // Reply indicator
                const replyIndicatorHtml = (replyingToDoodle && replyingToDoodle.doodleId === doodle.id)
                    ? `<div class="reply-indicator">
                        <span>â†© Replying to <strong>${escapeHtml(replyingToDoodle.username)}</strong></span>
                        <button class="cancel-reply" onclick="cancelDoodleReply()">âœ•</button>
                    </div>`
                    : '';

                const card = document.createElement('div');
                card.className = `doodle-card${isTop3 ? ' top-3' : ''}`;
                card.innerHTML = `
                    <div class="doodle-rank">
                        <span class="rank-badge ${rankClass}">${rank}</span>
                        <span class="doodle-artist username-clickable" onclick="showProfileCard('${escapeHtml(doodle.username || 'Anonymous')}', event)">${escapeHtml(doodle.username || 'Anonymous')}</span>
                        <span class="doodle-votes ${scoreClass}">${doodle.votes > 0 ? '+' : ''}${doodle.votes}</span>
                        ${deleteBtn}
                    </div>
                    <div class="doodle-thumbnail">
                        <img loading="lazy" src="${safeDrawingData}" onclick="openLightbox(this.src)">
                    </div>
                    <div class="doodle-card-actions">
                        <span class="doodle-time">${time}</span>
                        <button class="post-action-btn" onclick="focusDoodleComment('${doodle.id}')">
                            ðŸ’¬ ${comments.length}
                        </button>
                        <div class="vote-controls" data-doodle-id="${doodle.id}">
                            <button class="vote-btn upvote ${myVote === 1 ? 'active' : ''} ${isOwnDoodle ? 'disabled' : ''}"
                                onclick="${isOwnDoodle ? '' : `voteDoodle('${doodle.id}', 1, '${escapeHtml(doodle.username)}')`}"
                                title="${isOwnDoodle ? 'Cannot vote on own doodle' : 'Upvote'}">â–²</button>
                            <span class="vote-score ${scoreClass}">${doodle.votes}</span>
                            <button class="vote-btn downvote ${myVote === -1 ? 'active' : ''} ${isOwnDoodle ? 'disabled' : ''}"
                                onclick="${isOwnDoodle ? '' : `voteDoodle('${doodle.id}', -1, '${escapeHtml(doodle.username)}')`}"
                                title="${isOwnDoodle ? 'Cannot vote on own doodle' : 'Downvote'}">â–¼</button>
                        </div>
                    </div>
                    <div class="post-comments doodle-comments" id="doodle-comments-${doodle.id}">
                        ${commentsHtml}
                    </div>
                    ${replyIndicatorHtml}
                    <div class="comment-input-row">
                        <input class="comment-input" id="doodle-comment-input-${doodle.id}" placeholder="${replyingToDoodle && replyingToDoodle.doodleId === doodle.id ? 'Write a reply...' : 'Add a comment...'}" onkeydown="if(event.key==='Enter')addDoodleComment('${doodle.id}')">
                        <button class="comment-send" onclick="addDoodleComment('${doodle.id}')">POST</button>
                    </div>
                `;
                grid.appendChild(card);
            });

            container.appendChild(grid);
        }

        // Render threaded comments for doodles
        function renderDoodleComments(comments, doodleId) {
            const threads = {};
            const rootComments = [];

            comments.forEach(c => {
                const parentId = doodleCommentThreads[c.id];
                if (parentId) {
                    if (!threads[parentId]) threads[parentId] = [];
                    threads[parentId].push(c);
                } else {
                    rootComments.push(c);
                }
            });

            function renderComment(c, depth = 0) {
                const time = c.created_at ? new Date(c.created_at).toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'}) : '';
                const replies = threads[c.id] || [];
                const isNested = depth > 0;

                return `
                    <div class="comment ${isNested ? 'comment-thread' : ''}" data-comment-id="${c.id}" data-depth="${depth}">
                        <span class="comment-avatar">${c.avatar || 'ðŸ‘¤'}</span>
                        <div class="comment-content">
                            <span class="comment-username username-clickable" onclick="showProfileCard('${escapeHtml(c.username)}', event)">${escapeHtml(c.username)}</span>
                            <span class="comment-time">${time}</span>
                            <div class="comment-text">${escapeHtml(c.content)}</div>
                            <div class="comment-actions">
                                <button class="comment-reply-btn" onclick="startDoodleReply('${doodleId}', ${c.id}, '${escapeHtml(c.username)}')">â†© reply</button>
                            </div>
                        </div>
                        ${replies.length > 0 ? `<div class="comment-replies">${replies.map(r => renderComment(r, depth + 1)).join('')}</div>` : ''}
                    </div>
                `;
            }

            return rootComments.map(c => renderComment(c, 0)).join('');
        }

        window.focusDoodleComment = function(doodleId) {
            const input = document.getElementById(`doodle-comment-input-${doodleId}`);
            if (input) {
                input.scrollIntoView({ behavior: 'smooth', block: 'center' });
                input.focus();
            }
        };

        window.startDoodleReply = function(doodleId, commentId, username) {
            replyingToDoodle = { doodleId, commentId, username };
            loadDoodleLeaderboard();
            setTimeout(() => {
                const input = document.getElementById(`doodle-comment-input-${doodleId}`);
                if (input) input.focus();
            }, 50);
        };

        window.cancelDoodleReply = function() {
            replyingToDoodle = null;
            loadDoodleLeaderboard();
        };

        window.addDoodleComment = async function(doodleId) {
            if (!currentUser) return;

            const input = document.getElementById('doodle-comment-input-' + doodleId);
            var content = (input && input.value) ? input.value.trim() : '';
            if (!content) return;

            // Rate limit check
            const rateCheck = checkRateLimit('comment');
            if (!rateCheck.allowed) {
                showToast(rateCheck.message || 'Too many comments! Slow down.', 'warning');
                return;
            }
            recordAction('comment');

            const commentData = {
                doodle_id: doodleId,
                username: profile.username,
                avatar: profile.avatar,
                content: content,
                user_id: currentUser.id
            };

            // If replying to a comment, add parent reference
            if (replyingToDoodle && replyingToDoodle.doodleId === doodleId && replyingToDoodle.commentId) {
                commentData.parent_comment_id = replyingToDoodle.commentId;
            }

            const { data, error } = await supabase
                .from('sloppygram_doodle_comments')
                .insert(commentData)
                .select()
                .single();

            if (error) {
                console.error('Error adding doodle comment:', error);
                showToast('Failed to add comment', 'error');
                return;
            }

            // Add to local state
            if (!doodleComments[doodleId]) doodleComments[doodleId] = [];
            doodleComments[doodleId].push(data);
            if (replyingToDoodle && replyingToDoodle.commentId) {
                doodleCommentThreads[data.id] = replyingToDoodle.commentId;
            }

            input.value = '';
            replyingToDoodle = null;
            loadDoodleLeaderboard();
        };

        // Mobile sidebar toggle
        // === MOBILE MENU LOGIC ===
        window.toggleSidebar = function(side) {
            var sidebarLeft = document.getElementById('sidebarLeft');
            var sidebarRight = document.getElementById('sidebarRight');
            var backdrop = document.getElementById('mobileBackdrop');
            var hamburgerBtn = document.getElementById('hamburgerBtn');

            // Guard against null elements
            if (!sidebarLeft || !sidebarRight) return;

            // Close the other sidebar first
            if (side === 'left') {
                sidebarRight.classList.remove('mobile-show');
                sidebarLeft.classList.toggle('mobile-show');
                // Toggle hamburger animation
                if (hamburgerBtn) {
                    hamburgerBtn.classList.toggle('active', sidebarLeft.classList.contains('mobile-show'));
                }
            } else {
                sidebarLeft.classList.remove('mobile-show');
                sidebarRight.classList.toggle('mobile-show');
                // Remove hamburger active state when opening right sidebar
                if (hamburgerBtn) hamburgerBtn.classList.remove('active');
            }

            // Show backdrop if any sidebar is open
            var isAnyOpen = sidebarLeft.classList.contains('mobile-show') || sidebarRight.classList.contains('mobile-show');
            if (backdrop) backdrop.classList.toggle('active', isAnyOpen);

            // Prevent body scroll when sidebar open
            document.body.style.overflow = isAnyOpen ? 'hidden' : '';
        };

        window.closeSidebars = function() {
            var sidebarLeft = document.getElementById('sidebarLeft');
            var sidebarRight = document.getElementById('sidebarRight');
            var backdrop = document.getElementById('mobileBackdrop');
            var hamburgerBtn = document.getElementById('hamburgerBtn');

            if (sidebarLeft) sidebarLeft.classList.remove('mobile-show');
            if (sidebarRight) sidebarRight.classList.remove('mobile-show');
            if (backdrop) backdrop.classList.remove('active');
            if (hamburgerBtn) hamburgerBtn.classList.remove('active');
            document.body.style.overflow = '';
        };

        // Toggle mobile dropdown menu
        window.toggleMobileMenu = function() {
            var mobileMenu = document.getElementById('mobileMenu');
            var hamburgerBtn = document.getElementById('hamburgerBtn');

            if (!mobileMenu) return;

            var isOpen = mobileMenu.classList.contains('active');

            if (isOpen) {
                // Close menu
                mobileMenu.classList.remove('active');
                if (hamburgerBtn) hamburgerBtn.classList.remove('active');
            } else {
                // Open menu - close sidebars first
                window.closeSidebars();
                mobileMenu.classList.add('active');
                if (hamburgerBtn) hamburgerBtn.classList.add('active');
            }
        };

        // Close mobile menu when clicking outside
        document.addEventListener('click', function(e) {
            var mobileMenu = document.getElementById('mobileMenu');
            var hamburgerBtn = document.getElementById('hamburgerBtn');

            if (!mobileMenu || !mobileMenu.classList.contains('active')) return;

            // Check if click is outside menu and hamburger
            if (!mobileMenu.contains(e.target) && (!hamburgerBtn || !hamburgerBtn.contains(e.target))) {
                mobileMenu.classList.remove('active');
                if (hamburgerBtn) hamburgerBtn.classList.remove('active');
            }
        });

        // Close sidebars and mobile menu on escape key
        document.addEventListener('keydown', function(e) {
            if (e.key === 'Escape') {
                window.closeSidebars();
                // Also close mobile menu
                var mobileMenu = document.getElementById('mobileMenu');
                var hamburgerBtn = document.getElementById('hamburgerBtn');
                if (mobileMenu) mobileMenu.classList.remove('active');
                if (hamburgerBtn) hamburgerBtn.classList.remove('active');
            }
        });

        // === COLLABORATIVE CANVAS ===
        let collabCanvas, collabCtx, collabWrapper;
        let collabChannel = null;
        let collabColor = '#ff00ff';
        let collabIsEraser = false;
        const COLLAB_ERASER_COLOR = '#0a0a0a';
        let collabDrawing = false;
        let collabLastX = 0, collabLastY = 0;
        let collabInitialized = false;
        let collabUsers = new Map(); // Track other users' cursors
        const COLLAB_THROTTLE = 16; // ~60fps
        let lastCollabBroadcast = 0;

        // Stroke history for selective clearing
        let collabStrokes = []; // Array of {x1, y1, x2, y2, color, username}
        const COLLAB_MAX_STROKES = 10000; // Limit history size

        // Database persistence
        let collabStrokeBatch = []; // Batch queue for saving
        const COLLAB_BATCH_SIZE = 10; // Save every N strokes
        const COLLAB_BATCH_DELAY = 1000; // Or after 1 second
        let collabBatchTimeout = null;

        // Zoom/pan state
        let collabZoom = 1;
        const COLLAB_ZOOM_MIN = 0.25;
        const COLLAB_ZOOM_MAX = 4;
        const COLLAB_ZOOM_STEP = 0.25;

        async function initCollabCanvas() {
            if (collabInitialized) return;
            collabInitialized = true;

            collabCanvas = document.getElementById('collabCanvas');
            collabCtx = collabCanvas.getContext('2d');
            collabWrapper = document.getElementById('collabCanvasWrapper');

            // Fill with dark background
            collabCtx.fillStyle = '#0a0a0a';
            collabCtx.fillRect(0, 0, collabCanvas.width, collabCanvas.height);
            collabCtx.lineCap = 'round';
            collabCtx.lineJoin = 'round';
            collabCtx.lineWidth = 3;

            // Mouse events
            collabCanvas.addEventListener('mousedown', collabMouseDown);
            collabCanvas.addEventListener('mousemove', collabMouseMove);
            collabCanvas.addEventListener('mouseup', collabStopDraw);
            collabCanvas.addEventListener('mouseleave', collabStopDraw);

            // Touch events (2 fingers = pan, 1 finger = draw)
            collabCanvas.addEventListener('touchstart', collabTouchStart, { passive: false });
            collabCanvas.addEventListener('touchmove', collabTouchMove, { passive: false });
            collabCanvas.addEventListener('touchend', collabStopDraw);

            // Wheel zoom
            collabWrapper.addEventListener('wheel', collabWheelZoom, { passive: false });

            // Setup realtime channel
            setupCollabChannel();

            // Apply initial zoom
            updateCollabZoom();

            // Load existing strokes from database
            await loadCollabStrokes();
        }

        // Load persisted strokes from database
        async function loadCollabStrokes() {
            try {
                const { data, error } = await supabase
                    .from('sloppygram_collab_strokes')
                    .select('start_x, start_y, end_x, end_y, color, username')
                    .order('created_at', { ascending: true })
                    .limit(COLLAB_MAX_STROKES);

                if (error) {
                    console.error('Error loading collab strokes:', error);
                    return;
                }

                if (data && data.length > 0) {
                    // Convert DB format to local format
                    collabStrokes = data.map(s => ({
                        x1: s.start_x,
                        y1: s.start_y,
                        x2: s.end_x,
                        y2: s.end_y,
                        color: s.color,
                        username: s.username
                    }));

                    // Redraw all strokes
                    redrawCollabCanvas();
                    console.log(`Loaded ${data.length} strokes from database`);
                }
            } catch (err) {
                console.error('Failed to load collab strokes:', err);
            }
        }

        function getCollabCoords(clientX, clientY) {
            const rect = collabCanvas.getBoundingClientRect();
            // Account for zoom: rect size changes with CSS transform
            // Canvas internal size stays constant, so we need to map display coords to canvas coords
            const x = (clientX - rect.left) * (collabCanvas.width / rect.width);
            const y = (clientY - rect.top) * (collabCanvas.height / rect.height);
            return { x, y };
        }

        function collabMouseDown(e) {
            e.preventDefault();
            const coords = getCollabCoords(e.clientX, e.clientY);
            collabStartDraw(coords.x, coords.y);
        }

        function collabMouseMove(e) {
            const coords = getCollabCoords(e.clientX, e.clientY);
            collabDraw(coords.x, coords.y);
        }

        function collabTouchStart(e) {
            e.preventDefault();
            if (e.touches.length === 1) {
                const touch = e.touches[0];
                const coords = getCollabCoords(touch.clientX, touch.clientY);
                collabStartDraw(coords.x, coords.y);
            }
        }

        function collabTouchMove(e) {
            e.preventDefault();
            if (e.touches.length === 1) {
                const touch = e.touches[0];
                const coords = getCollabCoords(touch.clientX, touch.clientY);
                collabDraw(coords.x, coords.y);
            }
        }

        function collabStartDraw(x, y) {
            collabDrawing = true;
            collabLastX = x;
            collabLastY = y;
            collabCtx.beginPath();
            collabCtx.moveTo(x, y);
        }

        function collabDraw(x, y) {
            // Broadcast cursor position (throttled)
            const now = Date.now();
            if (now - lastCollabBroadcast > COLLAB_THROTTLE) {
                lastCollabBroadcast = now;
                broadcastCollabCursor(x, y);
            }

            if (!collabDrawing) return;

            // Draw locally - eraser has wider line
            collabCtx.strokeStyle = collabColor;
            collabCtx.lineWidth = collabIsEraser ? 20 : 3;
            collabCtx.lineTo(x, y);
            collabCtx.stroke();
            collabCtx.beginPath();
            collabCtx.moveTo(x, y);

            // Store stroke in history
            const stroke = { x1: collabLastX, y1: collabLastY, x2: x, y2: y, color: collabColor, username: profile.username };
            collabStrokes.push(stroke);
            if (collabStrokes.length > COLLAB_MAX_STROKES) {
                collabStrokes.shift(); // Remove oldest
            }

            // Queue stroke for database persistence
            queueCollabStroke(stroke);

            // Broadcast stroke
            broadcastCollabStroke(collabLastX, collabLastY, x, y, collabColor);

            collabLastX = x;
            collabLastY = y;
        }

        function collabStopDraw() {
            collabDrawing = false;
            // Flush any pending strokes when user stops drawing
            flushCollabStrokes();
        }

        // Batch save strokes to database
        function queueCollabStroke(stroke) {
            collabStrokeBatch.push(stroke);

            // Clear existing timeout
            if (collabBatchTimeout) {
                clearTimeout(collabBatchTimeout);
            }

            // Save immediately if batch is full, otherwise wait
            if (collabStrokeBatch.length >= COLLAB_BATCH_SIZE) {
                flushCollabStrokes();
            } else {
                collabBatchTimeout = setTimeout(flushCollabStrokes, COLLAB_BATCH_DELAY);
            }
        }

        async function flushCollabStrokes() {
            if (collabStrokeBatch.length === 0) return;

            const batch = collabStrokeBatch.slice();
            collabStrokeBatch = [];

            if (collabBatchTimeout) {
                clearTimeout(collabBatchTimeout);
                collabBatchTimeout = null;
            }

            try {
                const rows = batch.map(s => ({
                    start_x: Math.round(s.x1),
                    start_y: Math.round(s.y1),
                    end_x: Math.round(s.x2),
                    end_y: Math.round(s.y2),
                    color: s.color,
                    username: s.username,
                    user_id: (currentUser && currentUser.id) ? currentUser.id : null
                }));

                const { error } = await supabase
                    .from('sloppygram_collab_strokes')
                    .insert(rows);

                if (error) {
                    console.error('Error saving strokes:', error);
                }
            } catch (err) {
                console.error('Failed to save strokes:', err);
            }
        }

        // Zoom functions
        function collabWheelZoom(e) {
            e.preventDefault();
            const delta = e.deltaY > 0 ? -COLLAB_ZOOM_STEP : COLLAB_ZOOM_STEP;
            setCollabZoom(collabZoom + delta);
        }

        function setCollabZoom(newZoom) {
            collabZoom = Math.max(COLLAB_ZOOM_MIN, Math.min(COLLAB_ZOOM_MAX, newZoom));
            updateCollabZoom();
        }

        function updateCollabZoom() {
            if (collabCanvas && collabCanvas.style) {
                collabCanvas.style.transform = 'scale(' + collabZoom + ')';
            }
            var zoomLevel = document.getElementById('collabZoomLevel');
            if (zoomLevel) zoomLevel.textContent = Math.round(collabZoom * 100);

            // Update cursor overlay to match zoom
            var cursors = document.getElementById('collabCursors');
            if (cursors && cursors.style) {
                cursors.style.transform = 'scale(' + collabZoom + ')';
                cursors.style.transformOrigin = '0 0';
            }
        }

        window.collabZoomIn = function() {
            setCollabZoom(collabZoom + COLLAB_ZOOM_STEP);
        };

        window.collabZoomOut = function() {
            setCollabZoom(collabZoom - COLLAB_ZOOM_STEP);
        };

        window.collabZoomReset = function() {
            setCollabZoom(1);
            // Reset scroll position
            if (collabWrapper) {
                collabWrapper.scrollLeft = 0;
                collabWrapper.scrollTop = 0;
            }
        };

        // === STRESS TEST BOT ===
        // Tiny autonomous bot that draws random neon shapes on the canvas
        var stressBotInterval = null;
        var stressBotActive = false;
        var STRESS_BOT_COLORS = ['#00ff41', '#ff00ff', '#00ffff', '#ffff00', '#ff4444', '#ff8800', '#8844ff', '#44ff88'];

        window.startStressBot = function(speed) {
            if (stressBotActive) {
                showToast('Stress bot already running! Use stopStressBot() to stop.', 'warning');
                return;
            }
            if (!collabCanvas || !collabCtx) {
                showToast('Canvas not ready - switch to Collab tab first', 'error');
                return;
            }

            var interval = speed || 150; // ms between draws
            stressBotActive = true;
            showToast('ðŸ¤– Stress bot activated! Drawing at ' + interval + 'ms intervals', 'success');
            console.log('[STRESS BOT] Started - interval: ' + interval + 'ms');

            stressBotInterval = setInterval(function() {
                if (!collabCanvas || !collabCtx) {
                    window.stopStressBot();
                    return;
                }

                var shapeType = Math.floor(Math.random() * 4); // 0=line, 1=circle, 2=rect, 3=zigzag
                var color = STRESS_BOT_COLORS[Math.floor(Math.random() * STRESS_BOT_COLORS.length)];
                var x1 = Math.random() * collabCanvas.width;
                var y1 = Math.random() * collabCanvas.height;
                var x2 = Math.random() * collabCanvas.width;
                var y2 = Math.random() * collabCanvas.height;

                collabCtx.strokeStyle = color;
                collabCtx.fillStyle = color;
                collabCtx.lineWidth = Math.random() * 4 + 1;
                collabCtx.shadowColor = color;
                collabCtx.shadowBlur = 8;

                collabCtx.beginPath();

                if (shapeType === 0) {
                    // Neon line
                    collabCtx.moveTo(x1, y1);
                    collabCtx.lineTo(x2, y2);
                    collabCtx.stroke();
                } else if (shapeType === 1) {
                    // Neon circle
                    var radius = Math.random() * 30 + 5;
                    collabCtx.arc(x1, y1, radius, 0, Math.PI * 2);
                    if (Math.random() > 0.5) collabCtx.stroke();
                    else collabCtx.fill();
                } else if (shapeType === 2) {
                    // Neon rectangle
                    var w = Math.random() * 60 + 10;
                    var h = Math.random() * 60 + 10;
                    if (Math.random() > 0.5) collabCtx.strokeRect(x1, y1, w, h);
                    else collabCtx.fillRect(x1, y1, w, h);
                } else {
                    // Zigzag line
                    collabCtx.moveTo(x1, y1);
                    var steps = Math.floor(Math.random() * 5) + 3;
                    for (var i = 0; i < steps; i++) {
                        var nx = x1 + (x2 - x1) * (i + 1) / steps;
                        var ny = y1 + (y2 - y1) * (i + 1) / steps + (Math.random() - 0.5) * 40;
                        collabCtx.lineTo(nx, ny);
                    }
                    collabCtx.stroke();
                }

                collabCtx.shadowBlur = 0;

                // Broadcast to other users (simulate real drawing)
                if (collabChannel) {
                    collabChannel.send({
                        type: 'broadcast',
                        event: 'stroke',
                        payload: {
                            startX: x1, startY: y1, endX: x2, endY: y2,
                            color: color, username: 'ðŸ¤– StressBot'
                        }
                    });
                }
            }, interval);
        };

        window.stopStressBot = function() {
            if (stressBotInterval) {
                clearInterval(stressBotInterval);
                stressBotInterval = null;
            }
            stressBotActive = false;
            showToast('ðŸ¤– Stress bot stopped', 'info');
            console.log('[STRESS BOT] Stopped');
        };

        window.stressBotStatus = function() {
            console.log('[STRESS BOT] Active:', stressBotActive);
            return stressBotActive;
        };

        function setupCollabChannel() {
            if (collabChannel) return;

            collabChannel = supabase.channel('sloppygram-collab-canvas', {
                config: { broadcast: { self: false } }
            });

            // Listen for strokes from other users
            collabChannel.on('broadcast', { event: 'stroke' }, ({ payload }) => {
                drawRemoteStroke(payload);
            });

            // Listen for cursor positions
            collabChannel.on('broadcast', { event: 'cursor' }, ({ payload }) => {
                updateRemoteCursor(payload);
            });

            // Listen for clear_user events (remove specific user's strokes)
            collabChannel.on('broadcast', { event: 'clear_user' }, ({ payload }) => {
                collabStrokes = collabStrokes.filter(s => s.username !== payload.username);
                redrawCollabCanvas();
            });

            // Listen for clear_all events (wipe entire canvas)
            collabChannel.on('broadcast', { event: 'clear_all' }, () => {
                collabStrokes = [];
                collabCtx.fillStyle = '#0a0a0a';
                collabCtx.fillRect(0, 0, collabCanvas.width, collabCanvas.height);
            });

            // Track presence
            collabChannel.on('presence', { event: 'sync' }, () => {
                const state = collabChannel.presenceState();
                const count = Object.keys(state).length;
                document.getElementById('collabUserCount').textContent = count;
            });

            collabChannel.on('presence', { event: 'leave' }, ({ key }) => {
                // Remove cursor when user leaves
                const cursor = document.getElementById('cursor-' + key);
                if (cursor) cursor.remove();
                collabUsers.delete(key);
            });

            collabChannel.subscribe(async (status) => {
                if (status === 'SUBSCRIBED') {
                    await collabChannel.track({
                        username: profile.username,
                        avatar: profile.avatar,
                        color: collabColor
                    });
                }
            });
        }

        function broadcastCollabStroke(x1, y1, x2, y2, color) {
            if (!collabChannel) return;
            collabChannel.send({
                type: 'broadcast',
                event: 'stroke',
                payload: {
                    x1, y1, x2, y2, color,
                    username: profile.username,
                    avatar: profile.avatar
                }
            });
        }

        function broadcastCollabCursor(x, y) {
            if (!collabChannel) return;
            collabChannel.send({
                type: 'broadcast',
                event: 'cursor',
                payload: {
                    x, y,
                    username: profile.username,
                    avatar: profile.avatar,
                    color: collabColor
                }
            });
        }

        function drawRemoteStroke(payload) {
            const { x1, y1, x2, y2, color, username } = payload;

            // Store in history
            collabStrokes.push({ x1, y1, x2, y2, color, username });
            if (collabStrokes.length > COLLAB_MAX_STROKES) {
                collabStrokes.shift();
            }

            // Draw - eraser strokes are wider
            const isEraser = color === COLLAB_ERASER_COLOR;
            collabCtx.save();
            collabCtx.strokeStyle = color;
            collabCtx.lineWidth = isEraser ? 20 : 3;
            collabCtx.lineCap = 'round';
            collabCtx.beginPath();
            collabCtx.moveTo(x1, y1);
            collabCtx.lineTo(x2, y2);
            collabCtx.stroke();
            collabCtx.restore();
        }

        function updateRemoteCursor(payload) {
            const { x, y, username, avatar, color } = payload;
            const cursorId = 'cursor-' + username;
            let cursor = document.getElementById(cursorId);

            if (!cursor) {
                cursor = document.createElement('div');
                cursor.id = cursorId;
                cursor.className = 'collab-cursor';
                cursor.innerHTML = `
                    <div class="collab-cursor-dot" style="background:${color};color:${color}"></div>
                    <div class="collab-cursor-name">${avatar} ${username}</div>
                `;
                document.getElementById('collabCursors').appendChild(cursor);
            }

            // Position in canvas coordinates (cursors container is scaled with CSS transform)
            cursor.style.left = x + 'px';
            cursor.style.top = y + 'px';
            cursor.querySelector('.collab-cursor-dot').style.background = color;
            cursor.querySelector('.collab-cursor-dot').style.color = color;

            // Update color if changed
            collabUsers.set(username, { x, y, color, avatar });
        }

        window.setCollabColor = function(color) {
            collabColor = color;
            collabIsEraser = (color === COLLAB_ERASER_COLOR);
            document.querySelectorAll('.collab-color-btn').forEach(btn => {
                btn.classList.toggle('active', btn.dataset.color === color);
            });
            // Update presence with new color
            if (collabChannel) {
                collabChannel.track({
                    username: profile.username,
                    avatar: profile.avatar,
                    color: collabColor
                });
            }
        };

        // Redraw all strokes from history
        function redrawCollabCanvas() {
            if (!collabCtx) return;
            // Clear canvas
            collabCtx.fillStyle = '#0a0a0a';
            collabCtx.fillRect(0, 0, collabCanvas.width, collabCanvas.height);

            // Redraw all strokes
            collabCtx.save();
            collabCtx.lineCap = 'round';
            collabStrokes.forEach(stroke => {
                // Eraser strokes are wider
                const isEraser = stroke.color === COLLAB_ERASER_COLOR;
                collabCtx.lineWidth = isEraser ? 20 : 3;
                collabCtx.strokeStyle = stroke.color;
                collabCtx.beginPath();
                collabCtx.moveTo(stroke.x1, stroke.y1);
                collabCtx.lineTo(stroke.x2, stroke.y2);
                collabCtx.stroke();
            });
            collabCtx.restore();
        }

        // Clear only the current user's strokes
        window.clearCollabCanvas = async function() {
            if (!collabCtx) return;
            const myUsername = profile.username;

            // Remove user's strokes from history
            collabStrokes = collabStrokes.filter(s => s.username !== myUsername);

            // Redraw canvas with remaining strokes
            redrawCollabCanvas();

            // Delete user's strokes from database
            try {
                var currentUserId = (currentUser && currentUser.id) ? currentUser.id : null;
                const { error } = await supabase
                    .from('sloppygram_collab_strokes')
                    .delete()
                    .eq('user_id', currentUserId);

                if (error) {
                    console.error('Error deleting strokes from DB:', error);
                }
            } catch (err) {
                console.error('Failed to delete strokes:', err);
            }

            // Broadcast clear_user to others so they remove this user's strokes
            if (collabChannel) {
                collabChannel.send({
                    type: 'broadcast',
                    event: 'clear_user',
                    payload: { username: myUsername }
                });
            }
        };

        // Clear entire canvas (all users) - admin function
        window.clearCollabCanvasAll = async function() {
            if (!collabCtx) return;
            collabStrokes = [];
            collabCtx.fillStyle = '#0a0a0a';
            collabCtx.fillRect(0, 0, collabCanvas.width, collabCanvas.height);

            // Note: Can't delete all strokes due to RLS - only own strokes
            // This just clears visually and broadcasts

            if (collabChannel) {
                collabChannel.send({
                    type: 'broadcast',
                    event: 'clear_all',
                    payload: { username: profile.username }
                });
            }
        };

        // Snapshot collab canvas and post to main feed as a doodle
        window.snapshotCollabCanvas = async function() {
            if (!collabCanvas || !collabCtx) {
                showToast('Canvas not ready', 'error');
                return;
            }

            // Check rate limit (returns object with {allowed, waitTime, message})
            const rateCheck = checkRateLimit('drawing');
            if (!rateCheck.allowed) {
                showToast(rateCheck.message || 'Too many snapshots! Wait a moment.', 'warning');
                return;
            }
            recordAction('drawing');

            // Check if canvas has any strokes (prevent white/empty image)
            if (collabStrokes.length === 0) {
                showToast('Canvas is empty - draw something first!', 'warning');
                return;
            }

            try {
                // Ensure canvas has dark background before capture (fix white-image issue)
                // Create a temp canvas with proper background
                const tempCanvas = document.createElement('canvas');
                tempCanvas.width = collabCanvas.width;
                tempCanvas.height = collabCanvas.height;
                const tempCtx = tempCanvas.getContext('2d');

                // Fill with dark background first
                tempCtx.fillStyle = '#0a0a0a';
                tempCtx.fillRect(0, 0, tempCanvas.width, tempCanvas.height);

                // Draw the collab canvas on top
                tempCtx.drawImage(collabCanvas, 0, 0);

                // Get canvas data as PNG from temp canvas
                const dataUrl = tempCanvas.toDataURL('image/png');

                // Convert to blob for upload
                const blob = await (await fetch(dataUrl)).blob();

                // Use uploadToStorage helper (with fallback to base64)
                const storageUrl = await uploadToStorage(blob, 'collab_snapshots');
                if (!storageUrl) {
                    console.warn('Collab snapshot: Storage upload failed, falling back to base64');
                }
                const finalDrawingData = storageUrl || dataUrl;

                // Insert into messages table
                const { data, error } = await supabase
                    .from('sloppygram_messages')
                    .insert({
                        username: profile.username,
                        avatar: profile.avatar,
                        avatar_url: profile.avatarUrl || null,
                        content: 'ðŸ“¸ Collab Canvas Snapshot',
                        drawing_data: finalDrawingData,
                        message_type: 'drawing',
                        user_id: (currentUser && currentUser.id) ? currentUser.id : null
                    })
                    .select()
                    .single();

                if (error) {
                    console.error('Error saving snapshot:', error);
                    showToast('Failed to save snapshot', 'error');
                    return;
                }

                // Log AI event
                await supabase.from('ai_events').insert({
                    event_type: 'collab_snapshot',
                    entity_type: 'drawing',
                    entity_id: data.id,
                    username: profile.username,
                    metadata: { source: 'collab_canvas', stroke_count: collabStrokes.length },
                    user_id: (currentUser && currentUser.id) ? currentUser.id : null
                });

                // Show success and switch to doodles tab
                showToast('ðŸ“¸ Snapshot saved to doodles!', 'success');

                // Broadcast to realtime so others see it
                if (realtimeChannel) {
                    realtimeChannel.send({
                        type: 'broadcast',
                        event: 'new_message',
                        payload: { ...data, avatar_url: profile.avatarUrl }
                    });
                }

                // Switch to doodles view to show the snapshot
                switchView('doodles');

            } catch (err) {
                console.error('Snapshot failed:', err);
                showToast('Snapshot failed: ' + err.message, 'error');
            }
        };

        // Mobile touch swipe navigation
        const VIEWS = ['chat', 'posts', 'doodles', 'manifesto', 'collab'];
        let touchStartX = 0;
        let touchStartY = 0;
        let touchEndX = 0;
        let touchEndY = 0;
        const MIN_SWIPE_DISTANCE = 80;
        const MAX_VERTICAL_DISTANCE = 100;

        function isMobile() {
            return window.matchMedia('(max-width: 768px)').matches ||
                   'ontouchstart' in window ||
                   navigator.maxTouchPoints > 0;
        }

        function handleSwipe() {
            const deltaX = touchEndX - touchStartX;
            const deltaY = Math.abs(touchEndY - touchStartY);

            // Only trigger swipe if horizontal movement is significant and vertical is minimal
            if (Math.abs(deltaX) > MIN_SWIPE_DISTANCE && deltaY < MAX_VERTICAL_DISTANCE) {
                const currentIndex = VIEWS.indexOf(currentView);

                if (deltaX < 0 && currentIndex < VIEWS.length - 1) {
                    // Swipe left - go to next tab
                    switchView(VIEWS[currentIndex + 1]);
                } else if (deltaX > 0 && currentIndex > 0) {
                    // Swipe right - go to previous tab
                    switchView(VIEWS[currentIndex - 1]);
                }
            }
        }

        function initTouchSwipe() {
            const mainContent = document.querySelector('.main-content');
            if (!mainContent) return;

            mainContent.addEventListener('touchstart', (e) => {
                if (!isMobile()) return;
                touchStartX = e.changedTouches[0].screenX;
                touchStartY = e.changedTouches[0].screenY;
            }, { passive: true });

            mainContent.addEventListener('touchend', (e) => {
                if (!isMobile()) return;
                touchEndX = e.changedTouches[0].screenX;
                touchEndY = e.changedTouches[0].screenY;
                handleSwipe();
            }, { passive: true });
        }

        // Initialize touch swipe after DOM ready
        document.addEventListener('DOMContentLoaded', initTouchSwipe);

        // Initialize
        init();
    </script>
</body>
</html>
