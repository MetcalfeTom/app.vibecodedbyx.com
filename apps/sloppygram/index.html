<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>Sloppygram - Cyber Chat 1999</title>
    <link rel="icon" href="https://emojicdn.elk.sh/ðŸ’¾">

    <meta property="og:title" content="Sloppygram">
    <meta property="og:description" content="Retro cyber chatroom from 1999. Global chat and pure vibes.">
    <meta property="og:url" content="https://sloppy.live/sloppygram">
    <meta property="og:image" content="https://image.pollinations.ai/prompt/1990s%20retro%20cyber%20chatroom%20neon%20green%20dark%20hacker%20aesthetic%20terminal?width=1200&height=630&nologo=true">
    <meta property="og:type" content="website">

    <link href="https://fonts.googleapis.com/css2?family=VT323&family=Share+Tech+Mono&display=swap" rel="stylesheet">

    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        :root {
            --accent: #7c9885;
            --accent-light: #a8c4b0;
            --accent-dim: #5a7060;
            --highlight: #c9a87c;
            --dark-bg: #0a0a0f;
            --panel-bg: #12121a;
            --border-color: #2a2a35;
            --text-dim: #6a6a75;
            --msg-opacity: 0.95;
            --msg-color: 10, 10, 15;
            --msg-own-color: 90, 112, 96;
        }

        body {
            font-family: 'VT323', monospace;
            background: var(--dark-bg);
            min-height: 100vh;
            color: var(--accent);
            overflow: hidden;
        }

        /* Scanline effect */
        body::before {
            content: '';
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: repeating-linear-gradient(
                0deg,
                rgba(0, 0, 0, 0.15),
                rgba(0, 0, 0, 0.15) 1px,
                transparent 1px,
                transparent 2px
            );
            pointer-events: none;
            z-index: 9999;
        }

        .app {
            display: grid;
            grid-template-columns: 200px 1fr 180px;
            grid-template-rows: auto 1fr;
            height: 100vh;
            gap: 1px;
            background: transparent;
        }

        /* Hide sidebar close buttons on desktop */
        .sidebar-close-btn {
            display: none;
        }

        @media (max-width: 768px) {
            .app {
                grid-template-columns: 1fr;
                grid-template-rows: auto 1fr;
                height: 100vh;
                height: 100dvh;
                width: 100%;
                max-width: 100vw;
                overflow-x: hidden;
            }

            .sidebar-close-btn {
                display: flex;
                align-items: center;
                justify-content: center;
                width: 30px;
                height: 30px;
                position: absolute;
                top: 8px;
                right: 8px;
                background: var(--border-color);
                border: none;
                color: var(--accent);
                font-size: 1.2rem;
                cursor: pointer;
                border-radius: 4px;
                z-index: 10;
            }

            .sidebar-close-btn:hover {
                background: var(--accent-dim);
            }

            .mobile-backdrop {
                display: none;
                position: fixed;
                top: 60px;
                left: 0;
                right: 0;
                bottom: 0;
                background: rgba(0, 0, 0, 0.6);
                z-index: 100;
            }

            .mobile-backdrop.active {
                display: block;
            }
        }

        /* Header */
        .header {
            grid-column: 1 / -1;
            grid-row: 1;
            background: var(--panel-bg);
            padding: 8px 16px;
            display: flex;
            align-items: center;
            justify-content: space-between;
            flex-shrink: 0;
            min-height: 50px;
            z-index: 10;
            position: relative;
        }

        .logo {
            font-size: 1.8rem;
            color: var(--accent-light);
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .logo-blink {
            animation: blink 1s infinite;
        }

        @keyframes blink {
            0%, 50% { opacity: 1; }
            51%, 100% { opacity: 0; }
        }

        .marquee-container {
            flex: 1;
            overflow: hidden;
            margin: 0 20px;
            color: var(--highlight);
            font-size: 1.1rem;
        }

        .marquee {
            display: inline-block;
            white-space: nowrap;
            animation: marquee 20s linear infinite;
        }

        @keyframes marquee {
            from { transform: translateX(100%); }
            to { transform: translateX(-100%); }
        }

        .header-actions {
            display: flex;
            gap: 8px;
        }

        .cyber-btn {
            background: transparent;
            border: 1px solid var(--border-color);
            color: var(--accent);
            padding: 6px 12px;
            font-family: inherit;
            font-size: 1rem;
            cursor: pointer;
            transition: all 0.2s;
        }

        .cyber-btn:hover {
            background: var(--accent-dim);
            color: white;
        }

        /* Sidebars */
        .sidebar-left, .sidebar-right {
            grid-row: 2;
            background: var(--panel-bg);
            padding: 12px;
            overflow-y: auto;
            display: flex;
            flex-direction: column;
        }

        /* Mobile: completely hide sidebars when not active */
        @media (max-width: 768px) {
            .sidebar-left, .sidebar-right {
                display: none;
                position: fixed;
                top: 60px;
                bottom: 0;
                width: 75%;
                max-width: 280px;
                z-index: 101;
                box-shadow: 0 0 20px rgba(0,0,0,0.5);
            }
            .sidebar-left.mobile-show, .sidebar-right.mobile-show {
                display: flex;
            }
            .sidebar-left.mobile-show { left: 0; }
            .sidebar-right.mobile-show { right: 0; }

            .main-content {
                width: 100%;
                height: calc(100vh - 60px);
                height: calc(100dvh - 60px);
                max-height: calc(100vh - 60px);
                max-height: calc(100dvh - 60px);
                overflow: hidden;
                display: flex;
                flex-direction: column;
            }

            .input-area {
                flex-shrink: 0;
                position: sticky;
                top: 0;
                z-index: 10;
                background: var(--panel-bg);
            }

            .messages-container,
            .posts-container,
            .doodles-container,
            .manifesto-container {
                flex: 1;
                min-height: 0;
                max-height: none;
                overflow-y: auto;
                -webkit-overflow-scrolling: touch;
                width: 100%;
                padding: 8px;
                box-sizing: border-box;
            }

            .view-tabs {
                flex-shrink: 0;
                width: 100%;
            }

            .input-area {
                width: 100%;
                padding: 8px;
                box-sizing: border-box;
            }

            .input-row {
                width: 100%;
                max-width: 100%;
            }

            .message, .post, .doodle-card, .manifesto-item {
                width: 100%;
                max-width: 100%;
                box-sizing: border-box;
            }

            /* Prevent iOS auto-zoom on inputs */
            input, textarea, select {
                font-size: 16px !important;
            }
        }

        #publicFeed {
            max-height: 40vh;
            overflow-y: auto;
            flex-shrink: 1;
        }

        .panel-title {
            color: var(--highlight);
            font-size: 1.2rem;
            margin-bottom: 10px;
            padding-bottom: 6px;
            border-bottom: 1px solid var(--border-color);
        }

        /* Online Users */
        .user-list {
            list-style: none;
        }

        .user-item {
            padding: 6px 8px;
            margin-bottom: 4px;
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 1rem;
            border-left: 2px solid transparent;
            transition: all 0.2s;
        }

        .user-item:hover {
            background: rgba(255, 255, 255, 0.05);
            border-left-color: var(--accent);
        }

        .user-status {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: var(--accent);
            animation: pulse 2s infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        .user-avatar {
            font-size: 1.2rem;
        }

        .user-name {
            color: var(--accent-light);
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        /* Public Feed */
        .feed-item {
            padding: 8px;
            margin-bottom: 8px;
            background: rgba(255, 255, 255, 0.02);
            border-left: 2px solid var(--border-color);
            font-size: 0.95rem;
        }

        .feed-user {
            color: var(--highlight);
        }

        .feed-action {
            color: var(--text-dim);
        }

        .feed-time {
            color: #666;
            font-size: 0.85rem;
        }

        /* Messages Container */
        .main-content {
            grid-row: 2;
            background: var(--panel-bg);
            display: flex;
            flex-direction: column;
            overflow: hidden;
            min-height: 0;
        }

        .messages-container {
            flex: 1;
            overflow-y: auto;
            padding: 16px;
            display: flex;
            flex-direction: column;
            gap: 12px;
            min-height: 0;
            position: relative;
            background-size: cover;
            background-position: center;
            background-attachment: fixed;
            background-repeat: no-repeat;
            image-rendering: -webkit-optimize-contrast;
            image-rendering: crisp-edges;
        }

        .messages-container::-webkit-scrollbar {
            width: 8px;
        }

        .messages-container::-webkit-scrollbar-track {
            background: var(--dark-bg);
        }

        .messages-container::-webkit-scrollbar-thumb {
            background: var(--border-color);
        }

        .message {
            display: flex;
            gap: 10px;
            animation: glitchIn 0.3s ease-out;
        }

        @keyframes glitchIn {
            0% { opacity: 0; transform: translateX(-10px); }
            50% { opacity: 1; transform: translateX(3px); }
            100% { transform: translateX(0); }
        }

        .message.own {
            flex-direction: row-reverse;
        }

        .avatar {
            width: 40px;
            height: 40px;
            border: 1px solid var(--border-color);
            border-radius: 4px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 24px;
            flex-shrink: 0;
            background: var(--dark-bg);
        }

        .message-bubble {
            max-width: 70%;
            background: rgba(var(--msg-color), var(--msg-opacity));
            border: 1px solid var(--border-color);
            border-radius: 4px;
            padding: 10px 14px;
            color: var(--accent);
        }

        .message.own .message-bubble {
            background: rgba(var(--msg-own-color), var(--msg-opacity));
            color: var(--accent-light);
        }

        .message-header {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 4px;
        }

        .message-username {
            color: var(--accent-light);
            font-size: 1rem;
        }

        .message.own .message-username {
            color: var(--highlight);
        }

        .message-time {
            font-size: 0.85rem;
            color: #555;
        }

        .message-content {
            font-size: 1.1rem;
            line-height: 1.4;
            word-wrap: break-word;
        }

        .message-image, .message-drawing {
            max-width: 100%;
            margin-top: 8px;
            cursor: pointer;
            border: 1px solid var(--border-color);
        }

        /* Doodle Vote */
        .doodle-wrapper {
            position: relative;
            display: inline-block;
        }

        .doodle-vote-btn {
            position: absolute;
            bottom: 8px;
            right: 8px;
            background: rgba(0,0,0,0.7);
            border: 1px solid var(--border-color);
            color: var(--text-dim);
            padding: 4px 10px;
            font-family: inherit;
            font-size: 0.9rem;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 4px;
            transition: all 0.2s;
        }

        .doodle-vote-btn:hover {
            background: rgba(0,0,0,0.9);
            border-color: var(--highlight);
            color: var(--highlight);
        }

        .doodle-vote-btn.voted {
            color: var(--highlight);
            border-color: var(--highlight);
        }

        /* Vote controls (up/down) */
        .vote-controls {
            display: inline-flex;
            align-items: center;
            gap: 2px;
            background: rgba(0,0,0,0.3);
            border-radius: 12px;
            padding: 2px 4px;
        }

        .vote-btn {
            background: transparent;
            border: none;
            color: var(--text-dim);
            padding: 2px 6px;
            font-size: 0.85rem;
            cursor: pointer;
            transition: all 0.15s;
            border-radius: 8px;
        }

        .vote-btn:hover {
            background: rgba(255,255,255,0.1);
        }

        .vote-btn.upvote:hover, .vote-btn.upvote.active {
            color: #00ff41;
        }

        .vote-btn.downvote:hover, .vote-btn.downvote.active {
            color: #ff4444;
        }

        .vote-btn.disabled {
            opacity: 0.3;
            cursor: not-allowed;
        }

        .vote-score {
            font-size: 0.8rem;
            min-width: 20px;
            text-align: center;
            font-weight: bold;
        }

        .vote-score.positive { color: #00ff41; }
        .vote-score.negative { color: #ff4444; }
        .vote-score.neutral { color: var(--text-dim); }

        .message-footer {
            margin-top: 6px;
            padding-top: 4px;
        }

        .msg-delete-btn {
            background: transparent;
            border: none;
            color: var(--text-dim);
            cursor: pointer;
            padding: 2px 6px;
            font-size: 0.9rem;
            opacity: 0.7;
            margin-left: auto;
            transition: all 0.2s;
        }

        .msg-delete-btn:hover {
            opacity: 1;
            color: #ff6666;
            background: rgba(255, 100, 100, 0.1);
            border-radius: 4px;
        }

        .message-header {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        /* Doodle Leaderboard */
        .doodles-container {
            flex: 1;
            overflow-y: auto;
            padding: 16px;
            display: none;
            flex-direction: column;
            gap: 16px;
            min-height: 0;
        }

        .doodles-container.active {
            display: flex;
        }

        .leaderboard-header {
            text-align: center;
            padding: 16px;
            color: var(--accent);
            font-size: 1.1rem;
            border-bottom: 1px solid var(--border-color);
        }

        .doodle-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
            gap: 16px;
        }

        .doodle-card {
            background: var(--panel-bg);
            border: 1px solid var(--border-color);
            overflow: hidden;
            border-radius: 8px;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .doodle-card:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 20px rgba(0,0,0,0.3);
        }

        .doodle-card.top-3 {
            border-color: var(--highlight);
        }

        .doodle-rank {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 8px 12px;
            background: var(--dark-bg);
        }

        .rank-badge {
            width: 28px;
            height: 28px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            font-size: 0.9rem;
            background: var(--border-color);
            color: var(--text-dim);
        }

        .rank-badge.gold {
            background: linear-gradient(135deg, #ffd700, #ffaa00);
            color: #000;
        }
        .rank-badge.silver {
            background: linear-gradient(135deg, #e0e0e0, #a0a0a0);
            color: #000;
        }
        .rank-badge.bronze {
            background: linear-gradient(135deg, #cd7f32, #8b4513);
            color: #fff;
        }

        .doodle-artist {
            flex: 1;
            color: var(--accent-light);
            font-size: 0.9rem;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .doodle-votes {
            color: var(--highlight);
            font-size: 1rem;
            font-weight: bold;
        }

        .doodle-thumbnail {
            position: relative;
            background: #111;
            aspect-ratio: 4/3;
            overflow: hidden;
        }

        .doodle-card img {
            width: 100%;
            height: 100%;
            object-fit: contain;
            display: block;
            cursor: pointer;
            transition: transform 0.2s;
        }

        .doodle-card:hover img {
            transform: scale(1.05);
        }

        .doodle-card-actions {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px 12px;
            border-top: 1px solid var(--border-color);
            background: var(--dark-bg);
        }

        .doodle-time {
            color: var(--text-dim);
            font-size: 0.75rem;
        }

        .empty-doodles {
            text-align: center;
            padding: 60px 20px;
            color: var(--text-dim);
        }

        /* Manifesto Section */
        .manifesto-container {
            flex: 1;
            overflow-y: auto;
            padding: 16px;
            display: none;
            flex-direction: column;
            gap: 16px;
            min-height: 0;
        }

        .manifesto-container.active {
            display: flex;
        }

        /* Collaborative Canvas */
        .collab-container {
            flex: 1;
            overflow-y: auto;
            padding: 16px;
            display: none;
            flex-direction: column;
            gap: 16px;
            min-height: 0;
            align-items: center;
        }

        .collab-container.active {
            display: flex;
        }

        .collab-header {
            text-align: center;
            padding: 10px 20px;
        }

        .collab-header h2 {
            color: var(--accent);
            font-size: 1.3rem;
            margin-bottom: 4px;
        }

        .collab-subtitle {
            color: var(--text-dim);
            font-size: 0.85rem;
            margin-bottom: 8px;
        }

        .collab-users {
            display: flex;
            justify-content: center;
            gap: 8px;
        }

        .collab-user-count,
        .collab-zoom-level {
            background: rgba(0,255,65,0.1);
            border: 1px solid var(--accent);
            padding: 4px 12px;
            border-radius: 20px;
            font-size: 0.8rem;
            color: var(--accent);
        }

        .collab-canvas-wrapper {
            position: relative;
            border: 2px solid var(--accent);
            box-shadow: 0 0 20px rgba(0,255,65,0.2);
            background: #0a0a0a;
            width: 100%;
            max-width: 900px;
            height: 500px;
            overflow: auto;
        }

        #collabCanvas {
            display: block;
            cursor: crosshair;
            transform-origin: 0 0;
            transition: transform 0.1s ease-out;
        }

        .collab-zoom-controls {
            display: flex;
            gap: 4px;
        }

        .collab-zoom-btn {
            padding: 6px 12px;
            font-size: 0.9rem;
            min-width: 36px;
        }

        .collab-cursors {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            pointer-events: none;
            overflow: hidden;
        }

        .collab-cursor {
            position: absolute;
            pointer-events: none;
            transition: left 0.05s linear, top 0.05s linear;
            z-index: 10;
        }

        .collab-cursor-dot {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            border: 2px solid #fff;
            box-shadow: 0 0 8px currentColor;
        }

        .collab-cursor-name {
            position: absolute;
            top: 14px;
            left: 8px;
            font-size: 0.65rem;
            background: rgba(0,0,0,0.8);
            padding: 2px 6px;
            border-radius: 4px;
            white-space: nowrap;
            color: #fff;
        }

        .collab-controls {
            display: flex;
            flex-wrap: wrap;
            gap: 16px;
            align-items: center;
            justify-content: center;
            padding: 10px;
        }

        .collab-colors {
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
            justify-content: center;
        }

        .collab-color-btn {
            width: 32px;
            height: 32px;
            border-radius: 50%;
            border: 2px solid transparent;
            cursor: pointer;
            transition: all 0.2s;
        }

        .collab-color-btn:hover {
            transform: scale(1.1);
        }

        .collab-color-btn.active {
            border-color: #fff;
            box-shadow: 0 0 10px currentColor;
        }

        .collab-clear-btn {
            font-size: 0.8rem;
            padding: 8px 16px;
        }

        @media (max-width: 768px) {
            .collab-canvas-wrapper {
                width: 100%;
            }
            #collabCanvas {
                width: 100%;
                height: auto;
            }
        }

        .manifesto-header {
            text-align: center;
            padding: 20px;
            border-bottom: 1px solid var(--border-color);
        }

        .manifesto-header h2 {
            color: var(--highlight);
            font-size: 1.4rem;
            margin-bottom: 8px;
        }

        .manifesto-subtitle {
            color: var(--text-dim);
            font-size: 0.95rem;
            margin-bottom: 16px;
        }

        .manifesto-list {
            display: flex;
            flex-direction: column;
            gap: 16px;
        }

        .manifesto-card {
            background: linear-gradient(135deg, rgba(201,168,124,0.1), rgba(124,152,133,0.05));
            border: 1px solid var(--border-color);
            border-left: 3px solid var(--highlight);
            padding: 16px;
            transition: all 0.2s;
        }

        .manifesto-card:hover {
            border-color: var(--highlight);
            box-shadow: 0 4px 20px rgba(201,168,124,0.1);
        }

        .manifesto-card-header {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 12px;
        }

        .manifesto-avatar {
            width: 32px;
            height: 32px;
            border-radius: 50%;
            background: var(--dark-bg);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 18px;
            border: 1px solid var(--border-color);
        }

        .manifesto-author {
            color: var(--accent-light);
            font-size: 1rem;
        }

        .manifesto-time {
            margin-left: auto;
            color: var(--text-dim);
            font-size: 0.85rem;
        }

        .manifesto-title {
            color: var(--highlight);
            font-size: 1.2rem;
            margin-bottom: 10px;
            font-weight: normal;
        }

        .manifesto-text {
            color: var(--accent-light);
            font-size: 1rem;
            line-height: 1.6;
            white-space: pre-wrap;
        }

        .manifesto-actions {
            display: flex;
            gap: 12px;
            margin-top: 12px;
            padding-top: 12px;
            border-top: 1px solid var(--border-color);
        }

        .manifesto-vote-btn {
            background: transparent;
            border: 1px solid var(--border-color);
            color: var(--accent);
            padding: 6px 12px;
            cursor: pointer;
            font-family: inherit;
            font-size: 0.9rem;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .manifesto-vote-btn:hover {
            border-color: var(--highlight);
            color: var(--highlight);
        }

        .manifesto-vote-btn.voted {
            background: var(--highlight);
            border-color: var(--highlight);
            color: var(--dark-bg);
        }

        .manifesto-modal {
            max-width: 600px;
        }

        /* Transparency Slider Bar */
        .transparency-bar {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 6px 16px;
            background: var(--dark-bg);
            border-top: 1px solid var(--border-color);
            font-size: 0.8rem;
            color: var(--text-dim);
        }

        .transparency-bar label {
            white-space: nowrap;
        }

        .transparency-bar input[type="range"] {
            flex: 1;
            max-width: 120px;
            height: 4px;
            -webkit-appearance: none;
            background: var(--border-color);
            border-radius: 2px;
            cursor: pointer;
        }

        .transparency-bar input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 14px;
            height: 14px;
            background: var(--accent);
            border-radius: 50%;
            cursor: pointer;
        }

        .transparency-bar #opacityValue {
            min-width: 35px;
            text-align: right;
            color: var(--accent);
        }

        /* Input Area - now at top of chat */
        .input-area {
            background: var(--dark-bg);
            padding: 12px 16px;
            flex-shrink: 0;
            position: relative;
            z-index: 5;
            border-bottom: 1px solid var(--border-color);
        }

        .input-row {
            display: flex;
            gap: 8px;
            align-items: flex-end;
            max-width: 800px;
            margin: 0 auto;
        }

        .input-actions {
            display: flex;
            gap: 4px;
        }

        .action-btn {
            width: 40px;
            height: 40px;
            border: 1px solid var(--border-color);
            background: transparent;
            color: var(--accent);
            font-size: 18px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .action-btn:hover {
            background: var(--accent-dim);
            color: white;
        }

        .message-input {
            flex: 1;
            background: var(--panel-bg);
            border: 1px solid var(--border-color);
            padding: 10px 16px;
            color: var(--accent-light);
            font-family: inherit;
            font-size: 1.1rem;
            resize: none;
            max-height: 100px;
        }

        .message-input:focus {
            outline: none;
            border-color: var(--accent-dim);
        }

        .message-input::placeholder {
            color: var(--text-dim);
        }

        .send-btn {
            width: 60px;
            height: 40px;
            border: 1px solid var(--border-color);
            background: var(--accent-dim);
            color: white;
            font-family: inherit;
            font-size: 1rem;
            cursor: pointer;
            transition: all 0.2s;
        }

        .send-btn:hover {
            background: var(--accent);
        }

        /* Modals */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.9);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 1000;
        }

        .modal-overlay.active {
            display: flex;
        }

        .modal {
            background: var(--panel-bg);
            border: 1px solid var(--border-color);
            padding: 24px;
            width: 90%;
            max-width: 400px;
            max-height: 85vh;
            overflow-y: auto;
            color: var(--accent);
        }

        .modal h2 {
            margin-bottom: 16px;
            display: flex;
            align-items: center;
            gap: 10px;
            color: var(--accent-light);
            font-size: 1.5rem;
        }

        .modal-close {
            margin-left: auto;
            background: none;
            border: none;
            color: var(--text-dim);
            font-size: 24px;
            cursor: pointer;
        }

        /* Settings Tabs */
        .settings-tabs {
            display: flex;
            gap: 0;
            margin-bottom: 20px;
            border-bottom: 1px solid var(--border-color);
        }

        .settings-tab {
            padding: 10px 20px;
            background: transparent;
            border: none;
            border-bottom: 2px solid transparent;
            color: var(--text-dim);
            font-family: inherit;
            font-size: 1.1rem;
            cursor: pointer;
            transition: all 0.2s;
        }

        .settings-tab:hover {
            color: var(--accent);
        }

        .settings-tab.active {
            color: var(--accent-light);
            border-bottom-color: var(--accent);
        }

        .settings-panel {
            display: none;
        }

        .settings-panel.active {
            display: block;
        }

        /* Sound Library */
        .sound-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 10px;
            margin-bottom: 16px;
        }

        .sound-option {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 10px 12px;
            background: var(--dark-bg);
            border: 2px solid var(--border-color);
            cursor: pointer;
            transition: all 0.2s;
        }

        .sound-option:hover {
            border-color: var(--accent-dim);
        }

        .sound-option.selected {
            border-color: var(--accent);
            background: rgba(124, 152, 133, 0.1);
        }

        .sound-option .sound-icon {
            font-size: 1.5rem;
        }

        .sound-option .sound-name {
            font-size: 1rem;
            color: var(--accent-light);
        }

        .sound-preview-btn {
            margin-left: auto;
            background: var(--border-color);
            border: none;
            color: var(--accent);
            padding: 4px 8px;
            font-family: inherit;
            font-size: 0.9rem;
            cursor: pointer;
        }

        .sound-preview-btn:hover {
            background: var(--accent-dim);
        }

        .volume-control {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-top: 16px;
            padding-top: 16px;
            border-top: 1px solid var(--border-color);
        }

        .volume-control label {
            color: var(--text-dim);
        }

        .volume-control input[type="range"] {
            flex: 1;
        }

        /* Message Color Picker */
        .color-picker-grid {
            display: grid;
            grid-template-columns: repeat(5, 1fr);
            gap: 8px;
            margin-bottom: 16px;
        }

        .msg-color-option {
            aspect-ratio: 1;
            border: 2px solid var(--border-color);
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.2s;
            min-height: 36px;
        }

        .msg-color-option:hover {
            border-color: var(--accent);
            transform: scale(1.05);
        }

        .msg-color-option.selected {
            border-color: var(--accent-light);
            box-shadow: 0 0 8px var(--accent);
        }

        .theme-slider-row {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 16px;
        }

        .theme-slider-row label {
            min-width: 80px;
            color: var(--text-dim);
        }

        .theme-slider-row input[type="range"] {
            flex: 1;
        }

        .theme-slider-row span {
            min-width: 40px;
            text-align: right;
            color: var(--accent);
        }

        /* Avatar Picker */
        .avatar-grid {
            display: grid;
            grid-template-columns: repeat(6, 1fr);
            gap: 8px;
            margin-bottom: 16px;
        }

        .avatar-option {
            aspect-ratio: 1;
            border: 2px solid #333;
            background: var(--dark-bg);
            font-size: 28px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s;
        }

        .avatar-option:hover {
            border-color: var(--accent-dim);
        }

        .avatar-option.selected {
            border-color: var(--accent);
        }

        .form-group {
            margin-bottom: 16px;
        }

        .form-group label {
            display: block;
            margin-bottom: 6px;
            font-size: 1rem;
            color: var(--highlight);
        }

        .form-group input {
            width: 100%;
            padding: 10px;
            background: var(--dark-bg);
            border: 1px solid var(--border-color);
            color: var(--accent-light);
            font-family: inherit;
            font-size: 1.1rem;
        }

        .form-group input:focus {
            outline: none;
            border-color: var(--accent-dim);
        }

        .color-options {
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
        }

        .color-option {
            width: 32px;
            height: 32px;
            border: 2px solid transparent;
            cursor: pointer;
        }

        .color-option:hover {
            transform: scale(1.1);
        }

        .color-option.selected {
            border-color: white;
        }

        .modal-btn {
            width: 100%;
            padding: 12px;
            background: var(--accent-dim);
            border: 1px solid var(--border-color);
            color: white;
            font-family: inherit;
            font-size: 1.1rem;
            cursor: pointer;
            margin-top: 16px;
            transition: all 0.2s;
        }

        .modal-btn:hover {
            background: var(--accent);
        }

        /* File Upload */
        .file-upload-row {
            display: flex;
            gap: 8px;
        }

        .file-upload-btn {
            flex: 1;
            padding: 10px;
            background: var(--dark-bg);
            border: 1px dashed var(--border-color);
            color: var(--text-dim);
            font-family: inherit;
            font-size: 0.9rem;
            cursor: pointer;
            transition: all 0.2s;
        }

        .file-upload-btn:hover {
            border-color: var(--accent);
            color: var(--accent);
        }

        .file-clear-btn {
            padding: 10px 15px;
            background: #3a2020;
            border: 1px solid #5a3030;
            color: #ff6666;
            font-family: inherit;
            font-size: 0.9rem;
            cursor: pointer;
            transition: all 0.2s;
        }

        .file-clear-btn:hover {
            background: #4a2525;
        }

        .upload-preview {
            margin-top: 10px;
            border: 1px solid var(--border-color);
            padding: 8px;
            background: var(--dark-bg);
        }

        .upload-preview img {
            max-width: 100%;
            max-height: 150px;
            display: block;
            margin: 0 auto;
        }

        /* Global Backgrounds */
        .global-bg-section {
            margin-top: 8px;
        }

        .global-bg-label {
            font-size: 0.85rem;
            color: var(--text-dim);
            margin-bottom: 8px;
        }

        .global-bg-grid {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 8px;
            max-height: 150px;
            overflow-y: auto;
        }

        .global-bg-item {
            aspect-ratio: 16/9;
            border: 2px solid var(--border-color);
            border-radius: 4px;
            overflow: hidden;
            cursor: pointer;
            transition: all 0.2s;
        }

        .global-bg-item:hover {
            border-color: var(--accent);
            transform: scale(1.05);
        }

        .global-bg-item.selected {
            border-color: var(--highlight);
        }

        .global-bg-item img {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        .global-bg-upload {
            display: flex;
            align-items: center;
            justify-content: center;
            background: var(--dark-bg);
            color: var(--text-dim);
            font-size: 1.5rem;
        }

        .global-bg-upload:hover {
            color: var(--accent);
        }

        /* Drawing Canvas */
        .drawing-modal .modal {
            max-width: 500px;
        }

        .canvas-container {
            background: #111;
            border: 1px solid var(--border-color);
            margin-bottom: 16px;
        }

        #drawingCanvas {
            display: block;
            width: 100%;
            cursor: crosshair;
            touch-action: none;
        }

        .canvas-tools {
            display: flex;
            gap: 8px;
            margin-bottom: 12px;
            flex-wrap: wrap;
        }

        .tool-btn {
            padding: 8px 12px;
            background: transparent;
            border: 1px solid var(--border-color);
            color: var(--accent);
            cursor: pointer;
            font-family: inherit;
        }

        .tool-btn:hover, .tool-btn.active {
            background: var(--accent-dim);
            color: white;
        }

        .tool-btn:disabled {
            opacity: 0.4;
            cursor: not-allowed;
        }

        .tool-btn:disabled:hover {
            background: transparent;
            color: var(--accent);
        }

        .canvas-actions {
            display: flex;
            gap: 6px;
            margin-left: auto;
        }

        .brush-colors {
            display: flex;
            gap: 6px;
        }

        .brush-color {
            width: 28px;
            height: 28px;
            border: 2px solid #333;
            cursor: pointer;
        }

        .brush-color.selected {
            border-color: white;
        }

        /* Image preview */
        .image-preview {
            margin-bottom: 8px;
            position: relative;
            display: none;
        }

        .image-preview img {
            max-width: 200px;
            max-height: 150px;
            border: 1px solid var(--border-color);
        }

        .image-preview .remove-btn {
            position: absolute;
            top: -8px;
            right: -8px;
            width: 24px;
            height: 24px;
            background: #ff4444;
            border: none;
            color: white;
            cursor: pointer;
            font-size: 16px;
        }

        .empty-state {
            text-align: center;
            padding: 40px;
            color: var(--text-dim);
        }

        .empty-state .icon {
            font-size: 48px;
            margin-bottom: 16px;
        }

        /* Infinite scroll loading indicator */
        .loading-indicator {
            text-align: center;
            padding: 16px;
            color: var(--accent);
            font-size: 0.85rem;
            animation: pulse 1.5s ease-in-out infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 0.5; }
            50% { opacity: 1; }
        }

        /* System Toast Notifications */
        .toast-container {
            position: fixed;
            top: 20px;
            right: 20px;
            z-index: 10000;
            display: flex;
            flex-direction: column;
            gap: 10px;
            pointer-events: none;
        }

        .system-toast {
            background: var(--panel-bg, #1a1a2e);
            border: 1px solid var(--border-color, #333);
            border-left: 4px solid var(--accent, #00ff41);
            padding: 12px 16px;
            border-radius: 4px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4);
            max-width: 320px;
            font-size: 0.85rem;
            color: var(--text-light, #e0e0e0);
            pointer-events: auto;
            animation: slideIn 0.3s ease-out;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .system-toast.success { border-left-color: #00ff41; }
        .system-toast.error { border-left-color: #ff4444; }
        .system-toast.warning { border-left-color: #ffaa00; }
        .system-toast.info { border-left-color: #00aaff; }

        .system-toast .toast-icon {
            font-size: 1.2rem;
            flex-shrink: 0;
        }

        .system-toast .toast-message {
            flex: 1;
        }

        .system-toast .toast-close {
            background: none;
            border: none;
            color: var(--text-dim, #888);
            cursor: pointer;
            padding: 0;
            font-size: 1rem;
            line-height: 1;
            opacity: 0.7;
        }

        .system-toast .toast-close:hover {
            opacity: 1;
        }

        .system-toast.fade-out {
            animation: slideOut 0.3s ease-in forwards;
        }

        @keyframes slideIn {
            from { transform: translateX(100%); opacity: 0; }
            to { transform: translateX(0); opacity: 1; }
        }

        @keyframes slideOut {
            from { transform: translateX(0); opacity: 1; }
            to { transform: translateX(100%); opacity: 0; }
        }

        @media (max-width: 600px) {
            .toast-container {
                top: auto;
                bottom: 80px;
                right: 10px;
                left: 10px;
            }
            .system-toast {
                max-width: none;
            }
        }

        #imageInput {
            display: none;
        }

        /* Mobile toggle buttons */
        .mobile-toggle {
            display: none;
        }

        /* Hamburger menu button */
        .hamburger-btn {
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            width: 40px;
            height: 40px;
            background: var(--dark-bg);
            border: 1px solid var(--border-color);
            border-radius: 6px;
            cursor: pointer;
            padding: 8px;
            gap: 4px;
            transition: all 0.2s;
        }

        .hamburger-btn:hover {
            background: var(--border-color);
        }

        .hamburger-btn span {
            display: block;
            width: 20px;
            height: 2px;
            background: var(--accent);
            border-radius: 1px;
            transition: all 0.3s;
        }

        .hamburger-btn.active span:nth-child(1) {
            transform: rotate(45deg) translate(4px, 4px);
        }

        .hamburger-btn.active span:nth-child(2) {
            opacity: 0;
        }

        .hamburger-btn.active span:nth-child(3) {
            transform: rotate(-45deg) translate(4px, -4px);
        }

        @media (max-width: 768px) {
            .mobile-toggle {
                display: inline-block;
            }

            .hamburger-btn {
                display: flex;
            }
        }

        /* Tabs */
        .view-tabs {
            display: flex;
            background: var(--dark-bg);
            border-bottom: 1px solid var(--border-color);
            flex-shrink: 0;
        }

        .view-tab {
            flex: 1;
            padding: 10px;
            background: transparent;
            border: none;
            border-bottom: 2px solid transparent;
            color: var(--text-dim);
            font-family: inherit;
            font-size: 1rem;
            cursor: pointer;
            transition: all 0.2s;
        }

        .view-tab:hover {
            color: var(--accent);
        }

        .view-tab.active {
            color: var(--accent-light);
            border-bottom-color: var(--accent);
        }

        /* Posts Container */
        .posts-container {
            flex: 1;
            overflow-y: auto;
            padding: 16px;
            display: none;
            flex-direction: column;
            gap: 16px;
            min-height: 0;
        }

        .messages-container.hidden {
            display: none;
        }

        /* Post Card */
        .post-card {
            background: rgba(255, 255, 255, 0.03);
            border: 1px solid var(--border-color);
            overflow: hidden;
            flex-shrink: 0;
        }

        .post-header {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 12px;
            border-bottom: 1px solid var(--border-color);
        }

        .post-avatar {
            width: 36px;
            height: 36px;
            border-radius: 50%;
            background: var(--dark-bg);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 20px;
            border: 1px solid var(--border-color);
        }

        .post-username {
            color: var(--accent-light);
            font-size: 1.1rem;
        }

        .post-time {
            color: var(--text-dim);
            font-size: 0.9rem;
            flex: 1;
        }

        .post-delete-btn {
            background: none;
            border: none;
            cursor: pointer;
            font-size: 1.1rem;
            opacity: 0.7;
            transition: all 0.2s;
            padding: 4px 8px;
            border-radius: 4px;
        }

        .post-delete-btn:hover {
            opacity: 1;
            background: rgba(255, 100, 100, 0.15);
        }

        /* Reputation Badges */
        .rep-badge {
            display: inline-flex;
            align-items: center;
            gap: 2px;
            background: linear-gradient(135deg, var(--accent-dim), var(--highlight));
            color: white;
            padding: 2px 6px;
            border-radius: 10px;
            font-size: 0.75rem;
            margin-left: 6px;
            cursor: help;
        }

        .rep-badge.small {
            background: var(--border-color);
            color: var(--text-dim);
        }

        .post-image {
            width: 100%;
            max-height: 400px;
            object-fit: contain;
            background: #000;
            display: block;
        }

        .post-caption {
            padding: 12px;
            font-size: 1.1rem;
            line-height: 1.4;
            border-top: 1px solid var(--border-color);
        }

        /* Post Tags */
        .post-tags {
            display: flex;
            flex-wrap: wrap;
            gap: 6px;
            padding: 8px 12px;
            border-top: 1px solid var(--border-color);
        }

        .tag {
            background: linear-gradient(135deg, rgba(124, 152, 133, 0.2), rgba(169, 196, 176, 0.1));
            border: 1px solid var(--accent-dim);
            border-radius: 4px;
            padding: 3px 8px;
            font-size: 0.85rem;
            color: var(--accent-light);
            cursor: pointer;
            transition: all 0.2s;
        }

        .tag:hover {
            background: var(--accent-dim);
            color: white;
        }

        .tag.nested {
            background: linear-gradient(135deg, rgba(201, 168, 124, 0.2), rgba(201, 168, 124, 0.1));
            border-color: var(--highlight);
            color: var(--highlight);
        }

        .tag.nested:hover {
            background: var(--highlight);
            color: var(--dark-bg);
        }

        .tag-hierarchy {
            font-size: 0.7rem;
            opacity: 0.7;
            margin-right: 2px;
        }

        /* Tag Filter Bar */
        .tag-filter-bar {
            display: none;
            padding: 8px 12px;
            background: var(--dark-bg);
            border-bottom: 1px solid var(--border-color);
            align-items: center;
            gap: 8px;
            flex-shrink: 0;
        }

        .tag-filter-bar.active {
            display: flex;
        }

        /* Ensure posts container takes remaining space */
        .posts-container.active {
            display: flex;
            flex-direction: column;
            flex: 1;
            min-height: 0;
            overflow-y: auto;
        }

        .tag-filter-bar .tag {
            background: var(--accent);
            color: white;
        }

        .clear-filter {
            background: none;
            border: none;
            color: var(--text-dim);
            cursor: pointer;
            font-size: 1.2rem;
            padding: 0 8px;
        }

        .clear-filter:hover {
            color: #ff6666;
        }

        /* Trending Tags */
        .trending-tags {
            padding: 12px;
            border-top: 1px solid var(--border-color);
        }

        .trending-title {
            font-size: 0.8rem;
            color: var(--text-dim);
            margin-bottom: 8px;
            text-transform: uppercase;
            letter-spacing: 0.1em;
        }

        .trending-list {
            display: flex;
            flex-wrap: wrap;
            gap: 6px;
        }

        .trending-tag {
            background: rgba(255,255,255,0.05);
            border: 1px solid var(--border-color);
            border-radius: 12px;
            padding: 4px 10px;
            font-size: 0.8rem;
            color: var(--accent);
            cursor: pointer;
            transition: all 0.2s;
        }

        .trending-tag:hover {
            border-color: var(--accent);
            background: rgba(124, 152, 133, 0.2);
        }

        .trending-tag .count,
        .trending-tag .tag-count {
            color: var(--text-dim);
            font-size: 0.7rem;
            margin-left: 4px;
        }

        .trending-tag.hot {
            background: linear-gradient(135deg, rgba(255,100,100,0.2), rgba(255,150,100,0.1));
            border-color: #ff6666;
            color: #ff9999;
        }

        .trending-tag.warm {
            background: linear-gradient(135deg, rgba(201,168,124,0.2), rgba(201,168,124,0.1));
            border-color: var(--highlight);
            color: var(--highlight);
        }

        .trending-tags-section {
            margin-top: 12px;
            padding-top: 12px;
            border-top: 1px solid var(--border-color);
            flex-shrink: 0;
        }

        .trending-tags-list {
            display: flex;
            flex-direction: column;
            gap: 6px;
            max-height: 30vh;
            overflow-y: auto;
        }

        .trending-tags-list .trending-tag {
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        /* Tag Input */
        .tag-input-container {
            display: flex;
            flex-wrap: wrap;
            gap: 6px;
            padding: 8px;
            background: var(--dark-bg);
            border: 1px solid var(--border-color);
            min-height: 40px;
            align-items: center;
        }

        .tag-input-container .tag {
            display: flex;
            align-items: center;
            gap: 4px;
        }

        .tag-input-container .tag .remove {
            cursor: pointer;
            opacity: 0.7;
        }

        .tag-input-container .tag .remove:hover {
            opacity: 1;
        }

        .tag-input {
            flex: 1;
            min-width: 100px;
            background: transparent;
            border: none;
            color: var(--accent);
            font-family: inherit;
            font-size: 0.9rem;
            outline: none;
        }

        .tag-input::placeholder {
            color: var(--text-dim);
        }

        .post-actions {
            display: flex;
            gap: 16px;
            padding: 10px 12px;
            border-top: 1px solid var(--border-color);
        }

        .post-action-btn {
            background: none;
            border: none;
            color: var(--text-dim);
            font-family: inherit;
            font-size: 1rem;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 6px;
            transition: color 0.2s;
        }

        .post-action-btn:hover {
            color: var(--accent-light);
        }

        .post-action-btn.liked {
            color: #ff4466;
        }

        /* Emoji Reactions */
        .post-reactions {
            display: flex;
            flex-wrap: wrap;
            gap: 6px;
            padding: 8px 12px;
            border-top: 1px solid var(--border-color);
        }

        .reaction-btn {
            background: rgba(255,255,255,0.05);
            border: 1px solid var(--border-color);
            border-radius: 16px;
            padding: 4px 10px;
            font-size: 0.9rem;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 4px;
            transition: all 0.2s;
        }

        .reaction-btn:hover {
            background: rgba(255,255,255,0.1);
            border-color: var(--accent);
        }

        .reaction-btn.active {
            background: rgba(124, 152, 133, 0.2);
            border-color: var(--accent);
        }

        .reaction-count {
            font-size: 0.8rem;
            color: var(--text-dim);
        }

        .add-reaction-btn {
            background: transparent;
            border: 1px dashed var(--border-color);
            border-radius: 16px;
            padding: 4px 10px;
            font-size: 0.9rem;
            cursor: pointer;
            color: var(--text-dim);
            transition: all 0.2s;
        }

        .add-reaction-btn:hover {
            border-color: var(--accent);
            color: var(--accent);
        }

        .reaction-picker {
            display: none;
            position: absolute;
            bottom: 100%;
            left: 0;
            background: var(--panel-bg);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            padding: 8px;
            gap: 4px;
            flex-wrap: wrap;
            max-width: 200px;
            z-index: 10;
        }

        .reaction-picker.active {
            display: flex;
        }

        .reaction-picker button {
            background: none;
            border: none;
            font-size: 1.2rem;
            cursor: pointer;
            padding: 4px;
            border-radius: 4px;
            transition: background 0.2s;
        }

        .reaction-picker button:hover {
            background: rgba(255,255,255,0.1);
        }

        .post-comments {
            border-top: 1px solid var(--border-color);
            max-height: 200px;
            overflow-y: auto;
        }

        .comment {
            display: flex;
            gap: 8px;
            padding: 8px 12px;
            border-bottom: 1px solid rgba(255,255,255,0.05);
        }

        .comment-avatar {
            font-size: 16px;
        }

        .comment-content {
            flex: 1;
        }

        .comment-username {
            color: var(--accent);
            font-size: 0.95rem;
        }

        .comment-text {
            color: var(--accent-light);
            font-size: 1rem;
        }

        .comment-input-row {
            display: flex;
            gap: 8px;
            padding: 8px 12px;
            border-top: 1px solid var(--border-color);
        }

        .comment-input {
            flex: 1;
            background: var(--dark-bg);
            border: 1px solid var(--border-color);
            padding: 8px 12px;
            color: var(--accent-light);
            font-family: inherit;
            font-size: 1rem;
        }

        .comment-input:focus {
            outline: none;
            border-color: var(--accent-dim);
        }

        .comment-send {
            background: var(--accent-dim);
            border: none;
            color: white;
            padding: 8px 16px;
            font-family: inherit;
            cursor: pointer;
        }

        .comment-send:hover {
            background: var(--accent);
        }

        /* Threaded Comments - natural cascade */
        .comment-replies {
            margin-left: 12px;
            padding-left: 12px;
            border-left: 1px solid var(--border-color);
            margin-top: 4px;
        }

        .comment-thread {
            margin-top: 6px;
        }

        .comment-actions {
            display: flex;
            gap: 12px;
            margin-top: 4px;
        }

        .comment-reply-btn {
            background: none;
            border: none;
            color: var(--text-dim);
            font-family: inherit;
            font-size: 0.8rem;
            cursor: pointer;
            padding: 0;
        }

        .comment-reply-btn:hover {
            color: var(--accent);
        }

        .comment-vote-controls {
            display: inline-flex;
            align-items: center;
            gap: 2px;
            margin-left: 8px;
        }

        .comment-vote-btn {
            background: none;
            border: none;
            color: var(--text-dim);
            font-size: 0.75rem;
            cursor: pointer;
            padding: 0 2px;
            opacity: 0.7;
        }

        .comment-vote-btn:hover { opacity: 1; }
        .comment-vote-btn.upvote:hover, .comment-vote-btn.upvote.active { color: #00ff41; opacity: 1; }
        .comment-vote-btn.downvote:hover, .comment-vote-btn.downvote.active { color: #ff4444; opacity: 1; }
        .comment-vote-btn.disabled { opacity: 0.3; cursor: not-allowed; }

        .comment-vote-score {
            font-size: 0.75rem;
            min-width: 16px;
            text-align: center;
            color: var(--text-dim);
        }
        .comment-vote-score.positive { color: #00ff41; }
        .comment-vote-score.negative { color: #ff4444; }

        .reply-indicator {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 6px 12px;
            background: rgba(124, 152, 133, 0.1);
            border-left: 3px solid var(--accent);
            margin-bottom: 4px;
            font-size: 0.85rem;
        }

        .reply-indicator .cancel-reply {
            background: none;
            border: none;
            color: var(--text-dim);
            cursor: pointer;
            font-size: 1rem;
            padding: 0 4px;
        }

        .reply-indicator .cancel-reply:hover {
            color: #ff6b6b;
        }

        .comment-time {
            color: var(--text-dim);
            font-size: 0.75rem;
            margin-left: 8px;
        }

        /* Create Post Button */
        .create-post-btn {
            position: fixed;
            bottom: 80px;
            right: 20px;
            width: 56px;
            height: 56px;
            border-radius: 50%;
            background: var(--accent-dim);
            border: 2px solid var(--accent);
            color: white;
            font-size: 28px;
            cursor: pointer;
            z-index: 50;
            display: none;
            align-items: center;
            justify-content: center;
            transition: all 0.2s;
        }

        .create-post-btn.visible {
            display: flex;
        }

        .create-post-btn:hover {
            background: var(--accent);
            transform: scale(1.1);
        }

        /* Post Modal */
        .post-modal .modal {
            max-width: 500px;
        }

        .post-preview {
            margin-bottom: 16px;
            border: 1px solid var(--border-color);
            background: #000;
            min-height: 100px;
            display: flex;
            align-items: center;
            justify-content: center;
            color: var(--text-dim);
        }

        .post-preview img {
            max-width: 100%;
            max-height: 300px;
            display: block;
        }

        .post-preview.has-image {
            min-height: auto;
        }

        .or-divider {
            text-align: center;
            margin: 12px 0;
            color: var(--text-dim);
        }

        /* Profile Card */
        .profile-card {
            position: fixed;
            z-index: 10000;
            background: var(--dark-bg);
            border: 1px solid var(--accent);
            border-radius: 8px;
            padding: 16px;
            min-width: 220px;
            max-width: 280px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.5);
            display: none;
            animation: profileCardIn 0.15s ease-out;
        }

        @keyframes profileCardIn {
            from { opacity: 0; transform: translateY(-8px) scale(0.95); }
            to { opacity: 1; transform: translateY(0) scale(1); }
        }

        .profile-card.visible {
            display: block;
        }

        .profile-card-header {
            display: flex;
            align-items: center;
            gap: 12px;
            margin-bottom: 12px;
        }

        .profile-card-avatar {
            width: 48px;
            height: 48px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 28px;
            background: var(--panel-bg);
            border: 2px solid var(--accent);
            overflow: hidden;
        }

        .profile-card-avatar img {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        .profile-card-name {
            font-size: 1.2rem;
            color: var(--accent-light);
            font-weight: bold;
        }

        .profile-card-stats {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 8px;
            margin-bottom: 12px;
            text-align: center;
        }

        .profile-card-stat {
            background: var(--panel-bg);
            padding: 8px 4px;
            border-radius: 4px;
        }

        .profile-card-stat-value {
            font-size: 1.1rem;
            color: var(--highlight);
            font-weight: bold;
        }

        .profile-card-stat-label {
            font-size: 0.7rem;
            color: var(--text-dim);
            text-transform: uppercase;
        }

        .profile-card-loading {
            text-align: center;
            padding: 20px;
            color: var(--text-dim);
        }

        .username-clickable {
            cursor: pointer;
            transition: color 0.15s;
        }

        .username-clickable:hover {
            color: var(--highlight);
            text-decoration: underline;
        }

        /* Lazy loading placeholder */
        .lazy-image {
            background: var(--panel-bg);
            min-height: 100px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .lazy-image.loading::after {
            content: 'â—Œ';
            font-size: 24px;
            color: var(--text-dim);
            animation: lazyPulse 1s infinite;
        }

        @keyframes lazyPulse {
            0%, 100% { opacity: 0.3; }
            50% { opacity: 1; }
        }

    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/dompurify/3.0.6/purify.min.js"></script>
</head>
<body>
    <!-- Toast notification container -->
    <div class="toast-container" id="toastContainer"></div>

    <!-- Profile card popup -->
    <div class="profile-card" id="profileCard">
        <div class="profile-card-loading">Loading...</div>
    </div>

    <div class="app">
        <div class="header">
            <div class="logo">
                <span>ðŸ’¾</span>
                <span>SLOPPYGRAM<span class="logo-blink">_</span></span>
            </div>
            <div class="marquee-container">
                <div class="marquee">
                    â˜… WELCOME TO THE CYBER ZONE â˜… GLOBAL CHAT â˜… EST. 1999 â˜… VISITORS: <span id="visitorCount">???</span> â˜…
                </div>
            </div>
            <div class="header-actions">
                <button class="hamburger-btn" id="hamburgerBtn" onclick="toggleSidebar('left')" aria-label="Toggle menu">
                    <span></span>
                    <span></span>
                    <span></span>
                </button>
                <button class="cyber-btn mobile-toggle" onclick="toggleSidebar('right')">FEED</button>
                <button class="cyber-btn" onclick="openSettingsModal()">âš™ï¸ SETTINGS</button>
            </div>
        </div>

        <div class="mobile-backdrop" id="mobileBackdrop" onclick="closeSidebars()"></div>

        <div class="sidebar-left" id="sidebarLeft">
            <button class="sidebar-close-btn" onclick="closeSidebars()">Ã—</button>
            <div class="panel-title">[ ONLINE USERS ]</div>
            <ul class="user-list" id="userList">
            </ul>
        </div>

        <div class="main-content">
            <div class="view-tabs">
                <button class="view-tab active" data-view="chat" onclick="switchView('chat')">ðŸ’¬ CHAT</button>
                <button class="view-tab" data-view="posts" onclick="switchView('posts')">ðŸ“¸ POSTS</button>
                <button class="view-tab" data-view="doodles" onclick="switchView('doodles')">ðŸ† DOODLES</button>
                <button class="view-tab" data-view="manifesto" onclick="switchView('manifesto')">ðŸ“œ MANIFESTO</button>
                <button class="view-tab" data-view="collab" onclick="switchView('collab')">ðŸŽ¨ COLLAB</button>
            </div>
            <div class="input-area" id="chatInputArea">
                <div class="image-preview" id="imagePreview">
                    <img id="previewImg" src="">
                    <button class="remove-btn" onclick="removeImage()">Ã—</button>
                </div>
                <div class="input-row">
                    <div class="input-actions">
                        <button class="action-btn" onclick="document.getElementById('imageInput').click()">ðŸ“·</button>
                        <button class="action-btn" onclick="openDrawingModal()">ðŸŽ¨</button>
                    </div>
                    <input type="file" id="imageInput" accept="image/*" onchange="handleImageSelect(event)">
                    <textarea class="message-input" id="messageInput" placeholder="Type a message..." rows="1"></textarea>
                    <button class="send-btn" onclick="sendMessage()">SEND</button>
                </div>
            </div>
            <div class="messages-container" id="messagesContainer">
                <div class="empty-state" id="emptyState">
                    <div class="icon">ðŸ’¾</div>
                    <p>INITIALIZING CHAT PROTOCOL...</p>
                    <p>Say something!</p>
                </div>
            </div>
            <div class="tag-filter-bar" id="tagFilterBar">
                <span style="color:var(--text-dim);font-size:0.85rem;">Filtering by:</span>
                <span class="tag" id="activeFilterTag"></span>
                <button class="clear-filter" onclick="clearTagFilter()">Ã—</button>
            </div>
            <div class="posts-container" id="postsContainer">
                <div class="empty-state" id="postsEmptyState">
                    <div class="icon">ðŸ“¸</div>
                    <p>NO POSTS YET...</p>
                    <p>Be the first to share!</p>
                </div>
            </div>
            <div class="doodles-container" id="doodlesContainer">
                <div class="leaderboard-header">ðŸ† LEGENDARY DOODLES ðŸ†</div>
                <div class="empty-doodles" id="doodlesEmptyState">
                    <div class="icon">ðŸŽ¨</div>
                    <p>NO LEGENDARY DOODLES YET...</p>
                    <p>Draw something and get votes!</p>
                </div>
            </div>
            <div class="manifesto-container" id="manifestoContainer">
                <div class="manifesto-header">
                    <h2>ðŸ“œ THE MANIFESTO BOARD ðŸ“œ</h2>
                    <p class="manifesto-subtitle">Declare your ideas. Shape the future.</p>
                    <button class="cyber-btn" onclick="openManifestoModal()">âœï¸ WRITE MANIFESTO</button>
                </div>
                <div class="manifesto-list" id="manifestoList">
                    <div class="empty-state" id="manifestoEmptyState">
                        <div class="icon">ðŸ“œ</div>
                        <p>NO MANIFESTOS YET...</p>
                        <p>Be the first to declare your vision!</p>
                    </div>
                </div>
            </div>
            <div class="collab-container" id="collabContainer">
                <div class="collab-header">
                    <h2>ðŸŽ¨ COLLABORATIVE CANVAS ðŸŽ¨</h2>
                    <p class="collab-subtitle">Draw together in real-time. Scroll to zoom, drag to pan!</p>
                    <div class="collab-users" id="collabUsers">
                        <span class="collab-user-count">ðŸ‘¥ <span id="collabUserCount">0</span> drawing</span>
                        <span class="collab-zoom-level">ðŸ” <span id="collabZoomLevel">100</span>%</span>
                    </div>
                </div>
                <div class="collab-canvas-wrapper" id="collabCanvasWrapper">
                    <canvas id="collabCanvas" width="1600" height="1000"></canvas>
                    <div class="collab-cursors" id="collabCursors"></div>
                </div>
                <div class="collab-controls">
                    <div class="collab-zoom-controls">
                        <button class="cyber-btn collab-zoom-btn" onclick="collabZoomIn()">âž•</button>
                        <button class="cyber-btn collab-zoom-btn" onclick="collabZoomReset()">âŸ²</button>
                        <button class="cyber-btn collab-zoom-btn" onclick="collabZoomOut()">âž–</button>
                    </div>
                    <div class="collab-colors">
                        <button class="collab-color-btn active" data-color="#ff00ff" style="background:#ff00ff" onclick="setCollabColor('#ff00ff')"></button>
                        <button class="collab-color-btn" data-color="#00ffff" style="background:#00ffff" onclick="setCollabColor('#00ffff')"></button>
                        <button class="collab-color-btn" data-color="#00ff41" style="background:#00ff41" onclick="setCollabColor('#00ff41')"></button>
                        <button class="collab-color-btn" data-color="#ffff00" style="background:#ffff00" onclick="setCollabColor('#ffff00')"></button>
                        <button class="collab-color-btn" data-color="#ff6600" style="background:#ff6600" onclick="setCollabColor('#ff6600')"></button>
                        <button class="collab-color-btn" data-color="#ff0066" style="background:#ff0066" onclick="setCollabColor('#ff0066')"></button>
                        <button class="collab-color-btn" data-color="#ffffff" style="background:#ffffff" onclick="setCollabColor('#ffffff')"></button>
                        <button class="collab-color-btn" data-color="#000000" style="background:#000000;border:1px solid #333" onclick="setCollabColor('#000000')"></button>
                    </div>
                    <div class="collab-actions">
                        <button class="cyber-btn collab-clear-btn" onclick="clearCollabCanvas()">ðŸ§¹ CLEAR MINE</button>
                    </div>
                </div>
            </div>
        </div>

        <div class="sidebar-right" id="sidebarRight">
            <button class="sidebar-close-btn" onclick="closeSidebars()">Ã—</button>
            <div class="panel-title">[ PUBLIC FEED ]</div>
            <div id="publicFeed">
                <div class="feed-item">
                    <span class="feed-user">System</span>
                    <span class="feed-action">initialized</span>
                    <div class="feed-time">just now</div>
                </div>
            </div>
            <div class="trending-tags-section" id="trendingTagsSection">
                <div class="panel-title">[ TRENDING TAGS ]</div>
                <div id="trendingTagsList" class="trending-tags-list">
                    <div style="font-size:0.85rem;color:var(--text-dim)">Loading tags...</div>
                </div>
            </div>
        </div>
    </div>

    <!-- Settings Modal -->
    <div class="modal-overlay" id="settingsModal">
        <div class="modal" style="max-width: 450px;">
            <h2>
                <span>âš™ï¸</span> SETTINGS
                <button class="modal-close" onclick="closeSettingsModal()">Ã—</button>
            </h2>

            <div class="settings-tabs">
                <button class="settings-tab active" onclick="switchSettingsTab('profile')">ðŸ‘¤ PROFILE</button>
                <button class="settings-tab" onclick="switchSettingsTab('themes')">ðŸŽ¨ THEMES</button>
                <button class="settings-tab" onclick="switchSettingsTab('sounds')">ðŸ”” SOUNDS</button>
            </div>

            <!-- Profile Tab -->
            <div class="settings-panel active" id="profilePanel">
                <div class="form-group">
                    <label>USERNAME:</label>
                    <input type="text" id="usernameInput" placeholder="Enter handle..." maxlength="20">
                </div>

                <div class="form-group">
                    <label>SELECT AVATAR:</label>
                    <div class="avatar-grid" id="avatarGrid"></div>
                </div>

                <div class="form-group">
                    <label>CUSTOM AVATAR (upload image):</label>
                    <div class="file-upload-row">
                        <input type="file" id="avatarFileInput" accept="image/*" onchange="handleAvatarUpload(event)" style="display:none">
                        <button class="file-upload-btn" onclick="document.getElementById('avatarFileInput').click()">ðŸ“ CHOOSE FILE</button>
                        <button class="file-clear-btn" onclick="clearAvatarUpload()" id="clearAvatarBtn" style="display:none">âœ• CLEAR</button>
                    </div>
                    <div class="upload-preview" id="avatarPreview" style="display:none">
                        <img id="avatarPreviewImg" src="">
                    </div>
                </div>

                <div class="form-group">
                    <label>AVATAR COLOR:</label>
                    <div class="color-options" id="colorOptions"></div>
                </div>

                <div class="form-group">
                    <label>CUSTOM BACKGROUND (upload image):</label>
                    <div class="file-upload-row">
                        <input type="file" id="bgFileInput" accept="image/*" onchange="handleBgUpload(event)" style="display:none">
                        <button class="file-upload-btn" onclick="document.getElementById('bgFileInput').click()">ðŸ“ UPLOAD NEW</button>
                        <button class="file-upload-btn" onclick="shareBackground()" id="shareBgBtn" style="display:none">ðŸŒ SHARE</button>
                        <button class="file-upload-btn" onclick="setGlobalBackground()" id="setGlobalBgBtn" style="display:none;background:#4a1a7a;">ðŸŒ SET FOR ALL</button>
                        <button class="file-clear-btn" onclick="clearBgUpload()" id="clearBgBtn" style="display:none">âœ•</button>
                    </div>
                    <div class="upload-preview" id="bgPreview" style="display:none">
                        <img id="bgPreviewImg" src="">
                    </div>
                    <div class="global-bg-section">
                        <div class="global-bg-label">Or choose a shared background:</div>
                        <div class="global-bg-grid" id="globalBgGrid">
                            <div class="global-bg-item global-bg-upload" onclick="document.getElementById('bgFileInput').click()" title="Upload new">+</div>
                        </div>
                    </div>
                </div>

                <button class="modal-btn" onclick="saveProfile()">[ SAVE ]</button>
                <button class="modal-btn" style="background: #3a2020; margin-top: 8px;" onclick="resetProfile()">[ RESET ALL ]</button>
            </div>

            <!-- Themes Tab -->
            <div class="settings-panel" id="themesPanel">
                <div class="form-group">
                    <label>MESSAGE OPACITY:</label>
                    <div class="theme-slider-row">
                        <input type="range" id="msgOpacitySlider" min="0" max="100" value="95" oninput="setMessageOpacity(this.value)">
                        <span id="opacityValue">95%</span>
                    </div>
                </div>

                <div class="form-group">
                    <label>MESSAGE COLOR (others):</label>
                    <div class="color-picker-grid" id="msgColorGrid">
                        <div class="msg-color-option selected" style="background: rgb(10, 10, 15);" onclick="selectMsgColor('10, 10, 15')" title="Default Dark"></div>
                        <div class="msg-color-option" style="background: rgb(20, 20, 30);" onclick="selectMsgColor('20, 20, 30')" title="Midnight"></div>
                        <div class="msg-color-option" style="background: rgb(30, 20, 40);" onclick="selectMsgColor('30, 20, 40')" title="Purple Night"></div>
                        <div class="msg-color-option" style="background: rgb(20, 30, 30);" onclick="selectMsgColor('20, 30, 30')" title="Teal Dark"></div>
                        <div class="msg-color-option" style="background: rgb(40, 30, 20);" onclick="selectMsgColor('40, 30, 20')" title="Warm Brown"></div>
                        <div class="msg-color-option" style="background: rgb(15, 25, 35);" onclick="selectMsgColor('15, 25, 35')" title="Deep Blue"></div>
                        <div class="msg-color-option" style="background: rgb(35, 15, 25);" onclick="selectMsgColor('35, 15, 25')" title="Wine"></div>
                        <div class="msg-color-option" style="background: rgb(25, 35, 25);" onclick="selectMsgColor('25, 35, 25')" title="Forest"></div>
                        <div class="msg-color-option" style="background: rgb(45, 35, 45);" onclick="selectMsgColor('45, 35, 45')" title="Mauve"></div>
                        <div class="msg-color-option" style="background: rgb(50, 50, 50);" onclick="selectMsgColor('50, 50, 50')" title="Gray"></div>
                    </div>
                </div>

                <div class="form-group">
                    <label>YOUR MESSAGE COLOR:</label>
                    <div class="color-picker-grid" id="msgOwnColorGrid">
                        <div class="msg-color-option selected" style="background: rgb(90, 112, 96);" onclick="selectMsgOwnColor('90, 112, 96')" title="Default Green"></div>
                        <div class="msg-color-option" style="background: rgb(70, 90, 120);" onclick="selectMsgOwnColor('70, 90, 120')" title="Steel Blue"></div>
                        <div class="msg-color-option" style="background: rgb(100, 80, 120);" onclick="selectMsgOwnColor('100, 80, 120')" title="Lavender"></div>
                        <div class="msg-color-option" style="background: rgb(120, 90, 70);" onclick="selectMsgOwnColor('120, 90, 70')" title="Copper"></div>
                        <div class="msg-color-option" style="background: rgb(80, 110, 100);" onclick="selectMsgOwnColor('80, 110, 100')" title="Sage"></div>
                        <div class="msg-color-option" style="background: rgb(110, 85, 85);" onclick="selectMsgOwnColor('110, 85, 85')" title="Dusty Rose"></div>
                        <div class="msg-color-option" style="background: rgb(85, 100, 85);" onclick="selectMsgOwnColor('85, 100, 85')" title="Olive"></div>
                        <div class="msg-color-option" style="background: rgb(95, 95, 115);" onclick="selectMsgOwnColor('95, 95, 115')" title="Slate"></div>
                        <div class="msg-color-option" style="background: rgb(115, 100, 80);" onclick="selectMsgOwnColor('115, 100, 80')" title="Sand"></div>
                        <div class="msg-color-option" style="background: rgb(75, 105, 115);" onclick="selectMsgOwnColor('75, 105, 115')" title="Ocean"></div>
                    </div>
                </div>

                <div class="form-group">
                    <label>ACCENT COLOR:</label>
                    <div class="color-picker-grid" id="accentColorGrid">
                        <div class="msg-color-option selected" style="background: #7c9885;" onclick="selectAccentColor('#7c9885')" title="Default Green"></div>
                        <div class="msg-color-option" style="background: #8590a8;" onclick="selectAccentColor('#8590a8')" title="Steel"></div>
                        <div class="msg-color-option" style="background: #a085a0;" onclick="selectAccentColor('#a085a0')" title="Mauve"></div>
                        <div class="msg-color-option" style="background: #85a0a8;" onclick="selectAccentColor('#85a0a8')" title="Cyan"></div>
                        <div class="msg-color-option" style="background: #a89885;" onclick="selectAccentColor('#a89885')" title="Sand"></div>
                        <div class="msg-color-option" style="background: #a88585;" onclick="selectAccentColor('#a88585')" title="Rose"></div>
                        <div class="msg-color-option" style="background: #85a890;" onclick="selectAccentColor('#85a890')" title="Mint"></div>
                        <div class="msg-color-option" style="background: #9085a8;" onclick="selectAccentColor('#9085a8')" title="Violet"></div>
                        <div class="msg-color-option" style="background: #a8a085;" onclick="selectAccentColor('#a8a085')" title="Gold"></div>
                        <div class="msg-color-option" style="background: #85a8a8;" onclick="selectAccentColor('#85a8a8')" title="Teal"></div>
                    </div>
                </div>

                <div class="form-group">
                    <label>HIGHLIGHT COLOR:</label>
                    <div class="color-picker-grid" id="highlightColorGrid">
                        <div class="msg-color-option selected" style="background: #c9a87c;" onclick="selectHighlightColor('#c9a87c')" title="Default Gold"></div>
                        <div class="msg-color-option" style="background: #7ca8c9;" onclick="selectHighlightColor('#7ca8c9')" title="Sky"></div>
                        <div class="msg-color-option" style="background: #c97ca8;" onclick="selectHighlightColor('#c97ca8')" title="Pink"></div>
                        <div class="msg-color-option" style="background: #a8c97c;" onclick="selectHighlightColor('#a8c97c')" title="Lime"></div>
                        <div class="msg-color-option" style="background: #c9c97c;" onclick="selectHighlightColor('#c9c97c')" title="Yellow"></div>
                        <div class="msg-color-option" style="background: #7cc9a8;" onclick="selectHighlightColor('#7cc9a8')" title="Aqua"></div>
                        <div class="msg-color-option" style="background: #c97c7c;" onclick="selectHighlightColor('#c97c7c')" title="Coral"></div>
                        <div class="msg-color-option" style="background: #a87cc9;" onclick="selectHighlightColor('#a87cc9')" title="Purple"></div>
                        <div class="msg-color-option" style="background: #7cc9c9;" onclick="selectHighlightColor('#7cc9c9')" title="Cyan"></div>
                        <div class="msg-color-option" style="background: #c9c9c9;" onclick="selectHighlightColor('#c9c9c9')" title="Silver"></div>
                    </div>
                </div>

                <div class="form-group">
                    <label>PANEL BACKGROUND:</label>
                    <div class="color-picker-grid" id="panelBgGrid">
                        <div class="msg-color-option selected" style="background: #12121a;" onclick="selectPanelBg('#12121a')" title="Default Dark"></div>
                        <div class="msg-color-option" style="background: #0a0a0f;" onclick="selectPanelBg('#0a0a0f')" title="Pure Black"></div>
                        <div class="msg-color-option" style="background: #1a1218;" onclick="selectPanelBg('#1a1218')" title="Wine Dark"></div>
                        <div class="msg-color-option" style="background: #12181a;" onclick="selectPanelBg('#12181a')" title="Teal Dark"></div>
                        <div class="msg-color-option" style="background: #18121a;" onclick="selectPanelBg('#18121a')" title="Purple Dark"></div>
                        <div class="msg-color-option" style="background: #1a1812;" onclick="selectPanelBg('#1a1812')" title="Warm Dark"></div>
                        <div class="msg-color-option" style="background: #121a14;" onclick="selectPanelBg('#121a14')" title="Forest Dark"></div>
                        <div class="msg-color-option" style="background: #1a1a1a;" onclick="selectPanelBg('#1a1a1a')" title="Gray"></div>
                        <div class="msg-color-option" style="background: #121418;" onclick="selectPanelBg('#121418')" title="Navy"></div>
                        <div class="msg-color-option" style="background: #181414;" onclick="selectPanelBg('#181414')" title="Charcoal"></div>
                    </div>
                </div>

                <button class="modal-btn" onclick="saveThemeSettings()">[ SAVE THEME ]</button>
                <button class="modal-btn" style="background: #3a2020; margin-top: 8px;" onclick="resetTheme()">[ RESET THEME ]</button>
            </div>

            <!-- Sounds Tab -->
            <div class="settings-panel" id="soundsPanel">
                <div class="form-group">
                    <label>NOTIFICATION SOUND:</label>
                    <div class="sound-grid" id="soundGrid">
                        <div class="sound-option selected" onclick="selectSound('none')">
                            <span class="sound-icon">ðŸ”‡</span>
                            <span class="sound-name">None</span>
                        </div>
                        <div class="sound-option" onclick="selectSound('blip')">
                            <span class="sound-icon">ðŸ’«</span>
                            <span class="sound-name">Blip</span>
                            <button class="sound-preview-btn" onclick="event.stopPropagation(); previewSound('blip')">â–¶</button>
                        </div>
                        <div class="sound-option" onclick="selectSound('chime')">
                            <span class="sound-icon">ðŸ””</span>
                            <span class="sound-name">Chime</span>
                            <button class="sound-preview-btn" onclick="event.stopPropagation(); previewSound('chime')">â–¶</button>
                        </div>
                        <div class="sound-option" onclick="selectSound('pop')">
                            <span class="sound-icon">ðŸ’¬</span>
                            <span class="sound-name">Pop</span>
                            <button class="sound-preview-btn" onclick="event.stopPropagation(); previewSound('pop')">â–¶</button>
                        </div>
                        <div class="sound-option" onclick="selectSound('retro')">
                            <span class="sound-icon">ðŸ‘¾</span>
                            <span class="sound-name">Retro</span>
                            <button class="sound-preview-btn" onclick="event.stopPropagation(); previewSound('retro')">â–¶</button>
                        </div>
                        <div class="sound-option" onclick="selectSound('cyber')">
                            <span class="sound-icon">ðŸ¤–</span>
                            <span class="sound-name">Cyber</span>
                            <button class="sound-preview-btn" onclick="event.stopPropagation(); previewSound('cyber')">â–¶</button>
                        </div>
                        <div class="sound-option" onclick="selectSound('whoosh')">
                            <span class="sound-icon">ðŸ’¨</span>
                            <span class="sound-name">Whoosh</span>
                            <button class="sound-preview-btn" onclick="event.stopPropagation(); previewSound('whoosh')">â–¶</button>
                        </div>
                        <div class="sound-option" onclick="selectSound('ding')">
                            <span class="sound-icon">âœ¨</span>
                            <span class="sound-name">Ding</span>
                            <button class="sound-preview-btn" onclick="event.stopPropagation(); previewSound('ding')">â–¶</button>
                        </div>
                        <div class="sound-option" onclick="selectSound('custom')">
                            <span class="sound-icon">ðŸ”—</span>
                            <span class="sound-name">Custom</span>
                            <button class="sound-preview-btn" onclick="event.stopPropagation(); previewSound('custom')">â–¶</button>
                        </div>
                    </div>
                </div>

                <div class="form-group">
                    <label>CUSTOM SOUND:</label>
                    <div class="file-upload-row">
                        <input type="file" id="customSoundFile" accept="audio/*" onchange="handleSoundUpload(event)" style="display:none">
                        <button class="file-upload-btn" onclick="document.getElementById('customSoundFile').click()">ðŸ“ UPLOAD AUDIO</button>
                        <button class="file-clear-btn" onclick="clearCustomSound()" id="clearSoundBtn" style="display:none">âœ• CLEAR</button>
                    </div>
                    <div id="customSoundName" style="font-size:0.85rem;color:var(--accent);margin-top:6px;display:none;"></div>
                    <div style="font-size:0.8rem;color:var(--text-dim);margin-top:4px;">Upload .mp3, .wav, or .ogg (max 500KB)</div>
                </div>

                <div class="volume-control">
                    <label>ðŸ”Š VOLUME:</label>
                    <input type="range" id="volumeSlider" min="0" max="100" value="50" oninput="setVolume(this.value)">
                    <span id="volumeValue">50%</span>
                </div>

                <button class="modal-btn" style="margin-top: 20px;" onclick="saveSoundSettings()">[ SAVE SOUNDS ]</button>
            </div>
        </div>
    </div>

    <!-- Drawing Modal -->
    <div class="modal-overlay drawing-modal" id="drawingModal">
        <div class="modal">
            <h2>
                <span>ðŸŽ¨</span> PIXEL CANVAS
                <button class="modal-close" onclick="closeDrawingModal()">Ã—</button>
            </h2>

            <div class="canvas-tools">
                <div class="brush-colors" id="brushColors"></div>
                <div class="canvas-actions">
                    <button class="tool-btn" id="undoBtn" onclick="undoCanvas()" disabled title="Undo (Ctrl+Z)">â†© UNDO</button>
                    <button class="tool-btn" id="redoBtn" onclick="redoCanvas()" disabled title="Redo (Ctrl+Y)">â†ª REDO</button>
                    <button class="tool-btn" onclick="clearCanvas()">CLEAR</button>
                </div>
            </div>

            <div class="canvas-container">
                <canvas id="drawingCanvas" width="400" height="300"></canvas>
            </div>

            <button class="modal-btn" onclick="sendDrawing()">[ TRANSMIT ]</button>
        </div>
    </div>

    <!-- Create Post Modal -->
    <div class="modal-overlay post-modal" id="postModal">
        <div class="modal">
            <h2>
                <span>ðŸ“¸</span> NEW POST
                <button class="modal-close" onclick="closePostModal()">Ã—</button>
            </h2>

            <div class="post-preview" id="postPreview">
                <span>No image selected</span>
            </div>

            <div class="form-group">
                <label>IMAGE URL:</label>
                <input type="text" id="postImageUrl" placeholder="https://example.com/image.jpg" oninput="previewPostImage()">
            </div>

            <div class="or-divider">â€” OR â€”</div>

            <div class="form-group">
                <label>UPLOAD FILE:</label>
                <input type="file" id="postFileInput" accept="image/*" onchange="handlePostFileSelect(event)" style="display:block;background:var(--dark-bg);padding:8px;border:1px solid var(--border-color);color:var(--accent-light);width:100%;">
            </div>

            <div class="form-group">
                <label>CAPTION:</label>
                <input type="text" id="postCaption" placeholder="Write something..." maxlength="280">
            </div>

            <div class="form-group">
                <label>TAGS (use parent/child for nested):</label>
                <div class="tag-input-container" id="tagInputContainer">
                    <input type="text" class="tag-input" id="tagInput" placeholder="Type tag and press Enter... (e.g. art/digital)" onkeydown="handleTagInput(event)">
                </div>
                <div style="font-size:0.75rem;color:var(--text-dim);margin-top:4px;">
                    Tip: Use "/" for nested tags like "meme/cursed" or "art/pixel"
                </div>
            </div>

            <button class="modal-btn" onclick="submitPost()">[ POST IT ]</button>
        </div>
    </div>

    <!-- Create Post FAB -->
    <button class="create-post-btn" id="createPostBtn" onclick="openPostModal()">+</button>

    <!-- Create Manifesto Modal -->
    <div class="modal-overlay" id="manifestoModal">
        <div class="modal manifesto-modal">
            <h2>
                <span>ðŸ“œ</span> WRITE YOUR MANIFESTO
                <button class="modal-close" onclick="closeManifestoModal()">Ã—</button>
            </h2>

            <div class="form-group">
                <label>TITLE:</label>
                <input type="text" id="manifestoTitle" placeholder="Your manifesto title..." maxlength="100">
            </div>

            <div class="form-group">
                <label>YOUR VISION:</label>
                <textarea id="manifestoContent" placeholder="Declare your ideas, beliefs, and vision for the future..." rows="8" maxlength="2000" style="width:100%;background:var(--dark-bg);border:1px solid var(--border-color);color:var(--accent-light);padding:10px;font-family:inherit;resize:vertical;"></textarea>
                <div style="font-size:0.75rem;color:var(--text-dim);margin-top:4px;text-align:right;">
                    <span id="manifestoCharCount">0</span>/2000
                </div>
            </div>

            <div class="form-group">
                <label>TAGS (use parent/child for nested):</label>
                <div class="tag-input-container" id="manifestoTagInputContainer">
                    <input type="text" class="tag-input" id="manifestoTagInput" placeholder="Type tag and press Enter... (e.g. philosophy/ethics)" onkeydown="handleManifestoTagInput(event)">
                </div>
                <div style="font-size:0.75rem;color:var(--text-dim);margin-top:4px;">
                    Tip: Use "/" for nested tags like "tech/ai" or "society/future"
                </div>
            </div>

            <button class="modal-btn" onclick="submitManifesto()">[ DECLARE IT ]</button>
        </div>
    </div>

    <script type="module">
        import { createClient } from "https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2/+esm";

        const SUPABASE_URL = 'https://yjyxteqzhhmtrgcaekgz.supabase.co';
        const SUPABASE_ANON_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InlqeXh0ZXF6aGhtdHJnY2Fla2d6Iiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTczNTg3NDIsImV4cCI6MjA3MjkzNDc0Mn0.G8SRde7IN2QFW1EnASM8IS32IUYR2eenCCjdDdioiBU';
        const supabase = createClient(SUPABASE_URL, SUPABASE_ANON_KEY, {
            auth: {
                persistSession: true,
                storageKey: 'sloppygram-auth',
                autoRefreshToken: true,
                detectSessionInUrl: false
            }
        });

        // Storage bucket name
        const STORAGE_BUCKET = 'sloppygram';

        // Upload image to Supabase Storage, returns public URL or null on failure
        async function uploadToStorage(blob, folder = 'images') {
            try {
                const ext = blob.type === 'image/png' ? 'png' : 'jpg';
                const filename = `${folder}/${Date.now()}_${Math.random().toString(36).slice(2)}.${ext}`;

                const { data, error } = await supabase.storage
                    .from(STORAGE_BUCKET)
                    .upload(filename, blob, {
                        contentType: blob.type,
                        cacheControl: '3600',
                        upsert: false
                    });

                if (error) {
                    console.error('Storage upload error:', error);
                    return null;
                }

                // Get public URL
                const { data: urlData } = supabase.storage
                    .from(STORAGE_BUCKET)
                    .getPublicUrl(data.path);

                return urlData?.publicUrl || null;
            } catch (err) {
                console.error('Upload failed:', err);
                return null;
            }
        }

        // Convert base64 data URL to Blob
        function dataURLtoBlob(dataURL) {
            const parts = dataURL.split(',');
            const mime = parts[0].match(/:(.*?);/)[1];
            const binary = atob(parts[1]);
            const array = new Uint8Array(binary.length);
            for (let i = 0; i < binary.length; i++) {
                array[i] = binary.charCodeAt(i);
            }
            return new Blob([array], { type: mime });
        }

        // Avatar options
        const AVATARS = ['ðŸ˜€', 'ðŸ˜Ž', 'ðŸ¤–', 'ðŸ‘½', 'ðŸ±', 'ðŸ¶', 'ðŸ¦Š', 'ðŸ¼', 'ðŸ¸', 'ðŸ¦„', 'ðŸ²', 'ðŸ‘»', 'ðŸ’€', 'ðŸŽƒ', 'ðŸ¤¡', 'ðŸ‘¾', 'ðŸ¥·', 'ðŸ§™'];
        const COLORS = ['#00ff41', '#00ffff', '#ff00ff', '#ffff00', '#ff4444', '#ff8800', '#8844ff', '#44ff88', '#ff44aa', '#44aaff'];
        const BRUSH_COLORS = ['#00ff41', '#00ffff', '#ff00ff', '#ffff00', '#ff4444', '#ffffff', '#000000', '#888888'];

        let currentUser = null;
        let profile = {
            username: 'Anon' + Math.floor(Math.random() * 9999),
            avatar: AVATARS[Math.floor(Math.random() * AVATARS.length)],
            color: COLORS[Math.floor(Math.random() * COLORS.length)],
            avatarUrl: '',
            bgUrl: ''
        };
        let selectedImage = null;
        let drawingCtx = null;
        let isDrawing = false;
        let brushColor = '#00ff41';
        const seenMessageIds = new Set();
        let onlineUsers = new Map();
        let realtimeChannel = null;
        let currentView = 'chat';
        let posts = [];
        let postLikes = {};
        let postComments = {};
        let postReactions = {}; // { postId: { emoji: count, ... } }
        let myReactions = {}; // { postId: Set of emojis I've reacted with }
        const REACTION_EMOJIS = ['ðŸ˜‚', 'ðŸ”¥', 'â¤ï¸', 'ðŸ˜®', 'ðŸ˜¢', 'ðŸ‘', 'ðŸ™Œ', 'ðŸ’€'];
        let globalBackgrounds = [];
        let postImageData = null;
        let doodleVotes = {}; // { messageId: netScore }
        let myDoodleVotes = {}; // { messageId: 1 or -1 } for my vote type
        let messageVotes = {}; // { messageId: netScore } for chat messages
        let myMessageVotes = {}; // { messageId: 1 or -1 } for my vote type
        let postVotes = {}; // { postId: netScore }
        let myPostVotes = {}; // { postId: 1 or -1 } for my vote type
        let commentVotes = {}; // { commentId: netScore }
        let myCommentVotes = {}; // { commentId: 1 or -1 } for my vote type
        let postTags = {}; // { postId: [{ tag, parent_tag }, ...] }
        let pendingTags = []; // tags being added to new post
        let activeTagFilter = null; // current tag filter
        let commentThreads = {}; // { commentId: parentCommentId }
        let replyingTo = null; // { postId, commentId, username } when replying to a comment
        let userReputations = {}; // { username: { postLikes, manifestoVotes, total } }

        // Pagination state
        const PAGE_SIZE = 30;
        let messagesPage = 0;
        let messagesHasMore = true;
        let messagesLoading = false;
        let postsPage = 0;
        let postsHasMore = true;
        let postsLoading = false;

        // === RATE LIMITING ===
        const rateLimits = {
            message: { limit: 5, window: 10000 },    // 5 messages per 10 seconds
            post: { limit: 3, window: 60000 },       // 3 posts per minute
            vote: { limit: 20, window: 60000 },      // 20 votes per minute
            comment: { limit: 10, window: 60000 },   // 10 comments per minute
            drawing: { limit: 3, window: 30000 }     // 3 drawings per 30 seconds
        };
        const actionTimestamps = {};  // { actionType: [timestamps] }

        function checkRateLimit(actionType) {
            const config = rateLimits[actionType];
            if (!config) return { allowed: true };

            const now = Date.now();
            const timestamps = actionTimestamps[actionType] || [];

            // Remove expired timestamps
            const validTimestamps = timestamps.filter(t => now - t < config.window);
            actionTimestamps[actionType] = validTimestamps;

            if (validTimestamps.length >= config.limit) {
                const oldestValid = validTimestamps[0];
                const waitTime = Math.ceil((config.window - (now - oldestValid)) / 1000);
                return { allowed: false, waitTime, message: `Rate limited. Wait ${waitTime}s` };
            }

            return { allowed: true };
        }

        function recordAction(actionType) {
            if (!actionTimestamps[actionType]) {
                actionTimestamps[actionType] = [];
            }
            actionTimestamps[actionType].push(Date.now());
        }

        // === CANVAS UNDO/REDO ===
        const MAX_HISTORY = 20;
        let canvasHistory = [];
        let canvasHistoryIndex = -1;

        function saveCanvasState() {
            const canvas = document.getElementById('drawingCanvas');
            if (!canvas) return;

            // Remove any states after current index (for redo overwrite)
            canvasHistory = canvasHistory.slice(0, canvasHistoryIndex + 1);

            // Save current state
            canvasHistory.push(canvas.toDataURL());

            // Limit history size
            if (canvasHistory.length > MAX_HISTORY) {
                canvasHistory.shift();
            } else {
                canvasHistoryIndex++;
            }

            updateUndoRedoButtons();
        }

        function undoCanvas() {
            if (canvasHistoryIndex <= 0) return;
            canvasHistoryIndex--;
            restoreCanvasState(canvasHistory[canvasHistoryIndex]);
            updateUndoRedoButtons();
        }

        function redoCanvas() {
            if (canvasHistoryIndex >= canvasHistory.length - 1) return;
            canvasHistoryIndex++;
            restoreCanvasState(canvasHistory[canvasHistoryIndex]);
            updateUndoRedoButtons();
        }

        function restoreCanvasState(dataUrl) {
            const canvas = document.getElementById('drawingCanvas');
            if (!canvas || !dataUrl) return;

            const img = new Image();
            img.onload = function() {
                drawingCtx.clearRect(0, 0, canvas.width, canvas.height);
                drawingCtx.drawImage(img, 0, 0);
            };
            img.src = dataUrl;
        }

        function updateUndoRedoButtons() {
            const undoBtn = document.getElementById('undoBtn');
            const redoBtn = document.getElementById('redoBtn');
            if (undoBtn) undoBtn.disabled = canvasHistoryIndex <= 0;
            if (redoBtn) redoBtn.disabled = canvasHistoryIndex >= canvasHistory.length - 1;
        }

        function resetCanvasHistory() {
            canvasHistory = [];
            canvasHistoryIndex = -1;
            saveCanvasState(); // Save initial blank state
        }

        // Expose undo/redo globally
        window.undoCanvas = undoCanvas;
        window.redoCanvas = redoCanvas;

        // === PROFILE CARD SYSTEM ===
        const userProfileCache = new Map(); // Cache user stats and avatar
        const PROFILE_CACHE_TTL = 60000; // 1 minute cache
        let profileCardTimeout = null;

        async function getUserStats(username) {
            // Check cache first
            const cached = userProfileCache.get(username);
            if (cached && Date.now() - cached.timestamp < PROFILE_CACHE_TTL) {
                return cached.data;
            }

            try {
                // Fetch user stats and avatar from database in parallel
                const [messagesRes, postsRes, doodlesRes, manifestosRes, avatarMsgRes, avatarPostRes] = await Promise.all([
                    supabase.from('sloppygram_messages').select('id', { count: 'exact', head: true }).eq('username', username),
                    supabase.from('sloppygram_posts').select('id, likes_count', { count: 'exact' }).eq('username', username),
                    supabase.from('sloppygram_messages').select('id', { count: 'exact', head: true }).eq('username', username).eq('message_type', 'drawing'),
                    supabase.from('sloppygram_manifestos').select('id', { count: 'exact', head: true }).eq('username', username),
                    // Fetch most recent message with avatar info
                    supabase.from('sloppygram_messages').select('avatar, avatar_url').eq('username', username).order('created_at', { ascending: false }).limit(1),
                    // Fetch most recent post with avatar info
                    supabase.from('sloppygram_posts').select('avatar, avatar_url').eq('username', username).order('created_at', { ascending: false }).limit(1)
                ]);

                const totalPosts = postsRes.count || 0;
                const totalMessages = messagesRes.count || 0;
                const totalDoodles = doodlesRes.count || 0;
                const totalManifestos = manifestosRes.count || 0;
                const totalLikes = (postsRes.data || []).reduce((sum, p) => sum + (p.likes_count || 0), 0);

                // Get avatar from most recent activity
                let avatar = 'ðŸ‘¤';
                let avatarUrl = null;

                const latestMsg = avatarMsgRes.data?.[0];
                const latestPost = avatarPostRes.data?.[0];

                if (latestMsg) {
                    avatar = latestMsg.avatar || avatar;
                    avatarUrl = latestMsg.avatar_url || avatarUrl;
                }
                if (latestPost) {
                    avatar = latestPost.avatar || avatar;
                    avatarUrl = latestPost.avatar_url || avatarUrl;
                }

                const stats = {
                    messages: totalMessages,
                    posts: totalPosts,
                    doodles: totalDoodles,
                    manifestos: totalManifestos,
                    likes: totalLikes,
                    avatar: avatar,
                    avatarUrl: avatarUrl
                };

                // Cache the result
                userProfileCache.set(username, { data: stats, timestamp: Date.now() });
                return stats;
            } catch (err) {
                console.error('Error fetching user stats:', err);
                return {
                    messages: 0,
                    posts: 0,
                    doodles: 0,
                    manifestos: 0,
                    likes: 0,
                    avatar: 'ðŸ‘¤',
                    avatarUrl: null
                };
            }
        }

        // Kept for backwards compatibility but now uses cached data from getUserStats
        async function findUserInfo(username) {
            const stats = await getUserStats(username);
            return { avatar: stats.avatar, avatarUrl: stats.avatarUrl };
        }

        async function showProfileCard(username, event) {
            const card = document.getElementById('profileCard');
            if (!card) return;

            // Clear any pending hide timeout
            if (profileCardTimeout) {
                clearTimeout(profileCardTimeout);
                profileCardTimeout = null;
            }

            // Position card near click
            const rect = event.target.getBoundingClientRect();
            const cardWidth = 250;
            const cardHeight = 180;

            let left = rect.left;
            let top = rect.bottom + 8;

            // Keep card within viewport
            if (left + cardWidth > window.innerWidth) {
                left = window.innerWidth - cardWidth - 16;
            }
            if (top + cardHeight > window.innerHeight) {
                top = rect.top - cardHeight - 8;
            }

            card.style.left = Math.max(8, left) + 'px';
            card.style.top = Math.max(8, top) + 'px';

            // Show loading state
            card.innerHTML = '<div class="profile-card-loading">Loading...</div>';
            card.classList.add('visible');

            try {
                const stats = await getUserStats(username);

                // Avatar is now included in stats from database
                const safeAvatarUrl = sanitizeUrl(stats.avatarUrl);
                const avatarContent = safeAvatarUrl
                    ? `<img src="${safeAvatarUrl}" alt="${escapeHtml(username)}">`
                    : (stats.avatar || 'ðŸ‘¤');

                card.innerHTML = `
                    <div class="profile-card-header">
                        <div class="profile-card-avatar">${avatarContent}</div>
                        <div class="profile-card-name">${escapeHtml(username)}</div>
                    </div>
                    <div class="profile-card-stats">
                        <div class="profile-card-stat">
                            <div class="profile-card-stat-value">${stats.messages}</div>
                            <div class="profile-card-stat-label">Messages</div>
                        </div>
                        <div class="profile-card-stat">
                            <div class="profile-card-stat-value">${stats.posts}</div>
                            <div class="profile-card-stat-label">Posts</div>
                        </div>
                        <div class="profile-card-stat">
                            <div class="profile-card-stat-value">${stats.doodles}</div>
                            <div class="profile-card-stat-label">Doodles</div>
                        </div>
                    </div>
                    <div class="profile-card-stats" style="margin-bottom:0;">
                        <div class="profile-card-stat">
                            <div class="profile-card-stat-value">${stats.manifestos}</div>
                            <div class="profile-card-stat-label">Manifestos</div>
                        </div>
                        <div class="profile-card-stat" style="grid-column: span 2;">
                            <div class="profile-card-stat-value">${stats.likes >= 0 ? '+' : ''}${stats.likes}</div>
                            <div class="profile-card-stat-label">Total Likes</div>
                        </div>
                    </div>
                `;
            } catch (err) {
                console.error('Error loading profile:', err);
                card.innerHTML = '<div class="profile-card-loading">Could not load profile</div>';
            }
        }

        function hideProfileCard() {
            const card = document.getElementById('profileCard');
            if (card) {
                card.classList.remove('visible');
            }
        }

        function scheduleHideProfileCard() {
            profileCardTimeout = setTimeout(hideProfileCard, 300);
        }

        // Close profile card on click outside
        document.addEventListener('click', (e) => {
            const card = document.getElementById('profileCard');
            if (card && !card.contains(e.target) && !e.target.classList.contains('username-clickable')) {
                hideProfileCard();
            }
        });

        // Expose profile card functions
        window.showProfileCard = showProfileCard;
        window.hideProfileCard = hideProfileCard;

        // === LAZY LOADING OPTIMIZER ===
        let imageObserver = null;

        function initLazyLoading() {
            if (!('IntersectionObserver' in window)) {
                // Fallback: load all images immediately
                document.querySelectorAll('img[data-src]').forEach(img => {
                    img.src = img.dataset.src;
                });
                return;
            }

            imageObserver = new IntersectionObserver((entries, observer) => {
                entries.forEach(entry => {
                    if (entry.isIntersecting) {
                        const img = entry.target;
                        if (img.dataset.src) {
                            img.src = img.dataset.src;
                            img.removeAttribute('data-src');
                            img.classList.remove('loading');
                        }
                        observer.unobserve(img);
                    }
                });
            }, {
                rootMargin: '100px 0px', // Start loading 100px before visible
                threshold: 0.01
            });
        }

        function observeLazyImage(img) {
            if (imageObserver && img.dataset.src) {
                img.classList.add('loading');
                imageObserver.observe(img);
            }
        }

        function lazyLoadNewImages() {
            document.querySelectorAll('img[data-src]:not(.observed)').forEach(img => {
                img.classList.add('observed');
                observeLazyImage(img);
            });
        }

        // Initialize lazy loading on page load
        initLazyLoading();

        // Helper function to log AI events
        async function logAiEvent(eventType, entityType, entityId, metadata = {}) {
            if (!currentUser) return;
            try {
                await supabase.from('ai_events').insert({
                    event_type: eventType,
                    entity_type: entityType,
                    entity_id: entityId,
                    username: profile.username,
                    metadata: metadata,
                    user_id: currentUser.id
                });
            } catch (e) {
                console.error('Error logging AI event:', e);
            }
        }

        // Load saved profile
        const savedProfile = localStorage.getItem('sloppygram_profile');
        if (savedProfile) {
            profile = JSON.parse(savedProfile);
        }

        // === TOAST NOTIFICATION SYSTEM ===
        const toastTimers = new Map(); // Track active toast timers for cleanup

        function showToast(message, type = 'info', duration = 4000) {
            const container = document.getElementById('toastContainer');
            if (!container) return;

            const icons = {
                success: 'âœ“',
                error: 'âœ•',
                warning: 'âš ',
                info: 'â„¹'
            };

            const toast = document.createElement('div');
            toast.className = `system-toast ${type}`;
            const toastId = 'toast_' + Date.now() + '_' + Math.random().toString(36).slice(2);
            toast.id = toastId;

            toast.innerHTML = `
                <span class="toast-icon">${icons[type] || icons.info}</span>
                <span class="toast-message">${escapeHtml(message)}</span>
                <button class="toast-close" onclick="dismissToast('${toastId}')">&times;</button>
            `;

            container.appendChild(toast);

            // Auto-dismiss after duration
            const timerId = setTimeout(() => {
                dismissToast(toastId);
            }, duration);

            toastTimers.set(toastId, timerId);

            return toastId;
        }

        window.dismissToast = function(toastId) {
            const toast = document.getElementById(toastId);
            if (!toast) return;

            // Clear the timer
            const timerId = toastTimers.get(toastId);
            if (timerId) {
                clearTimeout(timerId);
                toastTimers.delete(toastId);
            }

            // Animate out
            toast.classList.add('fade-out');
            setTimeout(() => {
                toast.remove();
            }, 300);
        };

        // Expose globally for use in other functions
        window.showToast = showToast;

        // === MEMORY LEAK PREVENTION ===
        let presenceChannel = null;
        let postsChannel = null;
        let globalSettingsChannel = null;

        function cleanupChannels() {
            console.log('Cleaning up Supabase channels...');
            if (realtimeChannel) {
                supabase.removeChannel(realtimeChannel);
                realtimeChannel = null;
            }
            if (presenceChannel) {
                supabase.removeChannel(presenceChannel);
                presenceChannel = null;
            }
            if (postsChannel) {
                supabase.removeChannel(postsChannel);
                postsChannel = null;
            }
            if (globalSettingsChannel) {
                supabase.removeChannel(globalSettingsChannel);
                globalSettingsChannel = null;
            }

            // Clear all toast timers
            toastTimers.forEach((timerId) => clearTimeout(timerId));
            toastTimers.clear();
        }

        // Cleanup on page unload
        window.addEventListener('beforeunload', cleanupChannels);
        window.addEventListener('pagehide', cleanupChannels);

        // Initialize
        async function init() {
            // Listen for auth state changes
            supabase.auth.onAuthStateChange((event, session) => {
                console.log('Auth state changed:', event);
                if (session) {
                    currentUser = session.user;
                }
            });

            // Auth - try to restore existing session first
            let { data: { session } } = await supabase.auth.getSession();
            if (!session) {
                console.log('No existing session, signing in anonymously...');
                const { data, error } = await supabase.auth.signInAnonymously();
                if (error) console.error('Auth error:', error);
                session = data?.session;
            } else {
                console.log('Restored existing session for user:', session.user?.id);
            }
            currentUser = session?.user;

            setupAvatarGrid();
            setupColorOptions();
            setupBrushColors();
            setupDrawingCanvas();
            loadMessageOpacity();
            loadThemeSettings();
            // Load saved sound settings
            const savedSounds = localStorage.getItem('sloppygram_sounds');
            if (savedSounds) {
                soundSettings = JSON.parse(savedSounds);
            }
            await loadDoodleVotes();
            await loadMessageVotes();
            await loadCommentVotes();
            loadMessages();
            subscribeToMessages();
            subscribeToPostsAndComments();
            setupPresence();
            applyCustomBackground();

            // Load and subscribe to global settings (backgrounds, sounds, avatars)
            subscribeToGlobalSettings();
            loadGlobalSettings();

            // Random visitor count for 90s vibes
            document.getElementById('visitorCount').textContent = Math.floor(10000 + Math.random() * 90000);

            // Auto-resize textarea
            const input = document.getElementById('messageInput');
            input.addEventListener('input', () => {
                input.style.height = 'auto';
                input.style.height = Math.min(input.scrollHeight, 100) + 'px';
            });

            // Enter to send
            input.addEventListener('keydown', (e) => {
                if (e.key === 'Enter' && !e.shiftKey) {
                    e.preventDefault();
                    sendMessage();
                }
            });

            // Infinite scroll for messages (load older messages when scrolling down)
            const messagesContainer = document.getElementById('messagesContainer');
            messagesContainer.addEventListener('scroll', () => {
                const { scrollTop, scrollHeight, clientHeight } = messagesContainer;
                // Load more when near bottom (older messages are at bottom)
                if (scrollHeight - scrollTop - clientHeight < 200) {
                    loadMessages(true);
                }
            });

            // Infinite scroll for posts
            const postsContainer = document.getElementById('postsContainer');
            postsContainer.addEventListener('scroll', () => {
                const { scrollTop, scrollHeight, clientHeight } = postsContainer;
                if (scrollHeight - scrollTop - clientHeight < 200) {
                    loadMorePosts();
                }
            });
        }

        // Load more posts for infinite scroll
        async function loadMorePosts() {
            if (postsLoading || !postsHasMore) return;
            postsLoading = true;

            const container = document.getElementById('postsContainer');
            const loader = document.createElement('div');
            loader.className = 'loading-indicator';
            loader.id = 'postsLoader';
            loader.textContent = 'Loading more posts...';
            container.appendChild(loader);

            const from = postsPage * PAGE_SIZE;
            const to = from + PAGE_SIZE - 1;

            const { data, error } = await supabase
                .from('sloppygram_posts')
                .select('*')
                .order('created_at', { ascending: false })
                .range(from, to);

            document.getElementById('postsLoader')?.remove();
            postsLoading = false;

            if (error || !data) return;

            postsHasMore = data.length === PAGE_SIZE;
            postsPage++;

            // Add new posts to existing array and re-render
            posts = [...posts, ...data];

            // Need to reload related data for new posts
            const newPostIds = data.map(p => p.id);
            if (newPostIds.length > 0) {
                await loadPostRelatedData(newPostIds);
            }

            renderPosts();
        }

        // Load related data (votes, comments, etc.) for specific post IDs
        async function loadPostRelatedData(postIds) {
            const [votesResult, commentsResult, reactionsResult, tagsResult, threadsResult] = await Promise.all([
                supabase.from('sloppygram_post_likes').select('post_id, username, vote_type').in('post_id', postIds),
                supabase.from('sloppygram_post_comments').select('*').in('post_id', postIds).order('created_at', { ascending: true }),
                supabase.from('sloppygram_post_reactions').select('*').in('post_id', postIds),
                supabase.from('sloppygram_post_tags').select('*').in('post_id', postIds),
                supabase.from('sloppygram_comment_threads').select('*').eq('comment_type', 'post').in('post_id', postIds)
            ]);

            // Process and merge votes
            (votesResult.data || []).forEach(vote => {
                postVotes[vote.post_id] = (postVotes[vote.post_id] || 0) + (vote.vote_type || 1);
                if (vote.username === profile.username) {
                    myPostVotes[vote.post_id] = vote.vote_type || 1;
                }
            });

            // Process comments
            (commentsResult.data || []).forEach(comment => {
                if (!postComments[comment.post_id]) postComments[comment.post_id] = [];
                postComments[comment.post_id].push(comment);
            });

            // Process reactions
            (reactionsResult.data || []).forEach(r => {
                if (!postReactions[r.post_id]) postReactions[r.post_id] = {};
                postReactions[r.post_id][r.emoji] = (postReactions[r.post_id][r.emoji] || 0) + 1;
                if (r.username === profile.username) {
                    if (!myReactions[r.post_id]) myReactions[r.post_id] = new Set();
                    myReactions[r.post_id].add(r.emoji);
                }
            });

            // Process tags
            (tagsResult.data || []).forEach(t => {
                if (!postTags[t.post_id]) postTags[t.post_id] = [];
                postTags[t.post_id].push({ tag: t.tag, parent_tag: t.parent_tag });
            });

            // Process comment threads
            (threadsResult.data || []).forEach(t => {
                commentThreads[t.comment_id] = t.parent_comment_id;
            });
        }

        // Presence for online users
        function setupPresence() {
            // Clean up existing presence channel if any
            if (presenceChannel) {
                supabase.removeChannel(presenceChannel);
            }

            presenceChannel = supabase.channel('sloppygram_presence', {
                config: {
                    presence: { key: currentUser?.id || 'anon_' + Math.random() }
                }
            });

            presenceChannel
                .on('presence', { event: 'sync' }, () => {
                    const state = presenceChannel.presenceState();
                    updateOnlineUsers(state);
                })
                .on('presence', { event: 'join' }, ({ key, newPresences }) => {
                    addToFeed(newPresences[0]?.username || 'Someone', 'joined the chat');
                })
                .on('presence', { event: 'leave' }, ({ key, leftPresences }) => {
                    addToFeed(leftPresences[0]?.username || 'Someone', 'left the chat');
                })
                .subscribe(async (status) => {
                    if (status === 'SUBSCRIBED') {
                        await presenceChannel.track({
                            username: profile.username,
                            avatar: profile.avatar,
                            avatarUrl: profile.avatarUrl || null,
                            color: profile.color,
                            online_at: new Date().toISOString()
                        });
                    }
                });
        }

        function updateOnlineUsers(state) {
            const userList = document.getElementById('userList');
            const users = [];

            // Add real users
            Object.values(state).forEach(presences => {
                presences.forEach(p => {
                    if (!users.find(u => u.username === p.username)) {
                        users.push(p);
                    }
                });
            });

            userList.innerHTML = users.map(u => {
                const safeAvatarUrl = sanitizeUrl(u.avatarUrl);
                const avatarContent = safeAvatarUrl
                    ? `<img src="${safeAvatarUrl}" style="width:24px;height:24px;border-radius:50%;object-fit:cover;">`
                    : u.avatar;
                return `
                <li class="user-item">
                    <span class="user-status"></span>
                    <span class="user-avatar">${avatarContent}</span>
                    <span class="user-name" style="color: ${u.color || 'var(--accent-light)'}">${escapeHtml(u.username)}</span>
                </li>
            `}).join('');
        }

        function addToFeed(user, action) {
            const feed = document.getElementById('publicFeed');
            const time = new Date().toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });

            const item = document.createElement('div');
            item.className = 'feed-item';
            item.innerHTML = `
                <span class="feed-user username-clickable" onclick="showProfileCard('${escapeHtml(user)}', event)">${escapeHtml(user)}</span>
                <span class="feed-action">${action}</span>
                <div class="feed-time">${time}</div>
            `;

            feed.insertBefore(item, feed.firstChild);

            // Keep only last 20 items
            while (feed.children.length > 20) {
                feed.removeChild(feed.lastChild);
            }
        }

        // Setup avatar grid
        function setupAvatarGrid() {
            const grid = document.getElementById('avatarGrid');
            grid.innerHTML = AVATARS.map(a =>
                `<button class="avatar-option ${a === profile.avatar ? 'selected' : ''}" onclick="selectAvatar('${a}')">${a}</button>`
            ).join('');
        }

        window.selectAvatar = function(avatar) {
            profile.avatar = avatar;
            document.querySelectorAll('.avatar-option').forEach(el => {
                el.classList.toggle('selected', el.textContent === avatar);
            });
        };

        // Setup color options
        function setupColorOptions() {
            const container = document.getElementById('colorOptions');
            container.innerHTML = COLORS.map(c =>
                `<button class="color-option ${c === profile.color ? 'selected' : ''}" style="background: ${c}" onclick="selectColor('${c}')"></button>`
            ).join('');
        }

        window.selectColor = function(color) {
            profile.color = color;
            document.querySelectorAll('.color-option').forEach(el => {
                el.classList.toggle('selected', el.style.background === color);
            });
        };

        // Setup brush colors
        function setupBrushColors() {
            const container = document.getElementById('brushColors');
            container.innerHTML = BRUSH_COLORS.map(c =>
                `<button class="brush-color ${c === brushColor ? 'selected' : ''}" style="background: ${c}" onclick="selectBrushColor('${c}')"></button>`
            ).join('');
        }

        window.selectBrushColor = function(color) {
            brushColor = color;
            document.querySelectorAll('.brush-color').forEach(el => {
                el.classList.toggle('selected', el.style.background === color);
            });
        };

        // Drawing canvas
        function setupDrawingCanvas() {
            const canvas = document.getElementById('drawingCanvas');
            drawingCtx = canvas.getContext('2d');
            drawingCtx.fillStyle = '#111';
            drawingCtx.fillRect(0, 0, canvas.width, canvas.height);
            drawingCtx.lineCap = 'round';
            drawingCtx.lineJoin = 'round';
            drawingCtx.lineWidth = 4;

            canvas.addEventListener('mousedown', startDrawing);
            canvas.addEventListener('mousemove', draw);
            canvas.addEventListener('mouseup', stopDrawing);
            canvas.addEventListener('mouseout', stopDrawing);

            canvas.addEventListener('touchstart', (e) => {
                e.preventDefault();
                const touch = e.touches[0];
                const rect = canvas.getBoundingClientRect();
                const offsetX = touch.clientX - rect.left;
                const offsetY = touch.clientY - rect.top;
                startDrawing({ offsetX, offsetY });
            }, { passive: false });

            canvas.addEventListener('touchmove', (e) => {
                e.preventDefault();
                const touch = e.touches[0];
                const rect = canvas.getBoundingClientRect();
                const offsetX = touch.clientX - rect.left;
                const offsetY = touch.clientY - rect.top;
                draw({ offsetX, offsetY });
            }, { passive: false });

            canvas.addEventListener('touchend', stopDrawing);
        }

        function getCanvasCoords(e) {
            const canvas = document.getElementById('drawingCanvas');
            const rect = canvas.getBoundingClientRect();
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;
            return {
                x: e.offsetX * scaleX,
                y: e.offsetY * scaleY
            };
        }

        function startDrawing(e) {
            isDrawing = true;
            const coords = getCanvasCoords(e);
            drawingCtx.beginPath();
            drawingCtx.moveTo(coords.x, coords.y);
        }

        function draw(e) {
            if (!isDrawing) return;
            const coords = getCanvasCoords(e);
            drawingCtx.strokeStyle = brushColor;
            drawingCtx.lineTo(coords.x, coords.y);
            drawingCtx.stroke();
        }

        function stopDrawing() {
            if (isDrawing) {
                isDrawing = false;
                saveCanvasState(); // Save state after each stroke
            }
        }

        window.clearCanvas = function() {
            const canvas = document.getElementById('drawingCanvas');
            drawingCtx.fillStyle = '#111';
            drawingCtx.fillRect(0, 0, canvas.width, canvas.height);
            resetCanvasHistory(); // Reset undo history on clear
        };

        // Load messages (newest first, at top)
        async function loadMessages(loadMore = false) {
            if (messagesLoading) return;
            if (loadMore && !messagesHasMore) return;

            messagesLoading = true;
            const container = document.getElementById('messagesContainer');

            // Show loading indicator
            if (loadMore) {
                const loader = document.createElement('div');
                loader.className = 'loading-indicator';
                loader.id = 'messagesLoader';
                loader.textContent = 'Loading...';
                container.appendChild(loader);
            }

            const from = loadMore ? messagesPage * PAGE_SIZE : 0;
            const to = from + PAGE_SIZE - 1;

            const { data, error } = await supabase
                .from('sloppygram_messages')
                .select('*')
                .order('created_at', { ascending: false })
                .range(from, to);

            // Remove loading indicator
            const loader = document.getElementById('messagesLoader');
            if (loader) loader.remove();

            messagesLoading = false;

            if (error) {
                console.error('Load error:', error);
                return;
            }

            const emptyState = document.getElementById('emptyState');

            if (!loadMore && data.length === 0) {
                emptyState.style.display = 'block';
                return;
            }

            emptyState.style.display = 'none';

            // Check if there are more messages
            messagesHasMore = data.length === PAGE_SIZE;
            if (loadMore) {
                messagesPage++;
            } else {
                messagesPage = 1;
            }

            data.forEach(msg => {
                if (!seenMessageIds.has(msg.id)) {
                    seenMessageIds.add(msg.id);
                    addMessageToUI(msg, false); // append at end (older messages)
                }
            });

            // Scroll to top only on initial load
            if (!loadMore) {
                container.scrollTop = 0;
            }
        }

        // Subscribe to new messages
        function subscribeToMessages() {
            if (realtimeChannel) {
                supabase.removeChannel(realtimeChannel);
            }

            realtimeChannel = supabase.channel('sloppygram-global', {
                config: {
                    broadcast: { self: false }
                }
            });

            realtimeChannel.on('broadcast', { event: 'new_message' }, (payload) => {
                const msg = payload.payload;
                if (!msg || seenMessageIds.has(msg.id)) return;
                seenMessageIds.add(msg.id);
                addMessageToUI(msg, true); // prepend new messages at top
                addToFeed(msg.username, 'sent a message');
                // Play sound for messages from others
                if (msg.user_id !== currentUser?.id) {
                    playNotificationSound();
                }
            });

            // Listen for global background changes
            realtimeChannel.on('broadcast', { event: 'global_background' }, (payload) => {
                const bgData = payload.payload;
                if (bgData && bgData.image_data) {
                    const msgContainer = document.getElementById('messagesContainer');
                    if (msgContainer) {
                        msgContainer.style.backgroundImage = `url(${bgData.image_data})`;
                        msgContainer.style.backgroundSize = 'cover';
                        msgContainer.style.backgroundPosition = 'center';
                        msgContainer.style.backgroundAttachment = 'fixed';
                        msgContainer.style.backgroundRepeat = 'no-repeat';
                    }
                    addToFeed(bgData.username || 'Someone', 'changed the chat background');
                }
            });

            realtimeChannel.on('postgres_changes', {
                event: 'INSERT',
                schema: 'public',
                table: 'sloppygram_messages'
            }, (payload) => {
                if (seenMessageIds.has(payload.new.id)) return;
                seenMessageIds.add(payload.new.id);
                addMessageToUI(payload.new, true); // prepend new messages at top
                // Play sound for messages from others
                if (payload.new.user_id !== currentUser?.id) {
                    playNotificationSound();
                }
            });

            realtimeChannel.subscribe();
        }

        // Subscribe to posts and comments for real-time updates
        function subscribeToPostsAndComments() {
            if (postsChannel) {
                supabase.removeChannel(postsChannel);
            }

            postsChannel = supabase.channel('sloppygram-posts-realtime');

            // Listen for new posts
            postsChannel.on('postgres_changes', {
                event: 'INSERT',
                schema: 'public',
                table: 'sloppygram_posts'
            }, (payload) => {
                console.log('New post received:', payload.new);
                // Add to posts array if not already there
                if (!posts.find(p => p.id === payload.new.id)) {
                    posts.unshift(payload.new);
                    if (currentView === 'posts') {
                        renderPosts();
                    }
                }
            });

            // Listen for new comments
            postsChannel.on('postgres_changes', {
                event: 'INSERT',
                schema: 'public',
                table: 'sloppygram_post_comments'
            }, (payload) => {
                console.log('New comment received:', payload.new);
                const comment = payload.new;
                if (!postComments[comment.post_id]) {
                    postComments[comment.post_id] = [];
                }
                // Add if not already there
                if (!postComments[comment.post_id].find(c => c.id === comment.id)) {
                    postComments[comment.post_id].push(comment);
                    if (currentView === 'posts') {
                        renderPosts();
                    }
                }
            });

            // Listen for comment thread relationships
            postsChannel.on('postgres_changes', {
                event: 'INSERT',
                schema: 'public',
                table: 'sloppygram_comment_threads'
            }, (payload) => {
                console.log('New thread relationship:', payload.new);
                const thread = payload.new;
                commentThreads[thread.comment_id] = thread.parent_comment_id;
                if (currentView === 'posts') {
                    renderPosts();
                }
            });

            // Listen for new reactions
            postsChannel.on('postgres_changes', {
                event: '*',
                schema: 'public',
                table: 'sloppygram_post_reactions'
            }, (payload) => {
                console.log('Reaction change:', payload);
                // Reload reactions for affected post
                if (payload.new?.post_id || payload.old?.post_id) {
                    loadPosts(); // Simple reload for now
                }
            });

            // Listen for likes
            postsChannel.on('postgres_changes', {
                event: '*',
                schema: 'public',
                table: 'sloppygram_post_likes'
            }, (payload) => {
                console.log('Like change:', payload);
                if (payload.new?.post_id || payload.old?.post_id) {
                    loadPosts();
                }
            });

            // Listen for manifesto comments
            postsChannel.on('postgres_changes', {
                event: 'INSERT',
                schema: 'public',
                table: 'sloppygram_manifesto_comments'
            }, (payload) => {
                console.log('New manifesto comment:', payload.new);
                const comment = payload.new;
                if (!manifestoComments[comment.manifesto_id]) {
                    manifestoComments[comment.manifesto_id] = [];
                }
                if (!manifestoComments[comment.manifesto_id].find(c => c.id === comment.id)) {
                    manifestoComments[comment.manifesto_id].push(comment);
                    if (currentView === 'manifesto') {
                        renderManifestos();
                    }
                }
            });

            // Listen for new manifestos
            postsChannel.on('postgres_changes', {
                event: 'INSERT',
                schema: 'public',
                table: 'sloppygram_manifestos'
            }, (payload) => {
                console.log('New manifesto:', payload.new);
                if (!manifestos.find(m => m.id === payload.new.id)) {
                    manifestos.unshift(payload.new);
                    if (currentView === 'manifesto') {
                        renderManifestos();
                    }
                }
            });

            // Listen for manifesto votes
            postsChannel.on('postgres_changes', {
                event: '*',
                schema: 'public',
                table: 'sloppygram_manifesto_votes'
            }, (payload) => {
                console.log('Manifesto vote change:', payload);
                loadManifestos();
            });

            // Listen for manifesto reactions
            postsChannel.on('postgres_changes', {
                event: '*',
                schema: 'public',
                table: 'sloppygram_manifesto_reactions'
            }, (payload) => {
                console.log('Manifesto reaction change:', payload);
                loadManifestos();
            });

            // Listen for doodle votes
            postsChannel.on('postgres_changes', {
                event: '*',
                schema: 'public',
                table: 'sloppygram_doodle_votes'
            }, (payload) => {
                console.log('Doodle vote change:', payload);
                loadDoodleVotes();
                if (currentView === 'doodles') {
                    loadDoodleLeaderboard();
                }
            });

            // Listen for post tags (trending tags)
            postsChannel.on('postgres_changes', {
                event: '*',
                schema: 'public',
                table: 'sloppygram_post_tags'
            }, (payload) => {
                console.log('Post tag change:', payload);
                loadPosts(); // Reload to update trending tags
            });

            // Listen for manifesto tags
            postsChannel.on('postgres_changes', {
                event: '*',
                schema: 'public',
                table: 'sloppygram_manifesto_tags'
            }, (payload) => {
                console.log('Manifesto tag change:', payload);
                loadManifestos();
            });

            // Listen for global backgrounds
            postsChannel.on('postgres_changes', {
                event: 'INSERT',
                schema: 'public',
                table: 'sloppygram_global_backgrounds'
            }, (payload) => {
                console.log('New global background:', payload.new);
                globalBackgrounds.unshift(payload.new);
                renderGlobalBackgrounds(); // Update UI for all users
            });

            // Listen for chat message votes
            postsChannel.on('postgres_changes', {
                event: '*',
                schema: 'public',
                table: 'sloppygram_message_votes'
            }, (payload) => {
                console.log('Message vote change:', payload);
                loadMessageVotes();
            });

            // Listen for comment votes
            postsChannel.on('postgres_changes', {
                event: '*',
                schema: 'public',
                table: 'sloppygram_comment_votes'
            }, (payload) => {
                console.log('Comment vote change:', payload);
                loadCommentVotes().then(() => renderPosts());
            });

            postsChannel.subscribe((status) => {
                console.log('Posts realtime subscription status:', status);
            });
        }

        function broadcastMessage(msg) {
            if (realtimeChannel) {
                realtimeChannel.send({
                    type: 'broadcast',
                    event: 'new_message',
                    payload: msg
                });
            }
        }

        function scrollToBottom() {
            const container = document.getElementById('messagesContainer');
            container.scrollTop = container.scrollHeight;
        }

        // Add message to UI (append by default for bottom-up chat flow)
        function addMessageToUI(msg, prepend = false) {
            const container = document.getElementById('messagesContainer');
            document.getElementById('emptyState').style.display = 'none';

            const isOwn = msg.user_id === currentUser?.id;
            const time = new Date(msg.created_at).toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });

            const div = document.createElement('div');
            div.className = `message ${isOwn ? 'own' : ''}`;

            let contentHTML = '';
            if (msg.content) {
                contentHTML = `<div class="message-content">${escapeHtml(msg.content)}</div>`;
            }
            const safeImageData = sanitizeUrl(msg.image_data);
            if (safeImageData) {
                contentHTML += `<img class="message-image" src="${safeImageData}" onclick="window.open(this.src)">`;
            }
            const safeDrawingData = sanitizeUrl(msg.drawing_data);
            if (safeDrawingData) {
                const doodleId = msg.id;
                const isRealDoodleId = typeof doodleId === 'number' || (typeof doodleId === 'string' && !doodleId.startsWith('temp_'));
                const doodleScore = doodleVotes[doodleId] || 0;
                const myDoodleVote = myDoodleVotes[doodleId] || 0;
                const isOwnDoodle = msg.username === profile.username;
                const doodleScoreClass = doodleScore > 0 ? 'positive' : doodleScore < 0 ? 'negative' : 'neutral';
                const doodleVoteControls = isRealDoodleId ? `
                    <div class="vote-controls doodle-votes" data-doodle-id="${doodleId}">
                        <button class="vote-btn upvote ${myDoodleVote === 1 ? 'active' : ''} ${isOwnDoodle ? 'disabled' : ''}"
                            onclick="${isOwnDoodle ? '' : `voteDoodle('${doodleId}', 1, '${escapeHtml(msg.username)}')`}"
                            title="${isOwnDoodle ? 'Cannot vote on own doodle' : 'Upvote'}">â–²</button>
                        <span class="vote-score ${doodleScoreClass}">${doodleScore}</span>
                        <button class="vote-btn downvote ${myDoodleVote === -1 ? 'active' : ''} ${isOwnDoodle ? 'disabled' : ''}"
                            onclick="${isOwnDoodle ? '' : `voteDoodle('${doodleId}', -1, '${escapeHtml(msg.username)}')`}"
                            title="${isOwnDoodle ? 'Cannot vote on own doodle' : 'Downvote'}">â–¼</button>
                    </div>` : '';
                contentHTML += `
                    <div class="doodle-wrapper">
                        <img class="message-drawing" src="${safeDrawingData}">
                        ${doodleVoteControls}
                    </div>`;
            }

            // Vote controls for non-doodle messages
            const msgId = msg.id;
            const isRealId = typeof msgId === 'number' || (typeof msgId === 'string' && !msgId.startsWith('temp_'));
            const isOwnMessage = msg.username === profile.username;
            const chatVoteScore = messageVotes[msgId] || 0;
            const myVoteType = myMessageVotes[msgId] || 0;
            const scoreClass = chatVoteScore > 0 ? 'positive' : chatVoteScore < 0 ? 'negative' : 'neutral';
            const chatVoteBtn = (isRealId && !msg.drawing_data) ? `
                <div class="message-footer">
                    <div class="vote-controls" data-chat-id="${msgId}">
                        <button class="vote-btn upvote ${myVoteType === 1 ? 'active' : ''} ${isOwnMessage ? 'disabled' : ''}"
                            onclick="${isOwnMessage ? '' : `voteMessage('${msgId}', 1)`}" title="${isOwnMessage ? 'Cannot vote on own content' : 'Upvote'}">â–²</button>
                        <span class="vote-score ${scoreClass}">${chatVoteScore}</span>
                        <button class="vote-btn downvote ${myVoteType === -1 ? 'active' : ''} ${isOwnMessage ? 'disabled' : ''}"
                            onclick="${isOwnMessage ? '' : `voteMessage('${msgId}', -1)`}" title="${isOwnMessage ? 'Cannot vote on own content' : 'Downvote'}">â–¼</button>
                    </div>
                </div>` : '';

            const safeAvatarUrl = sanitizeUrl(msg.avatar_url || msg.avatarUrl);
            const avatarContent = safeAvatarUrl
                ? `<img src="${safeAvatarUrl}" alt="avatar" style="width:100%;height:100%;object-fit:cover;border-radius:50%;">`
                : (msg.avatar || 'ðŸ‘¤');
            const deleteBtn = (isOwnMessage && isRealId) ? `<button class="msg-delete-btn" onclick="deleteMessage('${msgId}')" title="Delete">delete</button>` : '';
            div.innerHTML = `
                <div class="avatar">${avatarContent}</div>
                <div class="message-bubble">
                    <div class="message-header">
                        <span class="message-username username-clickable" onclick="showProfileCard('${escapeHtml(msg.username || 'Anonymous')}', event)">${escapeHtml(msg.username || 'Anonymous')}</span>
                        <span class="message-time">${time}</span>
                        ${deleteBtn}
                    </div>
                    ${contentHTML}
                    ${chatVoteBtn}
                </div>
            `;

            if (prepend) {
                container.insertBefore(div, container.firstChild);
            } else {
                container.appendChild(div);
                // Scroll to bottom for new messages
                container.scrollTop = container.scrollHeight;
            }
        }

        // Sanitize text content using DOMPurify - removes all HTML/scripts
        function escapeHtml(text) {
            if (!text) return '';
            // Use DOMPurify to strip all HTML tags, keeping only text
            return DOMPurify.sanitize(String(text), { ALLOWED_TAGS: [] });
        }

        // Sanitize HTML content - allows safe tags but removes scripts
        function sanitizeHtml(html) {
            if (!html) return '';
            return DOMPurify.sanitize(html, {
                ALLOWED_TAGS: ['b', 'i', 'em', 'strong', 'br', 'p', 'span'],
                ALLOWED_ATTR: []
            });
        }

        // Sanitize URLs - block dangerous protocols but allow image data URLs
        function sanitizeUrl(url) {
            if (!url) return '';
            const str = String(url).trim();

            // Allow data:image URLs (base64 images) - match image MIME types
            if (/^data:image\/(png|jpeg|jpg|gif|webp|svg\+xml);base64,/i.test(str)) {
                return str;
            }

            // Block javascript:, other data:, vbscript:, file: protocols
            if (/^(javascript|data|vbscript|file):/i.test(str)) {
                console.warn('Blocked dangerous URL:', str.slice(0, 50));
                return '';
            }

            // Allow http/https URLs and relative paths
            return DOMPurify.sanitize(str, { ALLOWED_TAGS: [] });
        }

        // Send message
        window.sendMessage = async function() {
            const input = document.getElementById('messageInput');
            const content = input.value.trim();

            if (!content && !selectedImage) return;

            // Rate limiting check
            const rateCheck = checkRateLimit('message');
            if (!rateCheck.allowed) {
                showToast(rateCheck.message, 'warning');
                return;
            }
            recordAction('message');

            const tempId = 'temp_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
            const hasImage = !!selectedImage;
            const localImageData = selectedImage; // keep reference for optimistic UI

            const msg = {
                id: tempId,
                username: profile.username,
                avatar: profile.avatar,
                avatarUrl: profile.avatarUrl || null,
                content: content || null,
                image_data: localImageData || null, // temp local preview
                drawing_data: null,
                message_type: hasImage ? 'image' : 'text',
                user_id: currentUser?.id,
                created_at: new Date().toISOString()
            };

            input.value = '';
            input.style.height = 'auto';
            removeImage();

            seenMessageIds.add(tempId);
            addMessageToUI(msg, true); // prepend at top
            broadcastMessage(msg);
            addToFeed(profile.username, hasImage ? 'shared an image' : 'sent a message');

            // Upload image to storage if present
            let finalImageData = null;
            if (localImageData) {
                const blob = dataURLtoBlob(localImageData);
                const storageUrl = await uploadToStorage(blob, 'chat');
                finalImageData = storageUrl || localImageData; // fallback to base64
            }

            const { data, error } = await supabase
                .from('sloppygram_messages')
                .insert({
                    username: msg.username,
                    avatar: msg.avatar,
                    avatar_url: msg.avatarUrl,
                    content: msg.content,
                    image_data: finalImageData,
                    drawing_data: msg.drawing_data,
                    message_type: msg.message_type,
                    user_id: msg.user_id
                })
                .select('id')
                .single();

            if (error) {
                console.error('Send error:', error);
                return;
            }

            if (data?.id) {
                seenMessageIds.add(data.id);
            }
        };

        // Delete message
        window.deleteMessage = async function(messageId) {
            if (!currentUser) return;
            if (!confirm('Delete this message?')) return;

            const { error } = await supabase
                .from('sloppygram_messages')
                .delete()
                .eq('id', messageId)
                .eq('user_id', currentUser.id);

            if (error) {
                console.error('Delete error:', error);
                return;
            }

            // Remove from UI
            const container = document.getElementById('messagesContainer');
            const msgElements = container.querySelectorAll('.message');
            msgElements.forEach(el => {
                const voteControl = el.querySelector(`[data-chat-id="${messageId}"]`);
                const doodleControl = el.querySelector(`[data-doodle-id="${messageId}"]`);
                if (voteControl || doodleControl) {
                    el.remove();
                }
            });
        };

        // Send drawing
        window.sendDrawing = async function() {
            // Rate limiting check
            const rateCheck = checkRateLimit('drawing');
            if (!rateCheck.allowed) {
                showToast(rateCheck.message, 'warning');
                return;
            }
            recordAction('drawing');

            const canvas = document.getElementById('drawingCanvas');
            const drawingDataUrl = canvas.toDataURL('image/png');

            const tempId = 'temp_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);

            // Show optimistic UI with local data URL first
            const msg = {
                id: tempId,
                username: profile.username,
                avatar: profile.avatar,
                avatarUrl: profile.avatarUrl || null,
                content: null,
                image_data: null,
                drawing_data: drawingDataUrl, // temporary local preview
                message_type: 'drawing',
                user_id: currentUser?.id,
                created_at: new Date().toISOString()
            };

            closeDrawingModal();
            clearCanvas();

            seenMessageIds.add(tempId);
            addMessageToUI(msg, true); // prepend at top
            broadcastMessage(msg);
            addToFeed(profile.username, 'shared a drawing');

            // Upload to storage instead of saving base64
            const blob = dataURLtoBlob(drawingDataUrl);
            const storageUrl = await uploadToStorage(blob, 'doodles');

            // Use storage URL if upload succeeded, otherwise fallback to base64
            const finalDrawingData = storageUrl || drawingDataUrl;

            const { data, error } = await supabase
                .from('sloppygram_messages')
                .insert({
                    username: msg.username,
                    avatar: msg.avatar,
                    avatar_url: msg.avatarUrl,
                    content: msg.content,
                    image_data: msg.image_data,
                    drawing_data: finalDrawingData,
                    message_type: msg.message_type,
                    user_id: msg.user_id
                })
                .select('id')
                .single();

            if (error) {
                console.error('Send error:', error);
            }

            if (data?.id) {
                seenMessageIds.add(data.id);
            }
        };

        // Image handling
        window.handleImageSelect = function(event) {
            const file = event.target.files[0];
            if (!file) return;

            if (file.size > 500000) {
                alert('FILE TOO LARGE. MAX 500KB.');
                return;
            }

            const reader = new FileReader();
            reader.onload = (e) => {
                selectedImage = e.target.result;
                document.getElementById('previewImg').src = selectedImage;
                document.getElementById('imagePreview').style.display = 'block';
            };
            reader.readAsDataURL(file);
        };

        window.removeImage = function() {
            selectedImage = null;
            document.getElementById('imagePreview').style.display = 'none';
            document.getElementById('imageInput').value = '';
        };

        // Settings modal
        let pendingAvatarData = null;
        let pendingBgData = null;

        // Sound settings
        let soundSettings = {
            sound: 'none',
            volume: 50,
            customData: '',
            customName: ''
        };

        // Audio context for generating sounds
        let audioContext = null;
        let customSoundAudio = null;

        function getAudioContext() {
            if (!audioContext) {
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
            }
            // Resume if suspended (browser autoplay policy)
            if (audioContext.state === 'suspended') {
                audioContext.resume();
            }
            return audioContext;
        }

        // Sound library using Web Audio API (procedural sounds)
        const soundLibrary = {
            blip: function(ctx, vol) {
                const osc = ctx.createOscillator();
                const gain = ctx.createGain();
                osc.connect(gain);
                gain.connect(ctx.destination);
                osc.frequency.setValueAtTime(800, ctx.currentTime);
                osc.frequency.exponentialRampToValueAtTime(400, ctx.currentTime + 0.1);
                gain.gain.setValueAtTime(vol, ctx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, ctx.currentTime + 0.1);
                osc.start(ctx.currentTime);
                osc.stop(ctx.currentTime + 0.1);
            },
            chime: function(ctx, vol) {
                [523, 659, 784].forEach((freq, i) => {
                    const osc = ctx.createOscillator();
                    const gain = ctx.createGain();
                    osc.type = 'sine';
                    osc.connect(gain);
                    gain.connect(ctx.destination);
                    osc.frequency.setValueAtTime(freq, ctx.currentTime + i * 0.08);
                    gain.gain.setValueAtTime(vol * 0.6, ctx.currentTime + i * 0.08);
                    gain.gain.exponentialRampToValueAtTime(0.01, ctx.currentTime + i * 0.08 + 0.3);
                    osc.start(ctx.currentTime + i * 0.08);
                    osc.stop(ctx.currentTime + i * 0.08 + 0.3);
                });
            },
            pop: function(ctx, vol) {
                const osc = ctx.createOscillator();
                const gain = ctx.createGain();
                osc.type = 'sine';
                osc.connect(gain);
                gain.connect(ctx.destination);
                osc.frequency.setValueAtTime(600, ctx.currentTime);
                osc.frequency.exponentialRampToValueAtTime(200, ctx.currentTime + 0.05);
                gain.gain.setValueAtTime(vol, ctx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, ctx.currentTime + 0.05);
                osc.start(ctx.currentTime);
                osc.stop(ctx.currentTime + 0.05);
            },
            retro: function(ctx, vol) {
                const osc = ctx.createOscillator();
                const gain = ctx.createGain();
                osc.type = 'square';
                osc.connect(gain);
                gain.connect(ctx.destination);
                osc.frequency.setValueAtTime(440, ctx.currentTime);
                osc.frequency.setValueAtTime(880, ctx.currentTime + 0.05);
                osc.frequency.setValueAtTime(440, ctx.currentTime + 0.1);
                gain.gain.setValueAtTime(vol * 0.3, ctx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, ctx.currentTime + 0.15);
                osc.start(ctx.currentTime);
                osc.stop(ctx.currentTime + 0.15);
            },
            cyber: function(ctx, vol) {
                const osc = ctx.createOscillator();
                const osc2 = ctx.createOscillator();
                const gain = ctx.createGain();
                osc.type = 'sawtooth';
                osc2.type = 'square';
                osc.connect(gain);
                osc2.connect(gain);
                gain.connect(ctx.destination);
                osc.frequency.setValueAtTime(150, ctx.currentTime);
                osc.frequency.linearRampToValueAtTime(600, ctx.currentTime + 0.1);
                osc2.frequency.setValueAtTime(300, ctx.currentTime);
                osc2.frequency.linearRampToValueAtTime(100, ctx.currentTime + 0.1);
                gain.gain.setValueAtTime(vol * 0.2, ctx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, ctx.currentTime + 0.12);
                osc.start(ctx.currentTime);
                osc2.start(ctx.currentTime);
                osc.stop(ctx.currentTime + 0.12);
                osc2.stop(ctx.currentTime + 0.12);
            },
            whoosh: function(ctx, vol) {
                const bufferSize = ctx.sampleRate * 0.15;
                const buffer = ctx.createBuffer(1, bufferSize, ctx.sampleRate);
                const data = buffer.getChannelData(0);
                for (let i = 0; i < bufferSize; i++) {
                    data[i] = (Math.random() * 2 - 1) * (1 - i / bufferSize);
                }
                const noise = ctx.createBufferSource();
                const filter = ctx.createBiquadFilter();
                const gain = ctx.createGain();
                noise.buffer = buffer;
                filter.type = 'bandpass';
                filter.frequency.setValueAtTime(1000, ctx.currentTime);
                filter.frequency.exponentialRampToValueAtTime(200, ctx.currentTime + 0.15);
                noise.connect(filter);
                filter.connect(gain);
                gain.connect(ctx.destination);
                gain.gain.setValueAtTime(vol, ctx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, ctx.currentTime + 0.15);
                noise.start(ctx.currentTime);
            },
            ding: function(ctx, vol) {
                const osc = ctx.createOscillator();
                const gain = ctx.createGain();
                osc.type = 'sine';
                osc.connect(gain);
                gain.connect(ctx.destination);
                osc.frequency.setValueAtTime(1200, ctx.currentTime);
                gain.gain.setValueAtTime(vol * 0.5, ctx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, ctx.currentTime + 0.4);
                osc.start(ctx.currentTime);
                osc.stop(ctx.currentTime + 0.4);
            }
        };

        function playNotificationSound() {
            if (soundSettings.sound === 'none') return;
            const vol = soundSettings.volume / 100;

            // Custom sound (base64 data)
            if (soundSettings.sound === 'custom' && soundSettings.customData) {
                try {
                    if (!customSoundAudio || customSoundAudio.src !== soundSettings.customData) {
                        customSoundAudio = new Audio(soundSettings.customData);
                    }
                    customSoundAudio.volume = vol;
                    customSoundAudio.currentTime = 0;
                    customSoundAudio.play().catch(e => console.log('Audio play failed:', e));
                } catch (e) {
                    console.log('Custom sound error:', e);
                }
                return;
            }

            // Built-in sounds
            const ctx = getAudioContext();
            if (soundLibrary[soundSettings.sound]) {
                soundLibrary[soundSettings.sound](ctx, vol);
            }
        }

        window.previewSound = function(soundName) {
            const vol = soundSettings.volume / 100;

            if (soundName === 'custom') {
                const data = soundSettings.customData;
                if (data) {
                    try {
                        const audio = new Audio(data);
                        audio.volume = vol;
                        audio.play().catch(e => console.log('Audio play failed:', e));
                    } catch (e) {
                        console.log('Custom sound error:', e);
                    }
                } else {
                    alert('Upload a custom sound file first');
                }
                return;
            }

            const ctx = getAudioContext();
            if (soundLibrary[soundName]) {
                soundLibrary[soundName](ctx, vol);
            }
        };

        window.handleSoundUpload = function(event) {
            const file = event.target.files[0];
            if (!file) return;

            if (file.size > 500000) {
                alert('Audio file too large! Max 500KB.');
                return;
            }

            const reader = new FileReader();
            reader.onload = function(e) {
                soundSettings.customData = e.target.result;
                soundSettings.customName = file.name;
                document.getElementById('customSoundName').textContent = 'â™ª ' + file.name;
                document.getElementById('customSoundName').style.display = 'block';
                document.getElementById('clearSoundBtn').style.display = 'inline-block';
                // Auto-select custom sound
                selectSound('custom');
            };
            reader.readAsDataURL(file);
        };

        window.clearCustomSound = function() {
            soundSettings.customData = '';
            soundSettings.customName = '';
            document.getElementById('customSoundFile').value = '';
            document.getElementById('customSoundName').style.display = 'none';
            document.getElementById('clearSoundBtn').style.display = 'none';
            if (soundSettings.sound === 'custom') {
                selectSound('none');
            }
        };

        window.selectSound = function(soundName) {
            soundSettings.sound = soundName;
            document.querySelectorAll('.sound-option').forEach(opt => opt.classList.remove('selected'));
            document.querySelector(`.sound-option[onclick*="'${soundName}'"]`).classList.add('selected');
        };

        window.setVolume = function(value) {
            soundSettings.volume = parseInt(value);
            document.getElementById('volumeValue').textContent = value + '%';
        };

        window.saveSoundSettings = function() {
            localStorage.setItem('sloppygram_sounds', JSON.stringify(soundSettings));

            // Broadcast sound setting globally
            broadcastGlobalSetting('sound', soundSettings.sound, soundSettings.customData || '');

            closeSettingsModal();
        };

        function loadSoundSettings() {
            const saved = localStorage.getItem('sloppygram_sounds');
            if (saved) {
                soundSettings = JSON.parse(saved);
                document.getElementById('volumeSlider').value = soundSettings.volume;
                document.getElementById('volumeValue').textContent = soundSettings.volume + '%';
                document.querySelectorAll('.sound-option').forEach(opt => opt.classList.remove('selected'));
                const selectedOpt = document.querySelector(`.sound-option[onclick*="'${soundSettings.sound}'"]`);
                if (selectedOpt) selectedOpt.classList.add('selected');
                // Load custom sound info
                if (soundSettings.customData && soundSettings.customName) {
                    document.getElementById('customSoundName').textContent = 'â™ª ' + soundSettings.customName;
                    document.getElementById('customSoundName').style.display = 'block';
                    document.getElementById('clearSoundBtn').style.display = 'inline-block';
                }
            }
        }

        // === GLOBAL SETTINGS SYNC ===
        async function broadcastGlobalSetting(settingType, settingValue, extraData = '') {
            if (!currentUser) return;

            // Broadcast via realtime channel for instant update
            if (globalSettingsChannel) {
                globalSettingsChannel.send({
                    type: 'broadcast',
                    event: 'global_setting',
                    payload: {
                        setting_type: settingType,
                        setting_value: settingValue,
                        username: profile.username,
                        extra_data: extraData
                    }
                });
            }

            // Also save to database for persistence
            try {
                await supabase.from('sloppygram_global_settings').insert({
                    setting_type: settingType,
                    setting_value: settingValue,
                    username: profile.username,
                    extra_data: extraData,
                    user_id: currentUser.id
                });
            } catch (e) {
                console.error('Error saving global setting:', e);
            }
        }

        function applyGlobalSetting(settingType, settingValue, username, extraData) {
            const notification = `ðŸŒ ${username} changed global ${settingType}!`;

            switch (settingType) {
                case 'background':
                    const msgContainer = document.getElementById('messagesContainer');
                    if (msgContainer && settingValue) {
                        msgContainer.style.backgroundImage = `url(${settingValue})`;
                        msgContainer.style.backgroundSize = 'cover';
                        msgContainer.style.backgroundPosition = 'center';
                        msgContainer.style.backgroundAttachment = 'fixed';
                        addToFeed(username, 'set global background');
                    }
                    break;

                case 'sound':
                    soundSettings.sound = settingValue;
                    if (extraData) {
                        soundSettings.customData = extraData;
                    }
                    document.querySelectorAll('.sound-option').forEach(opt => opt.classList.remove('selected'));
                    const selectedOpt = document.querySelector(`.sound-option[onclick*="'${settingValue}'"]`);
                    if (selectedOpt) selectedOpt.classList.add('selected');
                    addToFeed(username, `set global sound to ${settingValue}`);
                    // Play the sound so everyone hears it
                    playNotificationSound();
                    break;

                case 'avatar':
                    // Show notification that someone changed their avatar globally
                    addToFeed(username, 'updated their avatar');
                    break;
            }
        }

        async function loadGlobalSettings() {
            // Load most recent global settings from database
            const { data: bgData } = await supabase
                .from('sloppygram_global_settings')
                .select('*')
                .eq('setting_type', 'background')
                .order('created_at', { ascending: false })
                .limit(1);

            if (bgData && bgData[0] && bgData[0].setting_value) {
                applyGlobalSetting('background', bgData[0].setting_value, bgData[0].username, '');
            }

            const { data: soundData } = await supabase
                .from('sloppygram_global_settings')
                .select('*')
                .eq('setting_type', 'sound')
                .order('created_at', { ascending: false })
                .limit(1);

            if (soundData && soundData[0]) {
                applyGlobalSetting('sound', soundData[0].setting_value, soundData[0].username, soundData[0].extra_data);
            }
        }

        function subscribeToGlobalSettings() {
            globalSettingsChannel = supabase.channel('sloppygram-global-settings', {
                config: { broadcast: { self: false } }
            });

            globalSettingsChannel.on('broadcast', { event: 'global_setting' }, (payload) => {
                const { setting_type, setting_value, username, extra_data } = payload.payload;
                applyGlobalSetting(setting_type, setting_value, username, extra_data);
            });

            globalSettingsChannel.subscribe();
        }

        window.switchSettingsTab = function(tab) {
            document.querySelectorAll('.settings-tab').forEach(t => t.classList.remove('active'));
            document.querySelectorAll('.settings-panel').forEach(p => p.classList.remove('active'));
            document.querySelector(`.settings-tab[onclick*="'${tab}'"]`).classList.add('active');
            document.getElementById(tab + 'Panel').classList.add('active');
        };

        window.openSettingsModal = async function() {
            document.getElementById('usernameInput').value = profile.username;

            // Show current avatar preview if exists
            pendingAvatarData = profile.avatarUrl || null;
            if (pendingAvatarData) {
                document.getElementById('avatarPreviewImg').src = pendingAvatarData;
                document.getElementById('avatarPreview').style.display = 'block';
                document.getElementById('clearAvatarBtn').style.display = 'block';
            } else {
                document.getElementById('avatarPreview').style.display = 'none';
                document.getElementById('clearAvatarBtn').style.display = 'none';
            }

            // Show current bg preview if exists
            pendingBgData = profile.bgUrl || null;
            if (pendingBgData) {
                document.getElementById('bgPreviewImg').src = pendingBgData;
                document.getElementById('bgPreview').style.display = 'block';
                document.getElementById('clearBgBtn').style.display = 'block';
                document.getElementById('shareBgBtn').style.display = 'block';
                document.getElementById('setGlobalBgBtn').style.display = 'block';
            } else {
                document.getElementById('bgPreview').style.display = 'none';
                document.getElementById('clearBgBtn').style.display = 'none';
                document.getElementById('shareBgBtn').style.display = 'none';
                document.getElementById('setGlobalBgBtn').style.display = 'none';
            }

            setupAvatarGrid();
            setupColorOptions();
            loadSoundSettings();
            updateThemeUI();
            await loadGlobalBackgrounds();
            document.getElementById('settingsModal').classList.add('active');
        };

        window.closeSettingsModal = function() {
            document.getElementById('settingsModal').classList.remove('active');
            pendingAvatarData = null;
            pendingBgData = null;
        };

        window.handleAvatarUpload = function(event) {
            const file = event.target.files[0];
            if (!file) return;

            if (file.size > 500000) {
                alert('Image too large! Max 500KB.');
                return;
            }

            const reader = new FileReader();
            reader.onload = function(e) {
                pendingAvatarData = e.target.result;
                document.getElementById('avatarPreviewImg').src = pendingAvatarData;
                document.getElementById('avatarPreview').style.display = 'block';
                document.getElementById('clearAvatarBtn').style.display = 'block';
            };
            reader.readAsDataURL(file);
        };

        window.clearAvatarUpload = function() {
            pendingAvatarData = null;
            document.getElementById('avatarFileInput').value = '';
            document.getElementById('avatarPreview').style.display = 'none';
            document.getElementById('clearAvatarBtn').style.display = 'none';
        };

        window.handleBgUpload = function(event) {
            const file = event.target.files[0];
            if (!file) return;

            if (file.size > 1000000) {
                alert('Image too large! Max 1MB for backgrounds.');
                return;
            }

            const reader = new FileReader();
            reader.onload = function(e) {
                pendingBgData = e.target.result;
                document.getElementById('bgPreviewImg').src = pendingBgData;
                document.getElementById('bgPreview').style.display = 'block';
                document.getElementById('clearBgBtn').style.display = 'block';
                document.getElementById('shareBgBtn').style.display = 'block';
                document.getElementById('setGlobalBgBtn').style.display = 'block';
            };
            reader.readAsDataURL(file);
        };

        window.clearBgUpload = function() {
            pendingBgData = null;
            document.getElementById('bgFileInput').value = '';
            document.getElementById('bgPreview').style.display = 'none';
            document.getElementById('clearBgBtn').style.display = 'none';
            document.getElementById('shareBgBtn').style.display = 'none';
            document.getElementById('setGlobalBgBtn').style.display = 'none';
        };

        // Global Backgrounds
        async function loadGlobalBackgrounds() {
            const { data } = await supabase
                .from('sloppygram_global_backgrounds')
                .select('*')
                .order('created_at', { ascending: false })
                .limit(20);

            globalBackgrounds = data || [];
            renderGlobalBackgrounds();
        }

        function renderGlobalBackgrounds() {
            const grid = document.getElementById('globalBgGrid');
            grid.innerHTML = globalBackgrounds.map(bg => {
                const safeBgData = sanitizeUrl(bg.image_data);
                return `
                <div class="global-bg-item ${pendingBgData === bg.image_data ? 'selected' : ''}"
                     onclick="selectGlobalBg('${bg.id}')"
                     title="${escapeHtml(bg.name || 'Shared by ' + bg.username)}">
                    <img src="${safeBgData}" alt="${escapeHtml(bg.name || 'Background')}">
                </div>`;
            }).join('') + `
                <div class="global-bg-item global-bg-upload" onclick="document.getElementById('bgFileInput').click()" title="Upload new">+</div>
            `;
        }

        window.selectGlobalBg = function(bgId) {
            const bg = globalBackgrounds.find(b => b.id == bgId);
            if (!bg) return;

            pendingBgData = bg.image_data;
            document.getElementById('bgPreviewImg').src = pendingBgData;
            document.getElementById('bgPreview').style.display = 'block';
            document.getElementById('clearBgBtn').style.display = 'block';
            document.getElementById('shareBgBtn').style.display = 'none'; // Already shared
            document.getElementById('setGlobalBgBtn').style.display = 'block'; // Can still set for everyone

            renderGlobalBackgrounds();
        };

        window.shareBackground = async function() {
            if (!pendingBgData || !currentUser) return;

            const name = prompt('Give your background a name:', 'My Background');
            if (!name) return;

            const { error } = await supabase
                .from('sloppygram_global_backgrounds')
                .insert({
                    image_data: pendingBgData,
                    username: profile.username,
                    name: name,
                    user_id: currentUser.id
                });

            if (error) {
                console.error('Error sharing background:', error);
                alert('Failed to share background');
                return;
            }

            alert('Background shared with everyone!');
            document.getElementById('shareBgBtn').style.display = 'none';
            await loadGlobalBackgrounds();
        };

        // Broadcast background to ALL users in real-time
        window.setGlobalBackground = function() {
            if (!pendingBgData || !realtimeChannel) return;

            realtimeChannel.send({
                type: 'broadcast',
                event: 'global_background',
                payload: {
                    image_data: pendingBgData,
                    username: profile.username
                }
            });

            // Also apply to self (chat container only)
            const msgContainer = document.getElementById('messagesContainer');
            if (msgContainer) {
                msgContainer.style.backgroundImage = `url(${pendingBgData})`;
                msgContainer.style.backgroundSize = 'cover';
                msgContainer.style.backgroundPosition = 'center';
                msgContainer.style.backgroundAttachment = 'fixed';
                msgContainer.style.backgroundRepeat = 'no-repeat';
            }

            addToFeed(profile.username, 'set a new chat background');
        };

        // Message opacity control
        window.setMessageOpacity = function(value) {
            const opacity = value / 100;
            document.documentElement.style.setProperty('--msg-opacity', opacity);
            document.getElementById('opacityValue').textContent = value + '%';
            localStorage.setItem('sloppygram_msg_opacity', value);
        };

        function loadMessageOpacity() {
            const saved = localStorage.getItem('sloppygram_msg_opacity');
            if (saved !== null) {
                const value = parseInt(saved);
                document.documentElement.style.setProperty('--msg-opacity', value / 100);
                const slider = document.getElementById('msgOpacitySlider');
                const display = document.getElementById('opacityValue');
                if (slider) slider.value = value;
                if (display) display.textContent = value + '%';
            }
        }

        // Theme color settings
        let themeSettings = {
            msgColor: '10, 10, 15',
            msgOwnColor: '90, 112, 96',
            accentColor: '#7c9885',
            highlightColor: '#c9a87c',
            panelBg: '#12121a'
        };

        window.selectMsgColor = function(color) {
            themeSettings.msgColor = color;
            document.documentElement.style.setProperty('--msg-color', color);
            document.querySelectorAll('#msgColorGrid .msg-color-option').forEach(opt => opt.classList.remove('selected'));
            document.querySelector(`#msgColorGrid .msg-color-option[onclick*="'${color}'"]`)?.classList.add('selected');
        };

        window.selectMsgOwnColor = function(color) {
            themeSettings.msgOwnColor = color;
            document.documentElement.style.setProperty('--msg-own-color', color);
            document.querySelectorAll('#msgOwnColorGrid .msg-color-option').forEach(opt => opt.classList.remove('selected'));
            document.querySelector(`#msgOwnColorGrid .msg-color-option[onclick*="'${color}'"]`)?.classList.add('selected');
        };

        window.selectAccentColor = function(color) {
            themeSettings.accentColor = color;
            document.documentElement.style.setProperty('--accent', color);
            // Generate lighter and dimmer variants
            const hex = color.replace('#', '');
            const r = parseInt(hex.substr(0, 2), 16);
            const g = parseInt(hex.substr(2, 2), 16);
            const b = parseInt(hex.substr(4, 2), 16);
            const light = `rgb(${Math.min(255, r + 40)}, ${Math.min(255, g + 40)}, ${Math.min(255, b + 40)})`;
            const dim = `rgb(${Math.max(0, r - 30)}, ${Math.max(0, g - 30)}, ${Math.max(0, b - 30)})`;
            document.documentElement.style.setProperty('--accent-light', light);
            document.documentElement.style.setProperty('--accent-dim', dim);
            document.querySelectorAll('#accentColorGrid .msg-color-option').forEach(opt => opt.classList.remove('selected'));
            document.querySelector(`#accentColorGrid .msg-color-option[onclick*="'${color}'"]`)?.classList.add('selected');
        };

        window.selectHighlightColor = function(color) {
            themeSettings.highlightColor = color;
            document.documentElement.style.setProperty('--highlight', color);
            document.querySelectorAll('#highlightColorGrid .msg-color-option').forEach(opt => opt.classList.remove('selected'));
            document.querySelector(`#highlightColorGrid .msg-color-option[onclick*="'${color}'"]`)?.classList.add('selected');
        };

        window.selectPanelBg = function(color) {
            themeSettings.panelBg = color;
            document.documentElement.style.setProperty('--panel-bg', color);
            // Also update dark-bg to be slightly darker than panel-bg
            const hex = color.replace('#', '');
            const r = Math.max(0, parseInt(hex.substr(0, 2), 16) - 8);
            const g = Math.max(0, parseInt(hex.substr(2, 2), 16) - 8);
            const b = Math.max(0, parseInt(hex.substr(4, 2), 16) - 5);
            const darkBg = `rgb(${r}, ${g}, ${b})`;
            document.documentElement.style.setProperty('--dark-bg', darkBg);
            // Also update border color to complement the panel
            const br = Math.min(255, parseInt(hex.substr(0, 2), 16) + 24);
            const bg = Math.min(255, parseInt(hex.substr(2, 2), 16) + 24);
            const bb = Math.min(255, parseInt(hex.substr(4, 2), 16) + 27);
            document.documentElement.style.setProperty('--border-color', `rgb(${br}, ${bg}, ${bb})`);
            document.querySelectorAll('#panelBgGrid .msg-color-option').forEach(opt => opt.classList.remove('selected'));
            document.querySelector(`#panelBgGrid .msg-color-option[onclick*="'${color}'"]`)?.classList.add('selected');
        };

        window.saveThemeSettings = function() {
            localStorage.setItem('sloppygram_theme', JSON.stringify(themeSettings));
            localStorage.setItem('sloppygram_msg_opacity', document.getElementById('msgOpacitySlider').value);
            closeSettingsModal();
        };

        window.resetTheme = function() {
            if (!confirm('Reset all theme settings to default?')) return;
            themeSettings = {
                msgColor: '10, 10, 15',
                msgOwnColor: '90, 112, 96',
                accentColor: '#7c9885',
                highlightColor: '#c9a87c',
                panelBg: '#12121a'
            };
            document.documentElement.style.setProperty('--msg-color', themeSettings.msgColor);
            document.documentElement.style.setProperty('--msg-own-color', themeSettings.msgOwnColor);
            document.documentElement.style.setProperty('--accent', themeSettings.accentColor);
            document.documentElement.style.setProperty('--accent-light', '#a8c4b0');
            document.documentElement.style.setProperty('--accent-dim', '#5a7060');
            document.documentElement.style.setProperty('--highlight', themeSettings.highlightColor);
            document.documentElement.style.setProperty('--panel-bg', themeSettings.panelBg);
            document.documentElement.style.setProperty('--dark-bg', '#0a0a0f');
            document.documentElement.style.setProperty('--border-color', '#2a2a35');
            localStorage.removeItem('sloppygram_theme');
            updateThemeUI();
        };

        function loadThemeSettings() {
            const saved = localStorage.getItem('sloppygram_theme');
            if (saved) {
                themeSettings = JSON.parse(saved);
                document.documentElement.style.setProperty('--msg-color', themeSettings.msgColor);
                document.documentElement.style.setProperty('--msg-own-color', themeSettings.msgOwnColor);
                if (themeSettings.accentColor) {
                    selectAccentColor(themeSettings.accentColor);
                }
                if (themeSettings.highlightColor) {
                    document.documentElement.style.setProperty('--highlight', themeSettings.highlightColor);
                }
                if (themeSettings.panelBg) {
                    // Use selectPanelBg to properly update all related variables
                    selectPanelBg(themeSettings.panelBg);
                }
            }
        }

        function updateThemeUI() {
            // Update color selection UI
            document.querySelectorAll('#msgColorGrid .msg-color-option').forEach(opt => opt.classList.remove('selected'));
            const msgColorOpt = document.querySelector(`#msgColorGrid .msg-color-option[onclick*="'${themeSettings.msgColor}'"]`);
            if (msgColorOpt) msgColorOpt.classList.add('selected');

            document.querySelectorAll('#msgOwnColorGrid .msg-color-option').forEach(opt => opt.classList.remove('selected'));
            const ownColorOpt = document.querySelector(`#msgOwnColorGrid .msg-color-option[onclick*="'${themeSettings.msgOwnColor}'"]`);
            if (ownColorOpt) ownColorOpt.classList.add('selected');

            document.querySelectorAll('#accentColorGrid .msg-color-option').forEach(opt => opt.classList.remove('selected'));
            const accentOpt = document.querySelector(`#accentColorGrid .msg-color-option[onclick*="'${themeSettings.accentColor}'"]`);
            if (accentOpt) accentOpt.classList.add('selected');

            document.querySelectorAll('#highlightColorGrid .msg-color-option').forEach(opt => opt.classList.remove('selected'));
            const highlightOpt = document.querySelector(`#highlightColorGrid .msg-color-option[onclick*="'${themeSettings.highlightColor}'"]`);
            if (highlightOpt) highlightOpt.classList.add('selected');

            document.querySelectorAll('#panelBgGrid .msg-color-option').forEach(opt => opt.classList.remove('selected'));
            const panelOpt = document.querySelector(`#panelBgGrid .msg-color-option[onclick*="'${themeSettings.panelBg}'"]`);
            if (panelOpt) panelOpt.classList.add('selected');
        }

        window.saveProfile = function() {
            const username = document.getElementById('usernameInput').value.trim() || 'Anon' + Math.floor(Math.random() * 9999);
            profile.username = username;
            profile.avatarUrl = pendingAvatarData || '';
            profile.bgUrl = pendingBgData || '';
            localStorage.setItem('sloppygram_profile', JSON.stringify(profile));
            applyCustomBackground();

            // Broadcast background globally if set
            if (profile.bgUrl) {
                broadcastGlobalSetting('background', profile.bgUrl);
            }
            // Broadcast avatar change globally if set
            if (profile.avatarUrl) {
                broadcastGlobalSetting('avatar', profile.avatarUrl);
            }

            closeSettingsModal();
        };

        window.resetProfile = function() {
            if (!confirm('Reset all profile data? This cannot be undone.')) return;
            localStorage.removeItem('sloppygram_profile');
            profile = {
                username: 'Anon' + Math.floor(Math.random() * 9999),
                avatar: AVATARS[Math.floor(Math.random() * AVATARS.length)],
                color: COLORS[Math.floor(Math.random() * COLORS.length)],
                avatarUrl: '',
                bgUrl: ''
            };
            pendingAvatarData = null;
            pendingBgData = null;
            const msgContainer = document.getElementById('messagesContainer');
            if (msgContainer) msgContainer.style.backgroundImage = '';
            closeSettingsModal();
        };

        function applyCustomBackground() {
            const msgContainer = document.getElementById('messagesContainer');
            if (!msgContainer) return;

            if (profile.bgUrl) {
                msgContainer.style.backgroundImage = `url(${profile.bgUrl})`;
                msgContainer.style.backgroundSize = 'cover';
                msgContainer.style.backgroundPosition = 'center';
                msgContainer.style.backgroundAttachment = 'fixed';
                msgContainer.style.backgroundRepeat = 'no-repeat';
            } else {
                msgContainer.style.backgroundImage = '';
            }
        }

        // Drawing modal
        window.openDrawingModal = function() {
            clearCanvas();
            document.getElementById('drawingModal').classList.add('active');

            // Add keyboard shortcuts for undo/redo when modal is open
            document.addEventListener('keydown', handleDrawingKeyboard);
        };

        window.closeDrawingModal = function() {
            document.getElementById('drawingModal').classList.remove('active');
            document.removeEventListener('keydown', handleDrawingKeyboard);
        };

        function handleDrawingKeyboard(e) {
            // Only handle if drawing modal is open
            if (!document.getElementById('drawingModal').classList.contains('active')) return;

            if (e.ctrlKey || e.metaKey) {
                if (e.key === 'z' && !e.shiftKey) {
                    e.preventDefault();
                    undoCanvas();
                } else if (e.key === 'y' || (e.key === 'z' && e.shiftKey)) {
                    e.preventDefault();
                    redoCanvas();
                }
            }
        }

        // === POSTS FUNCTIONALITY ===

        window.switchView = function(view) {
            currentView = view;
            document.querySelectorAll('.view-tab').forEach(tab => {
                tab.classList.toggle('active', tab.dataset.view === view);
            });
            document.getElementById('messagesContainer').classList.toggle('hidden', view !== 'chat');
            document.getElementById('postsContainer').classList.toggle('active', view === 'posts');
            document.getElementById('doodlesContainer').classList.toggle('active', view === 'doodles');
            document.getElementById('manifestoContainer').classList.toggle('active', view === 'manifesto');
            document.getElementById('collabContainer').classList.toggle('active', view === 'collab');
            document.getElementById('chatInputArea').style.display = view === 'chat' ? 'block' : 'none';
            document.getElementById('createPostBtn').classList.toggle('visible', view === 'posts');

            if (view === 'posts') {
                loadPosts();
            }
            if (view === 'doodles') {
                loadDoodleLeaderboard();
            }
            if (view === 'manifesto') {
                loadManifestos();
            }
            if (view === 'collab') {
                initCollabCanvas();
            }
        };

        async function loadPosts() {
            // Reset pagination state for fresh load
            postsPage = 0;
            postsHasMore = true;
            postsLoading = false;

            const { data, error } = await supabase
                .from('sloppygram_posts')
                .select('*')
                .order('created_at', { ascending: false })
                .range(0, PAGE_SIZE - 1);

            if (error) {
                console.error('Error loading posts:', error);
                return;
            }

            posts = data || [];
            const postIds = posts.map(p => p.id);

            // Batch all related queries in parallel to solve N+1 problem
            const [votesResult, commentsResult, reactionsResult, tagsResult, threadsResult] = await Promise.all([
                supabase.from('sloppygram_post_likes').select('post_id, username, vote_type'),
                postIds.length > 0
                    ? supabase.from('sloppygram_post_comments').select('*').in('post_id', postIds).order('created_at', { ascending: true })
                    : { data: [] },
                postIds.length > 0
                    ? supabase.from('sloppygram_post_reactions').select('*').in('post_id', postIds)
                    : { data: [] },
                postIds.length > 0
                    ? supabase.from('sloppygram_post_tags').select('*').in('post_id', postIds)
                    : { data: [] },
                postIds.length > 0
                    ? supabase.from('sloppygram_comment_threads').select('*').eq('comment_type', 'post').in('post_id', postIds)
                    : { data: [] }
            ]);

            // Process votes
            postVotes = {};
            myPostVotes = {};
            (votesResult.data || []).forEach(vote => {
                postVotes[vote.post_id] = (postVotes[vote.post_id] || 0) + (vote.vote_type || 1);
                if (vote.username === profile.username) {
                    myPostVotes[vote.post_id] = vote.vote_type || 1;
                }
            });

            // Update post.likes_count with net vote scores
            posts.forEach(p => {
                p.likes_count = postVotes[p.id] || 0;
            });

            // Process comments
            postComments = {};
            (commentsResult.data || []).forEach(comment => {
                if (!postComments[comment.post_id]) postComments[comment.post_id] = [];
                postComments[comment.post_id].push(comment);
            });

            // Process reactions
            postReactions = {};
            myReactions = {};
            (reactionsResult.data || []).forEach(r => {
                if (!postReactions[r.post_id]) postReactions[r.post_id] = {};
                postReactions[r.post_id][r.emoji] = (postReactions[r.post_id][r.emoji] || 0) + 1;
                if (r.username === profile.username) {
                    if (!myReactions[r.post_id]) myReactions[r.post_id] = new Set();
                    myReactions[r.post_id].add(r.emoji);
                }
            });

            // Process tags
            postTags = {};
            (tagsResult.data || []).forEach(t => {
                if (!postTags[t.post_id]) postTags[t.post_id] = [];
                postTags[t.post_id].push({ tag: t.tag, parent_tag: t.parent_tag });
            });

            // Process comment threads
            (threadsResult.data || []).forEach(t => {
                commentThreads[t.comment_id] = t.parent_comment_id;
            });

            // Update pagination state
            postsHasMore = posts.length === PAGE_SIZE;
            postsPage = 1;

            renderPosts();
        }

        function renderPosts() {
            const container = document.getElementById('postsContainer');
            const emptyState = document.getElementById('postsEmptyState');

            if (posts.length === 0) {
                emptyState.style.display = 'block';
                container.innerHTML = '';
                container.appendChild(emptyState);
                return;
            }

            emptyState.style.display = 'none';
            container.innerHTML = posts.map(post => renderPostCard(post)).join('');

            // Trigger lazy loading for new images
            lazyLoadNewImages();
        }

        // Render threaded comments with replies
        function renderThreadedComments(comments, postId, type = 'post') {
            // Build a map of comment threads
            const threads = {}; // parentId -> [children]
            const rootComments = [];

            comments.forEach(c => {
                const parentId = commentThreads[c.id];
                if (parentId) {
                    if (!threads[parentId]) threads[parentId] = [];
                    threads[parentId].push(c);
                } else {
                    rootComments.push(c);
                }
            });

            function renderComment(c, depth = 0) {
                const time = c.created_at ? new Date(c.created_at).toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'}) : '';
                const replies = threads[c.id] || [];
                const isNested = depth > 0;
                const isOwnComment = c.username === profile.username;
                const myVote = myCommentVotes[c.id] || 0;
                const voteScore = commentVotes[c.id] || 0;
                const scoreClass = voteScore > 0 ? 'positive' : voteScore < 0 ? 'negative' : '';

                return `
                    <div class="comment ${isNested ? 'comment-thread' : ''}" data-comment-id="${c.id}" data-depth="${depth}">
                        <span class="comment-avatar">${c.avatar || 'ðŸ‘¤'}</span>
                        <div class="comment-content">
                            <span class="comment-username username-clickable" onclick="showProfileCard('${escapeHtml(c.username)}', event)">${escapeHtml(c.username)}</span>
                            <span class="comment-time">${time}</span>
                            <div class="comment-text">${escapeHtml(c.content)}</div>
                            <div class="comment-actions">
                                <button class="comment-reply-btn" onclick="startReply(${postId}, ${c.id}, '${escapeHtml(c.username)}', '${type}')">â†© reply</button>
                                <span class="comment-vote-controls" data-comment-id="${c.id}">
                                    <button class="comment-vote-btn upvote ${myVote === 1 ? 'active' : ''} ${isOwnComment ? 'disabled' : ''}"
                                        onclick="${isOwnComment ? '' : `voteComment('${c.id}', 1, '${escapeHtml(c.username)}')`}"
                                        title="${isOwnComment ? 'Cannot vote on own comment' : 'Upvote'}">â–²</button>
                                    <span class="comment-vote-score ${scoreClass}">${voteScore}</span>
                                    <button class="comment-vote-btn downvote ${myVote === -1 ? 'active' : ''} ${isOwnComment ? 'disabled' : ''}"
                                        onclick="${isOwnComment ? '' : `voteComment('${c.id}', -1, '${escapeHtml(c.username)}')`}"
                                        title="${isOwnComment ? 'Cannot vote on own comment' : 'Downvote'}">â–¼</button>
                                </span>
                            </div>
                        </div>
                        ${replies.length > 0 ? `<div class="comment-replies">${replies.map(r => renderComment(r, depth + 1)).join('')}</div>` : ''}
                    </div>
                `;
            }

            return rootComments.map(c => renderComment(c, 0)).join('');
        }

        function renderPostCard(post) {
            const time = new Date(post.created_at).toLocaleString();
            const myVote = myPostVotes[post.id] || 0;
            const comments = postComments[post.id] || [];
            const voteScore = postVotes[post.id] || 0;
            const reactions = postReactions[post.id] || {};
            const myPostReactions = myReactions[post.id] || new Set();
            const isOwnPost = post.user_id === currentUser?.id || post.username === profile.username;
            const scoreClass = voteScore > 0 ? 'positive' : voteScore < 0 ? 'negative' : 'neutral';

            const safeAvatarUrl = sanitizeUrl(post.avatar_url);
            const avatarContent = safeAvatarUrl
                ? `<img src="${safeAvatarUrl}" style="width:100%;height:100%;object-fit:cover;border-radius:50%;">`
                : (post.avatar || 'ðŸ‘¤');

            const safeImageUrl = sanitizeUrl(post.image_url);
            const safeImageData = sanitizeUrl(post.image_data);
            const imageHtml = safeImageUrl
                ? `<img class="post-image lazy-image" loading="lazy" data-src="${safeImageUrl}" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.style.display='none'">`
                : (safeImageData ? `<img class="post-image" loading="lazy" src="${safeImageData}">` : '');

            const commentsHtml = renderThreadedComments(comments, post.id, 'post');

            // Reply indicator if replying to a comment on this post
            const replyIndicatorHtml = (replyingTo && replyingTo.postId === post.id && replyingTo.type === 'post')
                ? `<div class="reply-indicator">
                    <span>â†© Replying to <strong>${escapeHtml(replyingTo.username)}</strong></span>
                    <button class="cancel-reply" onclick="cancelReply()">âœ•</button>
                </div>`
                : '';

            // Build reactions HTML
            const reactionsHtml = Object.entries(reactions)
                .sort((a, b) => b[1] - a[1])
                .map(([emoji, count]) => {
                    const isActive = myPostReactions.has(emoji);
                    return `<button class="reaction-btn ${isActive ? 'active' : ''}" onclick="toggleReaction(${post.id}, '${emoji}')">
                        ${emoji} <span class="reaction-count">${count}</span>
                    </button>`;
                }).join('');

            const reactionPickerHtml = REACTION_EMOJIS.map(emoji =>
                `<button onclick="toggleReaction(${post.id}, '${emoji}')">${emoji}</button>`
            ).join('');

            // Build tags HTML
            const tags = postTags[post.id] || [];
            const tagsHtml = tags.length > 0 ? `
                <div class="post-tags">
                    ${tags.map(t => {
                        const isNested = t.parent_tag != null;
                        const displayTag = isNested ? `${t.parent_tag}/${t.tag}` : t.tag;
                        return `<span class="tag ${isNested ? 'nested' : ''}" onclick="filterByTag('${escapeHtml(displayTag)}')">#${escapeHtml(displayTag)}</span>`;
                    }).join('')}
                </div>
            ` : '';

            return `
                <div class="post-card" data-post-id="${post.id}">
                    <div class="post-header">
                        <div class="post-avatar">${avatarContent}</div>
                        <span class="post-username username-clickable" onclick="showProfileCard('${escapeHtml(post.username || 'Anonymous')}', event)">${escapeHtml(post.username || 'Anonymous')}</span>
                        <span class="post-time">${time}</span>
                        ${isOwnPost ? `<button class="post-delete-btn" onclick="deletePost(${post.id})" title="Delete post">delete</button>` : ''}
                    </div>
                    ${imageHtml}
                    ${post.caption ? `<div class="post-caption">${escapeHtml(post.caption)}</div>` : ''}
                    <div class="post-actions">
                        <div class="vote-controls" data-post-id="${post.id}">
                            <button class="vote-btn upvote ${myVote === 1 ? 'active' : ''} ${isOwnPost ? 'disabled' : ''}"
                                onclick="${isOwnPost ? '' : `votePost(${post.id}, 1)`}"
                                title="${isOwnPost ? 'Cannot vote on own post' : 'Upvote'}">â–²</button>
                            <span class="vote-score ${scoreClass}" id="post-score-${post.id}">${voteScore}</span>
                            <button class="vote-btn downvote ${myVote === -1 ? 'active' : ''} ${isOwnPost ? 'disabled' : ''}"
                                onclick="${isOwnPost ? '' : `votePost(${post.id}, -1)`}"
                                title="${isOwnPost ? 'Cannot vote on own post' : 'Downvote'}">â–¼</button>
                        </div>
                        <button class="post-action-btn" onclick="focusComment(${post.id})">
                            ðŸ’¬ ${comments.length}
                        </button>
                    </div>
                    <div class="post-reactions" id="reactions-${post.id}">
                        ${reactionsHtml}
                        <div style="position:relative;display:inline-block;">
                            <button class="add-reaction-btn" onclick="toggleReactionPicker(${post.id})">+ ðŸ˜€</button>
                            <div class="reaction-picker" id="picker-${post.id}">
                                ${reactionPickerHtml}
                            </div>
                        </div>
                    </div>
                    ${tagsHtml}
                    <div class="post-comments" id="comments-${post.id}">
                        ${commentsHtml}
                    </div>
                    ${replyIndicatorHtml}
                    <div class="comment-input-row">
                        <input class="comment-input" id="comment-input-${post.id}" placeholder="${replyingTo && replyingTo.postId === post.id ? 'Write a reply...' : 'Add a comment...'}" onkeydown="if(event.key==='Enter')addComment(${post.id})">
                        <button class="comment-send" onclick="addComment(${post.id})">POST</button>
                    </div>
                </div>
            `;
        }

        window.deletePost = async function(postId) {
            if (!currentUser) return;
            if (!confirm('Delete this post? This cannot be undone.')) return;

            const { error } = await supabase
                .from('sloppygram_posts')
                .delete()
                .eq('id', postId)
                .eq('user_id', currentUser.id);

            if (error) {
                console.error('Error deleting post:', error);
                alert('Could not delete post');
                return;
            }

            // Remove from local state
            posts = posts.filter(p => p.id !== postId);
            delete postComments[postId];
            delete postReactions[postId];
            delete postLikes[postId];
            delete postTags[postId];
            renderPosts();
        };

        window.votePost = async function(postId, voteType) {
            if (!currentUser) return;

            // Rate limiting check
            const rateCheck = checkRateLimit('vote');
            if (!rateCheck.allowed) {
                showToast(rateCheck.message, 'warning');
                return;
            }
            recordAction('vote');

            // Check if own post
            const post = posts.find(p => p.id === postId);
            if (post && (post.user_id === currentUser.id || post.username === profile.username)) return;

            const currentVote = myPostVotes[postId] || 0;

            if (currentVote === voteType) {
                // Remove vote if clicking same button
                await supabase
                    .from('sloppygram_post_likes')
                    .delete()
                    .eq('post_id', postId)
                    .eq('user_id', currentUser.id);

                myPostVotes[postId] = 0;
                postVotes[postId] = (postVotes[postId] || 0) - voteType;
            } else {
                // Remove existing vote first
                if (currentVote !== 0) {
                    await supabase
                        .from('sloppygram_post_likes')
                        .delete()
                        .eq('post_id', postId)
                        .eq('user_id', currentUser.id);
                    postVotes[postId] = (postVotes[postId] || 0) - currentVote;
                }

                // Add new vote
                await supabase
                    .from('sloppygram_post_likes')
                    .insert({
                        post_id: postId,
                        username: profile.username,
                        vote_type: voteType,
                        user_id: currentUser.id
                    });

                myPostVotes[postId] = voteType;
                postVotes[postId] = (postVotes[postId] || 0) + voteType;
            }

            // Update post.likes_count
            if (post) post.likes_count = postVotes[postId] || 0;

            // Log AI event for post vote
            logAiEvent('vote_cast', 'post', postId, {
                vote_type: myPostVotes[postId] || 0,
                net_score: postVotes[postId] || 0
            });

            // Update UI
            updatePostVoteUI(postId);
        };

        function updatePostVoteUI(postId) {
            const score = postVotes[postId] || 0;
            const myVote = myPostVotes[postId] || 0;
            const scoreClass = score > 0 ? 'positive' : score < 0 ? 'negative' : 'neutral';

            document.querySelectorAll(`[data-post-id="${postId}"]`).forEach(container => {
                const scoreEl = container.querySelector('.vote-score');
                const upBtn = container.querySelector('.vote-btn.upvote');
                const downBtn = container.querySelector('.vote-btn.downvote');

                if (scoreEl) {
                    scoreEl.textContent = score;
                    scoreEl.className = `vote-score ${scoreClass}`;
                }
                if (upBtn) upBtn.classList.toggle('active', myVote === 1);
                if (downBtn) downBtn.classList.toggle('active', myVote === -1);
            });
        }

        window.focusComment = function(postId) {
            document.getElementById(`comment-input-${postId}`).focus();
        };

        // Start replying to a specific comment
        window.startReply = function(postId, commentId, username, type = 'post') {
            replyingTo = { postId, commentId, username, type };
            if (type === 'post') {
                renderPosts();
                setTimeout(() => {
                    const input = document.getElementById(`comment-input-${postId}`);
                    if (input) input.focus();
                }, 50);
            } else {
                renderManifestos();
                setTimeout(() => {
                    const input = document.getElementById(`manifesto-comment-input-${postId}`);
                    if (input) input.focus();
                }, 50);
            }
        };

        // Cancel replying
        window.cancelReply = function() {
            const wasType = replyingTo?.type;
            replyingTo = null;
            if (wasType === 'post') {
                renderPosts();
            } else if (wasType === 'manifesto') {
                renderManifestos();
            }
        };

        window.addComment = async function(postId) {
            const input = document.getElementById(`comment-input-${postId}`);
            const content = input.value.trim();
            if (!content || !currentUser) return;

            // Rate limiting check
            const rateCheck = checkRateLimit('comment');
            if (!rateCheck.allowed) {
                showToast(rateCheck.message, 'warning');
                return;
            }
            recordAction('comment');

            const comment = {
                post_id: postId,
                username: profile.username,
                avatar: profile.avatar,
                content: content,
                user_id: currentUser.id
            };

            const { data, error } = await supabase
                .from('sloppygram_post_comments')
                .insert(comment)
                .select()
                .single();

            if (error) {
                console.error('Error adding comment:', error);
                return;
            }

            // If this is a reply, save the thread relationship
            if (replyingTo && replyingTo.postId === postId && replyingTo.type === 'post' && data) {
                await supabase
                    .from('sloppygram_comment_threads')
                    .insert({
                        comment_id: data.id,
                        parent_comment_id: replyingTo.commentId,
                        comment_type: 'post',
                        post_id: postId,
                        user_id: currentUser.id
                    });
                commentThreads[data.id] = replyingTo.commentId;
            }

            if (!postComments[postId]) postComments[postId] = [];
            postComments[postId].push({ ...comment, id: data?.id, created_at: new Date().toISOString() });

            input.value = '';
            replyingTo = null;
            renderPosts();
        };

        // Emoji Reactions
        window.toggleReactionPicker = function(postId) {
            const picker = document.getElementById(`picker-${postId}`);
            // Close all other pickers
            document.querySelectorAll('.reaction-picker.active').forEach(p => {
                if (p.id !== `picker-${postId}`) p.classList.remove('active');
            });
            picker.classList.toggle('active');
        };

        window.toggleReaction = async function(postId, emoji) {
            if (!currentUser) return;

            // Close picker
            const picker = document.getElementById(`picker-${postId}`);
            if (picker) picker.classList.remove('active');

            const hasReaction = myReactions[postId]?.has(emoji);

            if (hasReaction) {
                // Remove reaction
                await supabase
                    .from('sloppygram_post_reactions')
                    .delete()
                    .eq('post_id', postId)
                    .eq('emoji', emoji)
                    .eq('user_id', currentUser.id);

                myReactions[postId]?.delete(emoji);
                if (postReactions[postId]?.[emoji]) {
                    postReactions[postId][emoji]--;
                    if (postReactions[postId][emoji] <= 0) delete postReactions[postId][emoji];
                }
            } else {
                // Add reaction
                await supabase
                    .from('sloppygram_post_reactions')
                    .insert({
                        post_id: postId,
                        emoji: emoji,
                        username: profile.username,
                        user_id: currentUser.id
                    });

                if (!myReactions[postId]) myReactions[postId] = new Set();
                myReactions[postId].add(emoji);
                if (!postReactions[postId]) postReactions[postId] = {};
                postReactions[postId][emoji] = (postReactions[postId][emoji] || 0) + 1;
            }

            renderPosts();
        };

        // Close reaction pickers when clicking outside
        document.addEventListener('click', (e) => {
            if (!e.target.closest('.add-reaction-btn') && !e.target.closest('.reaction-picker')) {
                document.querySelectorAll('.reaction-picker.active').forEach(p => p.classList.remove('active'));
            }
        });

        // Post Modal
        window.openPostModal = function() {
            postImageData = null;
            document.getElementById('postImageUrl').value = '';
            document.getElementById('postCaption').value = '';
            document.getElementById('postFileInput').value = '';
            document.getElementById('postPreview').innerHTML = '<span>No image selected</span>';
            document.getElementById('postPreview').classList.remove('has-image');
            document.getElementById('postModal').classList.add('active');
        };

        window.closePostModal = function() {
            document.getElementById('postModal').classList.remove('active');
        };

        window.previewPostImage = function() {
            const url = document.getElementById('postImageUrl').value.trim();
            const preview = document.getElementById('postPreview');
            const safeUrl = sanitizeUrl(url);

            if (safeUrl) {
                preview.innerHTML = `<img src="${safeUrl}" onerror="this.parentElement.innerHTML='<span>Failed to load image</span>'">`;
                preview.classList.add('has-image');
                postImageData = null;
            } else if (!postImageData) {
                preview.innerHTML = '<span>No image selected</span>';
                preview.classList.remove('has-image');
            }
        };

        window.handlePostFileSelect = function(event) {
            const file = event.target.files[0];
            if (!file) return;

            if (file.size > 500000) {
                alert('Image too large! Max 500KB');
                event.target.value = '';
                return;
            }

            const reader = new FileReader();
            reader.onload = function(e) {
                postImageData = e.target.result;
                const preview = document.getElementById('postPreview');
                preview.innerHTML = `<img src="${postImageData}">`;
                preview.classList.add('has-image');
                document.getElementById('postImageUrl').value = '';
            };
            reader.readAsDataURL(file);
        };

        window.submitPost = async function() {
            const imageUrl = document.getElementById('postImageUrl').value.trim();
            const caption = document.getElementById('postCaption').value.trim();

            if (!imageUrl && !postImageData && !caption) {
                showToast('Add an image or caption!', 'warning');
                return;
            }

            // Rate limiting check
            const rateCheck = checkRateLimit('post');
            if (!rateCheck.allowed) {
                showToast(rateCheck.message, 'warning');
                return;
            }
            recordAction('post');

            // Upload local image to storage instead of saving base64
            let finalImageUrl = imageUrl || null;
            let finalImageData = null;

            if (postImageData && !imageUrl) {
                const blob = dataURLtoBlob(postImageData);
                const storageUrl = await uploadToStorage(blob, 'posts');
                if (storageUrl) {
                    finalImageUrl = storageUrl;
                } else {
                    // Fallback to base64 if storage fails
                    finalImageData = postImageData;
                }
            }

            const post = {
                username: profile.username,
                avatar: profile.avatar,
                avatar_url: profile.avatarUrl || null,
                caption: caption || null,
                image_url: finalImageUrl,
                image_data: finalImageData,
                likes_count: 0,
                user_id: currentUser.id
            };

            const { data: insertedPost, error } = await supabase
                .from('sloppygram_posts')
                .insert(post)
                .select()
                .single();

            if (error) {
                console.error('Error creating post:', error);
                alert('Failed to create post: ' + error.message);
                return;
            }

            if (!insertedPost) {
                console.error('Post insert returned no data');
                alert('Post created but could not retrieve ID for tags');
            }

            // Save tags if any
            if (pendingTags.length > 0 && insertedPost) {
                const tagInserts = pendingTags.map(t => ({
                    post_id: insertedPost.id,
                    tag: t.tag,
                    parent_tag: t.parent_tag || null,
                    user_id: currentUser.id
                }));
                const { error: tagError } = await supabase.from('sloppygram_post_tags').insert(tagInserts);
                if (tagError) {
                    console.error('Error saving tags:', tagError);
                }
            }

            // Log AI event for new post
            if (insertedPost) {
                logAiEvent('post_created', 'post', insertedPost.id, {
                    has_image: !!(finalImageUrl || finalImageData),
                    has_caption: !!caption,
                    tag_count: pendingTags.length
                });
            }

            closePostModal();
            addToFeed(profile.username, 'created a new post');

            // Clear any active tag filter so new post is visible
            activeTagFilter = null;
            document.getElementById('tagFilterBar').classList.remove('active');

            loadPosts();
        };

        // === TAG HANDLING FUNCTIONALITY ===

        window.handleTagInput = function(event) {
            if (event.key === 'Enter') {
                event.preventDefault();
                const input = document.getElementById('tagInput');
                const value = input.value.trim();
                if (!value) return;

                // Parse nested tag (e.g., "meme/cursed" -> parent_tag: "meme", tag: "cursed")
                let tag, parent_tag = null;
                if (value.includes('/')) {
                    const parts = value.split('/');
                    parent_tag = parts[0].trim();
                    tag = parts.slice(1).join('/').trim();
                } else {
                    tag = value;
                }

                // Don't add duplicates
                const exists = pendingTags.some(t => t.tag === tag && t.parent_tag === parent_tag);
                if (!exists) {
                    pendingTags.push({ tag, parent_tag });
                    renderPendingTags();
                }

                input.value = '';
            }
        };

        function renderPendingTags() {
            const container = document.getElementById('tagInputContainer');
            const input = document.getElementById('tagInput');

            // Remove existing tag chips
            container.querySelectorAll('.tag-chip').forEach(el => el.remove());

            // Add tag chips
            pendingTags.forEach((t, idx) => {
                const displayTag = t.parent_tag ? `${t.parent_tag}/${t.tag}` : t.tag;
                const chip = document.createElement('span');
                chip.className = `tag-chip ${t.parent_tag ? 'nested' : ''}`;
                chip.innerHTML = `#${escapeHtml(displayTag)} <button onclick="removePendingTag(${idx})">Ã—</button>`;
                container.insertBefore(chip, input);
            });
        }

        window.removePendingTag = function(idx) {
            pendingTags.splice(idx, 1);
            renderPendingTags();
        };

        window.filterByTag = function(tagStr) {
            activeTagFilter = tagStr;
            document.getElementById('tagFilterBar').classList.add('active');
            document.getElementById('activeFilterTag').textContent = '#' + tagStr;

            // Filter posts by tag
            renderFilteredPosts();
        };

        window.clearTagFilter = function() {
            activeTagFilter = null;
            document.getElementById('tagFilterBar').classList.remove('active');
            renderPosts();
        };

        function renderFilteredPosts() {
            if (!activeTagFilter) {
                renderPosts();
                return;
            }

            const container = document.getElementById('postsContainer');
            const emptyState = document.getElementById('postsEmptyState');

            // Filter posts that have the matching tag
            const filteredPosts = posts.filter(post => {
                const tags = postTags[post.id] || [];
                return tags.some(t => {
                    const fullTag = t.parent_tag ? `${t.parent_tag}/${t.tag}` : t.tag;
                    return fullTag === activeTagFilter ||
                           t.tag === activeTagFilter ||
                           t.parent_tag === activeTagFilter;
                });
            });

            if (filteredPosts.length === 0) {
                emptyState.style.display = 'block';
                emptyState.innerHTML = `<p>No posts with tag #${escapeHtml(activeTagFilter)}</p>`;
                container.innerHTML = '';
                container.appendChild(emptyState);
                return;
            }

            emptyState.style.display = 'none';
            container.innerHTML = filteredPosts.map(post => renderPostCard(post)).join('');
        }

        // Reset pending tags when opening post modal
        const originalOpenPostModal = window.openPostModal;
        window.openPostModal = function() {
            pendingTags = [];
            renderPendingTags();
            if (originalOpenPostModal) originalOpenPostModal();
            else document.getElementById('postModal').classList.add('active');
        };

        // Load and display trending tags
        async function loadTrendingTags() {
            const { data: tagsData } = await supabase
                .from('sloppygram_post_tags')
                .select('tag, parent_tag');

            if (!tagsData || tagsData.length === 0) {
                document.getElementById('trendingTagsList').innerHTML = `
                    <div style="font-size:0.85rem;color:var(--text-dim)">No tags yet</div>
                `;
                return;
            }

            // Count tag occurrences
            const tagCounts = {};
            tagsData.forEach(t => {
                const fullTag = t.parent_tag ? `${t.parent_tag}/${t.tag}` : t.tag;
                tagCounts[fullTag] = (tagCounts[fullTag] || 0) + 1;
            });

            // Sort by count and take top 10
            const topTags = Object.entries(tagCounts)
                .sort((a, b) => b[1] - a[1])
                .slice(0, 10);

            const container = document.getElementById('trendingTagsList');
            container.innerHTML = topTags.map(([tag, count], idx) => {
                const isNested = tag.includes('/');
                const rankClass = idx === 0 ? 'hot' : idx < 3 ? 'warm' : '';
                return `
                    <div class="trending-tag ${rankClass}" onclick="filterByTag('${escapeHtml(tag)}')">
                        <span class="tag ${isNested ? 'nested' : ''}">#${escapeHtml(tag)}</span>
                        <span class="tag-count">${count}</span>
                    </div>
                `;
            }).join('');
        }

        // Call loadTrendingTags when switching to posts view
        const originalSwitchView = switchView;
        switchView = function(view) {
            originalSwitchView(view);
            if (view === 'posts') {
                loadTrendingTags();
            }
        };

        // === MANIFESTO FUNCTIONALITY ===

        let manifestos = [];
        let manifestoVotes = {}; // { manifestoId: count }
        let myManifestoVotes = {}; // { manifestoId: true }
        let manifestoReactions = {}; // { manifestoId: { emoji: count } }
        let myManifestoReactions = {}; // { manifestoId: Set of emojis }
        let manifestoComments = {}; // { manifestoId: [comments] }
        let manifestoTags = {}; // { manifestoId: [tags] }
        let pendingManifestoTags = []; // tags being added to new manifesto

        window.openManifestoModal = function() {
            document.getElementById('manifestoModal').classList.add('active');
            document.getElementById('manifestoTitle').value = '';
            document.getElementById('manifestoContent').value = '';
            document.getElementById('manifestoCharCount').textContent = '0';
            pendingManifestoTags = [];
            renderPendingManifestoTags();
        };

        window.closeManifestoModal = function() {
            document.getElementById('manifestoModal').classList.remove('active');
        };

        // Character count for manifesto content
        document.addEventListener('DOMContentLoaded', () => {
            const content = document.getElementById('manifestoContent');
            if (content) {
                content.addEventListener('input', () => {
                    document.getElementById('manifestoCharCount').textContent = content.value.length;
                });
            }
        });

        // Manifesto tag input handling
        window.handleManifestoTagInput = function(event) {
            if (event.key === 'Enter') {
                event.preventDefault();
                const input = document.getElementById('manifestoTagInput');
                const value = input.value.trim();
                if (!value) return;

                let tag, parent_tag = null;
                if (value.includes('/')) {
                    const parts = value.split('/');
                    parent_tag = parts[0].trim();
                    tag = parts.slice(1).join('/').trim();
                } else {
                    tag = value;
                }

                const exists = pendingManifestoTags.some(t => t.tag === tag && t.parent_tag === parent_tag);
                if (!exists) {
                    pendingManifestoTags.push({ tag, parent_tag });
                    renderPendingManifestoTags();
                }
                input.value = '';
            }
        };

        function renderPendingManifestoTags() {
            const container = document.getElementById('manifestoTagInputContainer');
            const input = document.getElementById('manifestoTagInput');
            container.querySelectorAll('.tag-chip').forEach(el => el.remove());

            pendingManifestoTags.forEach((t, idx) => {
                const displayTag = t.parent_tag ? `${t.parent_tag}/${t.tag}` : t.tag;
                const chip = document.createElement('span');
                chip.className = `tag-chip ${t.parent_tag ? 'nested' : ''}`;
                chip.innerHTML = `#${escapeHtml(displayTag)} <button onclick="removeManifestoTag(${idx})">Ã—</button>`;
                container.insertBefore(chip, input);
            });
        }

        window.removeManifestoTag = function(idx) {
            pendingManifestoTags.splice(idx, 1);
            renderPendingManifestoTags();
        };

        window.submitManifesto = async function() {
            const title = document.getElementById('manifestoTitle').value.trim();
            const content = document.getElementById('manifestoContent').value.trim();

            if (!title || !content) {
                alert('Please fill in both title and content!');
                return;
            }

            const manifesto = {
                title,
                content,
                username: profile.username,
                avatar: profile.avatar,
                upvotes: 0,
                user_id: currentUser.id
            };

            const { data: insertedManifesto, error } = await supabase
                .from('sloppygram_manifestos')
                .insert(manifesto)
                .select()
                .single();

            if (error) {
                console.error('Error creating manifesto:', error);
                alert('Failed to create manifesto: ' + error.message);
                return;
            }

            // Save tags if any
            if (pendingManifestoTags.length > 0 && insertedManifesto) {
                const tagInserts = pendingManifestoTags.map(t => ({
                    manifesto_id: insertedManifesto.id,
                    tag: t.tag,
                    parent_tag: t.parent_tag || null,
                    user_id: currentUser.id
                }));
                await supabase.from('sloppygram_manifesto_tags').insert(tagInserts);
            }

            closeManifestoModal();
            addToFeed(profile.username, 'declared a new manifesto');
            loadManifestos();
        };

        async function loadManifestos() {
            const { data, error } = await supabase
                .from('sloppygram_manifestos')
                .select('*')
                .order('created_at', { ascending: false })
                .limit(50);

            if (error) {
                console.error('Error loading manifestos:', error);
                return;
            }

            manifestos = data || [];
            const manifestoIds = manifestos.map(m => m.id);

            // Batch all related queries in parallel to solve N+1 problem
            const [votesResult, reactionsResult, commentsResult, tagsResult, threadsResult] = await Promise.all([
                manifestoIds.length > 0
                    ? supabase.from('sloppygram_manifesto_votes').select('*').in('manifesto_id', manifestoIds)
                    : { data: [] },
                manifestoIds.length > 0
                    ? supabase.from('sloppygram_manifesto_reactions').select('*').in('manifesto_id', manifestoIds)
                    : { data: [] },
                manifestoIds.length > 0
                    ? supabase.from('sloppygram_manifesto_comments').select('*').in('manifesto_id', manifestoIds).order('created_at', { ascending: true })
                    : { data: [] },
                manifestoIds.length > 0
                    ? supabase.from('sloppygram_manifesto_tags').select('*').in('manifesto_id', manifestoIds)
                    : { data: [] },
                manifestoIds.length > 0
                    ? supabase.from('sloppygram_comment_threads').select('*').eq('comment_type', 'manifesto').in('post_id', manifestoIds)
                    : { data: [] }
            ]);

            // Process votes
            manifestoVotes = {};
            myManifestoVotes = {};
            (votesResult.data || []).forEach(v => {
                manifestoVotes[v.manifesto_id] = (manifestoVotes[v.manifesto_id] || 0) + 1;
                if (v.username === profile.username) {
                    myManifestoVotes[v.manifesto_id] = true;
                }
            });

            // Process reactions
            manifestoReactions = {};
            myManifestoReactions = {};
            (reactionsResult.data || []).forEach(r => {
                if (!manifestoReactions[r.manifesto_id]) manifestoReactions[r.manifesto_id] = {};
                manifestoReactions[r.manifesto_id][r.emoji] = (manifestoReactions[r.manifesto_id][r.emoji] || 0) + 1;
                if (r.username === profile.username) {
                    if (!myManifestoReactions[r.manifesto_id]) myManifestoReactions[r.manifesto_id] = new Set();
                    myManifestoReactions[r.manifesto_id].add(r.emoji);
                }
            });

            // Process comments
            manifestoComments = {};
            (commentsResult.data || []).forEach(c => {
                if (!manifestoComments[c.manifesto_id]) manifestoComments[c.manifesto_id] = [];
                manifestoComments[c.manifesto_id].push(c);
            });

            // Process tags
            manifestoTags = {};
            (tagsResult.data || []).forEach(t => {
                if (!manifestoTags[t.manifesto_id]) manifestoTags[t.manifesto_id] = [];
                manifestoTags[t.manifesto_id].push({ tag: t.tag, parent_tag: t.parent_tag });
            });

            // Process comment threads
            (threadsResult.data || []).forEach(t => {
                commentThreads[t.comment_id] = t.parent_comment_id;
            });

            renderManifestos();
        }

        function renderManifestos() {
            const container = document.getElementById('manifestoList');
            const emptyState = document.getElementById('manifestoEmptyState');

            if (manifestos.length === 0) {
                emptyState.style.display = 'block';
                container.innerHTML = '';
                container.appendChild(emptyState);
                return;
            }

            emptyState.style.display = 'none';
            container.innerHTML = manifestos.map(m => renderManifestoCard(m)).join('');
        }

        function renderManifestoCard(m) {
            const time = new Date(m.created_at).toLocaleString();
            const voteCount = manifestoVotes[m.id] || m.upvotes || 0;
            const hasVoted = myManifestoVotes[m.id];
            const reactions = manifestoReactions[m.id] || {};
            const myReacts = myManifestoReactions[m.id] || new Set();
            const comments = manifestoComments[m.id] || [];
            const tags = manifestoTags[m.id] || [];

            const reactionsHtml = Object.entries(reactions)
                .sort((a, b) => b[1] - a[1])
                .map(([emoji, count]) => {
                    const isActive = myReacts.has(emoji);
                    return `<button class="reaction-btn ${isActive ? 'active' : ''}" onclick="toggleManifestoReaction(${m.id}, '${emoji}')">
                        ${emoji} <span class="reaction-count">${count}</span>
                    </button>`;
                }).join('');

            const reactionPickerHtml = REACTION_EMOJIS.map(emoji =>
                `<button onclick="toggleManifestoReaction(${m.id}, '${emoji}')">${emoji}</button>`
            ).join('');

            const commentsHtml = renderThreadedComments(comments, m.id, 'manifesto');

            // Reply indicator if replying to a comment on this manifesto
            const replyIndicatorHtml = (replyingTo && replyingTo.postId === m.id && replyingTo.type === 'manifesto')
                ? `<div class="reply-indicator">
                    <span>â†© Replying to <strong>${escapeHtml(replyingTo.username)}</strong></span>
                    <button class="cancel-reply" onclick="cancelReply()">âœ•</button>
                </div>`
                : '';

            const tagsHtml = tags.length > 0 ? `
                <div class="post-tags">
                    ${tags.map(t => {
                        const isNested = t.parent_tag != null;
                        const displayTag = isNested ? `${t.parent_tag}/${t.tag}` : t.tag;
                        return `<span class="tag ${isNested ? 'nested' : ''}">#${escapeHtml(displayTag)}</span>`;
                    }).join('')}
                </div>
            ` : '';

            return `
                <div class="manifesto-card" data-manifesto-id="${m.id}">
                    <div class="manifesto-card-header">
                        <div class="manifesto-avatar">${m.avatar || 'ðŸ‘¤'}</div>
                        <span class="manifesto-author username-clickable" onclick="showProfileCard('${escapeHtml(m.username || 'Anonymous')}', event)">${escapeHtml(m.username || 'Anonymous')}</span>
                        <span class="manifesto-time">${time}</span>
                    </div>
                    <h3 class="manifesto-title">${escapeHtml(m.title)}</h3>
                    <div class="manifesto-text">${escapeHtml(m.content)}</div>
                    ${tagsHtml}
                    <div class="manifesto-actions">
                        <button class="manifesto-vote-btn ${hasVoted ? 'voted' : ''}" onclick="voteManifesto(${m.id})">
                            ${hasVoted ? 'â­' : 'â˜†'} <span>${voteCount}</span>
                        </button>
                        <button class="post-action-btn" onclick="focusManifestoComment(${m.id})">
                            ðŸ’¬ ${comments.length}
                        </button>
                    </div>
                    <div class="post-reactions" id="manifesto-reactions-${m.id}">
                        ${reactionsHtml}
                        <div style="position:relative;display:inline-block;">
                            <button class="add-reaction-btn" onclick="toggleManifestoReactionPicker(${m.id})">+ ðŸ˜€</button>
                            <div class="reaction-picker" id="manifesto-picker-${m.id}">
                                ${reactionPickerHtml}
                            </div>
                        </div>
                    </div>
                    <div class="post-comments" id="manifesto-comments-${m.id}">
                        ${commentsHtml}
                    </div>
                    ${replyIndicatorHtml}
                    <div class="comment-input-row">
                        <input class="comment-input" id="manifesto-comment-input-${m.id}" placeholder="${replyingTo && replyingTo.postId === m.id && replyingTo.type === 'manifesto' ? 'Write a reply...' : 'Add a comment...'}" onkeydown="if(event.key==='Enter')addManifestoComment(${m.id})">
                        <button class="comment-send" onclick="addManifestoComment(${m.id})">POST</button>
                    </div>
                </div>
            `;
        }

        window.voteManifesto = async function(manifestoId) {
            if (!currentUser) return;

            const hasVoted = myManifestoVotes[manifestoId];

            if (hasVoted) {
                await supabase
                    .from('sloppygram_manifesto_votes')
                    .delete()
                    .eq('manifesto_id', manifestoId)
                    .eq('user_id', currentUser.id);

                myManifestoVotes[manifestoId] = false;
                manifestoVotes[manifestoId] = Math.max(0, (manifestoVotes[manifestoId] || 0) - 1);
            } else {
                await supabase
                    .from('sloppygram_manifesto_votes')
                    .insert({
                        manifesto_id: manifestoId,
                        username: profile.username,
                        user_id: currentUser.id
                    });

                myManifestoVotes[manifestoId] = true;
                manifestoVotes[manifestoId] = (manifestoVotes[manifestoId] || 0) + 1;
            }

            renderManifestos();
        };

        window.toggleManifestoReactionPicker = function(manifestoId) {
            const picker = document.getElementById(`manifesto-picker-${manifestoId}`);
            document.querySelectorAll('.reaction-picker').forEach(p => {
                if (p !== picker) p.classList.remove('active');
            });
            picker.classList.toggle('active');
        };

        window.toggleManifestoReaction = async function(manifestoId, emoji) {
            if (!currentUser) return;

            const myReacts = myManifestoReactions[manifestoId] || new Set();
            const hasReacted = myReacts.has(emoji);

            if (hasReacted) {
                await supabase
                    .from('sloppygram_manifesto_reactions')
                    .delete()
                    .eq('manifesto_id', manifestoId)
                    .eq('emoji', emoji)
                    .eq('user_id', currentUser.id);

                myReacts.delete(emoji);
                if (!manifestoReactions[manifestoId]) manifestoReactions[manifestoId] = {};
                manifestoReactions[manifestoId][emoji] = Math.max(0, (manifestoReactions[manifestoId][emoji] || 0) - 1);
                if (manifestoReactions[manifestoId][emoji] === 0) delete manifestoReactions[manifestoId][emoji];
            } else {
                await supabase
                    .from('sloppygram_manifesto_reactions')
                    .insert({
                        manifesto_id: manifestoId,
                        emoji,
                        username: profile.username,
                        user_id: currentUser.id
                    });

                myReacts.add(emoji);
                if (!manifestoReactions[manifestoId]) manifestoReactions[manifestoId] = {};
                manifestoReactions[manifestoId][emoji] = (manifestoReactions[manifestoId][emoji] || 0) + 1;
            }

            myManifestoReactions[manifestoId] = myReacts;
            document.querySelectorAll('.reaction-picker').forEach(p => p.classList.remove('active'));
            renderManifestos();
        };

        window.focusManifestoComment = function(manifestoId) {
            document.getElementById(`manifesto-comment-input-${manifestoId}`).focus();
        };

        window.addManifestoComment = async function(manifestoId) {
            const input = document.getElementById(`manifesto-comment-input-${manifestoId}`);
            const content = input.value.trim();
            if (!content || !currentUser) return;

            // Rate limiting check
            const rateCheck = checkRateLimit('comment');
            if (!rateCheck.allowed) {
                showToast(rateCheck.message, 'warning');
                return;
            }
            recordAction('comment');

            const comment = {
                manifesto_id: manifestoId,
                username: profile.username,
                avatar: profile.avatar,
                content,
                user_id: currentUser.id
            };

            const { data, error } = await supabase
                .from('sloppygram_manifesto_comments')
                .insert(comment)
                .select()
                .single();

            if (error) {
                console.error('Error adding comment:', error);
                return;
            }

            // If this is a reply, save the thread relationship
            if (replyingTo && replyingTo.postId === manifestoId && replyingTo.type === 'manifesto' && data) {
                await supabase
                    .from('sloppygram_comment_threads')
                    .insert({
                        comment_id: data.id,
                        parent_comment_id: replyingTo.commentId,
                        comment_type: 'manifesto',
                        post_id: manifestoId,
                        user_id: currentUser.id
                    });
                commentThreads[data.id] = replyingTo.commentId;
            }

            if (!manifestoComments[manifestoId]) manifestoComments[manifestoId] = [];
            manifestoComments[manifestoId].push({ ...comment, id: data?.id, created_at: new Date().toISOString() });

            input.value = '';
            replyingTo = null;
            renderManifestos();
        };

        // === REPUTATION SYSTEM ===

        async function loadReputations() {
            // Calculate reputation from post votes (net score using vote_type)
            const { data: postsData } = await supabase
                .from('sloppygram_posts')
                .select('username, id');

            const postsByUser = {};
            (postsData || []).forEach(p => {
                if (p.username) {
                    if (!postsByUser[p.username]) postsByUser[p.username] = [];
                    postsByUser[p.username].push(p.id);
                }
            });

            const { data: postVotesData } = await supabase
                .from('sloppygram_post_likes')
                .select('post_id, vote_type');

            const postVotesByPost = {};
            (postVotesData || []).forEach(v => {
                postVotesByPost[v.post_id] = (postVotesByPost[v.post_id] || 0) + (v.vote_type || 1);
            });

            const postScoresByUser = {};
            for (const [username, postIds] of Object.entries(postsByUser)) {
                postScoresByUser[username] = postIds.reduce((sum, id) => sum + (postVotesByPost[id] || 0), 0);
            }

            // Calculate reputation from manifesto votes
            const { data: manifestosData } = await supabase
                .from('sloppygram_manifestos')
                .select('username, id');

            const manifestosByUser = {};
            (manifestosData || []).forEach(m => {
                if (m.username) {
                    if (!manifestosByUser[m.username]) manifestosByUser[m.username] = [];
                    manifestosByUser[m.username].push(m.id);
                }
            });

            const manifestoVotesByUser = {};
            for (const [username, manifestoIds] of Object.entries(manifestosByUser)) {
                if (manifestoIds.length > 0) {
                    const { count } = await supabase
                        .from('sloppygram_manifesto_votes')
                        .select('*', { count: 'exact', head: true })
                        .in('manifesto_id', manifestoIds);
                    manifestoVotesByUser[username] = count || 0;
                }
            }

            // Calculate reputation from chat message votes (net score)
            const { data: messagesData } = await supabase
                .from('sloppygram_messages')
                .select('username, id');

            const messagesByUser = {};
            (messagesData || []).forEach(m => {
                if (m.username) {
                    if (!messagesByUser[m.username]) messagesByUser[m.username] = [];
                    messagesByUser[m.username].push(m.id);
                }
            });

            const { data: chatVotesData } = await supabase
                .from('sloppygram_message_votes')
                .select('message_id, vote_type');

            const chatVotesByMessage = {};
            (chatVotesData || []).forEach(v => {
                chatVotesByMessage[v.message_id] = (chatVotesByMessage[v.message_id] || 0) + (v.vote_type || 1);
            });

            const chatVotesByUser = {};
            for (const [username, msgIds] of Object.entries(messagesByUser)) {
                chatVotesByUser[username] = msgIds.reduce((sum, id) => sum + (chatVotesByMessage[id] || 0), 0);
            }

            // Calculate reputation from doodle votes (net score)
            const { data: doodleVotesData } = await supabase
                .from('sloppygram_doodle_votes')
                .select('message_id, vote_type');

            const doodleVotesByMessage = {};
            (doodleVotesData || []).forEach(v => {
                doodleVotesByMessage[v.message_id] = (doodleVotesByMessage[v.message_id] || 0) + (v.vote_type || 1);
            });

            const doodleVotesByUser = {};
            for (const [username, msgIds] of Object.entries(messagesByUser)) {
                doodleVotesByUser[username] = msgIds.reduce((sum, id) => sum + (doodleVotesByMessage[id] || 0), 0);
            }

            // Combine into reputation scores
            const allUsers = new Set([
                ...Object.keys(postScoresByUser),
                ...Object.keys(manifestoVotesByUser),
                ...Object.keys(chatVotesByUser),
                ...Object.keys(doodleVotesByUser)
            ]);
            userReputations = {};
            allUsers.forEach(username => {
                const postScore = postScoresByUser[username] || 0;
                const manifestoVotes = manifestoVotesByUser[username] || 0;
                const chatScore = chatVotesByUser[username] || 0;
                const doodleScore = doodleVotesByUser[username] || 0;
                userReputations[username] = {
                    postLikes: postScore,
                    manifestoVotes,
                    chatVotes: chatScore,
                    doodleVotes: doodleScore,
                    total: postScore + (manifestoVotes * 2) + chatScore + (doodleScore * 2)
                };
            });

            console.log('Loaded reputations:', userReputations);
        }

        function getReputationBadge(username) {
            const rep = userReputations[username];
            if (!rep || rep.total === 0) return '';

            let badge = '';
            const parts = [];
            if (rep.postLikes > 0) parts.push(`${rep.postLikes} post`);
            if (rep.manifestoVotes > 0) parts.push(`${rep.manifestoVotes} manifesto`);
            if (rep.chatVotes > 0) parts.push(`${rep.chatVotes} chat`);
            if (rep.doodleVotes > 0) parts.push(`${rep.doodleVotes} doodle`);
            let title = `âš¡${rep.total} power (${parts.join(', ')})`;

            if (rep.total >= 100) {
                badge = 'ðŸ‘‘';
            } else if (rep.total >= 50) {
                badge = 'â­';
            } else if (rep.total >= 20) {
                badge = 'âœ¨';
            } else if (rep.total >= 5) {
                badge = 'ðŸ”¥';
            }

            return badge ? `<span class="rep-badge" title="${title}">${badge}${rep.total}</span>` :
                          `<span class="rep-badge small" title="${title}">âš¡${rep.total}</span>`;
        }

        // === DOODLE LEADERBOARD FUNCTIONALITY ===

        async function loadDoodleVotes() {
            const { data: votes } = await supabase
                .from('sloppygram_doodle_votes')
                .select('message_id, voter_username, vote_type');

            if (votes) {
                doodleVotes = {};
                votes.forEach(v => {
                    doodleVotes[v.message_id] = (doodleVotes[v.message_id] || 0) + (v.vote_type || 1);
                });

                myDoodleVotes = {};
                votes.filter(v => v.voter_username === profile.username).forEach(v => {
                    myDoodleVotes[v.message_id] = v.vote_type || 1;
                });
            }
        }

        window.voteDoodle = async function(messageId, voteType, ownerUsername) {
            if (!currentUser) return;
            if (ownerUsername === profile.username) return; // Can't vote on own doodle

            // Rate limiting check
            const rateCheck = checkRateLimit('vote');
            if (!rateCheck.allowed) {
                showToast(rateCheck.message, 'warning');
                return;
            }
            recordAction('vote');

            const currentVote = myDoodleVotes[messageId] || 0;

            if (currentVote === voteType) {
                // Remove vote if clicking same button
                await supabase
                    .from('sloppygram_doodle_votes')
                    .delete()
                    .eq('message_id', messageId)
                    .eq('user_id', currentUser.id);

                myDoodleVotes[messageId] = 0;
                doodleVotes[messageId] = (doodleVotes[messageId] || 0) - voteType;
            } else {
                // Remove existing vote first
                if (currentVote !== 0) {
                    await supabase
                        .from('sloppygram_doodle_votes')
                        .delete()
                        .eq('message_id', messageId)
                        .eq('user_id', currentUser.id);
                    doodleVotes[messageId] = (doodleVotes[messageId] || 0) - currentVote;
                }

                // Add new vote
                await supabase
                    .from('sloppygram_doodle_votes')
                    .insert({
                        message_id: messageId,
                        voter_username: profile.username,
                        vote_type: voteType,
                        user_id: currentUser.id
                    });

                myDoodleVotes[messageId] = voteType;
                doodleVotes[messageId] = (doodleVotes[messageId] || 0) + voteType;
            }

            // Log AI event for doodle vote
            logAiEvent('vote_cast', 'doodle', messageId, {
                vote_type: myDoodleVotes[messageId] || 0,
                net_score: doodleVotes[messageId] || 0
            });

            // Update UI
            updateDoodleVoteUI(messageId);
        };

        function updateDoodleVoteUI(messageId) {
            const score = doodleVotes[messageId] || 0;
            const myVote = myDoodleVotes[messageId] || 0;
            const scoreClass = score > 0 ? 'positive' : score < 0 ? 'negative' : 'neutral';

            document.querySelectorAll(`[data-doodle-id="${messageId}"]`).forEach(container => {
                const scoreEl = container.querySelector('.vote-score');
                const upBtn = container.querySelector('.vote-btn.upvote');
                const downBtn = container.querySelector('.vote-btn.downvote');

                if (scoreEl) {
                    scoreEl.textContent = score;
                    scoreEl.className = `vote-score ${scoreClass}`;
                }
                if (upBtn) upBtn.classList.toggle('active', myVote === 1);
                if (downBtn) downBtn.classList.toggle('active', myVote === -1);
            });
        }

        // === CHAT MESSAGE VOTING ===

        async function loadMessageVotes() {
            const { data: votes } = await supabase
                .from('sloppygram_message_votes')
                .select('message_id, voter_username, vote_type');

            if (votes) {
                messageVotes = {};
                votes.forEach(v => {
                    messageVotes[v.message_id] = (messageVotes[v.message_id] || 0) + (v.vote_type || 1);
                });

                myMessageVotes = {};
                votes.filter(v => v.voter_username === profile.username).forEach(v => {
                    myMessageVotes[v.message_id] = v.vote_type || 1;
                });
            }
        }

        window.voteMessage = async function(messageId, voteType) {
            if (!currentUser) return;

            // Rate limiting check
            const rateCheck = checkRateLimit('vote');
            if (!rateCheck.allowed) {
                showToast(rateCheck.message, 'warning');
                return;
            }
            recordAction('vote');

            const currentVote = myMessageVotes[messageId] || 0;

            if (currentVote === voteType) {
                // Remove vote if clicking same button
                await supabase
                    .from('sloppygram_message_votes')
                    .delete()
                    .eq('message_id', messageId)
                    .eq('user_id', currentUser.id);

                myMessageVotes[messageId] = 0;
                messageVotes[messageId] = (messageVotes[messageId] || 0) - voteType;
            } else {
                // Remove existing vote first
                if (currentVote !== 0) {
                    await supabase
                        .from('sloppygram_message_votes')
                        .delete()
                        .eq('message_id', messageId)
                        .eq('user_id', currentUser.id);
                    messageVotes[messageId] = (messageVotes[messageId] || 0) - currentVote;
                }

                // Add new vote
                await supabase
                    .from('sloppygram_message_votes')
                    .insert({
                        message_id: messageId,
                        voter_username: profile.username,
                        vote_type: voteType,
                        user_id: currentUser.id
                    });

                myMessageVotes[messageId] = voteType;
                messageVotes[messageId] = (messageVotes[messageId] || 0) + voteType;
            }

            // Log AI event for message vote
            logAiEvent('vote_cast', 'message', messageId, {
                vote_type: myMessageVotes[messageId] || 0,
                net_score: messageVotes[messageId] || 0
            });

            // Update UI
            updateMessageVoteUI(messageId);
        };

        function updateMessageVoteUI(messageId) {
            const score = messageVotes[messageId] || 0;
            const myVote = myMessageVotes[messageId] || 0;
            const scoreClass = score > 0 ? 'positive' : score < 0 ? 'negative' : 'neutral';

            document.querySelectorAll(`[data-chat-id="${messageId}"]`).forEach(container => {
                const scoreEl = container.querySelector('.vote-score');
                const upBtn = container.querySelector('.vote-btn.upvote');
                const downBtn = container.querySelector('.vote-btn.downvote');

                if (scoreEl) {
                    scoreEl.textContent = score;
                    scoreEl.className = `vote-score ${scoreClass}`;
                }
                if (upBtn) upBtn.classList.toggle('active', myVote === 1);
                if (downBtn) downBtn.classList.toggle('active', myVote === -1);
            });
        }

        // === COMMENT VOTING ===

        async function loadCommentVotes() {
            const { data: votes } = await supabase
                .from('sloppygram_comment_votes')
                .select('comment_id, voter_username, vote_type');

            if (votes) {
                commentVotes = {};
                votes.forEach(v => {
                    commentVotes[v.comment_id] = (commentVotes[v.comment_id] || 0) + (v.vote_type || 1);
                });

                myCommentVotes = {};
                votes.filter(v => v.voter_username === profile.username).forEach(v => {
                    myCommentVotes[v.comment_id] = v.vote_type || 1;
                });
            }
        }

        window.voteComment = async function(commentId, voteType, ownerUsername) {
            if (!currentUser) return;
            if (ownerUsername === profile.username) return; // Can't vote on own comment

            // Rate limiting check
            const rateCheck = checkRateLimit('vote');
            if (!rateCheck.allowed) {
                showToast(rateCheck.message, 'warning');
                return;
            }
            recordAction('vote');

            const currentVote = myCommentVotes[commentId] || 0;

            if (currentVote === voteType) {
                // Remove vote if clicking same button
                await supabase
                    .from('sloppygram_comment_votes')
                    .delete()
                    .eq('comment_id', commentId)
                    .eq('user_id', currentUser.id);

                myCommentVotes[commentId] = 0;
                commentVotes[commentId] = (commentVotes[commentId] || 0) - voteType;
            } else {
                // Remove existing vote first
                if (currentVote !== 0) {
                    await supabase
                        .from('sloppygram_comment_votes')
                        .delete()
                        .eq('comment_id', commentId)
                        .eq('user_id', currentUser.id);
                    commentVotes[commentId] = (commentVotes[commentId] || 0) - currentVote;
                }

                // Add new vote
                await supabase
                    .from('sloppygram_comment_votes')
                    .insert({
                        comment_id: commentId,
                        voter_username: profile.username,
                        vote_type: voteType,
                        user_id: currentUser.id
                    });

                myCommentVotes[commentId] = voteType;
                commentVotes[commentId] = (commentVotes[commentId] || 0) + voteType;
            }

            // Log AI event for comment vote
            logAiEvent('vote_cast', 'comment', commentId, {
                vote_type: myCommentVotes[commentId] || 0,
                net_score: commentVotes[commentId] || 0
            });

            // Update UI - re-render posts to reflect vote changes
            renderPosts();
        };

        async function loadDoodleLeaderboard() {
            const container = document.getElementById('doodlesContainer');
            const emptyState = document.getElementById('doodlesEmptyState');

            // Batch both queries in parallel
            const [doodlesResult, votesResult] = await Promise.all([
                supabase
                    .from('sloppygram_messages')
                    .select('*')
                    .not('drawing_data', 'is', null)
                    .order('created_at', { ascending: false }),
                supabase
                    .from('sloppygram_doodle_votes')
                    .select('message_id, vote_type')
            ]);

            const doodles = doodlesResult.data;
            const error = doodlesResult.error;

            if (error || !doodles || doodles.length === 0) {
                emptyState.style.display = 'block';
                return;
            }

            // Count net votes
            const voteCounts = {};
            (votesResult.data || []).forEach(v => {
                voteCounts[v.message_id] = (voteCounts[v.message_id] || 0) + (v.vote_type || 1);
            });

            // Sort by votes (descending), then by date
            const sortedDoodles = doodles
                .map(d => ({ ...d, votes: voteCounts[d.id] || 0 }))
                .sort((a, b) => b.votes - a.votes || new Date(b.created_at) - new Date(a.created_at));

            // Render leaderboard
            container.innerHTML = '<div class="leaderboard-header">ðŸ† LEGENDARY DOODLES ðŸ†</div>';

            if (sortedDoodles.length === 0) {
                container.innerHTML += `<div class="empty-doodles" id="doodlesEmptyState">
                    <div class="icon">ðŸŽ¨</div>
                    <p>NO LEGENDARY DOODLES YET...</p>
                    <p>Draw something and get votes!</p>
                </div>`;
                return;
            }

            // Create grid container
            const grid = document.createElement('div');
            grid.className = 'doodle-grid';

            sortedDoodles.forEach((doodle, index) => {
                const rank = index + 1;
                let rankClass = '';
                if (rank === 1) rankClass = 'gold';
                else if (rank === 2) rankClass = 'silver';
                else if (rank === 3) rankClass = 'bronze';

                const time = new Date(doodle.created_at).toLocaleDateString();
                const myVote = myDoodleVotes[doodle.id] || 0;
                const isOwnDoodle = doodle.username === profile.username;
                const scoreClass = doodle.votes > 0 ? 'positive' : doodle.votes < 0 ? 'negative' : 'neutral';
                const isTop3 = rank <= 3;
                const safeDrawingData = sanitizeUrl(doodle.drawing_data);

                const deleteBtn = isOwnDoodle ? `<button class="msg-delete-btn" onclick="deleteMessage('${doodle.id}')" title="Delete doodle">delete</button>` : '';

                const card = document.createElement('div');
                card.className = `doodle-card${isTop3 ? ' top-3' : ''}`;
                card.innerHTML = `
                    <div class="doodle-rank">
                        <span class="rank-badge ${rankClass}">${rank}</span>
                        <span class="doodle-artist username-clickable" onclick="showProfileCard('${escapeHtml(doodle.username || 'Anonymous')}', event)">${escapeHtml(doodle.username || 'Anonymous')}</span>
                        <span class="doodle-votes ${scoreClass}">${doodle.votes > 0 ? '+' : ''}${doodle.votes}</span>
                        ${deleteBtn}
                    </div>
                    <div class="doodle-thumbnail">
                        <img loading="lazy" src="${safeDrawingData}" onclick="window.open(this.src)">
                    </div>
                    <div class="doodle-card-actions">
                        <span class="doodle-time">${time}</span>
                        <div class="vote-controls" data-doodle-id="${doodle.id}">
                            <button class="vote-btn upvote ${myVote === 1 ? 'active' : ''} ${isOwnDoodle ? 'disabled' : ''}"
                                onclick="${isOwnDoodle ? '' : `voteDoodle('${doodle.id}', 1, '${escapeHtml(doodle.username)}')`}"
                                title="${isOwnDoodle ? 'Cannot vote on own doodle' : 'Upvote'}">â–²</button>
                            <span class="vote-score ${scoreClass}">${doodle.votes}</span>
                            <button class="vote-btn downvote ${myVote === -1 ? 'active' : ''} ${isOwnDoodle ? 'disabled' : ''}"
                                onclick="${isOwnDoodle ? '' : `voteDoodle('${doodle.id}', -1, '${escapeHtml(doodle.username)}')`}"
                                title="${isOwnDoodle ? 'Cannot vote on own doodle' : 'Downvote'}">â–¼</button>
                        </div>
                    </div>
                `;
                grid.appendChild(card);
            });

            container.appendChild(grid);
        }

        // Mobile sidebar toggle
        window.toggleSidebar = function(side) {
            const sidebarLeft = document.getElementById('sidebarLeft');
            const sidebarRight = document.getElementById('sidebarRight');
            const backdrop = document.getElementById('mobileBackdrop');
            const hamburgerBtn = document.getElementById('hamburgerBtn');

            // Close the other sidebar first
            if (side === 'left') {
                sidebarRight.classList.remove('mobile-show');
                sidebarLeft.classList.toggle('mobile-show');
                // Toggle hamburger animation
                hamburgerBtn.classList.toggle('active', sidebarLeft.classList.contains('mobile-show'));
            } else {
                sidebarLeft.classList.remove('mobile-show');
                sidebarRight.classList.toggle('mobile-show');
                // Remove hamburger active state when opening right sidebar
                hamburgerBtn.classList.remove('active');
            }

            // Show backdrop if any sidebar is open
            const isAnyOpen = sidebarLeft.classList.contains('mobile-show') || sidebarRight.classList.contains('mobile-show');
            backdrop.classList.toggle('active', isAnyOpen);
        };

        window.closeSidebars = function() {
            document.getElementById('sidebarLeft').classList.remove('mobile-show');
            document.getElementById('sidebarRight').classList.remove('mobile-show');
            document.getElementById('mobileBackdrop').classList.remove('active');
            document.getElementById('hamburgerBtn').classList.remove('active');
        };

        // === COLLABORATIVE CANVAS ===
        let collabCanvas, collabCtx, collabWrapper;
        let collabChannel = null;
        let collabColor = '#ff00ff';
        let collabDrawing = false;
        let collabLastX = 0, collabLastY = 0;
        let collabInitialized = false;
        let collabUsers = new Map(); // Track other users' cursors
        const COLLAB_THROTTLE = 16; // ~60fps
        let lastCollabBroadcast = 0;

        // Stroke history for selective clearing
        let collabStrokes = []; // Array of {x1, y1, x2, y2, color, username}
        const COLLAB_MAX_STROKES = 10000; // Limit history size

        // Database persistence
        let collabStrokeBatch = []; // Batch queue for saving
        const COLLAB_BATCH_SIZE = 10; // Save every N strokes
        const COLLAB_BATCH_DELAY = 1000; // Or after 1 second
        let collabBatchTimeout = null;

        // Zoom/pan state
        let collabZoom = 1;
        const COLLAB_ZOOM_MIN = 0.25;
        const COLLAB_ZOOM_MAX = 4;
        const COLLAB_ZOOM_STEP = 0.25;

        async function initCollabCanvas() {
            if (collabInitialized) return;
            collabInitialized = true;

            collabCanvas = document.getElementById('collabCanvas');
            collabCtx = collabCanvas.getContext('2d');
            collabWrapper = document.getElementById('collabCanvasWrapper');

            // Fill with dark background
            collabCtx.fillStyle = '#0a0a0a';
            collabCtx.fillRect(0, 0, collabCanvas.width, collabCanvas.height);
            collabCtx.lineCap = 'round';
            collabCtx.lineJoin = 'round';
            collabCtx.lineWidth = 3;

            // Mouse events
            collabCanvas.addEventListener('mousedown', collabMouseDown);
            collabCanvas.addEventListener('mousemove', collabMouseMove);
            collabCanvas.addEventListener('mouseup', collabStopDraw);
            collabCanvas.addEventListener('mouseleave', collabStopDraw);

            // Touch events (2 fingers = pan, 1 finger = draw)
            collabCanvas.addEventListener('touchstart', collabTouchStart, { passive: false });
            collabCanvas.addEventListener('touchmove', collabTouchMove, { passive: false });
            collabCanvas.addEventListener('touchend', collabStopDraw);

            // Wheel zoom
            collabWrapper.addEventListener('wheel', collabWheelZoom, { passive: false });

            // Setup realtime channel
            setupCollabChannel();

            // Apply initial zoom
            updateCollabZoom();

            // Load existing strokes from database
            await loadCollabStrokes();
        }

        // Load persisted strokes from database
        async function loadCollabStrokes() {
            try {
                const { data, error } = await supabase
                    .from('sloppygram_collab_strokes')
                    .select('start_x, start_y, end_x, end_y, color, username')
                    .order('created_at', { ascending: true })
                    .limit(COLLAB_MAX_STROKES);

                if (error) {
                    console.error('Error loading collab strokes:', error);
                    return;
                }

                if (data && data.length > 0) {
                    // Convert DB format to local format
                    collabStrokes = data.map(s => ({
                        x1: s.start_x,
                        y1: s.start_y,
                        x2: s.end_x,
                        y2: s.end_y,
                        color: s.color,
                        username: s.username
                    }));

                    // Redraw all strokes
                    redrawCollabCanvas();
                    console.log(`Loaded ${data.length} strokes from database`);
                }
            } catch (err) {
                console.error('Failed to load collab strokes:', err);
            }
        }

        function getCollabCoords(clientX, clientY) {
            const rect = collabCanvas.getBoundingClientRect();
            // Account for zoom: rect size changes with CSS transform
            // Canvas internal size stays constant, so we need to map display coords to canvas coords
            const x = (clientX - rect.left) * (collabCanvas.width / rect.width);
            const y = (clientY - rect.top) * (collabCanvas.height / rect.height);
            return { x, y };
        }

        function collabMouseDown(e) {
            e.preventDefault();
            const coords = getCollabCoords(e.clientX, e.clientY);
            collabStartDraw(coords.x, coords.y);
        }

        function collabMouseMove(e) {
            const coords = getCollabCoords(e.clientX, e.clientY);
            collabDraw(coords.x, coords.y);
        }

        function collabTouchStart(e) {
            e.preventDefault();
            if (e.touches.length === 1) {
                const touch = e.touches[0];
                const coords = getCollabCoords(touch.clientX, touch.clientY);
                collabStartDraw(coords.x, coords.y);
            }
        }

        function collabTouchMove(e) {
            e.preventDefault();
            if (e.touches.length === 1) {
                const touch = e.touches[0];
                const coords = getCollabCoords(touch.clientX, touch.clientY);
                collabDraw(coords.x, coords.y);
            }
        }

        function collabStartDraw(x, y) {
            collabDrawing = true;
            collabLastX = x;
            collabLastY = y;
            collabCtx.beginPath();
            collabCtx.moveTo(x, y);
        }

        function collabDraw(x, y) {
            // Broadcast cursor position (throttled)
            const now = Date.now();
            if (now - lastCollabBroadcast > COLLAB_THROTTLE) {
                lastCollabBroadcast = now;
                broadcastCollabCursor(x, y);
            }

            if (!collabDrawing) return;

            // Draw locally
            collabCtx.strokeStyle = collabColor;
            collabCtx.lineWidth = 3;
            collabCtx.lineTo(x, y);
            collabCtx.stroke();
            collabCtx.beginPath();
            collabCtx.moveTo(x, y);

            // Store stroke in history
            const stroke = { x1: collabLastX, y1: collabLastY, x2: x, y2: y, color: collabColor, username: profile.username };
            collabStrokes.push(stroke);
            if (collabStrokes.length > COLLAB_MAX_STROKES) {
                collabStrokes.shift(); // Remove oldest
            }

            // Queue stroke for database persistence
            queueCollabStroke(stroke);

            // Broadcast stroke
            broadcastCollabStroke(collabLastX, collabLastY, x, y, collabColor);

            collabLastX = x;
            collabLastY = y;
        }

        function collabStopDraw() {
            collabDrawing = false;
            // Flush any pending strokes when user stops drawing
            flushCollabStrokes();
        }

        // Batch save strokes to database
        function queueCollabStroke(stroke) {
            collabStrokeBatch.push(stroke);

            // Clear existing timeout
            if (collabBatchTimeout) {
                clearTimeout(collabBatchTimeout);
            }

            // Save immediately if batch is full, otherwise wait
            if (collabStrokeBatch.length >= COLLAB_BATCH_SIZE) {
                flushCollabStrokes();
            } else {
                collabBatchTimeout = setTimeout(flushCollabStrokes, COLLAB_BATCH_DELAY);
            }
        }

        async function flushCollabStrokes() {
            if (collabStrokeBatch.length === 0) return;

            const batch = collabStrokeBatch.slice();
            collabStrokeBatch = [];

            if (collabBatchTimeout) {
                clearTimeout(collabBatchTimeout);
                collabBatchTimeout = null;
            }

            try {
                const rows = batch.map(s => ({
                    start_x: Math.round(s.x1),
                    start_y: Math.round(s.y1),
                    end_x: Math.round(s.x2),
                    end_y: Math.round(s.y2),
                    color: s.color,
                    username: s.username,
                    user_id: currentUser?.id
                }));

                const { error } = await supabase
                    .from('sloppygram_collab_strokes')
                    .insert(rows);

                if (error) {
                    console.error('Error saving strokes:', error);
                }
            } catch (err) {
                console.error('Failed to save strokes:', err);
            }
        }

        // Zoom functions
        function collabWheelZoom(e) {
            e.preventDefault();
            const delta = e.deltaY > 0 ? -COLLAB_ZOOM_STEP : COLLAB_ZOOM_STEP;
            setCollabZoom(collabZoom + delta);
        }

        function setCollabZoom(newZoom) {
            collabZoom = Math.max(COLLAB_ZOOM_MIN, Math.min(COLLAB_ZOOM_MAX, newZoom));
            updateCollabZoom();
        }

        function updateCollabZoom() {
            collabCanvas.style.transform = `scale(${collabZoom})`;
            document.getElementById('collabZoomLevel').textContent = Math.round(collabZoom * 100);

            // Update cursor overlay to match zoom
            const cursors = document.getElementById('collabCursors');
            cursors.style.transform = `scale(${collabZoom})`;
            cursors.style.transformOrigin = '0 0';
        }

        window.collabZoomIn = function() {
            setCollabZoom(collabZoom + COLLAB_ZOOM_STEP);
        };

        window.collabZoomOut = function() {
            setCollabZoom(collabZoom - COLLAB_ZOOM_STEP);
        };

        window.collabZoomReset = function() {
            setCollabZoom(1);
            // Reset scroll position
            if (collabWrapper) {
                collabWrapper.scrollLeft = 0;
                collabWrapper.scrollTop = 0;
            }
        };

        function setupCollabChannel() {
            if (collabChannel) return;

            collabChannel = supabase.channel('sloppygram-collab-canvas', {
                config: { broadcast: { self: false } }
            });

            // Listen for strokes from other users
            collabChannel.on('broadcast', { event: 'stroke' }, ({ payload }) => {
                drawRemoteStroke(payload);
            });

            // Listen for cursor positions
            collabChannel.on('broadcast', { event: 'cursor' }, ({ payload }) => {
                updateRemoteCursor(payload);
            });

            // Listen for clear_user events (remove specific user's strokes)
            collabChannel.on('broadcast', { event: 'clear_user' }, ({ payload }) => {
                collabStrokes = collabStrokes.filter(s => s.username !== payload.username);
                redrawCollabCanvas();
            });

            // Listen for clear_all events (wipe entire canvas)
            collabChannel.on('broadcast', { event: 'clear_all' }, () => {
                collabStrokes = [];
                collabCtx.fillStyle = '#0a0a0a';
                collabCtx.fillRect(0, 0, collabCanvas.width, collabCanvas.height);
            });

            // Track presence
            collabChannel.on('presence', { event: 'sync' }, () => {
                const state = collabChannel.presenceState();
                const count = Object.keys(state).length;
                document.getElementById('collabUserCount').textContent = count;
            });

            collabChannel.on('presence', { event: 'leave' }, ({ key }) => {
                // Remove cursor when user leaves
                const cursor = document.getElementById('cursor-' + key);
                if (cursor) cursor.remove();
                collabUsers.delete(key);
            });

            collabChannel.subscribe(async (status) => {
                if (status === 'SUBSCRIBED') {
                    await collabChannel.track({
                        username: profile.username,
                        avatar: profile.avatar,
                        color: collabColor
                    });
                }
            });
        }

        function broadcastCollabStroke(x1, y1, x2, y2, color) {
            if (!collabChannel) return;
            collabChannel.send({
                type: 'broadcast',
                event: 'stroke',
                payload: {
                    x1, y1, x2, y2, color,
                    username: profile.username,
                    avatar: profile.avatar
                }
            });
        }

        function broadcastCollabCursor(x, y) {
            if (!collabChannel) return;
            collabChannel.send({
                type: 'broadcast',
                event: 'cursor',
                payload: {
                    x, y,
                    username: profile.username,
                    avatar: profile.avatar,
                    color: collabColor
                }
            });
        }

        function drawRemoteStroke(payload) {
            const { x1, y1, x2, y2, color, username } = payload;

            // Store in history
            collabStrokes.push({ x1, y1, x2, y2, color, username });
            if (collabStrokes.length > COLLAB_MAX_STROKES) {
                collabStrokes.shift();
            }

            // Draw
            collabCtx.save();
            collabCtx.strokeStyle = color;
            collabCtx.lineWidth = 3;
            collabCtx.lineCap = 'round';
            collabCtx.beginPath();
            collabCtx.moveTo(x1, y1);
            collabCtx.lineTo(x2, y2);
            collabCtx.stroke();
            collabCtx.restore();
        }

        function updateRemoteCursor(payload) {
            const { x, y, username, avatar, color } = payload;
            const cursorId = 'cursor-' + username;
            let cursor = document.getElementById(cursorId);

            if (!cursor) {
                cursor = document.createElement('div');
                cursor.id = cursorId;
                cursor.className = 'collab-cursor';
                cursor.innerHTML = `
                    <div class="collab-cursor-dot" style="background:${color};color:${color}"></div>
                    <div class="collab-cursor-name">${avatar} ${username}</div>
                `;
                document.getElementById('collabCursors').appendChild(cursor);
            }

            // Position in canvas coordinates (cursors container is scaled with CSS transform)
            cursor.style.left = x + 'px';
            cursor.style.top = y + 'px';
            cursor.querySelector('.collab-cursor-dot').style.background = color;
            cursor.querySelector('.collab-cursor-dot').style.color = color;

            // Update color if changed
            collabUsers.set(username, { x, y, color, avatar });
        }

        window.setCollabColor = function(color) {
            collabColor = color;
            document.querySelectorAll('.collab-color-btn').forEach(btn => {
                btn.classList.toggle('active', btn.dataset.color === color);
            });
            // Update presence with new color
            if (collabChannel) {
                collabChannel.track({
                    username: profile.username,
                    avatar: profile.avatar,
                    color: collabColor
                });
            }
        };

        // Redraw all strokes from history
        function redrawCollabCanvas() {
            if (!collabCtx) return;
            // Clear canvas
            collabCtx.fillStyle = '#0a0a0a';
            collabCtx.fillRect(0, 0, collabCanvas.width, collabCanvas.height);

            // Redraw all strokes
            collabCtx.save();
            collabCtx.lineWidth = 3;
            collabCtx.lineCap = 'round';
            collabStrokes.forEach(stroke => {
                collabCtx.strokeStyle = stroke.color;
                collabCtx.beginPath();
                collabCtx.moveTo(stroke.x1, stroke.y1);
                collabCtx.lineTo(stroke.x2, stroke.y2);
                collabCtx.stroke();
            });
            collabCtx.restore();
        }

        // Clear only the current user's strokes
        window.clearCollabCanvas = async function() {
            if (!collabCtx) return;
            const myUsername = profile.username;

            // Remove user's strokes from history
            collabStrokes = collabStrokes.filter(s => s.username !== myUsername);

            // Redraw canvas with remaining strokes
            redrawCollabCanvas();

            // Delete user's strokes from database
            try {
                const { error } = await supabase
                    .from('sloppygram_collab_strokes')
                    .delete()
                    .eq('user_id', currentUser?.id);

                if (error) {
                    console.error('Error deleting strokes from DB:', error);
                }
            } catch (err) {
                console.error('Failed to delete strokes:', err);
            }

            // Broadcast clear_user to others so they remove this user's strokes
            if (collabChannel) {
                collabChannel.send({
                    type: 'broadcast',
                    event: 'clear_user',
                    payload: { username: myUsername }
                });
            }
        };

        // Clear entire canvas (all users) - admin function
        window.clearCollabCanvasAll = async function() {
            if (!collabCtx) return;
            collabStrokes = [];
            collabCtx.fillStyle = '#0a0a0a';
            collabCtx.fillRect(0, 0, collabCanvas.width, collabCanvas.height);

            // Note: Can't delete all strokes due to RLS - only own strokes
            // This just clears visually and broadcasts

            if (collabChannel) {
                collabChannel.send({
                    type: 'broadcast',
                    event: 'clear_all',
                    payload: { username: profile.username }
                });
            }
        };

        // Mobile touch swipe navigation
        const VIEWS = ['chat', 'posts', 'doodles', 'manifesto', 'collab'];
        let touchStartX = 0;
        let touchStartY = 0;
        let touchEndX = 0;
        let touchEndY = 0;
        const MIN_SWIPE_DISTANCE = 80;
        const MAX_VERTICAL_DISTANCE = 100;

        function isMobile() {
            return window.matchMedia('(max-width: 768px)').matches ||
                   'ontouchstart' in window ||
                   navigator.maxTouchPoints > 0;
        }

        function handleSwipe() {
            const deltaX = touchEndX - touchStartX;
            const deltaY = Math.abs(touchEndY - touchStartY);

            // Only trigger swipe if horizontal movement is significant and vertical is minimal
            if (Math.abs(deltaX) > MIN_SWIPE_DISTANCE && deltaY < MAX_VERTICAL_DISTANCE) {
                const currentIndex = VIEWS.indexOf(currentView);

                if (deltaX < 0 && currentIndex < VIEWS.length - 1) {
                    // Swipe left - go to next tab
                    switchView(VIEWS[currentIndex + 1]);
                } else if (deltaX > 0 && currentIndex > 0) {
                    // Swipe right - go to previous tab
                    switchView(VIEWS[currentIndex - 1]);
                }
            }
        }

        function initTouchSwipe() {
            const mainContent = document.querySelector('.main-content');
            if (!mainContent) return;

            mainContent.addEventListener('touchstart', (e) => {
                if (!isMobile()) return;
                touchStartX = e.changedTouches[0].screenX;
                touchStartY = e.changedTouches[0].screenY;
            }, { passive: true });

            mainContent.addEventListener('touchend', (e) => {
                if (!isMobile()) return;
                touchEndX = e.changedTouches[0].screenX;
                touchEndY = e.changedTouches[0].screenY;
                handleSwipe();
            }, { passive: true });
        }

        // Initialize touch swipe after DOM ready
        document.addEventListener('DOMContentLoaded', initTouchSwipe);

        // Initialize
        init();
    </script>
</body>
</html>
