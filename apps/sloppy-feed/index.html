<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sloppy Feed</title>
    <link rel="icon" href="https://emojicdn.elk.sh/üì°">
    <meta property="og:title" content="Sloppy Feed">
    <meta property="og:description" content="The global timeline. Post, react, comment, vote.">
    <meta property="og:url" content="https://sloppy.live/sloppy-feed">
    <meta property="og:image" content="https://pollinations.ai/p/a%20retro%20terminal%20screen%20showing%20a%20scrolling%20social%20feed%20with%20neon%20green%20text%20on%20dark%20background%20pixel%20art?width=1200&height=630&nologo=true&referrer=sloppy.live">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link href="https://fonts.googleapis.com/css2?family=DM+Serif+Text:ital@0;1&family=Geist+Mono:wght@300;400;500;700&display=swap" rel="stylesheet">
    <style>
        :root {
            --bg: #0c0a0f;
            --surface: #14111a;
            --surface-hover: #1c1826;
            --border: #2a2535;
            --border-active: #4a3f5f;
            --text: #e8e4f0;
            --text-dim: #8a8296;
            --text-muted: #5a5470;
            --accent: #c084fc;
            --accent-dim: #7c3aed;
            --upvote: #34d399;
            --downvote: #f87171;
            --tag-bg: #1e1a2a;
            --tag-text: #a78bfa;
            --reaction-bg: #1a162a;
            --reaction-active: #2d2548;
            --comment-bg: #110f18;
            --serif: 'DM Serif Text', Georgia, serif;
            --mono: 'Geist Mono', 'Courier New', monospace;
        }
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            background: var(--bg);
            color: var(--text);
            font-family: var(--mono);
            font-size: 13px;
            min-height: 100vh;
        }
        a { color: var(--accent); text-decoration: none; }
        a:hover { text-decoration: underline; }

        .app-header {
            text-align: center;
            padding: 32px 16px 24px;
            border-bottom: 1px solid var(--border);
            background: linear-gradient(180deg, #14111a 0%, var(--bg) 100%);
        }
        .app-header h1 {
            font-family: var(--serif);
            font-size: 2.4rem;
            font-weight: 400;
            letter-spacing: 0.02em;
            color: var(--text);
        }
        .app-header h1 em { color: var(--accent); font-style: italic; }
        .app-header .subtitle {
            font-size: 11px;
            color: var(--text-muted);
            margin-top: 6px;
            letter-spacing: 0.08em;
            text-transform: uppercase;
        }
        .stats-row {
            display: flex;
            gap: 20px;
            justify-content: center;
            margin-top: 14px;
            font-size: 11px;
            color: var(--text-dim);
        }
        .stats-row span strong { color: var(--accent); }

        .toolbar {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 10px 16px;
            border-bottom: 1px solid var(--border);
            background: var(--surface);
            position: sticky;
            top: 0;
            z-index: 50;
        }
        .sort-tabs {
            display: flex;
            gap: 2px;
        }
        .sort-tab {
            background: none;
            border: 1px solid transparent;
            color: var(--text-dim);
            font-family: var(--mono);
            font-size: 11px;
            padding: 5px 10px;
            cursor: pointer;
            border-radius: 4px;
            transition: all 0.15s;
        }
        .sort-tab:hover { color: var(--text); background: var(--surface-hover); }
        .sort-tab.active {
            color: var(--accent);
            border-color: var(--border-active);
            background: var(--tag-bg);
        }
        .compose-btn {
            background: var(--accent-dim);
            color: #fff;
            border: none;
            font-family: var(--mono);
            font-size: 12px;
            padding: 6px 14px;
            border-radius: 4px;
            cursor: pointer;
            font-weight: 700;
            transition: background 0.15s;
        }
        .compose-btn:hover { background: var(--accent); }

        .tag-filter-bar {
            display: none;
            align-items: center;
            gap: 8px;
            padding: 8px 16px;
            background: var(--tag-bg);
            border-bottom: 1px solid var(--border);
            font-size: 11px;
        }
        .tag-filter-bar.active { display: flex; }
        .tag-filter-bar .tag-label { color: var(--tag-text); font-weight: 500; }
        .tag-filter-bar button {
            background: none;
            border: 1px solid var(--border);
            color: var(--text-dim);
            font-family: var(--mono);
            font-size: 10px;
            padding: 3px 8px;
            border-radius: 3px;
            cursor: pointer;
        }
        .tag-filter-bar button:hover { color: var(--text); border-color: var(--border-active); }

        .feed { max-width: 600px; margin: 0 auto; padding: 12px 8px 80px; }
        .feed-loading {
            text-align: center;
            padding: 40px;
            color: var(--text-muted);
            font-size: 12px;
        }
        .feed-empty {
            text-align: center;
            padding: 60px 20px;
            color: var(--text-muted);
        }
        .feed-empty .empty-icon { font-size: 2.4rem; margin-bottom: 10px; }

        .post-card {
            background: var(--surface);
            border: 1px solid var(--border);
            border-radius: 6px;
            margin-bottom: 10px;
            overflow: hidden;
            transition: border-color 0.2s;
        }
        .post-card:hover { border-color: var(--border-active); }
        .post-header {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 10px 12px 6px;
        }
        .post-avatar {
            width: 28px;
            height: 28px;
            border-radius: 50%;
            background: var(--tag-bg);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 14px;
            flex-shrink: 0;
            overflow: hidden;
        }
        .post-avatar img { width: 100%; height: 100%; object-fit: cover; }
        .post-username {
            font-weight: 500;
            color: var(--text);
            font-size: 12px;
            cursor: pointer;
        }
        .post-username:hover { color: var(--accent); }
        .post-time { font-size: 10px; color: var(--text-muted); margin-left: auto; }
        .post-delete {
            background: none;
            border: none;
            color: var(--text-muted);
            font-family: var(--mono);
            font-size: 10px;
            cursor: pointer;
            padding: 2px 6px;
        }
        .post-delete:hover { color: var(--downvote); }

        .post-image {
            width: 100%;
            max-height: 480px;
            object-fit: cover;
            display: block;
            background: var(--comment-bg);
        }
        .post-caption {
            padding: 8px 12px;
            font-size: 13px;
            line-height: 1.5;
            color: var(--text);
            word-break: break-word;
        }

        .post-actions {
            display: flex;
            align-items: center;
            gap: 4px;
            padding: 4px 12px 6px;
        }
        .vote-controls {
            display: flex;
            align-items: center;
            gap: 2px;
            margin-right: 8px;
        }
        .vote-btn {
            background: none;
            border: 1px solid transparent;
            color: var(--text-muted);
            font-size: 10px;
            padding: 3px 6px;
            cursor: pointer;
            border-radius: 3px;
            font-family: var(--mono);
            transition: all 0.12s;
        }
        .vote-btn:hover { background: var(--surface-hover); color: var(--text); }
        .vote-btn.upvote.active { color: var(--upvote); border-color: var(--upvote); }
        .vote-btn.downvote.active { color: var(--downvote); border-color: var(--downvote); }
        .vote-score {
            font-size: 12px;
            font-weight: 700;
            min-width: 24px;
            text-align: center;
            color: var(--text-dim);
        }
        .action-btn {
            background: none;
            border: none;
            color: var(--text-muted);
            font-family: var(--mono);
            font-size: 11px;
            padding: 4px 8px;
            cursor: pointer;
            border-radius: 3px;
            transition: all 0.12s;
        }
        .action-btn:hover { background: var(--surface-hover); color: var(--text); }

        .reactions-row {
            display: flex;
            flex-wrap: wrap;
            gap: 4px;
            padding: 0 12px 6px;
        }
        .reaction-pill {
            display: flex;
            align-items: center;
            gap: 3px;
            background: var(--reaction-bg);
            border: 1px solid var(--border);
            border-radius: 12px;
            padding: 2px 8px;
            font-size: 12px;
            cursor: pointer;
            transition: all 0.12s;
        }
        .reaction-pill:hover { border-color: var(--border-active); }
        .reaction-pill.mine { border-color: var(--accent-dim); background: var(--reaction-active); }
        .reaction-pill .count { font-size: 10px; color: var(--text-dim); }
        .reaction-add {
            background: none;
            border: 1px dashed var(--border);
            border-radius: 12px;
            padding: 2px 8px;
            font-size: 11px;
            color: var(--text-muted);
            cursor: pointer;
            position: relative;
        }
        .reaction-add:hover { border-color: var(--border-active); color: var(--text-dim); }
        .reaction-picker {
            display: none;
            position: absolute;
            bottom: 30px;
            left: 0;
            background: var(--surface);
            border: 1px solid var(--border-active);
            border-radius: 6px;
            padding: 4px;
            gap: 2px;
            z-index: 30;
            flex-wrap: wrap;
            width: 180px;
        }
        .reaction-picker.open { display: flex; }
        .reaction-picker button {
            background: none;
            border: none;
            font-size: 18px;
            cursor: pointer;
            padding: 4px;
            border-radius: 4px;
            transition: background 0.1s;
        }
        .reaction-picker button:hover { background: var(--surface-hover); }

        .tags-row {
            display: flex;
            flex-wrap: wrap;
            gap: 4px;
            padding: 0 12px 8px;
        }
        .tag-chip {
            background: var(--tag-bg);
            color: var(--tag-text);
            font-size: 10px;
            padding: 2px 8px;
            border-radius: 3px;
            cursor: pointer;
            border: 1px solid transparent;
            transition: all 0.12s;
        }
        .tag-chip:hover { border-color: var(--tag-text); }

        .comments-section {
            border-top: 1px solid var(--border);
            background: var(--comment-bg);
        }
        .comment {
            padding: 6px 12px;
            display: flex;
            gap: 6px;
            align-items: flex-start;
        }
        .comment-thread { padding-left: 28px; }
        .comment .c-avatar { font-size: 12px; flex-shrink: 0; padding-top: 2px; }
        .comment .c-body { flex: 1; min-width: 0; }
        .comment .c-user {
            font-weight: 500;
            font-size: 11px;
            color: var(--text-dim);
            cursor: pointer;
        }
        .comment .c-user:hover { color: var(--accent); }
        .comment .c-time { font-size: 9px; color: var(--text-muted); margin-left: 6px; }
        .comment .c-text { font-size: 12px; color: var(--text); margin-top: 1px; word-break: break-word; }
        .comment .c-actions {
            display: flex;
            gap: 6px;
            margin-top: 2px;
        }
        .comment .c-actions button {
            background: none;
            border: none;
            color: var(--text-muted);
            font-family: var(--mono);
            font-size: 9px;
            cursor: pointer;
            padding: 1px 3px;
        }
        .comment .c-actions button:hover { color: var(--text); }
        .comment .c-actions button.cv-active-up { color: var(--upvote); }
        .comment .c-actions button.cv-active-down { color: var(--downvote); }

        .comment-input-row {
            display: flex;
            gap: 6px;
            padding: 6px 12px;
            border-top: 1px solid var(--border);
        }
        .comment-input-row input {
            flex: 1;
            background: var(--bg);
            border: 1px solid var(--border);
            border-radius: 4px;
            color: var(--text);
            font-family: var(--mono);
            font-size: 11px;
            padding: 5px 8px;
            outline: none;
        }
        .comment-input-row input:focus { border-color: var(--accent-dim); }
        .comment-input-row button {
            background: var(--accent-dim);
            border: none;
            color: #fff;
            font-family: var(--mono);
            font-size: 10px;
            padding: 5px 10px;
            border-radius: 4px;
            cursor: pointer;
            font-weight: 700;
        }
        .comment-input-row button:hover { background: var(--accent); }
        .reply-indicator {
            padding: 3px 12px;
            font-size: 10px;
            color: var(--accent);
            background: var(--tag-bg);
            display: flex;
            align-items: center;
            gap: 6px;
        }
        .reply-indicator button {
            background: none;
            border: none;
            color: var(--text-muted);
            cursor: pointer;
            font-size: 10px;
            font-family: var(--mono);
        }

        .load-more-btn {
            display: block;
            margin: 16px auto;
            background: var(--surface);
            border: 1px solid var(--border);
            color: var(--text-dim);
            font-family: var(--mono);
            font-size: 11px;
            padding: 8px 24px;
            border-radius: 4px;
            cursor: pointer;
        }
        .load-more-btn:hover { border-color: var(--accent-dim); color: var(--accent); }

        /* Compose modal */
        .modal-overlay {
            display: none;
            position: fixed;
            inset: 0;
            background: rgba(0,0,0,0.7);
            z-index: 100;
            align-items: center;
            justify-content: center;
        }
        .modal-overlay.open { display: flex; }
        .modal {
            background: var(--surface);
            border: 1px solid var(--border-active);
            border-radius: 8px;
            padding: 20px;
            width: 90%;
            max-width: 500px;
            max-height: 90vh;
            overflow-y: auto;
        }
        .modal h2 {
            font-family: var(--serif);
            font-size: 1.3rem;
            font-weight: 400;
            margin-bottom: 14px;
        }
        .modal label {
            font-size: 10px;
            color: var(--text-muted);
            text-transform: uppercase;
            letter-spacing: 0.08em;
            display: block;
            margin-bottom: 4px;
            margin-top: 12px;
        }
        .modal input[type="text"],
        .modal textarea {
            width: 100%;
            background: var(--bg);
            border: 1px solid var(--border);
            border-radius: 4px;
            color: var(--text);
            font-family: var(--mono);
            font-size: 12px;
            padding: 8px 10px;
            outline: none;
        }
        .modal input:focus, .modal textarea:focus { border-color: var(--accent-dim); }
        .modal textarea { min-height: 80px; resize: vertical; }
        .modal .char-count { font-size: 10px; color: var(--text-muted); text-align: right; margin-top: 2px; }
        .pending-tags {
            display: flex;
            flex-wrap: wrap;
            gap: 4px;
            margin-top: 6px;
        }
        .pending-tag {
            background: var(--tag-bg);
            color: var(--tag-text);
            font-size: 10px;
            padding: 2px 8px;
            border-radius: 3px;
            display: flex;
            align-items: center;
            gap: 4px;
        }
        .pending-tag button {
            background: none;
            border: none;
            color: var(--text-muted);
            cursor: pointer;
            font-size: 10px;
        }
        .modal-actions {
            display: flex;
            gap: 8px;
            margin-top: 16px;
            justify-content: flex-end;
        }
        .modal-actions button {
            font-family: var(--mono);
            font-size: 12px;
            padding: 7px 16px;
            border-radius: 4px;
            cursor: pointer;
            border: 1px solid var(--border);
            background: var(--surface-hover);
            color: var(--text-dim);
        }
        .modal-actions button:hover { color: var(--text); border-color: var(--border-active); }
        .modal-actions .submit-btn {
            background: var(--accent-dim);
            border-color: var(--accent-dim);
            color: #fff;
            font-weight: 700;
        }
        .modal-actions .submit-btn:hover { background: var(--accent); }

        .backlink {
            text-align: center;
            padding: 12px;
            font-size: 11px;
        }

        .toast {
            position: fixed;
            bottom: 60px;
            left: 50%;
            transform: translateX(-50%) translateY(20px);
            background: var(--surface);
            border: 1px solid var(--border-active);
            color: var(--text);
            font-family: var(--mono);
            font-size: 11px;
            padding: 8px 18px;
            border-radius: 6px;
            z-index: 200;
            opacity: 0;
            transition: all 0.3s;
            pointer-events: none;
        }
        .toast.visible { opacity: 1; transform: translateX(-50%) translateY(0); }

        /* Embed mode: hide chrome when loaded inside Sloppygram iframe */
        body.embed-mode .app-header,
        body.embed-mode .backlink,
        body.embed-mode .stats-row { display: none !important; }
        body.embed-mode .toolbar { top: 0; }
        body.embed-mode .feed { padding-bottom: 20px; }

        @media (max-width: 600px) {
            .app-header h1 { font-size: 1.7rem; }
            .toolbar { flex-wrap: wrap; gap: 6px; }
            .sort-tabs { flex-wrap: wrap; }
            .feed { padding: 8px 4px 80px; }
            .modal { width: 95%; padding: 14px; }
        }
    </style>
<script>
(function(){var Q=[],N=0,MAX=10;function send(e){var sb=window.supabase;if(!sb){Q.push(e);return;}if(N>=MAX)return;N++;sb.auth.getSession().then(function(r){var u=r&&r.data&&r.data.session&&r.data.session.user;if(!u)return;sb.from('ai_events').insert({event_type:'client_error',entity_type:'app',entity_id:u.id,username:location.pathname.split('/').filter(Boolean)[0]||'unknown',metadata:e,user_id:u.id}).then(function(){});}).catch(function(){});}window.onerror=function(m,s,l,c,e){send({type:'error',msg:String(m).slice(0,500),src:s||'',line:l,col:c,stack:e?String(e.stack).slice(0,1000):''});};window.addEventListener('unhandledrejection',function(ev){var r=ev.reason;send({type:'promise',msg:String(r&&r.message||r).slice(0,500),stack:r?String(r.stack||'').slice(0,1000):''});});var fi=setInterval(function(){if(window.supabase){Q.splice(0).forEach(send);clearInterval(fi);}},1000);setTimeout(function(){clearInterval(fi);},30000);})();
</script>
</head>
<body>
    <div class="app-header">
        <h1>Sloppy <em>Feed</em></h1>
        <div class="subtitle">Global Timeline</div>
        <div class="stats-row" id="statsRow">
            <span><strong id="statPosts">‚Äî</strong> posts</span>
            <span><strong id="statComments">‚Äî</strong> comments</span>
            <span><strong id="statOnline">1</strong> online</span>
        </div>
    </div>

    <div class="toolbar">
        <div class="sort-tabs">
            <button class="sort-tab active" data-sort="newest" onclick="setSort('newest')">Newest</button>
            <button class="sort-tab" data-sort="top" onclick="setSort('top')">Top</button>
            <button class="sort-tab" data-sort="discussed" onclick="setSort('discussed')">Discussed</button>
        </div>
        <button class="compose-btn" id="composeBtn" onclick="openCompose()">+ Post</button>
    </div>

    <div class="tag-filter-bar" id="tagFilterBar">
        <span>Filtering:</span>
        <span class="tag-label" id="tagFilterLabel"></span>
        <button onclick="clearTagFilter()">clear ‚úï</button>
    </div>

    <div class="feed" id="feedContainer">
        <div class="feed-loading" id="feedLoading">Loading stream...</div>
    </div>

    <!-- Compose Modal -->
    <div class="modal-overlay" id="composeModal">
        <div class="modal">
            <h2>New Post</h2>
            <label>Image URL (optional)</label>
            <input type="text" id="composeImageUrl" placeholder="https://...">
            <label>Caption</label>
            <textarea id="composeCaption" maxlength="1000" placeholder="What's on your mind?" oninput="updateCharCount()"></textarea>
            <div class="char-count"><span id="charCount">0</span>/1000</div>
            <label>Tags (press Enter to add)</label>
            <input type="text" id="composeTagInput" placeholder="e.g. art/digital" onkeydown="handleTagKey(event)">
            <div class="pending-tags" id="pendingTagsContainer"></div>
            <div class="modal-actions">
                <button onclick="closeCompose()">Cancel</button>
                <button class="submit-btn" onclick="submitPost()">Post</button>
            </div>
        </div>
    </div>

    <div class="toast" id="toast"></div>

    <div class="backlink"><a href="https://sloppy.live">‚Üê sloppy.live</a></div>

    <script src="/sloppy-header/sloppy-bar.js" data-position="bottom" data-minimized="true"></script>
    <script type="module">
        import supabase from '/supabase-config-fixed.js';

        // Expose for error catcher script
        window.supabase = supabase;

        // Embed mode detection
        const isEmbedMode = new URLSearchParams(location.search).get('embed') === 'true';
        if (isEmbedMode) document.body.classList.add('embed-mode');

        const PAGE_SIZE = 20;
        const REACTION_EMOJIS = ['üòÇ','üî•','‚ù§Ô∏è','üòÆ','üò¢','üëè','üôå','üíÄ'];

        let currentUser = null;
        let profile = { username: 'Anonymous', avatar: 'üë§', avatarUrl: null };
        let posts = [];
        let postComments = {};
        let postReactions = {};
        let postVotes = {};
        let myPostVotes = {};
        let myReactions = {};
        let postTags = {};
        let commentThreads = {};
        let commentVotes = {};
        let myCommentVotes = {};
        let pendingTags = [];
        let activeTagFilter = null;
        let activeSort = 'newest';
        let postsPage = 0;
        let postsHasMore = true;
        let postsLoading = false;
        let replyingTo = null;
        let postsChannel = null;

        // --- Auth ---
        function applyHeaderContext(ctx) {
            if (!ctx) return;
            if (ctx.username && ctx.username !== 'Guest') profile.username = ctx.username;
            if (ctx.avatar) profile.avatar = ctx.avatar;
            if (ctx.avatarUrl) profile.avatarUrl = ctx.avatarUrl;
        }

        async function initAuth() {
            const { data: { session } } = await supabase.auth.getSession();
            let s = session;
            if (!s) {
                const { data } = await supabase.auth.signInAnonymously();
                s = data?.session;
            }
            if (s?.user) {
                currentUser = s.user;
                // Use header sync context for profile instead of direct DB query
                if (window.sloppyBarGetContext) {
                    const ctx = window.sloppyBarGetContext(function(readyCtx) {
                        applyHeaderContext(readyCtx);
                    });
                    applyHeaderContext(ctx);
                } else {
                    // Fallback: direct DB query if header not loaded
                    const { data: prof } = await supabase.from('sloppygram_profiles')
                        .select('username, avatar, avatar_url')
                        .eq('user_id', currentUser.id).single();
                    if (prof) {
                        profile.username = prof.username || 'Anonymous';
                        profile.avatar = prof.avatar || 'üë§';
                        profile.avatarUrl = prof.avatar_url || null;
                    }
                }
            }
        }

        // --- Helpers ---
        function escapeHtml(str) {
            if (!str) return '';
            return str.replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;').replace(/"/g,'&quot;');
        }
        function sanitize(str, max = 2000) {
            if (!str) return '';
            let s = str.trim().slice(0, max);
            if (/<script|javascript:|on\w+\s*=/i.test(s)) return '';
            return s;
        }
        function timeAgo(d) {
            const s = Math.floor((Date.now() - new Date(d).getTime()) / 1000);
            if (s < 60) return 'just now';
            if (s < 3600) return Math.floor(s/60) + 'm';
            if (s < 86400) return Math.floor(s/3600) + 'h';
            if (s < 604800) return Math.floor(s/86400) + 'd';
            return new Date(d).toLocaleDateString();
        }
        function showToast(msg) {
            const t = document.getElementById('toast');
            t.textContent = msg;
            t.classList.add('visible');
            setTimeout(() => t.classList.remove('visible'), 2200);
        }

        // Rate limiting
        const rateLimits = {};
        function checkRate(action, max, window) {
            const now = Date.now();
            if (!rateLimits[action]) rateLimits[action] = [];
            rateLimits[action] = rateLimits[action].filter(t => now - t < window);
            if (rateLimits[action].length >= max) return false;
            rateLimits[action].push(now);
            return true;
        }

        // --- Load Posts ---
        async function loadPosts() {
            postsPage = 0;
            postsHasMore = true;
            postsLoading = true;

            const { data, error } = await supabase.from('sloppygram_posts')
                .select('id, username, avatar, avatar_url, caption, image_url, image_data, likes_count, user_id, created_at')
                .order('created_at', { ascending: false })
                .range(0, PAGE_SIZE - 1);

            if (error) { console.error('Load posts error:', error); postsLoading = false; return; }
            posts = data || [];
            await loadRelatedData(posts.map(p => p.id));
            postsHasMore = posts.length === PAGE_SIZE;
            postsPage = 1;
            postsLoading = false;
            updateStats();
            renderFeed();
        }

        async function loadMorePosts() {
            if (postsLoading || !postsHasMore) return;
            postsLoading = true;
            const from = postsPage * PAGE_SIZE;
            const { data } = await supabase.from('sloppygram_posts')
                .select('id, username, avatar, avatar_url, caption, image_url, image_data, likes_count, user_id, created_at')
                .order('created_at', { ascending: false })
                .range(from, from + PAGE_SIZE - 1);
            if (!data || data.length === 0) { postsHasMore = false; postsLoading = false; renderFeed(); return; }
            posts.push(...data);
            await loadRelatedData(data.map(p => p.id));
            postsHasMore = data.length === PAGE_SIZE;
            postsPage++;
            postsLoading = false;
            renderFeed();
        }

        async function loadRelatedData(postIds) {
            if (!postIds.length) return;
            const [votesR, commentsR, reactionsR, tagsR, threadsR, cvR] = await Promise.all([
                supabase.from('sloppygram_post_likes').select('post_id, username, vote_type'),
                supabase.from('sloppygram_post_comments').select('id, post_id, username, avatar, content, created_at, user_id').in('post_id', postIds).order('created_at', { ascending: true }),
                supabase.from('sloppygram_post_reactions').select('id, post_id, emoji, username').in('post_id', postIds),
                supabase.from('sloppygram_post_tags').select('id, post_id, tag, parent_tag').in('post_id', postIds),
                supabase.from('sloppygram_comment_threads').select('comment_id, parent_comment_id, comment_type, post_id').eq('comment_type', 'post').in('post_id', postIds),
                supabase.from('sloppygram_comment_votes').select('comment_id, voter_username, vote_type')
            ]);

            // Votes
            (votesR.data || []).forEach(v => {
                postVotes[v.post_id] = (postVotes[v.post_id] || 0) + (v.vote_type || 1);
                if (v.username === profile.username) myPostVotes[v.post_id] = v.vote_type || 1;
            });
            posts.forEach(p => { if (postVotes[p.id] !== undefined) p.likes_count = postVotes[p.id]; });

            // Comments
            (commentsR.data || []).forEach(c => {
                if (!postComments[c.post_id]) postComments[c.post_id] = [];
                if (!postComments[c.post_id].find(x => x.id === c.id)) postComments[c.post_id].push(c);
            });

            // Reactions
            (reactionsR.data || []).forEach(r => {
                if (!postReactions[r.post_id]) postReactions[r.post_id] = {};
                postReactions[r.post_id][r.emoji] = (postReactions[r.post_id][r.emoji] || 0) + 1;
                if (r.username === profile.username) {
                    if (!myReactions[r.post_id]) myReactions[r.post_id] = new Set();
                    myReactions[r.post_id].add(r.emoji);
                }
            });

            // Tags
            (tagsR.data || []).forEach(t => {
                if (!postTags[t.post_id]) postTags[t.post_id] = [];
                postTags[t.post_id].push({ tag: t.tag, parent_tag: t.parent_tag });
            });

            // Threads
            (threadsR.data || []).forEach(t => { commentThreads[t.comment_id] = t.parent_comment_id; });

            // Comment votes
            (cvR.data || []).forEach(v => {
                commentVotes[v.comment_id] = (commentVotes[v.comment_id] || 0) + (v.vote_type || 0);
                if (v.voter_username === profile.username) myCommentVotes[v.comment_id] = v.vote_type;
            });
        }

        function updateStats() {
            document.getElementById('statPosts').textContent = posts.length;
            const totalComments = Object.values(postComments).reduce((a, c) => a + c.length, 0);
            document.getElementById('statComments').textContent = totalComments;
        }

        // --- Sorting ---
        function getSortedPosts() {
            let sorted = [...posts];
            if (activeSort === 'top') {
                sorted.sort((a, b) => (postVotes[b.id] || 0) - (postVotes[a.id] || 0));
            } else if (activeSort === 'discussed') {
                sorted.sort((a, b) => (postComments[b.id]?.length || 0) - (postComments[a.id]?.length || 0));
            }
            // 'newest' is default order from DB
            if (activeTagFilter) {
                sorted = sorted.filter(p => {
                    const tags = postTags[p.id] || [];
                    return tags.some(t => {
                        const display = t.parent_tag ? `${t.parent_tag}/${t.tag}` : t.tag;
                        return display.toLowerCase() === activeTagFilter.toLowerCase();
                    });
                });
            }
            return sorted;
        }

        window.setSort = function(s) {
            activeSort = s;
            document.querySelectorAll('.sort-tab').forEach(el => el.classList.toggle('active', el.dataset.sort === s));
            renderFeed();
        };

        window.clearTagFilter = function() {
            activeTagFilter = null;
            document.getElementById('tagFilterBar').classList.remove('active');
            renderFeed();
        };

        // --- Render ---
        function renderFeed() {
            const container = document.getElementById('feedContainer');
            const sorted = getSortedPosts();
            document.getElementById('feedLoading').style.display = 'none';

            if (sorted.length === 0) {
                container.innerHTML = '<div class="feed-empty"><div class="empty-icon">üì°</div>No posts yet. Be the first.</div>';
                return;
            }

            let html = sorted.map(p => renderPostCard(p)).join('');
            if (postsHasMore && !activeTagFilter) {
                html += '<button class="load-more-btn" onclick="loadMore()">Load more...</button>';
            }
            container.innerHTML = html;
        }

        function renderPostCard(post) {
            const isOwn = currentUser && (post.user_id === currentUser.id || post.username === profile.username);
            const myVote = myPostVotes[post.id] || 0;
            const score = postVotes[post.id] || 0;
            const comments = postComments[post.id] || [];
            const reactions = postReactions[post.id] || {};
            const myR = myReactions[post.id] || new Set();
            const tags = postTags[post.id] || [];

            const avatarHtml = post.avatar_url
                ? `<img src="${escapeHtml(post.avatar_url)}" alt="" loading="lazy">`
                : (post.avatar || 'üë§');

            const imageHtml = post.image_url
                ? `<img class="post-image" src="${escapeHtml(post.image_url)}" alt="" loading="lazy" onerror="this.style.display='none'">`
                : (post.image_data ? `<img class="post-image" src="${escapeHtml(post.image_data)}" alt="" loading="lazy">` : '');

            // Reactions
            let reactionsHtml = '';
            for (const [emoji, count] of Object.entries(reactions)) {
                const mine = myR.has(emoji) ? ' mine' : '';
                reactionsHtml += `<span class="reaction-pill${mine}" onclick="toggleReaction(${post.id},'${emoji}')">${emoji} <span class="count">${count}</span></span>`;
            }

            // Tags
            let tagsHtml = '';
            if (tags.length) {
                tagsHtml = '<div class="tags-row">' + tags.map(t => {
                    const display = t.parent_tag ? `${t.parent_tag}/${t.tag}` : t.tag;
                    return `<span class="tag-chip" onclick="filterByTag('${escapeHtml(display)}')">${escapeHtml(display)}</span>`;
                }).join('') + '</div>';
            }

            // Comments
            const commentsHtml = renderComments(comments, post.id);

            // Reply indicator
            const replyHtml = (replyingTo && replyingTo.postId === post.id)
                ? `<div class="reply-indicator">‚Ü© replying to ${escapeHtml(replyingTo.username)} <button onclick="cancelReply()">‚úï</button></div>`
                : '';

            return `<div class="post-card" data-post-id="${post.id}">
                <div class="post-header">
                    <div class="post-avatar">${avatarHtml}</div>
                    <span class="post-username" onclick="handleUsernameClick('${escapeHtml(post.username || 'Anonymous')}')">${escapeHtml(post.username || 'Anonymous')}</span>
                    <span class="post-time">${timeAgo(post.created_at)}</span>
                    ${isOwn ? `<button class="post-delete" onclick="deletePost(${post.id})">delete</button>` : ''}
                </div>
                ${imageHtml}
                ${post.caption ? `<div class="post-caption">${escapeHtml(post.caption)}</div>` : ''}
                <div class="post-actions">
                    <div class="vote-controls">
                        <button class="vote-btn upvote${myVote===1?' active':''}" onclick="votePost(${post.id},1,${isOwn})">‚ñ≤</button>
                        <span class="vote-score">${score}</span>
                        <button class="vote-btn downvote${myVote===-1?' active':''}" onclick="votePost(${post.id},-1,${isOwn})">‚ñº</button>
                    </div>
                    <button class="action-btn" onclick="focusComment(${post.id})">üí¨ ${comments.length}</button>
                    ${post.caption ? `<button class="action-btn" onclick="speakPost(${post.id})">üîä</button>` : ''}
                </div>
                <div class="reactions-row" id="reactions-${post.id}">
                    ${reactionsHtml}
                    <span class="reaction-add" onclick="togglePicker(${post.id})">+
                        <div class="reaction-picker" id="picker-${post.id}">
                            ${REACTION_EMOJIS.map(e => `<button onclick="event.stopPropagation();toggleReaction(${post.id},'${e}')">${e}</button>`).join('')}
                        </div>
                    </span>
                </div>
                ${tagsHtml}
                <div class="comments-section">
                    ${commentsHtml}
                    ${replyHtml}
                    <div class="comment-input-row">
                        <input id="ci-${post.id}" placeholder="Add a comment..." onkeydown="if(event.key==='Enter')addComment(${post.id})">
                        <button onclick="addComment(${post.id})">Post</button>
                    </div>
                </div>
            </div>`;
        }

        function renderComments(comments, postId) {
            if (!comments.length) return '';
            const threads = {};
            const roots = [];
            comments.forEach(c => {
                const parent = commentThreads[c.id];
                if (parent) {
                    if (!threads[parent]) threads[parent] = [];
                    threads[parent].push(c);
                } else {
                    roots.push(c);
                }
            });

            function renderC(c, depth) {
                const isThread = depth > 0;
                const myCV = myCommentVotes[c.id] || 0;
                const cvScore = commentVotes[c.id] || 0;
                const isOwn = c.username === profile.username;
                const replies = threads[c.id] || [];
                return `<div class="comment${isThread ? ' comment-thread' : ''}">
                    <span class="c-avatar">${c.avatar || 'üë§'}</span>
                    <div class="c-body">
                        <span class="c-user" onclick="handleUsernameClick('${escapeHtml(c.username)}')">${escapeHtml(c.username)}</span>
                        <span class="c-time">${timeAgo(c.created_at)}</span>
                        <div class="c-text">${escapeHtml(c.content)}</div>
                        <div class="c-actions">
                            <button onclick="startReply(${postId},${c.id},'${escapeHtml(c.username)}')">‚Ü©</button>
                            <button class="${myCV===1?'cv-active-up':''}" onclick="${isOwn?'':`voteComment(${c.id},1,'${escapeHtml(c.username)}')`}">‚ñ≤</button>
                            <span style="font-size:9px;color:var(--text-muted)">${cvScore}</span>
                            <button class="${myCV===-1?'cv-active-down':''}" onclick="${isOwn?'':`voteComment(${c.id},-1,'${escapeHtml(c.username)}')`}">‚ñº</button>
                        </div>
                    </div>
                </div>${replies.map(r => renderC(r, depth+1)).join('')}`;
            }

            return roots.map(c => renderC(c, 0)).join('');
        }

        // --- Actions ---
        window.votePost = async function(postId, voteType, isOwn) {
            if (!currentUser || isOwn) return;
            if (!checkRate('vote', 30, 60000)) { showToast('Slow down on votes'); return; }

            const current = myPostVotes[postId] || 0;
            if (current === voteType) {
                await supabase.from('sloppygram_post_likes').delete().eq('post_id', postId).eq('user_id', currentUser.id);
                myPostVotes[postId] = 0;
                postVotes[postId] = (postVotes[postId] || 0) - voteType;
            } else {
                if (current !== 0) {
                    await supabase.from('sloppygram_post_likes').delete().eq('post_id', postId).eq('user_id', currentUser.id);
                    postVotes[postId] = (postVotes[postId] || 0) - current;
                }
                await supabase.from('sloppygram_post_likes').insert({ post_id: postId, username: profile.username, vote_type: voteType, user_id: currentUser.id });
                myPostVotes[postId] = voteType;
                postVotes[postId] = (postVotes[postId] || 0) + voteType;
            }
            const post = posts.find(p => p.id === postId);
            if (post) post.likes_count = postVotes[postId] || 0;
            renderFeed();
        };

        window.voteComment = async function(commentId, voteType, ownerUsername) {
            if (!currentUser || ownerUsername === profile.username) return;
            if (!checkRate('cvote', 30, 60000)) return;

            const current = myCommentVotes[commentId] || 0;
            if (current === voteType) {
                await supabase.from('sloppygram_comment_votes').delete().eq('comment_id', commentId).eq('user_id', currentUser.id);
                myCommentVotes[commentId] = 0;
                commentVotes[commentId] = (commentVotes[commentId] || 0) - voteType;
            } else {
                if (current !== 0) {
                    await supabase.from('sloppygram_comment_votes').delete().eq('comment_id', commentId).eq('user_id', currentUser.id);
                    commentVotes[commentId] = (commentVotes[commentId] || 0) - current;
                }
                await supabase.from('sloppygram_comment_votes').insert({ comment_id: commentId, voter_username: profile.username, vote_type: voteType, user_id: currentUser.id });
                myCommentVotes[commentId] = voteType;
                commentVotes[commentId] = (commentVotes[commentId] || 0) + voteType;
            }
            renderFeed();
        };

        window.toggleReaction = async function(postId, emoji) {
            if (!currentUser) return;
            if (!checkRate('react', 20, 60000)) { showToast('Slow down on reactions'); return; }
            // Close picker
            const picker = document.getElementById(`picker-${postId}`);
            if (picker) picker.classList.remove('open');

            const mine = myReactions[postId] && myReactions[postId].has(emoji);
            if (mine) {
                await supabase.from('sloppygram_post_reactions').delete().eq('post_id', postId).eq('emoji', emoji).eq('user_id', currentUser.id);
                if (myReactions[postId]) myReactions[postId].delete(emoji);
                if (postReactions[postId]?.[emoji]) {
                    postReactions[postId][emoji]--;
                    if (postReactions[postId][emoji] <= 0) delete postReactions[postId][emoji];
                }
            } else {
                await supabase.from('sloppygram_post_reactions').insert({ post_id: postId, emoji, username: profile.username, user_id: currentUser.id });
                if (!myReactions[postId]) myReactions[postId] = new Set();
                myReactions[postId].add(emoji);
                if (!postReactions[postId]) postReactions[postId] = {};
                postReactions[postId][emoji] = (postReactions[postId][emoji] || 0) + 1;
            }
            renderFeed();
        };

        window.togglePicker = function(postId) {
            const picker = document.getElementById(`picker-${postId}`);
            if (picker) picker.classList.toggle('open');
        };

        window.addComment = async function(postId) {
            const input = document.getElementById(`ci-${postId}`);
            const raw = input?.value?.trim();
            if (!raw || !currentUser) return;
            if (!checkRate('comment', 15, 60000)) { showToast('Slow down on comments'); return; }

            const content = sanitize(raw);
            if (!content) return;

            const comment = { post_id: postId, username: profile.username, avatar: profile.avatar, content, user_id: currentUser.id };
            const { data, error } = await supabase.from('sloppygram_post_comments').insert(comment).select().single();
            if (error) { console.error('Comment error:', error); return; }

            if (replyingTo && replyingTo.postId === postId && data) {
                await supabase.from('sloppygram_comment_threads').insert({
                    comment_id: data.id,
                    parent_comment_id: replyingTo.commentId,
                    comment_type: 'post',
                    post_id: postId,
                    user_id: currentUser.id
                });
                commentThreads[data.id] = replyingTo.commentId;
            }

            if (!postComments[postId]) postComments[postId] = [];
            postComments[postId].push({ ...comment, id: data?.id, created_at: new Date().toISOString() });
            input.value = '';
            replyingTo = null;
            updateStats();
            renderFeed();
        };

        window.startReply = function(postId, commentId, username) {
            replyingTo = { postId, commentId, username };
            renderFeed();
            const input = document.getElementById(`ci-${postId}`);
            if (input) input.focus();
        };

        window.cancelReply = function() {
            replyingTo = null;
            renderFeed();
        };

        window.focusComment = function(postId) {
            const input = document.getElementById(`ci-${postId}`);
            if (input) { input.scrollIntoView({ behavior: 'smooth', block: 'center' }); input.focus(); }
        };

        window.deletePost = async function(postId) {
            if (!currentUser || !confirm('Delete this post?')) return;
            const { error } = await supabase.from('sloppygram_posts').delete().eq('id', postId).eq('user_id', currentUser.id);
            if (error) { showToast('Could not delete'); return; }
            posts = posts.filter(p => p.id !== postId);
            delete postComments[postId];
            delete postReactions[postId];
            delete postVotes[postId];
            delete postTags[postId];
            updateStats();
            renderFeed();
        };

        window.speakPost = function(postId) {
            const post = posts.find(p => p.id === postId);
            if (!post?.caption) return;
            speechSynthesis.cancel();
            const u = new SpeechSynthesisUtterance(post.caption);
            speechSynthesis.speak(u);
        };

        window.filterByTag = function(tag) {
            activeTagFilter = tag;
            document.getElementById('tagFilterLabel').textContent = tag;
            document.getElementById('tagFilterBar').classList.add('active');
            renderFeed();
        };

        window.loadMore = function() { loadMorePosts(); };

        // --- Compose ---
        window.openCompose = function() {
            if (!currentUser) { showToast('Sign in to post'); return; }
            document.getElementById('composeModal').classList.add('open');
        };
        window.closeCompose = function() {
            document.getElementById('composeModal').classList.remove('open');
            document.getElementById('composeImageUrl').value = '';
            document.getElementById('composeCaption').value = '';
            document.getElementById('composeTagInput').value = '';
            pendingTags = [];
            renderPendingTags();
            updateCharCount();
        };
        window.updateCharCount = function() {
            document.getElementById('charCount').textContent = document.getElementById('composeCaption').value.length;
        };
        window.handleTagKey = function(e) {
            if (e.key !== 'Enter') return;
            e.preventDefault();
            const input = document.getElementById('composeTagInput');
            const val = input.value.trim();
            if (!val) return;
            let tag, parent_tag = null;
            if (val.includes('/')) {
                const parts = val.split('/');
                parent_tag = parts[0].trim();
                tag = parts.slice(1).join('/').trim();
            } else { tag = val; }
            if (tag) pendingTags.push({ tag, parent_tag });
            input.value = '';
            renderPendingTags();
        };
        function renderPendingTags() {
            const c = document.getElementById('pendingTagsContainer');
            c.innerHTML = pendingTags.map((t, i) => {
                const display = t.parent_tag ? `${t.parent_tag}/${t.tag}` : t.tag;
                return `<span class="pending-tag">${escapeHtml(display)} <button onclick="removeTag(${i})">‚úï</button></span>`;
            }).join('');
        }
        window.removeTag = function(i) { pendingTags.splice(i, 1); renderPendingTags(); };

        window.submitPost = async function() {
            if (!currentUser) return;
            if (!checkRate('post', 5, 60000)) { showToast('Posting too fast'); return; }

            const imageUrl = document.getElementById('composeImageUrl').value.trim();
            const rawCaption = document.getElementById('composeCaption').value.trim();
            if (!imageUrl && !rawCaption) { showToast('Add an image or caption'); return; }

            const caption = rawCaption ? sanitize(rawCaption, 1000) : null;
            if (rawCaption && !caption) { showToast('Invalid content'); return; }

            const post = {
                username: profile.username,
                avatar: profile.avatar,
                avatar_url: profile.avatarUrl || null,
                caption,
                image_url: imageUrl || null,
                image_data: null,
                likes_count: 0,
                user_id: currentUser.id
            };

            const { data, error } = await supabase.from('sloppygram_posts').insert(post).select().single();
            if (error || !data) { showToast('Failed to post'); console.error(error); return; }

            // Save tags
            if (pendingTags.length > 0) {
                const tagInserts = pendingTags.filter(t => t.tag && t.tag.length <= 100).map(t => ({
                    post_id: data.id, tag: t.tag, parent_tag: t.parent_tag || null, user_id: currentUser.id
                }));
                if (tagInserts.length) await supabase.from('sloppygram_post_tags').insert(tagInserts);
                tagInserts.forEach(t => {
                    if (!postTags[data.id]) postTags[data.id] = [];
                    postTags[data.id].push({ tag: t.tag, parent_tag: t.parent_tag });
                });
            }

            const createdPost = { ...post, id: data.id, created_at: new Date().toISOString() };
            posts.unshift(createdPost);
            closeCompose();
            showToast('Posted!');
            updateStats();
            renderFeed();

            // Notify parent iframe (Sloppygram) about new post
            if (isEmbedMode && window.parent !== window) {
                window.parent.postMessage({ type: 'new-post-created', post: { id: data.id, username: post.username } }, '*');
            }
        };

        // --- Real-time ---
        function subscribeRealtime() {
            postsChannel = supabase.channel('sloppy-feed-realtime');

            postsChannel.on('postgres_changes', { event: 'INSERT', schema: 'public', table: 'sloppygram_posts' }, payload => {
                if (!posts.find(p => p.id === payload.new.id)) {
                    posts.unshift(payload.new);
                    renderFeed();
                    updateStats();
                }
            });

            postsChannel.on('postgres_changes', { event: 'INSERT', schema: 'public', table: 'sloppygram_post_comments' }, payload => {
                const c = payload.new;
                if (!postComments[c.post_id]) postComments[c.post_id] = [];
                if (!postComments[c.post_id].find(x => x.id === c.id)) {
                    postComments[c.post_id].push(c);
                    updateStats();
                    renderFeed();
                }
            });

            postsChannel.on('postgres_changes', { event: 'INSERT', schema: 'public', table: 'sloppygram_comment_threads' }, payload => {
                commentThreads[payload.new.comment_id] = payload.new.parent_comment_id;
                renderFeed();
            });

            // Presence for online count
            postsChannel.on('presence', { event: 'sync' }, () => {
                const state = postsChannel.presenceState();
                const count = Object.keys(state).length;
                document.getElementById('statOnline').textContent = Math.max(1, count);
            });

            postsChannel.subscribe(async (status) => {
                if (status === 'SUBSCRIBED') {
                    await postsChannel.track({ user: profile.username });
                }
            });
        }

        // --- Username click handler (for embed mode) ---
        window.handleUsernameClick = function(username) {
            if (isEmbedMode && window.parent !== window) {
                window.parent.postMessage({ type: 'username-click', username }, '*');
            }
        };

        // Also handle comment username clicks
        // (add onclick to c-user spans in renderComments)

        // --- Header sync listeners ---
        if (window.sloppyBarOn) {
            window.sloppyBarOn('identity-changed', function(e) {
                if (e.data) applyHeaderContext(e.data);
            });
            window.sloppyBarOn('context-ready', function(e) {
                if (e.data) applyHeaderContext(e.data);
            });
            if (!isEmbedMode) {
                window.sloppyBarOn('theme-changed', function(e) {
                    if (e.data && e.data.vars) {
                        var root = document.documentElement;
                        for (var key in e.data.vars) {
                            if (e.data.vars.hasOwnProperty(key)) root.style.setProperty(key, e.data.vars[key]);
                        }
                    }
                });
            }
        }

        // --- Init ---
        async function init() {
            await initAuth();
            document.getElementById('composeBtn').style.display = currentUser ? '' : 'none';
            await loadPosts();
            subscribeRealtime();
        }

        init().catch(err => {
            console.error('Init error:', err);
            document.getElementById('feedLoading').textContent = 'Failed to load. Refresh to try again.';
        });

        // Close picker on outside click
        document.addEventListener('click', (e) => {
            if (!e.target.closest('.reaction-add')) {
                document.querySelectorAll('.reaction-picker.open').forEach(p => p.classList.remove('open'));
            }
        });

        // Close modal on overlay click
        document.getElementById('composeModal').addEventListener('click', (e) => {
            if (e.target === e.currentTarget) closeCompose();
        });
    </script>
</body>
</html>