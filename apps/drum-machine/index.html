<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>SYNTH DRUM MACHINE</title>
  <link rel="icon" href="https://emojicdn.elk.sh/ðŸ¥">
  <meta property="og:title" content="SYNTH DRUM MACHINE">
  <meta property="og:description" content="16-step sequencer with heavy synthesized drums">
  <meta property="og:image" content="https://sloppy.live/drum-machine/og-image.png">
  <meta property="og:url" content="https://sloppy.live/drum-machine">
  <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&display=swap" rel="stylesheet">
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }

    :root {
      --magenta: #f0f;
      --cyan: #0ff;
      --yellow: #ff0;
      --green: #0f0;
      --orange: #f80;
      --red: #f44;
      --bg: #0a0a0f;
    }

    body {
      background: var(--bg);
      min-height: 100vh;
      font-family: 'Orbitron', sans-serif;
      color: #fff;
      overflow-x: hidden;
    }

    .container {
      max-width: 1100px;
      margin: 0 auto;
      padding: 20px;
    }

    header {
      text-align: center;
      margin-bottom: 30px;
    }

    h1 {
      font-size: 2.5em;
      font-weight: 900;
      background: linear-gradient(90deg, var(--magenta), var(--cyan));
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
      text-shadow: 0 0 30px rgba(255,0,255,0.5);
      letter-spacing: 4px;
    }

    .controls {
      display: flex;
      justify-content: center;
      align-items: center;
      gap: 20px;
      margin-bottom: 25px;
      flex-wrap: wrap;
    }

    .play-btn {
      width: 70px;
      height: 70px;
      border-radius: 50%;
      border: 3px solid var(--magenta);
      background: rgba(255,0,255,0.1);
      color: var(--magenta);
      font-size: 1.8em;
      cursor: pointer;
      transition: all 0.2s;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .play-btn:hover {
      background: var(--magenta);
      color: #000;
      box-shadow: 0 0 30px var(--magenta);
    }

    .play-btn.playing {
      border-color: var(--cyan);
      color: var(--cyan);
      animation: pulse 0.5s ease-in-out infinite;
    }

    .play-btn.playing:hover {
      background: var(--cyan);
    }

    @keyframes pulse {
      0%, 100% { box-shadow: 0 0 10px var(--cyan); }
      50% { box-shadow: 0 0 30px var(--cyan); }
    }

    .bpm-control {
      display: flex;
      align-items: center;
      gap: 10px;
    }

    .bpm-control label {
      color: var(--cyan);
      font-size: 0.9em;
    }

    .bpm-control input {
      width: 80px;
      padding: 10px;
      background: #111;
      border: 2px solid var(--cyan);
      color: var(--cyan);
      font-family: inherit;
      font-size: 1.2em;
      text-align: center;
      border-radius: 8px;
    }

    .bpm-control input:focus {
      outline: none;
      box-shadow: 0 0 15px var(--cyan);
    }

    .action-btns {
      display: flex;
      gap: 10px;
    }

    .action-btn {
      padding: 10px 18px;
      background: transparent;
      border: 2px solid #444;
      color: #888;
      font-family: inherit;
      font-size: 0.8em;
      cursor: pointer;
      border-radius: 6px;
      transition: all 0.2s;
    }

    .action-btn:hover {
      border-color: var(--yellow);
      color: var(--yellow);
    }

    .sequencer {
      background: #111;
      border-radius: 15px;
      padding: 20px;
      border: 1px solid #222;
      overflow-x: auto;
    }

    .track {
      display: flex;
      align-items: center;
      margin-bottom: 8px;
      gap: 10px;
    }

    .track:last-child { margin-bottom: 0; }

    .track-info {
      width: 90px;
      flex-shrink: 0;
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .track-name {
      font-size: 0.75em;
      font-weight: 700;
      text-transform: uppercase;
      letter-spacing: 1px;
      width: 55px;
    }

    .track-vol {
      width: 25px;
      height: 25px;
      background: #222;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      font-size: 0.7em;
      transition: all 0.2s;
    }

    .track-vol:hover {
      transform: scale(1.1);
    }

    .steps {
      display: flex;
      gap: 4px;
    }

    .step {
      width: 40px;
      height: 40px;
      background: #1a1a1a;
      border: 2px solid #333;
      border-radius: 6px;
      cursor: pointer;
      transition: all 0.1s;
      position: relative;
    }

    .step:hover {
      border-color: #555;
      transform: scale(1.05);
    }

    .step.active {
      border-color: var(--track-color);
      background: var(--track-color);
      box-shadow: 0 0 15px var(--track-color);
    }

    .step.playing {
      transform: scale(1.1);
      box-shadow: 0 0 20px #fff !important;
    }

    .step.beat-marker {
      border-color: #444;
    }

    .step.beat-marker.active {
      border-color: var(--track-color);
    }

    /* Track colors */
    .track[data-sound="kick"] { --track-color: var(--magenta); }
    .track[data-sound="kick"] .track-name { color: var(--magenta); }

    .track[data-sound="snare"] { --track-color: var(--cyan); }
    .track[data-sound="snare"] .track-name { color: var(--cyan); }

    .track[data-sound="hihat"] { --track-color: var(--yellow); }
    .track[data-sound="hihat"] .track-name { color: var(--yellow); }

    .track[data-sound="clap"] { --track-color: var(--green); }
    .track[data-sound="clap"] .track-name { color: var(--green); }

    .track[data-sound="tom"] { --track-color: var(--orange); }
    .track[data-sound="tom"] .track-name { color: var(--orange); }

    .track[data-sound="crash"] { --track-color: var(--red); }
    .track[data-sound="crash"] .track-name { color: var(--red); }

    .track[data-sound="bass"] { --track-color: #a0f; }
    .track[data-sound="bass"] .track-name { color: #a0f; }

    .track[data-sound="perc"] { --track-color: #0af; }
    .track[data-sound="perc"] .track-name { color: #0af; }

    .visualizer {
      height: 80px;
      background: #111;
      border-radius: 10px;
      margin-top: 20px;
      overflow: hidden;
      display: flex;
      align-items: flex-end;
      justify-content: center;
      gap: 3px;
      padding: 10px;
    }

    .viz-bar {
      width: 8px;
      background: linear-gradient(to top, var(--magenta), var(--cyan));
      border-radius: 4px 4px 0 0;
      transition: height 0.05s;
      min-height: 4px;
    }

    .swing-control, .fx-control {
      display: flex;
      align-items: center;
      gap: 10px;
    }

    .swing-control label, .fx-control label {
      color: var(--orange);
      font-size: 0.8em;
    }

    .fx-control.reverb label { color: var(--magenta); }
    .fx-control.chorus label { color: var(--cyan); }

    .swing-slider, .fx-slider {
      -webkit-appearance: none;
      width: 80px;
      height: 8px;
      background: #222;
      border-radius: 4px;
      outline: none;
    }

    .swing-slider::-webkit-slider-thumb, .fx-slider::-webkit-slider-thumb {
      -webkit-appearance: none;
      width: 18px;
      height: 18px;
      background: var(--orange);
      border-radius: 50%;
      cursor: pointer;
      box-shadow: 0 0 10px var(--orange);
    }

    .fx-control.reverb .fx-slider::-webkit-slider-thumb {
      background: var(--magenta);
      box-shadow: 0 0 10px var(--magenta);
    }

    .fx-control.chorus .fx-slider::-webkit-slider-thumb {
      background: var(--cyan);
      box-shadow: 0 0 10px var(--cyan);
    }

    .fx-row {
      display: flex;
      justify-content: center;
      gap: 25px;
      margin-bottom: 20px;
      flex-wrap: wrap;
      padding: 12px 20px;
      background: rgba(255,255,255,0.03);
      border-radius: 10px;
      border: 1px solid #222;
    }

    .fx-row .fx-label {
      font-size: 0.7em;
      color: #555;
      text-transform: uppercase;
      letter-spacing: 2px;
      margin-right: 10px;
    }

    .backlink {
      position: fixed;
      bottom: 5px;
      right: 10px;
      color: #333;
      text-decoration: none;
      font-size: 0.6em;
    }

    .presets {
      display: flex;
      gap: 8px;
      justify-content: center;
      margin-top: 15px;
      flex-wrap: wrap;
    }

    .preset-btn {
      padding: 8px 14px;
      background: #1a1a1a;
      border: 1px solid #333;
      color: #666;
      font-family: inherit;
      font-size: 0.7em;
      cursor: pointer;
      border-radius: 4px;
      transition: all 0.2s;
    }

    .preset-btn:hover {
      border-color: var(--magenta);
      color: var(--magenta);
    }

    @media (max-width: 700px) {
      h1 { font-size: 1.5em; }
      .step { width: 30px; height: 30px; }
      .track-info { width: 70px; }
      .track-name { font-size: 0.65em; width: 45px; }
      .controls { gap: 10px; }
      .play-btn { width: 55px; height: 55px; font-size: 1.4em; }
    }
  </style>
</head>
<body>
  <div class="container">
    <header>
      <h1>SYNTH DRUMS</h1>
    </header>

    <div class="controls">
      <button class="play-btn" id="playBtn" onclick="togglePlay()">â–¶</button>

      <div class="bpm-control">
        <label>BPM</label>
        <input type="number" id="bpmInput" value="120" min="60" max="200" onchange="updateBPM()">
      </div>

      <div class="swing-control">
        <label>SWING</label>
        <input type="range" class="swing-slider" id="swingSlider" min="0" max="50" value="0">
      </div>

      <div class="action-btns">
        <button class="action-btn" onclick="clearAll()">CLEAR</button>
        <button class="action-btn" onclick="randomize()">RANDOM</button>
      </div>
    </div>

    <div class="fx-row">
      <span class="fx-label">FX</span>
      <div class="fx-control reverb">
        <label>REVERB</label>
        <input type="range" class="fx-slider" id="reverbSlider" min="0" max="100" value="40">
      </div>
      <div class="fx-control chorus">
        <label>CHORUS</label>
        <input type="range" class="fx-slider" id="chorusSlider" min="0" max="100" value="30">
      </div>
    </div>

    <div class="sequencer" id="sequencer"></div>

    <div class="presets">
      <button class="preset-btn" onclick="loadPreset('basic')">BASIC</button>
      <button class="preset-btn" onclick="loadPreset('house')">HOUSE</button>
      <button class="preset-btn" onclick="loadPreset('trap')">TRAP</button>
      <button class="preset-btn" onclick="loadPreset('dnb')">D&B</button>
      <button class="preset-btn" onclick="loadPreset('techno')">TECHNO</button>
    </div>

    <div class="visualizer" id="visualizer"></div>
  </div>

  <a href="https://sloppy.live" class="backlink">sloppy.live</a>

  <script>
    // Audio context
    let audioCtx = null;
    let isPlaying = false;
    let currentStep = 0;
    let intervalId = null;
    let bpm = 120;

    // FX nodes
    let masterGain = null;
    let dryGain = null;
    let reverbGain = null;
    let chorusGain = null;
    let convolver = null;
    let chorusDelays = [];
    let chorusLFOs = [];

    // Tracks config
    const tracks = [
      { name: 'KICK', sound: 'kick', volume: 1 },
      { name: 'SNARE', sound: 'snare', volume: 0.9 },
      { name: 'HI-HAT', sound: 'hihat', volume: 0.7 },
      { name: 'CLAP', sound: 'clap', volume: 0.8 },
      { name: 'TOM', sound: 'tom', volume: 0.8 },
      { name: 'CRASH', sound: 'crash', volume: 0.6 },
      { name: 'BASS', sound: 'bass', volume: 0.9 },
      { name: 'PERC', sound: 'perc', volume: 0.7 }
    ];

    // Pattern data: 16 steps per track
    const pattern = tracks.map(() => Array(16).fill(false));

    // Initialize
    function init() {
      renderSequencer();
      renderVisualizer();
      loadPreset('basic');
    }

    function renderSequencer() {
      const seq = document.getElementById('sequencer');
      seq.innerHTML = tracks.map((track, ti) => `
        <div class="track" data-sound="${track.sound}">
          <div class="track-info">
            <span class="track-name">${track.name}</span>
            <button class="track-vol" onclick="playSound('${track.sound}')" title="Preview">ðŸ”Š</button>
          </div>
          <div class="steps">
            ${Array(16).fill(0).map((_, si) => `
              <div class="step ${si % 4 === 0 ? 'beat-marker' : ''}"
                   data-track="${ti}"
                   data-step="${si}"
                   onclick="toggleStep(${ti}, ${si})"></div>
            `).join('')}
          </div>
        </div>
      `).join('');
    }

    function renderVisualizer() {
      const viz = document.getElementById('visualizer');
      viz.innerHTML = Array(32).fill(0).map(() => '<div class="viz-bar"></div>').join('');
    }

    function toggleStep(track, step) {
      if (!audioCtx) initAudio();
      pattern[track][step] = !pattern[track][step];
      updateStepUI(track, step);
      if (pattern[track][step]) {
        playSound(tracks[track].sound);
      }
    }

    function updateStepUI(track, step) {
      const stepEl = document.querySelector(`[data-track="${track}"][data-step="${step}"]`);
      if (stepEl) {
        stepEl.classList.toggle('active', pattern[track][step]);
      }
    }

    function initAudio() {
      audioCtx = new (window.AudioContext || window.webkitAudioContext)();

      // Master output
      masterGain = audioCtx.createGain();
      masterGain.gain.value = 0.8;
      masterGain.connect(audioCtx.destination);

      // Dry signal path
      dryGain = audioCtx.createGain();
      dryGain.connect(masterGain);

      // === MASSIVE REVERB ===
      reverbGain = audioCtx.createGain();
      convolver = audioCtx.createConvolver();
      convolver.buffer = createReverbImpulse(3.5, 4.0); // Long, massive reverb

      const reverbFilter = audioCtx.createBiquadFilter();
      reverbFilter.type = 'lowpass';
      reverbFilter.frequency.value = 6000;

      const reverbPreDelay = audioCtx.createDelay(0.1);
      reverbPreDelay.delayTime.value = 0.03;

      reverbGain.connect(reverbPreDelay);
      reverbPreDelay.connect(convolver);
      convolver.connect(reverbFilter);
      reverbFilter.connect(masterGain);

      // === THICK CHORUS ===
      chorusGain = audioCtx.createGain();

      // Create 4 voices for thick chorus
      const chorusVoices = [
        { delay: 0.020, rate: 0.5, depth: 0.003 },
        { delay: 0.025, rate: 0.6, depth: 0.004 },
        { delay: 0.030, rate: 0.4, depth: 0.005 },
        { delay: 0.035, rate: 0.7, depth: 0.003 }
      ];

      const chorusMix = audioCtx.createGain();
      chorusMix.gain.value = 0.5;
      chorusMix.connect(masterGain);

      chorusVoices.forEach(voice => {
        const delay = audioCtx.createDelay(0.1);
        delay.delayTime.value = voice.delay;

        const lfo = audioCtx.createOscillator();
        lfo.type = 'sine';
        lfo.frequency.value = voice.rate;

        const lfoGain = audioCtx.createGain();
        lfoGain.gain.value = voice.depth;

        const voiceGain = audioCtx.createGain();
        voiceGain.gain.value = 0.4;

        // Subtle pitch variation via feedback
        const feedback = audioCtx.createGain();
        feedback.gain.value = 0.2;

        lfo.connect(lfoGain);
        lfoGain.connect(delay.delayTime);

        chorusGain.connect(delay);
        delay.connect(voiceGain);
        delay.connect(feedback);
        feedback.connect(delay);
        voiceGain.connect(chorusMix);

        lfo.start();
        chorusDelays.push(delay);
        chorusLFOs.push(lfo);
      });

      updateFXLevels();
    }

    // Generate reverb impulse response
    function createReverbImpulse(duration, decay) {
      const length = audioCtx.sampleRate * duration;
      const impulse = audioCtx.createBuffer(2, length, audioCtx.sampleRate);

      for (let channel = 0; channel < 2; channel++) {
        const channelData = impulse.getChannelData(channel);
        for (let i = 0; i < length; i++) {
          // Exponential decay with some early reflections
          const env = Math.pow(1 - i / length, decay);
          // Add some randomness and early reflections
          let sample = (Math.random() * 2 - 1) * env;

          // Early reflections at specific times
          if (i < audioCtx.sampleRate * 0.1) {
            const earlyEnv = Math.pow(1 - i / (audioCtx.sampleRate * 0.1), 1);
            sample += (Math.random() * 2 - 1) * earlyEnv * 0.5;
          }

          channelData[i] = sample;
        }
      }
      return impulse;
    }

    function updateFXLevels() {
      if (!audioCtx) return;

      const reverbAmount = parseInt(document.getElementById('reverbSlider').value) / 100;
      const chorusAmount = parseInt(document.getElementById('chorusSlider').value) / 100;

      // Dry level decreases as effects increase
      const dryLevel = 1 - (reverbAmount * 0.3 + chorusAmount * 0.2);
      dryGain.gain.value = Math.max(0.4, dryLevel);

      // Reverb wet level - make it massive
      if (convolver) {
        const reverbWet = reverbAmount * 0.8;
        // Smooth transition
        reverbGain.gain.setTargetAtTime(reverbWet, audioCtx.currentTime, 0.1);
      }

      // Chorus wet level - thick and lush
      if (chorusGain) {
        const chorusWet = chorusAmount * 0.7;
        chorusGain.gain.setTargetAtTime(chorusWet, audioCtx.currentTime, 0.1);
      }
    }

    // Add event listeners for FX sliders
    document.getElementById('reverbSlider').addEventListener('input', updateFXLevels);
    document.getElementById('chorusSlider').addEventListener('input', updateFXLevels);

    function togglePlay() {
      if (!audioCtx) initAudio();
      isPlaying = !isPlaying;

      const btn = document.getElementById('playBtn');
      btn.classList.toggle('playing', isPlaying);
      btn.textContent = isPlaying ? 'â¸' : 'â–¶';

      if (isPlaying) {
        currentStep = 0;
        scheduleNext();
      } else {
        clearTimeout(intervalId);
        document.querySelectorAll('.step').forEach(s => s.classList.remove('playing'));
      }
    }

    function scheduleNext() {
      if (!isPlaying) return;

      const swing = parseInt(document.getElementById('swingSlider').value) / 100;
      const stepDuration = (60 / bpm) / 4 * 1000; // 16th notes
      const swingOffset = currentStep % 2 === 1 ? stepDuration * swing : 0;

      playStep(currentStep);

      intervalId = setTimeout(() => {
        currentStep = (currentStep + 1) % 16;
        scheduleNext();
      }, stepDuration + swingOffset);
    }

    function playStep(step) {
      // Update UI
      document.querySelectorAll('.step').forEach(s => s.classList.remove('playing'));
      document.querySelectorAll(`[data-step="${step}"]`).forEach(s => s.classList.add('playing'));

      // Play sounds
      tracks.forEach((track, ti) => {
        if (pattern[ti][step]) {
          playSound(track.sound, track.volume);
        }
      });

      // Visualizer
      updateVisualizer();
    }

    function updateVisualizer() {
      const bars = document.querySelectorAll('.viz-bar');
      bars.forEach(bar => {
        const height = Math.random() * 50 + 10;
        bar.style.height = height + 'px';
      });
    }

    // Heavy synth drum sounds - routed through FX
    function playSound(type, volume = 1) {
      if (!audioCtx) initAudio();

      const now = audioCtx.currentTime;

      // Create sound output that routes to all FX chains
      const soundOut = audioCtx.createGain();
      soundOut.gain.value = volume * 0.7;

      // Route to dry, reverb, and chorus
      soundOut.connect(dryGain);
      soundOut.connect(reverbGain);
      soundOut.connect(chorusGain);

      switch(type) {
        case 'kick':
          playKick(now, soundOut);
          break;
        case 'snare':
          playSnare(now, soundOut);
          break;
        case 'hihat':
          playHiHat(now, soundOut);
          break;
        case 'clap':
          playClap(now, soundOut);
          break;
        case 'tom':
          playTom(now, soundOut);
          break;
        case 'crash':
          playCrash(now, soundOut);
          break;
        case 'bass':
          playBass(now, soundOut);
          break;
        case 'perc':
          playPerc(now, soundOut);
          break;
      }
    }

    function playKick(time, dest) {
      // Heavy 808-style kick
      const osc = audioCtx.createOscillator();
      const gain = audioCtx.createGain();

      osc.type = 'sine';
      osc.frequency.setValueAtTime(150, time);
      osc.frequency.exponentialRampToValueAtTime(30, time + 0.15);

      gain.gain.setValueAtTime(1, time);
      gain.gain.exponentialRampToValueAtTime(0.01, time + 0.5);

      // Add distortion layer
      const osc2 = audioCtx.createOscillator();
      const gain2 = audioCtx.createGain();
      osc2.type = 'triangle';
      osc2.frequency.setValueAtTime(80, time);
      osc2.frequency.exponentialRampToValueAtTime(20, time + 0.1);
      gain2.gain.setValueAtTime(0.5, time);
      gain2.gain.exponentialRampToValueAtTime(0.01, time + 0.3);

      osc.connect(gain).connect(dest);
      osc2.connect(gain2).connect(dest);

      osc.start(time);
      osc.stop(time + 0.5);
      osc2.start(time);
      osc2.stop(time + 0.3);
    }

    function playSnare(time, dest) {
      // Noise burst + tone
      const noise = createNoise(0.2);
      const noiseGain = audioCtx.createGain();
      const filter = audioCtx.createBiquadFilter();

      filter.type = 'highpass';
      filter.frequency.value = 1000;

      noiseGain.gain.setValueAtTime(1, time);
      noiseGain.gain.exponentialRampToValueAtTime(0.01, time + 0.2);

      noise.connect(filter).connect(noiseGain).connect(dest);
      noise.start(time);
      noise.stop(time + 0.2);

      // Body tone
      const osc = audioCtx.createOscillator();
      const oscGain = audioCtx.createGain();
      osc.type = 'triangle';
      osc.frequency.setValueAtTime(200, time);
      osc.frequency.exponentialRampToValueAtTime(100, time + 0.05);
      oscGain.gain.setValueAtTime(0.7, time);
      oscGain.gain.exponentialRampToValueAtTime(0.01, time + 0.1);

      osc.connect(oscGain).connect(dest);
      osc.start(time);
      osc.stop(time + 0.1);
    }

    function playHiHat(time, dest) {
      // Metallic noise
      const noise = createNoise(0.1);
      const gain = audioCtx.createGain();
      const filter = audioCtx.createBiquadFilter();
      const filter2 = audioCtx.createBiquadFilter();

      filter.type = 'highpass';
      filter.frequency.value = 7000;
      filter2.type = 'bandpass';
      filter2.frequency.value = 10000;

      gain.gain.setValueAtTime(0.5, time);
      gain.gain.exponentialRampToValueAtTime(0.01, time + 0.08);

      noise.connect(filter).connect(filter2).connect(gain).connect(dest);
      noise.start(time);
      noise.stop(time + 0.1);
    }

    function playClap(time, dest) {
      // Layered noise bursts
      for (let i = 0; i < 3; i++) {
        const noise = createNoise(0.15);
        const gain = audioCtx.createGain();
        const filter = audioCtx.createBiquadFilter();

        filter.type = 'bandpass';
        filter.frequency.value = 1500;
        filter.Q.value = 0.5;

        const offset = i * 0.01;
        gain.gain.setValueAtTime(0, time + offset);
        gain.gain.linearRampToValueAtTime(0.8, time + offset + 0.01);
        gain.gain.exponentialRampToValueAtTime(0.01, time + offset + 0.15);

        noise.connect(filter).connect(gain).connect(dest);
        noise.start(time + offset);
        noise.stop(time + offset + 0.15);
      }
    }

    function playTom(time, dest) {
      const osc = audioCtx.createOscillator();
      const gain = audioCtx.createGain();

      osc.type = 'sine';
      osc.frequency.setValueAtTime(200, time);
      osc.frequency.exponentialRampToValueAtTime(80, time + 0.2);

      gain.gain.setValueAtTime(0.8, time);
      gain.gain.exponentialRampToValueAtTime(0.01, time + 0.3);

      osc.connect(gain).connect(dest);
      osc.start(time);
      osc.stop(time + 0.3);
    }

    function playCrash(time, dest) {
      const noise = createNoise(1);
      const gain = audioCtx.createGain();
      const filter = audioCtx.createBiquadFilter();

      filter.type = 'highpass';
      filter.frequency.value = 5000;

      gain.gain.setValueAtTime(0.6, time);
      gain.gain.exponentialRampToValueAtTime(0.01, time + 1);

      noise.connect(filter).connect(gain).connect(dest);
      noise.start(time);
      noise.stop(time + 1);
    }

    function playBass(time, dest) {
      // Sub bass hit
      const osc = audioCtx.createOscillator();
      const osc2 = audioCtx.createOscillator();
      const gain = audioCtx.createGain();

      osc.type = 'sine';
      osc.frequency.setValueAtTime(55, time);
      osc2.type = 'square';
      osc2.frequency.setValueAtTime(55, time);

      const subGain = audioCtx.createGain();
      subGain.gain.value = 0.3;

      gain.gain.setValueAtTime(0.8, time);
      gain.gain.exponentialRampToValueAtTime(0.01, time + 0.3);

      osc.connect(gain).connect(dest);
      osc2.connect(subGain).connect(gain);

      osc.start(time);
      osc.stop(time + 0.3);
      osc2.start(time);
      osc2.stop(time + 0.3);
    }

    function playPerc(time, dest) {
      // Metallic percussion
      const osc = audioCtx.createOscillator();
      const osc2 = audioCtx.createOscillator();
      const gain = audioCtx.createGain();

      osc.type = 'square';
      osc.frequency.setValueAtTime(800, time);
      osc2.type = 'sawtooth';
      osc2.frequency.setValueAtTime(1200, time);

      gain.gain.setValueAtTime(0.4, time);
      gain.gain.exponentialRampToValueAtTime(0.01, time + 0.05);

      osc.connect(gain).connect(dest);
      osc2.connect(gain);

      osc.start(time);
      osc.stop(time + 0.05);
      osc2.start(time);
      osc2.stop(time + 0.05);
    }

    function createNoise(duration) {
      const bufferSize = audioCtx.sampleRate * duration;
      const buffer = audioCtx.createBuffer(1, bufferSize, audioCtx.sampleRate);
      const output = buffer.getChannelData(0);

      for (let i = 0; i < bufferSize; i++) {
        output[i] = Math.random() * 2 - 1;
      }

      const source = audioCtx.createBufferSource();
      source.buffer = buffer;
      return source;
    }

    function updateBPM() {
      bpm = parseInt(document.getElementById('bpmInput').value) || 120;
      bpm = Math.max(60, Math.min(200, bpm));
      document.getElementById('bpmInput').value = bpm;
    }

    function clearAll() {
      pattern.forEach((track, ti) => {
        track.fill(false);
        track.forEach((_, si) => updateStepUI(ti, si));
      });
    }

    function randomize() {
      pattern.forEach((track, ti) => {
        track.forEach((_, si) => {
          pattern[ti][si] = Math.random() < 0.25;
          updateStepUI(ti, si);
        });
      });
    }

    function loadPreset(name) {
      clearAll();
      const presets = {
        basic: [
          [1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0], // kick
          [0,0,0,0,1,0,0,0,0,0,0,0,1,0,0,0], // snare
          [1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0], // hihat
          [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0], // clap
          [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0], // tom
          [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0], // crash
          [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0], // bass
          [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]  // perc
        ],
        house: [
          [1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0], // kick
          [0,0,0,0,1,0,0,0,0,0,0,0,1,0,0,0], // snare
          [0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0], // hihat (offbeat)
          [0,0,0,0,1,0,0,0,0,0,0,0,1,0,0,1], // clap
          [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0], // tom
          [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0], // crash
          [1,0,0,1,0,0,1,0,0,0,1,0,0,1,0,0], // bass
          [0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,1]  // perc
        ],
        trap: [
          [1,0,0,0,0,0,1,0,0,0,1,0,0,0,0,0], // kick
          [0,0,0,0,1,0,0,0,0,0,0,0,1,0,0,0], // snare
          [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1], // hihat
          [0,0,0,0,1,0,0,0,0,0,0,0,1,0,0,0], // clap
          [0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0], // tom
          [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0], // crash
          [1,0,0,0,0,0,1,0,0,0,1,0,0,0,0,1], // bass
          [0,0,1,0,0,0,1,0,0,1,0,0,0,0,1,0]  // perc
        ],
        dnb: [
          [1,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0], // kick
          [0,0,0,0,1,0,0,1,0,0,0,0,1,0,0,0], // snare
          [1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0], // hihat
          [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0], // clap
          [0,0,0,0,0,0,0,0,0,0,0,1,0,0,1,0], // tom
          [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0], // crash
          [1,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0], // bass
          [0,0,1,0,0,0,1,0,0,0,0,0,0,1,0,0]  // perc
        ],
        techno: [
          [1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0], // kick
          [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0], // snare
          [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1], // hihat
          [0,0,0,0,1,0,0,0,0,0,0,0,1,0,0,0], // clap
          [0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0], // tom
          [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0], // crash
          [1,0,0,1,0,0,1,0,1,0,0,1,0,0,1,0], // bass
          [0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,1]  // perc
        ]
      };

      const preset = presets[name];
      if (preset) {
        preset.forEach((track, ti) => {
          track.forEach((step, si) => {
            pattern[ti][si] = step === 1;
            updateStepUI(ti, si);
          });
        });
      }
    }

    // Start
    init();
  </script>
</body>
</html>
