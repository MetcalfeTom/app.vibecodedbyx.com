<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>SYNTH STATION</title>
  <link rel="icon" href="https://emojicdn.elk.sh/ðŸŽ¹">
  <meta property="og:title" content="SYNTH STATION">
  <meta property="og:description" content="Drum machine + saw lead synth with piano roll">
  <meta property="og:image" content="https://sloppy.live/drum-machine/og-image.png">
  <meta property="og:url" content="https://sloppy.live/drum-machine">
  <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&display=swap" rel="stylesheet">
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }

    :root {
      --magenta: #f0f;
      --cyan: #0ff;
      --yellow: #ff0;
      --green: #0f0;
      --orange: #f80;
      --red: #f44;
      --bg: #0a0a0f;
    }

    body {
      background: var(--bg);
      min-height: 100vh;
      font-family: 'Orbitron', sans-serif;
      color: #fff;
      overflow-x: hidden;
    }

    .container {
      max-width: 1100px;
      margin: 0 auto;
      padding: 20px;
    }

    header {
      text-align: center;
      margin-bottom: 30px;
    }

    h1 {
      font-size: 2.5em;
      font-weight: 900;
      background: linear-gradient(90deg, var(--magenta), var(--cyan));
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
      text-shadow: 0 0 30px rgba(255,0,255,0.5);
      letter-spacing: 4px;
    }

    .controls {
      display: flex;
      justify-content: center;
      align-items: center;
      gap: 20px;
      margin-bottom: 25px;
      flex-wrap: wrap;
    }

    .play-btn {
      width: 70px;
      height: 70px;
      border-radius: 50%;
      border: 3px solid var(--magenta);
      background: rgba(255,0,255,0.1);
      color: var(--magenta);
      font-size: 1.8em;
      cursor: pointer;
      transition: all 0.2s;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .play-btn:hover {
      background: var(--magenta);
      color: #000;
      box-shadow: 0 0 30px var(--magenta);
    }

    .play-btn.playing {
      border-color: var(--cyan);
      color: var(--cyan);
      animation: pulse 0.5s ease-in-out infinite;
    }

    .play-btn.playing:hover {
      background: var(--cyan);
    }

    @keyframes pulse {
      0%, 100% { box-shadow: 0 0 10px var(--cyan); }
      50% { box-shadow: 0 0 30px var(--cyan); }
    }

    .bpm-control {
      display: flex;
      align-items: center;
      gap: 10px;
    }

    .bpm-control label {
      color: var(--cyan);
      font-size: 0.9em;
    }

    .bpm-control input {
      width: 80px;
      padding: 10px;
      background: #111;
      border: 2px solid var(--cyan);
      color: var(--cyan);
      font-family: inherit;
      font-size: 1.2em;
      text-align: center;
      border-radius: 8px;
    }

    .bpm-control input:focus {
      outline: none;
      box-shadow: 0 0 15px var(--cyan);
    }

    .action-btns {
      display: flex;
      gap: 10px;
    }

    .action-btn {
      padding: 10px 18px;
      background: transparent;
      border: 2px solid #444;
      color: #888;
      font-family: inherit;
      font-size: 0.8em;
      cursor: pointer;
      border-radius: 6px;
      transition: all 0.2s;
    }

    .action-btn:hover {
      border-color: var(--yellow);
      color: var(--yellow);
    }

    .sequencer {
      background: #111;
      border-radius: 15px;
      padding: 20px;
      border: 1px solid #222;
      overflow-x: auto;
    }

    .track {
      display: flex;
      align-items: center;
      margin-bottom: 8px;
      gap: 10px;
    }

    .track:last-child { margin-bottom: 0; }

    .track-info {
      width: 90px;
      flex-shrink: 0;
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .track-name {
      font-size: 0.75em;
      font-weight: 700;
      text-transform: uppercase;
      letter-spacing: 1px;
      width: 55px;
    }

    .track-vol {
      width: 25px;
      height: 25px;
      background: #222;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      font-size: 0.7em;
      transition: all 0.2s;
    }

    .track-vol:hover {
      transform: scale(1.1);
    }

    .steps {
      display: flex;
      gap: 4px;
    }

    .step {
      width: 40px;
      height: 40px;
      background: #1a1a1a;
      border: 2px solid #333;
      border-radius: 6px;
      cursor: pointer;
      transition: all 0.1s;
      position: relative;
    }

    .step:hover {
      border-color: #555;
      transform: scale(1.05);
    }

    .step.active {
      border-color: var(--track-color);
      background: var(--track-color);
      box-shadow: 0 0 15px var(--track-color);
    }

    .step.playing {
      transform: scale(1.1);
      box-shadow: 0 0 20px #fff !important;
    }

    .step.beat-marker {
      border-color: #444;
    }

    .step.beat-marker.active {
      border-color: var(--track-color);
    }

    /* Track colors */
    .track[data-sound="kick"] { --track-color: var(--magenta); }
    .track[data-sound="kick"] .track-name { color: var(--magenta); }

    .track[data-sound="snare"] { --track-color: var(--cyan); }
    .track[data-sound="snare"] .track-name { color: var(--cyan); }

    .track[data-sound="hihat"] { --track-color: var(--yellow); }
    .track[data-sound="hihat"] .track-name { color: var(--yellow); }

    .track[data-sound="clap"] { --track-color: var(--green); }
    .track[data-sound="clap"] .track-name { color: var(--green); }

    .track[data-sound="tom"] { --track-color: var(--orange); }
    .track[data-sound="tom"] .track-name { color: var(--orange); }

    .track[data-sound="crash"] { --track-color: var(--red); }
    .track[data-sound="crash"] .track-name { color: var(--red); }

    .track[data-sound="bass"] { --track-color: #a0f; }
    .track[data-sound="bass"] .track-name { color: #a0f; }

    .track[data-sound="perc"] { --track-color: #0af; }
    .track[data-sound="perc"] .track-name { color: #0af; }

    .visualizer {
      height: 80px;
      background: #111;
      border-radius: 10px;
      margin-top: 20px;
      overflow: hidden;
      display: flex;
      align-items: flex-end;
      justify-content: center;
      gap: 3px;
      padding: 10px;
    }

    .viz-bar {
      width: 8px;
      background: linear-gradient(to top, var(--magenta), var(--cyan));
      border-radius: 4px 4px 0 0;
      transition: height 0.05s;
      min-height: 4px;
    }

    .swing-control, .fx-control {
      display: flex;
      align-items: center;
      gap: 10px;
    }

    .swing-control label, .fx-control label {
      color: var(--orange);
      font-size: 0.8em;
    }

    .fx-control.reverb label { color: var(--magenta); }
    .fx-control.chorus label { color: var(--cyan); }

    .swing-slider, .fx-slider {
      -webkit-appearance: none;
      width: 80px;
      height: 8px;
      background: #222;
      border-radius: 4px;
      outline: none;
    }

    .swing-slider::-webkit-slider-thumb, .fx-slider::-webkit-slider-thumb {
      -webkit-appearance: none;
      width: 18px;
      height: 18px;
      background: var(--orange);
      border-radius: 50%;
      cursor: pointer;
      box-shadow: 0 0 10px var(--orange);
    }

    .fx-control.reverb .fx-slider::-webkit-slider-thumb {
      background: var(--magenta);
      box-shadow: 0 0 10px var(--magenta);
    }

    .fx-control.chorus .fx-slider::-webkit-slider-thumb {
      background: var(--cyan);
      box-shadow: 0 0 10px var(--cyan);
    }

    .fx-row {
      display: flex;
      justify-content: center;
      gap: 25px;
      margin-bottom: 20px;
      flex-wrap: wrap;
      padding: 12px 20px;
      background: rgba(255,255,255,0.03);
      border-radius: 10px;
      border: 1px solid #222;
    }

    .fx-row .fx-label {
      font-size: 0.7em;
      color: #555;
      text-transform: uppercase;
      letter-spacing: 2px;
      margin-right: 10px;
    }

    .backlink {
      position: fixed;
      bottom: 5px;
      right: 10px;
      color: #333;
      text-decoration: none;
      font-size: 0.6em;
    }

    .presets {
      display: flex;
      gap: 8px;
      justify-content: center;
      margin-top: 15px;
      flex-wrap: wrap;
    }

    .preset-btn {
      padding: 8px 14px;
      background: #1a1a1a;
      border: 1px solid #333;
      color: #666;
      font-family: inherit;
      font-size: 0.7em;
      cursor: pointer;
      border-radius: 4px;
      transition: all 0.2s;
    }

    .preset-btn:hover {
      border-color: var(--magenta);
      color: var(--magenta);
    }

    /* Piano Roll Styles */
    .piano-roll-section {
      margin-top: 25px;
    }

    .section-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 15px;
    }

    .section-title {
      font-size: 1em;
      color: var(--yellow);
      text-shadow: 0 0 10px var(--yellow);
      letter-spacing: 2px;
    }

    .lead-controls {
      display: flex;
      gap: 15px;
      align-items: center;
    }

    .lead-control {
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .lead-control label {
      font-size: 0.7em;
      color: #888;
    }

    .lead-slider {
      -webkit-appearance: none;
      width: 60px;
      height: 6px;
      background: #222;
      border-radius: 3px;
    }

    .lead-slider::-webkit-slider-thumb {
      -webkit-appearance: none;
      width: 14px;
      height: 14px;
      background: var(--yellow);
      border-radius: 50%;
      cursor: pointer;
      box-shadow: 0 0 8px var(--yellow);
    }

    /* Arpeggiator Controls */
    .arp-row {
      display: flex;
      align-items: center;
      gap: 15px;
      margin-top: 12px;
      padding: 10px 15px;
      background: rgba(255,255,0,0.05);
      border-radius: 8px;
      border: 1px solid rgba(255,255,0,0.2);
      flex-wrap: wrap;
    }

    .arp-toggle {
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .arp-toggle label {
      font-size: 0.75em;
      color: var(--green);
      font-weight: 700;
      letter-spacing: 1px;
    }

    .toggle-btn {
      width: 50px;
      height: 26px;
      background: #222;
      border: 2px solid #444;
      border-radius: 13px;
      cursor: pointer;
      position: relative;
      transition: all 0.2s;
    }

    .toggle-btn::after {
      content: '';
      position: absolute;
      width: 18px;
      height: 18px;
      background: #666;
      border-radius: 50%;
      top: 2px;
      left: 2px;
      transition: all 0.2s;
    }

    .toggle-btn.active {
      background: rgba(0,255,0,0.2);
      border-color: var(--green);
    }

    .toggle-btn.active::after {
      background: var(--green);
      left: 26px;
      box-shadow: 0 0 10px var(--green);
    }

    .arp-control {
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .arp-control label {
      font-size: 0.65em;
      color: #888;
      text-transform: uppercase;
    }

    .arp-select {
      background: #1a1a1a;
      border: 1px solid #444;
      color: var(--green);
      padding: 6px 10px;
      border-radius: 5px;
      font-family: inherit;
      font-size: 0.7em;
      cursor: pointer;
    }

    .arp-select:focus {
      outline: none;
      border-color: var(--green);
      box-shadow: 0 0 8px rgba(0,255,0,0.3);
    }

    .arp-slider {
      -webkit-appearance: none;
      width: 60px;
      height: 6px;
      background: #222;
      border-radius: 3px;
    }

    .arp-slider::-webkit-slider-thumb {
      -webkit-appearance: none;
      width: 14px;
      height: 14px;
      background: var(--green);
      border-radius: 50%;
      cursor: pointer;
      box-shadow: 0 0 8px var(--green);
    }

    .arp-rate-display {
      font-size: 0.7em;
      color: var(--green);
      min-width: 35px;
      text-align: center;
    }

    /* Sidechain Controls */
    .sidechain-row {
      display: flex;
      align-items: center;
      gap: 15px;
      margin-top: 10px;
      padding: 10px 15px;
      background: rgba(255,0,255,0.05);
      border-radius: 8px;
      border: 1px solid rgba(255,0,255,0.2);
      flex-wrap: wrap;
    }

    .sidechain-toggle {
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .sidechain-toggle label {
      font-size: 0.7em;
      color: var(--magenta);
      font-weight: 700;
      letter-spacing: 1px;
    }

    .toggle-btn.sidechain.active {
      background: rgba(255,0,255,0.2);
      border-color: var(--magenta);
    }

    .toggle-btn.sidechain.active::after {
      background: var(--magenta);
      box-shadow: 0 0 10px var(--magenta);
    }

    .sc-control {
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .sc-control label {
      font-size: 0.65em;
      color: #888;
      text-transform: uppercase;
    }

    .sc-slider {
      -webkit-appearance: none;
      width: 60px;
      height: 6px;
      background: #222;
      border-radius: 3px;
    }

    .sc-slider::-webkit-slider-thumb {
      -webkit-appearance: none;
      width: 14px;
      height: 14px;
      background: var(--magenta);
      border-radius: 50%;
      cursor: pointer;
      box-shadow: 0 0 8px var(--magenta);
    }

    .randomize-btn {
      padding: 8px 14px;
      background: rgba(0,255,255,0.1);
      border: 2px solid var(--cyan);
      color: var(--cyan);
      font-family: inherit;
      font-size: 0.7em;
      font-weight: 700;
      cursor: pointer;
      border-radius: 6px;
      transition: all 0.2s;
      letter-spacing: 1px;
    }

    .randomize-btn:hover {
      background: var(--cyan);
      color: #000;
      box-shadow: 0 0 15px var(--cyan);
    }

    .scale-select {
      background: #1a1a1a;
      border: 1px solid var(--cyan);
      color: var(--cyan);
      padding: 6px 10px;
      border-radius: 5px;
      font-family: inherit;
      font-size: 0.65em;
      cursor: pointer;
    }

    .scale-select:focus {
      outline: none;
      box-shadow: 0 0 8px rgba(0,255,255,0.3);
    }

    .melody-row {
      display: flex;
      align-items: center;
      gap: 12px;
      margin-top: 10px;
      padding: 10px 15px;
      background: rgba(0,255,255,0.05);
      border-radius: 8px;
      border: 1px solid rgba(0,255,255,0.2);
      flex-wrap: wrap;
    }

    .melody-row label {
      font-size: 0.65em;
      color: #888;
      text-transform: uppercase;
    }

    .piano-roll {
      background: #0d0d15;
      border-radius: 12px;
      padding: 15px;
      border: 1px solid #222;
      overflow-x: auto;
    }

    .piano-roll-grid {
      display: flex;
      gap: 0;
    }

    .piano-keys {
      display: flex;
      flex-direction: column;
      gap: 2px;
      margin-right: 8px;
      flex-shrink: 0;
    }

    .piano-key {
      width: 45px;
      height: 22px;
      display: flex;
      align-items: center;
      justify-content: flex-end;
      padding-right: 8px;
      font-size: 0.6em;
      font-weight: 600;
      border-radius: 3px 0 0 3px;
      cursor: pointer;
      transition: all 0.1s;
    }

    .piano-key.white {
      background: linear-gradient(90deg, #ddd, #fff);
      color: #333;
    }

    .piano-key.black {
      background: linear-gradient(90deg, #222, #444);
      color: #aaa;
    }

    .piano-key:hover {
      filter: brightness(1.2);
    }

    .note-grid {
      display: flex;
      flex-direction: column;
      gap: 2px;
    }

    .note-row {
      display: flex;
      gap: 2px;
    }

    .note-cell {
      width: 38px;
      height: 22px;
      background: #151520;
      border: 1px solid #252535;
      border-radius: 3px;
      cursor: pointer;
      transition: all 0.1s;
    }

    .note-cell:hover {
      background: #252535;
      border-color: var(--yellow);
    }

    .note-cell.active {
      background: var(--yellow);
      border-color: var(--yellow);
      box-shadow: 0 0 10px var(--yellow);
    }

    .note-cell.playing {
      box-shadow: 0 0 15px #fff;
    }

    .note-cell.beat-marker {
      border-color: #333;
    }

    .note-row.black-key .note-cell {
      background: #101018;
    }

    .note-row.black-key .note-cell.active {
      background: #cc0;
    }

    /* Legato note spans */
    .note-cell.note-start {
      border-radius: 3px 0 0 3px;
      border-right: none;
    }

    .note-cell.note-middle {
      border-radius: 0;
      border-left: none;
      border-right: none;
    }

    .note-cell.note-end {
      border-radius: 0 3px 3px 0;
      border-left: none;
    }

    .note-cell.note-single {
      border-radius: 3px;
    }

    .note-cell.dragging {
      background: rgba(255, 255, 0, 0.5);
      border-color: var(--yellow);
    }

    @media (max-width: 700px) {
      h1 { font-size: 1.5em; }
      .step { width: 30px; height: 30px; }
      .track-info { width: 70px; }
      .track-name { font-size: 0.65em; width: 45px; }
      .controls { gap: 10px; }
      .play-btn { width: 55px; height: 55px; font-size: 1.4em; }
      .note-cell { width: 28px; height: 18px; }
      .piano-key { width: 35px; height: 18px; font-size: 0.5em; }
    }
  </style>
</head>
<body>
  <div class="container">
    <header>
      <h1>SYNTH STATION</h1>
    </header>

    <div class="controls">
      <button class="play-btn" id="playBtn" onclick="togglePlay()">â–¶</button>

      <div class="bpm-control">
        <label>BPM</label>
        <input type="number" id="bpmInput" value="120" min="60" max="200" onchange="updateBPM()">
      </div>

      <div class="swing-control">
        <label>SWING</label>
        <input type="range" class="swing-slider" id="swingSlider" min="0" max="50" value="0">
      </div>

      <div class="action-btns">
        <button class="action-btn" onclick="clearAll()">CLEAR</button>
        <button class="action-btn" onclick="randomize()">RANDOM</button>
      </div>
    </div>

    <div class="fx-row">
      <span class="fx-label">FX</span>
      <div class="fx-control reverb">
        <label>REVERB</label>
        <input type="range" class="fx-slider" id="reverbSlider" min="0" max="100" value="40">
      </div>
      <div class="fx-control chorus">
        <label>CHORUS</label>
        <input type="range" class="fx-slider" id="chorusSlider" min="0" max="100" value="30">
      </div>
    </div>

    <div class="sequencer" id="sequencer"></div>

    <div class="presets">
      <button class="preset-btn" onclick="loadPreset('basic')">BASIC</button>
      <button class="preset-btn" onclick="loadPreset('house')">HOUSE</button>
      <button class="preset-btn" onclick="loadPreset('trap')">TRAP</button>
      <button class="preset-btn" onclick="loadPreset('dnb')">D&B</button>
      <button class="preset-btn" onclick="loadPreset('techno')">TECHNO</button>
    </div>

    <!-- Lead Synth Piano Roll -->
    <div class="piano-roll-section">
      <div class="section-header">
        <span class="section-title">â–² SAW LEAD</span>
        <div class="lead-controls">
          <div class="lead-control">
            <label>GLIDE</label>
            <input type="range" class="lead-slider" id="glideSlider" min="0" max="100" value="50">
          </div>
          <div class="lead-control">
            <label>DETUNE</label>
            <input type="range" class="lead-slider" id="detuneSlider" min="0" max="100" value="60">
          </div>
          <div class="lead-control">
            <label>FILTER</label>
            <input type="range" class="lead-slider" id="filterSlider" min="0" max="100" value="70">
          </div>
          <button class="action-btn" onclick="clearLead()">CLEAR</button>
        </div>
      </div>

      <!-- Arpeggiator Controls -->
      <div class="arp-row">
        <div class="arp-toggle">
          <label>ARP</label>
          <div class="toggle-btn" id="arpToggle" onclick="toggleArp()"></div>
        </div>
        <div class="arp-control">
          <label>MODE</label>
          <select class="arp-select" id="arpMode">
            <option value="up">UP â†‘</option>
            <option value="down">DOWN â†“</option>
            <option value="updown">UP-DOWN â†•</option>
            <option value="downup">DOWN-UP â†•</option>
            <option value="random">RANDOM âš¡</option>
            <option value="chord">CHORD â–£</option>
          </select>
        </div>
        <div class="arp-control">
          <label>RATE</label>
          <input type="range" class="arp-slider" id="arpRate" min="1" max="8" value="4" oninput="updateArpRateDisplay()">
          <span class="arp-rate-display" id="arpRateDisplay">1/4</span>
        </div>
        <div class="arp-control">
          <label>OCTAVES</label>
          <select class="arp-select" id="arpOctaves">
            <option value="1">1</option>
            <option value="2" selected>2</option>
            <option value="3">3</option>
          </select>
        </div>
      </div>

      <!-- Sidechain Compressor -->
      <div class="sidechain-row">
        <div class="sidechain-toggle">
          <label>SIDECHAIN</label>
          <div class="toggle-btn sidechain" id="sidechainToggle" onclick="toggleSidechain()"></div>
        </div>
        <div class="sc-control">
          <label>AMOUNT</label>
          <input type="range" class="sc-slider" id="scAmount" min="0" max="100" value="80">
        </div>
        <div class="sc-control">
          <label>RELEASE</label>
          <input type="range" class="sc-slider" id="scRelease" min="10" max="500" value="150">
        </div>
        <div class="sc-control">
          <label>ATTACK</label>
          <input type="range" class="sc-slider" id="scAttack" min="1" max="50" value="5">
        </div>
      </div>

      <!-- Melody Randomizer -->
      <div class="melody-row">
        <label>MELODY</label>
        <select class="scale-select" id="scaleSelect">
          <option value="chromatic">Chromatic</option>
          <option value="major" selected>Major</option>
          <option value="minor">Minor</option>
          <option value="pentatonic">Pentatonic</option>
          <option value="blues">Blues</option>
          <option value="dorian">Dorian</option>
        </select>
        <select class="scale-select" id="rootSelect">
          <option value="0">C</option>
          <option value="1">C#</option>
          <option value="2">D</option>
          <option value="3">D#</option>
          <option value="4">E</option>
          <option value="5">F</option>
          <option value="6">F#</option>
          <option value="7">G</option>
          <option value="8">G#</option>
          <option value="9">A</option>
          <option value="10">A#</option>
          <option value="11">B</option>
        </select>
        <select class="scale-select" id="densitySelect">
          <option value="25">Sparse</option>
          <option value="50" selected>Medium</option>
          <option value="75">Dense</option>
          <option value="100">Full</option>
        </select>
        <button class="randomize-btn" onclick="randomizeMelody()">ðŸŽ² RANDOMIZE</button>
      </div>

      <div class="piano-roll">
        <div class="piano-roll-grid">
          <div class="piano-keys" id="pianoKeys"></div>
          <div class="note-grid" id="noteGrid"></div>
        </div>
      </div>
    </div>

    <div class="visualizer" id="visualizer"></div>
  </div>

  <a href="https://sloppy.live" class="backlink">sloppy.live</a>

  <script>
    // Audio context
    let audioCtx = null;
    let isPlaying = false;
    let currentStep = 0;
    let intervalId = null;
    let bpm = 120;

    // FX nodes
    let masterGain = null;
    let dryGain = null;
    let reverbGain = null;
    let chorusGain = null;
    let convolver = null;
    let chorusDelays = [];
    let chorusLFOs = [];

    // Lead synth state
    let leadOscs = [];
    let leadGain = null;
    let leadFilter = null;
    let lastLeadFreq = 0;

    // Arpeggiator state
    let arpEnabled = false;
    let arpIndex = 0;
    let arpDirection = 1; // 1 = up, -1 = down
    let arpIntervalId = null;
    let arpNotes = []; // Current notes to arpeggiate

    // Sidechain state
    let sidechainEnabled = false;
    let leadSidechainGain = null; // Gain node for ducking the lead

    // Piano roll notes (2 octaves: C3 to B4) - top to bottom = high to low
    const leadNotes = [
      { note: 'B4', freq: 493.88, black: false },
      { note: 'A#4', freq: 466.16, black: true },
      { note: 'A4', freq: 440.00, black: false },
      { note: 'G#4', freq: 415.30, black: true },
      { note: 'G4', freq: 392.00, black: false },
      { note: 'F#4', freq: 369.99, black: true },
      { note: 'F4', freq: 349.23, black: false },
      { note: 'E4', freq: 329.63, black: false },
      { note: 'D#4', freq: 311.13, black: true },
      { note: 'D4', freq: 293.66, black: false },
      { note: 'C#4', freq: 277.18, black: true },
      { note: 'C4', freq: 261.63, black: false },
      { note: 'B3', freq: 246.94, black: false },
      { note: 'A#3', freq: 233.08, black: true },
      { note: 'A3', freq: 220.00, black: false },
      { note: 'G#3', freq: 207.65, black: true },
      { note: 'G3', freq: 196.00, black: false },
      { note: 'F#3', freq: 185.00, black: true },
      { note: 'F3', freq: 174.61, black: false },
      { note: 'E3', freq: 164.81, black: false },
      { note: 'D#3', freq: 155.56, black: true },
      { note: 'D3', freq: 146.83, black: false },
      { note: 'C#3', freq: 138.59, black: true },
      { note: 'C3', freq: 130.81, black: false }
    ];

    // Lead pattern: each step can have one note (index into leadNotes) or -1 for none
    const leadPattern = Array(16).fill(-1);
    // Note lengths: how many steps each note sustains (1 = single step, 2+ = legato)
    const leadNoteLengths = Array(16).fill(1);

    // Drag state for legato
    let isDragging = false;
    let dragStartStep = -1;
    let dragNoteIdx = -1;
    let dragCurrentStep = -1;

    // Tracks config
    const tracks = [
      { name: 'KICK', sound: 'kick', volume: 1 },
      { name: 'SNARE', sound: 'snare', volume: 0.9 },
      { name: 'HI-HAT', sound: 'hihat', volume: 0.7 },
      { name: 'CLAP', sound: 'clap', volume: 0.8 },
      { name: 'TOM', sound: 'tom', volume: 0.8 },
      { name: 'CRASH', sound: 'crash', volume: 0.6 },
      { name: 'BASS', sound: 'bass', volume: 0.9 },
      { name: 'PERC', sound: 'perc', volume: 0.7 }
    ];

    // Pattern data: 16 steps per track
    const pattern = tracks.map(() => Array(16).fill(false));

    // Initialize
    function init() {
      renderSequencer();
      renderPianoRoll();
      renderVisualizer();
      loadPreset('basic');
    }

    function renderPianoRoll() {
      const keysContainer = document.getElementById('pianoKeys');
      const gridContainer = document.getElementById('noteGrid');

      // Render piano keys
      keysContainer.innerHTML = leadNotes.map((n, i) => `
        <div class="piano-key ${n.black ? 'black' : 'white'}"
             onclick="previewLeadNote(${i})">${n.note}</div>
      `).join('');

      // Render note grid
      gridContainer.innerHTML = leadNotes.map((n, noteIdx) => `
        <div class="note-row ${n.black ? 'black-key' : ''}">
          ${Array(16).fill(0).map((_, stepIdx) => `
            <div class="note-cell ${stepIdx % 4 === 0 ? 'beat-marker' : ''}"
                 data-note="${noteIdx}"
                 data-step="${stepIdx}"
                 onmousedown="startNoteDrag(event, ${noteIdx}, ${stepIdx})"
                 onmouseenter="updateNoteDrag(${noteIdx}, ${stepIdx})"
                 ontouchstart="startNoteDrag(event, ${noteIdx}, ${stepIdx})"
                 ontouchmove="handleTouchMove(event)"></div>
          `).join('')}
        </div>
      `).join('');

      // Add global mouse up listener
      document.addEventListener('mouseup', endNoteDrag);
      document.addEventListener('touchend', endNoteDrag);
    }

    // === DRAG-BASED NOTE ENTRY FOR LEGATO ===
    function startNoteDrag(event, noteIdx, stepIdx) {
      event.preventDefault();
      if (!audioCtx) initAudio();

      // If clicking on an existing note, remove it
      if (leadPattern[stepIdx] === noteIdx) {
        clearNoteAt(stepIdx);
        return;
      }

      // Clear any existing note at this step
      if (leadPattern[stepIdx] >= 0) {
        clearNoteAt(stepIdx);
      }

      // Also check if this step is part of a longer note from a previous step
      for (let i = 0; i < stepIdx; i++) {
        if (leadPattern[i] >= 0) {
          const noteEnd = i + leadNoteLengths[i];
          if (noteEnd > stepIdx) {
            // Truncate the previous note
            leadNoteLengths[i] = stepIdx - i;
            refreshNoteDisplay();
          }
        }
      }

      isDragging = true;
      dragStartStep = stepIdx;
      dragNoteIdx = noteIdx;
      dragCurrentStep = stepIdx;

      // Set initial note
      leadPattern[stepIdx] = noteIdx;
      leadNoteLengths[stepIdx] = 1;

      previewLeadNote(noteIdx);
      refreshNoteDisplay();
      showDragPreview();
    }

    function updateNoteDrag(noteIdx, stepIdx) {
      if (!isDragging || noteIdx !== dragNoteIdx) return;

      // Only allow dragging to the right
      if (stepIdx >= dragStartStep) {
        dragCurrentStep = stepIdx;
        showDragPreview();
      }
    }

    function handleTouchMove(event) {
      if (!isDragging) return;

      const touch = event.touches[0];
      const element = document.elementFromPoint(touch.clientX, touch.clientY);
      if (element && element.classList.contains('note-cell')) {
        const noteIdx = parseInt(element.dataset.note);
        const stepIdx = parseInt(element.dataset.step);
        updateNoteDrag(noteIdx, stepIdx);
      }
    }

    function endNoteDrag() {
      if (!isDragging) return;

      // Finalize the note length
      const length = dragCurrentStep - dragStartStep + 1;
      leadNoteLengths[dragStartStep] = length;

      // Clear any notes that this new note overlaps
      for (let i = dragStartStep + 1; i <= dragCurrentStep; i++) {
        if (leadPattern[i] >= 0) {
          leadPattern[i] = -1;
          leadNoteLengths[i] = 1;
        }
      }

      isDragging = false;
      dragStartStep = -1;
      dragNoteIdx = -1;
      dragCurrentStep = -1;

      clearDragPreview();
      refreshNoteDisplay();
    }

    function showDragPreview() {
      clearDragPreview();
      for (let s = dragStartStep; s <= dragCurrentStep; s++) {
        const cell = document.querySelector(`.note-cell[data-note="${dragNoteIdx}"][data-step="${s}"]`);
        if (cell) {
          cell.classList.add('dragging');
        }
      }
    }

    function clearDragPreview() {
      document.querySelectorAll('.note-cell.dragging').forEach(c => c.classList.remove('dragging'));
    }

    function clearNoteAt(stepIdx) {
      // Find if this step is the start of a note or part of a longer note
      if (leadPattern[stepIdx] >= 0) {
        // It's the start of a note, clear it
        leadPattern[stepIdx] = -1;
        leadNoteLengths[stepIdx] = 1;
      } else {
        // Check if it's part of a previous note
        for (let i = 0; i < stepIdx; i++) {
          if (leadPattern[i] >= 0) {
            const noteEnd = i + leadNoteLengths[i] - 1;
            if (noteEnd >= stepIdx) {
              // Truncate the note to end before this step
              leadNoteLengths[i] = stepIdx - i;
              break;
            }
          }
        }
      }
      refreshNoteDisplay();
    }

    function refreshNoteDisplay() {
      // Clear all active states and classes
      document.querySelectorAll('.note-cell').forEach(c => {
        c.classList.remove('active', 'note-start', 'note-middle', 'note-end', 'note-single');
      });

      // Redraw all notes with their lengths
      for (let step = 0; step < 16; step++) {
        const noteIdx = leadPattern[step];
        if (noteIdx >= 0) {
          const length = leadNoteLengths[step];
          for (let s = step; s < step + length && s < 16; s++) {
            const cell = document.querySelector(`.note-cell[data-note="${noteIdx}"][data-step="${s}"]`);
            if (cell) {
              cell.classList.add('active');
              if (length === 1) {
                cell.classList.add('note-single');
              } else if (s === step) {
                cell.classList.add('note-start');
              } else if (s === step + length - 1) {
                cell.classList.add('note-end');
              } else {
                cell.classList.add('note-middle');
              }
            }
          }
        }
      }
    }

    function updateLeadNoteUI(noteIdx, stepIdx, active) {
      const cell = document.querySelector(`.note-cell[data-note="${noteIdx}"][data-step="${stepIdx}"]`);
      if (cell) {
        cell.classList.toggle('active', active);
      }
    }

    function clearLead() {
      leadPattern.fill(-1);
      leadNoteLengths.fill(1);
      document.querySelectorAll('.note-cell.active').forEach(c => {
        c.classList.remove('active', 'note-start', 'note-middle', 'note-end', 'note-single');
      });
    }

    function previewLeadNote(noteIdx) {
      if (!audioCtx) initAudio();
      playLeadNote(leadNotes[noteIdx].freq, 0.2);
    }

    function renderSequencer() {
      const seq = document.getElementById('sequencer');
      seq.innerHTML = tracks.map((track, ti) => `
        <div class="track" data-sound="${track.sound}">
          <div class="track-info">
            <span class="track-name">${track.name}</span>
            <button class="track-vol" onclick="playSound('${track.sound}')" title="Preview">ðŸ”Š</button>
          </div>
          <div class="steps">
            ${Array(16).fill(0).map((_, si) => `
              <div class="step ${si % 4 === 0 ? 'beat-marker' : ''}"
                   data-track="${ti}"
                   data-step="${si}"
                   onclick="toggleStep(${ti}, ${si})"></div>
            `).join('')}
          </div>
        </div>
      `).join('');
    }

    function renderVisualizer() {
      const viz = document.getElementById('visualizer');
      viz.innerHTML = Array(32).fill(0).map(() => '<div class="viz-bar"></div>').join('');
    }

    function toggleStep(track, step) {
      if (!audioCtx) initAudio();
      pattern[track][step] = !pattern[track][step];
      updateStepUI(track, step);
      if (pattern[track][step]) {
        playSound(tracks[track].sound);
      }
    }

    function updateStepUI(track, step) {
      const stepEl = document.querySelector(`[data-track="${track}"][data-step="${step}"]`);
      if (stepEl) {
        stepEl.classList.toggle('active', pattern[track][step]);
      }
    }

    function initAudio() {
      audioCtx = new (window.AudioContext || window.webkitAudioContext)();

      // Master output
      masterGain = audioCtx.createGain();
      masterGain.gain.value = 0.8;
      masterGain.connect(audioCtx.destination);

      // Dry signal path
      dryGain = audioCtx.createGain();
      dryGain.connect(masterGain);

      // Sidechain gain for lead ducking (connects to FX after they're created)
      leadSidechainGain = audioCtx.createGain();
      leadSidechainGain.gain.value = 1;

      // === MASSIVE REVERB ===
      reverbGain = audioCtx.createGain();
      convolver = audioCtx.createConvolver();
      convolver.buffer = createReverbImpulse(3.5, 4.0); // Long, massive reverb

      const reverbFilter = audioCtx.createBiquadFilter();
      reverbFilter.type = 'lowpass';
      reverbFilter.frequency.value = 6000;

      const reverbPreDelay = audioCtx.createDelay(0.1);
      reverbPreDelay.delayTime.value = 0.03;

      reverbGain.connect(reverbPreDelay);
      reverbPreDelay.connect(convolver);
      convolver.connect(reverbFilter);
      reverbFilter.connect(masterGain);

      // === THICK CHORUS ===
      chorusGain = audioCtx.createGain();

      // Create 4 voices for thick chorus
      const chorusVoices = [
        { delay: 0.020, rate: 0.5, depth: 0.003 },
        { delay: 0.025, rate: 0.6, depth: 0.004 },
        { delay: 0.030, rate: 0.4, depth: 0.005 },
        { delay: 0.035, rate: 0.7, depth: 0.003 }
      ];

      const chorusMix = audioCtx.createGain();
      chorusMix.gain.value = 0.5;
      chorusMix.connect(masterGain);

      chorusVoices.forEach(voice => {
        const delay = audioCtx.createDelay(0.1);
        delay.delayTime.value = voice.delay;

        const lfo = audioCtx.createOscillator();
        lfo.type = 'sine';
        lfo.frequency.value = voice.rate;

        const lfoGain = audioCtx.createGain();
        lfoGain.gain.value = voice.depth;

        const voiceGain = audioCtx.createGain();
        voiceGain.gain.value = 0.4;

        // Subtle pitch variation via feedback
        const feedback = audioCtx.createGain();
        feedback.gain.value = 0.2;

        lfo.connect(lfoGain);
        lfoGain.connect(delay.delayTime);

        chorusGain.connect(delay);
        delay.connect(voiceGain);
        delay.connect(feedback);
        feedback.connect(delay);
        voiceGain.connect(chorusMix);

        lfo.start();
        chorusDelays.push(delay);
        chorusLFOs.push(lfo);
      });

      // Connect lead sidechain to FX chains
      leadSidechainGain.connect(dryGain);
      leadSidechainGain.connect(reverbGain);
      leadSidechainGain.connect(chorusGain);

      updateFXLevels();
    }

    // Generate reverb impulse response
    function createReverbImpulse(duration, decay) {
      const length = audioCtx.sampleRate * duration;
      const impulse = audioCtx.createBuffer(2, length, audioCtx.sampleRate);

      for (let channel = 0; channel < 2; channel++) {
        const channelData = impulse.getChannelData(channel);
        for (let i = 0; i < length; i++) {
          // Exponential decay with some early reflections
          const env = Math.pow(1 - i / length, decay);
          // Add some randomness and early reflections
          let sample = (Math.random() * 2 - 1) * env;

          // Early reflections at specific times
          if (i < audioCtx.sampleRate * 0.1) {
            const earlyEnv = Math.pow(1 - i / (audioCtx.sampleRate * 0.1), 1);
            sample += (Math.random() * 2 - 1) * earlyEnv * 0.5;
          }

          channelData[i] = sample;
        }
      }
      return impulse;
    }

    function updateFXLevels() {
      if (!audioCtx) return;

      const reverbAmount = parseInt(document.getElementById('reverbSlider').value) / 100;
      const chorusAmount = parseInt(document.getElementById('chorusSlider').value) / 100;

      // Dry level decreases as effects increase
      const dryLevel = 1 - (reverbAmount * 0.3 + chorusAmount * 0.2);
      dryGain.gain.value = Math.max(0.4, dryLevel);

      // Reverb wet level - make it massive
      if (convolver) {
        const reverbWet = reverbAmount * 0.8;
        // Smooth transition
        reverbGain.gain.setTargetAtTime(reverbWet, audioCtx.currentTime, 0.1);
      }

      // Chorus wet level - thick and lush
      if (chorusGain) {
        const chorusWet = chorusAmount * 0.7;
        chorusGain.gain.setTargetAtTime(chorusWet, audioCtx.currentTime, 0.1);
      }
    }

    // Add event listeners for FX sliders
    document.getElementById('reverbSlider').addEventListener('input', updateFXLevels);
    document.getElementById('chorusSlider').addEventListener('input', updateFXLevels);

    function togglePlay() {
      if (!audioCtx) initAudio();
      isPlaying = !isPlaying;

      const btn = document.getElementById('playBtn');
      btn.classList.toggle('playing', isPlaying);
      btn.textContent = isPlaying ? 'â¸' : 'â–¶';

      if (isPlaying) {
        currentStep = 0;
        scheduleNext();
      } else {
        clearTimeout(intervalId);
        stopArp(); // Stop arpeggiator
        document.querySelectorAll('.step').forEach(s => s.classList.remove('playing'));
        document.querySelectorAll('.note-cell').forEach(c => c.classList.remove('playing'));
        lastLeadFreq = 0; // Reset glide state
      }
    }

    function scheduleNext() {
      if (!isPlaying) return;

      const swing = parseInt(document.getElementById('swingSlider').value) / 100;
      const stepDuration = (60 / bpm) / 4 * 1000; // 16th notes
      const swingOffset = currentStep % 2 === 1 ? stepDuration * swing : 0;

      playStep(currentStep);

      intervalId = setTimeout(() => {
        currentStep = (currentStep + 1) % 16;
        scheduleNext();
      }, stepDuration + swingOffset);
    }

    function playStep(step) {
      // Update drum UI
      document.querySelectorAll('.step').forEach(s => s.classList.remove('playing'));
      document.querySelectorAll(`.step[data-step="${step}"]`).forEach(s => s.classList.add('playing'));

      // Update piano roll UI
      document.querySelectorAll('.note-cell').forEach(c => c.classList.remove('playing'));
      document.querySelectorAll(`.note-cell[data-step="${step}"]`).forEach(c => c.classList.add('playing'));

      // Play drum sounds
      tracks.forEach((track, ti) => {
        if (pattern[ti][step]) {
          playSound(track.sound, track.volume);

          // Trigger sidechain on kick
          if (track.sound === 'kick') {
            triggerSidechain();
          }
        }
      });

      // Play lead note if present (with legato support)
      const noteIdx = leadPattern[step];
      if (noteIdx >= 0) {
        if (arpEnabled) {
          // Start arpeggiator on this note
          startArp(noteIdx);
        } else {
          const stepDuration = (60 / bpm) / 4; // Duration per step in seconds
          const noteLength = leadNoteLengths[step]; // How many steps this note spans
          const totalDuration = stepDuration * noteLength * 0.95; // 95% gate for legato
          playLeadNote(leadNotes[noteIdx].freq, totalDuration);
        }
      } else if (arpEnabled) {
        // No note at this step, stop arpeggiator
        stopArp();
      }
      // If this step is part of a sustained note from a previous step, don't trigger again
      // (The note is already playing from when it started)

      // Visualizer
      updateVisualizer();
    }

    function updateVisualizer() {
      const bars = document.querySelectorAll('.viz-bar');
      bars.forEach(bar => {
        const height = Math.random() * 50 + 10;
        bar.style.height = height + 'px';
      });
    }

    // Heavy synth drum sounds - routed through FX
    function playSound(type, volume = 1) {
      if (!audioCtx) initAudio();

      const now = audioCtx.currentTime;

      // Create sound output that routes to all FX chains
      const soundOut = audioCtx.createGain();
      soundOut.gain.value = volume * 0.7;

      // Route to dry, reverb, and chorus
      soundOut.connect(dryGain);
      soundOut.connect(reverbGain);
      soundOut.connect(chorusGain);

      switch(type) {
        case 'kick':
          playKick(now, soundOut);
          break;
        case 'snare':
          playSnare(now, soundOut);
          break;
        case 'hihat':
          playHiHat(now, soundOut);
          break;
        case 'clap':
          playClap(now, soundOut);
          break;
        case 'tom':
          playTom(now, soundOut);
          break;
        case 'crash':
          playCrash(now, soundOut);
          break;
        case 'bass':
          playBass(now, soundOut);
          break;
        case 'perc':
          playPerc(now, soundOut);
          break;
      }
    }

    function playKick(time, dest) {
      // Heavy 808-style kick
      const osc = audioCtx.createOscillator();
      const gain = audioCtx.createGain();

      osc.type = 'sine';
      osc.frequency.setValueAtTime(150, time);
      osc.frequency.exponentialRampToValueAtTime(30, time + 0.15);

      gain.gain.setValueAtTime(1, time);
      gain.gain.exponentialRampToValueAtTime(0.01, time + 0.5);

      // Add distortion layer
      const osc2 = audioCtx.createOscillator();
      const gain2 = audioCtx.createGain();
      osc2.type = 'triangle';
      osc2.frequency.setValueAtTime(80, time);
      osc2.frequency.exponentialRampToValueAtTime(20, time + 0.1);
      gain2.gain.setValueAtTime(0.5, time);
      gain2.gain.exponentialRampToValueAtTime(0.01, time + 0.3);

      osc.connect(gain).connect(dest);
      osc2.connect(gain2).connect(dest);

      osc.start(time);
      osc.stop(time + 0.5);
      osc2.start(time);
      osc2.stop(time + 0.3);
    }

    function playSnare(time, dest) {
      // Noise burst + tone
      const noise = createNoise(0.2);
      const noiseGain = audioCtx.createGain();
      const filter = audioCtx.createBiquadFilter();

      filter.type = 'highpass';
      filter.frequency.value = 1000;

      noiseGain.gain.setValueAtTime(1, time);
      noiseGain.gain.exponentialRampToValueAtTime(0.01, time + 0.2);

      noise.connect(filter).connect(noiseGain).connect(dest);
      noise.start(time);
      noise.stop(time + 0.2);

      // Body tone
      const osc = audioCtx.createOscillator();
      const oscGain = audioCtx.createGain();
      osc.type = 'triangle';
      osc.frequency.setValueAtTime(200, time);
      osc.frequency.exponentialRampToValueAtTime(100, time + 0.05);
      oscGain.gain.setValueAtTime(0.7, time);
      oscGain.gain.exponentialRampToValueAtTime(0.01, time + 0.1);

      osc.connect(oscGain).connect(dest);
      osc.start(time);
      osc.stop(time + 0.1);
    }

    function playHiHat(time, dest) {
      // Metallic noise
      const noise = createNoise(0.1);
      const gain = audioCtx.createGain();
      const filter = audioCtx.createBiquadFilter();
      const filter2 = audioCtx.createBiquadFilter();

      filter.type = 'highpass';
      filter.frequency.value = 7000;
      filter2.type = 'bandpass';
      filter2.frequency.value = 10000;

      gain.gain.setValueAtTime(0.5, time);
      gain.gain.exponentialRampToValueAtTime(0.01, time + 0.08);

      noise.connect(filter).connect(filter2).connect(gain).connect(dest);
      noise.start(time);
      noise.stop(time + 0.1);
    }

    function playClap(time, dest) {
      // Layered noise bursts
      for (let i = 0; i < 3; i++) {
        const noise = createNoise(0.15);
        const gain = audioCtx.createGain();
        const filter = audioCtx.createBiquadFilter();

        filter.type = 'bandpass';
        filter.frequency.value = 1500;
        filter.Q.value = 0.5;

        const offset = i * 0.01;
        gain.gain.setValueAtTime(0, time + offset);
        gain.gain.linearRampToValueAtTime(0.8, time + offset + 0.01);
        gain.gain.exponentialRampToValueAtTime(0.01, time + offset + 0.15);

        noise.connect(filter).connect(gain).connect(dest);
        noise.start(time + offset);
        noise.stop(time + offset + 0.15);
      }
    }

    function playTom(time, dest) {
      const osc = audioCtx.createOscillator();
      const gain = audioCtx.createGain();

      osc.type = 'sine';
      osc.frequency.setValueAtTime(200, time);
      osc.frequency.exponentialRampToValueAtTime(80, time + 0.2);

      gain.gain.setValueAtTime(0.8, time);
      gain.gain.exponentialRampToValueAtTime(0.01, time + 0.3);

      osc.connect(gain).connect(dest);
      osc.start(time);
      osc.stop(time + 0.3);
    }

    function playCrash(time, dest) {
      const noise = createNoise(1);
      const gain = audioCtx.createGain();
      const filter = audioCtx.createBiquadFilter();

      filter.type = 'highpass';
      filter.frequency.value = 5000;

      gain.gain.setValueAtTime(0.6, time);
      gain.gain.exponentialRampToValueAtTime(0.01, time + 1);

      noise.connect(filter).connect(gain).connect(dest);
      noise.start(time);
      noise.stop(time + 1);
    }

    function playBass(time, dest) {
      // Sub bass hit
      const osc = audioCtx.createOscillator();
      const osc2 = audioCtx.createOscillator();
      const gain = audioCtx.createGain();

      osc.type = 'sine';
      osc.frequency.setValueAtTime(55, time);
      osc2.type = 'square';
      osc2.frequency.setValueAtTime(55, time);

      const subGain = audioCtx.createGain();
      subGain.gain.value = 0.3;

      gain.gain.setValueAtTime(0.8, time);
      gain.gain.exponentialRampToValueAtTime(0.01, time + 0.3);

      osc.connect(gain).connect(dest);
      osc2.connect(subGain).connect(gain);

      osc.start(time);
      osc.stop(time + 0.3);
      osc2.start(time);
      osc2.stop(time + 0.3);
    }

    function playPerc(time, dest) {
      // Metallic percussion
      const osc = audioCtx.createOscillator();
      const osc2 = audioCtx.createOscillator();
      const gain = audioCtx.createGain();

      osc.type = 'square';
      osc.frequency.setValueAtTime(800, time);
      osc2.type = 'sawtooth';
      osc2.frequency.setValueAtTime(1200, time);

      gain.gain.setValueAtTime(0.4, time);
      gain.gain.exponentialRampToValueAtTime(0.01, time + 0.05);

      osc.connect(gain).connect(dest);
      osc2.connect(gain);

      osc.start(time);
      osc.stop(time + 0.05);
      osc2.start(time);
      osc2.stop(time + 0.05);
    }

    function createNoise(duration) {
      const bufferSize = audioCtx.sampleRate * duration;
      const buffer = audioCtx.createBuffer(1, bufferSize, audioCtx.sampleRate);
      const output = buffer.getChannelData(0);

      for (let i = 0; i < bufferSize; i++) {
        output[i] = Math.random() * 2 - 1;
      }

      const source = audioCtx.createBufferSource();
      source.buffer = buffer;
      return source;
    }

    // === DETUNED SAW LEAD SYNTH ===
    function playLeadNote(freq, duration = 0.25) {
      if (!audioCtx) return;

      const now = audioCtx.currentTime;
      const glideAmount = parseInt(document.getElementById('glideSlider').value) / 100;
      const detuneAmount = parseInt(document.getElementById('detuneSlider').value);
      const filterAmount = parseInt(document.getElementById('filterSlider').value) / 100;

      // Glide time in seconds
      const glideTime = glideAmount * 0.15;

      // Create output gain
      const output = audioCtx.createGain();
      output.gain.setValueAtTime(0, now);
      output.gain.linearRampToValueAtTime(0.35, now + 0.01);
      output.gain.setValueAtTime(0.35, now + duration - 0.05);
      output.gain.linearRampToValueAtTime(0, now + duration);

      // Lowpass filter with envelope
      const filter = audioCtx.createBiquadFilter();
      filter.type = 'lowpass';
      const baseFilterFreq = 400 + filterAmount * 4000;
      filter.frequency.setValueAtTime(baseFilterFreq * 2, now);
      filter.frequency.exponentialRampToValueAtTime(baseFilterFreq, now + 0.1);
      filter.Q.value = 2;

      // Route through sidechain gain then to FX
      filter.connect(output);
      output.connect(leadSidechainGain);

      // Create 5 detuned saw oscillators for thick sound
      const detunes = [-detuneAmount * 0.5, -detuneAmount * 0.25, 0, detuneAmount * 0.25, detuneAmount * 0.5];
      const oscGains = [0.2, 0.25, 0.3, 0.25, 0.2]; // Center osc slightly louder

      detunes.forEach((detune, i) => {
        const osc = audioCtx.createOscillator();
        osc.type = 'sawtooth';

        // Apply glide from last frequency
        if (lastLeadFreq > 0 && glideTime > 0) {
          osc.frequency.setValueAtTime(lastLeadFreq, now);
          osc.frequency.exponentialRampToValueAtTime(freq, now + glideTime);
        } else {
          osc.frequency.setValueAtTime(freq, now);
        }

        osc.detune.value = detune;

        const oscGain = audioCtx.createGain();
        oscGain.gain.value = oscGains[i];

        osc.connect(oscGain);
        oscGain.connect(filter);

        osc.start(now);
        osc.stop(now + duration + 0.1);
      });

      // Add sub oscillator (one octave down)
      const subOsc = audioCtx.createOscillator();
      subOsc.type = 'sine';
      if (lastLeadFreq > 0 && glideTime > 0) {
        subOsc.frequency.setValueAtTime(lastLeadFreq / 2, now);
        subOsc.frequency.exponentialRampToValueAtTime(freq / 2, now + glideTime);
      } else {
        subOsc.frequency.setValueAtTime(freq / 2, now);
      }

      const subGain = audioCtx.createGain();
      subGain.gain.value = 0.15;
      subOsc.connect(subGain);
      subGain.connect(filter);
      subOsc.start(now);
      subOsc.stop(now + duration + 0.1);

      lastLeadFreq = freq;
    }

    // === ARPEGGIATOR ===
    function toggleArp() {
      arpEnabled = !arpEnabled;
      document.getElementById('arpToggle').classList.toggle('active', arpEnabled);
      if (!arpEnabled) {
        stopArp();
      }
    }

    function updateArpRateDisplay() {
      const rate = parseInt(document.getElementById('arpRate').value);
      const rates = ['1/1', '1/2', '1/4', '1/8', '1/16', '1/32', '1/4T', '1/8T'];
      document.getElementById('arpRateDisplay').textContent = rates[rate - 1] || '1/4';
    }

    function getArpInterval() {
      const rate = parseInt(document.getElementById('arpRate').value);
      const beatMs = (60 / bpm) * 1000;
      // Rate: 1=whole, 2=half, 3=quarter, 4=8th, 5=16th, 6=32nd, 7=quarter triplet, 8=8th triplet
      const divisions = [1, 2, 4, 8, 16, 32, 6, 12]; // triplets are /3
      return beatMs * 4 / divisions[rate - 1];
    }

    function buildArpNotes(baseNoteIdx) {
      // Get base note and build notes across octaves
      const baseNote = leadNotes[baseNoteIdx];
      const octaves = parseInt(document.getElementById('arpOctaves').value);
      const notes = [];

      for (let oct = 0; oct < octaves; oct++) {
        const freq = baseNote.freq * Math.pow(2, oct);
        notes.push({ freq, noteIdx: baseNoteIdx, octave: oct });
      }

      return notes;
    }

    function getNextArpNote() {
      if (arpNotes.length === 0) return null;

      const mode = document.getElementById('arpMode').value;

      let note;
      switch (mode) {
        case 'up':
          note = arpNotes[arpIndex % arpNotes.length];
          arpIndex++;
          break;

        case 'down':
          note = arpNotes[(arpNotes.length - 1 - (arpIndex % arpNotes.length))];
          arpIndex++;
          break;

        case 'updown':
          note = arpNotes[arpIndex];
          arpIndex += arpDirection;
          if (arpIndex >= arpNotes.length - 1) {
            arpDirection = -1;
            arpIndex = arpNotes.length - 1;
          } else if (arpIndex <= 0) {
            arpDirection = 1;
            arpIndex = 0;
          }
          break;

        case 'downup':
          // Start from top
          if (arpIndex === 0 && arpDirection === 1) {
            arpIndex = arpNotes.length - 1;
            arpDirection = -1;
          }
          note = arpNotes[arpIndex];
          arpIndex += arpDirection;
          if (arpIndex < 0) {
            arpDirection = 1;
            arpIndex = 0;
          } else if (arpIndex >= arpNotes.length) {
            arpDirection = -1;
            arpIndex = arpNotes.length - 1;
          }
          break;

        case 'random':
          note = arpNotes[Math.floor(Math.random() * arpNotes.length)];
          break;

        case 'chord':
          // Play all notes at once
          return arpNotes;
      }

      return note ? [note] : null;
    }

    function startArp(baseNoteIdx) {
      stopArp();

      arpNotes = buildArpNotes(baseNoteIdx);
      arpIndex = 0;
      arpDirection = 1;

      const interval = getArpInterval();
      const noteDuration = interval * 0.8 / 1000; // 80% gate

      // Play first note immediately
      playArpNotes(noteDuration);

      // Schedule subsequent notes
      arpIntervalId = setInterval(() => {
        playArpNotes(noteDuration);
      }, interval);
    }

    function playArpNotes(duration) {
      const notesToPlay = getNextArpNote();
      if (!notesToPlay) return;

      notesToPlay.forEach(note => {
        playLeadNote(note.freq, duration);
      });
    }

    function stopArp() {
      if (arpIntervalId) {
        clearInterval(arpIntervalId);
        arpIntervalId = null;
      }
      arpNotes = [];
      arpIndex = 0;
      arpDirection = 1;
    }

    // Initialize arp rate display
    document.addEventListener('DOMContentLoaded', updateArpRateDisplay);

    // === SIDECHAIN COMPRESSOR ===
    function toggleSidechain() {
      sidechainEnabled = !sidechainEnabled;
      document.getElementById('sidechainToggle').classList.toggle('active', sidechainEnabled);
    }

    function triggerSidechain() {
      if (!sidechainEnabled || !audioCtx || !leadSidechainGain) return;

      const now = audioCtx.currentTime;
      const amount = parseInt(document.getElementById('scAmount').value) / 100;
      const attackMs = parseInt(document.getElementById('scAttack').value);
      const releaseMs = parseInt(document.getElementById('scRelease').value);

      const attackTime = attackMs / 1000;
      const releaseTime = releaseMs / 1000;
      const duckLevel = 1 - amount; // How much to duck (0 = full duck, 1 = no duck)

      // Cancel any scheduled changes
      leadSidechainGain.gain.cancelScheduledValues(now);

      // Quick attack (duck down)
      leadSidechainGain.gain.setValueAtTime(leadSidechainGain.gain.value, now);
      leadSidechainGain.gain.linearRampToValueAtTime(duckLevel, now + attackTime);

      // Smooth release (back to normal)
      leadSidechainGain.gain.linearRampToValueAtTime(1, now + attackTime + releaseTime);
    }

    // === MELODY RANDOMIZER ===
    const scales = {
      chromatic: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11],
      major: [0, 2, 4, 5, 7, 9, 11],
      minor: [0, 2, 3, 5, 7, 8, 10],
      pentatonic: [0, 2, 4, 7, 9],
      blues: [0, 3, 5, 6, 7, 10],
      dorian: [0, 2, 3, 5, 7, 9, 10]
    };

    // Map note names to semitone offsets from C
    const noteToSemitone = {
      'C': 0, 'C#': 1, 'D': 2, 'D#': 3, 'E': 4, 'F': 5,
      'F#': 6, 'G': 7, 'G#': 8, 'A': 9, 'A#': 10, 'B': 11
    };

    function isNoteInScale(noteIdx, scaleName, rootOffset) {
      const note = leadNotes[noteIdx];
      const noteName = note.note.replace(/[0-9]/g, ''); // Remove octave number
      const semitone = noteToSemitone[noteName];
      const scale = scales[scaleName];

      // Calculate semitone relative to root
      const relativeSemitone = (semitone - rootOffset + 12) % 12;
      return scale.includes(relativeSemitone);
    }

    function getScaleNotes(scaleName, rootOffset) {
      const validNotes = [];
      leadNotes.forEach((note, idx) => {
        if (isNoteInScale(idx, scaleName, rootOffset)) {
          validNotes.push(idx);
        }
      });
      return validNotes;
    }

    function randomizeMelody() {
      if (!audioCtx) initAudio();

      const scaleName = document.getElementById('scaleSelect').value;
      const rootOffset = parseInt(document.getElementById('rootSelect').value);
      const density = parseInt(document.getElementById('densitySelect').value) / 100;

      // Clear current pattern
      clearLead();

      // Get valid notes for this scale
      const validNotes = getScaleNotes(scaleName, rootOffset);
      if (validNotes.length === 0) return;

      // Generate random melody with varying note lengths
      let step = 0;
      while (step < 16) {
        if (Math.random() < density) {
          // Pick a random note from the scale
          const noteIdx = validNotes[Math.floor(Math.random() * validNotes.length)];
          leadPattern[step] = noteIdx;

          // Random note length (1-4 steps, weighted toward shorter)
          const maxLen = Math.min(4, 16 - step);
          const lenRoll = Math.random();
          let noteLen = 1;
          if (lenRoll > 0.7 && maxLen >= 2) noteLen = 2;
          if (lenRoll > 0.85 && maxLen >= 3) noteLen = 3;
          if (lenRoll > 0.95 && maxLen >= 4) noteLen = 4;

          leadNoteLengths[step] = noteLen;
          step += noteLen; // Skip steps covered by this note
        } else {
          step++;
        }
      }

      refreshNoteDisplay();
    }

    function updateBPM() {
      bpm = parseInt(document.getElementById('bpmInput').value) || 120;
      bpm = Math.max(60, Math.min(200, bpm));
      document.getElementById('bpmInput').value = bpm;
    }

    function clearAll() {
      pattern.forEach((track, ti) => {
        track.fill(false);
        track.forEach((_, si) => updateStepUI(ti, si));
      });
    }

    function randomize() {
      pattern.forEach((track, ti) => {
        track.forEach((_, si) => {
          pattern[ti][si] = Math.random() < 0.25;
          updateStepUI(ti, si);
        });
      });
    }

    function loadPreset(name) {
      clearAll();
      const presets = {
        basic: [
          [1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0], // kick
          [0,0,0,0,1,0,0,0,0,0,0,0,1,0,0,0], // snare
          [1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0], // hihat
          [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0], // clap
          [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0], // tom
          [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0], // crash
          [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0], // bass
          [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]  // perc
        ],
        house: [
          [1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0], // kick
          [0,0,0,0,1,0,0,0,0,0,0,0,1,0,0,0], // snare
          [0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0], // hihat (offbeat)
          [0,0,0,0,1,0,0,0,0,0,0,0,1,0,0,1], // clap
          [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0], // tom
          [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0], // crash
          [1,0,0,1,0,0,1,0,0,0,1,0,0,1,0,0], // bass
          [0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,1]  // perc
        ],
        trap: [
          [1,0,0,0,0,0,1,0,0,0,1,0,0,0,0,0], // kick
          [0,0,0,0,1,0,0,0,0,0,0,0,1,0,0,0], // snare
          [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1], // hihat
          [0,0,0,0,1,0,0,0,0,0,0,0,1,0,0,0], // clap
          [0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0], // tom
          [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0], // crash
          [1,0,0,0,0,0,1,0,0,0,1,0,0,0,0,1], // bass
          [0,0,1,0,0,0,1,0,0,1,0,0,0,0,1,0]  // perc
        ],
        dnb: [
          [1,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0], // kick
          [0,0,0,0,1,0,0,1,0,0,0,0,1,0,0,0], // snare
          [1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0], // hihat
          [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0], // clap
          [0,0,0,0,0,0,0,0,0,0,0,1,0,0,1,0], // tom
          [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0], // crash
          [1,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0], // bass
          [0,0,1,0,0,0,1,0,0,0,0,0,0,1,0,0]  // perc
        ],
        techno: [
          [1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0], // kick
          [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0], // snare
          [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1], // hihat
          [0,0,0,0,1,0,0,0,0,0,0,0,1,0,0,0], // clap
          [0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0], // tom
          [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0], // crash
          [1,0,0,1,0,0,1,0,1,0,0,1,0,0,1,0], // bass
          [0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,1]  // perc
        ]
      };

      const preset = presets[name];
      if (preset) {
        preset.forEach((track, ti) => {
          track.forEach((step, si) => {
            pattern[ti][si] = step === 1;
            updateStepUI(ti, si);
          });
        });
      }
    }

    // Start
    init();
  </script>
</body>
</html>
