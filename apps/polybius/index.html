<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
  <title>POLYBIUS</title>
  <link rel="icon" href="https://emojicdn.elk.sh/üëÅÔ∏è">
  <meta property="og:title" content="POLYBIUS">
  <meta property="og:description" content="Survive the geometric tunnel. Do not look away.">
  <meta property="og:image" content="https://sloppy.live/polybius/og-image.png">
  <meta property="og:url" content="https://sloppy.live/polybius">
  <link href="https://fonts.googleapis.com/css2?family=Share+Tech+Mono&display=swap" rel="stylesheet">
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      background: #000;
      overflow: hidden;
      font-family: 'Share Tech Mono', monospace;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      min-height: 100vh;
      cursor: none;
    }
    #warning {
      position: fixed;
      top: 0; left: 0; right: 0; bottom: 0;
      background: #000;
      color: #f00;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      z-index: 1000;
      text-align: center;
      padding: 20px;
    }
    #warning h1 {
      font-size: 3em;
      margin-bottom: 20px;
      animation: warningPulse 0.5s infinite;
    }
    @keyframes warningPulse {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.5; }
    }
    #warning p {
      font-size: 1.2em;
      margin: 10px 0;
      max-width: 600px;
    }
    #warning button {
      margin-top: 30px;
      padding: 15px 40px;
      font-size: 1.5em;
      font-family: inherit;
      background: transparent;
      border: 2px solid #f00;
      color: #f00;
      cursor: pointer;
      transition: all 0.2s;
    }
    #warning button:hover {
      background: #f00;
      color: #000;
    }
    #gameContainer {
      display: none;
      position: relative;
    }
    canvas {
      display: block;
    }
    #ui {
      position: fixed;
      top: 10px;
      left: 10px;
      color: #0ff;
      font-size: 1.2em;
      text-shadow: 0 0 10px #0ff;
      z-index: 10;
      pointer-events: none;
    }
    #subliminal {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      font-size: 4em;
      color: #fff;
      text-shadow: 0 0 30px #fff;
      opacity: 0;
      pointer-events: none;
      z-index: 20;
    }
    #gameOver {
      position: fixed;
      top: 0; left: 0; right: 0; bottom: 0;
      background: rgba(0,0,0,0.9);
      display: none;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      z-index: 100;
    }
    #gameOver h1 {
      font-size: 4em;
      color: #f0f;
      text-shadow: 0 0 30px #f0f;
      margin-bottom: 20px;
    }
    #gameOver p {
      font-size: 1.5em;
      color: #0ff;
      margin: 10px;
    }
    #gameOver button {
      margin-top: 30px;
      padding: 15px 40px;
      font-size: 1.5em;
      font-family: inherit;
      background: transparent;
      border: 2px solid #0ff;
      color: #0ff;
      cursor: pointer;
    }
    #backLink {
      position: fixed;
      bottom: 10px;
      right: 10px;
      color: #333;
      text-decoration: none;
      font-size: 0.8em;
      z-index: 50;
    }
    #mobileControls {
      display: none;
      position: fixed;
      bottom: 20px;
      left: 0;
      right: 0;
      justify-content: center;
      gap: 20px;
      z-index: 30;
    }
    .mobileBtn {
      width: 80px;
      height: 80px;
      border: 2px solid #0ff;
      background: rgba(0,255,255,0.1);
      color: #0ff;
      font-size: 2em;
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    @media (pointer: coarse) {
      #mobileControls { display: flex; }
    }
  </style>
</head>
<body>
  <div id="warning">
    <h1>‚ö†Ô∏è PHOTOSENSITIVITY WARNING ‚ö†Ô∏è</h1>
    <p>This game contains intense flashing lights and geometric patterns.</p>
    <p>Do not play if you have photosensitive epilepsy or are sensitive to flashing lights.</p>
    <p style="color:#0ff;margin-top:20px;">POLYBIUS - THE LEGEND RETURNS</p>
    <button onclick="startGame()">I UNDERSTAND - ENTER</button>
  </div>

  <div id="gameContainer">
    <canvas id="canvas"></canvas>
    <div id="ui">
      <div>SCORE: <span id="score">0</span></div>
      <div>DEPTH: <span id="depth">0</span></div>
    </div>
    <div id="subliminal"></div>
    <div id="mobileControls">
      <button class="mobileBtn" id="leftBtn">‚óÄ</button>
      <button class="mobileBtn" id="rightBtn">‚ñ∂</button>
    </div>
  </div>

  <div id="gameOver">
    <h1>SYSTEM FAILURE</h1>
    <p>FINAL SCORE: <span id="finalScore">0</span></p>
    <p>DEPTH REACHED: <span id="finalDepth">0</span></p>
    <button onclick="restartGame()">REINSERT COIN</button>
  </div>

  <a href="https://sloppy.live" id="backLink">sloppy.live</a>

  <script>
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    const subliminalEl = document.getElementById('subliminal');
    const scoreEl = document.getElementById('score');
    const depthEl = document.getElementById('depth');

    let W, H, centerX, centerY;

    function resize() {
      W = canvas.width = window.innerWidth;
      H = canvas.height = window.innerHeight;
      centerX = W / 2;
      centerY = H / 2;
    }
    resize();
    window.addEventListener('resize', resize);

    // Game state
    let gameRunning = false;
    let score = 0;
    let depth = 0;
    let playerAngle = 0;
    let playerRadius = 0.7;
    let speed = 1;
    let tunnelRotation = 0;
    let hue = 0;
    let flashIntensity = 0;
    let obstacles = [];
    let particles = [];
    let time = 0;

    // Subliminal messages
    const subliminals = [
      'OBEY', 'CONSUME', 'SUBMIT', 'CONFORM', 'BELIEVE',
      'WATCH', 'FOLLOW', 'TRUST', 'ACCEPT', 'COMPLY',
      'NO ESCAPE', 'STAY', 'DEEPER', 'FOREVER', 'ONE OF US',
      'DO NOT RESIST', 'SLEEP', 'FORGET', 'REMEMBER', 'SEE'
    ];

    // Input
    let keys = { left: false, right: false };

    document.addEventListener('keydown', e => {
      if (e.key === 'ArrowLeft' || e.key === 'a') keys.left = true;
      if (e.key === 'ArrowRight' || e.key === 'd') keys.right = true;
    });
    document.addEventListener('keyup', e => {
      if (e.key === 'ArrowLeft' || e.key === 'a') keys.left = false;
      if (e.key === 'ArrowRight' || e.key === 'd') keys.right = false;
    });

    // Mobile controls
    const leftBtn = document.getElementById('leftBtn');
    const rightBtn = document.getElementById('rightBtn');
    leftBtn.addEventListener('touchstart', e => { e.preventDefault(); keys.left = true; });
    leftBtn.addEventListener('touchend', e => { e.preventDefault(); keys.left = false; });
    rightBtn.addEventListener('touchstart', e => { e.preventDefault(); keys.right = true; });
    rightBtn.addEventListener('touchend', e => { e.preventDefault(); keys.right = false; });

    function startGame() {
      document.getElementById('warning').style.display = 'none';
      document.getElementById('gameContainer').style.display = 'block';
      resetGame();
      gameRunning = true;
      gameLoop();
    }

    function resetGame() {
      score = 0;
      depth = 0;
      playerAngle = 0;
      speed = 1;
      obstacles = [];
      particles = [];
      time = 0;
      flashIntensity = 0;
    }

    function restartGame() {
      document.getElementById('gameOver').style.display = 'none';
      resetGame();
      gameRunning = true;
    }

    function gameOver() {
      gameRunning = false;
      document.getElementById('finalScore').textContent = score;
      document.getElementById('finalDepth').textContent = depth;
      document.getElementById('gameOver').style.display = 'flex';
    }

    function showSubliminal() {
      const msg = subliminals[Math.floor(Math.random() * subliminals.length)];
      subliminalEl.textContent = msg;
      subliminalEl.style.opacity = '1';
      subliminalEl.style.color = `hsl(${Math.random() * 360}, 100%, 50%)`;
      setTimeout(() => {
        subliminalEl.style.opacity = '0';
      }, 50 + Math.random() * 100);
    }

    function spawnObstacle() {
      const sides = 3 + Math.floor(Math.random() * 5);
      const gapStart = Math.random() * Math.PI * 2;
      const gapSize = Math.PI * (0.3 + Math.random() * 0.4);
      obstacles.push({
        z: 20,
        sides: sides,
        gapStart: gapStart,
        gapSize: gapSize,
        rotation: Math.random() * Math.PI * 2,
        rotSpeed: (Math.random() - 0.5) * 0.02,
        hue: Math.random() * 360
      });
    }

    function spawnParticle(x, y, color) {
      for (let i = 0; i < 5; i++) {
        particles.push({
          x, y,
          vx: (Math.random() - 0.5) * 10,
          vy: (Math.random() - 0.5) * 10,
          life: 1,
          color
        });
      }
    }

    function drawTunnel() {
      const layers = 30;
      const maxRadius = Math.max(W, H) * 0.8;

      for (let i = layers; i >= 0; i--) {
        const t = i / layers;
        const radius = maxRadius * t * t;
        const sides = 8;
        const rot = tunnelRotation + i * 0.1;
        const layerHue = (hue + i * 10) % 360;

        // Flashing effect
        const flash = Math.sin(time * 0.1 + i * 0.3) > 0.7 ? 1 : 0.3;
        const brightness = 30 + flash * 40 + flashIntensity * 30;

        ctx.strokeStyle = `hsl(${layerHue}, 100%, ${brightness}%)`;
        ctx.lineWidth = 2 + (1 - t) * 3;
        ctx.shadowColor = `hsl(${layerHue}, 100%, 50%)`;
        ctx.shadowBlur = 10 + flash * 20;

        ctx.beginPath();
        for (let j = 0; j <= sides; j++) {
          const angle = (j / sides) * Math.PI * 2 + rot;
          const x = centerX + Math.cos(angle) * radius;
          const y = centerY + Math.sin(angle) * radius;
          if (j === 0) ctx.moveTo(x, y);
          else ctx.lineTo(x, y);
        }
        ctx.stroke();

        // Cross lines for depth
        if (i % 3 === 0) {
          ctx.beginPath();
          for (let j = 0; j < sides; j++) {
            const angle = (j / sides) * Math.PI * 2 + rot;
            ctx.moveTo(centerX, centerY);
            ctx.lineTo(centerX + Math.cos(angle) * radius, centerY + Math.sin(angle) * radius);
          }
          ctx.strokeStyle = `hsla(${layerHue}, 100%, 50%, 0.2)`;
          ctx.stroke();
        }
      }
    }

    function drawObstacles() {
      obstacles.forEach(obs => {
        const scale = 1 / (obs.z * 0.1 + 0.1);
        const radius = Math.max(W, H) * 0.5 * scale;

        if (radius < 10 || radius > Math.max(W, H)) return;

        ctx.strokeStyle = `hsl(${obs.hue}, 100%, 60%)`;
        ctx.lineWidth = 3 * scale;
        ctx.shadowColor = `hsl(${obs.hue}, 100%, 50%)`;
        ctx.shadowBlur = 20;

        ctx.beginPath();
        for (let i = 0; i <= obs.sides; i++) {
          const angle = (i / obs.sides) * Math.PI * 2 + obs.rotation;
          // Check if in gap
          let normalAngle = angle % (Math.PI * 2);
          if (normalAngle < 0) normalAngle += Math.PI * 2;
          let gapEnd = (obs.gapStart + obs.gapSize) % (Math.PI * 2);

          let inGap = false;
          if (obs.gapStart < gapEnd) {
            inGap = normalAngle >= obs.gapStart && normalAngle <= gapEnd;
          } else {
            inGap = normalAngle >= obs.gapStart || normalAngle <= gapEnd;
          }

          const x = centerX + Math.cos(angle) * radius;
          const y = centerY + Math.sin(angle) * radius;

          if (i === 0 || inGap) {
            ctx.moveTo(x, y);
          } else {
            ctx.lineTo(x, y);
          }
        }
        ctx.stroke();
      });
    }

    function drawPlayer() {
      const radius = Math.min(W, H) * 0.35 * playerRadius;
      const x = centerX + Math.cos(playerAngle) * radius;
      const y = centerY + Math.sin(playerAngle) * radius;

      // Player triangle
      const size = 15;
      const pointAngle = playerAngle + Math.PI;

      ctx.fillStyle = '#0ff';
      ctx.shadowColor = '#0ff';
      ctx.shadowBlur = 20;
      ctx.beginPath();
      ctx.moveTo(x + Math.cos(pointAngle) * size, y + Math.sin(pointAngle) * size);
      ctx.lineTo(x + Math.cos(pointAngle + 2.5) * size * 0.7, y + Math.sin(pointAngle + 2.5) * size * 0.7);
      ctx.lineTo(x + Math.cos(pointAngle - 2.5) * size * 0.7, y + Math.sin(pointAngle - 2.5) * size * 0.7);
      ctx.closePath();
      ctx.fill();

      // Trail
      ctx.strokeStyle = `hsla(180, 100%, 50%, 0.5)`;
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.arc(centerX, centerY, radius, playerAngle - 0.3, playerAngle + 0.3);
      ctx.stroke();
    }

    function drawParticles() {
      particles.forEach(p => {
        ctx.fillStyle = p.color;
        ctx.shadowColor = p.color;
        ctx.shadowBlur = 10;
        ctx.fillRect(p.x - 2, p.y - 2, 4, 4);
      });
    }

    function drawScanlines() {
      ctx.fillStyle = 'rgba(0,0,0,0.1)';
      for (let y = 0; y < H; y += 4) {
        ctx.fillRect(0, y, W, 2);
      }
    }

    function drawVignette() {
      const gradient = ctx.createRadialGradient(centerX, centerY, 0, centerX, centerY, Math.max(W, H) * 0.7);
      gradient.addColorStop(0, 'transparent');
      gradient.addColorStop(1, 'rgba(0,0,0,0.8)');
      ctx.fillStyle = gradient;
      ctx.fillRect(0, 0, W, H);
    }

    function checkCollision() {
      const playerR = Math.min(W, H) * 0.35 * playerRadius;

      for (let obs of obstacles) {
        if (obs.z > 0.5 && obs.z < 1.5) {
          // Check if player is in gap
          let normalAngle = (playerAngle - obs.rotation) % (Math.PI * 2);
          if (normalAngle < 0) normalAngle += Math.PI * 2;

          let gapEnd = (obs.gapStart + obs.gapSize) % (Math.PI * 2);
          let inGap = false;
          if (obs.gapStart < gapEnd) {
            inGap = normalAngle >= obs.gapStart && normalAngle <= gapEnd;
          } else {
            inGap = normalAngle >= obs.gapStart || normalAngle <= gapEnd;
          }

          if (!inGap) {
            return true;
          }
        }
      }
      return false;
    }

    function update() {
      time++;
      hue = (hue + 1) % 360;
      tunnelRotation += 0.01 * speed;

      // Player movement
      const turnSpeed = 0.05;
      if (keys.left) playerAngle -= turnSpeed;
      if (keys.right) playerAngle += turnSpeed;

      // Speed increases over time
      speed = 1 + depth * 0.001;

      // Move obstacles
      obstacles.forEach(obs => {
        obs.z -= 0.1 * speed;
        obs.rotation += obs.rotSpeed;
      });

      // Remove passed obstacles and score
      obstacles = obstacles.filter(obs => {
        if (obs.z < 0) {
          score += 100;
          depth++;
          flashIntensity = 0.5;
          return false;
        }
        return obs.z < 25;
      });

      // Spawn new obstacles
      if (obstacles.length < 5 && Math.random() < 0.03 * speed) {
        spawnObstacle();
      }

      // Decay flash
      flashIntensity *= 0.95;

      // Update particles
      particles.forEach(p => {
        p.x += p.vx;
        p.y += p.vy;
        p.life -= 0.02;
      });
      particles = particles.filter(p => p.life > 0);

      // Subliminal messages
      if (Math.random() < 0.005 * speed) {
        showSubliminal();
      }

      // Check collision
      if (checkCollision()) {
        const px = centerX + Math.cos(playerAngle) * Math.min(W, H) * 0.35 * playerRadius;
        const py = centerY + Math.sin(playerAngle) * Math.min(W, H) * 0.35 * playerRadius;
        for (let i = 0; i < 20; i++) {
          spawnParticle(px, py, '#f0f');
        }
        gameOver();
        return;
      }

      // Update UI
      scoreEl.textContent = score;
      depthEl.textContent = depth;
    }

    function draw() {
      // Clear with slight trail
      ctx.fillStyle = `rgba(0,0,0,${0.3 - flashIntensity * 0.2})`;
      ctx.fillRect(0, 0, W, H);

      // Random flash
      if (flashIntensity > 0.3 || (Math.random() < 0.01 * speed)) {
        ctx.fillStyle = `hsla(${hue}, 100%, 50%, ${0.05 + flashIntensity * 0.1})`;
        ctx.fillRect(0, 0, W, H);
      }

      ctx.shadowBlur = 0;

      drawTunnel();
      drawObstacles();
      drawPlayer();
      drawParticles();
      drawScanlines();
      drawVignette();

      // Glitch effect
      if (Math.random() < 0.02 * speed) {
        const glitchY = Math.random() * H;
        const glitchH = Math.random() * 20;
        ctx.drawImage(canvas, 0, glitchY, W, glitchH, (Math.random() - 0.5) * 20, glitchY, W, glitchH);
      }
    }

    function gameLoop() {
      if (gameRunning) {
        update();
        draw();
      }
      requestAnimationFrame(gameLoop);
    }

    window.startGame = startGame;
  </script>
</body>
</html>
