<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Bioluminescent Fox Den</title>
  <link rel="icon" href="https://emojicdn.elk.sh/ðŸ¦Š">
  <meta property="og:title" content="Bioluminescent Fox Den">
  <meta property="og:description" content="A magical glowing forest with neon trees and a cozy fox den">
  <meta property="og:url" content="https://app.sloppy.live/fox-den">
  <meta property="og:image" content="https://emojicdn.elk.sh/ðŸ¦Š?style=apple&size=512">
  <link href="https://fonts.googleapis.com/css2?family=Quicksand:wght@400;600;700&display=swap" rel="stylesheet">
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body { background: #000; overflow: hidden; font-family: 'Quicksand', sans-serif; }

    #canvas-container { position: fixed; top: 0; left: 0; width: 100%; height: 100%; }
    canvas { display: block; }

    .title-overlay {
      position: fixed; top: 20px; left: 20px; z-index: 100;
      pointer-events: none;
    }
    .title {
      font-size: 1.8rem; font-weight: 700;
      background: linear-gradient(135deg, #00ffaa, #00ccff, #ff00ff);
      -webkit-background-clip: text; -webkit-text-fill-color: transparent;
      background-clip: text; text-shadow: 0 0 30px rgba(0,255,170,0.5);
    }
    .subtitle { color: #668899; font-size: 0.85rem; margin-top: 5px; }

    .info-panel {
      position: fixed; bottom: 20px; right: 20px;
      background: rgba(0, 20, 30, 0.8); border: 1px solid rgba(0,255,170,0.3);
      border-radius: 15px; padding: 15px 20px; z-index: 100;
      backdrop-filter: blur(10px);
    }
    .info-panel p { color: #88ccaa; font-size: 0.75rem; margin: 5px 0; }
    .info-panel .glow { color: #00ffaa; }

    .back-link {
      position: fixed; bottom: 20px; left: 20px;
      color: #446655; font-size: 0.7rem; text-decoration: none; z-index: 100;
    }
    .back-link:hover { color: #00ffaa; }

    .ambient-overlay {
      position: fixed; top: 0; left: 0; width: 100%; height: 100%;
      pointer-events: none; z-index: 50;
      background: radial-gradient(ellipse at 50% 100%, rgba(0,255,170,0.05) 0%, transparent 70%);
    }
  </style>
</head>
<body>
  <div id="canvas-container"></div>
  <div class="ambient-overlay"></div>

  <div class="title-overlay">
    <div class="title">Bioluminescent Fox Den</div>
    <div class="subtitle">A magical glowing forest</div>
  </div>

  <div class="info-panel">
    <p>Drag to look around</p>
    <p>Scroll to zoom</p>
    <p class="glow">âœ¨ Watch the fireflies</p>
  </div>

  <a href="https://sloppy.live" class="back-link">sloppy.live</a>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script>
    let scene, camera, renderer, controls;
    let trees = [], mushrooms = [], grassBlades = [], fireflies = [];
    let fox = null;
    let time = 0;

    // Mouse controls
    let isDragging = false;
    let previousMousePosition = { x: 0, y: 0 };
    let cameraAngle = { x: 0.3, y: 0 };
    let cameraDistance = 15;

    function init() {
      scene = new THREE.Scene();
      scene.background = new THREE.Color(0x001015);
      scene.fog = new THREE.FogExp2(0x001520, 0.02);

      camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
      updateCameraPosition();

      renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
      document.getElementById('canvas-container').appendChild(renderer.domElement);

      // Lighting
      const ambient = new THREE.AmbientLight(0x112233, 0.3);
      scene.add(ambient);

      createGround();
      createDen();
      createTrees();
      createGlowingGrass();
      createMushrooms();
      createFox();
      createFireflies();

      // Event listeners
      renderer.domElement.addEventListener('mousedown', onMouseDown);
      renderer.domElement.addEventListener('mousemove', onMouseMove);
      renderer.domElement.addEventListener('mouseup', onMouseUp);
      renderer.domElement.addEventListener('wheel', onWheel);
      renderer.domElement.addEventListener('touchstart', onTouchStart);
      renderer.domElement.addEventListener('touchmove', onTouchMove);
      renderer.domElement.addEventListener('touchend', onTouchEnd);
      window.addEventListener('resize', onResize);

      animate();
    }

    function createGround() {
      // Main ground
      const groundGeo = new THREE.CircleGeometry(30, 64);
      const groundMat = new THREE.MeshBasicMaterial({ color: 0x0a1a15 });
      const ground = new THREE.Mesh(groundGeo, groundMat);
      ground.rotation.x = -Math.PI / 2;
      ground.position.y = -0.01;
      scene.add(ground);

      // Glowing ground accents
      const glowGroundGeo = new THREE.CircleGeometry(8, 32);
      const glowGroundMat = new THREE.MeshBasicMaterial({
        color: 0x00ffaa,
        transparent: true,
        opacity: 0.1
      });
      const glowGround = new THREE.Mesh(glowGroundGeo, glowGroundMat);
      glowGround.rotation.x = -Math.PI / 2;
      glowGround.position.y = 0.01;
      scene.add(glowGround);
    }

    function createDen() {
      const den = new THREE.Group();

      // Den mound
      const moundGeo = new THREE.SphereGeometry(2.5, 16, 12, 0, Math.PI * 2, 0, Math.PI / 2);
      const moundMat = new THREE.MeshBasicMaterial({ color: 0x1a2a20 });
      const mound = new THREE.Mesh(moundGeo, moundMat);
      mound.scale.set(1.5, 0.8, 1.2);
      den.add(mound);

      // Den entrance
      const entranceGeo = new THREE.CircleGeometry(0.8, 16);
      const entranceMat = new THREE.MeshBasicMaterial({ color: 0x050a08 });
      const entrance = new THREE.Mesh(entranceGeo, entranceMat);
      entrance.position.set(0, 0.5, 1.8);
      entrance.rotation.x = -0.3;
      den.add(entrance);

      // Entrance glow rim
      const rimGeo = new THREE.TorusGeometry(0.85, 0.08, 8, 32);
      const rimMat = new THREE.MeshBasicMaterial({
        color: 0x00ffaa,
        transparent: true,
        opacity: 0.6
      });
      const rim = new THREE.Mesh(rimGeo, rimMat);
      rim.position.set(0, 0.5, 1.82);
      rim.rotation.x = -0.3;
      den.add(rim);

      // Moss patches on den
      for (let i = 0; i < 8; i++) {
        const mossGeo = new THREE.SphereGeometry(0.3 + Math.random() * 0.3, 8, 6);
        const mossMat = new THREE.MeshBasicMaterial({
          color: 0x00ff88,
          transparent: true,
          opacity: 0.4 + Math.random() * 0.3
        });
        const moss = new THREE.Mesh(mossGeo, mossMat);
        const angle = Math.random() * Math.PI * 2;
        const dist = 1.5 + Math.random() * 1;
        moss.position.set(
          Math.cos(angle) * dist,
          0.3 + Math.random() * 0.5,
          Math.sin(angle) * dist * 0.8
        );
        moss.scale.y = 0.3;
        den.add(moss);
      }

      den.position.set(0, 0, 0);
      scene.add(den);
    }

    function createTrees() {
      const treePositions = [
        { x: -8, z: -5 }, { x: -6, z: 4 }, { x: 6, z: -4 },
        { x: 8, z: 3 }, { x: -4, z: -8 }, { x: 5, z: -7 },
        { x: -9, z: 1 }, { x: 9, z: -1 }, { x: 3, z: 8 },
        { x: -3, z: 7 }, { x: 0, z: -10 }, { x: -7, z: -7 }
      ];

      treePositions.forEach(pos => {
        const tree = createTree();
        tree.position.set(pos.x, 0, pos.z);
        tree.rotation.y = Math.random() * Math.PI * 2;
        scene.add(tree);
        trees.push(tree);
      });
    }

    function createTree() {
      const tree = new THREE.Group();
      const height = 4 + Math.random() * 3;
      const glowColor = Math.random() > 0.5 ? 0x00ffaa : 0x00ccff;

      // Trunk
      const trunkGeo = new THREE.CylinderGeometry(0.15, 0.25, height, 8);
      const trunkMat = new THREE.MeshBasicMaterial({ color: 0x1a2520 });
      const trunk = new THREE.Mesh(trunkGeo, trunkMat);
      trunk.position.y = height / 2;
      tree.add(trunk);

      // Glowing bark veins
      for (let i = 0; i < 5; i++) {
        const veinGeo = new THREE.CylinderGeometry(0.02, 0.02, height * 0.8, 4);
        const veinMat = new THREE.MeshBasicMaterial({
          color: glowColor,
          transparent: true,
          opacity: 0.7
        });
        const vein = new THREE.Mesh(veinGeo, veinMat);
        const angle = (i / 5) * Math.PI * 2;
        vein.position.set(
          Math.cos(angle) * 0.18,
          height / 2,
          Math.sin(angle) * 0.18
        );
        tree.add(vein);
      }

      // Canopy layers
      for (let layer = 0; layer < 3; layer++) {
        const y = height - 1 + layer * 0.8;
        const radius = 1.5 - layer * 0.3;

        // Canopy sphere
        const canopyGeo = new THREE.SphereGeometry(radius, 12, 8);
        const canopyMat = new THREE.MeshBasicMaterial({
          color: glowColor,
          transparent: true,
          opacity: 0.15 + layer * 0.05
        });
        const canopy = new THREE.Mesh(canopyGeo, canopyMat);
        canopy.position.y = y;
        canopy.scale.y = 0.6;
        tree.add(canopy);

        // Glowing leaves/particles
        for (let i = 0; i < 8; i++) {
          const leafGeo = new THREE.SphereGeometry(0.1 + Math.random() * 0.1, 6, 6);
          const leafMat = new THREE.MeshBasicMaterial({
            color: glowColor,
            transparent: true,
            opacity: 0.8
          });
          const leaf = new THREE.Mesh(leafGeo, leafMat);
          const angle = Math.random() * Math.PI * 2;
          const dist = Math.random() * radius;
          leaf.position.set(
            Math.cos(angle) * dist,
            y + (Math.random() - 0.5) * 0.5,
            Math.sin(angle) * dist
          );
          leaf.userData.baseY = leaf.position.y;
          leaf.userData.phase = Math.random() * Math.PI * 2;
          tree.add(leaf);
        }
      }

      // Tree glow light
      const light = new THREE.PointLight(glowColor, 0.3, 8);
      light.position.y = height;
      tree.add(light);

      return tree;
    }

    function createGlowingGrass() {
      const grassCount = 200;
      const colors = [0x00ffaa, 0x00ff88, 0x00ccff, 0x88ffaa];

      for (let i = 0; i < grassCount; i++) {
        const grass = new THREE.Group();

        // Random position avoiding den center
        let x, z;
        do {
          x = (Math.random() - 0.5) * 25;
          z = (Math.random() - 0.5) * 25;
        } while (Math.sqrt(x * x + z * z) < 4);

        const bladeCount = 3 + Math.floor(Math.random() * 3);
        const color = colors[Math.floor(Math.random() * colors.length)];

        for (let j = 0; j < bladeCount; j++) {
          const height = 0.3 + Math.random() * 0.4;
          const bladeGeo = new THREE.ConeGeometry(0.02, height, 4);
          const bladeMat = new THREE.MeshBasicMaterial({
            color: color,
            transparent: true,
            opacity: 0.6 + Math.random() * 0.3
          });
          const blade = new THREE.Mesh(bladeGeo, bladeMat);
          blade.position.set(
            (Math.random() - 0.5) * 0.2,
            height / 2,
            (Math.random() - 0.5) * 0.2
          );
          blade.rotation.x = (Math.random() - 0.5) * 0.3;
          blade.rotation.z = (Math.random() - 0.5) * 0.3;
          grass.add(blade);
        }

        grass.position.set(x, 0, z);
        grass.userData.phase = Math.random() * Math.PI * 2;
        scene.add(grass);
        grassBlades.push(grass);
      }
    }

    function createMushrooms() {
      const mushroomPositions = [
        { x: 3, z: 2 }, { x: -2, z: 3 }, { x: 4, z: -2 },
        { x: -3, z: -2 }, { x: 2, z: -3 }, { x: -4, z: 1 },
        { x: 1, z: 4 }, { x: -1, z: -4 }
      ];

      const colors = [0xff00ff, 0x00ffff, 0x00ff88, 0xffaa00];

      mushroomPositions.forEach(pos => {
        const mushroom = new THREE.Group();
        const color = colors[Math.floor(Math.random() * colors.length)];
        const scale = 0.5 + Math.random() * 0.5;

        // Stem
        const stemGeo = new THREE.CylinderGeometry(0.08 * scale, 0.12 * scale, 0.4 * scale, 8);
        const stemMat = new THREE.MeshBasicMaterial({ color: 0xeeeedd });
        const stem = new THREE.Mesh(stemGeo, stemMat);
        stem.position.y = 0.2 * scale;
        mushroom.add(stem);

        // Cap
        const capGeo = new THREE.SphereGeometry(0.25 * scale, 12, 8, 0, Math.PI * 2, 0, Math.PI / 2);
        const capMat = new THREE.MeshBasicMaterial({
          color: color,
          transparent: true,
          opacity: 0.8
        });
        const cap = new THREE.Mesh(capGeo, capMat);
        cap.position.y = 0.4 * scale;
        cap.scale.y = 0.6;
        mushroom.add(cap);

        // Glow
        const glowGeo = new THREE.SphereGeometry(0.35 * scale, 8, 8);
        const glowMat = new THREE.MeshBasicMaterial({
          color: color,
          transparent: true,
          opacity: 0.3
        });
        const glow = new THREE.Mesh(glowGeo, glowMat);
        glow.position.y = 0.35 * scale;
        mushroom.add(glow);

        // Spots on cap
        for (let i = 0; i < 5; i++) {
          const spotGeo = new THREE.CircleGeometry(0.03 * scale, 6);
          const spotMat = new THREE.MeshBasicMaterial({
            color: 0xffffff,
            transparent: true,
            opacity: 0.8
          });
          const spot = new THREE.Mesh(spotGeo, spotMat);
          const angle = Math.random() * Math.PI * 2;
          const dist = Math.random() * 0.15 * scale;
          spot.position.set(
            Math.cos(angle) * dist,
            0.42 * scale + Math.random() * 0.05,
            Math.sin(angle) * dist
          );
          spot.rotation.x = -Math.PI / 2 + Math.random() * 0.5;
          mushroom.add(spot);
        }

        mushroom.position.set(pos.x, 0, pos.z);
        mushroom.userData.phase = Math.random() * Math.PI * 2;
        mushroom.userData.color = color;
        scene.add(mushroom);
        mushrooms.push(mushroom);
      });
    }

    function createFox() {
      fox = new THREE.Group();

      const bodyColor = 0xff6622;
      const bellyColor = 0xffddcc;

      // Body
      const bodyGeo = new THREE.SphereGeometry(0.6, 12, 8);
      const bodyMat = new THREE.MeshBasicMaterial({ color: bodyColor });
      const body = new THREE.Mesh(bodyGeo, bodyMat);
      body.scale.set(1.2, 0.8, 0.8);
      body.position.set(0, 0.5, 0);
      fox.add(body);

      // Head
      const headGeo = new THREE.SphereGeometry(0.35, 12, 8);
      const headMat = new THREE.MeshBasicMaterial({ color: bodyColor });
      const head = new THREE.Mesh(headGeo, headMat);
      head.position.set(0.6, 0.7, 0);
      head.scale.set(1.2, 1, 1);
      fox.add(head);

      // Snout
      const snoutGeo = new THREE.ConeGeometry(0.15, 0.35, 8);
      const snoutMat = new THREE.MeshBasicMaterial({ color: bodyColor });
      const snout = new THREE.Mesh(snoutGeo, snoutMat);
      snout.rotation.z = -Math.PI / 2;
      snout.position.set(0.95, 0.65, 0);
      fox.add(snout);

      // Nose
      const noseGeo = new THREE.SphereGeometry(0.05, 8, 8);
      const noseMat = new THREE.MeshBasicMaterial({ color: 0x111111 });
      const nose = new THREE.Mesh(noseGeo, noseMat);
      nose.position.set(1.12, 0.65, 0);
      fox.add(nose);

      // Eyes
      [-1, 1].forEach(side => {
        const eyeGeo = new THREE.SphereGeometry(0.06, 8, 8);
        const eyeMat = new THREE.MeshBasicMaterial({ color: 0x111111 });
        const eye = new THREE.Mesh(eyeGeo, eyeMat);
        eye.position.set(0.8, 0.8, side * 0.18);
        fox.add(eye);

        // Eye shine
        const shineGeo = new THREE.SphereGeometry(0.02, 6, 6);
        const shineMat = new THREE.MeshBasicMaterial({ color: 0x00ffaa });
        const shine = new THREE.Mesh(shineGeo, shineMat);
        shine.position.set(0.83, 0.82, side * 0.16);
        fox.add(shine);
      });

      // Ears
      [-1, 1].forEach(side => {
        const earGeo = new THREE.ConeGeometry(0.12, 0.25, 4);
        const earMat = new THREE.MeshBasicMaterial({ color: bodyColor });
        const ear = new THREE.Mesh(earGeo, earMat);
        ear.position.set(0.5, 1.0, side * 0.2);
        ear.rotation.z = side * 0.2;
        fox.add(ear);

        // Inner ear
        const innerGeo = new THREE.ConeGeometry(0.06, 0.15, 4);
        const innerMat = new THREE.MeshBasicMaterial({ color: 0xffaaaa });
        const inner = new THREE.Mesh(innerGeo, innerMat);
        inner.position.set(0.5, 0.97, side * 0.2);
        inner.rotation.z = side * 0.2;
        fox.add(inner);
      });

      // Tail
      const tailGeo = new THREE.CylinderGeometry(0.08, 0.2, 0.8, 8);
      const tailMat = new THREE.MeshBasicMaterial({ color: bodyColor });
      const tail = new THREE.Mesh(tailGeo, tailMat);
      tail.position.set(-0.7, 0.6, 0);
      tail.rotation.z = Math.PI / 3;
      fox.add(tail);

      // Tail tip
      const tipGeo = new THREE.SphereGeometry(0.15, 8, 8);
      const tipMat = new THREE.MeshBasicMaterial({ color: 0xffffff });
      const tip = new THREE.Mesh(tipGeo, tipMat);
      tip.position.set(-1.0, 0.9, 0);
      fox.add(tip);

      // Legs
      [[-0.3, -0.25], [-0.3, 0.25], [0.3, -0.2], [0.3, 0.2]].forEach(([x, z]) => {
        const legGeo = new THREE.CylinderGeometry(0.06, 0.08, 0.35, 6);
        const legMat = new THREE.MeshBasicMaterial({ color: bodyColor });
        const leg = new THREE.Mesh(legGeo, legMat);
        leg.position.set(x, 0.17, z);
        fox.add(leg);

        // Paw
        const pawGeo = new THREE.SphereGeometry(0.08, 6, 6);
        const pawMat = new THREE.MeshBasicMaterial({ color: 0x111111 });
        const paw = new THREE.Mesh(pawGeo, pawMat);
        paw.position.set(x, 0.02, z);
        paw.scale.y = 0.5;
        fox.add(paw);
      });

      fox.position.set(0, 0, 2.5);
      fox.rotation.y = Math.PI;
      fox.userData.baseY = 0;
      scene.add(fox);
    }

    function createFireflies() {
      const fireflyCount = 50;

      for (let i = 0; i < fireflyCount; i++) {
        const firefly = new THREE.Group();

        // Core
        const coreGeo = new THREE.SphereGeometry(0.03, 6, 6);
        const colors = [0x00ffaa, 0xaaff00, 0x00ffff, 0xffff00];
        const color = colors[Math.floor(Math.random() * colors.length)];
        const coreMat = new THREE.MeshBasicMaterial({ color });
        const core = new THREE.Mesh(coreGeo, coreMat);
        firefly.add(core);

        // Glow
        const glowGeo = new THREE.SphereGeometry(0.08, 6, 6);
        const glowMat = new THREE.MeshBasicMaterial({
          color,
          transparent: true,
          opacity: 0.4
        });
        const glow = new THREE.Mesh(glowGeo, glowMat);
        firefly.add(glow);

        firefly.position.set(
          (Math.random() - 0.5) * 20,
          0.5 + Math.random() * 4,
          (Math.random() - 0.5) * 20
        );

        firefly.userData = {
          basePos: firefly.position.clone(),
          phase: Math.random() * Math.PI * 2,
          speed: 0.5 + Math.random() * 0.5,
          radius: 0.5 + Math.random() * 1.5
        };

        scene.add(firefly);
        fireflies.push(firefly);
      }
    }

    function updateCameraPosition() {
      camera.position.x = Math.sin(cameraAngle.y) * Math.cos(cameraAngle.x) * cameraDistance;
      camera.position.y = Math.sin(cameraAngle.x) * cameraDistance + 2;
      camera.position.z = Math.cos(cameraAngle.y) * Math.cos(cameraAngle.x) * cameraDistance;
      camera.lookAt(0, 1, 0);
    }

    function onMouseDown(e) {
      isDragging = true;
      previousMousePosition = { x: e.clientX, y: e.clientY };
    }

    function onMouseMove(e) {
      if (!isDragging) return;
      const deltaX = e.clientX - previousMousePosition.x;
      const deltaY = e.clientY - previousMousePosition.y;
      cameraAngle.y += deltaX * 0.005;
      cameraAngle.x = Math.max(0.1, Math.min(1.2, cameraAngle.x + deltaY * 0.005));
      updateCameraPosition();
      previousMousePosition = { x: e.clientX, y: e.clientY };
    }

    function onMouseUp() { isDragging = false; }

    function onWheel(e) {
      cameraDistance = Math.max(8, Math.min(25, cameraDistance + e.deltaY * 0.01));
      updateCameraPosition();
    }

    function onTouchStart(e) {
      if (e.touches.length === 1) {
        isDragging = true;
        previousMousePosition = { x: e.touches[0].clientX, y: e.touches[0].clientY };
      }
    }

    function onTouchMove(e) {
      if (!isDragging || e.touches.length !== 1) return;
      const deltaX = e.touches[0].clientX - previousMousePosition.x;
      const deltaY = e.touches[0].clientY - previousMousePosition.y;
      cameraAngle.y += deltaX * 0.005;
      cameraAngle.x = Math.max(0.1, Math.min(1.2, cameraAngle.x + deltaY * 0.005));
      updateCameraPosition();
      previousMousePosition = { x: e.touches[0].clientX, y: e.touches[0].clientY };
    }

    function onTouchEnd() { isDragging = false; }

    function animate() {
      requestAnimationFrame(animate);
      time += 0.016;

      // Animate grass swaying
      grassBlades.forEach(grass => {
        grass.rotation.x = Math.sin(time * 2 + grass.userData.phase) * 0.1;
        grass.rotation.z = Math.cos(time * 1.5 + grass.userData.phase) * 0.1;
      });

      // Animate mushroom glow
      mushrooms.forEach(m => {
        const glow = m.children[2];
        if (glow) {
          glow.material.opacity = 0.2 + Math.sin(time * 3 + m.userData.phase) * 0.15;
          glow.scale.setScalar(1 + Math.sin(time * 2 + m.userData.phase) * 0.1);
        }
      });

      // Animate fireflies
      fireflies.forEach(f => {
        const d = f.userData;
        f.position.x = d.basePos.x + Math.sin(time * d.speed + d.phase) * d.radius;
        f.position.y = d.basePos.y + Math.sin(time * d.speed * 0.7 + d.phase) * 0.5;
        f.position.z = d.basePos.z + Math.cos(time * d.speed * 0.8 + d.phase) * d.radius;

        // Blink
        const blink = 0.3 + Math.abs(Math.sin(time * 4 + d.phase)) * 0.7;
        f.children[1].material.opacity = blink * 0.5;
      });

      // Animate fox breathing
      if (fox) {
        fox.position.y = fox.userData.baseY + Math.sin(time * 1.5) * 0.02;
        fox.children[0].scale.y = 0.8 + Math.sin(time * 1.5) * 0.03;
      }

      // Slow camera auto-rotate when not dragging
      if (!isDragging) {
        cameraAngle.y += 0.001;
        updateCameraPosition();
      }

      renderer.render(scene, camera);
    }

    function onResize() {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    }

    init();
  </script>
<script src="/sloppy-header/sloppy-bar.js"></script>
</body>
</html>
