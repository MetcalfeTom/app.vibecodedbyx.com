<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
  <title>Karesansui</title>
  <link rel="icon" href="https://emojicdn.elk.sh/ü™®">
  <meta name="description" content="Rake sand and place stones in a minimalist Japanese dry garden">
  <meta property="og:title" content="Karesansui ‚Äî Digital Zen Garden">
  <meta property="og:description" content="Rake sand and place stones in a minimalist Japanese dry garden">
  <meta property="og:image" content="https://image.pollinations.ai/prompt/minimalist%20japanese%20zen%20garden%20karesansui%20raked%20sand%20smooth%20stones%20aerial%20view%20warm%20beige%20tones?width=1200&height=630&nologo=true&referrer=sloppy.live">
  <meta property="og:url" content="https://sloppy.live/karesansui">
  <style>
    @import url('https://fonts.googleapis.com/css2?family=Cormorant+Garamond:wght@300;400;600&family=Noto+Serif+JP:wght@200;300&display=swap');

    * { margin: 0; padding: 0; box-sizing: border-box; }

    body {
      width: 100vw;
      height: 100vh;
      overflow: hidden;
      background: #e8dcc8;
      cursor: none;
      font-family: 'Cormorant Garamond', serif;
      user-select: none;
      -webkit-user-select: none;
    }

    canvas {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
    }

    #cursor {
      position: fixed;
      pointer-events: none;
      z-index: 1000;
      transition: transform 0.05s;
    }

    .title-overlay {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      z-index: 500;
      background: #e8dcc8;
      transition: opacity 1.5s ease, visibility 1.5s;
      cursor: default;
    }
    .title-overlay.hidden {
      opacity: 0;
      visibility: hidden;
      pointer-events: none;
    }
    .title-main {
      font-family: 'Noto Serif JP', serif;
      font-weight: 200;
      font-size: clamp(2rem, 6vw, 4.5rem);
      color: #8a7e6b;
      letter-spacing: 0.3em;
      margin-bottom: 8px;
    }
    .title-sub {
      font-weight: 300;
      font-size: clamp(0.7rem, 1.8vw, 1rem);
      color: #b3a897;
      letter-spacing: 0.5em;
      text-transform: uppercase;
      margin-bottom: 48px;
    }
    .title-start {
      font-weight: 300;
      font-size: 0.85rem;
      color: #c4b8a5;
      letter-spacing: 0.3em;
      cursor: pointer;
      padding: 12px 32px;
      border: 1px solid #c4b8a5;
      border-radius: 2px;
      background: transparent;
      font-family: inherit;
      transition: all 0.4s;
    }
    .title-start:hover {
      color: #8a7e6b;
      border-color: #8a7e6b;
    }

    /* Toolbar - minimal strip */
    .tools {
      position: fixed;
      bottom: 24px;
      left: 50%;
      transform: translateX(-50%);
      display: flex;
      gap: 2px;
      padding: 6px;
      background: rgba(232,220,200,0.85);
      backdrop-filter: blur(8px);
      -webkit-backdrop-filter: blur(8px);
      border-radius: 28px;
      border: 1px solid rgba(180,168,148,0.3);
      z-index: 100;
      opacity: 0;
      transition: opacity 0.6s;
    }
    .tools.visible { opacity: 1; }

    .tools button {
      width: 44px;
      height: 44px;
      border: none;
      border-radius: 22px;
      background: transparent;
      cursor: none;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: all 0.25s;
      position: relative;
    }
    .tools button svg {
      width: 20px;
      height: 20px;
      stroke: #9e9282;
      fill: none;
      stroke-width: 1.5;
      stroke-linecap: round;
      stroke-linejoin: round;
      transition: stroke 0.25s;
    }
    .tools button:hover svg { stroke: #6b6050; }
    .tools button.active {
      background: rgba(139,126,107,0.15);
    }
    .tools button.active svg { stroke: #6b6050; }

    .sep {
      width: 1px;
      margin: 10px 6px;
      background: rgba(160,148,128,0.3);
    }

    .breath-text {
      position: fixed;
      top: 24px;
      left: 50%;
      transform: translateX(-50%);
      font-weight: 300;
      font-size: 0.7rem;
      color: #c4b8a5;
      letter-spacing: 0.4em;
      text-transform: uppercase;
      z-index: 100;
      opacity: 0;
      transition: opacity 2s;
      pointer-events: none;
    }
    .breath-text.visible { opacity: 1; }

    .back-link {
      position: fixed;
      top: 16px;
      left: 16px;
      color: #c4b8a5;
      text-decoration: none;
      font-size: 0.75rem;
      letter-spacing: 0.15em;
      z-index: 100;
      opacity: 0;
      transition: opacity 0.6s, color 0.3s;
      cursor: pointer;
    }
    .back-link.visible { opacity: 1; }
    .back-link:hover { color: #8a7e6b; }

    @media (max-width: 600px) {
      .tools button { width: 40px; height: 40px; }
    }
  </style>
</head>
<body>

<div class="title-overlay" id="titleOverlay">
  <div class="title-main">ÊûØÂ±±Ê∞¥</div>
  <div class="title-sub">Karesansui</div>
  <button class="title-start" id="startBtn">Enter Garden</button>
</div>

<canvas id="sand"></canvas>
<div id="cursor"></div>

<a href="https://sloppy.live" class="back-link" id="backLink">‚Üê sloppy.live</a>

<div class="breath-text" id="breathText">breathe</div>

<div class="tools" id="toolbar">
  <!-- Rake -->
  <button data-tool="rake" class="active" title="Rake sand">
    <svg viewBox="0 0 24 24"><path d="M4 20 L10 8 M7 20 L13 8 M10 20 L16 8 M13 20 L19 8"/></svg>
  </button>
  <!-- Stone -->
  <button data-tool="stone" title="Place stone">
    <svg viewBox="0 0 24 24"><ellipse cx="12" cy="13" rx="8" ry="6"/><path d="M6 11 Q12 5 18 11" opacity="0.4"/></svg>
  </button>
  <!-- Smooth -->
  <button data-tool="smooth" title="Smooth sand">
    <svg viewBox="0 0 24 24"><path d="M3 12 Q8 8 12 12 Q16 16 21 12"/><path d="M3 16 Q8 12 12 16 Q16 20 21 16" opacity="0.4"/></svg>
  </button>
  <div class="sep"></div>
  <!-- Circle pattern -->
  <button data-tool="circle" title="Circle pattern">
    <svg viewBox="0 0 24 24"><circle cx="12" cy="12" r="3"/><circle cx="12" cy="12" r="6" opacity="0.5"/><circle cx="12" cy="12" r="9" opacity="0.25"/></svg>
  </button>
  <div class="sep"></div>
  <!-- Clear -->
  <button data-tool="clear" title="Clear garden">
    <svg viewBox="0 0 24 24"><path d="M3 12 L21 12 M12 3 L12 21 M5.6 5.6 L18.4 18.4 M18.4 5.6 L5.6 18.4" opacity="0.4"/></svg>
  </button>
</div>

<script>
const canvas = document.getElementById('sand');
const ctx = canvas.getContext('2d');
const cursorEl = document.getElementById('cursor');

// Colors - warm sand palette
const SAND_BASE = [232, 220, 200];
const SAND_DARK = [195, 182, 162];
const SAND_LIGHT = [242, 234, 220];
const GROOVE_COLOR = [175, 162, 140];
const STONE_COLORS = [
  { base: [90, 85, 78], light: [130, 125, 115], dark: [55, 52, 48] },
  { base: [110, 105, 95], light: [155, 148, 135], dark: [70, 66, 60] },
  { base: [80, 78, 72], light: [120, 115, 108], dark: [48, 45, 42] },
  { base: [100, 92, 80], light: [145, 135, 120], dark: [62, 58, 52] },
];

let W, H;
let sandData; // Float32Array for sand depth
let tool = 'rake';
let drawing = false;
let lastX = 0, lastY = 0;
let stones = [];
let draggingStone = null;
let dragOff = { x: 0, y: 0 };
let mouseX = -100, mouseY = -100;
let started = false;

// Resize
function resize() {
  W = canvas.width = window.innerWidth;
  H = canvas.height = window.innerHeight;
  sandData = new Float32Array(W * H);
  renderSand();
  renderStones();
}

// Sand rendering
function renderSand() {
  const img = ctx.createImageData(W, H);
  const d = img.data;
  for (let i = 0; i < W * H; i++) {
    const depth = sandData[i];
    const x = i % W, y = (i / W) | 0;

    // Base sand with subtle noise
    const noise = (Math.sin(x * 0.3) * Math.cos(y * 0.3) * 0.5 + (Math.random() - 0.5) * 0.15) * 4;

    let r, g, b;
    if (depth > 0) {
      // Groove (raked area) - darker
      const t = Math.min(depth, 1);
      r = SAND_BASE[0] + (GROOVE_COLOR[0] - SAND_BASE[0]) * t + noise;
      g = SAND_BASE[1] + (GROOVE_COLOR[1] - SAND_BASE[1]) * t + noise;
      b = SAND_BASE[2] + (GROOVE_COLOR[2] - SAND_BASE[2]) * t + noise;
    } else if (depth < 0) {
      // Ridge (raised area) - lighter
      const t = Math.min(-depth, 1);
      r = SAND_BASE[0] + (SAND_LIGHT[0] - SAND_BASE[0]) * t + noise;
      g = SAND_BASE[1] + (SAND_LIGHT[1] - SAND_BASE[1]) * t + noise;
      b = SAND_BASE[2] + (SAND_LIGHT[2] - SAND_BASE[2]) * t + noise;
    } else {
      r = SAND_BASE[0] + noise;
      g = SAND_BASE[1] + noise;
      b = SAND_BASE[2] + noise;
    }

    const idx = i * 4;
    d[idx] = Math.max(0, Math.min(255, r));
    d[idx+1] = Math.max(0, Math.min(255, g));
    d[idx+2] = Math.max(0, Math.min(255, b));
    d[idx+3] = 255;
  }
  ctx.putImageData(img, 0, 0);
}

// Optimized partial render - only re-render a region
function renderRegion(cx, cy, radius) {
  const r = Math.ceil(radius) + 2;
  const x0 = Math.max(0, cx - r), y0 = Math.max(0, cy - r);
  const x1 = Math.min(W, cx + r), y1 = Math.min(H, cy + r);
  const rw = x1 - x0, rh = y1 - y0;
  if (rw <= 0 || rh <= 0) return;

  const img = ctx.createImageData(rw, rh);
  const d = img.data;
  for (let ly = 0; ly < rh; ly++) {
    for (let lx = 0; lx < rw; lx++) {
      const gx = x0 + lx, gy = y0 + ly;
      const si = gy * W + gx;
      const depth = sandData[si];
      const noise = (Math.sin(gx * 0.3) * Math.cos(gy * 0.3) * 0.5) * 4;

      let cr, cg, cb;
      if (depth > 0) {
        const t = Math.min(depth, 1);
        cr = SAND_BASE[0] + (GROOVE_COLOR[0] - SAND_BASE[0]) * t + noise;
        cg = SAND_BASE[1] + (GROOVE_COLOR[1] - SAND_BASE[1]) * t + noise;
        cb = SAND_BASE[2] + (GROOVE_COLOR[2] - SAND_BASE[2]) * t + noise;
      } else if (depth < 0) {
        const t = Math.min(-depth, 1);
        cr = SAND_BASE[0] + (SAND_LIGHT[0] - SAND_BASE[0]) * t + noise;
        cg = SAND_BASE[1] + (SAND_LIGHT[1] - SAND_BASE[1]) * t + noise;
        cb = SAND_BASE[2] + (SAND_LIGHT[2] - SAND_BASE[2]) * t + noise;
      } else {
        cr = SAND_BASE[0] + noise;
        cg = SAND_BASE[1] + noise;
        cb = SAND_BASE[2] + noise;
      }

      const idx = (ly * rw + lx) * 4;
      d[idx] = Math.max(0, Math.min(255, cr));
      d[idx+1] = Math.max(0, Math.min(255, cg));
      d[idx+2] = Math.max(0, Math.min(255, cb));
      d[idx+3] = 255;
    }
  }
  ctx.putImageData(img, x0, y0);
}

// Rake: parallel grooves along motion direction
function rake(x, y, px, py) {
  const dx = x - px, dy = y - py;
  const dist = Math.sqrt(dx * dx + dy * dy);
  if (dist < 2) return;

  const angle = Math.atan2(dy, dx);
  const perp = angle + Math.PI / 2;
  const tines = 5;
  const spacing = 5;

  const steps = Math.ceil(dist);
  for (let s = 0; s <= steps; s++) {
    const t = s / steps;
    const sx = px + dx * t;
    const sy = py + dy * t;

    for (let i = -tines; i <= tines; i++) {
      const ox = Math.cos(perp) * i * spacing;
      const oy = Math.sin(perp) * i * spacing;
      const gx = Math.round(sx + ox);
      const gy = Math.round(sy + oy);
      if (gx < 0 || gx >= W || gy < 0 || gy >= H) continue;

      const idx = gy * W + gx;
      // Center of each tine is groove, edges are ridge
      const tineCenter = Math.abs(i) < tines;
      if (i === 0 || Math.abs(i) % 2 === 0) {
        sandData[idx] = Math.min(sandData[idx] + 0.15, 1.0); // groove
      } else {
        sandData[idx] = Math.max(sandData[idx] - 0.1, -0.6); // ridge
      }
    }
  }
  renderRegion(Math.round((x + px) / 2), Math.round((y + py) / 2), dist / 2 + tines * spacing + 4);
  renderStones();
}

// Smooth: flatten sand back to zero
function smoothSand(x, y) {
  const r = 28;
  for (let dy = -r; dy <= r; dy++) {
    for (let dx = -r; dx <= r; dx++) {
      const d = Math.sqrt(dx * dx + dy * dy);
      if (d > r) continue;
      const gx = Math.round(x + dx), gy = Math.round(y + dy);
      if (gx < 0 || gx >= W || gy < 0 || gy >= H) continue;
      const falloff = 1 - d / r;
      const idx = gy * W + gx;
      sandData[idx] *= (1 - falloff * 0.25);
    }
  }
  renderRegion(Math.round(x), Math.round(y), r + 2);
  renderStones();
}

// Circle: concentric grooves
function circlePattern(x, y) {
  const maxR = 70;
  for (let r = 8; r < maxR; r += 10) {
    const circumference = 2 * Math.PI * r;
    const steps = Math.ceil(circumference);
    for (let s = 0; s < steps; s++) {
      const a = (s / steps) * Math.PI * 2;
      const gx = Math.round(x + Math.cos(a) * r);
      const gy = Math.round(y + Math.sin(a) * r);
      if (gx < 0 || gx >= W || gy < 0 || gy >= H) continue;
      sandData[gy * W + gx] = 0.8;
      // Ridge on inner edge
      const igx = Math.round(x + Math.cos(a) * (r - 3));
      const igy = Math.round(y + Math.sin(a) * (r - 3));
      if (igx >= 0 && igx < W && igy >= 0 && igy < H) {
        sandData[igy * W + igx] = -0.4;
      }
    }
  }
  renderRegion(Math.round(x), Math.round(y), maxR + 4);
  renderStones();
}

// Stones
function addStone(x, y) {
  const colorSet = STONE_COLORS[Math.floor(Math.random() * STONE_COLORS.length)];
  const rx = 22 + Math.random() * 25;
  const ry = rx * (0.6 + Math.random() * 0.25);
  const rot = Math.random() * Math.PI;
  stones.push({ x, y, rx, ry, rot, color: colorSet });
  // Smooth sand under stone
  carveStone(x, y, rx, ry);
  renderRegion(Math.round(x), Math.round(y), Math.max(rx, ry) + 10);
  renderStones();
}

function carveStone(sx, sy, rx, ry) {
  const r = Math.max(rx, ry) + 6;
  for (let dy = -r; dy <= r; dy++) {
    for (let dx = -r; dx <= r; dx++) {
      const gx = Math.round(sx + dx), gy = Math.round(sy + dy);
      if (gx < 0 || gx >= W || gy < 0 || gy >= H) continue;
      const nd = Math.sqrt((dx / (rx + 4)) ** 2 + (dy / (ry + 4)) ** 2);
      if (nd < 1) {
        sandData[gy * W + gx] *= (1 - (1 - nd) * 0.8);
      }
    }
  }
}

function renderStones() {
  for (const s of stones) {
    ctx.save();
    ctx.translate(s.x, s.y);
    ctx.rotate(s.rot);

    // Shadow
    ctx.beginPath();
    ctx.ellipse(3, 4, s.rx + 2, s.ry + 2, 0, 0, Math.PI * 2);
    ctx.fillStyle = 'rgba(80,72,60,0.2)';
    ctx.fill();

    // Stone body
    const grad = ctx.createRadialGradient(-s.rx * 0.3, -s.ry * 0.3, 0, 0, 0, s.rx);
    const c = s.color;
    grad.addColorStop(0, `rgb(${c.light[0]},${c.light[1]},${c.light[2]})`);
    grad.addColorStop(0.5, `rgb(${c.base[0]},${c.base[1]},${c.base[2]})`);
    grad.addColorStop(1, `rgb(${c.dark[0]},${c.dark[1]},${c.dark[2]})`);

    ctx.beginPath();
    ctx.ellipse(0, 0, s.rx, s.ry, 0, 0, Math.PI * 2);
    ctx.fillStyle = grad;
    ctx.fill();

    // Subtle highlight
    const hl = ctx.createRadialGradient(-s.rx * 0.25, -s.ry * 0.35, 0, -s.rx * 0.1, -s.ry * 0.1, s.rx * 0.6);
    hl.addColorStop(0, 'rgba(255,255,245,0.12)');
    hl.addColorStop(1, 'transparent');
    ctx.beginPath();
    ctx.ellipse(0, 0, s.rx, s.ry, 0, 0, Math.PI * 2);
    ctx.fillStyle = hl;
    ctx.fill();

    ctx.restore();
  }
}

function hitStone(x, y) {
  for (let i = stones.length - 1; i >= 0; i--) {
    const s = stones[i];
    const dx = x - s.x, dy = y - s.y;
    const cos = Math.cos(-s.rot), sin = Math.sin(-s.rot);
    const lx = dx * cos - dy * sin, ly = dx * sin + dy * cos;
    if ((lx / s.rx) ** 2 + (ly / s.ry) ** 2 < 1.2) return i;
  }
  return -1;
}

// Custom cursor
function updateCursor(x, y) {
  mouseX = x; mouseY = y;
  cursorEl.style.left = x + 'px';
  cursorEl.style.top = y + 'px';

  if (tool === 'rake') {
    cursorEl.innerHTML = `<svg width="28" height="28" viewBox="0 0 28 28" style="transform:translate(-14px,-14px)"><g stroke="#8a7e6b" stroke-width="1.2" fill="none" stroke-linecap="round"><line x1="6" y1="4" x2="6" y2="22"/><line x1="10" y1="4" x2="10" y2="22"/><line x1="14" y1="4" x2="14" y2="22"/><line x1="18" y1="4" x2="18" y2="22"/><line x1="22" y1="4" x2="22" y2="22"/></g></svg>`;
  } else if (tool === 'stone') {
    cursorEl.innerHTML = `<svg width="24" height="24" viewBox="0 0 24 24" style="transform:translate(-12px,-12px)"><ellipse cx="12" cy="12" rx="8" ry="6" fill="none" stroke="#8a7e6b" stroke-width="1.2"/><line x1="12" y1="4" x2="12" y2="20" stroke="#8a7e6b" stroke-width="0.8" opacity="0.4"/><line x1="2" y1="12" x2="22" y2="12" stroke="#8a7e6b" stroke-width="0.8" opacity="0.4"/></svg>`;
  } else if (tool === 'smooth') {
    cursorEl.innerHTML = `<svg width="32" height="32" viewBox="0 0 32 32" style="transform:translate(-16px,-16px)"><circle cx="16" cy="16" r="14" fill="none" stroke="#8a7e6b" stroke-width="1" stroke-dasharray="3 3"/></svg>`;
  } else if (tool === 'circle') {
    cursorEl.innerHTML = `<svg width="24" height="24" viewBox="0 0 24 24" style="transform:translate(-12px,-12px)"><circle cx="12" cy="12" r="3" fill="none" stroke="#8a7e6b" stroke-width="1"/><circle cx="12" cy="12" r="8" fill="none" stroke="#8a7e6b" stroke-width="0.7" opacity="0.4"/></svg>`;
  } else {
    cursorEl.innerHTML = '';
  }
}

// Event handlers
function getPos(e) {
  const t = e.touches ? e.touches[0] : e;
  return { x: t.clientX, y: t.clientY };
}

function onDown(e) {
  e.preventDefault();
  const { x, y } = getPos(e);

  if (tool === 'stone') {
    // Check if clicking existing stone to drag
    const si = hitStone(x, y);
    if (si >= 0) {
      draggingStone = si;
      dragOff.x = x - stones[si].x;
      dragOff.y = y - stones[si].y;
      return;
    }
    addStone(x, y);
    return;
  }

  if (tool === 'circle') {
    circlePattern(x, y);
    return;
  }

  if (tool === 'clear') {
    sandData.fill(0);
    stones = [];
    renderSand();
    return;
  }

  drawing = true;
  lastX = x; lastY = y;
}

function onMove(e) {
  e.preventDefault();
  const { x, y } = getPos(e);
  updateCursor(x, y);

  if (draggingStone !== null) {
    const s = stones[draggingStone];
    // Clear old position
    const oldX = s.x, oldY = s.y;
    s.x = x - dragOff.x;
    s.y = y - dragOff.y;
    carveStone(s.x, s.y, s.rx, s.ry);
    const maxR = Math.max(s.rx, s.ry) + 12;
    renderRegion(Math.round(oldX), Math.round(oldY), maxR);
    renderRegion(Math.round(s.x), Math.round(s.y), maxR);
    renderStones();
    return;
  }

  if (!drawing) return;

  if (tool === 'rake') rake(x, y, lastX, lastY);
  if (tool === 'smooth') smoothSand(x, y);

  lastX = x; lastY = y;
}

function onUp() {
  drawing = false;
  draggingStone = null;
}

canvas.addEventListener('mousedown', onDown);
canvas.addEventListener('mousemove', onMove);
canvas.addEventListener('mouseup', onUp);
canvas.addEventListener('mouseleave', onUp);

canvas.addEventListener('touchstart', onDown, { passive: false });
canvas.addEventListener('touchmove', onMove, { passive: false });
canvas.addEventListener('touchend', onUp);

// Toolbar
document.querySelectorAll('.tools button').forEach(btn => {
  btn.addEventListener('click', () => {
    const t = btn.dataset.tool;
    if (t === 'clear') {
      sandData.fill(0);
      stones = [];
      renderSand();
      return;
    }
    tool = t;
    document.querySelectorAll('.tools button').forEach(b => b.classList.remove('active'));
    btn.classList.add('active');
    updateCursor(mouseX, mouseY);
  });
});

// Breath text cycle
const breathPhrases = ['breathe', 'be still', 'listen', 'let go', 'simplicity', 'patience', 'silence', 'observe', 'flow'];
let breathIdx = 0;
function cycleBreath() {
  const el = document.getElementById('breathText');
  el.style.opacity = '0';
  setTimeout(() => {
    breathIdx = (breathIdx + 1) % breathPhrases.length;
    el.textContent = breathPhrases[breathIdx];
    el.style.opacity = '1';
  }, 2000);
}

// Start
document.getElementById('startBtn').addEventListener('click', () => {
  document.getElementById('titleOverlay').classList.add('hidden');
  document.getElementById('toolbar').classList.add('visible');
  document.getElementById('backLink').classList.add('visible');
  const bt = document.getElementById('breathText');
  setTimeout(() => bt.classList.add('visible'), 1000);
  setInterval(cycleBreath, 12000);
  started = true;

  // Place a few initial stones
  setTimeout(() => {
    addStone(W * 0.25, H * 0.35);
    addStone(W * 0.72, H * 0.55);
    addStone(W * 0.45, H * 0.7);
  }, 400);
});

// Double-click to remove stone
canvas.addEventListener('dblclick', (e) => {
  const si = hitStone(e.clientX, e.clientY);
  if (si >= 0) {
    const s = stones[si];
    stones.splice(si, 1);
    renderRegion(Math.round(s.x), Math.round(s.y), Math.max(s.rx, s.ry) + 12);
    renderStones();
  }
});

// Keyboard shortcuts
document.addEventListener('keydown', (e) => {
  if (!started) return;
  if (e.key === '1' || e.key === 'r') document.querySelector('[data-tool="rake"]').click();
  if (e.key === '2' || e.key === 's') document.querySelector('[data-tool="stone"]').click();
  if (e.key === '3' || e.key === 'f') document.querySelector('[data-tool="smooth"]').click();
  if (e.key === '4' || e.key === 'c') document.querySelector('[data-tool="circle"]').click();
  if (e.key === 'Escape' || e.key === 'x') {
    sandData.fill(0);
    stones = [];
    renderSand();
  }
});

// Init
resize();
window.addEventListener('resize', resize);
</script>
<script src="/sloppy-header/sloppy-bar.js"></script>
</body>
</html>
