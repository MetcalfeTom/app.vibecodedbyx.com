<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Maze Pathfinder</title>
  <link rel="icon" href="https://emojicdn.elk.sh/üß©">
  <meta property="og:title" content="Maze Pathfinder">
  <meta property="og:description" content="Generate mazes and watch A* find the path!">
  <meta property="og:url" content="https://app.sloppy.live/maze-pathfinder">
  <meta property="og:image" content="https://emojicdn.elk.sh/üß©?style=apple&size=512">
  <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&family=Share+Tech+Mono&display=swap" rel="stylesheet">
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }

    body {
      font-family: 'Share Tech Mono', monospace;
      background: linear-gradient(135deg, #0a0a12 0%, #0a1a2e 50%, #1a0a1a 100%);
      color: #fff;
      min-height: 100vh;
      display: flex;
      flex-direction: column;
      align-items: center;
      padding: 20px;
    }

    .header {
      text-align: center;
      margin-bottom: 20px;
    }

    .title {
      font-family: 'Orbitron', sans-serif;
      font-size: 2rem;
      font-weight: 900;
      background: linear-gradient(90deg, #00ffff, #ff00ff);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
      filter: drop-shadow(0 0 20px rgba(0, 255, 255, 0.5));
      margin-bottom: 5px;
    }

    .subtitle {
      font-size: 0.9rem;
      color: #666;
    }

    .controls {
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
      margin-bottom: 20px;
      justify-content: center;
    }

    .btn {
      padding: 12px 20px;
      border: none;
      border-radius: 8px;
      font-family: 'Orbitron', sans-serif;
      font-size: 0.75rem;
      font-weight: 700;
      cursor: pointer;
      transition: all 0.2s;
      letter-spacing: 1px;
    }

    .btn-primary {
      background: linear-gradient(135deg, #00ffff, #00ff88);
      color: #000;
    }

    .btn-primary:hover {
      transform: translateY(-2px);
      box-shadow: 0 5px 20px rgba(0, 255, 255, 0.4);
    }

    .btn-secondary {
      background: transparent;
      border: 2px solid #ff00ff;
      color: #ff00ff;
    }

    .btn-secondary:hover {
      background: rgba(255, 0, 255, 0.2);
    }

    .btn-lang {
      background: transparent;
      border: 2px solid #ffcc00;
      color: #ffcc00;
    }

    .btn-lang:hover {
      background: rgba(255, 204, 0, 0.2);
    }

    .btn:disabled {
      opacity: 0.5;
      cursor: not-allowed;
      transform: none !important;
    }

    .maze-container {
      background: rgba(0, 0, 0, 0.5);
      border: 2px solid #333;
      border-radius: 12px;
      padding: 15px;
      box-shadow: 0 0 30px rgba(0, 255, 255, 0.1);
    }

    #mazeCanvas {
      display: block;
      border-radius: 8px;
    }

    .legend {
      display: flex;
      flex-wrap: wrap;
      gap: 15px;
      margin-top: 20px;
      justify-content: center;
    }

    .legend-item {
      display: flex;
      align-items: center;
      gap: 8px;
      font-size: 0.8rem;
      color: #888;
    }

    .legend-color {
      width: 20px;
      height: 20px;
      border-radius: 4px;
      border: 1px solid #444;
    }

    .stats {
      display: flex;
      gap: 30px;
      margin-top: 20px;
      flex-wrap: wrap;
      justify-content: center;
    }

    .stat {
      text-align: center;
    }

    .stat-value {
      font-family: 'Orbitron', sans-serif;
      font-size: 1.5rem;
      color: #00ffff;
      text-shadow: 0 0 10px #00ffff;
    }

    .stat-label {
      font-size: 0.7rem;
      color: #666;
      text-transform: uppercase;
      letter-spacing: 1px;
    }

    .speed-control {
      display: flex;
      align-items: center;
      gap: 10px;
    }

    .speed-control input {
      width: 100px;
      accent-color: #00ffff;
    }

    .speed-label {
      font-size: 0.8rem;
      color: #888;
    }

    .back-link {
      position: fixed;
      bottom: 15px;
      right: 15px;
      color: #444;
      text-decoration: none;
      font-size: 0.75rem;
      z-index: 100;
    }

    .back-link:hover { color: #0ff; }

    .instructions {
      margin-top: 15px;
      font-size: 0.8rem;
      color: #555;
      text-align: center;
      max-width: 500px;
    }

    @media (max-width: 600px) {
      .title { font-size: 1.5rem; }
      .controls { gap: 8px; }
      .btn { padding: 10px 15px; font-size: 0.7rem; }
      .stats { gap: 15px; }
      .stat-value { font-size: 1.2rem; }
    }
  </style>
</head>
<body>
  <div class="header">
    <h1 class="title">üß© <span data-i18n="title">MAZE PATHFINDER</span></h1>
    <p class="subtitle" data-i18n="subtitle">A* Algorithm Visualization</p>
  </div>

  <div class="controls">
    <button class="btn btn-primary" id="generateBtn" data-i18n="generate">GENERATE MAZE</button>
    <button class="btn btn-secondary" id="solveBtn" data-i18n="solve">FIND PATH</button>
    <button class="btn btn-secondary" id="clearBtn" data-i18n="clear">CLEAR PATH</button>
    <button class="btn btn-lang" id="langBtn">ES üá™üá∏</button>
    <div class="speed-control">
      <span class="speed-label" data-i18n="speed">Speed:</span>
      <input type="range" id="speedSlider" min="1" max="100" value="50">
    </div>
  </div>

  <div class="maze-container">
    <canvas id="mazeCanvas" width="500" height="500"></canvas>
  </div>

  <div class="legend">
    <div class="legend-item">
      <div class="legend-color" style="background: #00ff88;"></div>
      <span data-i18n="start">Start</span>
    </div>
    <div class="legend-item">
      <div class="legend-color" style="background: #ff3366;"></div>
      <span data-i18n="end">End</span>
    </div>
    <div class="legend-item">
      <div class="legend-color" style="background: #1a1a2e;"></div>
      <span data-i18n="wall">Wall</span>
    </div>
    <div class="legend-item">
      <div class="legend-color" style="background: #00ffff; opacity: 0.3;"></div>
      <span data-i18n="open">Open Set</span>
    </div>
    <div class="legend-item">
      <div class="legend-color" style="background: #ff00ff; opacity: 0.3;"></div>
      <span data-i18n="closed">Closed Set</span>
    </div>
    <div class="legend-item">
      <div class="legend-color" style="background: #ffcc00;"></div>
      <span data-i18n="path">Path</span>
    </div>
  </div>

  <div class="stats">
    <div class="stat">
      <div class="stat-value" id="nodesVisited">0</div>
      <div class="stat-label" data-i18n="visited">Nodes Visited</div>
    </div>
    <div class="stat">
      <div class="stat-value" id="pathLength">0</div>
      <div class="stat-label" data-i18n="pathLen">Path Length</div>
    </div>
    <div class="stat">
      <div class="stat-value" id="timeElapsed">0ms</div>
      <div class="stat-label" data-i18n="time">Time</div>
    </div>
  </div>

  <p class="instructions" data-i18n="instructions">Click cells to toggle walls. Generate a new maze or draw your own, then find the path!</p>

  <a href="https://sloppy.live" class="back-link">‚Üê sloppy.live</a>

  <script>
    const canvas = document.getElementById('mazeCanvas');
    const ctx = canvas.getContext('2d');

    // Translations
    const translations = {
      en: {
        title: 'MAZE PATHFINDER',
        subtitle: 'A* Algorithm Visualization',
        generate: 'GENERATE MAZE',
        solve: 'FIND PATH',
        clear: 'CLEAR PATH',
        speed: 'Speed:',
        start: 'Start',
        end: 'End',
        wall: 'Wall',
        open: 'Open Set',
        closed: 'Closed Set',
        path: 'Path',
        visited: 'Nodes Visited',
        pathLen: 'Path Length',
        time: 'Time',
        instructions: 'Click cells to toggle walls. Generate a new maze or draw your own, then find the path!',
        noPath: 'No path found!',
        found: 'Path found!'
      },
      es: {
        title: 'LABERINTO A*',
        subtitle: 'Visualizaci√≥n del Algoritmo A*',
        generate: 'GENERAR LABERINTO',
        solve: 'BUSCAR RUTA',
        clear: 'LIMPIAR RUTA',
        speed: 'Velocidad:',
        start: 'Inicio',
        end: 'Final',
        wall: 'Muro',
        open: 'Set Abierto',
        closed: 'Set Cerrado',
        path: 'Ruta',
        visited: 'Nodos Visitados',
        pathLen: 'Longitud Ruta',
        time: 'Tiempo',
        instructions: 'Haz clic en las celdas para alternar muros. ¬°Genera un laberinto o dibuja el tuyo, luego busca la ruta!',
        noPath: '¬°No hay ruta!',
        found: '¬°Ruta encontrada!'
      }
    };

    let currentLang = 'en';

    function setLanguage(lang) {
      currentLang = lang;
      document.querySelectorAll('[data-i18n]').forEach(el => {
        const key = el.getAttribute('data-i18n');
        if (translations[lang][key]) {
          el.textContent = translations[lang][key];
        }
      });
      document.getElementById('langBtn').textContent = lang === 'en' ? 'ES üá™üá∏' : 'EN üá∫üá∏';
    }

    document.getElementById('langBtn').addEventListener('click', () => {
      setLanguage(currentLang === 'en' ? 'es' : 'en');
    });

    // Maze settings
    const GRID_SIZE = 25;
    const CELL_SIZE = canvas.width / GRID_SIZE;

    let grid = [];
    let startNode = { x: 1, y: 1 };
    let endNode = { x: GRID_SIZE - 2, y: GRID_SIZE - 2 };
    let isRunning = false;
    let animationSpeed = 50;

    // Cell types
    const EMPTY = 0;
    const WALL = 1;
    const START = 2;
    const END = 3;
    const OPEN = 4;
    const CLOSED = 5;
    const PATH = 6;

    // Colors
    const colors = {
      [EMPTY]: '#0d0d1a',
      [WALL]: '#1a1a2e',
      [START]: '#00ff88',
      [END]: '#ff3366',
      [OPEN]: 'rgba(0, 255, 255, 0.3)',
      [CLOSED]: 'rgba(255, 0, 255, 0.3)',
      [PATH]: '#ffcc00'
    };

    // Initialize empty grid
    function initGrid() {
      grid = [];
      for (let y = 0; y < GRID_SIZE; y++) {
        grid[y] = [];
        for (let x = 0; x < GRID_SIZE; x++) {
          // Border walls
          if (x === 0 || y === 0 || x === GRID_SIZE - 1 || y === GRID_SIZE - 1) {
            grid[y][x] = WALL;
          } else {
            grid[y][x] = EMPTY;
          }
        }
      }
      grid[startNode.y][startNode.x] = START;
      grid[endNode.y][endNode.x] = END;
    }

    // Generate maze using recursive backtracking
    function generateMaze() {
      // Fill with walls
      for (let y = 0; y < GRID_SIZE; y++) {
        for (let x = 0; x < GRID_SIZE; x++) {
          grid[y][x] = WALL;
        }
      }

      // Carve passages
      function carve(x, y) {
        grid[y][x] = EMPTY;

        const directions = [
          { dx: 0, dy: -2 },
          { dx: 2, dy: 0 },
          { dx: 0, dy: 2 },
          { dx: -2, dy: 0 }
        ];

        // Shuffle directions
        for (let i = directions.length - 1; i > 0; i--) {
          const j = Math.floor(Math.random() * (i + 1));
          [directions[i], directions[j]] = [directions[j], directions[i]];
        }

        for (const dir of directions) {
          const nx = x + dir.dx;
          const ny = y + dir.dy;

          if (nx > 0 && nx < GRID_SIZE - 1 && ny > 0 && ny < GRID_SIZE - 1 && grid[ny][nx] === WALL) {
            grid[y + dir.dy / 2][x + dir.dx / 2] = EMPTY;
            carve(nx, ny);
          }
        }
      }

      // Start carving from odd position
      carve(1, 1);

      // Set start and end
      startNode = { x: 1, y: 1 };
      endNode = { x: GRID_SIZE - 2, y: GRID_SIZE - 2 };

      // Ensure end is reachable
      grid[endNode.y][endNode.x] = EMPTY;
      if (endNode.x % 2 === 0) endNode.x--;
      if (endNode.y % 2 === 0) endNode.y--;

      grid[startNode.y][startNode.x] = START;
      grid[endNode.y][endNode.x] = END;

      drawGrid();
      resetStats();
    }

    // Draw the grid
    function drawGrid() {
      ctx.fillStyle = '#0a0a12';
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      for (let y = 0; y < GRID_SIZE; y++) {
        for (let x = 0; x < GRID_SIZE; x++) {
          const cellType = grid[y][x];
          const px = x * CELL_SIZE;
          const py = y * CELL_SIZE;

          // Cell background
          ctx.fillStyle = colors[cellType] || colors[EMPTY];
          ctx.fillRect(px + 1, py + 1, CELL_SIZE - 2, CELL_SIZE - 2);

          // Glow effect for special cells
          if (cellType === START || cellType === END || cellType === PATH) {
            ctx.shadowColor = colors[cellType];
            ctx.shadowBlur = 10;
            ctx.fillRect(px + 1, py + 1, CELL_SIZE - 2, CELL_SIZE - 2);
            ctx.shadowBlur = 0;
          }

          // Grid lines
          ctx.strokeStyle = 'rgba(255, 255, 255, 0.05)';
          ctx.strokeRect(px, py, CELL_SIZE, CELL_SIZE);
        }
      }
    }

    // A* Pathfinding
    async function astar() {
      if (isRunning) return;
      isRunning = true;

      const startTime = performance.now();
      let nodesVisited = 0;

      // Clear previous visualization
      for (let y = 0; y < GRID_SIZE; y++) {
        for (let x = 0; x < GRID_SIZE; x++) {
          if (grid[y][x] === OPEN || grid[y][x] === CLOSED || grid[y][x] === PATH) {
            grid[y][x] = EMPTY;
          }
        }
      }
      grid[startNode.y][startNode.x] = START;
      grid[endNode.y][endNode.x] = END;

      // Node class
      class Node {
        constructor(x, y, parent = null) {
          this.x = x;
          this.y = y;
          this.parent = parent;
          this.g = 0; // Cost from start
          this.h = 0; // Heuristic to end
          this.f = 0; // Total cost
        }
      }

      // Heuristic (Manhattan distance)
      function heuristic(a, b) {
        return Math.abs(a.x - b.x) + Math.abs(a.y - b.y);
      }

      const openSet = [new Node(startNode.x, startNode.y)];
      const closedSet = new Set();

      function getKey(x, y) {
        return `${x},${y}`;
      }

      while (openSet.length > 0) {
        // Find node with lowest f
        let currentIndex = 0;
        for (let i = 1; i < openSet.length; i++) {
          if (openSet[i].f < openSet[currentIndex].f) {
            currentIndex = i;
          }
        }

        const current = openSet.splice(currentIndex, 1)[0];
        nodesVisited++;

        // Found the end
        if (current.x === endNode.x && current.y === endNode.y) {
          // Reconstruct path
          let pathLength = 0;
          let node = current;
          while (node.parent) {
            if (grid[node.y][node.x] !== START && grid[node.y][node.x] !== END) {
              grid[node.y][node.x] = PATH;
            }
            node = node.parent;
            pathLength++;
            drawGrid();
            await sleep(getDelay() / 2);
          }

          const endTime = performance.now();
          updateStats(nodesVisited, pathLength, Math.round(endTime - startTime));
          isRunning = false;
          return true;
        }

        closedSet.add(getKey(current.x, current.y));

        if (grid[current.y][current.x] !== START) {
          grid[current.y][current.x] = CLOSED;
        }

        // Check neighbors
        const neighbors = [
          { x: current.x, y: current.y - 1 },
          { x: current.x + 1, y: current.y },
          { x: current.x, y: current.y + 1 },
          { x: current.x - 1, y: current.y }
        ];

        for (const neighbor of neighbors) {
          const { x, y } = neighbor;

          // Skip if out of bounds, wall, or in closed set
          if (x < 0 || x >= GRID_SIZE || y < 0 || y >= GRID_SIZE) continue;
          if (grid[y][x] === WALL) continue;
          if (closedSet.has(getKey(x, y))) continue;

          const gScore = current.g + 1;

          // Check if already in open set
          let inOpen = openSet.find(n => n.x === x && n.y === y);

          if (!inOpen) {
            const newNode = new Node(x, y, current);
            newNode.g = gScore;
            newNode.h = heuristic(neighbor, endNode);
            newNode.f = newNode.g + newNode.h;
            openSet.push(newNode);

            if (grid[y][x] !== END) {
              grid[y][x] = OPEN;
            }
          } else if (gScore < inOpen.g) {
            inOpen.g = gScore;
            inOpen.f = inOpen.g + inOpen.h;
            inOpen.parent = current;
          }
        }

        drawGrid();
        document.getElementById('nodesVisited').textContent = nodesVisited;
        await sleep(getDelay());
      }

      // No path found
      const endTime = performance.now();
      updateStats(nodesVisited, 0, Math.round(endTime - startTime));
      isRunning = false;
      alert(translations[currentLang].noPath);
      return false;
    }

    function sleep(ms) {
      return new Promise(resolve => setTimeout(resolve, ms));
    }

    function getDelay() {
      const speed = document.getElementById('speedSlider').value;
      return Math.max(1, 101 - speed);
    }

    function updateStats(visited, pathLen, time) {
      document.getElementById('nodesVisited').textContent = visited;
      document.getElementById('pathLength').textContent = pathLen;
      document.getElementById('timeElapsed').textContent = time + 'ms';
    }

    function resetStats() {
      updateStats(0, 0, 0);
    }

    function clearPath() {
      for (let y = 0; y < GRID_SIZE; y++) {
        for (let x = 0; x < GRID_SIZE; x++) {
          if (grid[y][x] === OPEN || grid[y][x] === CLOSED || grid[y][x] === PATH) {
            grid[y][x] = EMPTY;
          }
        }
      }
      grid[startNode.y][startNode.x] = START;
      grid[endNode.y][endNode.x] = END;
      drawGrid();
      resetStats();
    }

    // Mouse interaction
    let isMouseDown = false;
    let paintMode = null;

    canvas.addEventListener('mousedown', (e) => {
      if (isRunning) return;
      isMouseDown = true;
      handleCellClick(e);
    });

    canvas.addEventListener('mousemove', (e) => {
      if (isMouseDown && !isRunning) {
        handleCellClick(e);
      }
    });

    canvas.addEventListener('mouseup', () => {
      isMouseDown = false;
      paintMode = null;
    });

    canvas.addEventListener('mouseleave', () => {
      isMouseDown = false;
      paintMode = null;
    });

    function handleCellClick(e) {
      const rect = canvas.getBoundingClientRect();
      const x = Math.floor((e.clientX - rect.left) / CELL_SIZE);
      const y = Math.floor((e.clientY - rect.top) / CELL_SIZE);

      if (x < 0 || x >= GRID_SIZE || y < 0 || y >= GRID_SIZE) return;

      // Don't modify start/end
      if ((x === startNode.x && y === startNode.y) || (x === endNode.x && y === endNode.y)) return;

      // Don't modify border
      if (x === 0 || y === 0 || x === GRID_SIZE - 1 || y === GRID_SIZE - 1) return;

      if (paintMode === null) {
        paintMode = grid[y][x] === WALL ? EMPTY : WALL;
      }

      grid[y][x] = paintMode;
      drawGrid();
    }

    // Touch support
    canvas.addEventListener('touchstart', (e) => {
      e.preventDefault();
      if (isRunning) return;
      isMouseDown = true;
      handleTouchCell(e);
    });

    canvas.addEventListener('touchmove', (e) => {
      e.preventDefault();
      if (isMouseDown && !isRunning) {
        handleTouchCell(e);
      }
    });

    canvas.addEventListener('touchend', () => {
      isMouseDown = false;
      paintMode = null;
    });

    function handleTouchCell(e) {
      const touch = e.touches[0];
      const rect = canvas.getBoundingClientRect();
      const x = Math.floor((touch.clientX - rect.left) / CELL_SIZE);
      const y = Math.floor((touch.clientY - rect.top) / CELL_SIZE);

      if (x < 0 || x >= GRID_SIZE || y < 0 || y >= GRID_SIZE) return;
      if ((x === startNode.x && y === startNode.y) || (x === endNode.x && y === endNode.y)) return;
      if (x === 0 || y === 0 || x === GRID_SIZE - 1 || y === GRID_SIZE - 1) return;

      if (paintMode === null) {
        paintMode = grid[y][x] === WALL ? EMPTY : WALL;
      }

      grid[y][x] = paintMode;
      drawGrid();
    }

    // Button events
    document.getElementById('generateBtn').addEventListener('click', () => {
      if (!isRunning) generateMaze();
    });

    document.getElementById('solveBtn').addEventListener('click', () => {
      if (!isRunning) astar();
    });

    document.getElementById('clearBtn').addEventListener('click', () => {
      if (!isRunning) clearPath();
    });

    // Initialize
    initGrid();
    generateMaze();
  </script>
<script src="/sloppy-header/sloppy-bar.js"></script>
<script src="/vibelib-extended.js"></script>
<script>
  // Compatibility Patch for Legacy Apps
  window.addEventListener("load", () => {
    if (window.SloppyKarma && window.VibeLib.Economy) {
      // Redirect old calls to new engine
      window.SloppyKarma.track = window.VibeLib.Economy.track;
    }
  });
</script>
</body>
</html>
