<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>WebOS</title>
  <link rel="icon" href="https://emojicdn.elk.sh/üíª">
  <meta name="description" content="A fully interactive web-based operating system.">
  <meta property="og:title" content="WebOS">
  <meta property="og:description" content="Complete desktop OS in your browser with file system and bash terminal.">
  <meta property="og:url" content="https://app.sloppy.live/web-os">
  <meta property="og:image" content="https://app.sloppy.live/web-os/og-image.png">
  <meta property="og:type" content="website">
  <link href="https://fonts.googleapis.com/css2?family=IBM+Plex+Mono:wght@400;500&family=IBM+Plex+Sans:wght@400;500;600&display=swap" rel="stylesheet">
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
      user-select: none;
    }

    body {
      font-family: 'IBM Plex Sans', -apple-system, sans-serif;
      overflow: hidden;
      height: 100vh;
    }

    /* Desktop */
    .desktop {
      height: calc(100vh - 48px);
      background: linear-gradient(135deg, #1a1a2e 0%, #16213e 50%, #0f3460 100%);
      position: relative;
      overflow: hidden;
    }

    .desktop-icons {
      padding: 20px;
      display: flex;
      flex-direction: column;
      gap: 10px;
      position: absolute;
      top: 0;
      left: 0;
    }

    .desktop-icon {
      width: 80px;
      padding: 10px;
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 5px;
      border-radius: 8px;
      cursor: pointer;
      transition: background 0.2s;
    }

    .desktop-icon:hover {
      background: rgba(255, 255, 255, 0.1);
    }

    .desktop-icon.selected {
      background: rgba(100, 150, 255, 0.3);
    }

    .desktop-icon-img {
      font-size: 40px;
      line-height: 1;
    }

    .desktop-icon-label {
      font-size: 11px;
      color: #fff;
      text-align: center;
      text-shadow: 0 1px 3px rgba(0,0,0,0.8);
      word-break: break-word;
    }

    /* Taskbar */
    .taskbar {
      height: 48px;
      background: rgba(20, 20, 30, 0.95);
      backdrop-filter: blur(10px);
      display: flex;
      align-items: center;
      padding: 0 10px;
      border-top: 1px solid rgba(255,255,255,0.1);
    }

    .start-btn {
      width: 40px;
      height: 40px;
      background: linear-gradient(135deg, #4a90d9, #357abd);
      border: none;
      border-radius: 8px;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 20px;
      transition: transform 0.1s;
    }

    .start-btn:hover {
      transform: scale(1.05);
    }

    .start-btn:active {
      transform: scale(0.95);
    }

    .taskbar-apps {
      display: flex;
      gap: 5px;
      margin-left: 15px;
      flex: 1;
    }

    .taskbar-app {
      height: 36px;
      min-width: 150px;
      max-width: 200px;
      background: rgba(255,255,255,0.1);
      border: none;
      border-radius: 6px;
      padding: 0 12px;
      display: flex;
      align-items: center;
      gap: 8px;
      cursor: pointer;
      color: #fff;
      font-size: 12px;
      transition: background 0.2s;
    }

    .taskbar-app:hover {
      background: rgba(255,255,255,0.15);
    }

    .taskbar-app.active {
      background: rgba(100, 150, 255, 0.3);
    }

    .taskbar-app-icon {
      font-size: 16px;
    }

    .taskbar-app-title {
      flex: 1;
      text-align: left;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
    }

    .taskbar-time {
      color: #fff;
      font-size: 12px;
      padding: 0 15px;
    }

    /* Windows */
    .window {
      position: absolute;
      background: #1e1e2e;
      border-radius: 10px;
      box-shadow: 0 10px 40px rgba(0,0,0,0.5);
      display: flex;
      flex-direction: column;
      min-width: 400px;
      min-height: 300px;
      overflow: hidden;
    }

    .window.maximized {
      top: 0 !important;
      left: 0 !important;
      width: 100% !important;
      height: 100% !important;
      border-radius: 0;
    }

    .window.focused {
      z-index: 100;
    }

    .window-header {
      height: 36px;
      background: #2d2d3d;
      display: flex;
      align-items: center;
      padding: 0 10px;
      cursor: move;
      flex-shrink: 0;
    }

    .window-controls {
      display: flex;
      gap: 8px;
    }

    .window-control {
      width: 14px;
      height: 14px;
      border-radius: 50%;
      border: none;
      cursor: pointer;
      transition: filter 0.2s;
    }

    .window-control:hover {
      filter: brightness(1.2);
    }

    .window-control.close { background: #ff5f56; }
    .window-control.minimize { background: #ffbd2e; }
    .window-control.maximize { background: #27ca40; }

    .window-title {
      flex: 1;
      text-align: center;
      color: #aaa;
      font-size: 13px;
      font-weight: 500;
    }

    .window-title-spacer {
      width: 62px;
    }

    .window-body {
      flex: 1;
      overflow: hidden;
      display: flex;
      flex-direction: column;
    }

    .window-resize {
      position: absolute;
      bottom: 0;
      right: 0;
      width: 15px;
      height: 15px;
      cursor: nwse-resize;
    }

    /* Terminal */
    .terminal {
      flex: 1;
      background: #0d0d0d;
      color: #f0f0f0;
      font-family: 'IBM Plex Mono', monospace;
      font-size: 13px;
      padding: 10px;
      overflow-y: auto;
    }

    .terminal-line {
      white-space: pre-wrap;
      word-break: break-all;
      line-height: 1.5;
    }

    .terminal-line.error { color: #ff6b6b; }
    .terminal-line.success { color: #69db7c; }
    .terminal-line.info { color: #74c0fc; }
    .terminal-line.dir { color: #74c0fc; }
    .terminal-line.exec { color: #69db7c; }

    .terminal-input-line {
      display: flex;
      align-items: center;
      line-height: 1.5;
    }

    .terminal-prompt {
      color: #69db7c;
      margin-right: 8px;
      white-space: nowrap;
    }

    .terminal-input {
      flex: 1;
      background: transparent;
      border: none;
      color: #f0f0f0;
      font-family: 'IBM Plex Mono', monospace;
      font-size: 13px;
      outline: none;
    }

    /* File Manager */
    .file-manager {
      flex: 1;
      display: flex;
      flex-direction: column;
      background: #1e1e2e;
    }

    .file-manager-toolbar {
      height: 40px;
      background: #2d2d3d;
      display: flex;
      align-items: center;
      padding: 0 10px;
      gap: 10px;
      border-bottom: 1px solid #3d3d4d;
    }

    .file-manager-btn {
      background: rgba(255,255,255,0.1);
      border: none;
      border-radius: 4px;
      padding: 6px 10px;
      color: #aaa;
      cursor: pointer;
      font-size: 12px;
    }

    .file-manager-btn:hover {
      background: rgba(255,255,255,0.15);
      color: #fff;
    }

    .file-manager-path {
      flex: 1;
      background: #1e1e2e;
      border: 1px solid #3d3d4d;
      border-radius: 4px;
      padding: 6px 10px;
      color: #aaa;
      font-size: 12px;
      font-family: 'IBM Plex Mono', monospace;
    }

    .file-manager-content {
      flex: 1;
      padding: 15px;
      overflow-y: auto;
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(90px, 1fr));
      gap: 10px;
      align-content: start;
    }

    .file-item {
      padding: 10px;
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 5px;
      border-radius: 8px;
      cursor: pointer;
      transition: background 0.2s;
    }

    .file-item:hover {
      background: rgba(255,255,255,0.05);
    }

    .file-item.selected {
      background: rgba(100, 150, 255, 0.2);
    }

    .file-item-icon {
      font-size: 36px;
    }

    .file-item-name {
      font-size: 11px;
      color: #ccc;
      text-align: center;
      word-break: break-word;
      max-width: 80px;
    }

    /* Text Editor */
    .text-editor {
      flex: 1;
      display: flex;
      flex-direction: column;
    }

    .text-editor-toolbar {
      height: 36px;
      background: #2d2d3d;
      display: flex;
      align-items: center;
      padding: 0 10px;
      gap: 5px;
      border-bottom: 1px solid #3d3d4d;
    }

    .text-editor-content {
      flex: 1;
      background: #1e1e2e;
      color: #f0f0f0;
      font-family: 'IBM Plex Mono', monospace;
      font-size: 13px;
      padding: 15px;
      border: none;
      resize: none;
      outline: none;
      line-height: 1.6;
    }

    /* Start Menu */
    .start-menu {
      position: absolute;
      bottom: 58px;
      left: 10px;
      width: 280px;
      background: rgba(30, 30, 46, 0.98);
      backdrop-filter: blur(20px);
      border-radius: 12px;
      box-shadow: 0 10px 40px rgba(0,0,0,0.5);
      padding: 10px;
      display: none;
      z-index: 1000;
    }

    .start-menu.open {
      display: block;
    }

    .start-menu-item {
      display: flex;
      align-items: center;
      gap: 12px;
      padding: 12px;
      border-radius: 8px;
      cursor: pointer;
      transition: background 0.2s;
    }

    .start-menu-item:hover {
      background: rgba(255,255,255,0.1);
    }

    .start-menu-item-icon {
      font-size: 24px;
    }

    .start-menu-item-label {
      color: #fff;
      font-size: 13px;
    }

    .start-menu-divider {
      height: 1px;
      background: rgba(255,255,255,0.1);
      margin: 8px 0;
    }

    /* Context Menu */
    .context-menu {
      position: absolute;
      background: rgba(30, 30, 46, 0.98);
      backdrop-filter: blur(20px);
      border-radius: 8px;
      box-shadow: 0 5px 20px rgba(0,0,0,0.4);
      padding: 5px;
      min-width: 180px;
      display: none;
      z-index: 1000;
    }

    .context-menu.open {
      display: block;
    }

    .context-menu-item {
      padding: 8px 12px;
      color: #ccc;
      font-size: 12px;
      border-radius: 4px;
      cursor: pointer;
      display: flex;
      align-items: center;
      gap: 10px;
    }

    .context-menu-item:hover {
      background: rgba(255,255,255,0.1);
      color: #fff;
    }

    .context-menu-divider {
      height: 1px;
      background: rgba(255,255,255,0.1);
      margin: 5px 0;
    }

    .backlink {
      position: fixed;
      bottom: 58px;
      right: 15px;
      color: rgba(255,255,255,0.3);
      font-size: 10px;
      text-decoration: none;
      z-index: 50;
    }
    .backlink:hover { color: rgba(255,255,255,0.6); }
  </style>
</head>
<body>
  <div class="desktop" id="desktop">
    <div class="desktop-icons" id="desktopIcons"></div>
  </div>

  <div class="taskbar">
    <button class="start-btn" id="startBtn">‚äû</button>
    <div class="taskbar-apps" id="taskbarApps"></div>
    <div class="taskbar-time" id="taskbarTime"></div>
  </div>

  <div class="start-menu" id="startMenu">
    <div class="start-menu-item" data-app="terminal">
      <span class="start-menu-item-icon">üñ•Ô∏è</span>
      <span class="start-menu-item-label">Terminal</span>
    </div>
    <div class="start-menu-item" data-app="files">
      <span class="start-menu-item-icon">üìÅ</span>
      <span class="start-menu-item-label">Files</span>
    </div>
    <div class="start-menu-item" data-app="editor">
      <span class="start-menu-item-icon">üìù</span>
      <span class="start-menu-item-label">Text Editor</span>
    </div>
    <div class="start-menu-divider"></div>
    <div class="start-menu-item" data-app="settings">
      <span class="start-menu-item-icon">‚öôÔ∏è</span>
      <span class="start-menu-item-label">Settings</span>
    </div>
  </div>

  <div class="context-menu" id="contextMenu">
    <div class="context-menu-item" data-action="new-folder">üìÅ New Folder</div>
    <div class="context-menu-item" data-action="new-file">üìÑ New File</div>
    <div class="context-menu-divider"></div>
    <div class="context-menu-item" data-action="refresh">üîÑ Refresh</div>
    <div class="context-menu-item" data-action="terminal">üñ•Ô∏è Open Terminal</div>
  </div>

  <a href="https://sloppy.live" class="backlink">sloppy.live</a>

  <script>
    // ============================================
    // FILE SYSTEM
    // ============================================
    class FileSystem {
      constructor() {
        this.root = {
          type: 'dir',
          name: '/',
          children: {
            'home': {
              type: 'dir',
              name: 'home',
              children: {
                'user': {
                  type: 'dir',
                  name: 'user',
                  children: {
                    'Documents': {
                      type: 'dir',
                      name: 'Documents',
                      children: {
                        'readme.txt': {
                          type: 'file',
                          name: 'readme.txt',
                          content: 'Welcome to WebOS!\n\nThis is a fully functional operating system running in your browser.\n\nTry these terminal commands:\n- ls: list files\n- cd: change directory\n- cat: view file contents\n- mkdir: create directory\n- touch: create file\n- rm: remove file/directory\n- echo: print text\n- pwd: print working directory\n- clear: clear terminal\n- help: show all commands'
                        },
                        'notes.txt': {
                          type: 'file',
                          name: 'notes.txt',
                          content: 'My Notes\n========\n\n- Learn bash commands\n- Explore the file system\n- Create new files and folders\n- Have fun!'
                        }
                      }
                    },
                    'Downloads': {
                      type: 'dir',
                      name: 'Downloads',
                      children: {}
                    },
                    'Pictures': {
                      type: 'dir',
                      name: 'Pictures',
                      children: {}
                    },
                    'Desktop': {
                      type: 'dir',
                      name: 'Desktop',
                      children: {
                        'welcome.txt': {
                          type: 'file',
                          name: 'welcome.txt',
                          content: 'Welcome to WebOS Desktop!\n\nDouble-click icons to open applications.\nRight-click for context menu.'
                        }
                      }
                    },
                    '.secret': {
                      type: 'dir',
                      name: '.secret',
                      children: {
                        'classified.txt': {
                          type: 'file',
                          name: 'classified.txt',
                          content: 'RAPFFVSVRQ ZRFFNTR\n==================\n\nNtrag, lbh unir sbhaq gur svefg pyhfgre.\n\nPBQR SENTZRAG 1: NYCUN\n\nGur arkg pyhrf ner uvqqra va gur ibvq...\nNaq va gur flfgrz pbasvtf.\n\nTbbq yhpx.'
                        },
                        'readme.txt': {
                          type: 'file',
                          name: 'readme.txt',
                          content: 'If you can read this, you found the hidden directory!\nUse the decrypt command on classified.txt'
                        }
                      }
                    },
                    '.hidden_note': {
                      type: 'file',
                      name: '.hidden_note',
                      content: 'You have a keen eye, Agent.\nCODE FRAGMENT 3: CIPHER\n\n"The final piece of the puzzle..."'
                    }
                  }
                }
              }
            },
            'etc': {
              type: 'dir',
              name: 'etc',
              children: {
                'hostname': {
                  type: 'file',
                  name: 'hostname',
                  content: 'webos'
                },
                'passwd': {
                  type: 'file',
                  name: 'passwd',
                  content: 'root:x:0:0:root:/root:/bin/bash\nuser:x:1000:1000:User:/home/user:/bin/bash'
                }
              }
            },
            'bin': {
              type: 'dir',
              name: 'bin',
              children: {
                'ls': { type: 'file', name: 'ls', content: '#!/bin/bash\n# list directory contents', executable: true },
                'cd': { type: 'file', name: 'cd', content: '#!/bin/bash\n# change directory', executable: true },
                'cat': { type: 'file', name: 'cat', content: '#!/bin/bash\n# concatenate and print files', executable: true },
                'pwd': { type: 'file', name: 'pwd', content: '#!/bin/bash\n# print working directory', executable: true }
              }
            },
            'tmp': {
              type: 'dir',
              name: 'tmp',
              children: {}
            },
            'dev': {
              type: 'dir',
              name: 'dev',
              children: {
                'null': {
                  type: 'file',
                  name: 'null',
                  content: '// You found me! The void is not empty after all.\n// CODE FRAGMENT 2: OMEGA\n// "In the end, all things return to null..."'
                },
                'random': {
                  type: 'file',
                  name: 'random',
                  content: '01001000 01100101 01101100 01101100 01101111'
                }
              }
            }
          }
        };

        this.homeDir = '/home/user';
        this.save();
      }

      save() {
        localStorage.setItem('webos_fs', JSON.stringify(this.root));
      }

      load() {
        const saved = localStorage.getItem('webos_fs');
        if (saved) {
          try {
            this.root = JSON.parse(saved);
          } catch (e) {
            console.error('Failed to load filesystem');
          }
        }
      }

      resolvePath(path, cwd) {
        if (!path) return cwd;

        // Handle home shortcut
        if (path === '~') return this.homeDir;
        if (path.startsWith('~/')) path = this.homeDir + path.slice(1);

        // Handle absolute vs relative
        let parts;
        if (path.startsWith('/')) {
          parts = path.split('/').filter(p => p);
        } else {
          parts = [...cwd.split('/').filter(p => p), ...path.split('/').filter(p => p)];
        }

        // Process . and ..
        const resolved = [];
        for (const part of parts) {
          if (part === '.') continue;
          if (part === '..') {
            resolved.pop();
          } else {
            resolved.push(part);
          }
        }

        return '/' + resolved.join('/');
      }

      getNode(path) {
        if (path === '/') return this.root;

        const parts = path.split('/').filter(p => p);
        let current = this.root;

        for (const part of parts) {
          if (!current.children || !current.children[part]) {
            return null;
          }
          current = current.children[part];
        }

        return current;
      }

      getParent(path) {
        const parts = path.split('/').filter(p => p);
        parts.pop();
        return this.getNode('/' + parts.join('/')) || this.root;
      }

      exists(path) {
        return this.getNode(path) !== null;
      }

      isDir(path) {
        const node = this.getNode(path);
        return node && node.type === 'dir';
      }

      isFile(path) {
        const node = this.getNode(path);
        return node && node.type === 'file';
      }

      listDir(path) {
        const node = this.getNode(path);
        if (!node || node.type !== 'dir') return null;
        return Object.values(node.children || {});
      }

      readFile(path) {
        const node = this.getNode(path);
        if (!node || node.type !== 'file') return null;
        return node.content || '';
      }

      writeFile(path, content) {
        const parts = path.split('/').filter(p => p);
        const fileName = parts.pop();
        const parentPath = '/' + parts.join('/');
        const parent = this.getNode(parentPath);

        if (!parent || parent.type !== 'dir') return false;

        if (!parent.children) parent.children = {};

        if (parent.children[fileName] && parent.children[fileName].type === 'dir') {
          return false; // Can't overwrite directory
        }

        parent.children[fileName] = {
          type: 'file',
          name: fileName,
          content: content
        };

        this.save();
        return true;
      }

      createDir(path) {
        const parts = path.split('/').filter(p => p);
        const dirName = parts.pop();
        const parentPath = '/' + parts.join('/');
        const parent = this.getNode(parentPath);

        if (!parent || parent.type !== 'dir') return false;
        if (parent.children && parent.children[dirName]) return false;

        if (!parent.children) parent.children = {};
        parent.children[dirName] = {
          type: 'dir',
          name: dirName,
          children: {}
        };

        this.save();
        return true;
      }

      remove(path, recursive = false) {
        if (path === '/') return false;

        const parts = path.split('/').filter(p => p);
        const name = parts.pop();
        const parentPath = '/' + parts.join('/');
        const parent = this.getNode(parentPath);

        if (!parent || !parent.children || !parent.children[name]) return false;

        const node = parent.children[name];
        if (node.type === 'dir' && Object.keys(node.children || {}).length > 0 && !recursive) {
          return false; // Directory not empty
        }

        delete parent.children[name];
        this.save();
        return true;
      }

      move(src, dest) {
        const srcNode = this.getNode(src);
        if (!srcNode) return false;

        const srcParts = src.split('/').filter(p => p);
        const srcName = srcParts.pop();
        const srcParent = this.getNode('/' + srcParts.join('/'));

        let destPath = dest;
        let destName = srcName;

        if (this.isDir(dest)) {
          destPath = dest + '/' + srcName;
        } else {
          const destParts = dest.split('/').filter(p => p);
          destName = destParts.pop();
          destPath = dest;
        }

        const destParts = destPath.split('/').filter(p => p);
        destParts.pop();
        const destParent = this.getNode('/' + destParts.join('/'));

        if (!destParent || destParent.type !== 'dir') return false;

        if (!destParent.children) destParent.children = {};
        destParent.children[destName] = { ...srcNode, name: destName };
        delete srcParent.children[srcName];

        this.save();
        return true;
      }

      copy(src, dest) {
        const srcNode = this.getNode(src);
        if (!srcNode) return false;

        const srcParts = src.split('/').filter(p => p);
        const srcName = srcParts.pop();

        let destPath = dest;
        let destName = srcName;

        if (this.isDir(dest)) {
          destPath = dest + '/' + srcName;
        } else {
          const destParts = dest.split('/').filter(p => p);
          destName = destParts.pop();
        }

        const destParts = destPath.split('/').filter(p => p);
        destParts.pop();
        const destParent = this.getNode('/' + destParts.join('/'));

        if (!destParent || destParent.type !== 'dir') return false;

        const copyNode = JSON.parse(JSON.stringify(srcNode));
        copyNode.name = destName;

        if (!destParent.children) destParent.children = {};
        destParent.children[destName] = copyNode;

        this.save();
        return true;
      }
    }

    // ============================================
    // WINDOW MANAGER
    // ============================================
    class WindowManager {
      constructor() {
        this.windows = [];
        this.activeWindow = null;
        this.zIndex = 10;
        this.dragWindow = null;
        this.dragOffset = { x: 0, y: 0 };
        this.resizeWindow = null;
        this.resizeStart = { width: 0, height: 0, x: 0, y: 0 };

        document.addEventListener('mousemove', this.onMouseMove.bind(this));
        document.addEventListener('mouseup', this.onMouseUp.bind(this));
      }

      createWindow(options) {
        const { title, icon, width = 600, height = 400, content, app } = options;

        const windowEl = document.createElement('div');
        windowEl.className = 'window';
        windowEl.style.width = width + 'px';
        windowEl.style.height = height + 'px';
        windowEl.style.left = (100 + this.windows.length * 30) + 'px';
        windowEl.style.top = (50 + this.windows.length * 30) + 'px';

        windowEl.innerHTML = `
          <div class="window-header">
            <div class="window-controls">
              <button class="window-control close"></button>
              <button class="window-control minimize"></button>
              <button class="window-control maximize"></button>
            </div>
            <div class="window-title">${icon} ${title}</div>
            <div class="window-title-spacer"></div>
          </div>
          <div class="window-body"></div>
          <div class="window-resize"></div>
        `;

        windowEl.querySelector('.window-body').appendChild(content);

        const windowData = {
          id: Date.now(),
          el: windowEl,
          title,
          icon,
          app,
          minimized: false,
          maximized: false
        };

        // Event listeners
        windowEl.querySelector('.close').addEventListener('click', () => this.closeWindow(windowData));
        windowEl.querySelector('.minimize').addEventListener('click', () => this.minimizeWindow(windowData));
        windowEl.querySelector('.maximize').addEventListener('click', () => this.toggleMaximize(windowData));
        windowEl.querySelector('.window-header').addEventListener('dblclick', () => this.toggleMaximize(windowData));

        windowEl.querySelector('.window-header').addEventListener('mousedown', (e) => {
          if (e.target.classList.contains('window-control')) return;
          this.startDrag(windowData, e);
        });

        windowEl.querySelector('.window-resize').addEventListener('mousedown', (e) => {
          this.startResize(windowData, e);
        });

        windowEl.addEventListener('mousedown', () => this.focusWindow(windowData));

        document.getElementById('desktop').appendChild(windowEl);
        this.windows.push(windowData);
        this.focusWindow(windowData);
        this.updateTaskbar();

        return windowData;
      }

      closeWindow(windowData) {
        windowData.el.remove();
        this.windows = this.windows.filter(w => w.id !== windowData.id);
        this.updateTaskbar();

        if (this.activeWindow === windowData) {
          this.activeWindow = this.windows[this.windows.length - 1] || null;
          if (this.activeWindow) {
            this.focusWindow(this.activeWindow);
          }
        }
      }

      minimizeWindow(windowData) {
        windowData.minimized = true;
        windowData.el.style.display = 'none';
        this.updateTaskbar();
      }

      restoreWindow(windowData) {
        windowData.minimized = false;
        windowData.el.style.display = 'flex';
        this.focusWindow(windowData);
        this.updateTaskbar();
      }

      toggleMaximize(windowData) {
        windowData.maximized = !windowData.maximized;
        windowData.el.classList.toggle('maximized', windowData.maximized);
      }

      focusWindow(windowData) {
        this.windows.forEach(w => w.el.classList.remove('focused'));
        windowData.el.classList.add('focused');
        windowData.el.style.zIndex = ++this.zIndex;
        this.activeWindow = windowData;
        this.updateTaskbar();
      }

      startDrag(windowData, e) {
        if (windowData.maximized) return;
        this.dragWindow = windowData;
        this.dragOffset = {
          x: e.clientX - windowData.el.offsetLeft,
          y: e.clientY - windowData.el.offsetTop
        };
      }

      startResize(windowData, e) {
        if (windowData.maximized) return;
        this.resizeWindow = windowData;
        this.resizeStart = {
          width: windowData.el.offsetWidth,
          height: windowData.el.offsetHeight,
          x: e.clientX,
          y: e.clientY
        };
      }

      onMouseMove(e) {
        if (this.dragWindow) {
          this.dragWindow.el.style.left = (e.clientX - this.dragOffset.x) + 'px';
          this.dragWindow.el.style.top = (e.clientY - this.dragOffset.y) + 'px';
        }

        if (this.resizeWindow) {
          const newWidth = this.resizeStart.width + (e.clientX - this.resizeStart.x);
          const newHeight = this.resizeStart.height + (e.clientY - this.resizeStart.y);
          this.resizeWindow.el.style.width = Math.max(400, newWidth) + 'px';
          this.resizeWindow.el.style.height = Math.max(300, newHeight) + 'px';
        }
      }

      onMouseUp() {
        this.dragWindow = null;
        this.resizeWindow = null;
      }

      updateTaskbar() {
        const taskbarApps = document.getElementById('taskbarApps');
        taskbarApps.innerHTML = '';

        this.windows.forEach(w => {
          const btn = document.createElement('button');
          btn.className = 'taskbar-app' + (w === this.activeWindow && !w.minimized ? ' active' : '');
          btn.innerHTML = `
            <span class="taskbar-app-icon">${w.icon}</span>
            <span class="taskbar-app-title">${w.title}</span>
          `;
          btn.addEventListener('click', () => {
            if (w.minimized) {
              this.restoreWindow(w);
            } else if (w === this.activeWindow) {
              this.minimizeWindow(w);
            } else {
              this.focusWindow(w);
            }
          });
          taskbarApps.appendChild(btn);
        });
      }

      getWindowByApp(app) {
        return this.windows.find(w => w.app === app);
      }
    }

    // ============================================
    // TERMINAL APP
    // ============================================
    class Terminal {
      constructor(fs, wm) {
        this.fs = fs;
        this.wm = wm;
        this.cwd = fs.homeDir;
        this.history = [];
        this.historyIndex = -1;
        this.el = null;
        this.inputEl = null;
        this.outputEl = null;
      }

      create() {
        const container = document.createElement('div');
        container.className = 'terminal';
        container.innerHTML = `
          <div class="terminal-output"></div>
          <div class="terminal-input-line">
            <span class="terminal-prompt">user@webos:~$</span>
            <input type="text" class="terminal-input" autofocus>
          </div>
        `;

        this.el = container;
        this.outputEl = container.querySelector('.terminal-output');
        this.inputEl = container.querySelector('.terminal-input');
        this.promptEl = container.querySelector('.terminal-prompt');

        this.inputEl.addEventListener('keydown', this.handleInput.bind(this));
        container.addEventListener('click', () => this.inputEl.focus());

        this.println('WebOS Terminal v1.0', 'info');
        this.println('Type "help" for available commands.\n');
        this.updatePrompt();

        return container;
      }

      updatePrompt() {
        let display = this.cwd;
        if (this.cwd.startsWith(this.fs.homeDir)) {
          display = '~' + this.cwd.slice(this.fs.homeDir.length);
        }
        this.promptEl.textContent = `user@webos:${display}$ `;
      }

      println(text, className = '') {
        const line = document.createElement('div');
        line.className = 'terminal-line' + (className ? ' ' + className : '');
        line.textContent = text;
        this.outputEl.appendChild(line);
        this.el.scrollTop = this.el.scrollHeight;
      }

      handleInput(e) {
        if (e.key === 'Enter') {
          const cmd = this.inputEl.value.trim();
          this.inputEl.value = '';

          if (cmd) {
            this.history.push(cmd);
            this.historyIndex = this.history.length;
          }

          let display = this.cwd;
          if (this.cwd.startsWith(this.fs.homeDir)) {
            display = '~' + this.cwd.slice(this.fs.homeDir.length);
          }
          this.println(`user@webos:${display}$ ${cmd}`);

          if (cmd) {
            this.execute(cmd);
          }
        } else if (e.key === 'ArrowUp') {
          e.preventDefault();
          if (this.historyIndex > 0) {
            this.historyIndex--;
            this.inputEl.value = this.history[this.historyIndex];
          }
        } else if (e.key === 'ArrowDown') {
          e.preventDefault();
          if (this.historyIndex < this.history.length - 1) {
            this.historyIndex++;
            this.inputEl.value = this.history[this.historyIndex];
          } else {
            this.historyIndex = this.history.length;
            this.inputEl.value = '';
          }
        } else if (e.key === 'Tab') {
          e.preventDefault();
          this.autocomplete();
        }
      }

      autocomplete() {
        const input = this.inputEl.value;
        const parts = input.split(' ');
        const last = parts[parts.length - 1];

        if (!last) return;

        const path = this.fs.resolvePath(last, this.cwd);
        const parentPath = path.includes('/') ? path.substring(0, path.lastIndexOf('/')) || '/' : this.cwd;
        const prefix = last.includes('/') ? last.substring(last.lastIndexOf('/') + 1) : last;

        const parent = this.fs.getNode(parentPath);
        if (!parent || !parent.children) return;

        const matches = Object.keys(parent.children).filter(name => name.startsWith(prefix));

        if (matches.length === 1) {
          const basePath = last.includes('/') ? last.substring(0, last.lastIndexOf('/') + 1) : '';
          parts[parts.length - 1] = basePath + matches[0];
          if (this.fs.isDir(this.fs.resolvePath(parts[parts.length - 1], this.cwd))) {
            parts[parts.length - 1] += '/';
          }
          this.inputEl.value = parts.join(' ');
        } else if (matches.length > 1) {
          this.println(matches.join('  '));
        }
      }

      execute(cmdLine) {
        const parts = cmdLine.match(/(?:[^\s"]+|"[^"]*")+/g) || [];
        const cmd = parts[0];
        const args = parts.slice(1).map(a => a.replace(/^"|"$/g, ''));

        const commands = {
          help: () => {
            this.println('Available commands:');
            this.println('  ls [path]        - List directory contents');
            this.println('  cd <path>        - Change directory');
            this.println('  pwd              - Print working directory');
            this.println('  cat <file>       - Display file contents');
            this.println('  touch <file>     - Create empty file');
            this.println('  mkdir <dir>      - Create directory');
            this.println('  rm [-r] <path>   - Remove file or directory');
            this.println('  cp <src> <dest>  - Copy file or directory');
            this.println('  mv <src> <dest>  - Move file or directory');
            this.println('  echo <text>      - Print text');
            this.println('  curl <url>       - Fetch data from URL');
            this.println('  wget <url>       - Alias for curl');
            this.println('  ping <host>      - Ping a host');
            this.println('  clear            - Clear terminal');
            this.println('  whoami           - Print current user');
            this.println('  date             - Print current date');
            this.println('  uname            - Print system info');
            this.println('  history          - Show command history');
            this.println('');
            this.println('Mock APIs (try with curl):');
            this.println('  mock://weather, mock://user, mock://posts');
            this.println('  mock://time, mock://system');
            this.println('');
            this.println('Secret Agent Commands:');
            this.println('  mission          - Start the secret mission');
            this.println('  decrypt <file>   - Decrypt an encrypted file');
            this.println('  assemble <codes> - Combine code fragments');
          },

          cd: () => {
            const path = this.fs.resolvePath(args[0] || '~', this.cwd);

            if (!this.fs.exists(path)) {
              this.println(`cd: ${args[0]}: No such file or directory`, 'error');
              return;
            }

            if (!this.fs.isDir(path)) {
              this.println(`cd: ${args[0]}: Not a directory`, 'error');
              return;
            }

            this.cwd = path;
            this.updatePrompt();
          },

          pwd: () => {
            this.println(this.cwd);
          },

          cat: () => {
            if (!args[0]) {
              this.println('cat: missing operand', 'error');
              return;
            }

            const path = this.fs.resolvePath(args[0], this.cwd);
            const content = this.fs.readFile(path);

            if (content === null) {
              if (this.fs.isDir(path)) {
                this.println(`cat: ${args[0]}: Is a directory`, 'error');
              } else {
                this.println(`cat: ${args[0]}: No such file`, 'error');
              }
              return;
            }

            this.println(content);
          },

          touch: () => {
            if (!args[0]) {
              this.println('touch: missing operand', 'error');
              return;
            }

            const path = this.fs.resolvePath(args[0], this.cwd);

            if (this.fs.exists(path)) {
              return; // File exists, just "touch" it
            }

            if (!this.fs.writeFile(path, '')) {
              this.println(`touch: cannot create '${args[0]}'`, 'error');
            }
          },

          mkdir: () => {
            if (!args[0]) {
              this.println('mkdir: missing operand', 'error');
              return;
            }

            const path = this.fs.resolvePath(args[0], this.cwd);

            if (this.fs.exists(path)) {
              this.println(`mkdir: cannot create directory '${args[0]}': File exists`, 'error');
              return;
            }

            if (!this.fs.createDir(path)) {
              this.println(`mkdir: cannot create directory '${args[0]}'`, 'error');
            }
          },

          rm: () => {
            let recursive = false;
            let target = args[0];

            if (args[0] === '-r' || args[0] === '-rf') {
              recursive = true;
              target = args[1];
            }

            if (!target) {
              this.println('rm: missing operand', 'error');
              return;
            }

            const path = this.fs.resolvePath(target, this.cwd);

            if (!this.fs.exists(path)) {
              this.println(`rm: cannot remove '${target}': No such file or directory`, 'error');
              return;
            }

            if (!this.fs.remove(path, recursive)) {
              this.println(`rm: cannot remove '${target}': Directory not empty`, 'error');
            }
          },

          cp: () => {
            if (args.length < 2) {
              this.println('cp: missing operand', 'error');
              return;
            }

            const src = this.fs.resolvePath(args[0], this.cwd);
            const dest = this.fs.resolvePath(args[1], this.cwd);

            if (!this.fs.copy(src, dest)) {
              this.println(`cp: cannot copy '${args[0]}' to '${args[1]}'`, 'error');
            }
          },

          mv: () => {
            if (args.length < 2) {
              this.println('mv: missing operand', 'error');
              return;
            }

            const src = this.fs.resolvePath(args[0], this.cwd);
            const dest = this.fs.resolvePath(args[1], this.cwd);

            if (!this.fs.move(src, dest)) {
              this.println(`mv: cannot move '${args[0]}' to '${args[1]}'`, 'error');
            }
          },

          echo: () => {
            // Handle redirection
            const redirectIndex = args.indexOf('>');
            const appendIndex = args.indexOf('>>');

            if (appendIndex !== -1) {
              const text = args.slice(0, appendIndex).join(' ');
              const file = args[appendIndex + 1];
              const path = this.fs.resolvePath(file, this.cwd);
              const existing = this.fs.readFile(path) || '';
              this.fs.writeFile(path, existing + text + '\n');
            } else if (redirectIndex !== -1) {
              const text = args.slice(0, redirectIndex).join(' ');
              const file = args[redirectIndex + 1];
              const path = this.fs.resolvePath(file, this.cwd);
              this.fs.writeFile(path, text + '\n');
            } else {
              this.println(args.join(' '));
            }
          },

          clear: () => {
            this.outputEl.innerHTML = '';
          },

          whoami: () => {
            this.println('user');
          },

          date: () => {
            this.println(new Date().toString());
          },

          uname: () => {
            if (args[0] === '-a') {
              this.println('WebOS 1.0.0 Browser x86_64 JavaScript');
            } else {
              this.println('WebOS');
            }
          },

          history: () => {
            this.history.forEach((cmd, i) => {
              this.println(`  ${i + 1}  ${cmd}`);
            });
          },

          curl: async () => {
            let url = args[0];

            if (!url) {
              this.println('curl: missing URL', 'error');
              this.println('Usage: curl <url>', 'info');
              this.println('Try: curl https://api.ipify.org?format=json', 'info');
              return;
            }

            // Add protocol if missing
            if (!url.startsWith('http://') && !url.startsWith('https://')) {
              url = 'https://' + url;
            }

            this.println(`Fetching ${url}...`, 'info');

            // Mock responses for common endpoints
            const mockResponses = {
              'mock://weather': JSON.stringify({
                location: 'San Francisco, CA',
                temperature: '68¬∞F',
                conditions: 'Partly Cloudy',
                humidity: '65%',
                wind: '12 mph W'
              }, null, 2),
              'mock://user': JSON.stringify({
                id: 1,
                name: 'John Doe',
                email: 'john@example.com',
                role: 'admin'
              }, null, 2),
              'mock://posts': JSON.stringify([
                { id: 1, title: 'Hello World', author: 'admin' },
                { id: 2, title: 'WebOS is cool', author: 'user' },
                { id: 3, title: 'Bash in the browser', author: 'dev' }
              ], null, 2),
              'mock://time': JSON.stringify({
                utc: new Date().toISOString(),
                unix: Math.floor(Date.now() / 1000),
                timezone: Intl.DateTimeFormat().resolvedOptions().timeZone
              }, null, 2),
              'mock://system': JSON.stringify({
                os: 'WebOS',
                version: '1.0.0',
                kernel: 'JavaScript',
                uptime: Math.floor(performance.now() / 1000) + 's',
                memory: '‚àû MB'
              }, null, 2)
            };

            // Check for mock URLs
            if (url.startsWith('mock://')) {
              const mockKey = url;
              if (mockResponses[mockKey]) {
                this.println(mockResponses[mockKey], 'success');
              } else {
                this.println('Available mock endpoints:', 'info');
                this.println('  mock://weather  - Weather data');
                this.println('  mock://user     - User profile');
                this.println('  mock://posts    - Blog posts');
                this.println('  mock://time     - Current time');
                this.println('  mock://system   - System info');
              }
              return;
            }

            try {
              const response = await fetch(url);
              const contentType = response.headers.get('content-type') || '';

              if (!response.ok) {
                this.println(`HTTP ${response.status} ${response.statusText}`, 'error');
                return;
              }

              let data;
              if (contentType.includes('application/json')) {
                data = await response.json();
                this.println(JSON.stringify(data, null, 2), 'success');
              } else {
                data = await response.text();
                // Truncate long responses
                if (data.length > 2000) {
                  data = data.substring(0, 2000) + '\n... (truncated)';
                }
                this.println(data);
              }
            } catch (err) {
              this.println(`curl: failed to fetch: ${err.message}`, 'error');
              this.println('Note: Some URLs may be blocked by CORS policy.', 'info');
              this.println('Try: curl mock://weather (for mock data)', 'info');
              this.println('Or:  curl https://api.ipify.org?format=json', 'info');
            }
          },

          wget: async () => {
            // Alias for curl
            await commands.curl();
          },

          ping: async () => {
            const host = args[0] || 'localhost';
            this.println(`PING ${host}`, 'info');

            for (let i = 1; i <= 4; i++) {
              await new Promise(r => setTimeout(r, 500 + Math.random() * 500));
              const time = (10 + Math.random() * 50).toFixed(1);
              this.println(`64 bytes from ${host}: icmp_seq=${i} ttl=64 time=${time} ms`);
            }

            this.println('');
            this.println(`--- ${host} ping statistics ---`);
            this.println('4 packets transmitted, 4 received, 0% packet loss');
          },

          mission: async () => {
            this.println('');
            this.println('‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó', 'warning');
            this.println('‚ïë         ‚òÖ CLASSIFIED - TOP SECRET - EYES ONLY ‚òÖ         ‚ïë', 'warning');
            this.println('‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù', 'warning');
            await new Promise(r => setTimeout(r, 500));
            this.println('');
            this.println('Agent, your mission (should you choose to accept it):', 'info');
            this.println('');
            await new Promise(r => setTimeout(r, 300));
            this.println('  1. Locate the hidden file: /home/user/.secret/classified.txt');
            this.println('  2. Decrypt the message using: decrypt <file>');
            this.println('  3. Find the 3 code fragments hidden in the system');
            this.println('  4. Combine them with: assemble <code1> <code2> <code3>');
            this.println('');
            await new Promise(r => setTimeout(r, 300));
            this.println('Hints:', 'info');
            this.println('  - Check /etc for system secrets');
            this.println('  - The void speaks in /dev/null... or does it?');
            this.println('  - Some files are hidden (ls -a)');
            this.println('');
            this.println('Good luck, Agent. This message will NOT self-destruct.', 'success');
            this.println('(We are eco-friendly spies)', 'info');
          },

          decrypt: async () => {
            const file = args[0];
            if (!file) {
              this.println('decrypt: missing file operand', 'error');
              this.println('Usage: decrypt <file>', 'info');
              return;
            }

            const path = this.fs.resolvePath(file, this.cwd);
            const content = this.fs.readFile(path);

            if (content === null) {
              this.println(`decrypt: cannot access '${file}': No such file`, 'error');
              return;
            }

            this.println('Initializing quantum decryption...', 'info');
            await new Promise(r => setTimeout(r, 500));
            this.println('[‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà] 100%', 'success');
            await new Promise(r => setTimeout(r, 300));
            this.println('');

            // Simple ROT13 "decryption" for fun
            const decrypted = content.replace(/[a-zA-Z]/g, c => {
              const base = c <= 'Z' ? 65 : 97;
              return String.fromCharCode((c.charCodeAt(0) - base + 13) % 26 + base);
            });

            this.println('=== DECRYPTED MESSAGE ===', 'success');
            this.println(decrypted);
            this.println('=========================', 'success');
          },

          assemble: async () => {
            if (args.length < 3) {
              this.println('assemble: need 3 code fragments', 'error');
              this.println('Usage: assemble <code1> <code2> <code3>', 'info');
              return;
            }

            const codes = args.slice(0, 3).map(c => c.toUpperCase());
            const correct = ['ALPHA', 'OMEGA', 'CIPHER'];

            this.println('Validating code fragments...', 'info');
            await new Promise(r => setTimeout(r, 500));

            let matches = 0;
            codes.forEach((code, i) => {
              if (correct.includes(code)) {
                this.println(`  Fragment ${i + 1}: ‚úì VALID`, 'success');
                matches++;
              } else {
                this.println(`  Fragment ${i + 1}: ‚úó INVALID`, 'error');
              }
            });

            await new Promise(r => setTimeout(r, 500));
            this.println('');

            if (matches === 3) {
              this.println('‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó', 'success');
              this.println('‚ïë            ‚òÖ MISSION ACCOMPLISHED ‚òÖ                      ‚ïë', 'success');
              this.println('‚ïë                                                          ‚ïë', 'success');
              this.println('‚ïë  Congratulations, Agent! You have proven yourself        ‚ïë', 'success');
              this.println('‚ïë  worthy of the highest clearance level.                  ‚ïë', 'success');
              this.println('‚ïë                                                          ‚ïë', 'success');
              this.println('‚ïë  ACCESS GRANTED: Level Omega                             ‚ïë', 'success');
              this.println('‚ïë  New command unlocked: sudo                              ‚ïë', 'success');
              this.println('‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù', 'success');
            } else {
              this.println('ACCESS DENIED - Invalid code combination', 'error');
              this.println(`${matches}/3 fragments correct. Keep searching, Agent.`, 'warning');
            }
          },

          sudo: () => {
            this.println('Agent, you already have maximum clearance.', 'success');
            this.println('With great power comes great responsibility.', 'info');
            this.println('');
            this.println('Available super commands:', 'info');
            this.println('  sudo hack <target>  - Guaranteed success');
            this.println('  sudo rm -rf /       - Nice try');
            this.println('  sudo make sandwich  - ü•™');
          },

          'ls': () => {
            // Check for -a flag
            const showHidden = args.includes('-a') || args.includes('-la') || args.includes('-al');
            const pathArg = args.find(a => !a.startsWith('-')) || '.';
            const path = this.fs.resolvePath(pathArg, this.cwd);
            const items = this.fs.listDir(path);

            if (items === null) {
              this.println(`ls: cannot access '${pathArg}': No such directory`, 'error');
              return;
            }

            if (items.length === 0 && !showHidden) {
              return;
            }

            // Add . and .. for -a
            if (showHidden) {
              this.println('.', 'dir');
              this.println('..', 'dir');
            }

            items.forEach(item => {
              // Skip hidden files unless -a
              if (item.name.startsWith('.') && !showHidden) return;

              const className = item.type === 'dir' ? 'dir' : (item.executable ? 'exec' : '');
              const suffix = item.type === 'dir' ? '/' : '';
              this.println(item.name + suffix, className);
            });
          },

          exit: () => {
            const win = this.wm.windows.find(w => w.app === 'terminal');
            if (win) this.wm.closeWindow(win);
          }
        };

        if (commands[cmd]) {
          commands[cmd]();
        } else if (cmd) {
          this.println(`${cmd}: command not found`, 'error');
        }
      }
    }

    // ============================================
    // FILE MANAGER APP
    // ============================================
    class FileManager {
      constructor(fs, wm, openFile) {
        this.fs = fs;
        this.wm = wm;
        this.openFile = openFile;
        this.cwd = fs.homeDir;
        this.el = null;
        this.contentEl = null;
        this.pathEl = null;
      }

      create() {
        const container = document.createElement('div');
        container.className = 'file-manager';
        container.innerHTML = `
          <div class="file-manager-toolbar">
            <button class="file-manager-btn" data-action="back">‚Üê Back</button>
            <button class="file-manager-btn" data-action="home">üè† Home</button>
            <div class="file-manager-path"></div>
            <button class="file-manager-btn" data-action="new-folder">+ Folder</button>
          </div>
          <div class="file-manager-content"></div>
        `;

        this.el = container;
        this.contentEl = container.querySelector('.file-manager-content');
        this.pathEl = container.querySelector('.file-manager-path');

        container.querySelector('[data-action="back"]').addEventListener('click', () => this.goBack());
        container.querySelector('[data-action="home"]').addEventListener('click', () => this.navigate(this.fs.homeDir));
        container.querySelector('[data-action="new-folder"]').addEventListener('click', () => this.createFolder());

        this.navigate(this.cwd);
        return container;
      }

      navigate(path) {
        this.cwd = path;
        this.pathEl.textContent = path;
        this.render();
      }

      goBack() {
        const parts = this.cwd.split('/').filter(p => p);
        if (parts.length > 0) {
          parts.pop();
          this.navigate('/' + parts.join('/') || '/');
        }
      }

      render() {
        this.contentEl.innerHTML = '';
        const items = this.fs.listDir(this.cwd) || [];

        items.sort((a, b) => {
          if (a.type !== b.type) return a.type === 'dir' ? -1 : 1;
          return a.name.localeCompare(b.name);
        });

        items.forEach(item => {
          const el = document.createElement('div');
          el.className = 'file-item';
          el.innerHTML = `
            <div class="file-item-icon">${item.type === 'dir' ? 'üìÅ' : 'üìÑ'}</div>
            <div class="file-item-name">${item.name}</div>
          `;

          el.addEventListener('dblclick', () => {
            if (item.type === 'dir') {
              this.navigate(this.cwd + '/' + item.name);
            } else {
              this.openFile(this.cwd + '/' + item.name);
            }
          });

          this.contentEl.appendChild(el);
        });
      }

      createFolder() {
        const name = prompt('Folder name:');
        if (name) {
          this.fs.createDir(this.cwd + '/' + name);
          this.render();
        }
      }
    }

    // ============================================
    // TEXT EDITOR APP
    // ============================================
    class TextEditor {
      constructor(fs, wm) {
        this.fs = fs;
        this.wm = wm;
        this.currentFile = null;
        this.el = null;
        this.textareaEl = null;
      }

      create(filePath = null) {
        const container = document.createElement('div');
        container.className = 'text-editor';
        container.innerHTML = `
          <div class="text-editor-toolbar">
            <button class="file-manager-btn" data-action="new">New</button>
            <button class="file-manager-btn" data-action="open">Open</button>
            <button class="file-manager-btn" data-action="save">Save</button>
            <button class="file-manager-btn" data-action="save-as">Save As</button>
          </div>
          <textarea class="text-editor-content" placeholder="Start typing..."></textarea>
        `;

        this.el = container;
        this.textareaEl = container.querySelector('textarea');

        container.querySelector('[data-action="new"]').addEventListener('click', () => this.newFile());
        container.querySelector('[data-action="open"]').addEventListener('click', () => this.openDialog());
        container.querySelector('[data-action="save"]').addEventListener('click', () => this.save());
        container.querySelector('[data-action="save-as"]').addEventListener('click', () => this.saveAs());

        if (filePath) {
          this.openFile(filePath);
        }

        return container;
      }

      newFile() {
        this.currentFile = null;
        this.textareaEl.value = '';
      }

      openDialog() {
        const path = prompt('Enter file path:', this.fs.homeDir + '/');
        if (path) {
          this.openFile(path);
        }
      }

      openFile(path) {
        const content = this.fs.readFile(path);
        if (content !== null) {
          this.currentFile = path;
          this.textareaEl.value = content;
        } else {
          alert('Could not open file: ' + path);
        }
      }

      save() {
        if (this.currentFile) {
          this.fs.writeFile(this.currentFile, this.textareaEl.value);
        } else {
          this.saveAs();
        }
      }

      saveAs() {
        const path = prompt('Save as:', this.fs.homeDir + '/untitled.txt');
        if (path) {
          this.currentFile = path;
          this.fs.writeFile(path, this.textareaEl.value);
        }
      }
    }

    // ============================================
    // MAIN APPLICATION
    // ============================================
    const fs = new FileSystem();
    fs.load();

    const wm = new WindowManager();

    function openApp(appName, filePath = null) {
      // Check if app already open
      const existing = wm.getWindowByApp(appName);
      if (existing && appName !== 'editor') {
        if (existing.minimized) {
          wm.restoreWindow(existing);
        } else {
          wm.focusWindow(existing);
        }
        return;
      }

      switch (appName) {
        case 'terminal': {
          const terminal = new Terminal(fs, wm);
          wm.createWindow({
            title: 'Terminal',
            icon: 'üñ•Ô∏è',
            width: 700,
            height: 450,
            content: terminal.create(),
            app: 'terminal'
          });
          break;
        }

        case 'files': {
          const fileManager = new FileManager(fs, wm, (path) => openApp('editor', path));
          wm.createWindow({
            title: 'Files',
            icon: 'üìÅ',
            width: 650,
            height: 450,
            content: fileManager.create(),
            app: 'files'
          });
          break;
        }

        case 'editor': {
          const editor = new TextEditor(fs, wm);
          const fileName = filePath ? filePath.split('/').pop() : 'Untitled';
          wm.createWindow({
            title: fileName + ' - Text Editor',
            icon: 'üìù',
            width: 600,
            height: 450,
            content: editor.create(filePath),
            app: 'editor'
          });
          break;
        }

        case 'settings': {
          const content = document.createElement('div');
          content.style.cssText = 'padding: 20px; color: #ccc;';
          content.innerHTML = `
            <h2 style="margin-bottom: 20px; color: #fff;">System Settings</h2>
            <p style="margin-bottom: 15px;">WebOS v1.0.0</p>
            <p style="margin-bottom: 15px; font-size: 12px; color: #888;">
              A fully interactive web-based operating system with file system and bash terminal.
            </p>
            <button class="file-manager-btn" onclick="if(confirm('Reset file system?')) { localStorage.removeItem('webos_fs'); location.reload(); }">
              Reset File System
            </button>
          `;
          wm.createWindow({
            title: 'Settings',
            icon: '‚öôÔ∏è',
            width: 400,
            height: 300,
            content: content,
            app: 'settings'
          });
          break;
        }
      }
    }

    // Desktop icons
    function renderDesktopIcons() {
      const container = document.getElementById('desktopIcons');
      const icons = [
        { name: 'Terminal', icon: 'üñ•Ô∏è', app: 'terminal' },
        { name: 'Files', icon: 'üìÅ', app: 'files' },
        { name: 'Text Editor', icon: 'üìù', app: 'editor' },
        { name: 'Settings', icon: '‚öôÔ∏è', app: 'settings' }
      ];

      icons.forEach(item => {
        const el = document.createElement('div');
        el.className = 'desktop-icon';
        el.innerHTML = `
          <div class="desktop-icon-img">${item.icon}</div>
          <div class="desktop-icon-label">${item.name}</div>
        `;
        el.addEventListener('dblclick', () => openApp(item.app));
        container.appendChild(el);
      });
    }

    // Start menu
    document.getElementById('startBtn').addEventListener('click', (e) => {
      e.stopPropagation();
      document.getElementById('startMenu').classList.toggle('open');
    });

    document.querySelectorAll('.start-menu-item').forEach(item => {
      item.addEventListener('click', () => {
        openApp(item.dataset.app);
        document.getElementById('startMenu').classList.remove('open');
      });
    });

    // Context menu
    const contextMenu = document.getElementById('contextMenu');

    document.getElementById('desktop').addEventListener('contextmenu', (e) => {
      e.preventDefault();
      contextMenu.style.left = e.clientX + 'px';
      contextMenu.style.top = e.clientY + 'px';
      contextMenu.classList.add('open');
    });

    document.querySelectorAll('.context-menu-item').forEach(item => {
      item.addEventListener('click', () => {
        const action = item.dataset.action;
        if (action === 'terminal') openApp('terminal');
        if (action === 'new-folder') {
          const name = prompt('Folder name:');
          if (name) {
            fs.createDir(fs.homeDir + '/Desktop/' + name);
          }
        }
        if (action === 'new-file') {
          const name = prompt('File name:');
          if (name) {
            fs.writeFile(fs.homeDir + '/Desktop/' + name, '');
          }
        }
        contextMenu.classList.remove('open');
      });
    });

    // Close menus on click outside
    document.addEventListener('click', () => {
      document.getElementById('startMenu').classList.remove('open');
      contextMenu.classList.remove('open');
    });

    // Clock
    function updateClock() {
      const now = new Date();
      const time = now.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
      const date = now.toLocaleDateString([], { month: 'short', day: 'numeric' });
      document.getElementById('taskbarTime').textContent = `${time}  ${date}`;
    }
    updateClock();
    setInterval(updateClock, 1000);

    // Initialize
    renderDesktopIcons();

    // Open terminal on startup
    setTimeout(() => openApp('terminal'), 500);
  </script>
<script src="/apps/sloppy-header/sloppy-bar.js"></script>
<script src="/vibelib-extended.js"></script>
<script>
  // Compatibility Patch for Legacy Apps
  window.addEventListener("load", () => {
    if (window.SloppyKarma && window.VibeLib.Economy) {
      // Redirect old calls to new engine
      window.SloppyKarma.track = window.VibeLib.Economy.track;
    }
  });
</script>
</body>
</html>
