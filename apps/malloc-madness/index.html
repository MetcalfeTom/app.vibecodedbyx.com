<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
  <title>MALLOC MADNESS</title>
  <link rel="icon" href="https://emojicdn.elk.sh/ðŸ§ ">
  <meta property="og:title" content="MALLOC MADNESS">
  <meta property="og:description" content="Free memory blocks before the heap explodes!">
  <meta property="og:image" content="https://app.sloppy.live/malloc-madness/og-image.png">
  <meta property="og:url" content="https://app.sloppy.live/malloc-madness">
  <link href="https://fonts.googleapis.com/css2?family=Fira+Code:wght@400;700&display=swap" rel="stylesheet">
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }

    :root {
      --green: #0f0;
      --red: #f00;
      --cyan: #0ff;
      --yellow: #ff0;
      --magenta: #f0f;
      --bg: #0a0a0a;
    }

    body {
      background: var(--bg);
      min-height: 100vh;
      font-family: 'Fira Code', monospace;
      color: var(--green);
      display: flex;
      flex-direction: column;
      align-items: center;
      padding: 10px;
      overflow: hidden;
    }

    h1 {
      font-size: 1.8em;
      text-shadow: 0 0 10px var(--green), 0 0 20px var(--green);
      margin-bottom: 5px;
      letter-spacing: 3px;
    }

    .subtitle {
      font-size: 0.8em;
      color: #0a0;
      margin-bottom: 10px;
    }

    .stats {
      display: flex;
      gap: 20px;
      margin-bottom: 10px;
      flex-wrap: wrap;
      justify-content: center;
    }

    .stat {
      background: rgba(0,255,0,0.1);
      border: 1px solid var(--green);
      padding: 8px 15px;
      border-radius: 5px;
      font-size: 0.9em;
    }

    .stat span {
      color: var(--cyan);
    }

    .heap-container {
      position: relative;
      width: 100%;
      max-width: 800px;
      flex: 1;
      min-height: 400px;
      max-height: 600px;
    }

    #heap {
      width: 100%;
      height: 100%;
      border: 3px solid var(--green);
      border-radius: 10px;
      box-shadow: 0 0 20px rgba(0,255,0,0.3), inset 0 0 50px rgba(0,255,0,0.05);
      position: relative;
      overflow: hidden;
      background: linear-gradient(180deg, #0a0a0a 0%, #0f1a0f 100%);
    }

    .memory-bar {
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      height: 4px;
      background: #111;
    }

    .memory-fill {
      height: 100%;
      background: var(--green);
      transition: width 0.2s, background 0.3s;
      box-shadow: 0 0 10px currentColor;
    }

    .block {
      position: absolute;
      border-radius: 4px;
      cursor: pointer;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      font-size: 0.7em;
      transition: transform 0.1s, box-shadow 0.1s;
      user-select: none;
      overflow: hidden;
    }

    .block:hover {
      transform: scale(1.05);
      z-index: 100;
    }

    .block.allocated {
      background: linear-gradient(135deg, #1a3a1a, #0f2a0f);
      border: 2px solid var(--green);
      box-shadow: 0 0 10px rgba(0,255,0,0.5), inset 0 0 20px rgba(0,255,0,0.1);
    }

    .block.locked {
      background: linear-gradient(135deg, #3a1a1a, #2a0f0f);
      border: 2px solid var(--red);
      box-shadow: 0 0 10px rgba(255,0,0,0.5);
      cursor: not-allowed;
    }

    .block.locked::after {
      content: 'ðŸ”’';
      position: absolute;
      font-size: 1.2em;
    }

    .block.fragmented {
      background: linear-gradient(135deg, #3a3a1a, #2a2a0f);
      border: 2px solid var(--yellow);
      box-shadow: 0 0 10px rgba(255,255,0,0.5);
    }

    .block.critical {
      animation: critical 0.3s infinite;
    }

    @keyframes critical {
      0%, 100% { border-color: var(--red); box-shadow: 0 0 20px var(--red); }
      50% { border-color: var(--yellow); box-shadow: 0 0 30px var(--yellow); }
    }

    .block .size {
      font-size: 1.1em;
      font-weight: bold;
    }

    .block .addr {
      font-size: 0.8em;
      opacity: 0.7;
    }

    .block .timer {
      position: absolute;
      bottom: 2px;
      right: 2px;
      font-size: 0.7em;
      color: var(--cyan);
    }

    .particle {
      position: absolute;
      pointer-events: none;
      border-radius: 2px;
    }

    #overlay {
      position: fixed;
      top: 0; left: 0; right: 0; bottom: 0;
      background: rgba(0,0,0,0.9);
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      z-index: 1000;
    }

    #overlay.hidden { display: none; }

    #overlay h2 {
      font-size: 2.5em;
      margin-bottom: 20px;
      text-shadow: 0 0 20px currentColor;
    }

    #overlay.gameover h2 { color: var(--red); }
    #overlay.start h2 { color: var(--green); }

    #overlay p {
      font-size: 1em;
      margin: 5px 0;
      color: var(--cyan);
    }

    #overlay button {
      margin-top: 20px;
      padding: 15px 40px;
      font-family: inherit;
      font-size: 1.2em;
      background: transparent;
      border: 2px solid var(--green);
      color: var(--green);
      cursor: pointer;
      border-radius: 5px;
      transition: all 0.2s;
    }

    #overlay button:hover {
      background: var(--green);
      color: #000;
      box-shadow: 0 0 20px var(--green);
    }

    .instructions {
      margin-top: 20px;
      font-size: 0.8em;
      color: #0a0;
      text-align: center;
      max-width: 400px;
    }

    .instructions span { color: var(--green); }
    .instructions .red { color: var(--red); }
    .instructions .yellow { color: var(--yellow); }

    .terminal-log {
      position: fixed;
      bottom: 10px;
      left: 10px;
      font-size: 0.7em;
      color: #0a0;
      max-width: 300px;
      pointer-events: none;
    }

    .terminal-log div {
      opacity: 0;
      animation: logFade 3s forwards;
    }

    @keyframes logFade {
      0% { opacity: 1; }
      70% { opacity: 1; }
      100% { opacity: 0; }
    }

    .backlink {
      position: fixed;
      bottom: 10px;
      right: 10px;
      color: #333;
      text-decoration: none;
      font-size: 0.7em;
    }

    .shake {
      animation: shake 0.2s;
    }

    @keyframes shake {
      0%, 100% { transform: translateX(0); }
      25% { transform: translateX(-5px); }
      75% { transform: translateX(5px); }
    }

    .explosion {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      font-size: 10em;
      z-index: 999;
      animation: explode 1s forwards;
    }

    @keyframes explode {
      0% { transform: translate(-50%, -50%) scale(0); opacity: 1; }
      50% { transform: translate(-50%, -50%) scale(2); opacity: 1; }
      100% { transform: translate(-50%, -50%) scale(3); opacity: 0; }
    }
  </style>
</head>
<body>
  <h1>MALLOC MADNESS</h1>
  <p class="subtitle">// free() the blocks before heap overflow!</p>

  <div class="stats">
    <div class="stat">SCORE: <span id="score">0</span></div>
    <div class="stat">HEAP: <span id="heapUsage">0</span>/<span id="heapMax">1024</span> bytes</div>
    <div class="stat">FREED: <span id="freed">0</span></div>
    <div class="stat">LEVEL: <span id="level">1</span></div>
  </div>

  <div class="heap-container">
    <div id="heap">
      <div class="memory-bar">
        <div class="memory-fill" id="memoryFill"></div>
      </div>
    </div>
  </div>

  <div class="terminal-log" id="log"></div>

  <div id="overlay" class="start">
    <h2>MALLOC MADNESS</h2>
    <p>Memory blocks are being allocated!</p>
    <p>Click <span style="color:#0f0">GREEN</span> blocks to free() them</p>
    <p><span style="color:#f00">RED</span> blocks are locked - wait for unlock</p>
    <p><span style="color:#ff0">YELLOW</span> blocks are fragmented - worth more!</p>
    <button onclick="startGame()">malloc(game)</button>
    <div class="instructions">
      <p>Don't let the heap fill up or it will <span class="red">EXPLODE!</span></p>
      <p>Bigger blocks = more points</p>
      <p>Speed increases each level</p>
    </div>
  </div>

  <a href="https://sloppy.live" class="backlink">sloppy.live</a>

  <script>
    const heap = document.getElementById('heap');
    const memoryFill = document.getElementById('memoryFill');
    const scoreEl = document.getElementById('score');
    const heapUsageEl = document.getElementById('heapUsage');
    const heapMaxEl = document.getElementById('heapMax');
    const freedEl = document.getElementById('freed');
    const levelEl = document.getElementById('level');
    const overlay = document.getElementById('overlay');
    const logEl = document.getElementById('log');

    const HEAP_MAX = 1024;
    const BLOCK_SIZES = [16, 32, 64, 128, 256];

    let gameRunning = false;
    let score = 0;
    let heapUsage = 0;
    let freed = 0;
    let level = 1;
    let blocks = [];
    let allocInterval = null;
    let gameLoopId = null;

    function log(msg) {
      const div = document.createElement('div');
      div.textContent = '> ' + msg;
      logEl.appendChild(div);
      setTimeout(() => div.remove(), 3000);
      if (logEl.children.length > 5) {
        logEl.firstChild.remove();
      }
    }

    function getRandomPosition(width, height) {
      const heapRect = heap.getBoundingClientRect();
      const padding = 10;
      const maxX = heap.clientWidth - width - padding;
      const maxY = heap.clientHeight - height - padding - 10;

      // Try to find non-overlapping position
      for (let attempts = 0; attempts < 50; attempts++) {
        const x = padding + Math.random() * maxX;
        const y = padding + Math.random() * maxY;

        let overlaps = false;
        for (let block of blocks) {
          if (x < block.x + block.width + 5 &&
              x + width + 5 > block.x &&
              y < block.y + block.height + 5 &&
              y + height + 5 > block.y) {
            overlaps = true;
            break;
          }
        }

        if (!overlaps) return { x, y };
      }

      // Fallback to random position
      return {
        x: padding + Math.random() * maxX,
        y: padding + Math.random() * maxY
      };
    }

    function allocateBlock() {
      if (!gameRunning) return;

      const size = BLOCK_SIZES[Math.floor(Math.random() * BLOCK_SIZES.length)];

      if (heapUsage + size > HEAP_MAX) {
        gameOver();
        return;
      }

      const width = 40 + size / 4;
      const height = 40 + size / 8;
      const pos = getRandomPosition(width, height);

      const isLocked = Math.random() < 0.25;
      const isFragmented = !isLocked && Math.random() < 0.15;
      const lockTime = isLocked ? 2000 + Math.random() * 3000 : 0;

      const block = {
        id: Date.now() + Math.random(),
        size,
        x: pos.x,
        y: pos.y,
        width,
        height,
        locked: isLocked,
        fragmented: isFragmented,
        lockTime,
        created: Date.now(),
        element: null
      };

      const el = document.createElement('div');
      el.className = 'block ' + (isLocked ? 'locked' : isFragmented ? 'fragmented' : 'allocated');
      el.style.left = pos.x + 'px';
      el.style.top = pos.y + 'px';
      el.style.width = width + 'px';
      el.style.height = height + 'px';

      el.innerHTML = `
        <div class="size">${size}B</div>
        <div class="addr">0x${Math.floor(Math.random() * 65535).toString(16).padStart(4, '0')}</div>
        ${isLocked ? '' : '<div class="timer"></div>'}
      `;

      el.addEventListener('click', () => freeBlock(block));
      el.addEventListener('touchstart', e => {
        e.preventDefault();
        freeBlock(block);
      });

      heap.appendChild(el);
      block.element = el;
      blocks.push(block);

      heapUsage += size;
      updateUI();

      log(`malloc(${size}) -> allocated`);

      // Unlock after time
      if (isLocked) {
        setTimeout(() => {
          if (blocks.includes(block)) {
            block.locked = false;
            el.classList.remove('locked');
            el.classList.add('allocated');
            log(`Block ${size}B unlocked`);
          }
        }, lockTime);
      }
    }

    function freeBlock(block) {
      if (!gameRunning || block.locked) {
        if (block.locked) {
          block.element.classList.add('shake');
          setTimeout(() => block.element.classList.remove('shake'), 200);
          log('ERROR: Block is locked!');
        }
        return;
      }

      // Create particles
      createParticles(block);

      // Remove block
      const index = blocks.indexOf(block);
      if (index > -1) {
        blocks.splice(index, 1);
      }

      block.element.remove();
      heapUsage -= block.size;
      freed++;

      // Score based on size and type
      let points = block.size;
      if (block.fragmented) points *= 2;

      // Bonus for quick free
      const age = Date.now() - block.created;
      if (age < 1000) points *= 1.5;

      score += Math.floor(points);
      log(`free(${block.size}B) -> +${Math.floor(points)} pts`);

      updateUI();
      checkLevelUp();
    }

    function createParticles(block) {
      const colors = block.fragmented ? ['#ff0', '#fa0', '#f80'] : ['#0f0', '#0a0', '#0f8'];

      for (let i = 0; i < 10; i++) {
        const particle = document.createElement('div');
        particle.className = 'particle';
        particle.style.left = (block.x + block.width / 2) + 'px';
        particle.style.top = (block.y + block.height / 2) + 'px';
        particle.style.width = '4px';
        particle.style.height = '4px';
        particle.style.background = colors[Math.floor(Math.random() * colors.length)];
        particle.style.boxShadow = `0 0 5px ${particle.style.background}`;

        const angle = Math.random() * Math.PI * 2;
        const speed = 50 + Math.random() * 100;
        const vx = Math.cos(angle) * speed;
        const vy = Math.sin(angle) * speed;

        heap.appendChild(particle);

        let x = block.x + block.width / 2;
        let y = block.y + block.height / 2;
        let life = 1;

        function animateParticle() {
          x += vx * 0.016;
          y += vy * 0.016;
          life -= 0.02;

          particle.style.left = x + 'px';
          particle.style.top = y + 'px';
          particle.style.opacity = life;

          if (life > 0) {
            requestAnimationFrame(animateParticle);
          } else {
            particle.remove();
          }
        }
        requestAnimationFrame(animateParticle);
      }
    }

    function updateUI() {
      scoreEl.textContent = score;
      heapUsageEl.textContent = heapUsage;
      freedEl.textContent = freed;
      levelEl.textContent = level;

      const usage = heapUsage / HEAP_MAX;
      memoryFill.style.width = (usage * 100) + '%';

      if (usage > 0.9) {
        memoryFill.style.background = '#f00';
        blocks.forEach(b => {
          if (!b.locked) b.element.classList.add('critical');
        });
      } else if (usage > 0.7) {
        memoryFill.style.background = '#fa0';
        blocks.forEach(b => b.element.classList.remove('critical'));
      } else {
        memoryFill.style.background = '#0f0';
        blocks.forEach(b => b.element.classList.remove('critical'));
      }
    }

    function checkLevelUp() {
      const newLevel = Math.floor(freed / 10) + 1;
      if (newLevel > level) {
        level = newLevel;
        log(`LEVEL UP! -> Level ${level}`);

        // Increase allocation speed
        clearInterval(allocInterval);
        const interval = Math.max(500, 2000 - level * 150);
        allocInterval = setInterval(allocateBlock, interval);
      }
    }

    function gameOver() {
      gameRunning = false;
      clearInterval(allocInterval);

      // Explosion effect
      const explosion = document.createElement('div');
      explosion.className = 'explosion';
      explosion.textContent = 'ðŸ’¥';
      document.body.appendChild(explosion);
      setTimeout(() => explosion.remove(), 1000);

      log('SEGMENTATION FAULT (core dumped)');

      setTimeout(() => {
        overlay.className = 'gameover';
        overlay.innerHTML = `
          <h2>HEAP OVERFLOW!</h2>
          <p>Segmentation fault (core dumped)</p>
          <p>Final Score: <span style="color:#0ff">${score}</span></p>
          <p>Blocks Freed: <span style="color:#0ff">${freed}</span></p>
          <p>Level Reached: <span style="color:#0ff">${level}</span></p>
          <button onclick="startGame()">malloc(retry)</button>
        `;
      }, 500);
    }

    function startGame() {
      // Clear previous game
      blocks.forEach(b => b.element.remove());
      blocks = [];

      score = 0;
      heapUsage = 0;
      freed = 0;
      level = 1;

      updateUI();
      overlay.classList.add('hidden');
      gameRunning = true;

      log('Initializing heap...');
      log('malloc_madness v1.0 started');

      // Start allocating
      allocInterval = setInterval(allocateBlock, 2000);

      // Initial blocks
      setTimeout(allocateBlock, 500);
      setTimeout(allocateBlock, 1000);
      setTimeout(allocateBlock, 1500);
    }

    // Prevent context menu on long press
    document.addEventListener('contextmenu', e => e.preventDefault());
  </script>
<script src="/sloppy-header/sloppy-bar.js"></script>
<script src="/vibelib-extended.js"></script>
<script>
  // Compatibility Patch for Legacy Apps
  window.addEventListener("load", () => {
    if (window.SloppyKarma && window.VibeLib.Economy) {
      // Redirect old calls to new engine
      window.SloppyKarma.track = window.VibeLib.Economy.track;
    }
  });
</script>
</body>
</html>
