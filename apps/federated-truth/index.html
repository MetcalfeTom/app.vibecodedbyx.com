<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Federated Truth Node</title>
    <link rel="icon" href="https://emojicdn.elk.sh/üîÆ">
    <meta name="description" content="Distributed consensus verification following Protocol V">
    <meta property="og:title" content="Federated Truth Node">
    <meta property="og:description" content="Query peer nodes to validate facts through distributed consensus">
    <meta property="og:url" content="https://sloppy.live/federated-truth">
    <link href="https://fonts.googleapis.com/css2?family=IBM+Plex+Mono:wght@300;400;500;700&display=swap" rel="stylesheet">
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }

        :root {
            --void: #050508;
            --surface: #0a0a10;
            --verified: #00ff88;
            --pending: #fbbf24;
            --rejected: #ef4444;
            --idle: #3b82f6;
            --text: #e0e0e0;
            --muted: #555;
        }

        body {
            font-family: 'IBM Plex Mono', monospace;
            background: var(--void);
            color: var(--text);
            min-height: 100vh;
            overflow: hidden;
        }

        #canvas {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 0;
        }

        header {
            position: fixed;
            top: 0;
            left: 0;
            right: 320px;
            padding: 20px;
            z-index: 10;
            display: flex;
            align-items: center;
            gap: 15px;
        }

        .logo-box {
            background: rgba(10, 10, 16, 0.8);
            border: 1px solid rgba(255,255,255,0.1);
            padding: 10px;
            border-radius: 8px;
        }

        .logo-box svg { display: block; }

        .header-text h1 {
            font-size: 1.1rem;
            font-weight: 700;
            letter-spacing: 0.15em;
            background: linear-gradient(135deg, var(--verified), #00cc6a);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }

        .header-meta {
            font-size: 0.6rem;
            color: var(--muted);
            display: flex;
            align-items: center;
            gap: 8px;
            margin-top: 4px;
        }

        .pulse-dot {
            width: 6px;
            height: 6px;
            background: var(--verified);
            border-radius: 50%;
            animation: pulse 2s infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.4; }
        }

        /* Consensus Log Sidebar */
        .sidebar {
            position: fixed;
            top: 0;
            right: 0;
            width: 320px;
            height: 100%;
            background: rgba(5, 5, 10, 0.9);
            backdrop-filter: blur(10px);
            border-left: 1px solid rgba(255,255,255,0.05);
            z-index: 20;
            display: flex;
            flex-direction: column;
        }

        .sidebar-header {
            padding: 20px;
            border-bottom: 1px solid rgba(255,255,255,0.05);
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 0.75rem;
            font-weight: 700;
            letter-spacing: 0.1em;
        }

        .log-list {
            flex: 1;
            overflow-y: auto;
            padding: 15px;
        }

        .log-empty {
            text-align: center;
            padding: 40px 20px;
            opacity: 0.3;
            font-size: 0.7rem;
        }

        .log-item {
            background: rgba(10, 10, 20, 0.5);
            border: 1px solid rgba(255,255,255,0.05);
            border-radius: 8px;
            padding: 12px;
            margin-bottom: 10px;
            transition: border-color 0.2s;
        }

        .log-item:hover {
            border-color: rgba(255,255,255,0.1);
        }

        .log-item-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 8px;
        }

        .log-status {
            font-size: 0.6rem;
            font-weight: 700;
            padding: 2px 6px;
            border-radius: 3px;
        }

        .log-status.verified {
            background: rgba(0, 255, 136, 0.1);
            color: var(--verified);
        }

        .log-status.rejected {
            background: rgba(248, 81, 73, 0.1);
            color: var(--rejected);
        }

        .log-time {
            font-size: 0.6rem;
            color: var(--muted);
        }

        .log-text {
            font-size: 0.75rem;
            color: #aaa;
            margin-bottom: 8px;
            line-height: 1.4;
        }

        .log-confidence {
            display: flex;
            justify-content: space-between;
            font-size: 0.6rem;
            color: var(--muted);
        }

        /* Status Overlay */
        .status-overlay {
            position: fixed;
            top: 100px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(10, 10, 20, 0.95);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255,255,255,0.1);
            border-radius: 12px;
            padding: 25px 35px;
            z-index: 15;
            max-width: 500px;
            text-align: center;
            display: none;
        }

        .status-overlay.active {
            display: block;
            animation: slideIn 0.3s;
        }

        @keyframes slideIn {
            from { opacity: 0; transform: translateX(-50%) translateY(-10px); }
            to { opacity: 1; transform: translateX(-50%) translateY(0); }
        }

        .status-label {
            font-size: 0.65rem;
            font-weight: 700;
            color: var(--muted);
            letter-spacing: 0.15em;
            margin-bottom: 10px;
        }

        .status-claim {
            font-size: 1.1rem;
            font-weight: 300;
            color: #fff;
            margin-bottom: 15px;
        }

        .progress-bar {
            height: 4px;
            background: var(--surface);
            border-radius: 2px;
            overflow: hidden;
        }

        .progress-fill {
            height: 100%;
            background: var(--verified);
            width: 0%;
            transition: width 0.3s;
        }

        /* Input Area */
        .input-area {
            position: fixed;
            bottom: 30px;
            left: 30px;
            right: 350px;
            z-index: 10;
            display: flex;
            gap: 10px;
            max-width: 600px;
        }

        .claim-input {
            flex: 1;
            background: rgba(10, 10, 20, 0.8);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255,255,255,0.1);
            border-radius: 8px;
            padding: 14px 18px;
            color: var(--text);
            font-family: inherit;
            font-size: 0.85rem;
        }

        .claim-input:focus {
            outline: none;
            border-color: var(--verified);
        }

        .claim-input::placeholder {
            color: var(--muted);
        }

        .claim-btn {
            background: var(--verified);
            border: none;
            border-radius: 8px;
            padding: 14px 24px;
            color: var(--void);
            font-family: inherit;
            font-size: 0.8rem;
            font-weight: 700;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 8px;
            transition: background 0.2s;
        }

        .claim-btn:hover {
            background: #00cc6a;
        }

        .claim-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        /* Node Tooltip */
        .tooltip {
            position: fixed;
            background: var(--surface);
            border: 1px solid rgba(0, 255, 136, 0.3);
            border-radius: 6px;
            padding: 8px 12px;
            font-size: 0.65rem;
            z-index: 30;
            pointer-events: none;
            display: none;
        }

        .tooltip.visible {
            display: block;
        }

        .tooltip-id {
            font-weight: 700;
            color: var(--verified);
        }

        .tooltip-status {
            color: var(--muted);
        }

        .tooltip-vote {
            margin-top: 4px;
        }

        .tooltip-vote.true { color: var(--verified); }
        .tooltip-vote.false { color: var(--rejected); }

        .back-link {
            position: fixed;
            bottom: 15px;
            right: 340px;
            font-size: 0.65rem;
            color: var(--muted);
            text-decoration: none;
            z-index: 100;
        }

        .back-link:hover {
            color: var(--verified);
        }

        @media (max-width: 800px) {
            .sidebar { display: none; }
            header { right: 20px; }
            .input-area { right: 30px; }
            .back-link { right: 20px; bottom: 80px; }
        }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>

    <header>
        <div class="logo-box">
            <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="#00ff88" stroke-width="2">
                <rect x="4" y="4" width="16" height="16" rx="2"/>
                <rect x="9" y="9" width="6" height="6"/>
                <line x1="9" y1="1" x2="9" y2="4"/><line x1="15" y1="1" x2="15" y2="4"/>
                <line x1="9" y1="20" x2="9" y2="23"/><line x1="15" y1="20" x2="15" y2="23"/>
                <line x1="20" y1="9" x2="23" y2="9"/><line x1="20" y1="14" x2="23" y2="14"/>
                <line x1="1" y1="9" x2="4" y2="9"/><line x1="1" y1="14" x2="4" y2="14"/>
            </svg>
        </div>
        <div class="header-text">
            <h1>FEDERATED TRUTH NODE</h1>
            <div class="header-meta">
                <span class="pulse-dot"></span>
                Protocol V Active ‚Ä¢ Nodes: <span id="nodeCountDisplay">7</span>
            </div>
        </div>
    </header>

    <div class="sidebar">
        <div class="sidebar-header">
            <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <circle cx="12" cy="12" r="10"/><polyline points="12 6 12 12 16 14"/>
            </svg>
            CONSENSUS LOG
        </div>
        <div class="log-list" id="logList">
            <div class="log-empty" id="logEmpty">
                <svg width="40" height="40" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1" style="margin: 0 auto 15px;">
                    <polyline points="4 17 10 11 4 5"/><line x1="12" y1="19" x2="20" y2="19"/>
                </svg>
                NO RECORDS FOUND
            </div>
        </div>
    </div>

    <div class="status-overlay" id="statusOverlay">
        <div class="status-label" id="statusLabel">Broadcasting...</div>
        <div class="status-claim" id="statusClaim"></div>
        <div class="progress-bar">
            <div class="progress-fill" id="progressFill"></div>
        </div>
    </div>

    <div class="input-area">
        <input type="text" class="claim-input" id="claimInput" placeholder="Enter claim for distributed verification..." maxlength="200">
        <button class="claim-btn" id="claimBtn">
            VERIFY
            <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <path d="M12 22s8-4 8-10V5l-8-3-8 3v7c0 6 8 10 8 10z"/><polyline points="9 12 11 14 15 10"/>
            </svg>
        </button>
    </div>

    <div class="tooltip" id="tooltip">
        <div class="tooltip-id" id="tooltipId">NODE_00</div>
        <div class="tooltip-status" id="tooltipStatus">STATUS: IDLE</div>
        <div class="tooltip-vote" id="tooltipVote"></div>
    </div>

    <a href="https://sloppy.live" class="back-link">‚Üê sloppy.live</a>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');

        // Theme colors
        const THEME = {
            void: '#050508',
            verified: '#00ff88',
            pending: '#fbbf24',
            rejected: '#ef4444',
            idle: '#3b82f6'
        };

        // State
        const NODE_COUNT = 7;
        let nodes = [];
        let messages = [];
        let claims = [];
        let currentClaim = null;
        let systemStatus = 'IDLE';
        let hoveredNode = null;

        // DOM elements
        const claimInput = document.getElementById('claimInput');
        const claimBtn = document.getElementById('claimBtn');
        const statusOverlay = document.getElementById('statusOverlay');
        const statusLabel = document.getElementById('statusLabel');
        const statusClaim = document.getElementById('statusClaim');
        const progressFill = document.getElementById('progressFill');
        const logList = document.getElementById('logList');
        const logEmpty = document.getElementById('logEmpty');
        const tooltip = document.getElementById('tooltip');
        const tooltipId = document.getElementById('tooltipId');
        const tooltipStatus = document.getElementById('tooltipStatus');
        const tooltipVote = document.getElementById('tooltipVote');

        // Resize canvas
        function resize() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            initNodes();
        }

        // Initialize nodes with physics properties
        function initNodes() {
            nodes = [];
            const centerX = canvas.width / 2;
            const centerY = canvas.height / 2;
            const baseRadius = Math.min(centerX, centerY) * 0.45;

            for (let i = 0; i < NODE_COUNT; i++) {
                const angle = (i / NODE_COUNT) * Math.PI * 2 - Math.PI / 2;
                const bx = centerX + Math.cos(angle) * baseRadius;
                const by = centerY + Math.sin(angle) * baseRadius;
                nodes.push({
                    id: i,
                    bx, by,           // Base position (anchor)
                    x: bx, y: by,     // Current position
                    vx: (Math.random() - 0.5) * 0.3,  // Velocity
                    vy: (Math.random() - 0.5) * 0.3,
                    radius: 18 + Math.random() * 8,
                    state: 'idle',
                    vote: null,
                    pulseOffset: Math.random() * Math.PI * 2
                });
            }
        }

        // Animation loop
        function animate() {
            ctx.fillStyle = THEME.void;
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Draw connections
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.04)';
            ctx.lineWidth = 1;
            ctx.beginPath();
            for (let i = 0; i < nodes.length; i++) {
                for (let j = i + 1; j < nodes.length; j++) {
                    const dist = Math.hypot(nodes[i].x - nodes[j].x, nodes[i].y - nodes[j].y);
                    if (dist < 400) {
                        ctx.moveTo(nodes[i].x, nodes[i].y);
                        ctx.lineTo(nodes[j].x, nodes[j].y);
                    }
                }
            }
            ctx.stroke();

            // Update and draw nodes with physics
            nodes.forEach(node => {
                // Physics: drift and tether
                node.x += node.vx;
                node.y += node.vy;

                // Tether force (pull back to base)
                const dx = node.bx - node.x;
                const dy = node.by - node.y;
                node.vx += dx * 0.0008;
                node.vy += dy * 0.0008;

                // Damping
                node.vx *= 0.985;
                node.vy *= 0.985;

                // Draw node
                const pulse = Math.sin(Date.now() / 500 + node.pulseOffset) * 0.2 + 0.8;
                const color = THEME[node.state] || THEME.idle;

                // Glow
                const gradient = ctx.createRadialGradient(node.x, node.y, 0, node.x, node.y, node.radius * 3);
                gradient.addColorStop(0, color + '30');
                gradient.addColorStop(1, 'transparent');
                ctx.fillStyle = gradient;
                ctx.beginPath();
                ctx.arc(node.x, node.y, node.radius * 3 * pulse, 0, Math.PI * 2);
                ctx.fill();

                // Core (dark center)
                ctx.fillStyle = THEME.void;
                ctx.beginPath();
                ctx.arc(node.x, node.y, node.radius, 0, Math.PI * 2);
                ctx.fill();

                // Ring
                ctx.strokeStyle = color;
                ctx.lineWidth = 2;
                ctx.stroke();

                // Inner dot
                ctx.fillStyle = color;
                ctx.beginPath();
                ctx.arc(node.x, node.y, node.radius * 0.35, 0, Math.PI * 2);
                ctx.fill();

                // Label
                ctx.fillStyle = '#fff';
                ctx.font = '10px IBM Plex Mono';
                ctx.textAlign = 'center';
                ctx.fillText(`N${node.id}`, node.x, node.y + node.radius + 14);
            });

            // Draw messages with trails
            messages = messages.filter(msg => {
                msg.progress += 0.025;
                if (msg.progress >= 1) {
                    const target = nodes[msg.to];
                    if (target && msg.type === 'broadcast') {
                        target.state = 'pending';
                    }
                    return false;
                }

                const from = nodes[msg.from];
                const to = nodes[msg.to];

                // Easing
                const t = msg.progress;
                const ease = t < 0.5 ? 2 * t * t : -1 + (4 - 2 * t) * t;

                const x = from.x + (to.x - from.x) * ease;
                const y = from.y + (to.y - from.y) * ease;

                // Trail
                const trailEase = Math.max(0, ease - 0.08);
                const tailX = from.x + (to.x - from.x) * trailEase;
                const tailY = from.y + (to.y - from.y) * trailEase;

                ctx.strokeStyle = msg.type === 'broadcast' ? THEME.pending : THEME.verified;
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(tailX, tailY);
                ctx.lineTo(x, y);
                ctx.stroke();

                // Head
                ctx.fillStyle = '#fff';
                ctx.beginPath();
                ctx.arc(x, y, 3, 0, Math.PI * 2);
                ctx.fill();

                return true;
            });

            requestAnimationFrame(animate);
        }

        // Submit claim
        function submitClaim() {
            const text = claimInput.value.trim();
            if (!text || systemStatus !== 'IDLE') return;

            claimInput.value = '';
            claimBtn.disabled = true;
            currentClaim = { text, votes: 0 };
            systemStatus = 'BROADCASTING';

            // Reset nodes
            nodes.forEach(n => { n.state = 'idle'; n.vote = null; });

            // Show overlay
            statusLabel.textContent = 'ENCRYPTING & BROADCASTING...';
            statusClaim.textContent = `"${text}"`;
            progressFill.style.width = '0%';
            statusOverlay.classList.add('active');

            // Broadcast messages
            nodes.forEach((node, i) => {
                setTimeout(() => {
                    const fromIdx = (i + Math.floor(NODE_COUNT / 2)) % NODE_COUNT;
                    messages.push({ from: fromIdx, to: i, progress: 0, type: 'broadcast' });
                }, i * 120);
            });

            // Start verification
            setTimeout(() => {
                systemStatus = 'VERIFYING';
                statusLabel.textContent = 'CONSENSUS IN PROGRESS...';
                verifyNodes(text);
            }, 1500);
        }

        function verifyNodes(text) {
            let completed = 0;
            let yesVotes = 0;

            nodes.forEach((node, i) => {
                setTimeout(() => {
                    // Deterministic "random" vote
                    const hash = text.split('').reduce((a, c) => a + c.charCodeAt(0), 0);
                    const isYes = ((hash + node.id * 17) % 100) > 30;

                    node.vote = isYes;
                    node.state = isYes ? 'verified' : 'rejected';
                    if (isYes) yesVotes++;
                    completed++;

                    // Update progress
                    const pct = (completed / NODE_COUNT) * 100;
                    progressFill.style.width = pct + '%';

                    if (completed === NODE_COUNT) {
                        systemStatus = 'CONSENSUS';
                        statusLabel.textContent = 'FINALIZING BLOCK...';
                        setTimeout(() => finalizeConsensus(text, yesVotes), 800);
                    }
                }, 800 + Math.random() * 1500);
            });
        }

        function finalizeConsensus(text, yesVotes) {
            const isVerified = yesVotes >= Math.ceil(NODE_COUNT / 2);
            const consensus = Math.round((yesVotes / NODE_COUNT) * 100);

            const result = {
                id: Date.now(),
                text,
                status: isVerified ? 'VERIFIED' : 'REJECTED',
                consensus,
                time: new Date().toLocaleTimeString()
            };

            claims.unshift(result);
            renderLog();

            setTimeout(() => {
                statusOverlay.classList.remove('active');
                systemStatus = 'IDLE';
                claimBtn.disabled = false;
                currentClaim = null;

                // Reset nodes after delay
                setTimeout(() => {
                    nodes.forEach(n => n.state = 'idle');
                }, 2000);
            }, 1000);
        }

        function renderLog() {
            if (claims.length === 0) {
                logEmpty.style.display = 'block';
                return;
            }
            logEmpty.style.display = 'none';

            const html = claims.map(c => `
                <div class="log-item">
                    <div class="log-item-header">
                        <span class="log-status ${c.status.toLowerCase()}">${c.status}</span>
                        <span class="log-time">${c.time}</span>
                    </div>
                    <div class="log-text">"${c.text}"</div>
                    <div class="log-confidence">
                        <span>Confidence</span>
                        <span style="color: ${c.status === 'VERIFIED' ? THEME.verified : THEME.rejected}">${c.consensus}%</span>
                    </div>
                </div>
            `).join('');

            logList.innerHTML = html;
        }

        // Mouse tracking for tooltip
        canvas.addEventListener('mousemove', (e) => {
            const rect = canvas.getBoundingClientRect();
            const mx = e.clientX - rect.left;
            const my = e.clientY - rect.top;

            hoveredNode = nodes.find(n => Math.hypot(n.x - mx, n.y - my) < n.radius + 10);

            if (hoveredNode) {
                tooltip.classList.add('visible');
                tooltip.style.left = (e.clientX + 15) + 'px';
                tooltip.style.top = (e.clientY - 10) + 'px';
                tooltipId.textContent = `NODE_0${hoveredNode.id}`;
                tooltipStatus.textContent = `STATUS: ${hoveredNode.state.toUpperCase()}`;
                if (hoveredNode.vote !== null) {
                    tooltipVote.textContent = `VOTE: ${hoveredNode.vote ? 'TRUE' : 'FALSE'}`;
                    tooltipVote.className = 'tooltip-vote ' + (hoveredNode.vote ? 'true' : 'false');
                } else {
                    tooltipVote.textContent = '';
                }
            } else {
                tooltip.classList.remove('visible');
            }
        });

        canvas.addEventListener('mouseleave', () => {
            tooltip.classList.remove('visible');
        });

        // Event listeners
        claimBtn.addEventListener('click', submitClaim);
        claimInput.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') submitClaim();
        });
        window.addEventListener('resize', resize);

        // Init
        resize();
        animate();
    </script>
<script src="/sloppy-header/sloppy-bar.js"></script>
</body>
</html>
