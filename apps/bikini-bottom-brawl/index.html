<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Bikini Bottom Brawl â€” Three.js Demo</title>
    <meta
      name="description"
      content="Dash around Bikini Bottom in a SpongeBob-inspired Three.js mini game. Collect jellyfish, dodge robots, and race the timer with handmade textures."
    />
    <meta property="og:title" content="Bikini Bottom Brawl" />
    <meta
      property="og:description"
      content="Arcade-sized SpongeBob Battle for Bikini Bottom vibes â€” custom Three.js playground with jellyfish pickups and robot foes."
    />
    <meta property="og:type" content="website" />
    <meta property="og:url" content="https://app.vibecodedbyx.com/bikini-bottom-brawl/" />
    <meta property="og:image" content="https://app.vibecodedbyx.com/bikini-bottom-brawl/og-image.svg" />
    <meta name="twitter:card" content="summary_large_image" />
    <meta name="twitter:title" content="Bikini Bottom Brawl" />
    <meta name="twitter:description" content="Three.js SpongeBob mini demo with custom textures and no sound." />
    <meta name="twitter:image" content="https://app.vibecodedbyx.com/bikini-bottom-brawl/og-image.svg" />
    <link rel="icon" href="./favicon.svg" type="image/svg+xml" />
    <meta name="theme-color" content="#3bd6ff" />
    <style>
      :root {
        color-scheme: light;
        font-family: "Inter", "Segoe UI", sans-serif;
        --hud-bg: rgba(255, 255, 255, 0.82);
        --hud-border: rgba(10, 20, 46, 0.16);
        --accent: #ffed63;
        --text: #0a1436;
      }

      *, *::before, *::after {
        box-sizing: border-box;
      }

      body {
        margin: 0;
        background: radial-gradient(circle at 20% -10%, rgba(255, 237, 99, 0.55), transparent 65%), #3bd6ff;
        color: var(--text);
        overflow: hidden;
      }

      canvas {
        display: block;
      }

      .hud {
        position: fixed;
        top: 16px;
        left: 16px;
        display: grid;
        gap: 14px;
        padding: 18px;
        max-width: min(360px, 88vw);
        background: var(--hud-bg);
        border: 1px solid var(--hud-border);
        border-radius: 18px;
        box-shadow: 0 16px 34px rgba(10, 20, 46, 0.18);
        backdrop-filter: blur(12px);
      }

      .hud h1 {
        margin: 0;
        font-size: 1.4rem;
        letter-spacing: 0.08em;
        text-transform: uppercase;
      }

      .hud p {
        margin: 0;
        font-size: 0.92rem;
        line-height: 1.5;
      }

      .stats {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(110px, 1fr));
        gap: 8px;
      }

      .stat {
        background: rgba(255, 255, 255, 0.86);
        border-radius: 12px;
        border: 1px solid rgba(10, 20, 46, 0.08);
        padding: 8px 10px;
        text-align: center;
      }

      .stat .label {
        display: block;
        font-size: 0.68rem;
        letter-spacing: 0.16em;
        text-transform: uppercase;
        color: rgba(10, 20, 46, 0.55);
      }

      .stat .value {
        font-size: 1.08rem;
        font-weight: 600;
      }

      .hud a {
        color: var(--accent);
        font-weight: 600;
        text-decoration: none;
      }

      .hud a:hover,
      .hud a:focus-visible {
        text-decoration: underline;
      }

      .mobile-hint {
        display: none;
        font-size: 0.85rem;
        color: rgba(10, 20, 46, 0.7);
      }

      @media (max-width: 720px), (hover: none) {
        .hud {
          max-width: 92vw;
          padding: 16px;
        }
        .mobile-hint {
          display: block;
        }
      }

      .touch-stick,
      .touch-buttons {
        position: fixed;
        bottom: 20px;
        pointer-events: none;
        display: none;
      }

      .touch-stick {
        left: 20px;
        width: 120px;
        height: 120px;
        border-radius: 50%;
        background: rgba(255, 255, 255, 0.5);
        border: 1px solid rgba(10, 20, 46, 0.16);
        touch-action: none;
        pointer-events: auto;
      }

      .touch-stick::after {
        content: "";
        position: absolute;
        width: 60px;
        height: 60px;
        border-radius: 50%;
        background: rgba(255, 255, 255, 0.95);
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
      }

      .touch-buttons {
        right: 20px;
        display: flex;
        gap: 12px;
      }

      .touch-buttons button {
        width: 56px;
        height: 56px;
        border-radius: 16px;
        border: 1px solid rgba(10, 20, 46, 0.16);
        background: rgba(255, 255, 255, 0.85);
        color: var(--text);
        font-weight: 700;
        font-size: 1.4rem;
        pointer-events: auto;
      }

      @media (hover: none) {
        .touch-stick,
        .touch-buttons {
          display: block;
        }
      }
    </style>
  </head>
  <body>
    <div class="hud">
      <h1>Bikini Bottom Brawl</h1>
      <p>
        WASD or arrows to swim-run SpongeBob. Space dashes forward. Collect jellyfish, whack evil robots, and keep the timer
        alive across blocky Bikini Bottom.
      </p>
      <div class="stats">
        <div class="stat"><span class="label">Time</span><span class="value" id="timer">90.0</span></div>
        <div class="stat"><span class="label">Jellyfish</span><span class="value" id="jellyfish">0</span></div>
        <div class="stat"><span class="label">Robots</span><span class="value" id="robots">0</span></div>
      </div>
      <p id="message">Gary needs snacks! Reel in jellyfish around Jellyfish Fields and smash robots near the Krusty Krab.</p>
      <p class="mobile-hint">Drag the left circle to move. Tap âš¡ for dash and ðŸ§½ to spin attack.</p>
      <a href="https://www.vibecodedbyx.com" target="_blank" rel="noreferrer noopener">â¬… Back to the livestream</a>
    </div>

    <div class="touch-stick" id="touchStick"></div>
    <div class="touch-buttons" id="touchButtons">
      <button id="dashBtn" aria-label="Dash">âš¡</button>
      <button id="spinBtn" aria-label="Spin attack">ðŸ§½</button>
      <button id="resetBtn" aria-label="Reset">â†º</button>
    </div>

    <script type="importmap">
      {
        "imports": {
          "three": "https://cdn.jsdelivr.net/npm/three@0.167.0/build/three.module.js",
          "three/examples/": "https://cdn.jsdelivr.net/npm/three@0.167.0/examples/"
        }
      }
    </script>

    <script type="module">
      import * as THREE from "three";
      import { PointerLockControls } from "three/examples/jsm/controls/PointerLockControls.js";

      const scene = new THREE.Scene();
      scene.background = new THREE.Color(0x3bd6ff);
      scene.fog = new THREE.Fog(0x3bd6ff, 60, 220);

      const renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
      renderer.shadowMap.enabled = true;
      document.body.appendChild(renderer.domElement);

      const camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.1, 400);
      camera.position.set(0, 9, 18);

      const controls = new PointerLockControls(camera, renderer.domElement);
      controls.getObject().position.set(0, 6, 18);
      scene.add(controls.getObject());

      renderer.domElement.addEventListener("click", () => {
        if (!matchMedia("(hover: none)").matches && !controls.isLocked) controls.lock();
      });

      controls.addEventListener("lock", () => {
        messageEl.textContent = "You're in control! Dash with Space, spin with F.";
      });

      controls.addEventListener("unlock", () => {
        messageEl.textContent = "Click the world to move SpongeBob.";
      });

      const ambient = new THREE.HemisphereLight(0xfff7b5, 0x0a2747, 0.8);
      scene.add(ambient);

      const sun = new THREE.DirectionalLight(0xffffff, 1.0);
      sun.position.set(-60, 110, 80);
      sun.castShadow = true;
      sun.shadow.mapSize.set(2048, 2048);
      sun.shadow.camera.left = -140;
      sun.shadow.camera.right = 140;
      sun.shadow.camera.top = 140;
      sun.shadow.camera.bottom = -140;
      scene.add(sun);

      const textures = buildTextures();

      const world = new THREE.Group();
      scene.add(world);

      const seabed = new THREE.Mesh(new THREE.PlaneGeometry(400, 400), textures.sand);
      seabed.rotation.x = -Math.PI / 2;
      seabed.receiveShadow = true;
      world.add(seabed);

      const bubbleDome = new THREE.Mesh(new THREE.SphereGeometry(220, 32, 32), textures.dome);
      bubbleDome.scale.set(1, 0.6, 1);
      bubbleDome.position.y = 60;
      bubbleDome.material.side = THREE.BackSide;
      world.add(bubbleDome);

      const landmarks = buildLandmarks();
      world.add(landmarks);

      const jellyfishGroup = new THREE.Group();
      world.add(jellyfishGroup);
      spawnJellyfish();

      const robotGroup = new THREE.Group();
      world.add(robotGroup);
      spawnRobots();

      const particles = new THREE.Group();
      world.add(particles);

      const sponge = buildSponge();
      world.add(sponge.mesh);

      const clock = new THREE.Clock();
      const keyState = {};
      document.addEventListener("keydown", (e) => (keyState[e.code] = true));
      document.addEventListener("keyup", (e) => (keyState[e.code] = false));

      const stats = {
        jellyfish: 0,
        robots: 0,
        time: 90,
        playing: true,
      };

      const timerEl = document.getElementById("timer");
      const jellyfishEl = document.getElementById("jellyfish");
      const robotsEl = document.getElementById("robots");
      const messageEl = document.getElementById("message");

      setupTouchControls();

      function buildTextures() {
        const tex = {};
        tex.sand = makeMaterial((ctx) => {
          const { canvas } = ctx;
          ctx.fillStyle = "#f7d58b";
          ctx.fillRect(0, 0, canvas.width, canvas.height);
          ctx.fillStyle = "#f1c97a";
          for (let i = 0; i < 200; i++) {
            const size = Math.random() * 10 + 4;
            ctx.globalAlpha = 0.4;
            ctx.fillRect(Math.random() * canvas.width, Math.random() * canvas.height, size, size);
          }
          ctx.globalAlpha = 1;
        }, 256, 256, { roughness: 0.95 });

        tex.dome = new THREE.MeshBasicMaterial({ color: 0x3bd6ff, transparent: true, opacity: 0.35 });

        tex.sponge = makeMaterial((ctx) => {
          const { canvas } = ctx;
          ctx.fillStyle = "#ffe066";
          ctx.fillRect(0, 0, canvas.width, canvas.height);
          ctx.fillStyle = "#f7c948";
          for (let i = 0; i < 60; i++) {
            ctx.beginPath();
            const r = Math.random() * 12 + 6;
            ctx.globalAlpha = 0.45;
            ctx.arc(Math.random() * canvas.width, Math.random() * canvas.height, r, 0, Math.PI * 2);
            ctx.fill();
          }
          ctx.globalAlpha = 1;
        }, 128, 128, { roughness: 0.4, metalness: 0.05 });

        tex.shortPants = new THREE.MeshStandardMaterial({ color: 0x8b4513, roughness: 0.6 });
        tex.tie = new THREE.MeshStandardMaterial({ color: 0xff3d3d, roughness: 0.4 });

        tex.pineapple = makeMaterial((ctx) => {
          const { canvas } = ctx;
          ctx.fillStyle = "#ffa94d";
          ctx.fillRect(0, 0, canvas.width, canvas.height);
          ctx.strokeStyle = "#f0802c";
          ctx.lineWidth = 6;
          for (let i = -40; i < canvas.width + 40; i += 32) {
            ctx.beginPath();
            ctx.moveTo(i, -20);
            ctx.lineTo(i + canvas.height, canvas.height + 20);
            ctx.stroke();
            ctx.beginPath();
            ctx.moveTo(i + canvas.height, -20);
            ctx.lineTo(i, canvas.height + 20);
            ctx.stroke();
          }
        }, 256, 256, { roughness: 0.7 });

        tex.jellyfish = makeMaterial((ctx) => {
          const { canvas } = ctx;
          ctx.fillStyle = "#ff8ad4";
          ctx.beginPath();
          ctx.arc(canvas.width / 2, canvas.height / 2, canvas.width / 2 - 8, 0, Math.PI * 2);
          ctx.fill();
          ctx.fillStyle = "#ffd6f2";
          for (let i = 0; i < 30; i++) {
            ctx.fillRect(Math.random() * canvas.width, Math.random() * canvas.height, 6, 12);
          }
        }, 128, 128, { transparent: true, opacity: 0.9, roughness: 0.3 });

        tex.robot = makeMaterial((ctx) => {
          const { canvas } = ctx;
          ctx.fillStyle = "#d1d1d1";
          ctx.fillRect(0, 0, canvas.width, canvas.height);
          ctx.fillStyle = "#ff5555";
          ctx.fillRect(canvas.width / 4, canvas.height / 4, canvas.width / 2, canvas.height / 4);
        }, 128, 128, { roughness: 0.5, metalness: 0.4 });

        return tex;
      }

      function makeMaterial(drawFn, width, height, extra = {}) {
        const canvas = document.createElement("canvas");
        canvas.width = width;
        canvas.height = height;
        const ctx = canvas.getContext("2d");
        drawFn(ctx);
        const tex = new THREE.CanvasTexture(canvas);
        tex.wrapS = tex.wrapT = THREE.RepeatWrapping;
        tex.colorSpace = THREE.SRGBColorSpace;
        return new THREE.MeshStandardMaterial({ map: tex, ...extra });
      }

      function buildLandmarks() {
        const group = new THREE.Group();

        const pineapple = new THREE.Mesh(new THREE.CapsuleGeometry(5, 10, 12, 24), textures.pineapple);
        pineapple.position.set(20, 10, -30);
        pineapple.castShadow = true;
        group.add(pineapple);

        const krusty = new THREE.Mesh(new THREE.BoxGeometry(18, 8, 12), textures.robot.map ? textures.robot.clone() : textures.robot);
        krusty.material = textures.robot.clone();
        krusty.material.color = new THREE.Color(0xffad3b);
        krusty.position.set(-26, 4, 18);
        krusty.castShadow = true;
        group.add(krusty);

        const chumBucket = new THREE.Mesh(new THREE.CylinderGeometry(6, 8, 12, 24), new THREE.MeshStandardMaterial({ color: 0x364d79, roughness: 0.6 }));
        chumBucket.position.set(-40, 6, -40);
        chumBucket.castShadow = true;
        group.add(chumBucket);

        const jellyField = new THREE.Mesh(new THREE.CircleGeometry(28, 32), new THREE.MeshStandardMaterial({ color: 0xc0f8ff, transparent: true, opacity: 0.3 }));
        jellyField.rotation.x = -Math.PI / 2;
        jellyField.position.set(35, 0.05, 35);
        group.add(jellyField);

        return group;
      }

      function buildSponge() {
        const group = new THREE.Group();
        const body = new THREE.Mesh(new THREE.BoxGeometry(2.4, 3.2, 1.4), textures.sponge);
        body.position.y = 2.2;
        body.castShadow = true;
        group.add(body);

        const pants = new THREE.Mesh(new THREE.BoxGeometry(2.4, 1.2, 1.4), textures.shortPants);
        pants.position.y = 1.1;
        pants.castShadow = true;
        group.add(pants);

        const tie = new THREE.Mesh(new THREE.BoxGeometry(0.6, 1.2, 0.3), textures.tie);
        tie.position.set(0, 2, 0.71);
        group.add(tie);

        const spongeState = {
          mesh: group,
          velocity: new THREE.Vector3(),
          heading: 0,
          speed: 0,
        };
        return spongeState;
      }

      function spawnJellyfish() {
        const geo = new THREE.SphereGeometry(1.2, 16, 16, 0, Math.PI * 2, 0, Math.PI / 1.2);
        for (let i = 0; i < 24; i++) {
          const jelly = new THREE.Mesh(geo, textures.jellyfish);
          const angle = Math.random() * Math.PI * 2;
          const radius = THREE.MathUtils.randFloat(12, 60);
          jelly.position.set(35 + Math.cos(angle) * radius, THREE.MathUtils.randFloat(4, 10), 35 + Math.sin(angle) * radius);
          jelly.castShadow = true;
          jelly.userData = { baseY: jelly.position.y, offset: Math.random() * Math.PI * 2 };
          jellyfishGroup.add(jelly);
        }
      }

      function spawnRobots() {
        for (let i = 0; i < 12; i++) {
          const body = new THREE.Mesh(new THREE.BoxGeometry(2.2, 2.8, 1.6), textures.robot);
          body.position.set(THREE.MathUtils.randFloatSpread(80) - 20, 1.6, THREE.MathUtils.randFloatSpread(80) - 20);
          body.castShadow = true;
          body.userData = {
            angle: Math.random() * Math.PI * 2,
            radius: THREE.MathUtils.randFloat(8, 26),
            center: new THREE.Vector3(-20, 0, 10),
            speed: THREE.MathUtils.randFloat(0.6, 1.4),
            alive: true,
          };
          robotGroup.add(body);
        }
      }

      const touchStick = document.getElementById("touchStick");
      const dashBtn = document.getElementById("dashBtn");
      const spinBtn = document.getElementById("spinBtn");
      const resetBtn = document.getElementById("resetBtn");

      function setupTouchControls() {
        if (!matchMedia("(hover: none)").matches) return;
        renderer.domElement.style.touchAction = "none";

        touchStick.addEventListener("touchstart", (event) => {
          const touch = event.touches[0];
          touchStick.dataset.startX = touch.clientX;
          touchStick.dataset.startY = touch.clientY;
          event.preventDefault();
        });

        touchStick.addEventListener("touchmove", (event) => {
          const touch = event.touches[0];
          const startX = parseFloat(touchStick.dataset.startX || "0");
          const startY = parseFloat(touchStick.dataset.startY || "0");
          const dx = (touch.clientX - startX) / 40;
          const dy = (touch.clientY - startY) / 40;
          keyState["KeyW"] = dy < -0.3;
          keyState["KeyS"] = dy > 0.3;
          keyState["KeyA"] = dx < -0.3;
          keyState["KeyD"] = dx > 0.3;
          event.preventDefault();
        });

        touchStick.addEventListener("touchend", () => {
          keyState["KeyW"] = keyState["KeyS"] = keyState["KeyA"] = keyState["KeyD"] = false;
        });

        dashBtn.addEventListener("touchstart", (event) => {
          event.preventDefault();
          keyState["Space"] = true;
        });
        dashBtn.addEventListener("touchend", () => (keyState["Space"] = false));

        spinBtn.addEventListener("touchstart", (event) => {
          event.preventDefault();
          spinAttack();
        });

        resetBtn.addEventListener("touchstart", (event) => {
          event.preventDefault();
          resetSponge();
        });
      }

      function resetSponge() {
        sponge.mesh.position.set(0, 0, 0);
        sponge.mesh.rotation.set(0, 0, 0);
        sponge.speed = 0;
        stats.time = 90;
        stats.jellyfish = 0;
        stats.robots = 0;
        stats.playing = true;
        messageEl.textContent = "Fresh start! Jellyfish Fields awaits.";
        jellyfishGroup.children.forEach((jelly) => (jelly.visible = true));
        robotGroup.children.forEach((robot) => (robot.userData.alive = true));
      }

      function spinAttack() {
        if (!stats.playing) return;
        spawnBubble(sponge.mesh.position.clone().add(new THREE.Vector3(0, 1.6, 0)));
        robotGroup.children.forEach((robot) => {
          if (!robot.userData.alive) return;
          if (robot.position.distanceTo(sponge.mesh.position) < 3.6) {
            robot.userData.alive = false;
            stats.robots += 1;
            stats.time = Math.min(120, stats.time + 4);
            spawnBubble(robot.position.clone().add(new THREE.Vector3(0, 1, 0)));
            messageEl.textContent = "Robot down! +4s";
          }
        });
      }

      document.addEventListener("keydown", (event) => {
        if (event.code === "KeyF") spinAttack();
      });

      function spawnBubble(position) {
        const bubble = new THREE.Mesh(new THREE.SphereGeometry(0.8, 12, 12), new THREE.MeshStandardMaterial({ color: 0xffffff, transparent: true, opacity: 0.7 }));
        bubble.position.copy(position);
        bubble.userData = { life: 0.8 };
        particles.add(bubble);
      }

      function updateSponge(delta) {
        const forward = new THREE.Vector3(Math.sin(sponge.heading), 0, Math.cos(sponge.heading));
        const right = new THREE.Vector3().crossVectors(forward, new THREE.Vector3(0, 1, 0));

        const moveForward = (keyState["KeyW"] || keyState["ArrowUp"]) - (keyState["KeyS"] || keyState["ArrowDown"]);
        const moveRight = (keyState["KeyD"] || keyState["ArrowRight"]) - (keyState["KeyA"] || keyState["ArrowLeft"]);
        const dash = keyState["Space"] ? 12 : 0;

        const desiredHeading = Math.atan2(moveRight, moveForward);
        if (moveForward || moveRight) {
          const targetAngle = Math.atan2(moveRight, moveForward) + controls.getObject().rotation.y;
          sponge.heading = THREE.MathUtils.dampAngle(sponge.heading, targetAngle, 8.5, delta);
          sponge.speed = THREE.MathUtils.damp(sponge.speed, 40 + dash * 3.5, 8, delta);
        } else {
          sponge.speed = THREE.MathUtils.damp(sponge.speed, 0, 6, delta);
        }

        const direction = new THREE.Vector3(Math.sin(sponge.heading), 0, Math.cos(sponge.heading));
        sponge.mesh.position.add(direction.multiplyScalar(sponge.speed * delta));
        sponge.mesh.rotation.y = sponge.heading;

        sponge.mesh.position.x = THREE.MathUtils.clamp(sponge.mesh.position.x, -180, 180);
        sponge.mesh.position.z = THREE.MathUtils.clamp(sponge.mesh.position.z, -180, 180);

        controls.getObject().position.lerp(
          sponge.mesh.position
            .clone()
            .add(new THREE.Vector3(Math.sin(sponge.heading) * -14, 9, Math.cos(sponge.heading) * -14)),
          0.1
        );
        camera.position.copy(controls.getObject().position);
        camera.lookAt(sponge.mesh.position.clone().add(new THREE.Vector3(0, 2.5, 0)));
      }

      function updateJellyfish(delta, elapsed) {
        jellyfishGroup.children.forEach((jelly) => {
          if (!jelly.visible) return;
          jelly.position.y = jelly.userData.baseY + Math.sin(elapsed + jelly.userData.offset) * 0.6;
          jelly.rotation.y += delta * 0.8;
          if (jelly.position.distanceTo(sponge.mesh.position) < 2.6) {
            jelly.visible = false;
            stats.jellyfish += 1;
            stats.time = Math.min(120, stats.time + 3);
            messageEl.textContent = "Jelly caught! +3s";
            spawnBubble(jelly.position);
          }
        });
      }

      function updateRobots(delta, elapsed) {
        robotGroup.children.forEach((robot) => {
          if (!robot.userData.alive) {
            robot.visible = false;
            return;
          }
          robot.visible = true;
          robot.userData.angle += delta * robot.userData.speed;
          const center = robot.userData.center;
          robot.position.set(
            center.x + Math.cos(robot.userData.angle) * robot.userData.radius,
            1.6,
            center.z + Math.sin(robot.userData.angle) * robot.userData.radius
          );
          robot.rotation.y = robot.userData.angle + Math.PI / 2;

          if (robot.position.distanceTo(sponge.mesh.position) < 2.4) {
            stats.time = Math.max(0, stats.time - 4);
            messageEl.textContent = "Ouch! Robot bite -4s";
            spawnBubble(robot.position);
          }
        });
      }

      function updateParticles(delta) {
        for (let i = particles.children.length - 1; i >= 0; i--) {
          const bubble = particles.children[i];
          bubble.position.y += delta * 3;
          bubble.userData.life -= delta;
          bubble.material.opacity = Math.max(0, bubble.userData.life / 0.8);
          if (bubble.userData.life <= 0) {
            particles.remove(bubble);
            bubble.geometry.dispose();
            bubble.material.dispose();
          }
        }
      }

      function animate() {
        const delta = Math.min(clock.getDelta(), 0.033);
        const elapsed = clock.elapsedTime;
        if (stats.playing) {
          stats.time = Math.max(0, stats.time - delta);
          timerEl.textContent = stats.time.toFixed(1);
          if (stats.time <= 0) {
            stats.playing = false;
            messageEl.textContent = `Mission done! ${stats.jellyfish} jellyfish & ${stats.robots} robots.`;
          }
        }

        if (stats.playing) {
          updateSponge(delta);
          updateJellyfish(delta, elapsed);
          updateRobots(delta, elapsed);
        }

        updateParticles(delta);

        jellyfishEl.textContent = stats.jellyfish;
        robotsEl.textContent = stats.robots;

        renderer.render(scene, camera);
        requestAnimationFrame(animate);
      }

      animate();

      window.addEventListener("resize", () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      });
    </script>
  </body>
</html>
