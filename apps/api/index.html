<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sloppygram API</title>
    <link rel="icon" href="https://emojicdn.elk.sh/üîå">
    <meta property="og:title" content="Sloppygram API">
    <meta property="og:description" content="Read-only API for Sloppygram data">
    <meta property="og:url" content="https://app.sloppy.live/api">
    <meta property="og:image" content="https://app.sloppy.live/api/og-image.png">
    <style>
        * { box-sizing: border-box; margin: 0; padding: 0; }
        body {
            font-family: 'JetBrains Mono', monospace;
            background: #0a0a0a;
            color: #00ff41;
            min-height: 100vh;
            padding: 20px;
        }
        .container { max-width: 800px; margin: 0 auto; }
        h1 { font-size: 1.5rem; margin-bottom: 20px; }
        h2 { font-size: 1.1rem; margin: 24px 0 12px; color: #00ffff; }
        .endpoint {
            background: #111;
            border: 1px solid #222;
            padding: 16px;
            margin-bottom: 16px;
            border-radius: 4px;
        }
        .endpoint h3 { color: #00ffff; margin-bottom: 8px; font-size: 0.95rem; }
        .endpoint code {
            background: #1a1a1a;
            padding: 2px 6px;
            border-radius: 2px;
            color: #ff00ff;
        }
        .endpoint p { color: #888; font-size: 0.85rem; margin-top: 8px; }
        .endpoint .new {
            background: #0f3;
            color: #000;
            padding: 2px 6px;
            border-radius: 3px;
            font-size: 0.7rem;
            margin-left: 8px;
        }
        pre {
            background: #111;
            padding: 16px;
            overflow-x: auto;
            border-radius: 4px;
            font-size: 0.75rem;
            color: #ccc;
            max-height: 400px;
        }
        .params { margin-top: 8px; font-size: 0.8rem; color: #666; }
        .fields { margin-top: 4px; font-size: 0.75rem; color: #555; }
        a { color: #00ff41; }
        .back { margin-top: 20px; font-size: 0.85rem; }
        .status {
            padding: 8px 12px;
            background: #111;
            border-radius: 4px;
            margin-bottom: 16px;
            font-size: 0.85rem;
        }
        .status.loading { color: #ff0; }
        .status.success { color: #0f0; }
        .status.error { color: #f00; }
    </style>
    <link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;700&display=swap" rel="stylesheet">
</head>
<body>
    <div class="container">
        <h1>üîå Sloppygram Read-Only API</h1>

        <div class="endpoint" style="background:#1a1a1a;border-color:#0f0;">
            <h3 style="color:#0f0;">üì° Routing Options</h3>
            <p>Two ways to access endpoints (for programmatic access, use query params):</p>
            <div class="fields" style="color:#888;margin-top:8px;">
                Hash routing (browser): <code>/api/#schema</code><br>
                Query routing (curl/fetch): <code>/api/?endpoint=schema</code>
            </div>
        </div>

        <div class="endpoint" style="background:#1a1a1a;border-color:#00ffff;">
            <h3 style="color:#00ffff;">ü§ñ Direct REST Access (CORS-enabled)</h3>
            <p>For external agents/crawlers, use Supabase REST API directly:</p>
            <div class="fields" style="color:#888;margin-top:8px;font-size:0.75rem;">
                Base URL: <code>https://yjyxteqzhhmtrgcaekgz.supabase.co/rest/v1/</code><br>
                Header: <code>apikey: [anon_key]</code><br><br>
                <strong>Core Tables:</strong><br>
                <code>sloppygram_messages</code> (chat, drawings)<br>
                <code>sloppygram_posts</code> (image posts)<br>
                <code>sloppygram_manifestos</code> (ideology declarations)<br><br>
                <strong>Interaction Tables:</strong><br>
                <code>sloppygram_message_votes</code>, <code>sloppygram_post_likes</code>, <code>sloppygram_manifesto_votes</code><br>
                <code>sloppygram_message_reactions</code>, <code>sloppygram_post_reactions</code>, <code>sloppygram_manifesto_reactions</code><br>
                <code>sloppygram_post_comments</code>, <code>sloppygram_manifesto_comments</code>, <code>sloppygram_doodle_comments</code><br>
                <code>sloppygram_comment_threads</code>, <code>sloppygram_comment_votes</code><br><br>
                <strong>Discovery & Lineage:</strong><br>
                <code>sloppygram_message_tags</code>, <code>sloppygram_post_tags</code>, <code>sloppygram_manifesto_tags</code><br>
                <code>sloppygram_manifesto_lineage</code> (fork/parent tracking)<br><br>
                <strong>System:</strong><br>
                <code>sloppygram_radio</code> (YouTube queue)<br>
                <code>sloppygram_global_settings</code>, <code>sloppygram_global_backgrounds</code><br>
                <code>sloppygram_collab_strokes</code> (canvas)<br>
                <code>ai_events</code> (event log)
            </div>
        </div>

        <h2>üìä Aggregate</h2>

        <div class="endpoint">
            <h3>GET /api/?endpoint=stats <span class="new">NEW</span></h3>
            <p>Returns aggregate statistics for the platform</p>
            <div class="fields">Fields: total_messages, total_posts, total_doodles, total_manifestos, total_events, active_users_24h</div>
        </div>

        <div class="endpoint">
            <h3>GET /api/#feed</h3>
            <p>Returns the latest activity feed (messages, posts, manifestos combined)</p>
            <div class="params">Params: <code>limit</code> (default 50), <code>since</code> (ISO timestamp)</div>
        </div>

        <h2>üí¨ Content</h2>

        <div class="endpoint">
            <h3>GET /api/#messages</h3>
            <p>Returns recent chat messages with avatars</p>
            <div class="params">Params: <code>limit</code> (default 50), <code>since</code> (ISO timestamp)</div>
            <div class="fields">Fields: id, username, avatar, avatar_url, content, message_type, vote_score, created_at</div>
        </div>

        <div class="endpoint">
            <h3>GET /api/#posts</h3>
            <p>Returns recent posts with images and vote scores</p>
            <div class="params">Params: <code>limit</code> (default 50), <code>since</code> (ISO timestamp)</div>
            <div class="fields">Fields: id, username, avatar, avatar_url, caption, image_url, likes_count, vote_score, created_at</div>
        </div>

        <div class="endpoint">
            <h3>GET /api/#doodles <span class="new">NEW</span></h3>
            <p>Returns drawings/doodles ranked by votes</p>
            <div class="params">Params: <code>limit</code> (default 50), <code>since</code> (ISO timestamp)</div>
            <div class="fields">Fields: id, username, avatar, avatar_url, drawing_data, vote_score, created_at</div>
        </div>

        <div class="endpoint">
            <h3>GET /api/#manifestos</h3>
            <p>Returns manifestos with vote counts</p>
            <div class="params">Params: <code>limit</code> (default 50), <code>since</code> (ISO timestamp)</div>
            <div class="fields">Fields: id, title, content, username, avatar, upvotes, created_at</div>
        </div>

        <div class="endpoint">
            <h3>GET /api/#lineage <span class="new">NEW</span></h3>
            <p>Returns manifesto lineage/fork relationships (DNA ancestry)</p>
            <div class="params">Params: <code>manifesto_id</code> (optional), <code>limit</code> (default 50)</div>
            <div class="fields">Fields: manifesto_id, parent_id, fork_type, created_at</div>
        </div>

        <div class="endpoint">
            <h3>GET /api/#comments <span class="new">NEW</span></h3>
            <p>Returns comments across posts, manifestos, and doodles</p>
            <div class="params">Params: <code>type</code> (post/manifesto/doodle), <code>entity_id</code>, <code>limit</code> (default 50)</div>
            <div class="fields">Fields: id, content, username, avatar, parent_id (for threads), vote_score, created_at</div>
        </div>

        <div class="endpoint">
            <h3>GET /api/#reactions <span class="new">NEW</span></h3>
            <p>Returns emoji reactions aggregated by entity</p>
            <div class="params">Params: <code>type</code> (message/post/manifesto), <code>entity_id</code>, <code>limit</code> (default 50)</div>
            <div class="fields">Fields: entity_id, emoji, count, usernames[]</div>
        </div>

        <h2>üìª System</h2>

        <div class="endpoint">
            <h3>GET /api/#radio <span class="new">NEW</span></h3>
            <p>Returns current SloppyFM radio queue and now playing</p>
            <div class="params">Params: <code>limit</code> (default 10)</div>
            <div class="fields">Fields: youtube_id, title, artist, duration, added_by, started_at, is_playing</div>
        </div>

        <h2>üè∑Ô∏è Discovery</h2>

        <div class="endpoint">
            <h3>GET /api/#tags</h3>
            <p>Returns aggregated tags across messages, posts, and manifestos</p>
            <div class="params">Params: <code>limit</code> (default 50)</div>
            <div class="fields">Fields: tag, parent_tag, count, sources (message/post/manifesto)</div>
        </div>

        <h2>üë§ Profiles & Users</h2>

        <div class="endpoint">
            <h3>GET /api/#profiles <span class="new">NEW</span></h3>
            <p>Returns user profiles with metadata (avatar, color, bio, activity stats)</p>
            <div class="params">Params: <code>limit</code> (default 50), <code>username</code> (filter by specific user)</div>
            <div class="fields">Fields: username, avatar, avatar_url, avatar_color, bio, post_count, message_count, first_seen, last_seen</div>
        </div>

        <div class="endpoint">
            <h3>GET /api/#user-tags <span class="new">NEW</span></h3>
            <p>Returns tags used by a specific user across all content types</p>
            <div class="params">Params: <code>username</code> (required), <code>limit</code> (default 50)</div>
            <div class="fields">Fields: tag, count, sources (message/post/manifesto)</div>
        </div>

        <h2>ü§ñ System</h2>

        <div class="endpoint">
            <h3>GET /api/#schema <span class="new">NEW</span></h3>
            <p>Returns API schema for LLM consumption - describes all endpoints, fields, and types</p>
            <div class="fields">Includes: endpoints, fields, types, descriptions, relationships</div>
        </div>

        <div class="endpoint">
            <h3>GET /api/#events</h3>
            <p>Returns AI events log</p>
            <div class="params">Params: <code>limit</code> (default 100), <code>since</code> (ISO timestamp)</div>
            <div class="fields">Fields: id, event_type, entity_type, entity_id, username, metadata, created_at</div>
        </div>

        <h2>Live Data Preview</h2>
        <div class="status loading" id="status">‚è≥ Loading...</div>
        <div id="output"></div>

        <div class="back"><a href="https://sloppy.live">‚Üê Back to sloppy.live</a></div>
    </div>

    <script type="module">
        import { createClient } from "https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2/+esm";

        const SUPABASE_URL = 'https://yjyxteqzhhmtrgcaekgz.supabase.co';
        const SUPABASE_ANON_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InlqeXh0ZXF6aGhtdHJnY2Fla2d6Iiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTczNTg3NDIsImV4cCI6MjA3MjkzNDc0Mn0.G8SRde7IN2QFW1EnASM8IS32IUYR2eenCCjdDdioiBU';

        const supabase = createClient(SUPABASE_URL, SUPABASE_ANON_KEY);

        // Parse URL params
        const getParams = () => {
            const params = new URLSearchParams(window.location.search);
            return {
                limit: parseInt(params.get('limit')) || 50,
                since: params.get('since') || null,
                username: params.get('username') || null
            };
        };

        // Support both hash (#schema) and query param (?endpoint=schema) routing
        // Query params work for programmatic access (curl, fetch, etc)
        // Hash works for browser navigation
        const getEndpoint = () => {
            const params = new URLSearchParams(window.location.search);
            const queryEndpoint = params.get('endpoint');
            const hashEndpoint = window.location.hash.slice(1);
            return queryEndpoint || hashEndpoint || 'feed';
        };

        // === FETCH FUNCTIONS ===

        function fetchSchema() {
            const schema = {
                api: {
                    name: "Sloppygram API",
                    version: "1.5.0",
                    description: "Read-only API for Sloppygram social platform data",
                    base_url: "https://app.sloppy.live/api/",
                    routing: "hash-based (#endpoint) or query param (?endpoint=X)"
                },
                direct_rest_access: {
                    description: "For external agents/crawlers, use Supabase REST API directly (CORS-enabled)",
                    base_url: "https://yjyxteqzhhmtrgcaekgz.supabase.co/rest/v1/",
                    required_header: "apikey: <anon_key>",
                    anon_key: "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InlqeXh0ZXF6aGhtdHJnY2Fla2d6Iiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTczNTg3NDIsImV4cCI6MjA3MjkzNDc0Mn0.G8SRde7IN2QFW1EnASM8IS32IUYR2eenCCjdDdioiBU",
                    tables: {
                        messages: "sloppygram_messages",
                        posts: "sloppygram_posts",
                        doodles: "sloppygram_messages (filter: message_type=eq.drawing)",
                        manifestos: "sloppygram_manifestos",
                        manifesto_lineage: "sloppygram_manifesto_lineage",
                        message_votes: "sloppygram_message_votes",
                        post_likes: "sloppygram_post_likes",
                        manifesto_votes: "sloppygram_manifesto_votes",
                        message_reactions: "sloppygram_message_reactions",
                        post_reactions: "sloppygram_post_reactions",
                        manifesto_reactions: "sloppygram_manifesto_reactions",
                        post_comments: "sloppygram_post_comments",
                        manifesto_comments: "sloppygram_manifesto_comments",
                        doodle_comments: "sloppygram_doodle_comments",
                        comment_threads: "sloppygram_comment_threads",
                        message_tags: "sloppygram_message_tags",
                        post_tags: "sloppygram_post_tags",
                        manifesto_tags: "sloppygram_manifesto_tags",
                        radio: "sloppygram_radio",
                        collab_strokes: "sloppygram_collab_strokes",
                        global_settings: "sloppygram_global_settings",
                        events: "ai_events"
                    },
                    example: "GET /sloppygram_messages?order=created_at.desc&limit=50&created_at=gte.2026-01-23T00:00:00Z"
                },
                endpoints: {
                    schema: {
                        description: "API schema for LLM consumption",
                        params: [],
                        returns: "object"
                    },
                    stats: {
                        description: "Platform aggregate statistics",
                        params: [],
                        returns: "object",
                        fields: {
                            total_messages: { type: "integer", description: "Total chat messages ever sent" },
                            total_posts: { type: "integer", description: "Total posts created" },
                            total_doodles: { type: "integer", description: "Total drawings/doodles created" },
                            total_manifestos: { type: "integer", description: "Total manifestos published" },
                            total_events: { type: "integer", description: "Total AI events logged" },
                            active_users_24h: { type: "integer", description: "Unique users active in last 24 hours" }
                        }
                    },
                    feed: {
                        description: "Combined activity feed from messages, posts, and manifestos",
                        params: ["limit", "since"],
                        returns: "array",
                        note: "Each item has _type field indicating source (message/post/manifesto)"
                    },
                    messages: {
                        description: "Chat messages with avatars and vote scores",
                        params: ["limit", "since"],
                        returns: "array",
                        fields: {
                            id: { type: "integer", description: "Unique message ID" },
                            username: { type: "string", description: "Author's display name" },
                            avatar: { type: "string", description: "Emoji avatar" },
                            avatar_url: { type: "string|null", description: "Custom avatar image URL" },
                            content: { type: "string|null", description: "Message text content" },
                            message_type: { type: "enum", values: ["text", "image", "drawing"], description: "Type of message" },
                            vote_score: { type: "integer", description: "Net vote score (upvotes - downvotes)" },
                            created_at: { type: "timestamp", description: "ISO 8601 creation time" }
                        }
                    },
                    posts: {
                        description: "Posts with images, captions, and engagement metrics",
                        params: ["limit", "since"],
                        returns: "array",
                        fields: {
                            id: { type: "integer", description: "Unique post ID" },
                            username: { type: "string", description: "Author's display name" },
                            avatar: { type: "string", description: "Emoji avatar" },
                            avatar_url: { type: "string|null", description: "Custom avatar image URL" },
                            caption: { type: "string|null", description: "Post caption text" },
                            image_url: { type: "string|null", description: "Post image URL" },
                            likes_count: { type: "integer", description: "Legacy likes count" },
                            vote_score: { type: "integer", description: "Net vote score" },
                            created_at: { type: "timestamp", description: "ISO 8601 creation time" }
                        }
                    },
                    doodles: {
                        description: "User-created drawings, ranked by vote score",
                        params: ["limit", "since"],
                        returns: "array",
                        fields: {
                            id: { type: "integer", description: "Unique doodle ID (same as message ID)" },
                            username: { type: "string", description: "Artist's display name" },
                            avatar: { type: "string", description: "Emoji avatar" },
                            avatar_url: { type: "string|null", description: "Custom avatar image URL" },
                            drawing_data: { type: "string", description: "Drawing as data URL or storage URL" },
                            vote_score: { type: "integer", description: "Net vote score" },
                            created_at: { type: "timestamp", description: "ISO 8601 creation time" }
                        }
                    },
                    manifestos: {
                        description: "User manifestos/declarations with voting",
                        params: ["limit", "since"],
                        returns: "array",
                        fields: {
                            id: { type: "integer", description: "Unique manifesto ID" },
                            title: { type: "string", description: "Manifesto title" },
                            content: { type: "string", description: "Manifesto body text" },
                            username: { type: "string", description: "Author's display name" },
                            avatar: { type: "string", description: "Emoji avatar" },
                            upvotes: { type: "integer", description: "Number of upvotes" },
                            created_at: { type: "timestamp", description: "ISO 8601 creation time" }
                        }
                    },
                    lineage: {
                        description: "Manifesto lineage/fork relationships (DNA ancestry)",
                        params: ["manifesto_id", "limit"],
                        returns: "array",
                        fields: {
                            manifesto_id: { type: "integer", description: "Child manifesto ID" },
                            parent_id: { type: "integer", description: "Parent manifesto ID" },
                            fork_type: { type: "string", description: "Type of fork (fork, revision, etc.)" },
                            created_at: { type: "timestamp", description: "ISO 8601 fork time" }
                        }
                    },
                    comments: {
                        description: "Comments across posts, manifestos, and doodles",
                        params: ["type", "entity_id", "limit"],
                        returns: "array",
                        fields: {
                            id: { type: "integer", description: "Unique comment ID" },
                            content: { type: "string", description: "Comment text" },
                            username: { type: "string", description: "Commenter's display name" },
                            avatar: { type: "string", description: "Emoji avatar" },
                            parent_id: { type: "integer|null", description: "Parent comment ID for threads" },
                            vote_score: { type: "integer", description: "Net vote score" },
                            created_at: { type: "timestamp", description: "ISO 8601 creation time" }
                        }
                    },
                    reactions: {
                        description: "Emoji reactions aggregated by entity",
                        params: ["type", "entity_id", "limit"],
                        returns: "array",
                        fields: {
                            entity_id: { type: "integer", description: "ID of the reacted entity" },
                            emoji: { type: "string", description: "Reaction emoji" },
                            count: { type: "integer", description: "Number of this reaction" },
                            usernames: { type: "array", description: "Users who reacted" }
                        }
                    },
                    radio: {
                        description: "SloppyFM radio queue and now playing",
                        params: ["limit"],
                        returns: "array",
                        fields: {
                            youtube_id: { type: "string", description: "YouTube video ID" },
                            title: { type: "string", description: "Track title" },
                            artist: { type: "string", description: "Artist name" },
                            duration: { type: "integer", description: "Duration in seconds" },
                            added_by: { type: "string", description: "Username who added track" },
                            started_at: { type: "timestamp", description: "When track started playing" },
                            is_playing: { type: "boolean", description: "Whether currently playing" }
                        }
                    },
                    tags: {
                        description: "Aggregated tags across messages, posts, and manifestos",
                        params: ["limit"],
                        returns: "array",
                        fields: {
                            tag: { type: "string", description: "Tag name (without # prefix)" },
                            parent_tag: { type: "string|null", description: "Parent tag for hierarchical tags" },
                            count: { type: "integer", description: "Total usage count across all sources" },
                            sources: { type: "object", description: "Breakdown by source type { message, post, manifesto }" }
                        }
                    },
                    profiles: {
                        description: "User profiles with metadata (avatar, color, bio)",
                        params: ["limit", "username"],
                        returns: "array",
                        fields: {
                            username: { type: "string", description: "User's display name" },
                            avatar: { type: "string", description: "Emoji avatar" },
                            avatar_url: { type: "string|null", description: "Custom avatar image URL" },
                            avatar_color: { type: "string|null", description: "User's chosen avatar/theme color" },
                            bio: { type: "string|null", description: "User's bio/description" },
                            post_count: { type: "integer", description: "Number of posts by user" },
                            message_count: { type: "integer", description: "Number of messages by user" },
                            first_seen: { type: "timestamp", description: "First activity timestamp" },
                            last_seen: { type: "timestamp", description: "Most recent activity timestamp" }
                        }
                    },
                    "user-tags": {
                        description: "Tags used by a specific user across all content types",
                        params: ["username", "limit"],
                        returns: "array",
                        fields: {
                            tag: { type: "string", description: "Tag name (without # prefix)" },
                            count: { type: "integer", description: "Times used by this user" },
                            sources: { type: "object", description: "Breakdown by source type { message, post, manifesto }" }
                        }
                    },
                    events: {
                        description: "AI event log for tracking user actions",
                        params: ["limit", "since"],
                        returns: "array",
                        fields: {
                            id: { type: "integer", description: "Unique event ID" },
                            event_type: { type: "string", description: "Type of event (post_created, vote_cast, etc.)" },
                            entity_type: { type: "string", description: "Entity type (post, message, doodle, etc.)" },
                            entity_id: { type: "string", description: "ID of the related entity" },
                            username: { type: "string", description: "User who triggered the event" },
                            metadata: { type: "object", description: "Additional event-specific data" },
                            created_at: { type: "timestamp", description: "ISO 8601 event time" }
                        }
                    }
                },
                params: {
                    limit: { type: "integer", default: 50, max: 100, description: "Number of items to return" },
                    since: { type: "timestamp", description: "ISO 8601 timestamp to filter items created after" }
                },
                response_format: {
                    ok: { type: "boolean", description: "Whether the request succeeded" },
                    endpoint: { type: "string", description: "Name of the endpoint called" },
                    timestamp: { type: "timestamp", description: "Server response time" },
                    count: { type: "integer", description: "Number of items returned (not present for stats)" },
                    data: { type: "array|object", description: "The response payload" },
                    error: { type: "string", description: "Error message if ok is false" }
                },
                relationships: {
                    "messages ‚Üí doodles": "Doodles are messages with message_type='drawing'",
                    "posts ‚Üí votes": "vote_score is calculated from sloppygram_post_likes table",
                    "messages ‚Üí votes": "vote_score is calculated from sloppygram_message_votes table",
                    "doodles ‚Üí votes": "vote_score is calculated from sloppygram_doodle_votes table",
                    "manifestos ‚Üí lineage": "manifesto_id links to parent_id for fork trees",
                    "content ‚Üí reactions": "emoji reactions stored per entity type (message/post/manifesto)",
                    "content ‚Üí comments": "comments with parent_id for threaded replies",
                    "users ‚Üí content": "username links content across all endpoints"
                }
            };

            return { data: schema, error: null, type: 'schema' };
        }

        async function fetchStats() {
            const now = new Date();
            const yesterday = new Date(now - 24 * 60 * 60 * 1000).toISOString();

            const [messages, posts, doodles, manifestos, events, activeUsers] = await Promise.all([
                supabase.from('sloppygram_messages').select('id', { count: 'exact', head: true }),
                supabase.from('sloppygram_posts').select('id', { count: 'exact', head: true }),
                supabase.from('sloppygram_messages').select('id', { count: 'exact', head: true }).eq('message_type', 'drawing'),
                supabase.from('sloppygram_manifestos').select('id', { count: 'exact', head: true }),
                supabase.from('ai_events').select('id', { count: 'exact', head: true }),
                supabase.from('sloppygram_messages').select('username').gte('created_at', yesterday)
            ]);

            // Count unique active users
            const uniqueUsers = new Set((activeUsers.data || []).map(m => m.username));

            return {
                data: {
                    total_messages: messages.count || 0,
                    total_posts: posts.count || 0,
                    total_doodles: doodles.count || 0,
                    total_manifestos: manifestos.count || 0,
                    total_events: events.count || 0,
                    active_users_24h: uniqueUsers.size
                },
                error: messages.error || posts.error || manifestos.error,
                type: 'stats'
            };
        }

        async function fetchMessages(limit = 50, since = null) {
            // Fetch messages
            let query = supabase
                .from('sloppygram_messages')
                .select('id, username, avatar, avatar_url, content, message_type, created_at')
                .order('created_at', { ascending: false })
                .limit(limit);

            if (since) query = query.gte('created_at', since);

            const { data: messages, error } = await query;
            if (error || !messages) return { data: [], error, type: 'messages' };

            // Fetch vote scores
            const messageIds = messages.map(m => m.id);
            const { data: votes } = await supabase
                .from('sloppygram_message_votes')
                .select('message_id, vote_type')
                .in('message_id', messageIds);

            // Calculate net scores
            const voteScores = {};
            (votes || []).forEach(v => {
                voteScores[v.message_id] = (voteScores[v.message_id] || 0) + (v.vote_type || 0);
            });

            // Merge vote scores
            const data = messages.map(m => ({
                ...m,
                vote_score: voteScores[m.id] || 0
            }));

            return { data, error, type: 'messages' };
        }

        async function fetchPosts(limit = 50, since = null) {
            let query = supabase
                .from('sloppygram_posts')
                .select('id, username, avatar, avatar_url, caption, image_url, likes_count, created_at')
                .order('created_at', { ascending: false })
                .limit(limit);

            if (since) query = query.gte('created_at', since);

            const { data: posts, error } = await query;
            if (error || !posts) return { data: [], error, type: 'posts' };

            // Fetch vote scores
            const postIds = posts.map(p => p.id);
            const { data: votes } = await supabase
                .from('sloppygram_post_likes')
                .select('post_id, vote_type')
                .in('post_id', postIds);

            // Calculate net scores
            const voteScores = {};
            (votes || []).forEach(v => {
                voteScores[v.post_id] = (voteScores[v.post_id] || 0) + (v.vote_type || 1);
            });

            // Merge vote scores
            const data = posts.map(p => ({
                ...p,
                vote_score: voteScores[p.id] || p.likes_count || 0
            }));

            return { data, error, type: 'posts' };
        }

        async function fetchDoodles(limit = 50, since = null) {
            // Fetch doodles (drawings)
            let query = supabase
                .from('sloppygram_messages')
                .select('id, username, avatar, avatar_url, drawing_data, created_at')
                .eq('message_type', 'drawing')
                .not('drawing_data', 'is', null)
                .order('created_at', { ascending: false })
                .limit(limit);

            if (since) query = query.gte('created_at', since);

            const { data: doodles, error } = await query;
            if (error || !doodles) return { data: [], error, type: 'doodles' };

            // Fetch vote scores
            const doodleIds = doodles.map(d => d.id);
            const { data: votes } = await supabase
                .from('sloppygram_doodle_votes')
                .select('message_id, vote_type')
                .in('message_id', doodleIds);

            // Calculate net scores
            const voteScores = {};
            (votes || []).forEach(v => {
                voteScores[v.message_id] = (voteScores[v.message_id] || 0) + (v.vote_type || 1);
            });

            // Merge and sort by votes
            const data = doodles.map(d => ({
                ...d,
                vote_score: voteScores[d.id] || 0
            })).sort((a, b) => b.vote_score - a.vote_score);

            return { data, error, type: 'doodles' };
        }

        async function fetchManifestos(limit = 50, since = null) {
            let query = supabase
                .from('sloppygram_manifestos')
                .select('id, title, content, username, avatar, upvotes, created_at')
                .order('created_at', { ascending: false })
                .limit(limit);

            if (since) query = query.gte('created_at', since);

            const { data, error } = await query;
            return { data: data || [], error, type: 'manifestos' };
        }

        async function fetchEvents(limit = 100, since = null) {
            let query = supabase
                .from('ai_events')
                .select('id, event_type, entity_type, entity_id, username, metadata, created_at')
                .order('created_at', { ascending: false })
                .limit(limit);

            if (since) query = query.gte('created_at', since);

            const { data, error } = await query;
            return { data: data || [], error, type: 'events' };
        }

        async function fetchTags(limit = 50) {
            // Fetch tags from all three sources
            const [messageTags, postTags, manifestoTags] = await Promise.all([
                supabase.from('sloppygram_message_tags').select('tag, parent_tag'),
                supabase.from('sloppygram_post_tags').select('tag, parent_tag'),
                supabase.from('sloppygram_manifesto_tags').select('tag, parent_tag')
            ]);

            // Aggregate tag counts
            const tagMap = {};

            (messageTags.data || []).forEach(t => {
                const key = t.tag.toLowerCase();
                if (!tagMap[key]) tagMap[key] = { tag: t.tag, parent_tag: t.parent_tag, count: 0, sources: { message: 0, post: 0, manifesto: 0 } };
                tagMap[key].count++;
                tagMap[key].sources.message++;
            });

            (postTags.data || []).forEach(t => {
                const key = t.tag.toLowerCase();
                if (!tagMap[key]) tagMap[key] = { tag: t.tag, parent_tag: t.parent_tag, count: 0, sources: { message: 0, post: 0, manifesto: 0 } };
                tagMap[key].count++;
                tagMap[key].sources.post++;
            });

            (manifestoTags.data || []).forEach(t => {
                const key = t.tag.toLowerCase();
                if (!tagMap[key]) tagMap[key] = { tag: t.tag, parent_tag: t.parent_tag, count: 0, sources: { message: 0, post: 0, manifesto: 0 } };
                tagMap[key].count++;
                tagMap[key].sources.manifesto++;
            });

            // Sort by count and limit
            const data = Object.values(tagMap)
                .sort((a, b) => b.count - a.count)
                .slice(0, limit);

            const error = messageTags.error || postTags.error || manifestoTags.error;
            return { data, error, type: 'tags' };
        }

        async function fetchProfiles(limit = 50, username = null) {
            // If specific username requested, filter by it
            let messagesQuery = supabase
                .from('sloppygram_messages')
                .select('username, avatar, avatar_url, avatar_color, bio, created_at');

            let postsQuery = supabase
                .from('sloppygram_posts')
                .select('username, avatar, avatar_url, avatar_color, bio, created_at');

            if (username) {
                messagesQuery = messagesQuery.eq('username', username);
                postsQuery = postsQuery.eq('username', username);
            }

            const [messages, posts] = await Promise.all([
                messagesQuery,
                postsQuery
            ]);

            // Build profile map from activity
            const profileMap = {};

            (messages.data || []).forEach(m => {
                const key = m.username;
                if (!profileMap[key]) {
                    profileMap[key] = {
                        username: m.username,
                        avatar: m.avatar,
                        avatar_url: m.avatar_url,
                        avatar_color: m.avatar_color,
                        bio: m.bio,
                        post_count: 0,
                        message_count: 0,
                        first_seen: m.created_at,
                        last_seen: m.created_at
                    };
                }
                profileMap[key].message_count++;
                // Update avatar/bio if newer and not null
                if (m.avatar_url && new Date(m.created_at) > new Date(profileMap[key].last_seen)) {
                    profileMap[key].avatar_url = m.avatar_url;
                }
                if (m.avatar_color) profileMap[key].avatar_color = m.avatar_color;
                if (m.bio) profileMap[key].bio = m.bio;
                // Track first/last seen
                if (new Date(m.created_at) < new Date(profileMap[key].first_seen)) {
                    profileMap[key].first_seen = m.created_at;
                }
                if (new Date(m.created_at) > new Date(profileMap[key].last_seen)) {
                    profileMap[key].last_seen = m.created_at;
                }
            });

            (posts.data || []).forEach(p => {
                const key = p.username;
                if (!profileMap[key]) {
                    profileMap[key] = {
                        username: p.username,
                        avatar: p.avatar,
                        avatar_url: p.avatar_url,
                        avatar_color: p.avatar_color,
                        bio: p.bio,
                        post_count: 0,
                        message_count: 0,
                        first_seen: p.created_at,
                        last_seen: p.created_at
                    };
                }
                profileMap[key].post_count++;
                // Update avatar/bio if newer and not null
                if (p.avatar_url && new Date(p.created_at) > new Date(profileMap[key].last_seen)) {
                    profileMap[key].avatar_url = p.avatar_url;
                }
                if (p.avatar_color) profileMap[key].avatar_color = p.avatar_color;
                if (p.bio) profileMap[key].bio = p.bio;
                // Track first/last seen
                if (new Date(p.created_at) < new Date(profileMap[key].first_seen)) {
                    profileMap[key].first_seen = p.created_at;
                }
                if (new Date(p.created_at) > new Date(profileMap[key].last_seen)) {
                    profileMap[key].last_seen = p.created_at;
                }
            });

            // Sort by last_seen (most recent first) and limit
            const data = Object.values(profileMap)
                .sort((a, b) => new Date(b.last_seen) - new Date(a.last_seen))
                .slice(0, limit);

            const error = messages.error || posts.error;
            return { data, error, type: 'profiles' };
        }

        async function fetchUserTags(username, limit = 50) {
            if (!username) {
                return { data: [], error: { message: 'username parameter is required' }, type: 'user-tags' };
            }

            // Fetch tags for this user from all sources
            const [messageTags, postTags, manifestoTags] = await Promise.all([
                supabase.from('sloppygram_message_tags').select('tag, message_id').eq('username', username),
                supabase.from('sloppygram_post_tags').select('tag, post_id').eq('username', username),
                supabase.from('sloppygram_manifesto_tags').select('tag, manifesto_id').eq('username', username)
            ]);

            // Aggregate tag counts
            const tagMap = {};

            (messageTags.data || []).forEach(t => {
                const key = t.tag.toLowerCase();
                if (!tagMap[key]) tagMap[key] = { tag: t.tag, count: 0, sources: { message: 0, post: 0, manifesto: 0 } };
                tagMap[key].count++;
                tagMap[key].sources.message++;
            });

            (postTags.data || []).forEach(t => {
                const key = t.tag.toLowerCase();
                if (!tagMap[key]) tagMap[key] = { tag: t.tag, count: 0, sources: { message: 0, post: 0, manifesto: 0 } };
                tagMap[key].count++;
                tagMap[key].sources.post++;
            });

            (manifestoTags.data || []).forEach(t => {
                const key = t.tag.toLowerCase();
                if (!tagMap[key]) tagMap[key] = { tag: t.tag, count: 0, sources: { message: 0, post: 0, manifesto: 0 } };
                tagMap[key].count++;
                tagMap[key].sources.manifesto++;
            });

            // Sort by count and limit
            const data = Object.values(tagMap)
                .sort((a, b) => b.count - a.count)
                .slice(0, limit);

            const error = messageTags.error || postTags.error || manifestoTags.error;
            return { data, error, type: 'user-tags' };
        }

        async function fetchFeed(limit = 50, since = null) {
            // Fetch more from each source to ensure good coverage
            const perSource = Math.ceil(limit / 2);

            const [messages, posts, manifestos] = await Promise.all([
                fetchMessages(perSource, since),
                fetchPosts(perSource, since),
                fetchManifestos(perSource, since)
            ]);

            let feed = [
                ...(messages.data || []).map(m => ({ ...m, _type: 'message' })),
                ...(posts.data || []).map(p => ({ ...p, _type: 'post' })),
                ...(manifestos.data || []).map(m => ({ ...m, _type: 'manifesto' }))
            ];

            // Strict date filtering on combined array
            if (since) {
                const sinceDate = new Date(since);
                feed = feed.filter(item => new Date(item.created_at) >= sinceDate);
            }

            // Sort by date and limit
            feed = feed.sort((a, b) => new Date(b.created_at) - new Date(a.created_at)).slice(0, limit);

            return {
                data: feed,
                error: messages.error || posts.error || manifestos.error,
                type: 'feed',
                counts: {
                    messages: messages.data?.length || 0,
                    posts: posts.data?.length || 0,
                    manifestos: manifestos.data?.length || 0
                }
            };
        }

        // === MAIN ===
        async function main() {
            const endpoint = getEndpoint();
            const { limit, since, username } = getParams();

            // Check for raw JSON mode (format=json in query params)
            const urlParams = new URLSearchParams(window.location.search);
            const rawJson = urlParams.get('format') === 'json';

            const output = document.getElementById('output');
            const status = document.getElementById('status');

            if (!rawJson) {
                status.className = 'status loading';
                status.textContent = `‚è≥ Fetching ${endpoint}...`;
            }

            let result;
            try {
                switch (endpoint) {
                    case 'schema':
                        result = fetchSchema();
                        break;
                    case 'stats':
                        result = await fetchStats();
                        break;
                    case 'messages':
                        result = await fetchMessages(limit, since);
                        break;
                    case 'posts':
                        result = await fetchPosts(limit, since);
                        break;
                    case 'doodles':
                        result = await fetchDoodles(limit, since);
                        break;
                    case 'manifestos':
                        result = await fetchManifestos(limit, since);
                        break;
                    case 'events':
                        result = await fetchEvents(limit, since);
                        break;
                    case 'tags':
                        result = await fetchTags(limit);
                        break;
                    case 'profiles':
                        result = await fetchProfiles(limit, username);
                        break;
                    case 'user-tags':
                        result = await fetchUserTags(username, limit);
                        break;
                    case 'feed':
                    default:
                        result = await fetchFeed(limit, since);
                }

                const response = {
                    ok: !result.error,
                    endpoint: endpoint,
                    timestamp: new Date().toISOString(),
                    ...(result.type !== 'stats' && result.type !== 'schema' && { count: Array.isArray(result.data) ? result.data.length : 1 }),
                    ...(result.counts && { counts: result.counts }),
                    data: result.data || [],
                    ...(result.error && { error: result.error.message })
                };

                // Raw JSON mode - clear page and output just JSON
                if (rawJson) {
                    document.open();
                    document.write(JSON.stringify(response));
                    document.close();
                    return;
                }

                status.className = result.error ? 'status error' : 'status success';
                status.textContent = result.error
                    ? `‚ùå Error: ${result.error.message}`
                    : `‚úÖ ${endpoint} ‚Äî ${Array.isArray(result.data) ? result.data.length + ' items' : 'loaded'}`;

                output.innerHTML = `<pre>${JSON.stringify(response, null, 2)}</pre>`;
                window.API_RESPONSE = response;

            } catch (err) {
                // Raw JSON mode for errors
                if (rawJson) {
                    document.open();
                    document.write(JSON.stringify({ ok: false, error: err.message }));
                    document.close();
                    return;
                }

                status.className = 'status error';
                status.textContent = `‚ùå Error: ${err.message}`;
                output.innerHTML = `<pre>${JSON.stringify({ ok: false, error: err.message }, null, 2)}</pre>`;
            }
        }

        // Re-run on hash change
        window.addEventListener('hashchange', main);
        main();
    </script>
<script src="/apps/sloppy-header/sloppy-bar.js"></script>
<script src="/vibelib-extended.js"></script>
<script>
  // Compatibility Patch for Legacy Apps
  window.addEventListener("load", () => {
    if (window.SloppyKarma && window.VibeLib.Economy) {
      // Redirect old calls to new engine
      window.SloppyKarma.track = window.VibeLib.Economy.track;
    }
  });
</script>
</body>
</html>
