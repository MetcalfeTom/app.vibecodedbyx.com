<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
  <title>Neon Invaders</title>
  <link rel="icon" href="https://emojicdn.elk.sh/üëæ">
  <meta property="og:title" content="Neon Invaders">
  <meta property="og:description" content="Space invaders with rainbow lasers and screen shake!">
  <meta property="og:url" content="https://sloppy.live/neon-invaders">
  <meta property="og:image" content="https://emojicdn.elk.sh/üëæ?style=apple&size=512">
  <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      background: #000;
      overflow: hidden;
      font-family: 'Press Start 2P', cursive;
    }
    #wrapper {
      width: 100vw;
      height: 100vh;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    canvas { display: block; }
    .ui {
      position: fixed;
      top: 10px;
      left: 10px;
      right: 10px;
      display: flex;
      justify-content: space-between;
      z-index: 100;
      pointer-events: none;
    }
    .score {
      color: #0ff;
      font-size: 16px;
      text-shadow: 0 0 10px #0ff;
    }
    .high-score {
      color: #f0f;
      font-size: 12px;
      text-shadow: 0 0 10px #f0f;
    }
    .lives {
      display: flex;
      gap: 5px;
      align-items: center;
    }
    .life {
      color: #0f0;
      font-size: 16px;
      text-shadow: 0 0 8px #0f0;
    }
    .wave {
      color: #ff0;
      font-size: 12px;
      text-shadow: 0 0 10px #ff0;
    }
    .overlay {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      text-align: center;
      z-index: 200;
    }
    .overlay h1 {
      font-size: 32px;
      margin-bottom: 20px;
      animation: pulse 0.5s infinite alternate;
    }
    @keyframes pulse {
      from { text-shadow: 0 0 20px currentColor; }
      to { text-shadow: 0 0 40px currentColor, 0 0 60px currentColor; }
    }
    .overlay.start h1 { color: #0ff; }
    .overlay.gameover h1 { color: #f00; }
    .overlay.victory h1 { color: #0f0; }
    .overlay p {
      color: #fff;
      font-size: 12px;
      margin-bottom: 30px;
      text-shadow: 0 0 10px #fff;
    }
    .btn {
      background: transparent;
      border: 2px solid #0ff;
      color: #0ff;
      padding: 12px 30px;
      font-family: 'Press Start 2P', cursive;
      font-size: 12px;
      cursor: pointer;
      text-shadow: 0 0 10px #0ff;
      box-shadow: 0 0 20px rgba(0,255,255,0.3);
      transition: all 0.2s;
    }
    .btn:hover {
      background: rgba(0,255,255,0.2);
      box-shadow: 0 0 40px rgba(0,255,255,0.6);
      transform: scale(1.05);
    }
    .controls {
      position: fixed;
      bottom: 10px;
      left: 50%;
      transform: translateX(-50%);
      color: rgba(255,255,255,0.4);
      font-size: 8px;
      z-index: 100;
    }
    .mobile-controls {
      position: fixed;
      bottom: 20px;
      left: 0;
      right: 0;
      display: none;
      justify-content: space-between;
      padding: 0 20px;
      z-index: 100;
    }
    .touch-btn {
      width: 70px;
      height: 70px;
      border-radius: 50%;
      background: rgba(0,255,255,0.15);
      border: 2px solid rgba(0,255,255,0.4);
      color: #0ff;
      font-size: 24px;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    .touch-btn.fire {
      background: linear-gradient(45deg, rgba(255,0,0,0.3), rgba(255,255,0,0.3), rgba(0,255,0,0.3), rgba(0,255,255,0.3), rgba(255,0,255,0.3));
      border: 2px solid #fff;
      width: 80px;
      height: 80px;
    }
    .touch-group { display: flex; gap: 15px; }
    @media (max-width: 768px) {
      .mobile-controls { display: flex; }
      .controls { display: none; }
      .score { font-size: 12px; }
    }
    .backlink {
      position: fixed;
      bottom: 10px;
      left: 10px;
      color: rgba(255,255,255,0.3);
      font-size: 8px;
      text-decoration: none;
      z-index: 50;
    }
  </style>
</head>
<body>
  <div id="wrapper">
    <canvas id="game"></canvas>
  </div>

  <div class="ui">
    <div>
      <div class="score">SCORE: <span id="score">0</span></div>
      <div class="high-score">HI: <span id="hiScore">0</span></div>
    </div>
    <div class="wave">WAVE <span id="wave">1</span></div>
    <div class="lives" id="lives"></div>
  </div>

  <div class="overlay start" id="startScreen">
    <h1>NEON INVADERS</h1>
    <p>RAINBOW LASERS ‚Ä¢ SCREEN SHAKE</p>
    <button class="btn" id="startBtn">START</button>
  </div>

  <div class="overlay gameover" id="gameOver" style="display:none">
    <h1>GAME OVER</h1>
    <p>FINAL SCORE: <span id="finalScore">0</span></p>
    <button class="btn" id="restartBtn">RETRY</button>
  </div>

  <div class="overlay victory" id="victory" style="display:none">
    <h1>WAVE CLEAR!</h1>
    <p>BONUS: +1000</p>
  </div>

  <div class="controls">‚Üê ‚Üí or A D to move ‚Ä¢ SPACE to fire</div>

  <div class="mobile-controls">
    <div class="touch-group">
      <button class="touch-btn" id="touchLeft">‚óÄ</button>
      <button class="touch-btn" id="touchRight">‚ñ∂</button>
    </div>
    <button class="touch-btn fire" id="touchFire">‚ö°</button>
  </div>

  <a href="https://sloppy.live" class="backlink">sloppy.live</a>

  <script>
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');
    const wrapper = document.getElementById('wrapper');

    const WIDTH = 800;
    const HEIGHT = 600;
    canvas.width = WIDTH;
    canvas.height = HEIGHT;

    // Screen shake
    let shakeIntensity = 0;
    let shakeDecay = 0.9;

    function shake(intensity) {
      shakeIntensity = Math.max(shakeIntensity, intensity);
    }

    function applyShake() {
      if (shakeIntensity > 0.5) {
        const dx = (Math.random() - 0.5) * shakeIntensity;
        const dy = (Math.random() - 0.5) * shakeIntensity;
        canvas.style.transform = `translate(${dx}px, ${dy}px)`;
        shakeIntensity *= shakeDecay;
      } else {
        canvas.style.transform = '';
        shakeIntensity = 0;
      }
    }

    // Game state
    let gameRunning = false;
    let score = 0;
    let hiScore = parseInt(localStorage.getItem('neonInvadersHi') || '0');
    let wave = 1;
    let lives = 3;

    document.getElementById('hiScore').textContent = hiScore;

    const keys = {};

    // Player
    const player = {
      x: WIDTH / 2,
      y: HEIGHT - 50,
      width: 50,
      height: 30,
      speed: 6
    };

    // Bullets
    let playerBullets = [];
    let enemyBullets = [];

    // Invaders
    let invaders = [];
    let invaderDirection = 1;
    let invaderSpeed = 1;
    let invaderDropAmount = 20;

    // Particles
    let particles = [];

    // Shields
    let shields = [];

    // Rainbow color
    let rainbowHue = 0;
    function getRainbow(offset = 0) {
      return `hsl(${(rainbowHue + offset) % 360}, 100%, 50%)`;
    }

    // Initialize invaders
    function createInvaders() {
      invaders = [];
      const rows = 5;
      const cols = 11;
      const types = ['üëæ', 'üëΩ', 'üõ∏'];
      
      for (let row = 0; row < rows; row++) {
        for (let col = 0; col < cols; col++) {
          invaders.push({
            x: 80 + col * 55,
            y: 80 + row * 45,
            width: 40,
            height: 30,
            type: types[Math.min(row, 2)],
            points: (3 - Math.min(row, 2)) * 10 + 10,
            alive: true,
            animFrame: 0
          });
        }
      }
      invaderSpeed = 1 + wave * 0.3;
      invaderDirection = 1;
    }

    // Create shields
    function createShields() {
      shields = [];
      const shieldPositions = [150, 325, 500, 675];
      
      shieldPositions.forEach(x => {
        for (let row = 0; row < 4; row++) {
          for (let col = 0; col < 6; col++) {
            // Skip corners for shield shape
            if ((row === 0 && (col === 0 || col === 5)) ||
                (row === 3 && col >= 2 && col <= 3)) continue;
            
            shields.push({
              x: x - 30 + col * 10,
              y: HEIGHT - 150 + row * 10,
              width: 10,
              height: 10,
              health: 3
            });
          }
        }
      });
    }

    // Particle explosion
    function explode(x, y, color, count = 20) {
      for (let i = 0; i < count; i++) {
        const angle = Math.random() * Math.PI * 2;
        const speed = Math.random() * 5 + 2;
        particles.push({
          x, y,
          vx: Math.cos(angle) * speed,
          vy: Math.sin(angle) * speed,
          color: color || getRainbow(i * 30),
          size: Math.random() * 4 + 2,
          life: 40 + Math.random() * 20
        });
      }
    }

    // Player bullet (rainbow!)
    class PlayerBullet {
      constructor(x, y) {
        this.x = x;
        this.y = y;
        this.width = 6;
        this.height = 20;
        this.speed = 10;
        this.hue = rainbowHue;
      }

      update() {
        this.y -= this.speed;
        this.hue += 5;
      }

      draw() {
        // Rainbow gradient beam
        const gradient = ctx.createLinearGradient(this.x, this.y, this.x, this.y + this.height);
        gradient.addColorStop(0, `hsl(${this.hue}, 100%, 50%)`);
        gradient.addColorStop(0.5, `hsl(${(this.hue + 60) % 360}, 100%, 50%)`);
        gradient.addColorStop(1, `hsl(${(this.hue + 120) % 360}, 100%, 50%)`);
        
        ctx.fillStyle = gradient;
        ctx.shadowColor = `hsl(${this.hue}, 100%, 50%)`;
        ctx.shadowBlur = 15;
        ctx.fillRect(this.x - this.width / 2, this.y, this.width, this.height);
        
        // Trail particles
        if (Math.random() > 0.5) {
          particles.push({
            x: this.x + (Math.random() - 0.5) * 10,
            y: this.y + this.height,
            vx: (Math.random() - 0.5) * 2,
            vy: Math.random() * 2,
            color: `hsl(${this.hue}, 100%, 50%)`,
            size: Math.random() * 3 + 1,
            life: 15
          });
        }
        
        ctx.shadowBlur = 0;
      }
    }

    // Enemy bullet
    class EnemyBullet {
      constructor(x, y) {
        this.x = x;
        this.y = y;
        this.width = 4;
        this.height = 15;
        this.speed = 5 + wave * 0.5;
      }

      update() {
        this.y += this.speed;
      }

      draw() {
        ctx.fillStyle = '#f00';
        ctx.shadowColor = '#f00';
        ctx.shadowBlur = 10;
        ctx.fillRect(this.x - this.width / 2, this.y, this.width, this.height);
        ctx.shadowBlur = 0;
      }
    }

    // Shooting
    let lastShot = 0;
    function shoot() {
      const now = Date.now();
      if (now - lastShot < 300) return;
      lastShot = now;
      playerBullets.push(new PlayerBullet(player.x, player.y - 20));
    }

    // Enemy shooting
    function enemyShoot() {
      const aliveInvaders = invaders.filter(i => i.alive);
      if (aliveInvaders.length === 0) return;
      
      // Find bottom invaders in each column
      const columns = {};
      aliveInvaders.forEach(inv => {
        const col = Math.floor(inv.x / 55);
        if (!columns[col] || inv.y > columns[col].y) {
          columns[col] = inv;
        }
      });
      
      const bottomInvaders = Object.values(columns);
      if (bottomInvaders.length > 0 && Math.random() < 0.02 + wave * 0.005) {
        const shooter = bottomInvaders[Math.floor(Math.random() * bottomInvaders.length)];
        enemyBullets.push(new EnemyBullet(shooter.x + shooter.width / 2, shooter.y + shooter.height));
      }
    }

    // Collision detection
    function collides(a, b) {
      return a.x < b.x + b.width &&
             a.x + a.width > b.x &&
             a.y < b.y + b.height &&
             a.y + a.height > b.y;
    }

    // Update lives display
    function updateLives() {
      const container = document.getElementById('lives');
      container.innerHTML = '';
      for (let i = 0; i < lives; i++) {
        const life = document.createElement('span');
        life.className = 'life';
        life.textContent = '‚ñ≤';
        container.appendChild(life);
      }
    }

    // Update game
    function update() {
      if (!gameRunning) return;

      rainbowHue = (rainbowHue + 2) % 360;

      // Player movement
      if (keys['ArrowLeft'] || keys['a']) {
        player.x = Math.max(player.width / 2, player.x - player.speed);
      }
      if (keys['ArrowRight'] || keys['d']) {
        player.x = Math.min(WIDTH - player.width / 2, player.x + player.speed);
      }

      // Update player bullets
      playerBullets.forEach(b => b.update());
      playerBullets = playerBullets.filter(b => b.y > -20);

      // Update enemy bullets
      enemyBullets.forEach(b => b.update());
      enemyBullets = enemyBullets.filter(b => b.y < HEIGHT + 20);

      // Update particles
      particles.forEach(p => {
        p.x += p.vx;
        p.y += p.vy;
        p.vy += 0.1;
        p.life--;
      });
      particles = particles.filter(p => p.life > 0);

      // Move invaders
      let shouldDrop = false;
      const aliveInvaders = invaders.filter(i => i.alive);
      
      aliveInvaders.forEach(inv => {
        inv.x += invaderSpeed * invaderDirection;
        inv.animFrame = (inv.animFrame + 0.1) % 2;
        
        if (inv.x <= 20 || inv.x >= WIDTH - 60) {
          shouldDrop = true;
        }
      });

      if (shouldDrop) {
        invaderDirection *= -1;
        aliveInvaders.forEach(inv => {
          inv.y += invaderDropAmount;
        });
        invaderSpeed += 0.1;
      }

      // Enemy shooting
      enemyShoot();

      // Bullet-invader collision
      playerBullets.forEach((bullet, bi) => {
        invaders.forEach((inv, ii) => {
          if (inv.alive && collides(
            { x: bullet.x - bullet.width / 2, y: bullet.y, width: bullet.width, height: bullet.height },
            inv
          )) {
            inv.alive = false;
            playerBullets.splice(bi, 1);
            score += inv.points;
            explode(inv.x + inv.width / 2, inv.y + inv.height / 2, null, 30);
            shake(15);
          }
        });
      });

      // Bullet-shield collision
      playerBullets.forEach((bullet, bi) => {
        shields.forEach((shield, si) => {
          if (shield.health > 0 && collides(
            { x: bullet.x - bullet.width / 2, y: bullet.y, width: bullet.width, height: bullet.height },
            shield
          )) {
            shield.health--;
            playerBullets.splice(bi, 1);
            explode(shield.x + 5, shield.y + 5, '#0f0', 5);
          }
        });
      });

      enemyBullets.forEach((bullet, bi) => {
        shields.forEach((shield, si) => {
          if (shield.health > 0 && collides(
            { x: bullet.x - bullet.width / 2, y: bullet.y, width: bullet.width, height: bullet.height },
            shield
          )) {
            shield.health--;
            enemyBullets.splice(bi, 1);
            explode(shield.x + 5, shield.y + 5, '#f00', 5);
          }
        });
      });

      // Enemy bullet-player collision
      enemyBullets.forEach((bullet, bi) => {
        if (collides(
          { x: bullet.x - bullet.width / 2, y: bullet.y, width: bullet.width, height: bullet.height },
          { x: player.x - player.width / 2, y: player.y - player.height / 2, width: player.width, height: player.height }
        )) {
          enemyBullets.splice(bi, 1);
          lives--;
          updateLives();
          explode(player.x, player.y, '#0ff', 40);
          shake(30);
          
          if (lives <= 0) {
            gameOver();
          }
        }
      });

      // Invader reaches bottom
      aliveInvaders.forEach(inv => {
        if (inv.y + inv.height >= player.y - 20) {
          gameOver();
        }
      });

      // Wave clear
      if (aliveInvaders.length === 0) {
        waveComplete();
      }

      // Update UI
      document.getElementById('score').textContent = score;
      document.getElementById('wave').textContent = wave;
    }

    // Draw game
    function draw() {
      // Clear
      ctx.fillStyle = '#000';
      ctx.fillRect(0, 0, WIDTH, HEIGHT);

      // Stars
      ctx.fillStyle = 'rgba(255,255,255,0.5)';
      for (let i = 0; i < 50; i++) {
        const x = (i * 137 + rainbowHue) % WIDTH;
        const y = (i * 97) % HEIGHT;
        ctx.fillRect(x, y, 1, 1);
      }

      // Draw shields
      shields.forEach(shield => {
        if (shield.health > 0) {
          const alpha = shield.health / 3;
          ctx.fillStyle = `rgba(0, 255, 0, ${alpha})`;
          ctx.shadowColor = '#0f0';
          ctx.shadowBlur = 5;
          ctx.fillRect(shield.x, shield.y, shield.width, shield.height);
        }
      });
      ctx.shadowBlur = 0;

      // Draw invaders
      invaders.forEach(inv => {
        if (!inv.alive) return;
        
        ctx.font = '28px sans-serif';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        
        // Glow effect
        const glowColor = getRainbow(inv.x + inv.y);
        ctx.shadowColor = glowColor;
        ctx.shadowBlur = 15;
        
        const bounce = Math.sin(inv.animFrame * Math.PI) * 3;
        ctx.fillText(inv.type, inv.x + inv.width / 2, inv.y + inv.height / 2 + bounce);
        ctx.shadowBlur = 0;
      });

      // Draw player
      ctx.fillStyle = '#0ff';
      ctx.shadowColor = '#0ff';
      ctx.shadowBlur = 15;
      
      ctx.beginPath();
      ctx.moveTo(player.x, player.y - player.height / 2);
      ctx.lineTo(player.x - player.width / 2, player.y + player.height / 2);
      ctx.lineTo(player.x + player.width / 2, player.y + player.height / 2);
      ctx.closePath();
      ctx.fill();
      ctx.shadowBlur = 0;

      // Draw bullets
      playerBullets.forEach(b => b.draw());
      enemyBullets.forEach(b => b.draw());

      // Draw particles
      particles.forEach(p => {
        ctx.fillStyle = p.color;
        ctx.globalAlpha = p.life / 60;
        ctx.shadowColor = p.color;
        ctx.shadowBlur = 8;
        ctx.beginPath();
        ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
        ctx.fill();
      });
      ctx.globalAlpha = 1;
      ctx.shadowBlur = 0;

      applyShake();
    }

    // Game loop
    function gameLoop() {
      update();
      draw();
      requestAnimationFrame(gameLoop);
    }

    // Start game
    function startGame() {
      gameRunning = true;
      score = 0;
      wave = 1;
      lives = 3;
      player.x = WIDTH / 2;
      playerBullets = [];
      enemyBullets = [];
      particles = [];
      
      createInvaders();
      createShields();
      updateLives();
      
      document.getElementById('startScreen').style.display = 'none';
      document.getElementById('gameOver').style.display = 'none';
      document.getElementById('victory').style.display = 'none';
    }

    // Wave complete
    function waveComplete() {
      score += 1000;
      wave++;
      
      document.getElementById('victory').style.display = 'block';
      gameRunning = false;
      
      setTimeout(() => {
        document.getElementById('victory').style.display = 'none';
        createInvaders();
        enemyBullets = [];
        gameRunning = true;
      }, 2000);
    }

    // Game over
    function gameOver() {
      gameRunning = false;
      
      if (score > hiScore) {
        hiScore = score;
        localStorage.setItem('neonInvadersHi', hiScore);
        document.getElementById('hiScore').textContent = hiScore;
      }
      
      document.getElementById('finalScore').textContent = score;
      document.getElementById('gameOver').style.display = 'block';
    }

    // Input
    document.addEventListener('keydown', e => {
      keys[e.key] = true;
      if (e.key === ' ' && gameRunning) {
        e.preventDefault();
        shoot();
      }
    });
    document.addEventListener('keyup', e => keys[e.key] = false);

    // Touch controls
    function setupTouch(id, key) {
      const btn = document.getElementById(id);
      btn.addEventListener('touchstart', e => { e.preventDefault(); keys[key] = true; }, { passive: false });
      btn.addEventListener('touchend', e => { e.preventDefault(); keys[key] = false; }, { passive: false });
    }
    setupTouch('touchLeft', 'ArrowLeft');
    setupTouch('touchRight', 'ArrowRight');

    const fireBtn = document.getElementById('touchFire');
    let fireInterval;
    fireBtn.addEventListener('touchstart', e => {
      e.preventDefault();
      shoot();
      fireInterval = setInterval(shoot, 300);
    }, { passive: false });
    fireBtn.addEventListener('touchend', e => {
      e.preventDefault();
      clearInterval(fireInterval);
    }, { passive: false });

    // Buttons
    document.getElementById('startBtn').addEventListener('click', startGame);
    document.getElementById('restartBtn').addEventListener('click', startGame);

    // Init
    updateLives();
    gameLoop();
  </script>
</body>
</html>
