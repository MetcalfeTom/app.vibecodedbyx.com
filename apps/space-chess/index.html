<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Space Chess - Neon 3D Battle</title>
  <link rel="icon" href="https://emojicdn.elk.sh/â™Ÿï¸">
  <meta property="og:title" content="Space Chess">
  <meta property="og:description" content="Play chess in the cosmos with neon floating pieces!">
  <meta property="og:url" content="https://sloppy.live/space-chess">
  <meta property="og:image" content="https://emojicdn.elk.sh/â™Ÿï¸?style=apple&size=512">
  <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&family=Exo+2:wght@300;400&display=swap" rel="stylesheet">
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }

    body {
      font-family: 'Exo 2', sans-serif;
      background: #000;
      overflow: hidden;
      color: #fff;
    }

    #canvas-container {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
    }

    .ui {
      position: fixed;
      z-index: 10;
      pointer-events: none;
    }

    .ui > * { pointer-events: auto; }

    .header {
      position: fixed;
      top: 15px;
      left: 50%;
      transform: translateX(-50%);
      text-align: center;
    }

    .title {
      font-family: 'Orbitron', sans-serif;
      font-size: 1.8rem;
      background: linear-gradient(90deg, #0ff, #f0f, #0ff);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
      text-shadow: none;
      filter: drop-shadow(0 0 10px #0ff);
    }

    .turn-indicator {
      position: fixed;
      top: 60px;
      left: 50%;
      transform: translateX(-50%);
      font-family: 'Orbitron', sans-serif;
      font-size: 1rem;
      padding: 8px 25px;
      border-radius: 25px;
      border: 2px solid;
      transition: all 0.3s;
    }

    .turn-indicator.white {
      color: #0ff;
      border-color: #0ff;
      box-shadow: 0 0 20px rgba(0, 255, 255, 0.5);
    }

    .turn-indicator.black {
      color: #f0f;
      border-color: #f0f;
      box-shadow: 0 0 20px rgba(255, 0, 255, 0.5);
    }

    .controls {
      position: fixed;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      display: flex;
      gap: 15px;
    }

    .ctrl-btn {
      font-family: 'Orbitron', sans-serif;
      font-size: 0.9rem;
      padding: 10px 25px;
      background: rgba(0, 0, 0, 0.7);
      border: 2px solid #0ff;
      color: #0ff;
      cursor: pointer;
      border-radius: 5px;
      transition: all 0.3s;
    }

    .ctrl-btn:hover {
      background: #0ff;
      color: #000;
      box-shadow: 0 0 20px #0ff;
    }

    .captured-panel {
      position: fixed;
      top: 100px;
      padding: 15px;
      background: rgba(0, 0, 0, 0.7);
      border-radius: 10px;
      min-width: 60px;
    }

    .captured-panel.left {
      left: 15px;
      border: 2px solid #0ff;
    }

    .captured-panel.right {
      right: 15px;
      border: 2px solid #f0f;
    }

    .captured-title {
      font-family: 'Orbitron', sans-serif;
      font-size: 0.7rem;
      margin-bottom: 10px;
      text-align: center;
    }

    .captured-pieces {
      display: flex;
      flex-direction: column;
      gap: 5px;
      font-size: 1.5rem;
      text-align: center;
    }

    .game-over {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: rgba(0, 0, 0, 0.95);
      border: 3px solid #f0f;
      border-radius: 15px;
      padding: 40px;
      text-align: center;
      display: none;
      z-index: 100;
    }

    .game-over.show { display: block; }

    .game-over h2 {
      font-family: 'Orbitron', sans-serif;
      font-size: 2rem;
      margin-bottom: 20px;
      background: linear-gradient(90deg, #0ff, #f0f);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
    }

    .backlink {
      position: fixed;
      bottom: 70px;
      left: 50%;
      transform: translateX(-50%);
      font-size: 0.8rem;
      opacity: 0.6;
    }

    .backlink a {
      color: #0ff;
      text-decoration: none;
    }

    .hint {
      position: fixed;
      bottom: 100px;
      left: 50%;
      transform: translateX(-50%);
      font-size: 0.8rem;
      color: #888;
    }

    @media (max-width: 600px) {
      .title { font-size: 1.3rem; }
      .captured-panel { display: none; }
    }
  </style>
</head>
<body>
  <div id="canvas-container"></div>

  <div class="ui">
    <div class="header">
      <h1 class="title">SPACE CHESS</h1>
    </div>

    <div class="turn-indicator white" id="turn">CYAN'S TURN</div>

    <div class="captured-panel left">
      <div class="captured-title" style="color: #0ff;">CYAN CAPTURED</div>
      <div class="captured-pieces" id="white-captured"></div>
    </div>

    <div class="captured-panel right">
      <div class="captured-title" style="color: #f0f;">MAGENTA CAPTURED</div>
      <div class="captured-pieces" id="black-captured"></div>
    </div>

    <div class="controls">
      <button class="ctrl-btn" id="reset-btn">NEW GAME</button>
      <button class="ctrl-btn" id="rotate-btn">ROTATE VIEW</button>
    </div>

    <div class="hint">Click a piece to select, then click destination</div>

    <div class="backlink">
      <a href="https://sloppy.live">ðŸŒŒ Back to sloppy.live</a>
    </div>
  </div>

  <div class="game-over" id="game-over">
    <h2 id="winner-text">CHECKMATE!</h2>
    <p id="winner-desc"></p>
    <button class="ctrl-btn" id="new-game-btn" style="margin-top: 20px;">PLAY AGAIN</button>
  </div>

  <script type="importmap">
  {
    "imports": {
      "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
      "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
    }
  }
  </script>

  <script type="module">
    import * as THREE from 'three';
    import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

    // Scene setup
    const container = document.getElementById('canvas-container');
    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    renderer.toneMapping = THREE.ACESFilmicToneMapping;
    container.appendChild(renderer.domElement);

    camera.position.set(0, 12, 12);
    camera.lookAt(0, 0, 0);

    // Controls
    const controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;
    controls.dampingFactor = 0.05;
    controls.minDistance = 8;
    controls.maxDistance = 25;
    controls.maxPolarAngle = Math.PI / 2.2;

    // Lighting
    const ambientLight = new THREE.AmbientLight(0x222233, 0.5);
    scene.add(ambientLight);

    const cyanLight = new THREE.PointLight(0x00ffff, 1, 30);
    cyanLight.position.set(-5, 10, -5);
    scene.add(cyanLight);

    const magentaLight = new THREE.PointLight(0xff00ff, 1, 30);
    magentaLight.position.set(5, 10, 5);
    scene.add(magentaLight);

    // Stars
    const starsGeometry = new THREE.BufferGeometry();
    const starPositions = [];
    for (let i = 0; i < 2000; i++) {
      starPositions.push(
        (Math.random() - 0.5) * 200,
        (Math.random() - 0.5) * 200,
        (Math.random() - 0.5) * 200
      );
    }
    starsGeometry.setAttribute('position', new THREE.Float32BufferAttribute(starPositions, 3));
    const starsMaterial = new THREE.PointsMaterial({ color: 0xffffff, size: 0.3 });
    const stars = new THREE.Points(starsGeometry, starsMaterial);
    scene.add(stars);

    // Chess board
    const boardGroup = new THREE.Group();
    const TILE_SIZE = 1.2;
    const tiles = [];

    for (let row = 0; row < 8; row++) {
      tiles[row] = [];
      for (let col = 0; col < 8; col++) {
        const isLight = (row + col) % 2 === 0;
        const geometry = new THREE.BoxGeometry(TILE_SIZE, 0.1, TILE_SIZE);
        const material = new THREE.MeshStandardMaterial({
          color: isLight ? 0x1a1a2e : 0x0a0a15,
          emissive: isLight ? 0x0a0a15 : 0x050508,
          metalness: 0.8,
          roughness: 0.3
        });
        const tile = new THREE.Mesh(geometry, material);
        tile.position.set(
          (col - 3.5) * TILE_SIZE,
          0,
          (row - 3.5) * TILE_SIZE
        );
        tile.userData = { row, col, originalColor: material.color.getHex() };
        tiles[row][col] = tile;
        boardGroup.add(tile);
      }
    }

    // Board frame
    const frameGeometry = new THREE.BoxGeometry(TILE_SIZE * 8.4, 0.2, TILE_SIZE * 8.4);
    const frameMaterial = new THREE.MeshStandardMaterial({
      color: 0x1a0a2e,
      emissive: 0x0f0520,
      metalness: 0.9,
      roughness: 0.2
    });
    const frame = new THREE.Mesh(frameGeometry, frameMaterial);
    frame.position.y = -0.1;
    boardGroup.add(frame);

    // Neon edge glow
    const edgeGeometry = new THREE.EdgesGeometry(new THREE.BoxGeometry(TILE_SIZE * 8.2, 0.15, TILE_SIZE * 8.2));
    const edgeMaterial = new THREE.LineBasicMaterial({ color: 0x00ffff });
    const edges = new THREE.LineSegments(edgeGeometry, edgeMaterial);
    edges.position.y = 0.05;
    boardGroup.add(edges);

    scene.add(boardGroup);

    // Piece shapes
    function createPiece(type, isWhite) {
      const group = new THREE.Group();
      const color = isWhite ? 0x00ffff : 0xff00ff;
      const emissive = isWhite ? 0x004444 : 0x440044;

      const material = new THREE.MeshStandardMaterial({
        color: color,
        emissive: emissive,
        metalness: 0.7,
        roughness: 0.2,
        transparent: true,
        opacity: 0.9
      });

      let mesh;

      if (type === 'pawn') {
        const body = new THREE.Mesh(new THREE.CylinderGeometry(0.25, 0.35, 0.6, 16), material);
        const head = new THREE.Mesh(new THREE.SphereGeometry(0.2, 16, 16), material);
        head.position.y = 0.45;
        group.add(body, head);
      } else if (type === 'rook') {
        const body = new THREE.Mesh(new THREE.CylinderGeometry(0.3, 0.4, 0.8, 16), material);
        const top = new THREE.Mesh(new THREE.BoxGeometry(0.5, 0.2, 0.5), material);
        top.position.y = 0.5;
        group.add(body, top);
      } else if (type === 'knight') {
        const body = new THREE.Mesh(new THREE.CylinderGeometry(0.25, 0.35, 0.5, 16), material);
        const head = new THREE.Mesh(new THREE.ConeGeometry(0.25, 0.5, 8), material);
        head.position.y = 0.5;
        head.rotation.x = -0.3;
        head.position.z = 0.1;
        group.add(body, head);
      } else if (type === 'bishop') {
        const body = new THREE.Mesh(new THREE.CylinderGeometry(0.2, 0.35, 0.7, 16), material);
        const top = new THREE.Mesh(new THREE.ConeGeometry(0.2, 0.4, 16), material);
        top.position.y = 0.55;
        group.add(body, top);
      } else if (type === 'queen') {
        const body = new THREE.Mesh(new THREE.CylinderGeometry(0.25, 0.4, 0.9, 16), material);
        const crown = new THREE.Mesh(new THREE.TorusGeometry(0.2, 0.08, 8, 16), material);
        crown.position.y = 0.55;
        crown.rotation.x = Math.PI / 2;
        const gem = new THREE.Mesh(new THREE.OctahedronGeometry(0.15), material);
        gem.position.y = 0.7;
        group.add(body, crown, gem);
      } else if (type === 'king') {
        const body = new THREE.Mesh(new THREE.CylinderGeometry(0.25, 0.4, 1, 16), material);
        const cross1 = new THREE.Mesh(new THREE.BoxGeometry(0.08, 0.3, 0.08), material);
        cross1.position.y = 0.65;
        const cross2 = new THREE.Mesh(new THREE.BoxGeometry(0.2, 0.08, 0.08), material);
        cross2.position.y = 0.7;
        group.add(body, cross1, cross2);
      }

      // Add glow
      const glowMaterial = new THREE.MeshBasicMaterial({
        color: color,
        transparent: true,
        opacity: 0.3
      });
      const glow = new THREE.Mesh(new THREE.SphereGeometry(0.5, 8, 8), glowMaterial);
      glow.position.y = 0.3;
      group.add(glow);

      group.userData.baseY = 0.4;
      group.userData.floatOffset = Math.random() * Math.PI * 2;

      return group;
    }

    // Game state
    const PIECES = { PAWN: 'pawn', ROOK: 'rook', KNIGHT: 'knight', BISHOP: 'bishop', QUEEN: 'queen', KING: 'king' };
    let board = [];
    let pieces3D = [];
    let selectedPiece = null;
    let selectedPos = null;
    let isWhiteTurn = true;
    let whiteCaptured = [];
    let blackCaptured = [];
    let gameOver = false;

    const pieceSymbols = {
      pawn: { white: 'â™™', black: 'â™Ÿ' },
      rook: { white: 'â™–', black: 'â™œ' },
      knight: { white: 'â™˜', black: 'â™ž' },
      bishop: { white: 'â™—', black: 'â™' },
      queen: { white: 'â™•', black: 'â™›' },
      king: { white: 'â™”', black: 'â™š' }
    };

    function initBoard() {
      // Clear existing pieces
      pieces3D.forEach(p => scene.remove(p));
      pieces3D = [];
      whiteCaptured = [];
      blackCaptured = [];
      gameOver = false;
      selectedPiece = null;
      selectedPos = null;
      isWhiteTurn = true;
      updateTurnIndicator();
      updateCaptured();
      document.getElementById('game-over').classList.remove('show');

      // Reset highlights
      for (let r = 0; r < 8; r++) {
        for (let c = 0; c < 8; c++) {
          tiles[r][c].material.emissive.setHex(tiles[r][c].userData.originalColor === 0x1a1a2e ? 0x0a0a15 : 0x050508);
        }
      }

      board = Array(8).fill(null).map(() => Array(8).fill(null));

      // Place pieces
      const backRow = [PIECES.ROOK, PIECES.KNIGHT, PIECES.BISHOP, PIECES.QUEEN, PIECES.KING, PIECES.BISHOP, PIECES.KNIGHT, PIECES.ROOK];

      for (let col = 0; col < 8; col++) {
        // White pieces (bottom)
        placePiece(backRow[col], true, 0, col);
        placePiece(PIECES.PAWN, true, 1, col);

        // Black pieces (top)
        placePiece(backRow[col], false, 7, col);
        placePiece(PIECES.PAWN, false, 6, col);
      }
    }

    function placePiece(type, isWhite, row, col) {
      const piece3D = createPiece(type, isWhite);
      piece3D.position.set(
        (col - 3.5) * TILE_SIZE,
        0.4,
        (row - 3.5) * TILE_SIZE
      );
      piece3D.userData.type = type;
      piece3D.userData.isWhite = isWhite;
      piece3D.userData.row = row;
      piece3D.userData.col = col;

      scene.add(piece3D);
      pieces3D.push(piece3D);
      board[row][col] = { type, isWhite, piece3D };
    }

    function getValidMoves(row, col) {
      const piece = board[row][col];
      if (!piece) return [];

      const moves = [];
      const { type, isWhite } = piece;
      const dir = isWhite ? 1 : -1;

      const addMove = (r, c) => {
        if (r >= 0 && r < 8 && c >= 0 && c < 8) {
          const target = board[r][c];
          if (!target || target.isWhite !== isWhite) {
            moves.push({ row: r, col: c });
          }
        }
      };

      const addLineMoves = (dr, dc) => {
        for (let i = 1; i < 8; i++) {
          const r = row + dr * i;
          const c = col + dc * i;
          if (r < 0 || r >= 8 || c < 0 || c >= 8) break;
          const target = board[r][c];
          if (target) {
            if (target.isWhite !== isWhite) moves.push({ row: r, col: c });
            break;
          }
          moves.push({ row: r, col: c });
        }
      };

      if (type === PIECES.PAWN) {
        // Forward move
        if (!board[row + dir]?.[col]) {
          addMove(row + dir, col);
          // Double move from start
          if ((isWhite && row === 1) || (!isWhite && row === 6)) {
            if (!board[row + dir * 2]?.[col]) {
              addMove(row + dir * 2, col);
            }
          }
        }
        // Captures
        if (board[row + dir]?.[col - 1]?.isWhite !== isWhite && board[row + dir]?.[col - 1]) {
          addMove(row + dir, col - 1);
        }
        if (board[row + dir]?.[col + 1]?.isWhite !== isWhite && board[row + dir]?.[col + 1]) {
          addMove(row + dir, col + 1);
        }
      } else if (type === PIECES.ROOK) {
        addLineMoves(1, 0); addLineMoves(-1, 0);
        addLineMoves(0, 1); addLineMoves(0, -1);
      } else if (type === PIECES.BISHOP) {
        addLineMoves(1, 1); addLineMoves(1, -1);
        addLineMoves(-1, 1); addLineMoves(-1, -1);
      } else if (type === PIECES.QUEEN) {
        addLineMoves(1, 0); addLineMoves(-1, 0);
        addLineMoves(0, 1); addLineMoves(0, -1);
        addLineMoves(1, 1); addLineMoves(1, -1);
        addLineMoves(-1, 1); addLineMoves(-1, -1);
      } else if (type === PIECES.KING) {
        for (let dr = -1; dr <= 1; dr++) {
          for (let dc = -1; dc <= 1; dc++) {
            if (dr !== 0 || dc !== 0) addMove(row + dr, col + dc);
          }
        }
      } else if (type === PIECES.KNIGHT) {
        const knightMoves = [[-2,-1],[-2,1],[-1,-2],[-1,2],[1,-2],[1,2],[2,-1],[2,1]];
        knightMoves.forEach(([dr, dc]) => addMove(row + dr, col + dc));
      }

      return moves;
    }

    function highlightMoves(moves) {
      // Reset all tiles
      for (let r = 0; r < 8; r++) {
        for (let c = 0; c < 8; c++) {
          const isLight = (r + c) % 2 === 0;
          tiles[r][c].material.emissive.setHex(isLight ? 0x0a0a15 : 0x050508);
        }
      }

      // Highlight valid moves
      moves.forEach(({ row, col }) => {
        const hasEnemy = board[row][col] !== null;
        tiles[row][col].material.emissive.setHex(hasEnemy ? 0x440000 : 0x003300);
      });
    }

    function movePiece(fromRow, fromCol, toRow, toCol) {
      const piece = board[fromRow][fromCol];
      const captured = board[toRow][toCol];

      if (captured) {
        scene.remove(captured.piece3D);
        pieces3D = pieces3D.filter(p => p !== captured.piece3D);

        const symbol = pieceSymbols[captured.type][captured.isWhite ? 'white' : 'black'];
        if (piece.isWhite) {
          whiteCaptured.push(symbol);
        } else {
          blackCaptured.push(symbol);
        }
        updateCaptured();

        // Check for king capture (game over)
        if (captured.type === PIECES.KING) {
          endGame(piece.isWhite);
        }
      }

      // Animate move
      const targetX = (toCol - 3.5) * TILE_SIZE;
      const targetZ = (toRow - 3.5) * TILE_SIZE;

      piece.piece3D.userData.row = toRow;
      piece.piece3D.userData.col = toCol;

      // Simple animation
      const startX = piece.piece3D.position.x;
      const startZ = piece.piece3D.position.z;
      let t = 0;
      const animate = () => {
        t += 0.1;
        if (t >= 1) {
          piece.piece3D.position.x = targetX;
          piece.piece3D.position.z = targetZ;
        } else {
          piece.piece3D.position.x = startX + (targetX - startX) * t;
          piece.piece3D.position.z = startZ + (targetZ - startZ) * t;
          piece.piece3D.position.y = 0.4 + Math.sin(t * Math.PI) * 0.5;
          requestAnimationFrame(animate);
        }
      };
      animate();

      // Pawn promotion
      if (piece.type === PIECES.PAWN && (toRow === 7 || toRow === 0)) {
        scene.remove(piece.piece3D);
        pieces3D = pieces3D.filter(p => p !== piece.piece3D);
        const queen3D = createPiece(PIECES.QUEEN, piece.isWhite);
        queen3D.position.set(targetX, 0.4, targetZ);
        queen3D.userData.type = PIECES.QUEEN;
        queen3D.userData.isWhite = piece.isWhite;
        queen3D.userData.row = toRow;
        queen3D.userData.col = toCol;
        scene.add(queen3D);
        pieces3D.push(queen3D);
        piece.type = PIECES.QUEEN;
        piece.piece3D = queen3D;
      }

      board[toRow][toCol] = piece;
      board[fromRow][fromCol] = null;

      isWhiteTurn = !isWhiteTurn;
      updateTurnIndicator();
    }

    function updateTurnIndicator() {
      const indicator = document.getElementById('turn');
      indicator.textContent = isWhiteTurn ? "CYAN'S TURN" : "MAGENTA'S TURN";
      indicator.className = 'turn-indicator ' + (isWhiteTurn ? 'white' : 'black');
    }

    function updateCaptured() {
      document.getElementById('white-captured').innerHTML = whiteCaptured.map(s => `<span>${s}</span>`).join('');
      document.getElementById('black-captured').innerHTML = blackCaptured.map(s => `<span>${s}</span>`).join('');
    }

    function endGame(whiteWins) {
      gameOver = true;
      document.getElementById('winner-text').textContent = whiteWins ? 'CYAN WINS!' : 'MAGENTA WINS!';
      document.getElementById('winner-desc').textContent = 'The king has fallen in the cosmic battlefield.';
      document.getElementById('game-over').classList.add('show');
    }

    // Raycasting for selection
    const raycaster = new THREE.Raycaster();
    const mouse = new THREE.Vector2();

    function onMouseClick(event) {
      if (gameOver) return;

      const rect = renderer.domElement.getBoundingClientRect();
      mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
      mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;

      raycaster.setFromCamera(mouse, camera);

      // Check piece clicks
      const pieceIntersects = raycaster.intersectObjects(pieces3D, true);

      if (pieceIntersects.length > 0) {
        let clickedPiece = pieceIntersects[0].object;
        while (clickedPiece.parent && !clickedPiece.userData.type) {
          clickedPiece = clickedPiece.parent;
        }

        if (clickedPiece.userData.type) {
          const { row, col, isWhite } = clickedPiece.userData;

          if (selectedPiece && selectedPos) {
            // Check if clicking on enemy piece (capture)
            const moves = getValidMoves(selectedPos.row, selectedPos.col);
            const canCapture = moves.some(m => m.row === row && m.col === col);
            if (canCapture && isWhite !== isWhiteTurn) {
              movePiece(selectedPos.row, selectedPos.col, row, col);
              selectedPiece = null;
              selectedPos = null;
              highlightMoves([]);
              return;
            }
          }

          // Select own piece
          if (isWhite === isWhiteTurn) {
            selectedPiece = clickedPiece;
            selectedPos = { row, col };
            const moves = getValidMoves(row, col);
            highlightMoves(moves);
          }
          return;
        }
      }

      // Check tile clicks for movement
      const tileObjects = [];
      for (let r = 0; r < 8; r++) {
        for (let c = 0; c < 8; c++) {
          tileObjects.push(tiles[r][c]);
        }
      }

      const tileIntersects = raycaster.intersectObjects(tileObjects);

      if (tileIntersects.length > 0 && selectedPiece && selectedPos) {
        const tile = tileIntersects[0].object;
        const { row, col } = tile.userData;

        const moves = getValidMoves(selectedPos.row, selectedPos.col);
        const validMove = moves.find(m => m.row === row && m.col === col);

        if (validMove) {
          movePiece(selectedPos.row, selectedPos.col, row, col);
        }

        selectedPiece = null;
        selectedPos = null;
        highlightMoves([]);
      }
    }

    renderer.domElement.addEventListener('click', onMouseClick);

    // Buttons
    document.getElementById('reset-btn').addEventListener('click', initBoard);
    document.getElementById('new-game-btn').addEventListener('click', initBoard);
    document.getElementById('rotate-btn').addEventListener('click', () => {
      const angle = Math.atan2(camera.position.x, camera.position.z) + Math.PI / 2;
      const dist = Math.sqrt(camera.position.x ** 2 + camera.position.z ** 2);
      camera.position.x = Math.sin(angle) * dist;
      camera.position.z = Math.cos(angle) * dist;
    });

    // Animation
    const clock = new THREE.Clock();

    function animate() {
      requestAnimationFrame(animate);
      const time = clock.getElapsedTime();

      // Float pieces
      pieces3D.forEach(piece => {
        const baseY = piece.userData.baseY || 0.4;
        const offset = piece.userData.floatOffset || 0;
        piece.position.y = baseY + Math.sin(time * 2 + offset) * 0.05;
        piece.rotation.y = Math.sin(time * 0.5 + offset) * 0.1;
      });

      // Rotate stars slowly
      stars.rotation.y = time * 0.02;

      // Pulse lights
      cyanLight.intensity = 1 + Math.sin(time * 2) * 0.3;
      magentaLight.intensity = 1 + Math.cos(time * 2) * 0.3;

      controls.update();
      renderer.render(scene, camera);
    }

    // Resize
    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });

    initBoard();
    animate();
  </script>
<script src="/sloppy-header/sloppy-bar.js"></script>
</body>
</html>
