<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Raftcraft — Mini Voxel Sandbox</title>
    <meta
      name="description"
      content="Explore a chill Minecraft-inspired sandbox built with Three.js. Place and mine blocks while drifting the Raft frontier."
    />
    <meta property="og:title" content="Raftcraft — Mini Voxel Sandbox" />
    <meta
      property="og:description"
      content="Custom Three.js voxel playground. Sail, mine, build — no mods, no sounds, just vibes."
    />
    <meta property="og:type" content="website" />
    <meta property="og:url" content="https://app.vibecodedbyx.com/raft/" />
    <meta property="og:image" content="./og-image.svg" />
    <meta name="twitter:card" content="summary_large_image" />
    <meta name="twitter:title" content="Raftcraft — Mini Voxel Sandbox" />
    <meta
      name="twitter:description"
      content="Basic Minecraft-style sandbox in Three.js with handmade textures and raft vibes."
    />
    <meta name="twitter:image" content="./og-image.svg" />
    <link rel="icon" href="./favicon.svg" type="image/svg+xml" />
    <meta name="theme-color" content="#1b2640" />
    <style>
      :root {
        color-scheme: dark;
        font-family: "Inter", "Segoe UI", sans-serif;
        --hud-bg: rgba(10, 16, 32, 0.72);
        --hud-border: rgba(255, 255, 255, 0.14);
        --accent: #ffd34f;
        --text: #f5f6ff;
      }

      *, *::before, *::after {
        box-sizing: border-box;
      }

      body {
        margin: 0;
        min-height: 100vh;
        background: radial-gradient(circle at 20% 0%, rgba(95, 170, 255, 0.24), transparent 60%), #050915;
        color: var(--text);
        overflow: hidden;
      }

      canvas {
        display: block;
      }

      .hud {
        position: fixed;
        top: 16px;
        left: 16px;
        display: grid;
        gap: 12px;
        max-width: min(320px, 70vw);
        padding: 16px;
        border-radius: 16px;
        background: var(--hud-bg);
        border: 1px solid var(--hud-border);
        backdrop-filter: blur(12px);
      }

      .hud h1 {
        margin: 0;
        font-size: 1.2rem;
        letter-spacing: 0.08em;
        text-transform: uppercase;
      }

      .hud p {
        margin: 0;
        font-size: 0.9rem;
        line-height: 1.5;
      }

      .hud a {
        color: var(--accent);
        text-decoration: none;
      }

      .hud a:hover,
      .hud a:focus-visible {
        text-decoration: underline;
        outline: none;
      }

      .controls-grid {
        display: grid;
        gap: 6px;
        font-size: 0.85rem;
        line-height: 1.4;
      }

      .pointer-prompt {
        display: none;
        padding: 8px 10px;
        border-radius: 10px;
        background: rgba(255, 211, 79, 0.18);
        color: var(--accent);
        font-size: 0.85rem;
      }

      #crosshair {
        position: fixed;
        top: 50%;
        left: 50%;
        width: 18px;
        height: 18px;
        margin-left: -9px;
        margin-top: -9px;
        pointer-events: none;
        opacity: 0.7;
      }

      #crosshair::before,
      #crosshair::after {
        content: "";
        position: absolute;
        background: rgba(255, 255, 255, 0.85);
      }

      #crosshair::before {
        width: 2px;
        height: 100%;
        left: 50%;
        transform: translateX(-50%);
        border-radius: 1px;
      }

      #crosshair::after {
        height: 2px;
        width: 100%;
        top: 50%;
        transform: translateY(-50%);
        border-radius: 1px;
      }

      .mobile-hint {
        display: none;
        font-size: 0.8rem;
        color: rgba(245, 246, 255, 0.7);
      }

      @media (max-width: 720px) {
        .hud {
          max-width: 90vw;
          padding: 14px;
        }

        .pointer-prompt {
          display: none !important;
        }

        .mobile-hint {
          display: block;
        }
      }

      .touch-controls {
        position: fixed;
        bottom: 20px;
        right: 20px;
        display: none;
        gap: 12px;
        pointer-events: none;
      }

      .touch-controls button {
        width: 56px;
        height: 56px;
        border-radius: 18px;
        border: 1px solid var(--hud-border);
        background: rgba(10, 16, 32, 0.6);
        color: var(--text);
        font-weight: 600;
        pointer-events: auto;
      }

      .touch-stick {
        position: fixed;
        bottom: 20px;
        left: 20px;
        width: 120px;
        height: 120px;
        border-radius: 50%;
        background: rgba(10, 16, 32, 0.4);
        border: 1px solid rgba(255, 255, 255, 0.1);
        display: none;
        pointer-events: auto;
        touch-action: none;
      }

      .touch-stick::after {
        content: "";
        position: absolute;
        width: 60px;
        height: 60px;
        border-radius: 50%;
        background: rgba(255, 255, 255, 0.18);
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
      }

      @media (hover: none) {
        .touch-controls,
        .touch-stick {
          display: block;
        }

        #crosshair {
          opacity: 0.4;
        }
      }
    </style>
  </head>
  <body>
    <div class="hud" id="hud">
      <h1>Raftcraft</h1>
      <p>
        WASD to move, space to hop, mouse to look. Left-click places a block, right-click removes. Escape releases the
        cursor when you need a breather.
      </p>
      <div class="controls-grid">
        <span><strong>Blocks:</strong> 1 Grass · 2 Stone · 3 Neon</span>
        <span><strong>Build tip:</strong> Aim at a face to anchor. Hold Shift to edge along the raft without slipping.</span>
        <span class="mobile-hint">Use the joystick to move and drag to look. Tap ⊕ to place, ⊝ to mine.</span>
      </div>
      <div class="pointer-prompt" id="pointerPrompt">Click the raft to lock the cursor.</div>
      <a href="https://www.vibecodedbyx.com" target="_blank" rel="noreferrer noopener">⬅ Back to the livestream</a>
    </div>

    <div id="crosshair"></div>

    <div class="touch-stick" id="touchStick"></div>
    <div class="touch-controls" id="touchButtons">
      <button id="placeBtn" aria-label="Place block">⊕</button>
      <button id="breakBtn" aria-label="Break block">⊝</button>
      <button id="jumpBtn" aria-label="Jump">⟰</button>
    </div>

    <script type="importmap">
      {
        "imports": {
          "three": "https://cdn.jsdelivr.net/npm/three@0.167.0/build/three.module.js",
          "three/examples/": "https://cdn.jsdelivr.net/npm/three@0.167.0/examples/"
        }
      }
    </script>

    <script type="module">
      import * as THREE from "three";
      import { PointerLockControls } from "three/examples/jsm/controls/PointerLockControls.js";

      const scene = new THREE.Scene();
      scene.background = new THREE.Color(0x0b132d);
      scene.fog = new THREE.Fog(0x0b132d, 40, 180);

      const camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.1, 500);
      camera.position.set(0, 5, 12);

      const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
      renderer.shadowMap.enabled = true;
      document.body.appendChild(renderer.domElement);

      const ambient = new THREE.HemisphereLight(0x97c8ff, 0x2f180c, 0.75);
      scene.add(ambient);

      const sun = new THREE.DirectionalLight(0xfff1cc, 0.85);
      sun.position.set(-60, 80, 40);
      sun.castShadow = true;
      sun.shadow.mapSize.set(2048, 2048);
      scene.add(sun);

      const controls = new PointerLockControls(camera, renderer.domElement);
      scene.add(controls.getObject());
      controls.getObject().position.set(0, 5, 12);
      const pointerPrompt = document.getElementById("pointerPrompt");

      const worldGroup = new THREE.Group();
      worldGroup.receiveShadow = true;
      scene.add(worldGroup);

      const blockSize = 1;
      const blockMap = new Map();
      const tempVec = new THREE.Vector3();
      const placeIndicator = new THREE.Mesh(
        new THREE.BoxGeometry(blockSize * 1.02, blockSize * 1.02, blockSize * 1.02),
        new THREE.MeshBasicMaterial({ color: 0xffffff, wireframe: true, transparent: true, opacity: 0.35 })
      );
      placeIndicator.visible = false;
      scene.add(placeIndicator);

      const blockTypes = [
        { name: "grass", texture: createBlockTexture(["#78c850", "#4d651f"], ["#8dda5c", "#43601d"]) },
        { name: "stone", texture: createBlockTexture(["#8d8d8d", "#5e5e5e"], ["#a9a9a9", "#4a4a4a"]) },
        { name: "neon", texture: createBlockTexture(["#252147", "#221f5f"], ["#6f4dff", "#4220c9"]) },
      ];
      let currentBlockIndex = 0;

      const blockMaterials = blockTypes.map((type) => {
        const mat = new THREE.MeshLambertMaterial({ map: type.texture });
        mat.transparent = false;
        return mat;
      });

      const blockGeometry = new THREE.BoxGeometry(blockSize, blockSize, blockSize);

      // Build initial terrain
      const extent = 24;
      for (let x = -extent; x <= extent; x++) {
        for (let z = -extent; z <= extent; z++) {
          const height = Math.floor(Math.sin(x * 0.18) * 1.5 + Math.cos(z * 0.22) * 1.3 + 2);
          for (let y = 0; y < height; y++) {
            const typeIndex = y === height - 1 ? 0 : 1;
            createBlock(x, y - 2, z, typeIndex);
          }
        }
      }

      // Scatter neon crystals for ambience
      for (let i = 0; i < 36; i++) {
        const x = Math.floor(THREE.MathUtils.randFloatSpread(extent * 1.6));
        const z = Math.floor(THREE.MathUtils.randFloatSpread(extent * 1.6));
        const columnHeight = columnTop(x, z);
        if (columnHeight !== null) {
          createBlock(x, columnHeight + 1, z, 2);
        }
      }

      const velocity = new THREE.Vector3();
      const direction = new THREE.Vector3();
      const up = new THREE.Vector3(0, 1, 0);
      const clock = new THREE.Clock();

      const keyState = {};
      const walkSpeed = 13;
      const runMultiplier = 1.8;
      let canJump = false;
      let isMobile = matchMedia("(hover: none)").matches;
      if (!isMobile) {
        pointerPrompt.style.display = "block";
      }
      let lookDragActive = false;
      let lastPointerPosition = null;

      document.addEventListener("keydown", (event) => {
        keyState[event.code] = true;
        if (event.code === "Digit1") currentBlockIndex = 0;
        if (event.code === "Digit2") currentBlockIndex = 1;
        if (event.code === "Digit3") currentBlockIndex = 2;
        if (event.code === "KeyC") toggleCreativeFly();
      });

      document.addEventListener("keyup", (event) => {
        keyState[event.code] = false;
      });

      renderer.domElement.addEventListener("click", () => {
        if (!controls.isLocked && !isMobile) {
          controls.lock();
        }
      });

      controls.addEventListener("lock", () => {
        pointerPrompt.style.display = "none";
      });

      controls.addEventListener("unlock", () => {
        pointerPrompt.style.display = "block";
      });

      renderer.domElement.addEventListener("contextmenu", (event) => event.preventDefault());

      // Mouse interactions
      window.addEventListener("mousedown", (event) => {
        if (!controls.isLocked && !isMobile) return;
        if (event.button === 0) {
          placeBlock();
        } else if (event.button === 2) {
          removeBlock();
        }
      });

      // Mobile controls
      const touchStick = document.getElementById("touchStick");
      const placeBtn = document.getElementById("placeBtn");
      const breakBtn = document.getElementById("breakBtn");
      const jumpBtn = document.getElementById("jumpBtn");

      if (isMobile) {
        pointerPrompt.style.display = "none";
        touchStick.addEventListener("touchstart", (event) => {
          const touch = event.touches[0];
          touchStick.dataset.startX = touch.clientX;
          touchStick.dataset.startY = touch.clientY;
          event.preventDefault();
        });

        touchStick.addEventListener("touchmove", (event) => {
          const startX = parseFloat(touchStick.dataset.startX || "0");
          const startY = parseFloat(touchStick.dataset.startY || "0");
          const touch = event.touches[0];
          const dx = (touch.clientX - startX) / 30;
          const dy = (touch.clientY - startY) / 30;
          keyState["KeyW"] = dy < -0.4;
          keyState["KeyS"] = dy > 0.4;
          keyState["KeyA"] = dx < -0.4;
          keyState["KeyD"] = dx > 0.4;
          event.preventDefault();
        });

        touchStick.addEventListener("touchend", () => {
          keyState["KeyW"] = keyState["KeyA"] = keyState["KeyS"] = keyState["KeyD"] = false;
        });

        placeBtn.addEventListener("touchstart", (e) => {
          e.preventDefault();
          placeBlock();
        });
        breakBtn.addEventListener("touchstart", (e) => {
          e.preventDefault();
          removeBlock();
        });
        jumpBtn.addEventListener("touchstart", (e) => {
          e.preventDefault();
          if (canJump) {
            velocity.y = 6.2;
            canJump = false;
          }
        });

        renderer.domElement.addEventListener("touchstart", () => {
          lookDragActive = true;
        });
        renderer.domElement.addEventListener("touchmove", (event) => {
          if (!lookDragActive) return;
          if (!lastPointerPosition) {
            lastPointerPosition = { x: event.touches[0].clientX, y: event.touches[0].clientY };
            return;
          }
          const touch = event.touches[0];
          const movementX = touch.clientX - lastPointerPosition.x;
          const movementY = touch.clientY - lastPointerPosition.y;
          controls.getObject().rotation.y -= movementX * 0.002;
          camera.rotation.x -= movementY * 0.002;
          camera.rotation.x = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, camera.rotation.x));
          lastPointerPosition = { x: touch.clientX, y: touch.clientY };
        });
        renderer.domElement.addEventListener("touchend", () => {
          lookDragActive = false;
          lastPointerPosition = null;
        });
      }

      window.addEventListener("resize", () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      });

      const raycaster = new THREE.Raycaster();
      const pointerCoords = new THREE.Vector2(0, 0);
      const sunOffset = new THREE.Vector3(-40, 60, 20);

      function createBlockTexture(primary, secondary) {
        const canvas = document.createElement("canvas");
        canvas.width = 64;
        canvas.height = 64;
        const ctx = canvas.getContext("2d");
        ctx.fillStyle = primary[0];
        ctx.fillRect(0, 0, 64, 64);
        ctx.fillStyle = primary[1];
        for (let i = 0; i < 220; i++) {
          const size = Math.random() * 6 + 2;
          ctx.globalAlpha = 0.6;
          ctx.fillRect(Math.random() * 64, Math.random() * 64, size, size);
        }
        ctx.globalAlpha = 1;
        ctx.fillStyle = secondary[0];
        ctx.fillRect(0, 0, 64, 10);
        ctx.fillRect(0, 54, 64, 10);
        ctx.fillStyle = secondary[1];
        ctx.fillRect(0, 26, 64, 12);
        const texture = new THREE.CanvasTexture(canvas);
        texture.wrapS = texture.wrapT = THREE.RepeatWrapping;
        texture.colorSpace = THREE.SRGBColorSpace;
        return texture;
      }

      function key(x, y, z) {
        return `${x},${y},${z}`;
      }

      function createBlock(x, y, z, typeIndex = 0) {
        const id = key(x, y, z);
        if (blockMap.has(id)) return;
        const mesh = new THREE.Mesh(blockGeometry, blockMaterials[typeIndex]);
        mesh.position.set(x * blockSize, y * blockSize, z * blockSize);
        mesh.castShadow = true;
        mesh.receiveShadow = true;
        mesh.userData = { typeIndex };
        worldGroup.add(mesh);
        blockMap.set(id, mesh);
      }

      function removeBlockAt(x, y, z) {
        const id = key(x, y, z);
        const mesh = blockMap.get(id);
        if (!mesh) return;
        worldGroup.remove(mesh);
        blockMap.delete(id);
      }

      function columnTop(x, z) {
        for (let y = 30; y >= -30; y--) {
          if (blockMap.has(key(x, y, z))) {
            return y;
          }
        }
        return null;
      }

      function blockAtPoint(point) {
        const x = Math.round(point.x / blockSize);
        const y = Math.round(point.y / blockSize);
        const z = Math.round(point.z / blockSize);
        return { x, y, z, mesh: blockMap.get(key(x, y, z)) };
      }

      function placeBlock() {
        const hit = intersectBlock();
        if (!hit) return;
        const normal = hit.face.normal.clone();
        const point = hit.point.clone().addScaledVector(normal, blockSize / 2);
        const pos = blockAtPoint(point);
        if (!blockMap.has(key(pos.x, pos.y, pos.z))) {
          createBlock(pos.x, pos.y, pos.z, currentBlockIndex);
        }
      }

      function removeBlock() {
        const hit = intersectBlock();
        if (!hit) return;
        const pos = blockAtPoint(hit.point.clone().addScaledVector(hit.face.normal, -blockSize / 2));
        if (pos.mesh) {
          removeBlockAt(pos.x, pos.y, pos.z);
        }
      }

      function intersectBlock() {
        raycaster.setFromCamera(pointerCoords, camera);
        const intersects = raycaster.intersectObjects(worldGroup.children, false);
        if (intersects.length === 0) {
          placeIndicator.visible = false;
          return null;
        }
        const hit = intersects[0];
        const blockPosition = hit.object.position.clone().divideScalar(blockSize);
        placeIndicator.position.copy(blockPosition.multiplyScalar(blockSize));
        placeIndicator.visible = true;
        return hit;
      }

      let creativeFly = false;
      function toggleCreativeFly() {
        creativeFly = !creativeFly;
        if (creativeFly) {
          velocity.y = 0;
        }
      }

      function update() {
        const delta = Math.min(clock.getDelta(), 0.05);
        intersectBlock();

        direction.set(0, 0, 0);
        if (keyState["KeyW"]) direction.z -= 1;
        if (keyState["KeyS"]) direction.z += 1;
        if (keyState["KeyA"]) direction.x -= 1;
        if (keyState["KeyD"]) direction.x += 1;
        direction.normalize();

        const speed = walkSpeed * (keyState["ShiftLeft"] ? runMultiplier : 1);

        if (creativeFly) {
          velocity.x = direction.x * speed * delta * 12;
          velocity.z = direction.z * speed * delta * 12;
          if (keyState["Space"]) camera.position.y += speed * delta * 3;
          if (keyState["ShiftLeft"]) camera.position.y -= speed * delta * 2;
          controls.moveRight(velocity.x * delta);
          controls.moveForward(-velocity.z * delta);
        } else {
          velocity.x -= velocity.x * 10.0 * delta;
          velocity.z -= velocity.z * 10.0 * delta;
          velocity.y -= 30 * delta; // gravity

          if (keyState["KeyW"]) velocity.z -= speed * delta;
          if (keyState["KeyS"]) velocity.z += speed * delta;
          if (keyState["KeyA"]) velocity.x -= speed * delta;
          if (keyState["KeyD"]) velocity.x += speed * delta;

          controls.moveRight(velocity.x * delta);
          controls.moveForward(-velocity.z * delta);
          controls.getObject().position.y += velocity.y * delta;

          if (controls.getObject().position.y < 3) {
            velocity.y = 0;
            controls.getObject().position.y = 3;
            canJump = true;
          }

          if (keyState["Space"] && canJump) {
            velocity.y = 6.2;
            canJump = false;
          }
        }

        sun.position.copy(camera.position).add(sunOffset);

        renderer.render(scene, camera);
        requestAnimationFrame(update);
      }

      update();
    </script>
  </body>
</html>
